<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ASLTypingReference (herdtools7.ASLTypingReference)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">herdtools7</a> &#x00BB; ASLTypingReference</nav><header class="odoc-preamble"><h1 id="asl-typing-reference"><a href="#asl-typing-reference" class="anchor"></a>ASL Typing Reference</h1></header><nav class="odoc-toc"><ul><li><a href="#disclaimer">Disclaimer</a></li><li><a href="#type-nomenclature-">Type nomenclature </a><ul><li><a href="#singular-and-aggregate-types">Singular and Aggregate Types</a><ul><li><a href="#typingdefinition.singulartype">TypingDefinition.SingularType</a></li><li><a href="#typingdefinition.aggregatetype">TypingDefinition.AggregateType</a></li></ul></li><li><a href="#named-and-anonymous-types">Named and Anonymous Types</a><ul><li><a href="#definitions">Definitions</a></li><li><a href="#comments">Comments</a></li><li><a href="#examples">Examples</a></li></ul></li><li><a href="#primitive-and-non-primitive-types">Primitive and Non-primitive types</a><ul><li><a href="#definitions_2">Definitions</a></li><li><a href="#examples_2">Examples</a></li></ul></li><li><a href="#structure-of-a-type">Structure of a type</a><ul><li><a href="#definition">Definition</a></li><li><a href="#examples_3">Examples</a></li></ul></li><li><a href="#domain-of-values-for-types">Domain of Values for Types</a><ul><li><a href="#definition_2">Definition</a></li><li><a href="#examples_4">Examples</a></li></ul></li></ul></li><li><a href="#typing-rules">Typing Rules</a><ul><li><a href="#typing-of-expressions">Typing of Expressions</a><ul><li><a href="#typingrule.lit">TypingRule.Lit</a><ul><li><a href="#rule">Rule</a></li><li><a href="#examples_5">Examples</a></li></ul></li><li><a href="#typingrule.typedexpr">TypingRule.TypedExpr</a><ul><li><a href="#rule_2">Rule</a></li><li><a href="#examples_6">Examples</a></li></ul></li><li><a href="#typingrule.elocalvarconstant">TypingRule.ELocalVarConstant</a><ul><li><a href="#rule_3">Rule</a></li><li><a href="#examples_7">Examples</a></li></ul></li><li><a href="#typingrule.elocalvar">TypingRule.ELocalVar</a><ul><li><a href="#rule_4">Rule</a></li><li><a href="#examples_8">Examples</a></li></ul></li><li><a href="#typingrule.eglobalvarconstantval">TypingRule.EGlobalVarConstantVal</a><ul><li><a href="#rule_5">Rule</a></li><li><a href="#examples_9">Examples</a></li></ul></li><li><a href="#typingrule.eglobalvar">TypingRule.EGlobalVar</a><ul><li><a href="#rule_6">Rule</a></li><li><a href="#examples_10">Examples</a></li></ul></li><li><a href="#typingrule.eundefident">TypingRule.EUndefIdent</a><ul><li><a href="#rule_7">Rule</a></li><li><a href="#examples_11">Examples</a></li></ul></li><li><a href="#typingrule.binop">TypingRule.Binop</a><ul><li><a href="#rule_8">Rule</a></li><li><a href="#examples_12">Examples</a></li></ul></li><li><a href="#typingrule.unop">TypingRule.Unop</a><ul><li><a href="#rule_9">Rule</a></li><li><a href="#examples_13">Examples</a></li></ul></li><li><a href="#typingrule.econd">TypingRule.ECond</a><ul><li><a href="#rule_10">Rule</a></li><li><a href="#examples_14">Examples</a></li></ul></li><li><a href="#typingrule.etuple">TypingRule.ETuple</a><ul><li><a href="#rule_11">Rule</a></li><li><a href="#examples_15">Examples</a></li></ul></li><li><a href="#typingrule.econcatempty">TypingRule.EConcatEmpty</a><ul><li><a href="#rule_12">Rule</a></li><li><a href="#examples_16">Examples</a></li></ul></li><li><a href="#typingrule.econcat">TypingRule.EConcat</a><ul><li><a href="#rule_13">Rule</a></li><li><a href="#examples_17">Examples</a></li></ul></li><li><a href="#typingrule.erecordnotarecord">TypingRule.ERecordNotARecord</a><ul><li><a href="#rule_14">Rule</a></li><li><a href="#examples_18">Examples</a></li></ul></li><li><a href="#typingrule.erecordmissingfield">TypingRule.ERecordMissingField</a><ul><li><a href="#rule_15">Rule</a></li><li><a href="#examples_19">Examples</a></li></ul></li><li><a href="#typingrule.erecord">TypingRule.ERecord</a><ul><li><a href="#rule_16">Rule</a></li><li><a href="#examples_20">Examples</a></li></ul></li><li><a href="#typingrule.ecall">TypingRule.ECall</a><ul><li><a href="#rule_17">Rule</a></li><li><a href="#examples_21">Examples</a></li></ul></li><li><a href="#typingrule.eunknown">TypingRule.EUnknown</a><ul><li><a href="#rule_18">Rule</a></li><li><a href="#examples_22">Examples</a></li></ul></li><li><a href="#typingrule.eslice">TypingRule.ESlice</a><ul><li><a href="#rule_19">Rule</a></li><li><a href="#examples_23">Examples</a></li></ul></li><li><a href="#typingrule.egetarray">TypingRule.EGetArray</a><ul><li><a href="#rule_20">Rule</a></li><li><a href="#examples_24">Examples</a></li></ul></li><li><a href="#typingrule.egetrecordfield">TypingRule.EGetRecordField</a><ul><li><a href="#rule_21">Rule</a></li><li><a href="#examples_25">Examples</a></li></ul></li><li><a href="#typingrule.egetbadrecordfield">TypingRule.EGetBadRecordField</a><ul><li><a href="#rule_22">Rule</a></li><li><a href="#examples_26">Examples</a></li></ul></li><li><a href="#typingrule.egetbadbitfield">TypingRule.EGetBadBitField</a><ul><li><a href="#rule_23">Rule</a></li><li><a href="#examples_27">Examples</a></li></ul></li><li><a href="#typingrule.egetbadfield">TypingRule.EGetBadField</a><ul><li><a href="#rule_24">Rule</a></li><li><a href="#examples_28">Examples</a></li></ul></li><li><a href="#typingrule.egetbitfield">TypingRule.EGetBitField</a><ul><li><a href="#rule_25">Rule</a></li><li><a href="#examples_29">Examples</a></li></ul></li><li><a href="#typingrule.egetbitfieldnested">TypingRule.EGetBitFieldNested</a><ul><li><a href="#rule_26">Rule</a></li><li><a href="#examples_30">Examples</a></li></ul></li><li><a href="#typingrule.egetbitfieldtyped">TypingRule.EGetBitFieldTyped</a><ul><li><a href="#rule_27">Rule</a></li><li><a href="#examples_31">Examples</a></li></ul></li><li><a href="#typingrule.egetbitfields">TypingRule.EGetBitFields</a><ul><li><a href="#rule_28">Rule</a></li><li><a href="#examples_32">Examples</a></li></ul></li><li><a href="#typingrule.epattern">TypingRule.EPattern</a><ul><li><a href="#rule_29">Rule</a></li><li><a href="#examples_33">Examples</a></li></ul></li></ul></li><li><a href="#typing-of-left-hand-side-expressions">Typing of Left-Hand-Side Expressions</a><ul><li><a href="#typingrule.leignore">TypingRule.LEIgnore</a><ul><li><a href="#rule_30">Rule</a></li><li><a href="#examples_34">Examples</a></li></ul></li><li><a href="#typingrule.lelocalvar">TypingRule.LELocalVar</a><ul><li><a href="#rule_31">Rule</a></li><li><a href="#examples_35">Examples</a></li></ul></li><li><a href="#typingrule.leglobalvar">TypingRule.LEGlobalVar</a><ul><li><a href="#rule_32">Rule</a></li><li><a href="#examples_36">Examples</a></li></ul></li><li><a href="#typingrule.letuple">TypingRule.LETuple</a><ul><li><a href="#rule_33">Rule</a></li><li><a href="#examples_37">Examples</a></li></ul></li><li><a href="#typingrule.leslice">TypingRule.LESlice</a><ul><li><a href="#rule_34">Rule</a></li><li><a href="#examples_38">Examples</a></li></ul></li><li><a href="#typingrule.lesetarray">TypingRule.LESetArray</a><ul><li><a href="#rule_35">Rule</a></li><li><a href="#examples_39">Examples</a></li></ul></li><li><a href="#typingrule.lesetbadrecordfield">TypingRule.LESetBadRecordField</a><ul><li><a href="#rule_36">Rule</a></li><li><a href="#examples_40">Examples</a></li></ul></li><li><a href="#typingrule.lesetrecordfield">TypingRule.LESetRecordField</a><ul><li><a href="#rule_37">Rule</a></li><li><a href="#examples_41">Examples</a></li></ul></li><li><a href="#typingrule.lesetbadbitfield">TypingRule.LESetBadBitField</a><ul><li><a href="#rule_38">Rule</a></li><li><a href="#examples_42">Examples</a></li></ul></li><li><a href="#typingrule.lesetbitfield">TypingRule.LESetBitField</a><ul><li><a href="#rule_39">Rule</a></li><li><a href="#examples_43">Examples</a></li></ul></li><li><a href="#typingrule.lesetbitfieldnested">TypingRule.LESetBitFieldNested</a><ul><li><a href="#rule_40">Rule</a></li><li><a href="#examples_44">Examples</a></li></ul></li><li><a href="#typingrule.lesetbitfieldtyped">TypingRule.LESetBitFieldTyped</a><ul><li><a href="#rule_41">Rule</a></li><li><a href="#examples_45">Examples</a></li></ul></li><li><a href="#typingrule.lesetbadfield">TypingRule.LESetBadField</a><ul><li><a href="#rule_42">Rule</a></li><li><a href="#examples_46">Examples</a></li></ul></li><li><a href="#typingrule.lesetfields">TypingRule.LESetFields</a><ul><li><a href="#rule_43">Rule</a></li><li><a href="#examples_47">Examples</a></li></ul></li><li><a href="#typingrule.leconcat">TypingRule.LEConcat</a><ul><li><a href="#rule_44">Rule</a></li><li><a href="#examples_48">Examples</a></li></ul></li></ul></li><li><a href="#typing-of-local-declarations">Typing of Local Declarations</a><ul><li><a href="#typingrule.ldignorenone">TypingRule.LDIgnoreNone</a><ul><li><a href="#rule_45">Rule</a></li><li><a href="#examples_49">Examples</a></li></ul></li><li><a href="#typingrule.ldignoresome">TypingRule.LDIgnoreSome</a><ul><li><a href="#rule_46">Rule</a></li><li><a href="#examples_50">Examples</a></li></ul></li><li><a href="#typingrule.ldvar">TypingRule.LDVar</a><ul><li><a href="#rule_47">Rule</a></li><li><a href="#examples_51">Examples</a></li></ul></li><li><a href="#typingrule.lduninitialisedtypedtuple">TypingRule.LDUninitialisedTypedTuple</a><ul><li><a href="#rule_48">Rule</a></li><li><a href="#examples_52">Examples</a></li></ul></li><li><a href="#typingrule.ldtuple">TypingRule.LDTuple</a><ul><li><a href="#rule_49">Rule</a></li><li><a href="#examples_53">Examples</a></li></ul></li><li><a href="#typingrule.ldtypedtuple">TypingRule.LDTypedTuple</a><ul><li><a href="#rule_50">Rule</a></li><li><a href="#examples_54">Examples</a></li></ul></li></ul></li><li><a href="#typing-of-statements">Typing of Statements</a><ul><li><a href="#typingrule.spass">TypingRule.SPass</a><ul><li><a href="#rule_51">Rule</a></li><li><a href="#examples_55">Examples</a></li></ul></li><li><a href="#typingrule.sthen">TypingRule.SThen</a><ul><li><a href="#rule_52">Rule</a></li><li><a href="#examples_56">Examples</a></li></ul></li><li><a href="#typingrule.sassign">TypingRule.SAssign</a><ul><li><a href="#rule_53">Rule</a></li><li><a href="#examples_57">Examples</a></li></ul></li><li><a href="#typingrule.scall">TypingRule.SCall</a><ul><li><a href="#rule_54">Rule</a></li><li><a href="#examples_58">Examples</a></li></ul></li><li><a href="#typingrule.sreturnnone">TypingRule.SReturnNone</a><ul><li><a href="#rule_55">Rule</a></li><li><a href="#examples_59">Examples</a></li></ul></li><li><a href="#typingrule.sreturnone">TypingRule.SReturnOne</a><ul><li><a href="#rule_56">Rule</a></li><li><a href="#examples_60">Examples</a></li></ul></li><li><a href="#typingrule.sreturnsome">TypingRule.SReturnSome</a><ul><li><a href="#rule_57">Rule</a></li><li><a href="#examples_61">Examples</a></li></ul></li><li><a href="#typingrule.scond">TypingRule.SCond</a><ul><li><a href="#rule_58">Rule</a></li><li><a href="#examples_62">Examples</a></li></ul></li><li><a href="#typingrule.scase">TypingRule.SCase</a><ul><li><a href="#rule_59">Rule</a></li><li><a href="#examples_63">Examples</a></li></ul></li><li><a href="#typingrule.sassert">TypingRule.SAssert</a><ul><li><a href="#rule_60">Rule</a></li><li><a href="#examples_64">Examples</a></li></ul></li><li><a href="#typingrule.swhile">TypingRule.SWhile</a><ul><li><a href="#rule_61">Rule</a></li><li><a href="#examples_65">Examples</a></li></ul></li><li><a href="#typingrule.srepeat">TypingRule.SRepeat</a><ul><li><a href="#rule_62">Rule</a></li><li><a href="#examples_66">Examples</a></li></ul></li><li><a href="#typingrule.sfor">TypingRule.SFor</a><ul><li><a href="#rule_63">Rule</a></li><li><a href="#examples_67">Examples</a></li></ul></li><li><a href="#typingrule.sdeclsome">TypingRule.SDeclSome</a><ul><li><a href="#rule_64">Rule</a></li><li><a href="#examples_68">Examples</a></li></ul></li><li><a href="#typingrule.sdeclnone">TypingRule.SDeclNone</a><ul><li><a href="#rule_65">Rule</a></li><li><a href="#examples_69">Examples</a></li></ul></li><li><a href="#typingrule.sthrownone">TypingRule.SThrowNone</a><ul><li><a href="#rule_66">Rule</a></li><li><a href="#examples_70">Examples</a></li></ul></li><li><a href="#typingrule.sthrowsome">TypingRule.SThrowSome</a><ul><li><a href="#rule_67">Rule</a></li><li><a href="#examples_71">Examples</a></li></ul></li><li><a href="#typingrule.stry">TypingRule.STry</a><ul><li><a href="#rule_68">Rule</a></li><li><a href="#examples_72">Examples</a></li></ul></li></ul></li><li><a href="#typing-of-slices">Typing of Slices</a><ul><li><a href="#typingrule.slicelength">TypingRule.SliceLength</a><ul><li><a href="#rule_69">Rule</a></li><li><a href="#examples_73">Examples</a></li></ul></li><li><a href="#typingrule.slicesingle">TypingRule.SliceSingle</a><ul><li><a href="#rule_70">Rule</a></li><li><a href="#comments_2">Comments</a></li><li><a href="#examples_74">Examples</a></li></ul></li><li><a href="#typingrule.slicerange">TypingRule.SliceRange</a><ul><li><a href="#rule_71">Rule</a></li><li><a href="#comments_3">Comments</a></li><li><a href="#examples_75">Examples</a></li></ul></li><li><a href="#typingrule.slicestar">TypingRule.SliceStar</a><ul><li><a href="#rule_72">Rule</a></li><li><a href="#comments_4">Comments</a></li><li><a href="#examples_76">Examples</a></li></ul></li></ul></li><li><a href="#typing-of-patterns">Typing of Patterns</a><ul><li><a href="#typingrule.pall">TypingRule.PAll</a><ul><li><a href="#rule_73">Rule</a></li><li><a href="#examples_77">Examples</a></li></ul></li><li><a href="#typingrule.pany">TypingRule.PAny</a><ul><li><a href="#rule_74">Rule</a></li><li><a href="#examples_78">Examples</a></li></ul></li><li><a href="#typingrule.pnot">TypingRule.PNot</a><ul><li><a href="#rule_75">Rule</a></li><li><a href="#examples_79">Examples</a></li></ul></li><li><a href="#typingrule.psingle">TypingRule.PSingle</a><ul><li><a href="#rule_76">Rule</a></li><li><a href="#examples_80">Examples</a></li></ul></li><li><a href="#typingrule.pgeq">TypingRule.PGeq</a><ul><li><a href="#rule_77">Rule</a></li><li><a href="#examples_81">Examples</a></li></ul></li><li><a href="#typingrule.pleq">TypingRule.PLeq</a><ul><li><a href="#rule_78">Rule</a></li><li><a href="#examples_82">Examples</a></li></ul></li><li><a href="#typingrule.prange">TypingRule.PRange</a><ul><li><a href="#rule_79">Rule</a></li><li><a href="#examples_83">Examples</a></li></ul></li><li><a href="#typingrule.pmask">TypingRule.PMask</a><ul><li><a href="#rule_80">Rule</a></li><li><a href="#examples_84">Examples</a></li></ul></li><li><a href="#typingrule.ptuplebadarity">TypingRule.PTupleBadArity</a><ul><li><a href="#rule_81">Rule</a></li><li><a href="#examples_85">Examples</a></li></ul></li><li><a href="#typingrule.ptuple">TypingRule.PTuple</a><ul><li><a href="#rule_82">Rule</a></li><li><a href="#examples_86">Examples</a></li></ul></li><li><a href="#typingrule.ptupleconflict">TypingRule.PTupleConflict</a><ul><li><a href="#rule_83">Rule</a></li><li><a href="#examples_87">Examples</a></li></ul></li></ul></li><li><a href="#typing-of-blocks">Typing of Blocks</a><ul><li><a href="#typingrule.block">TypingRule.Block</a><ul><li><a href="#rule_84">Rule</a></li><li><a href="#comments_5">Comments</a></li><li><a href="#examples_88">Examples</a></li></ul></li></ul></li><li><a href="#typing-of-catchers">Typing of Catchers</a><ul><li><a href="#typingrule.catchernone">TypingRule.CatcherNone</a><ul><li><a href="#rule_85">Rule</a></li><li><a href="#examples_89">Examples</a></li></ul></li><li><a href="#typingrule.catchersome">TypingRule.CatcherSome</a><ul><li><a href="#rule_86">Rule</a></li><li><a href="#examples_90">Examples</a></li></ul></li></ul></li><li><a href="#typing-of-function-calls">Typing of Function Calls</a><ul><li><a href="#typingrule.fcallbadarity">TypingRule.FCallBadArity</a><ul><li><a href="#rule_87">Rule</a></li><li><a href="#examples_91">Examples</a></li></ul></li><li><a href="#typingrule.fcallgetter">TypingRule.FCallGetter</a><ul><li><a href="#rule_88">Rule</a></li><li><a href="#examples_92">Examples</a></li></ul></li><li><a href="#typingrule.fcallsetter">TypingRule.FCallSetter</a><ul><li><a href="#rule_89">Rule</a></li><li><a href="#examples_93">Examples</a></li></ul></li><li><a href="#typingrule.fcallmismatch">TypingRule.FCallMismatch</a><ul><li><a href="#rule_90">Rule</a></li><li><a href="#examples_94">Examples</a></li></ul></li></ul></li><li><a href="#typing-of-functions">Typing of Functions</a><ul><li><a href="#typingrule.func">TypingRule.Func</a><ul><li><a href="#rule_91">Rule</a></li><li><a href="#examples_95">Examples</a></li></ul></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="disclaimer"><a href="#disclaimer" class="anchor"></a>Disclaimer</h2><p>This material covers both ASLv0 (viz, the existing ASL pseudocode language which appears in the Arm Architecture Reference Manual) and ASLv1, a new, experimental, and as yet unreleased version of ASL.</p><p>This material is work in progress, more precisely at pre-Alpha quality as per Arm’s quality standards. In particular, this means that it would be premature to base any production tool development on this material.</p><p>However, any feedback, question, query and feature request would be most welcome; those can be sent to Arm’s Architecture Formal Team Lead Jade Alglave &lt;jade.alglave@arm.com&gt; or by raising issues or PRs to the herdtools7 github repository.</p><h2 id="type-nomenclature-"><a href="#type-nomenclature-" class="anchor"></a>Type nomenclature </h2><h3 id="singular-and-aggregate-types"><a href="#singular-and-aggregate-types" class="anchor"></a>Singular and Aggregate Types</h3><p>All types are either singular or aggregate.</p><h4 id="typingdefinition.singulartype"><a href="#typingdefinition.singulartype" class="anchor"></a>TypingDefinition.SingularType</h4><p>The builtin singular types are:</p><ul><li>integer;</li><li>real;</li><li>string;</li><li>boolean;</li><li>bit;</li><li>bits;</li><li>enumeration.</li></ul><h4 id="typingdefinition.aggregatetype"><a href="#typingdefinition.aggregatetype" class="anchor"></a>TypingDefinition.AggregateType</h4><p>The builtin aggregate types are:</p><ul><li>tuple;</li><li>array;</li><li>record;</li><li>exception.</li></ul><h3 id="named-and-anonymous-types"><a href="#named-and-anonymous-types" class="anchor"></a>Named and Anonymous Types</h3><h4 id="definitions"><a href="#definitions" class="anchor"></a>Definitions</h4><p>All types are either:</p><ul><li>named types: those which are declared using the type syntax;</li><li>or anonymous types: those which are not declared using the type syntax.</li></ul><h4 id="comments"><a href="#comments" class="anchor"></a>Comments</h4><p>A named type is singular if it has the structure of a singular type, otherwise it is aggregate.</p><h4 id="examples"><a href="#examples" class="anchor"></a>Examples</h4><h3 id="primitive-and-non-primitive-types"><a href="#primitive-and-non-primitive-types" class="anchor"></a>Primitive and Non-primitive types</h3><h4 id="definitions_2"><a href="#definitions_2" class="anchor"></a>Definitions</h4><p>All types are either:</p><ul><li>primitive types: those which only uses the builtin types;</li><li>or non-primitive types: those which are named types or which make use of named types.</li></ul><h4 id="examples_2"><a href="#examples_2" class="anchor"></a>Examples</h4><h3 id="structure-of-a-type"><a href="#structure-of-a-type" class="anchor"></a>Structure of a type</h3><h4 id="definition"><a href="#definition" class="anchor"></a>Definition</h4><p>The structure of a type is the primitive type it is equivalent to such that it can hold the same values.</p><h4 id="examples_3"><a href="#examples_3" class="anchor"></a>Examples</h4><p><code>type T1 of integer;</code> is the named type <code>T1</code> whose structure is integer.</p><p><code>type T2 of (integer, T1);</code> is the named type <code>T2</code> whose structure is (integer, integer). In this example, <code>(integer, T1)</code> is non-primitive since it uses <code>T1</code>.</p><p>In this example: <code>var x: T1;</code> the type of <code>x</code> is the named (hence non-primitive) type <code>T1</code>, whose structure is <code>integer</code>.</p><p>In this example: <code>var y: integer;</code> the type of y is the anonymous primitive type <code>integer</code>.</p><p>In this example: <code>var z: (integer, T1);</code> the type of z is the anonymous non-primitive type `(integer, T1)` whose structure is `(integer, integer)`.</p><h3 id="domain-of-values-for-types"><a href="#domain-of-values-for-types" class="anchor"></a>Domain of Values for Types</h3><h4 id="definition_2"><a href="#definition_2" class="anchor"></a>Definition</h4><p>The domain of a type is the set of values which storage elements of that type may hold.</p><h4 id="examples_4"><a href="#examples_4" class="anchor"></a>Examples</h4><p>The domain of <code>integer</code> is the infinite set of all integers.</p><p>The domain of <code>bits(1)</code> is the set <code>{‘1’, ‘0’}</code>.</p><p>The domain of <code>integer {2,16}</code> is the set containing the integers <code>2</code> and <code>16</code>.</p><p>The domain of <code>bits({2,16})</code> is the set containing all two bit and all sixteen bit values.</p><h2 id="typing-rules"><a href="#typing-rules" class="anchor"></a>Typing Rules</h2><p>Typing a program is typing its main function. Constructively, typing a program requires following its Abstract Syntax Tree and typing each of its components.</p><p>Formally, the types of a program are given by applying a set of annotate_&lt;object&gt; functions. Each annotate_&lt;object&gt; function describes how to annotate a specific object, as follows.</p><ul><li><code>annotate_expr</code> annotates expressions;</li><li><code>annotate_slices</code> annotates slices;</li><li><code>annotate_pattern</code> annotates pattern;</li><li><code>annotate_local_decl_item</code> annotates local declarations;</li><li><code>annotate_lexpr</code> annotates left-hand sides of assignments;</li><li><code>annotate_stmt</code> annotates statements;</li><li><code>annotate_block</code> annotates blocks;</li><li><code>annotate_catcher</code> annotates catchers;</li><li><code>annotate_call</code> annotates functions calls;</li><li><code>annotate_func</code> annotates functions.</li></ul><h3 id="typing-of-expressions"><a href="#typing-of-expressions" class="anchor"></a>Typing of Expressions</h3><p><code>annotate_expr</code> specifies how to annotate an expression <code>e</code> in an environment <code>env</code>. Formally, the result of annotating the expression <code>e</code> in <code>env</code> is <code>t,new_e</code> and one of the following applies:</p><h4 id="typingrule.lit"><a href="#typingrule.lit" class="anchor"></a>TypingRule.Lit</h4><h5 id="rule"><a href="#rule" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> is a Literal <code>v</code>;</li><li><code>t</code> is the type of <code>v</code>;</li><li><code>new_e</code> is <code>e</code>.</li></ul><h5 id="examples_5"><a href="#examples_5" class="anchor"></a>Examples</h5><h4 id="typingrule.typedexpr"><a href="#typingrule.typedexpr" class="anchor"></a>TypingRule.TypedExpr</h4><h5 id="rule_2"><a href="#rule_2" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> is a typed expression <code>(e',t')</code>;</li><li><code>t'',e''</code> is the result of annotating <code>e'</code> in <code>env</code>;</li><li>One of the following applies:</li><li>All of the following applies:</li><li><code>t''</code> is a structural subtype of <code>t'</code> in <code>env</code>;</li><li><code>t''</code> is a domain subtype of <code>t'</code> in <code>env</code>;</li><li><code>t</code> is <code>t'</code>;</li><li><code>new_e</code> is <code>e''</code>.</li><li>All of the following applies:</li><li><code>t''</code> is a structural subtype of <code>t'</code> in <code>env</code>;</li><li><code>t''</code> is not a domain subtype of <code>t'</code> in <code>env</code>;</li><li>an execution-time check that the expression evaluates to a value in the domain of the required type is required.</li><li>All of the following applies:</li><li><code>t''</code> is not a structural subtype of <code>t'</code> in <code>env</code>;</li><li>a &quot;ConflictingTypes&quot; error is raised.</li></ul><h5 id="examples_6"><a href="#examples_6" class="anchor"></a>Examples</h5><h4 id="typingrule.elocalvarconstant"><a href="#typingrule.elocalvarconstant" class="anchor"></a>TypingRule.ELocalVarConstant</h4><h5 id="rule_3"><a href="#rule_3" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> is a variable <code>x</code>;</li><li><code>x</code> maps to a type <code>ty</code> in the <code>storage_types</code> of the local environment given by <code>env</code>;</li><li><code>x</code> maps to a local constant <code>v</code>;</li><li><code>t</code> is <code>ty</code>;</li><li><code>new_e</code> is the Literal <code>v</code>.</li></ul><h5 id="examples_7"><a href="#examples_7" class="anchor"></a>Examples</h5><h4 id="typingrule.elocalvar"><a href="#typingrule.elocalvar" class="anchor"></a>TypingRule.ELocalVar</h4><h5 id="rule_4"><a href="#rule_4" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> is a variable <code>x</code>;</li><li><code>x</code> maps to a type <code>ty</code> in the <code>storage_types</code> of the local environment given by <code>env</code>;</li><li><code>x</code> does not map to a local constant;</li><li><code>t</code> is <code>ty</code>;</li><li><code>new_e</code> is <code>e</code>.</li></ul><h5 id="examples_8"><a href="#examples_8" class="anchor"></a>Examples</h5><h4 id="typingrule.eglobalvarconstantval"><a href="#typingrule.eglobalvarconstantval" class="anchor"></a>TypingRule.EGlobalVarConstantVal</h4><h5 id="rule_5"><a href="#rule_5" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> is a variable <code>x</code>;</li><li><code>x</code> maps to a type <code>ty</code> in the <code>constant_values</code> of the global environment given by <code>env</code>;</li><li><code>x</code> maps to a global constant;</li><li><code>x</code> maps to a value <code>v</code>;</li><li><code>t</code> is <code>ty</code>;</li><li><code>new_e</code> is <code>E_Literal v</code>.</li></ul><h5 id="examples_9"><a href="#examples_9" class="anchor"></a>Examples</h5><h4 id="typingrule.eglobalvar"><a href="#typingrule.eglobalvar" class="anchor"></a>TypingRule.EGlobalVar</h4><h5 id="rule_6"><a href="#rule_6" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> is a variable <code>x</code>;</li><li><code>x</code> maps to a type <code>ty</code> in the <code>constant_values</code> of the global environment given by <code>env</code>;</li><li><code>x</code> does not map to a global constant;</li><li><code>t</code> is <code>ty</code>;</li><li><code>new_e</code> is <code>e</code>.</li></ul><h5 id="examples_10"><a href="#examples_10" class="anchor"></a>Examples</h5><h4 id="typingrule.eundefident"><a href="#typingrule.eundefident" class="anchor"></a>TypingRule.EUndefIdent</h4><h5 id="rule_7"><a href="#rule_7" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> is a variable <code>x</code>;</li><li><code>x</code> is not bound in <code>env</code>;</li><li>an error &quot;Undefined Identifier&quot; is raised.</li></ul><h5 id="examples_11"><a href="#examples_11" class="anchor"></a>Examples</h5><h4 id="typingrule.binop"><a href="#typingrule.binop" class="anchor"></a>TypingRule.Binop</h4><h5 id="rule_8"><a href="#rule_8" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a binary operation <code>op</code> over two expressions <code>e1</code> and <code>e2</code>;</li><li><code>t1,e1'</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t2,e2'</code> is the result of annotating <code>e2</code> in <code>env</code>;</li><li><code>t</code> is the result of checking compatibility of <code>op</code> with <code>t1</code> and <code>t2</code>;</li><li><code>new_e</code> denotes <code>op</code> over <code>e1'</code> and <code>e2'</code>.</li></ul><h5 id="examples_12"><a href="#examples_12" class="anchor"></a>Examples</h5><h4 id="typingrule.unop"><a href="#typingrule.unop" class="anchor"></a>TypingRule.Unop</h4><h5 id="rule_9"><a href="#rule_9" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a unary operation <code>op</code> over an expression <code>e'</code>;</li><li><code>t'',e''</code> is the result of annotating <code>e'</code> in <code>env</code>;</li><li><code>t</code> is the result of checking compatibility of <code>op</code> with <code>t''</code>;</li><li><code>new_e</code> denotes <code>op</code> over <code>e''</code>.</li></ul><h5 id="examples_13"><a href="#examples_13" class="anchor"></a>Examples</h5><h4 id="typingrule.econd"><a href="#typingrule.econd" class="anchor"></a>TypingRule.ECond</h4><h5 id="rule_10"><a href="#rule_10" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a condition <code>e_cond</code> with two options <code>e_true</code> and <code>e_false</code>;</li><li><code>t_cond, e'_cond</code> is the result of annotating <code>e_cond</code> in <code>env</code>;</li><li><code>t_true, e'_true</code> is the result of annotating <code>e_true</code> in <code>env</code>;</li><li><code>t_false, e'_false</code> is the result of annotating <code>e_false</code> in <code>env</code>;</li><li>One of the following applies:</li><li>All of the following applies:</li><li><code>t</code> is the lowest common ancestor of <code>t_true</code> and <code>t_false</code>;</li><li><code>new_e</code> is the condition <code>e'_cond</code> with two options <code>e'_true</code> and <code>e'_false</code>.</li><li>All of the following applies:</li><li>there is no lowest common ancestor of <code>t_true</code> and <code>t_false</code>;</li><li>an error &quot;Unreconciliable Types&quot; is raised.</li></ul><h5 id="examples_14"><a href="#examples_14" class="anchor"></a>Examples</h5><h4 id="typingrule.etuple"><a href="#typingrule.etuple" class="anchor"></a>TypingRule.ETuple</h4><h5 id="rule_11"><a href="#rule_11" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a tuple <code>li</code>;</li><li><code>ts, es</code> is the result of annotating in <code>env</code> each expression in <code>li</code>;</li><li><code>t</code> is <code>ts</code>;</li><li><code>new_e</code> is <code>es</code>.</li></ul><h5 id="examples_15"><a href="#examples_15" class="anchor"></a>Examples</h5><h4 id="typingrule.econcatempty"><a href="#typingrule.econcatempty" class="anchor"></a>TypingRule.EConcatEmpty</h4><h5 id="rule_12"><a href="#rule_12" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the empty concatenation;</li><li><code>t</code> is <code>bits(0)</code>;</li><li><code>new_e</code> is <code>e</code>.</li></ul><h5 id="examples_16"><a href="#examples_16" class="anchor"></a>Examples</h5><h4 id="typingrule.econcat"><a href="#typingrule.econcat" class="anchor"></a>TypingRule.EConcat</h4><h5 id="rule_13"><a href="#rule_13" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the concatenation of a non-empty list of expressions <code>li</code>;</li><li><code>ts, es</code> is the result of annotating <code>li</code> in <code>env</code>;</li><li><code>w</code> is the sum of the widths of the bitvector types <code>ts</code>;</li><li><code>t</code> is <code>bits(w)</code>;</li><li><code>new_e</code> is <code>es</code>.</li></ul><h5 id="examples_17"><a href="#examples_17" class="anchor"></a>Examples</h5><h4 id="typingrule.erecordnotarecord"><a href="#typingrule.erecordnotarecord" class="anchor"></a>TypingRule.ERecordNotARecord</h4><h5 id="rule_14"><a href="#rule_14" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the record expression of type <code>ty</code> with fields <code>fields</code>;</li><li><code>ty</code> is neither a record nor an exception type;</li><li>an error &quot;Conflicting Types&quot; is raised.</li></ul><h5 id="examples_18"><a href="#examples_18" class="anchor"></a>Examples</h5><h4 id="typingrule.erecordmissingfield"><a href="#typingrule.erecordmissingfield" class="anchor"></a>TypingRule.ERecordMissingField</h4><h5 id="rule_15"><a href="#rule_15" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the record expression of type <code>ty</code> with fields <code>fields</code>;</li><li><code>ty</code> is the name of a record type with fields <code>field_types</code>;</li><li>one field in <code>field_types</code> is not initialised by <code>fields</code>;</li><li>an error &quot;Bad Fields&quot; is raised.</li></ul><h5 id="examples_19"><a href="#examples_19" class="anchor"></a>Examples</h5><h4 id="typingrule.erecord"><a href="#typingrule.erecord" class="anchor"></a>TypingRule.ERecord</h4><h5 id="rule_16"><a href="#rule_16" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the record expression of type <code>ty</code> with fields <code>fields</code>;</li><li><code>ty</code> is the name of a record type with fields <code>field_types</code>;</li><li>For each field named <code>name</code> associated with the expression <code>e'</code> in <code>field_types</code>, all of the following applies:</li><li><code>t',e''</code> is the result of annotating <code>e'</code> in <code>env</code>;</li><li><code>t_spec'</code> is the type associated to <code>name</code> in <code>field_types</code>;</li><li><code>t'</code> type-satisfies <code>t_spec'</code>;</li><li><code>fields'</code> associates <code>name</code> to <code>e''</code>;</li><li><code>t</code> is <code>ty</code>;</li><li><code>new_e</code> is the record expression of type <code>ty</code> with fields <code>fields'</code>.</li></ul><h5 id="examples_20"><a href="#examples_20" class="anchor"></a>Examples</h5><h4 id="typingrule.ecall"><a href="#typingrule.ecall" class="anchor"></a>TypingRule.ECall</h4><h5 id="rule_17"><a href="#rule_17" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a call to a function named <code>name</code> with arguments <code>args</code> and parameters <code>eqs</code>;</li><li><code>name', args', eqs', ty</code> is the result of annotating the call of that function in <code>env</code>;</li><li><code>t</code> is <code>ty</code>;</li><li><code>new_e</code> is the call the function named <code>name'</code> with arguments <code>args'</code> and parameters <code>eqs'</code>.</li></ul><h5 id="examples_21"><a href="#examples_21" class="anchor"></a>Examples</h5><h4 id="typingrule.eunknown"><a href="#typingrule.eunknown" class="anchor"></a>TypingRule.EUnknown</h4><h5 id="rule_18"><a href="#rule_18" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes an unknown expression of type <code>ty</code>;</li><li><code>ty'</code> is the structure of <code>ty</code> in <code>env</code>;</li><li><code>t</code> is <code>ty</code>;</li><li><code>new_e</code> is an unknown expression of type <code>ty'</code>.</li></ul><h5 id="examples_22"><a href="#examples_22" class="anchor"></a>Examples</h5><h4 id="typingrule.eslice"><a href="#typingrule.eslice" class="anchor"></a>TypingRule.ESlice</h4><h5 id="rule_19"><a href="#rule_19" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the slicing of expression <code>e'</code> by the slices <code>slices</code>;</li><li><code>t_e',e'</code> is the result of annotating the expression <code>e'</code> in <code>env</code>;</li><li><code>t_e'</code> has the structure of an integer or a bitvector;</li><li><code>w</code> is the width of <code>slices</code>;</li><li><code>slices'</code> is the result of annotating <code>slices</code> in <code>env</code>;</li><li><code>t</code> is the bitvector type of width <code>w</code>;</li><li><code>new_e</code> is the slicing of expression <code>e'</code> by the slices <code>slices'</code>.</li></ul><h5 id="examples_23"><a href="#examples_23" class="anchor"></a>Examples</h5><h4 id="typingrule.egetarray"><a href="#typingrule.egetarray" class="anchor"></a>TypingRule.EGetArray</h4><h5 id="rule_20"><a href="#rule_20" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the slicing of expression <code>e'</code> by the slices <code>slices</code>;</li><li><code>t_e',e'</code> is the result of annotating the expression <code>e'</code> in <code>env</code>;</li><li><code>t_e'</code> has the structure of an array of size <code>size</code> and type <code>t</code>;</li><li>One of the following applies:</li><li><code>wanted_t_index</code> is an enumeration type of name <code>size</code>;</li><li><code>wanted_t_index</code> is the type <code>integer {0..size-1}</code>;</li><li><code>slices</code> is a single expression <code>e_index</code>;</li><li><code>t_index', e_index'</code> is the result of annotating <code>e_index</code> in <code>env</code>;</li><li><code>t_index'</code> type-satisfies <code>wanted_t_index</code>;</li><li><code>new_e</code> is an access to array <code>e'</code> at index <code>e_index'</code>.</li></ul><h5 id="examples_24"><a href="#examples_24" class="anchor"></a>Examples</h5><h4 id="typingrule.egetrecordfield"><a href="#typingrule.egetrecordfield" class="anchor"></a>TypingRule.EGetRecordField</h4><h5 id="rule_21"><a href="#rule_21" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the access of field <code>field_name</code> on expression <code>e1</code>;</li><li><code>t_e1, e2</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t_e2</code> is the anonymous type corresponding to <code>t_e1</code> in <code>env</code>;</li><li><code>t_e2</code> is an Exception or a Record type with fields <code>fields</code>;</li><li><code>field_name</code> is declared in <code>fields</code>;</li><li><code>t</code> is the type corresponding to <code>field_name</code> in <code>fields</code>;</li><li><code>new_e</code> is the access of field <code>field_name</code> on expression <code>e2</code>.</li></ul><h5 id="examples_25"><a href="#examples_25" class="anchor"></a>Examples</h5><h4 id="typingrule.egetbadrecordfield"><a href="#typingrule.egetbadrecordfield" class="anchor"></a>TypingRule.EGetBadRecordField</h4><h5 id="rule_22"><a href="#rule_22" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the access of field <code>field_name</code> on expression <code>e1</code>;</li><li><code>t_e1, e2</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t_e2</code> is the anonymous type corresponding to <code>t_e1</code> in <code>env</code>;</li><li><code>t_e2</code> is an Exception or a Record type with fields <code>fields</code>;</li><li><code>field_name</code> is not declared in <code>fields</code>;</li><li>an error &quot;Bad Field&quot; is raised.</li></ul><h5 id="examples_26"><a href="#examples_26" class="anchor"></a>Examples</h5><h4 id="typingrule.egetbadbitfield"><a href="#typingrule.egetbadbitfield" class="anchor"></a>TypingRule.EGetBadBitField</h4><h5 id="rule_23"><a href="#rule_23" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the access of field <code>field_name</code> on expression <code>e1</code>;</li><li><code>t_e1, e2</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t_e2</code> is the anonymous type corresponding to <code>t_e1</code> in <code>env</code>;</li><li><code>t_e2</code> is a bitvector type with bitfields <code>bitfields</code>;</li><li><code>field_name</code> is not declared in <code>bitfields</code>;</li><li>an error &quot;Bad Field&quot; is raised.</li></ul><h5 id="examples_27"><a href="#examples_27" class="anchor"></a>Examples</h5><h4 id="typingrule.egetbadfield"><a href="#typingrule.egetbadfield" class="anchor"></a>TypingRule.EGetBadField</h4><h5 id="rule_24"><a href="#rule_24" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the access of field <code>field_name</code> on expression <code>e1</code>;</li><li><code>t_e1, e2</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t_e1</code> does not have the structure of a record or an exception or a bitvector type;</li><li>an error &quot;Conflicting Types&quot; is raised.</li></ul><h5 id="examples_28"><a href="#examples_28" class="anchor"></a>Examples</h5><h4 id="typingrule.egetbitfield"><a href="#typingrule.egetbitfield" class="anchor"></a>TypingRule.EGetBitField</h4><h5 id="rule_25"><a href="#rule_25" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the access of field <code>field_name</code> on expression <code>e1</code>;</li><li><code>t_e1, e2</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t_e2</code> is the anonymous type corresponding to <code>t_e1</code> in <code>env</code>;</li><li><code>t_e2</code> is a bitvector type with bitfields <code>bitfields</code>;</li><li><code>field_name</code> is declared in <code>bitfields</code>;</li><li><code>slices</code> gives the slices corresponding to the bitfield <code>field_name</code> in <code>bitfields</code>;</li><li><code>e3</code> denotes the slicing of the expression <code>e2</code> by the slices <code>slices</code>;</li><li><code>t,new_e</code> is the result of annotating <code>e3</code>.</li></ul><h5 id="examples_29"><a href="#examples_29" class="anchor"></a>Examples</h5><h4 id="typingrule.egetbitfieldnested"><a href="#typingrule.egetbitfieldnested" class="anchor"></a>TypingRule.EGetBitFieldNested</h4><h5 id="rule_26"><a href="#rule_26" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes the access of field <code>field_name</code> on expression <code>e1</code>;</li><li><code>t_e1, e2</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t_e2</code> is the anonymous type corresponding to <code>t_e1</code> in <code>env</code>;</li><li><code>t_e2</code> is a bitvector type with bitfields <code>bitfields</code>;</li><li><code>field_name</code> is declared in <code>bitfields</code>;</li><li><code>slices</code> gives the slices corresponding to the bitfield <code>field_name</code> in <code>bitfields</code>;</li><li><code>e3</code> denotes the slicing of the expression <code>e2</code> by the slices <code>slices</code>;</li><li><code>t4, e4</code> is the result of annotating <code>e3</code> in <code>env</code>;</li><li><code>bitfields'</code> gives the bitfields corresponding to the bitfield <code>field_name</code> in <code>bitfields</code>;</li><li><code>t</code> is the bitvector type with the width of <code>t4</code> and the bitfields <code>bitfields'</code></li><li><code>new_e</code> is <code>e4</code>.</li></ul><h5 id="examples_30"><a href="#examples_30" class="anchor"></a>Examples</h5><h4 id="typingrule.egetbitfieldtyped"><a href="#typingrule.egetbitfieldtyped" class="anchor"></a>TypingRule.EGetBitFieldTyped</h4><h5 id="rule_27"><a href="#rule_27" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes <code>e1, field_name</code>;</li><li><code>t_e1, e2</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t_e2</code> is the anonymous type corresponding to <code>t_e1</code> in <code>env</code>;</li><li><code>t_e2</code> is a bitvector type with bitfields <code>bitfields</code>;</li><li><code>field_name</code> is declared in <code>bitfields</code>;</li><li><code>slices</code> gives the slices corresponding to the bitfield <code>field_name</code> in <code>bitfields</code>;</li><li><code>t_e3,e3</code> is the result of annotating <code>e2,slices</code> in <code>env</code>;</li><li><code>t</code> gives the type corresponding to the bitfield <code>field_name</code> in <code>bitfields</code>;</li><li><code>t_e3</code> type-satisfies <code>t</code> in <code>env</code>;</li><li><code>new_e</code> is <code>e3</code>.</li></ul><h5 id="examples_31"><a href="#examples_31" class="anchor"></a>Examples</h5><h4 id="typingrule.egetbitfields"><a href="#typingrule.egetbitfields" class="anchor"></a>TypingRule.EGetBitFields</h4><h5 id="rule_28"><a href="#rule_28" class="anchor"></a>Rule</h5><p>&lt;description&gt;</p><h5 id="examples_32"><a href="#examples_32" class="anchor"></a>Examples</h5><p>&lt;minimal example&gt;</p><h4 id="typingrule.epattern"><a href="#typingrule.epattern" class="anchor"></a>TypingRule.EPattern</h4><h5 id="rule_29"><a href="#rule_29" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes whether the expression <code>e'</code> matches <code>patterns</code>;</li><li><code>t_e', e''</code> is the result of annotating <code>e'</code> in <code>env</code>;</li><li><code>patterns'</code> is the result of annotating <code>patterns</code> in <code>env</code>;</li><li><code>t</code> is <code>boolean</code>;</li><li><code>new_e</code> denotes whether the expression <code>e''</code> matches <code>patterns'</code>.</li></ul><h5 id="examples_33"><a href="#examples_33" class="anchor"></a>Examples</h5><h3 id="typing-of-left-hand-side-expressions"><a href="#typing-of-left-hand-side-expressions" class="anchor"></a>Typing of Left-Hand-Side Expressions</h3><p><code>annotate_lexpr version env le t_e</code> is <code>new_le</code> and one of the following applies:</p><h4 id="typingrule.leignore"><a href="#typingrule.leignore" class="anchor"></a>TypingRule.LEIgnore</h4><h5 id="rule_30"><a href="#rule_30" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes an expression which can be ignored;</li><li><code>new_le</code> is <code>le</code>.</li></ul><h5 id="examples_34"><a href="#examples_34" class="anchor"></a>Examples</h5><h4 id="typingrule.lelocalvar"><a href="#typingrule.lelocalvar" class="anchor"></a>TypingRule.LELocalVar</h4><h5 id="rule_31"><a href="#rule_31" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes a local variable <code>x</code> of type <code>ty</code>;</li><li><code>x</code> is locally declared as a variable of type <code>ty</code> in <code>env</code>;</li><li><code>new_le</code> is <code>le</code>.</li></ul><h5 id="examples_35"><a href="#examples_35" class="anchor"></a>Examples</h5><h4 id="typingrule.leglobalvar"><a href="#typingrule.leglobalvar" class="anchor"></a>TypingRule.LEGlobalVar</h4><h5 id="rule_32"><a href="#rule_32" class="anchor"></a>Rule</h5><h5 id="examples_36"><a href="#examples_36" class="anchor"></a>Examples</h5><h4 id="typingrule.letuple"><a href="#typingrule.letuple" class="anchor"></a>TypingRule.LETuple</h4><h5 id="rule_33"><a href="#rule_33" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes a tuple <code>les</code>;</li><li><code>t_e</code> denotes a tuple type <code>sub_tys</code>;</li><li>One of the following applies:</li><li>All of the following applies:</li><li><code>les</code> and <code>sub_tys</code> have the same length;</li><li><code>new_le</code> is the result of annotating <code>les</code> with <code>sub_tys</code> in <code>env</code></li><li>All of the following applies:</li><li><code>les</code> and <code>sub_tys</code> do not have the same length;</li><li>an error &quot;Bad Arity Tuple Unpacking&quot; is raised.</li></ul><h5 id="examples_37"><a href="#examples_37" class="anchor"></a>Examples</h5><h4 id="typingrule.leslice"><a href="#typingrule.leslice" class="anchor"></a>TypingRule.LESlice</h4><h5 id="rule_34"><a href="#rule_34" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes the slicing of a left-hand-side expression <code>le1</code> by the slices <code>slices</code>;</li><li><code>t_le1</code> is the type result of annotating the right-hand-side expression corresponding to <code>le1</code> in <code>env</code>;</li><li><code>t_le1</code> has the structure of a bitvector type;</li><li><code>le2</code> is the result of annotating <code>le1</code> in <code>env</code>;</li><li><code>width</code> is the width of the slices <code>slices</code> in <code>env</code>;</li><li><code>t</code> is the bitvector type of width <code>width</code>;</li><li><code>slices2</code> is the result of annotating <code>slices</code> in <code>env</code>;</li><li><code>new_le</code> is the slicing of <code>le2</code> by <code>slices2</code>.</li></ul><h5 id="examples_38"><a href="#examples_38" class="anchor"></a>Examples</h5><h4 id="typingrule.lesetarray"><a href="#typingrule.lesetarray" class="anchor"></a>TypingRule.LESetArray</h4><h5 id="rule_35"><a href="#rule_35" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes the slicing of a left-hand-side expression <code>le1</code> by the slices <code>slices</code>;</li><li><code>t_le1</code> is the type result of annotating the right-hand-side expression corresponding to <code>le1</code> in <code>env</code>;</li><li><code>t_le1</code> has the structure of an array type of size <code>size</code> and item type <code>t</code>;</li><li><code>le2</code> is the result of annotating <code>le1</code> in <code>env</code>;</li><li>One of the following applies:</li><li><code>wanted_t_index</code> is an enumeration type of name <code>size</code>;</li><li><code>wanted_t_index</code> is the type <code>integer {0..size-1}</code>;</li><li><code>slices</code> is a single expression <code>e_index</code>;</li><li><code>t_index', e_index'</code> is the result of annotating <code>e_index</code> in <code>env</code>;</li><li><code>t_index'</code> type-satisfies <code>wanted_t_index</code>;</li><li><code>new_le</code> is an access to array <code>le2</code> at index <code>e_index'</code>.</li></ul><h5 id="examples_39"><a href="#examples_39" class="anchor"></a>Examples</h5><h4 id="typingrule.lesetbadrecordfield"><a href="#typingrule.lesetbadrecordfield" class="anchor"></a>TypingRule.LESetBadRecordField</h4><h5 id="rule_36"><a href="#rule_36" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes the access to the field named <code>field</code> in <code>le1</code>;</li><li><code>t_le1</code> is the type result of annotating the right-hand-side expression corresponding to <code>le1</code> in <code>env</code>;</li><li><code>le2</code> is the result of annotating <code>le1</code> in <code>env</code>;</li><li><code>t_le1</code> has the structure of an exception or a record type with fields <code>fields</code>;</li><li><code>field</code> is not declared in <code>fields</code>;</li><li>an error &quot;Bad Field&quot; is raised.</li></ul><h5 id="examples_40"><a href="#examples_40" class="anchor"></a>Examples</h5><h4 id="typingrule.lesetrecordfield"><a href="#typingrule.lesetrecordfield" class="anchor"></a>TypingRule.LESetRecordField</h4><h5 id="rule_37"><a href="#rule_37" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes the access to the field named <code>field</code> in <code>le1</code>;</li><li><code>t_le1</code> is the type result of annotating the right-hand-side expression corresponding to <code>le1</code> in <code>env</code>;</li><li><code>le2</code> is the result of annotating <code>le1</code> in <code>env</code>;</li><li><code>t_le1</code> has the structure of an exception or a record type with fields <code>fields</code>;</li><li><code>field</code> is bound to type <code>t</code> in <code>fields</code>;</li><li><code>t_e</code> type-satisfies <code>t</code>;</li><li><code>new_le</code> is the access to the field <code>field</code> in <code>le2</code>.</li></ul><h5 id="examples_41"><a href="#examples_41" class="anchor"></a>Examples</h5><h4 id="typingrule.lesetbadbitfield"><a href="#typingrule.lesetbadbitfield" class="anchor"></a>TypingRule.LESetBadBitField</h4><h5 id="rule_38"><a href="#rule_38" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes the access to the field named <code>field</code> in <code>le1</code>;</li><li><code>t_le1</code> is the type result of annotating the right-hand-side expression corresponding to <code>le1</code> in <code>env</code>;</li><li><code>le2</code> is the result of annotating <code>le1</code> in <code>env</code>;</li><li><code>t_le1</code> has the structure of a bitvector with bitfields <code>bitfields</code>;</li><li><code>field</code> is not declared in <code>bitfields</code>;</li><li>an error &quot;Bad Field&quot; is raised.</li></ul><h5 id="examples_42"><a href="#examples_42" class="anchor"></a>Examples</h5><h4 id="typingrule.lesetbitfield"><a href="#typingrule.lesetbitfield" class="anchor"></a>TypingRule.LESetBitField</h4><h5 id="rule_39"><a href="#rule_39" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes the access to the field named <code>field</code> in <code>le1</code>;</li><li><code>t_le1</code> is the type result of annotating the right-hand-side expression corresponding to <code>le1</code> in <code>env</code>;</li><li><code>le2</code> is the result of annotating <code>le1</code> in <code>env</code>;</li><li><code>t_le1</code> has the structure of a bitvector with bitfields <code>bitfields</code>;</li><li><code>field</code> is declared in <code>bitfields</code>;</li><li><code>slices</code> gives the slices corresponding to the bitfield <code>field</code> in <code>bitfields</code>;</li><li><code>w</code> is the width of <code>slices</code>;</li><li><code>t</code> is the bitvector type of width <code>w</code>;</li><li><code>t_e</code> type-satisfies <code>t</code>;</li><li><code>le2</code> is the slicing of <code>le1</code> by <code>slices</code>;</li><li><code>new_le</code> is the result of annotating <code>le2</code> in <code>env</code>.</li></ul><h5 id="examples_43"><a href="#examples_43" class="anchor"></a>Examples</h5><h4 id="typingrule.lesetbitfieldnested"><a href="#typingrule.lesetbitfieldnested" class="anchor"></a>TypingRule.LESetBitFieldNested</h4><h5 id="rule_40"><a href="#rule_40" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes the access to the field named <code>field</code> in <code>le1</code>;</li><li><code>t_le1</code> is the type result of annotating the right-hand-side expression corresponding to <code>le1</code> in <code>env</code>;</li><li><code>le2</code> is the result of annotating <code>le1</code> in <code>env</code>;</li><li><code>t_le1</code> has the structure of a bitvector with bitfields <code>bitfields</code>;</li><li><code>slices</code> gives the slices corresponding to the bitfield <code>field</code> in <code>bitfields</code>;</li><li><code>w</code> is the width of <code>slices</code>;</li><li><code>bitfields'</code> gives the bitfields corresponding to <code>field</code> in <code>bitfields</code>;</li><li><code>t</code> is the bitvector type of width <code>w</code> and bitfields <code>bitfields'</code>;</li><li><code>t_e</code> type-satisfies <code>t</code>;</li><li><code>le2</code> is the slicing of <code>le1</code> by <code>slices</code>;</li><li><code>new_le</code> is the result of annotating <code>le2</code> in <code>env</code>.</li></ul><h5 id="examples_44"><a href="#examples_44" class="anchor"></a>Examples</h5><h4 id="typingrule.lesetbitfieldtyped"><a href="#typingrule.lesetbitfieldtyped" class="anchor"></a>TypingRule.LESetBitFieldTyped</h4><h5 id="rule_41"><a href="#rule_41" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes the access to the field named <code>field</code> in <code>le1</code>;</li><li><code>t_le1</code> is the type result of annotating the right-hand-side expression corresponding to <code>le1</code> in <code>env</code>;</li><li><code>le2</code> is the result of annotating <code>le1</code> in <code>env</code>;</li><li><code>t_le1</code> has the structure of a bitvector with bitfields <code>bitfields</code>;</li><li><code>slices</code> gives the slices corresponding to the bitfield <code>field</code> in <code>bitfields</code>;</li><li><code>w</code> is the width of <code>slices</code>;</li><li><code>t'</code> is the bitvector type of width <code>w</code>;</li><li><code>t</code> gives the type corresponding to the bitfield <code>field</code> in <code>bitfields</code>;</li><li><code>t'</code> type-satisfies <code>t</code>;</li><li><code>t_e</code> type-satisfies <code>t</code>;</li><li><code>le2</code> is the slicing of <code>le1</code> by <code>slices</code>;</li><li><code>new_le</code> is the result of annotating <code>le2</code> in <code>env</code>.</li></ul><h5 id="examples_45"><a href="#examples_45" class="anchor"></a>Examples</h5><h4 id="typingrule.lesetbadfield"><a href="#typingrule.lesetbadfield" class="anchor"></a>TypingRule.LESetBadField</h4><h5 id="rule_42"><a href="#rule_42" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes the access to the field named <code>field</code> in <code>le1</code>;</li><li><code>t_le1</code> is the type result of annotating the right-hand-side expression corresponding to <code>le1</code> in <code>env</code>;</li><li><code>le2</code> is the result of annotating <code>le1</code> in <code>env</code>;</li><li><code>t_le1</code> does not have the structure of a record, or an exception or a bitvector type;</li><li>an error &quot;Conflicting Types&quot; is raised.</li></ul><h5 id="examples_46"><a href="#examples_46" class="anchor"></a>Examples</h5><h4 id="typingrule.lesetfields"><a href="#typingrule.lesetfields" class="anchor"></a>TypingRule.LESetFields</h4><h5 id="rule_43"><a href="#rule_43" class="anchor"></a>Rule</h5><h5 id="examples_47"><a href="#examples_47" class="anchor"></a>Examples</h5><h4 id="typingrule.leconcat"><a href="#typingrule.leconcat" class="anchor"></a>TypingRule.LEConcat</h4><h5 id="rule_44"><a href="#rule_44" class="anchor"></a>Rule</h5><h5 id="examples_48"><a href="#examples_48" class="anchor"></a>Examples</h5><h3 id="typing-of-local-declarations"><a href="#typing-of-local-declarations" class="anchor"></a>Typing of Local Declarations</h3><p><code>annotate_local_decl_item loc env ty ldk ldi</code> is <code>new_env, new_ldi</code> and one of the following applies:</p><h4 id="typingrule.ldignorenone"><a href="#typingrule.ldignorenone" class="anchor"></a>TypingRule.LDIgnoreNone</h4><h5 id="rule_45"><a href="#rule_45" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> is a local declaration which can be ignored;</li><li>no type is given;</li><li><code>new_env</code> is <code>env</code>;</li><li><code>new_ldi</code> is <code>ldi</code>.</li></ul><h5 id="examples_49"><a href="#examples_49" class="anchor"></a>Examples</h5><h4 id="typingrule.ldignoresome"><a href="#typingrule.ldignoresome" class="anchor"></a>TypingRule.LDIgnoreSome</h4><h5 id="rule_46"><a href="#rule_46" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> is a local declaration which can be ignored;</li><li>a type <code>t</code> is given;</li><li>One of the following applies:</li><li>All of the following applies:</li><li><code>t</code> can be initialised with <code>ty</code> in <code>env</code>;</li><li><code>new_env</code> is <code>env</code>;</li><li><code>new_ldi</code> is <code>ldi</code>.</li><li>All of the following applies:</li><li><code>t</code> cannot be initialised with <code>ty</code> in <code>env</code>;</li><li>an error &quot;Conflicting Types&quot; is raised.</li></ul><h5 id="examples_50"><a href="#examples_50" class="anchor"></a>Examples</h5><h4 id="typingrule.ldvar"><a href="#typingrule.ldvar" class="anchor"></a>TypingRule.LDVar</h4><h5 id="rule_47"><a href="#rule_47" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> denotes a variable <code>x</code> with an optional type <code>ty_opt</code>;</li><li><code>x</code> is not declared in <code>env</code>;</li><li>One of the following applies:</li><li>All of the following applies:</li><li><code>ty_opt</code> is <code>None</code>;</li><li><code>t</code> is <code>ty</code></li><li>All of the following applies:</li><li><code>ty_opt</code> is <code>Some t</code>;</li><li><code>t</code> can be initialized with <code>ty</code> in <code>env</code>;</li><li><code>new_env</code> is <code>env</code> modified so that <code>x</code> is locally declared of type <code>t</code>;</li><li><code>new_ldi</code> is the declaration of variable <code>x</code> with type <code>t</code>.</li></ul><h5 id="examples_51"><a href="#examples_51" class="anchor"></a>Examples</h5><h4 id="typingrule.lduninitialisedtypedtuple"><a href="#typingrule.lduninitialisedtypedtuple" class="anchor"></a>TypingRule.LDUninitialisedTypedTuple</h4><h5 id="rule_48"><a href="#rule_48" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> denotes a singleton list <code>ld</code>;</li><li><code>new_env, new_ldi</code> is the result of annotating the local declaration <code>ld</code> with <code>ty</code> in <code>env</code>.</li></ul><h5 id="examples_52"><a href="#examples_52" class="anchor"></a>Examples</h5><h4 id="typingrule.ldtuple"><a href="#typingrule.ldtuple" class="anchor"></a>TypingRule.LDTuple</h4><h5 id="rule_49"><a href="#rule_49" class="anchor"></a>Rule</h5><h5 id="examples_53"><a href="#examples_53" class="anchor"></a>Examples</h5><h4 id="typingrule.ldtypedtuple"><a href="#typingrule.ldtypedtuple" class="anchor"></a>TypingRule.LDTypedTuple</h4><h5 id="rule_50"><a href="#rule_50" class="anchor"></a>Rule</h5><h5 id="examples_54"><a href="#examples_54" class="anchor"></a>Examples</h5><h3 id="typing-of-statements"><a href="#typing-of-statements" class="anchor"></a>Typing of Statements</h3><p><code>annotate_stmt env s</code> is a statement <code>new_s</code> and an environment <code>new_env</code> and one of the following applies:</p><h4 id="typingrule.spass"><a href="#typingrule.spass" class="anchor"></a>TypingRule.SPass</h4><h5 id="rule_51"><a href="#rule_51" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a pass statement;</li><li><code>new_s</code> is <code>s</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_55"><a href="#examples_55" class="anchor"></a>Examples</h5><h4 id="typingrule.sthen"><a href="#typingrule.sthen" class="anchor"></a>TypingRule.SThen</h4><h5 id="rule_52"><a href="#rule_52" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a then statement over two statements <code>s1</code> and <code>s2</code>;</li><li><code>new_s1, env1</code> is the result of annotating <code>s1</code> in <code>env</code>;</li><li><code>new_s2, env2</code> is the result of annotating <code>s2</code> in <code>env1</code>;</li><li><code>new_s</code> is a then statement over two statements <code>new_s1</code> and <code>new_s2</code>;</li><li><code>new_env</code> is <code>env2</code>.</li></ul><h5 id="examples_56"><a href="#examples_56" class="anchor"></a>Examples</h5><h4 id="typingrule.sassign"><a href="#typingrule.sassign" class="anchor"></a>TypingRule.SAssign</h4><h5 id="rule_53"><a href="#rule_53" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is an assignment <code>le = re</code> under language version <code>ver</code>;</li><li><code>t_e, e1</code> is the result of annotating <code>e</code> in <code>env</code>;</li><li><code>reduced</code> is the result of potential result of inlining a setter call in <code>le</code>;</li><li>One of the following applies:</li><li>All of the following applies:</li><li><code>reduced</code> gives a statement <code>s</code>;</li><li><code>new_s</code> is <code>s</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><ul><li>All of the following applies:</li><li><code>reduced</code> does not give a statement <code>s</code>;</li><li>One of the following applies:</li><li>All of the following applies:</li><li><code>ver</code> is ASLv1;</li><li><code>env1</code> is <code>env</code>;</li></ul><ul><li>All of the following applies:</li><li><code>ver</code> is ASLv0;</li><li><code>env1</code> is the result of annotating undeclared variables by using the first assignments to such variables as declarations;</li></ul><ul><li><code>le1</code> is the result of annotating <code>le</code> in <code>env1</code>;</li><li><code>new_s</code> is the assignment <code>le1 = e1</code>;</li><li><code>new_env</code> is <code>env1</code>.</li></ul><h5 id="examples_57"><a href="#examples_57" class="anchor"></a>Examples</h5><h4 id="typingrule.scall"><a href="#typingrule.scall" class="anchor"></a>TypingRule.SCall</h4><h5 id="rule_54"><a href="#rule_54" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a call to a function named <code>name</code> with arguments <code>args</code> and parameters <code>eqs</code>;</li><li><code>new_name, new_args, new_eqs</code> is the result of annotating the call to the procedure <code>name</code> with arguments <code>args</code> and parameters <code>eqs</code>;</li><li><code>new_s</code> is the call to a function named <code>new_name</code> with arguments <code>new_args</code> and parameters <code>new_eqs</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_58"><a href="#examples_58" class="anchor"></a>Examples</h5><h4 id="typingrule.sreturnnone"><a href="#typingrule.sreturnnone" class="anchor"></a>TypingRule.SReturnNone</h4><h5 id="rule_55"><a href="#rule_55" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a return statement with no value and no return type;</li><li><code>new_s</code> is a return statement with no value;</li><li>the enclosing function does not have a return type (it is either a setter or a procedure);</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_59"><a href="#examples_59" class="anchor"></a>Examples</h5><h4 id="typingrule.sreturnone"><a href="#typingrule.sreturnone" class="anchor"></a>TypingRule.SReturnOne</h4><h5 id="rule_56"><a href="#rule_56" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li>One of the following applies:</li><li>All of the following applies:</li><li><code>s</code> is a return statement with some value;</li><li>the enclosing function does not have a return type;</li><li>All of the following applies:</li><li><code>s</code> is a return statement with no value;</li><li>the enclosing function has a return type;</li><li>An error &quot;Bad Return Statement&quot; is raised.</li></ul><h5 id="examples_60"><a href="#examples_60" class="anchor"></a>Examples</h5><h4 id="typingrule.sreturnsome"><a href="#typingrule.sreturnsome" class="anchor"></a>TypingRule.SReturnSome</h4><h5 id="rule_57"><a href="#rule_57" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a return statement with some value <code>e</code>;</li><li>the enclosing function has a return type <code>t</code>;</li><li><code>t_e',e'</code> is the result of annotating <code>e</code> in <code>env</code>;</li><li><code>t_e'</code> type-satisfies <code>t</code>;</li><li><code>new_s</code> is a return statement with value <code>e'</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_61"><a href="#examples_61" class="anchor"></a>Examples</h5><h4 id="typingrule.scond"><a href="#typingrule.scond" class="anchor"></a>TypingRule.SCond</h4><h5 id="rule_58"><a href="#rule_58" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a condition <code>e</code> with two statements <code>s1</code> and <code>s2</code>;</li><li><code>t_cond, e_cond</code> is the result of annotating <code>e</code> in <code>env</code>;</li><li><code>t_cond</code> type-satisfies <code>t_bool</code>;</li><li><code>s1'</code> is the result of annotating <code>s1</code> in <code>env</code>;</li><li><code>s2'</code> is the result of annotating <code>s2</code> in <code>env</code>;</li><li><code>new_s</code> is the condition <code>e_cond</code> with two statements <code>s1'</code> and <code>s2'</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_62"><a href="#examples_62" class="anchor"></a>Examples</h5><h4 id="typingrule.scase"><a href="#typingrule.scase" class="anchor"></a>TypingRule.SCase</h4><h5 id="rule_59"><a href="#rule_59" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a case statement with expression <code>e</code> and cases <code>cases</code>;</li><li><code>t_e, e1</code> is the result of annotating <code>e</code> in <code>env</code>;</li><li><code>cases1, env1</code> is the result of annotating each case in <code>cases</code>;</li><li><code>new_s</code> is a case statement with expression <code>e1</code> and cases <code>cases1</code>;</li><li><code>new_env</code> is <code>env1</code>.</li></ul><h5 id="examples_63"><a href="#examples_63" class="anchor"></a>Examples</h5><h4 id="typingrule.sassert"><a href="#typingrule.sassert" class="anchor"></a>TypingRule.SAssert</h4><h5 id="rule_60"><a href="#rule_60" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is an assert statement with expression <code>e</code>;</li><li><code>t_e',e'</code> is the result of annotating <code>e</code> in <code>env</code>;</li><li><code>t_e'</code> type-satisfies <code>t_bool</code>;</li><li><code>new_s</code> is an assert statement with expression <code>e'</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_64"><a href="#examples_64" class="anchor"></a>Examples</h5><h4 id="typingrule.swhile"><a href="#typingrule.swhile" class="anchor"></a>TypingRule.SWhile</h4><h5 id="rule_61"><a href="#rule_61" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a while statement with expression <code>e1</code> and statement <code>s1</code>;</li><li><code>t, e2</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t</code> type-satisfies <code>t_bool</code>;</li><li><code>s2</code> is the result of annotating <code>s1</code> in <code>env</code>;</li><li><code>new_s</code> is a while statement with expression <code>e2</code> and statement <code>s2</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_65"><a href="#examples_65" class="anchor"></a>Examples</h5><h4 id="typingrule.srepeat"><a href="#typingrule.srepeat" class="anchor"></a>TypingRule.SRepeat</h4><h5 id="rule_62"><a href="#rule_62" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a repeat statement with expression <code>e1</code> and statement <code>s1</code>;</li><li><code>s2</code> is the result of annotating <code>s1</code> in <code>env</code>;</li><li><code>t, e2</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t</code> type-satisfies <code>t_bool</code>;</li><li><code>new_s</code> is a repeat statement with expression <code>e2</code> and statement <code>s2</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_66"><a href="#examples_66" class="anchor"></a>Examples</h5><h4 id="typingrule.sfor"><a href="#typingrule.sfor" class="anchor"></a>TypingRule.SFor</h4><h5 id="rule_63"><a href="#rule_63" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a for statement with index <code>id</code>, direction <code>dir</code>, two expressions <code>e1</code> and <code>e2</code> and a statement <code>s'</code>;</li><li><code>t1,e1'</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t2,e2'</code> is the result of annotating <code>e2</code> in <code>env</code>;</li><li><code>t1</code> has the structure of an integer type;</li><li><code>t2</code> has the structure of an integer type;</li><li><code>ty</code> is ;</li><li><code>s''</code> is the result of annotating <code>s'</code> in <code>env</code>;</li><li><code>new_s</code> is a for statement with index <code>id</code>, direction <code>dir</code>, two expressions <code>e1'</code> and <code>e2'</code> and statement <code>s''</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_67"><a href="#examples_67" class="anchor"></a>Examples</h5><h4 id="typingrule.sdeclsome"><a href="#typingrule.sdeclsome" class="anchor"></a>TypingRule.SDeclSome</h4><h5 id="rule_64"><a href="#rule_64" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a declaration with <code>ldk</code>, <code>ldi</code> and an expression <code>e</code>;</li><li><code>t_e,e'</code> is the result of annotating <code>e</code> in <code>env</code>;</li><li><code>env', ldi'</code> is the result of declaring the local identifiers of <code>ldi</code> in <code>env</code>;</li><li><code>new_s</code> is a declaration with <code>ldk</code>, <code>ldi'</code> and an expression <code>e'</code>;</li><li><code>new_env</code> is <code>env'</code>.</li></ul><h5 id="examples_68"><a href="#examples_68" class="anchor"></a>Examples</h5><h4 id="typingrule.sdeclnone"><a href="#typingrule.sdeclnone" class="anchor"></a>TypingRule.SDeclNone</h4><h5 id="rule_65"><a href="#rule_65" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a declaration statement with <code>ldk</code>, <code>ldi</code> and no initial expression;</li><li><code>env', s'</code> is the result of annotating uninitialised local declarations <code>ldi</code> in <code>env</code>;</li><li><code>new_s</code> is <code>s'</code>;</li><li><code>new_env</code> is <code>env'</code>.</li></ul><h5 id="examples_69"><a href="#examples_69" class="anchor"></a>Examples</h5><h4 id="typingrule.sthrownone"><a href="#typingrule.sthrownone" class="anchor"></a>TypingRule.SThrowNone</h4><h5 id="rule_66"><a href="#rule_66" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a throw statement with no expression;</li><li><code>new_s</code> is <code>s</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_70"><a href="#examples_70" class="anchor"></a>Examples</h5><h4 id="typingrule.sthrowsome"><a href="#typingrule.sthrowsome" class="anchor"></a>TypingRule.SThrowSome</h4><h5 id="rule_67"><a href="#rule_67" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a throw statement with expression <code>e</code>;</li><li><code>t_e,e'</code> is the result of annotating <code>e</code> in <code>env</code>;</li><li><code>t_e</code> has the structure of an exception type;</li><li><code>new_s</code> is a throw statement with expression <code>e'</code> and type <code>t_e</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_71"><a href="#examples_71" class="anchor"></a>Examples</h5><h4 id="typingrule.stry"><a href="#typingrule.stry" class="anchor"></a>TypingRule.STry</h4><h5 id="rule_68"><a href="#rule_68" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a try statement with statement <code>s'</code>, catchers <code>catchers</code> and block <code>otherwise</code>;</li><li><code>s''</code> is the result of annotating <code>s'</code> in <code>env</code>;</li><li><code>otherwise'</code> is the result of annotating <code>otherwise</code> in <code>env</code>;</li><li><code>catchers'</code> is the result of annotating <code>catchers</code> in <code>env</code>;</li><li><code>new_s</code> is a try statement with statement <code>s''</code>, catchers <code>catchers'</code> and block <code>otherwise'</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="examples_72"><a href="#examples_72" class="anchor"></a>Examples</h5><h3 id="typing-of-slices"><a href="#typing-of-slices" class="anchor"></a>Typing of Slices</h3><p><code>annotate_slices env slices</code> is the pair <code>(offset, length)</code> and one of the following applies:</p><h4 id="typingrule.slicelength"><a href="#typingrule.slicelength" class="anchor"></a>TypingRule.SliceLength</h4><h5 id="rule_69"><a href="#rule_69" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>slices</code> gives <code>offset</code> and <code>length</code>;</li><li><code>t_offset, offset'</code> is the result of annotating <code>offset</code> in <code>env</code>;</li><li><code>t_length, length'</code> is the result of annotating <code>length</code> in <code>env</code>;</li><li><code>t_offset</code> has the structure of an integer type;</li><li><code>t_length</code> has the structure of an integer type;</li><li><code>length</code> is pure.</li></ul><h5 id="examples_73"><a href="#examples_73" class="anchor"></a>Examples</h5><h4 id="typingrule.slicesingle"><a href="#typingrule.slicesingle" class="anchor"></a>TypingRule.SliceSingle</h4><h5 id="rule_70"><a href="#rule_70" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>slices</code> gives an index <code>i</code>;</li><li><code>(offset, length)</code> is the result of applying TypingRule.SliceLength to <code>i, i+:1</code>.</li></ul><h5 id="comments_2"><a href="#comments_2" class="anchor"></a>Comments</h5><p>R_GXKG: The notation b<code>i</code> is syntactic sugar for b<code>i +: 1</code>.</p><h5 id="examples_74"><a href="#examples_74" class="anchor"></a>Examples</h5><h4 id="typingrule.slicerange"><a href="#typingrule.slicerange" class="anchor"></a>TypingRule.SliceRange</h4><h5 id="rule_71"><a href="#rule_71" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>slices</code> gives a range <code>(j, i)</code>;</li><li><code>pre_length</code> is <code>i +: j-i+1</code>;</li><li><code>offset, length</code> is the result of applying TypingRule.SliceLength to <code>i,pre_length</code>.</li></ul><h5 id="comments_3"><a href="#comments_3" class="anchor"></a>Comments</h5><p>R_GXKG: The notation b<code>j:i</code> is syntactic sugar for b<code>i +: j-i+1</code>.</p><h5 id="examples_75"><a href="#examples_75" class="anchor"></a>Examples</h5><h4 id="typingrule.slicestar"><a href="#typingrule.slicestar" class="anchor"></a>TypingRule.SliceStar</h4><h5 id="rule_72"><a href="#rule_72" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>slices</code> gives <code>(factor, pre_length)</code>;</li><li><code>pre_offset</code> is <code>factor * pre_length</code>;</li><li><code>offset, length</code> is the result of applying TypingRule.SliceLength to <code>(pre_offset, pre_length)</code>.</li></ul><h5 id="comments_4"><a href="#comments_4" class="anchor"></a>Comments</h5><p>R_GXQG: The notation b<code>i *: n</code> is syntactic sugar for b<code>i*n +: n</code></p><h5 id="examples_76"><a href="#examples_76" class="anchor"></a>Examples</h5><h3 id="typing-of-patterns"><a href="#typing-of-patterns" class="anchor"></a>Typing of Patterns</h3><p><code>annotate_pattern loc env t p</code> is <code>new_p</code> and one of the following applies:</p><h4 id="typingrule.pall"><a href="#typingrule.pall" class="anchor"></a>TypingRule.PAll</h4><h5 id="rule_73"><a href="#rule_73" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern matching everything;</li><li><code>new_p</code> is <code>p</code>.</li></ul><h5 id="examples_77"><a href="#examples_77" class="anchor"></a>Examples</h5><h4 id="typingrule.pany"><a href="#typingrule.pany" class="anchor"></a>TypingRule.PAny</h4><h5 id="rule_74"><a href="#rule_74" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern which matches anything in a list <code>li</code>;</li><li><code>new_li</code> is the result of mapping the result of annotating <code>p</code> in <code>env</code> onto <code>li</code>;</li><li><code>new_p</code> is the pattern which matches anything in <code>new_li</code>.</li></ul><h5 id="examples_78"><a href="#examples_78" class="anchor"></a>Examples</h5><h4 id="typingrule.pnot"><a href="#typingrule.pnot" class="anchor"></a>TypingRule.PNot</h4><h5 id="rule_75"><a href="#rule_75" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern which matches the negation of a pattern <code>q</code>;</li><li><code>new_q</code> is the result of annotating <code>q</code> in <code>env</code>;</li><li><code>new_p</code> is pattern which matches the negation of <code>new_q</code>.</li></ul><h5 id="examples_79"><a href="#examples_79" class="anchor"></a>Examples</h5><h4 id="typingrule.psingle"><a href="#typingrule.psingle" class="anchor"></a>TypingRule.PSingle</h4><h5 id="rule_76"><a href="#rule_76" class="anchor"></a>Rule</h5><h5 id="examples_80"><a href="#examples_80" class="anchor"></a>Examples</h5><h4 id="typingrule.pgeq"><a href="#typingrule.pgeq" class="anchor"></a>TypingRule.PGeq</h4><h5 id="rule_77"><a href="#rule_77" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern which matches anything greater than or equal to an expression <code>e</code>;</li><li><code>t_e, e'</code> is the result of annotating <code>e</code> in <code>env</code>;</li><li><code>e'</code> is a compile-time constant;</li><li><code>t</code> has the structure of an integer;</li><li><code>t_e</code> has the structure of an integer;</li><li><code>new_p</code> is the pattern which matches anything greater than or equal to <code>e'</code>.</li></ul><h5 id="examples_81"><a href="#examples_81" class="anchor"></a>Examples</h5><h4 id="typingrule.pleq"><a href="#typingrule.pleq" class="anchor"></a>TypingRule.PLeq</h4><h5 id="rule_78"><a href="#rule_78" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern which matches anything lesser than or equal to an expression <code>e</code>;</li><li><code>t_e, e'</code> is the result of annotating <code>e</code> in <code>env</code>;</li><li><code>e'</code> is a compile-time constant;</li><li><code>t</code> has the structure of an integer;</li><li><code>t_e</code> has the structure of an integer;</li><li><code>new_p</code> is the pattern which matches anything lesser than or equal to <code>e'</code>.</li></ul><h5 id="examples_82"><a href="#examples_82" class="anchor"></a>Examples</h5><h4 id="typingrule.prange"><a href="#typingrule.prange" class="anchor"></a>TypingRule.PRange</h4><h5 id="rule_79"><a href="#rule_79" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern which matches anything within the range given by expressions <code>e1</code> and <code>e2</code>;</li><li><code>t_e1, e1'</code> is the result of annotating <code>e1</code> in <code>env</code>;</li><li><code>t_e2, e2'</code> is the result of annotating <code>e2</code> in <code>env</code>;</li><li><code>t</code> has the structure of an integer;</li><li><code>t_e1</code> has the structure of an integer;</li><li><code>t_e2</code> has the structure of an integer;</li><li>e1' and e2' are compile-time constants;</li><li><code>new_p</code> is the pattern which matches anything within the range given by expressions <code>e1'</code> and <code>e2'</code>.</li></ul><h5 id="examples_83"><a href="#examples_83" class="anchor"></a>Examples</h5><h4 id="typingrule.pmask"><a href="#typingrule.pmask" class="anchor"></a>TypingRule.PMask</h4><h5 id="rule_80"><a href="#rule_80" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern which matches a mask <code>m</code>;</li><li><code>t</code> has the structure of a bitvector type;</li><li><code>n</code> is the length of mask <code>m</code>;</li><li><code>t_m</code> is the bitvector type of width <code>n</code>;</li><li><code>t</code> type-satisfies <code>t_m</code>;</li><li><code>new_p</code> is <code>p</code>.</li></ul><h5 id="examples_84"><a href="#examples_84" class="anchor"></a>Examples</h5><h4 id="typingrule.ptuplebadarity"><a href="#typingrule.ptuplebadarity" class="anchor"></a>TypingRule.PTupleBadArity</h4><h5 id="rule_81"><a href="#rule_81" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern which matches a tuple <code>li</code>;</li><li><code>t</code> has the type structure of a tuple type <code>ts</code>;</li><li><code>ts</code> is a list of different size to the size of <code>li</code>;</li><li>an error &quot;Bad Arity&quot; is raised.</li></ul><h5 id="examples_85"><a href="#examples_85" class="anchor"></a>Examples</h5><h4 id="typingrule.ptuple"><a href="#typingrule.ptuple" class="anchor"></a>TypingRule.PTuple</h4><h5 id="rule_82"><a href="#rule_82" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern which matches a tuple <code>li</code>;</li><li><code>t_struct</code> is the type structure of <code>t</code>;</li><li><code>t_struct</code> is a tuple <code>ts</code>;</li><li><code>ts</code> is a list of same size to the size of <code>li</code>;</li><li><code>new_li</code> is the result of annotating <code>li</code> with <code>ts</code>;</li><li><code>new_p</code> is the pattern which matches the tuple <code>new_li</code>.</li></ul><h5 id="examples_86"><a href="#examples_86" class="anchor"></a>Examples</h5><h4 id="typingrule.ptupleconflict"><a href="#typingrule.ptupleconflict" class="anchor"></a>TypingRule.PTupleConflict</h4><h5 id="rule_83"><a href="#rule_83" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> is the pattern which matches a tuple <code>li</code>;</li><li><code>t_struct</code> is the type structure of <code>t</code>;</li><li><code>t_struct</code> is not a tuple type;</li><li>an error &quot;Conflicting Types&quot; is raised.</li></ul><h5 id="examples_87"><a href="#examples_87" class="anchor"></a>Examples</h5><h3 id="typing-of-blocks"><a href="#typing-of-blocks" class="anchor"></a>Typing of Blocks</h3><h4 id="typingrule.block"><a href="#typingrule.block" class="anchor"></a>TypingRule.Block</h4><h5 id="rule_84"><a href="#rule_84" class="anchor"></a>Rule</h5><p><code>annotate_block env return_type s</code> is the result of annotating the statement <code>s</code> in <code>env</code>.</p><h5 id="comments_5"><a href="#comments_5" class="anchor"></a>Comments</h5><p>A local identifier declared with var, let or constant is in scope from the point immediately after its declaration until the end of the immediately enclosing block.</p><p>From that follows that we can discard the environment at the end of an enclosing block.</p><h5 id="examples_88"><a href="#examples_88" class="anchor"></a>Examples</h5><p><code>@asl{
    func main () =&gt; integer
    begin
      if UNKNOWN: boolean then
         let i = 3;
         print (i);
      end
      let i = &quot;Some text&quot;;
      print (i);
      return 0;
    end
    }</code></p><h3 id="typing-of-catchers"><a href="#typing-of-catchers" class="anchor"></a>Typing of Catchers</h3><h4 id="typingrule.catchernone"><a href="#typingrule.catchernone" class="anchor"></a>TypingRule.CatcherNone</h4><p><code>annotate_catchers env return_type (name_opt, ty, stmt)</code> is <code>(name_opt, ty,
  new_stmt)</code> and one of the following applies:</p><h5 id="rule_85"><a href="#rule_85" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ty</code> has the structure of an exception type;</li><li><code>name_opt</code> gives no name;</li><li><code>env'</code> is <code>env</code>;</li><li><code>new_stmt</code> is the result of annotating <code>stmt</code> in <code>env'</code> with <code>return_type</code>.</li></ul><h5 id="examples_89"><a href="#examples_89" class="anchor"></a>Examples</h5><h4 id="typingrule.catchersome"><a href="#typingrule.catchersome" class="anchor"></a>TypingRule.CatcherSome</h4><h5 id="rule_86"><a href="#rule_86" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ty</code> has the structure of an exception type;</li><li><code>name_opt</code> gives a name <code>name</code>;</li><li><code>name</code> is not already declared in <code>env</code>;</li><li><code>name</code> is annotated with <code>ty</code> in <code>env</code>;</li><li><code>env'</code> is <code>env</code> modified to have <code>name</code> locally declared as immutable of type <code>ty</code>;</li><li><code>new_stmt</code> is the result of annotating <code>stmt</code> in <code>env'</code> with <code>return_type</code>.</li></ul><h5 id="examples_90"><a href="#examples_90" class="anchor"></a>Examples</h5><h3 id="typing-of-function-calls"><a href="#typing-of-function-calls" class="anchor"></a>Typing of Function Calls</h3><p><code>annotate_call loc en name args eqs call_type</code> annotates the call to function <code>name</code> with arguments <code>args</code> and parameters <code>eqs</code>. Formally, <code>annotate_call loc
en name args eqs call_type</code> is <code>(name1, args, eqs2, ret_ty1)</code> or an error is raised and one of the following applies:</p><h4 id="typingrule.fcallbadarity"><a href="#typingrule.fcallbadarity" class="anchor"></a>TypingRule.FCallBadArity</h4><h5 id="rule_87"><a href="#rule_87" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>caller_arg_types, args1</code> is the result of annotating <code>args</code> in <code>env</code>;</li><li><code>name</code> is bound in <code>env</code> to a function with a unique name <code>name1</code> whose argument types <code>callee_arg_types</code> type-clash <code>caller_arg_types</code> and whose return type is <code>ret_ty</code>;</li><li><code>eqs1</code> is the list made of both <code>eqs</code> and <code>extra_nargs</code>;</li><li>the lists <code>callee_arg_types</code> and <code>args1</code> do not have the same length;</li><li>an error &quot;Bad Arity&quot; is raised.</li></ul><h5 id="examples_91"><a href="#examples_91" class="anchor"></a>Examples</h5><h4 id="typingrule.fcallgetter"><a href="#typingrule.fcallgetter" class="anchor"></a>TypingRule.FCallGetter</h4><h5 id="rule_88"><a href="#rule_88" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>caller_arg_types, arg1</code> is the result of annotating <code>args</code> in <code>env</code>;</li><li><code>name</code> is bound in <code>env</code> to a function with argument types <code>callee_arg_types</code>;</li><li><code>eqs2</code> is <code>eqs1</code> modified to add all the type equations from the type-clash of <code>caller_arg_types</code> and <code>callee_arg_types</code>;</li><li><code>call_type</code> is a either a function or a getter type;</li><li><code>ret_ty1</code> is the result of renaming <code>ty</code> in <code>eqs2</code>.</li></ul><h5 id="examples_92"><a href="#examples_92" class="anchor"></a>Examples</h5><h4 id="typingrule.fcallsetter"><a href="#typingrule.fcallsetter" class="anchor"></a>TypingRule.FCallSetter</h4><h5 id="rule_89"><a href="#rule_89" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>caller_arg_types, arg1</code> is the result of annotating <code>args</code> in <code>env</code>;</li><li><code>name</code> is bound in <code>env</code> to a function with a unique name <code>name1</code> whose argument types <code>callee_arg_types</code> type-clash <code>caller_arg_types</code> and whose return type is <code>ret_ty</code>;</li><li><code>eqs1</code> is the list made of both <code>eqs</code> and <code>extra_nargs</code>;</li><li><code>eqs2</code> is ;</li><li><code>call_type</code> is a setter or procedure type;</li><li><code>ret_ty</code> is None;</li><li><code>ret_ty1</code> is None.</li></ul><h5 id="examples_93"><a href="#examples_93" class="anchor"></a>Examples</h5><h4 id="typingrule.fcallmismatch"><a href="#typingrule.fcallmismatch" class="anchor"></a>TypingRule.FCallMismatch</h4><h5 id="rule_90"><a href="#rule_90" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>caller_arg_types, arg1</code> is the result of annotating <code>args</code> in <code>env</code>;</li><li><code>extra_nargs, name1, callee_arg_types, ret_ty</code> is the result of trying to find the name <code>name</code> with <code>caller_arg_types</code> in <code>env</code>;</li><li><code>eqs1</code> is the list made of both <code>eqs</code> and <code>extra_nargs</code>;</li><li><code>eqs2</code> is ;</li><li><code>call_type</code> is not a function, getter, setter or procedure type;</li><li>an error &quot;Mismatched Return Value&quot; is raised.</li></ul><h5 id="examples_94"><a href="#examples_94" class="anchor"></a>Examples</h5><h3 id="typing-of-functions"><a href="#typing-of-functions" class="anchor"></a>Typing of Functions</h3><p><code>annotate_func loc env f</code> annotates the function named <code>f</code> and returns <code>f</code>, <code>new_body</code> and <code>name</code>.</p><h4 id="typingrule.func"><a href="#typingrule.func" class="anchor"></a>TypingRule.Func</h4><h5 id="rule_91"><a href="#rule_91" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>env1</code> is <code>env</code> modified to have an empty local environment;</li><li><code>env2</code> is <code>env1</code> with every formal argument declared as immutable with its type;</li><li><code>env3</code> is <code>env2</code> modified to add explicit parameters;</li><li><code>env4</code> is <code>env3</code> modified to resolve dependently typed identifiers in the arguments;</li><li><code>env5</code> is <code>env4</code> modified to resolve dependently typed identifiers in the result type;</li><li><code>body</code> is the body given by <code>f</code>;</li><li><code>new_body</code> is the result of annotating <code>body</code> in <code>env5</code>;</li><li><code>name</code> is the name <code>f</code> as found in <code>env5</code>.</li></ul><h5 id="examples_95"><a href="#examples_95" class="anchor"></a>Examples</h5></div></body></html>