<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ASLSemanticsReference (herdtools7.ASLSemanticsReference)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">herdtools7</a> &#x00BB; ASLSemanticsReference</nav><header class="odoc-preamble"><h1 id="asl-semantics-reference"><a href="#asl-semantics-reference" class="anchor"></a>ASL Semantics Reference</h1></header><nav class="odoc-toc"><ul><li><a href="#disclaimer">Disclaimer</a></li><li><a href="#environments">Environments</a><ul><li><a href="#base-value">Base Value</a></li><li><a href="#initial-environment">Initial environment</a><ul><li><a href="#function-calls">Function Calls</a></li><li><a href="#global-storage">Global Storage</a></li><li><a href="#global-environment">Global Environment</a></li><li><a href="#bind-environment">Bind Environment</a></li></ul></li><li><a href="#scopes">Scopes</a></li></ul></li><li><a href="#evaluation">Evaluation</a><ul><li><a href="#evaluation-of-expressions">Evaluation of Expressions</a><ul><li><a href="#semanticsrule.lit">SemanticsRule.Lit</a><ul><li><a href="#rule">Rule</a></li><li><a href="#example">Example</a></li></ul></li><li><a href="#semanticsrule.typedexpr">SemanticsRule.TypedExpr</a><ul><li><a href="#rule_2">Rule</a></li><li><a href="#example_2">Example</a></li></ul></li><li><a href="#semanticsrule.elocalvar">SemanticsRule.ELocalVar</a><ul><li><a href="#rule_3">Rule</a></li><li><a href="#example_3">Example</a></li></ul></li><li><a href="#semanticsrule.eglobalvar">SemanticsRule.EGlobalVar</a><ul><li><a href="#rule_4">Rule</a></li><li><a href="#example_4">Example</a></li></ul></li><li><a href="#semanticsrule.eundefident">SemanticsRule.EUndefIdent</a><ul><li><a href="#rule_5">Rule</a></li><li><a href="#example_5">Example</a></li></ul></li><li><a href="#semanticsrule.binopand">SemanticsRule.BinopAnd</a><ul><li><a href="#rule_6">Rule</a></li><li><a href="#example_6">Example</a></li></ul></li><li><a href="#semanticsrule.binopor">SemanticsRule.BinopOr</a><ul><li><a href="#rule_7">Rule</a></li><li><a href="#example_7">Example</a></li></ul></li><li><a href="#semanticsrule.binopimpl">SemanticsRule.BinopImpl</a><ul><li><a href="#rule_8">Rule</a></li><li><a href="#example_8">Example</a></li></ul></li><li><a href="#semanticsrule.binop">SemanticsRule.Binop</a><ul><li><a href="#rule_9">Rule</a></li><li><a href="#example_9">Example</a></li></ul></li><li><a href="#semanticsrule.unop">SemanticsRule.Unop</a><ul><li><a href="#rule_10">Rule</a></li><li><a href="#example_10">Example</a></li></ul></li><li><a href="#semanticsrule.econd">SemanticsRule.ECond</a><ul><li><a href="#rule_11">Rule</a></li><li><a href="#example_11">Example</a></li></ul></li><li><a href="#semanticsrule.eslice">SemanticsRule.ESlice</a><ul><li><a href="#rule_12">Rule</a></li><li><a href="#example_12">Example</a></li></ul></li><li><a href="#semanticsrule.ecall">SemanticsRule.ECall</a><ul><li><a href="#rule_13">Rule</a></li><li><a href="#example_13">Example</a></li></ul></li><li><a href="#semanticsrule.egetarray">SemanticsRule.EGetArray</a><ul><li><a href="#rule_14">Rule</a></li><li><a href="#example_14">Example</a></li></ul></li><li><a href="#semanticsrule.erecord">SemanticsRule.ERecord</a><ul><li><a href="#rule_15">Rule</a></li><li><a href="#example_15">Example</a></li></ul></li><li><a href="#semanticsrule.egetfield">SemanticsRule.EGetField</a><ul><li><a href="#rule_16">Rule</a></li><li><a href="#example_16">Example</a></li></ul></li><li><a href="#semanticsrule.egetfields">SemanticsRule.EGetFields</a><ul><li><a href="#rule_17">Rule</a></li><li><a href="#example_17">Example</a></li></ul></li><li><a href="#semanticsrule.econcat">SemanticsRule.EConcat</a><ul><li><a href="#rule_18">Rule</a></li><li><a href="#example_18">Example</a></li></ul></li><li><a href="#semanticsrule.etuple">SemanticsRule.ETuple</a><ul><li><a href="#rule_19">Rule</a></li><li><a href="#example_19">Example</a></li></ul></li><li><a href="#semanticsrule.eunknown">SemanticsRule.EUnknown</a><ul><li><a href="#rule_20">Rule</a></li><li><a href="#example_20">Example</a></li></ul></li><li><a href="#semanticsrule.epattern">SemanticsRule.EPattern</a><ul><li><a href="#rule_21">Rule</a></li><li><a href="#example_21">Example</a></li></ul></li></ul></li><li><a href="#evaluation-of-side-effect-free-expressions">Evaluation of Side-Effect-Free Expressions</a><ul><li><a href="#semanticsrule">SemanticsRule</a></li><li><a href="#example_22">Example</a></li></ul></li><li><a href="#evaluation-of-left-hand-side-expressions">Evaluation of Left-Hand-Side Expressions</a><ul><li><a href="#semanticsrule.leignore">SemanticsRule.LEIgnore</a><ul><li><a href="#rule_22">Rule</a></li><li><a href="#example_23">Example</a></li></ul></li><li><a href="#semanticsrule.lelocalvar">SemanticsRule.LELocalVar</a><ul><li><a href="#rule_23">Rule</a></li><li><a href="#example_24">Example</a></li></ul></li><li><a href="#semanticsrule.leglobalvar">SemanticsRule.LEGlobalVar</a><ul><li><a href="#rule_24">Rule</a></li><li><a href="#example_25">Example</a></li></ul></li><li><a href="#semanticsrule.leundefidentv1">SemanticsRule.LEUndefIdentV1</a><ul><li><a href="#rule_25">Rule</a></li><li><a href="#example_26">Example</a></li></ul></li><li><a href="#semanticsrule.leundefidentv0">SemanticsRule.LEUndefIdentV0</a><ul><li><a href="#rule_26">Rule</a></li><li><a href="#example_27">Example</a></li></ul></li><li><a href="#semanticsrule.leslice">SemanticsRule.LESlice</a><ul><li><a href="#rule_27">Rule</a></li><li><a href="#example_28">Example</a></li></ul></li><li><a href="#semanticsrule.lesetarray">SemanticsRule.LESetArray</a><ul><li><a href="#rule_28">Rule</a></li><li><a href="#example_29">Example</a></li></ul></li><li><a href="#semanticsrule.lesetfield">SemanticsRule.LESetField</a><ul><li><a href="#rule_29">Rule</a></li><li><a href="#example_30">Example</a></li></ul></li><li><a href="#semanticsrule.lesetfields">SemanticsRule.LESetFields</a><ul><li><a href="#rule_30">Rule</a></li><li><a href="#example_31">Example</a></li></ul></li><li><a href="#semanticsrule.letuple">SemanticsRule.LETuple</a><ul><li><a href="#rule_31">Rule</a></li><li><a href="#example_32">Example</a></li></ul></li></ul></li><li><a href="#evaluation-of-expression-lists">Evaluation of Expression Lists</a></li><li><a href="#evaluation-of-slices">Evaluation of Slices</a></li><li><a href="#evaluation-of-patterns">Evaluation of Patterns</a><ul><li><a href="#semanticsrule.pall">SemanticsRule.PAll</a><ul><li><a href="#rule_32">Rule</a></li><li><a href="#example_33">Example</a></li></ul></li><li><a href="#semanticsrule.pany">SemanticsRule.PAny</a><ul><li><a href="#rule_33">Rule</a></li><li><a href="#example_34">Example</a></li></ul></li><li><a href="#semanticsrule.pgeq">SemanticsRule.PGeq</a><ul><li><a href="#rule_34">Rule</a></li><li><a href="#example_35">Example</a></li></ul></li><li><a href="#semanticsrule.pleq">SemanticsRule.PLeq</a><ul><li><a href="#rule_35">Rule</a></li><li><a href="#example_36">Example</a></li></ul></li><li><a href="#semanticsrule.pnot">SemanticsRule.PNot</a><ul><li><a href="#rule_36">Rule</a></li><li><a href="#example_37">Example</a></li></ul></li><li><a href="#semanticsrule.prange">SemanticsRule.PRange</a><ul><li><a href="#rule_37">Rule</a></li><li><a href="#example_38">Example</a></li></ul></li><li><a href="#semanticsrule.psingle">SemanticsRule.PSingle</a><ul><li><a href="#rule_38">Rule</a></li><li><a href="#example_39">Example</a></li></ul></li><li><a href="#semanticsrule.pmask">SemanticsRule.PMask</a><ul><li><a href="#rule_39">Rule</a></li><li><a href="#example_40">Example</a></li></ul></li><li><a href="#semanticsrule.ptuple">SemanticsRule.PTuple</a><ul><li><a href="#rule_40">Rule</a></li><li><a href="#example_41">Example</a></li></ul></li></ul></li><li><a href="#evaluation-of-local-declarations">Evaluation of Local Declarations</a><ul><li><a href="#semanticsrule.ldignore">SemanticsRule.LDIgnore</a><ul><li><a href="#rule_41">Rule</a></li><li><a href="#example_42">Example</a></li></ul></li><li><a href="#semanticsrule.ldvar">SemanticsRule.LDVar</a><ul><li><a href="#rule_42">Rule</a></li><li><a href="#example_43">Example</a></li></ul></li><li><a href="#semanticsrule.ldtypedvar">SemanticsRule.LDTypedVar</a><ul><li><a href="#rule_43">Rule</a></li><li><a href="#example_44">Example</a></li></ul></li><li><a href="#semanticsrule.lduninitialisedvar">SemanticsRule.LDUninitialisedVar</a><ul><li><a href="#rule_44">Rule</a></li><li><a href="#example_45">Example</a></li></ul></li><li><a href="#semanticsrule.ldtuple">SemanticsRule.LDTuple</a><ul><li><a href="#rule_45">Rule</a></li><li><a href="#example_46">Example</a></li></ul></li><li><a href="#semanticsrule.ldtypedtuple">SemanticsRule.LDTypedTuple</a><ul><li><a href="#rule_46">Rule</a></li><li><a href="#example_47">Example</a></li></ul></li><li><a href="#semanticsrule.lduninitialisedtuple">SemanticsRule.LDUninitialisedTuple</a><ul><li><a href="#rule_47">Rule</a></li><li><a href="#example_48">Example</a></li></ul></li></ul></li><li><a href="#evaluation-of-statements">Evaluation of Statements</a><ul><li><a href="#semanticsrule.spass">SemanticsRule.SPass</a><ul><li><a href="#rule_48">Rule</a></li><li><a href="#example_49">Example</a></li></ul></li><li><a href="#semanticsrule.sassign">SemanticsRule.SAssign</a><ul><li><a href="#rule_49">Rule</a></li><li><a href="#example_50">Example</a></li></ul></li><li><a href="#semanticsrule.sassigncall">SemanticsRule.SAssignCall</a><ul><li><a href="#rule_50">Rule</a></li><li><a href="#example_51">Example</a></li></ul></li><li><a href="#semanticsrule.sassigntuple">SemanticsRule.SAssignTuple</a><ul><li><a href="#rule_51">Rule</a></li><li><a href="#example_52">Example</a></li></ul></li><li><a href="#semanticsrule.sreturnnone">SemanticsRule.SReturnNone</a><ul><li><a href="#rule_52">Rule</a></li><li><a href="#example_53">Example</a></li></ul></li><li><a href="#semanticsrule.sreturnone">SemanticsRule.SReturnOne</a><ul><li><a href="#rule_53">Rule</a></li><li><a href="#example_54">Example</a></li></ul></li><li><a href="#semanticsrule.sreturnsome">SemanticsRule.SReturnSome</a><ul><li><a href="#rule_54">Rule</a></li><li><a href="#example_55">Example</a></li></ul></li><li><a href="#semanticsrule.sthen">SemanticsRule.SThen</a><ul><li><a href="#rule_55">Rule</a></li><li><a href="#example_56">Example</a></li></ul></li><li><a href="#semanticsrule.scall">SemanticsRule.SCall</a><ul><li><a href="#rule_56">Rule</a></li><li><a href="#example_57">Example</a></li></ul></li><li><a href="#semanticsrule.scond">SemanticsRule.SCond</a><ul><li><a href="#rule_57">Rule</a></li><li><a href="#example_58">Example</a></li></ul></li><li><a href="#semanticsrule.scase">SemanticsRule.SCase</a><ul><li><a href="#rule_58">Rule</a></li><li><a href="#example_59">Example</a></li></ul></li><li><a href="#semanticsrule.sassert">SemanticsRule.SAssert</a><ul><li><a href="#rule_59">Rule</a></li><li><a href="#example_60">Example</a></li></ul></li><li><a href="#semanticsrule.swhile">SemanticsRule.SWhile</a><ul><li><a href="#rule_60">Rule</a></li><li><a href="#example_61">Example</a></li></ul></li><li><a href="#semanticsrule.srepeat">SemanticsRule.SRepeat</a><ul><li><a href="#rule_61">Rule</a></li><li><a href="#example_62">Example</a></li></ul></li><li><a href="#semanticsrule.sfor">SemanticsRule.SFor</a><ul><li><a href="#rule_62">Rule</a></li><li><a href="#example_63">Example</a></li></ul></li><li><a href="#semanticsrule.sthrownone">SemanticsRule.SThrowNone</a><ul><li><a href="#rule_63">Rule</a></li><li><a href="#example_64">Example</a></li></ul></li><li><a href="#semanticsrule.sthrowsometyped">SemanticsRule.SThrowSomeTyped</a><ul><li><a href="#rule_64">Rule</a></li><li><a href="#example_65">Example</a></li></ul></li><li><a href="#semanticsrule.sthrowsome">SemanticsRule.SThrowSome</a><ul><li><a href="#rule_65">Rule</a></li><li><a href="#example_66">Example</a></li></ul></li><li><a href="#semanticsrule.stry">SemanticsRule.STry</a><ul><li><a href="#rule_66">Rule</a></li><li><a href="#example_67">Example</a></li></ul></li><li><a href="#semanticsrule.sdeclsome">SemanticsRule.SDeclSome</a><ul><li><a href="#rule_67">Rule</a></li><li><a href="#example_68">Example</a></li></ul></li><li><a href="#semanticsrule.sdeclnone">SemanticsRule.SDeclNone</a><ul><li><a href="#rule_68">Rule</a></li><li><a href="#example_69">Example</a></li></ul></li><li><a href="#semanticsrule.sdebug">SemanticsRule.SDebug</a><ul><li><a href="#rule_69">Rule</a></li><li><a href="#example_70">Example</a></li></ul></li></ul></li><li><a href="#evaluation-of-blocks">Evaluation of Blocks</a><ul><li><a href="#semanticsrule.block">SemanticsRule.Block</a><ul><li><a href="#rule_70">Rule</a></li><li><a href="#example_71">Example</a></li></ul></li></ul></li><li><a href="#evaluation-of-while-and-repeat-loops">Evaluation of <code>while</code> and <code>repeat</code> loops</a><ul><li><a href="#semanticsrule.loop">SemanticsRule.Loop</a><ul><li><a href="#rule_71">Rule</a></li><li><a href="#example_72">Example</a></li></ul></li></ul></li><li><a href="#evaluation-of-for-loops">Evaluation of <code>for</code> loops</a><ul><li><a href="#semanticsrule.for">SemanticsRule.For</a><ul><li><a href="#rule_72">Rule</a></li><li><a href="#example_73">Example</a></li></ul></li></ul></li><li><a href="#evaluation-of-catchers">Evaluation of Catchers</a><ul><li><a href="#semanticsrule.catch">SemanticsRule.Catch</a><ul><li><a href="#rule_73">Rule</a></li><li><a href="#example_74">Example</a></li></ul></li><li><a href="#semanticsrule.catchnamed">SemanticsRule.CatchNamed</a><ul><li><a href="#rule_74">Rule</a></li><li><a href="#example_75">Example</a></li></ul></li><li><a href="#semanticsrule.catchotherwise">SemanticsRule.CatchOtherwise</a><ul><li><a href="#rule_75">Rule</a></li><li><a href="#example_76">Example</a></li></ul></li><li><a href="#semanticsrule.catchnone">SemanticsRule.CatchNone</a><ul><li><a href="#rule_76">Rule</a></li><li><a href="#example_77">Example</a></li></ul></li><li><a href="#semanticsrule.catchnothrow">SemanticsRule.CatchNoThrow</a><ul><li><a href="#rule_77">Rule</a></li><li><a href="#example_78">Example</a></li></ul></li></ul></li><li><a href="#evaluation-of-function-calls">Evaluation of Function Calls</a><ul><li><a href="#rule_78">Rule</a></li><li><a href="#example_79">Example</a></li></ul></li><li><a href="#evaluation-of-functions">Evaluation of Functions</a><ul><li><a href="#semanticsrule.fundefident">SemanticsRule.FUndefIdent</a><ul><li><a href="#rule_79">Rule</a></li><li><a href="#example_80">Example</a></li></ul></li><li><a href="#semanticsrule.fprimitive">SemanticsRule.FPrimitive</a><ul><li><a href="#rule_80">Rule</a></li><li><a href="#example_81">Example</a></li></ul></li><li><a href="#semanticsrule.fbadarity">SemanticsRule.FBadArity</a><ul><li><a href="#rule_81">Rule</a></li><li><a href="#example_82">Example</a></li></ul></li><li><a href="#semanticsrule.fcall">SemanticsRule.FCall</a><ul><li><a href="#rule_82">Rule</a></li><li><a href="#example_83">Example</a></li></ul></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="disclaimer"><a href="#disclaimer" class="anchor"></a>Disclaimer</h2><p>This material covers both ASLv0 (viz, the existing ASL pseudocode language which appears in the Arm Architecture Reference Manual) and ASLv1, a new, experimental, and as yet unreleased version of ASL.</p><p>This material is work in progress, more precisely at pre-Alpha quality as per Arm’s quality standards. In particular, this means that it would be premature to base any production tool development on this material.</p><p>However, any feedback, question, query and feature request would be most welcome; those can be sent to Arm’s Architecture Formal Team Lead Jade Alglave &lt;jade.alglave@arm.com&gt; or by raising issues or PRs to the herdtools7 github repository.</p><h2 id="environments"><a href="#environments" class="anchor"></a>Environments</h2><p>An environment is what the semantics operates over: a structure which amongst other things associates values to variables. Intuitively, the evaluation of a program makes an initial environment evolve, with new values as given by the operations of the program.</p><h3 id="base-value"><a href="#base-value" class="anchor"></a>Base Value</h3><p><code>base_value</code> &lt;description, minimal example&gt;</p><h3 id="initial-environment"><a href="#initial-environment" class="anchor"></a>Initial environment</h3><p>The initial environment is built with the help of the <code>build_&lt;object&gt;</code> functions. Each <code>build_&lt;object&gt;</code> function builds a specific object, as follows.</p><h4 id="function-calls"><a href="#function-calls" class="anchor"></a>Function Calls</h4><p><code>build_func_call_ref</code> &lt;description, minimal example&gt;</p><h4 id="global-storage"><a href="#global-storage" class="anchor"></a>Global Storage</h4><p><code>build_global_storage</code> &lt;description, minimal example&gt;</p><h4 id="global-environment"><a href="#global-environment" class="anchor"></a>Global Environment</h4><p><code>build_global_env</code> &lt;description, minimal example&gt;</p><h4 id="bind-environment"><a href="#bind-environment" class="anchor"></a>Bind Environment</h4><p><code>bind_env</code>, also written <code>let*^</code>, &lt;description, minimal example&gt;</p><h3 id="scopes"><a href="#scopes" class="anchor"></a>Scopes</h3><p><code>push_scope</code> pushes a new scope on the declaration stack. Variables declared here will be stored until the corresponding <code>pop_scope</code>.</p><p><code>pop_scope old new</code> restores the variable bindings of <code>old</code>, with the updated values of <code>new</code>.</p><h2 id="evaluation"><a href="#evaluation" class="anchor"></a>Evaluation</h2><p>Evaluating a program is evaluating its main function. Constructively, evaluating a program requires following its Abstract Syntax Tree and evaluating each of its components.</p><p>Formally, the semantics of a program are given by applying a set of eval_&lt;object&gt; functions. Each eval_&lt;object&gt; function describes how to evaluate a specific object, as follows.</p><ul><li><code>eval_expr</code> evaluates expressions: it takes an environment and an expression and returns a wrapped value and a new environment;</li><li><code>eval_expr_sef</code> evaluates expressions without side effects;</li><li><code>eval_expr_list</code> and <code>eval_expr_list_m</code> evaluate lists of expressions;</li><li><code>eval_slices</code> evaluates slices;</li><li><code>eval_patterns</code> evaluates patterns;</li><li><code>eval_local_decl</code> evaluates local declarations;</li><li><code>eval_lexpr</code> evaluates left-hand sides of assignments: it takes an environment, the left-hand side of an assignment and a wrapped value to be written, and returns a wrapped environment updated with the new value;</li><li><code>eval_stmt</code> evaluates statements: it takes an environment and a statement and returns a wrapped new environment, viz, the environment updated with the side-effects of the statement;</li><li><code>eval_block</code> evaluates blocks;</li><li><code>eval_loop</code> evaluates both while and repeat loops;</li><li><code>eval_for</code> evaluates for loops;</li><li><code>eval_catchers</code> evaluates catchers;</li><li><code>eval_call</code> evaluates functions calls;</li><li><code>eval_func</code> evaluates functions: it takes an environment, a function name and its arguments, and returns a wrapped list of the return values of the function. The evaluation of a program is the evaluation of its main function.</li></ul><h3 id="evaluation-of-expressions"><a href="#evaluation-of-expressions" class="anchor"></a>Evaluation of Expressions</h3><p><code>eval_expr</code> specifies how to evaluate an expression <code>e</code> in an environment <code>env</code>. More precisely, <code>eval_expr env e</code> is the monadic evaluation of <code>e</code> in <code>env</code>.</p><p>Evaluation of the expression <code>e</code> under an environment <code>env</code> is either a value <code>v</code> or an error and one of the following applies:</p><h4 id="semanticsrule.lit"><a href="#semanticsrule.lit" class="anchor"></a>SemanticsRule.Lit</h4><h5 id="rule"><a href="#rule" class="anchor"></a>Rule</h5><p><code>e</code> denotes a Literal <code>l</code> and <code>v</code> is the value of <code>l</code> in <code>env</code>.</p><h5 id="example"><a href="#example" class="anchor"></a>Example</h5><p>The expression <code>3</code> evaluates to the value <code>3</code>.</p><h4 id="semanticsrule.typedexpr"><a href="#semanticsrule.typedexpr" class="anchor"></a>SemanticsRule.TypedExpr</h4><h5 id="rule_2"><a href="#rule_2" class="anchor"></a>Rule</h5><p><code>(e,_t)</code> denotes a typed expression and &lt;description&gt;</p><h5 id="example_2"><a href="#example_2" class="anchor"></a>Example</h5><p>The expression <code>(3 as integer)</code> evaluates to the value <code>3</code>.</p><p>The expression <code>(3 as integer {5:7})</code> raises a &quot;Mismatched Value&quot; error.</p><h4 id="semanticsrule.elocalvar"><a href="#semanticsrule.elocalvar" class="anchor"></a>SemanticsRule.ELocalVar</h4><h5 id="rule_3"><a href="#rule_3" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a variable <code>x</code> which is bound locally in <code>env</code>;</li><li><code>v</code> is the value of <code>x</code> in <code>env</code>.</li></ul><h5 id="example_3"><a href="#example_3" class="anchor"></a>Example</h5><p><code>
  func main () =&gt; integer
  begin
    var x: integer = 3;
    assert x == 3;
    return 0;
  end  
  </code></p><p>The evaluation of <code>x</code> within <code>assert x == 3</code>; uses ELocalVar.</p><h4 id="semanticsrule.eglobalvar"><a href="#semanticsrule.eglobalvar" class="anchor"></a>SemanticsRule.EGlobalVar</h4><h5 id="rule_4"><a href="#rule_4" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a variable <code>x</code> which is bound globally in <code>env</code>;</li><li><code>v</code> is the value of <code>x</code> in <code>env</code>.</li></ul><h5 id="example_4"><a href="#example_4" class="anchor"></a>Example</h5><p><code>
   var global_x: integer = 3;
   func main () =&gt; integer
   begin
     assert global_x == 3;
     return 0;
   end
  </code></p><p>The evaluation of <code>global_x</code> within <code>assert global_x == 3;</code> uses EGlobalVar.</p><p><code>
   var x: integer = 3;
   func main () =&gt; integer
   begin
     assert x == 3;
   end
  </code></p><p>This raises a type error because <code>x</code> is already declared locally in <code>stdlib.asl</code>.</p><h4 id="semanticsrule.eundefident"><a href="#semanticsrule.eundefident" class="anchor"></a>SemanticsRule.EUndefIdent</h4><h5 id="rule_5"><a href="#rule_5" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a variable <code>x</code> which is not bound in <code>env</code>;</li><li>an Error &quot;UndefinedIdentifier&quot; is raised.</li></ul><h5 id="example_5"><a href="#example_5" class="anchor"></a>Example</h5><p><code>
  func main () =&gt; integer
  begin
    let x = 42;
    print(y);
    return 0;
  end
  </code> raises an Undefined Identifier error: the variable <code>y</code> is undefined in the environment <code>x → 42</code>.</p><h4 id="semanticsrule.binopand"><a href="#semanticsrule.binopand" class="anchor"></a>SemanticsRule.BinopAnd</h4><h5 id="rule_6"><a href="#rule_6" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a conjunction over two expressions <code>e1</code> and <code>e2</code>;</li><li><code>e</code> is evaluated as <code>if e1 then e2 else false</code>.</li></ul><h5 id="example_6"><a href="#example_6" class="anchor"></a>Example</h5><h4 id="semanticsrule.binopor"><a href="#semanticsrule.binopor" class="anchor"></a>SemanticsRule.BinopOr</h4><h5 id="rule_7"><a href="#rule_7" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a disjunction over two expressions <code>e1</code> and <code>e2</code>;</li><li><code>e</code> is evaluated as <code>if e1 then true else e2</code>.</li></ul><h5 id="example_7"><a href="#example_7" class="anchor"></a>Example</h5><h4 id="semanticsrule.binopimpl"><a href="#semanticsrule.binopimpl" class="anchor"></a>SemanticsRule.BinopImpl</h4><h5 id="rule_8"><a href="#rule_8" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes an implication over two expressions <code>e1</code> and <code>e2</code>;</li><li><code>e</code> is evaluated as <code>if e1 then e2 else true</code>.</li></ul><h5 id="example_8"><a href="#example_8" class="anchor"></a>Example</h5><h4 id="semanticsrule.binop"><a href="#semanticsrule.binop" class="anchor"></a>SemanticsRule.Binop</h4><h5 id="rule_9"><a href="#rule_9" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a Binary Operator <code>op</code> over two expressions <code>e1</code> and <code>e2</code>;</li><li>The evaluation of the expression <code>e1</code> under <code>env</code> is <code>v1</code>;</li><li>The evaluation of the expression <code>e2</code> under <code>env</code> is <code>v2</code>;</li><li><code>v</code> is the result of applying the Binary Operator <code>op</code> to <code>v1</code> and <code>v2</code>.</li></ul><h5 id="example_9"><a href="#example_9" class="anchor"></a>Example</h5><p>In this program: <code>
  func main () =&gt; integer
  begin
    let x = 3 + 2;
    assert(x==5);
    return 0;
  end
  </code> The expression <code>3 + 2</code> evaluates to the value <code>5</code>.</p><p>For the program: <code>
  func main () =&gt; integer
  begin
    let x = 3 DIV 0;
    return 0;
  end
  </code></p><p>Without type-checking, the expression <code>3 DIV 0</code> raises a backend-defined error, e.g. <code>
  ASL Execution error: Illegal application of operator DIV for values 3 and 0.
  </code>.</p><p>With type-checking, the expression <code>3 DIV 0</code> raises a type error.</p><h4 id="semanticsrule.unop"><a href="#semanticsrule.unop" class="anchor"></a>SemanticsRule.Unop</h4><h5 id="rule_10"><a href="#rule_10" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a Unary Operator <code>op</code> over an expression <code>e</code>;</li><li>The evaluation of the expression <code>e</code> under <code>env</code> is <code>t</code>;</li><li><code>v</code> is the result of applying the Unary Operator <code>op</code> to <code>t</code>.</li></ul><h5 id="example_10"><a href="#example_10" class="anchor"></a>Example</h5><p>The expression <code>NOT '1010'</code> evaluates to the value <code>'0101'</code>.</p><h4 id="semanticsrule.econd"><a href="#semanticsrule.econd" class="anchor"></a>SemanticsRule.ECond</h4><h5 id="rule_11"><a href="#rule_11" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a condition <code>e_cond</code> with two options <code>e1</code> and <code>e2</code>;</li><li>The evaluation of the condition <code>e_cond</code> under <code>env</code> is <code>m_cond</code>;</li><li>One of <code>e1</code> or <code>e2</code> is not a simple expression;</li><li>The evaluation of <code>e1</code> or <code>e2</code>, depending on <code>m_cond</code>, is <code>v</code>.</li></ul><h5 id="example_11"><a href="#example_11" class="anchor"></a>Example</h5><p>In the program: <code>
  func Return42() =&gt; integer
  begin
    return 42;
  end
  func main () =&gt; integer
  begin
    let x = if FALSE then Return42() else 3;
    assert(x==3);
    return 0;
  end
  </code> The expression <code>if FALSE then Return42() else 3</code> evaluates to the value <code>3</code>.</p><p>In the program: <code>
  func Return42() =&gt; integer
  begin
    return 42;
  end
  func main () =&gt; integer
  begin
    let x = if UNKNOWN: boolean then 3 else Return42();
    assert(x==3);
    return 0;
  end
  </code> The expression <code>if UNKNOWN: boolean then 3 else Return42()</code> will evaluate either <code>3</code> or <code>Return42()</code> depending on how UNKNOWN is implemented.</p><h4 id="semanticsrule.eslice"><a href="#semanticsrule.eslice" class="anchor"></a>SemanticsRule.ESlice</h4><h5 id="rule_12"><a href="#rule_12" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes an expression <code>e_bv</code> sliced as per <code>slices</code>;</li><li>The evaluation of <code>e_bv</code> under <code>env</code> is <code>v_bv</code>;</li><li>The evaluation of <code>slices</code> under <code>env</code> is <code>positions</code>;</li><li><code>v</code> is the value read in <code>v_bv</code> from <code>positions</code>.</li></ul><h5 id="example_12"><a href="#example_12" class="anchor"></a>Example</h5><p>The expression <code>'11110000'[5:2]</code> evaluates to the value <code>'1100'</code>.</p><h4 id="semanticsrule.ecall"><a href="#semanticsrule.ecall" class="anchor"></a>SemanticsRule.ECall</h4><h5 id="rule_13"><a href="#rule_13" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a function call <code>(name, actual_args, params)</code>;</li><li>The evaluation of that function call under <code>env</code> is <code>ms</code>;</li><li><code>v</code> is the value read from <code>ms</code>.</li></ul><h5 id="example_13"><a href="#example_13" class="anchor"></a>Example</h5><p>In the program: <code>
  func Return42() =&gt; integer
  begin
    return 42;
  end
  func main () =&gt; integer
  begin
    let x = Return42();
    assert(x==42);
    return 0;
  end
  </code> The expression <code>Return42()</code> evaluates to the value <code>42</code> because the function <code>Return42()</code> is implemented to return the value <code>42</code>.</p><h4 id="semanticsrule.egetarray"><a href="#semanticsrule.egetarray" class="anchor"></a>SemanticsRule.EGetArray</h4><h5 id="rule_14"><a href="#rule_14" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes an array <code>e_array</code> and an index <code>e_index</code>;</li><li>The evaluation of <code>e_array</code> under <code>env</code> is <code>v_array</code>;</li><li>The evaluation of <code>e_index</code> under <code>env</code> is <code>v_index</code>;</li><li><code>v</code> is the value found at the index <code>v_index</code> of <code>v_array</code>.</li></ul><h5 id="example_14"><a href="#example_14" class="anchor"></a>Example</h5><p>In the program: <code>
  type MyArrayType of array [3] of integer;
  var my_array : MyArrayType;  
  func main () =&gt; integer
  begin
    my_array[2]=42;
    assert(my_array[2]==42);
    return 0;
  end
  </code> The expression <code>my_array[2]</code> evaluates to the value <code>42</code> since the element indexed by <code>2</code> in <code>my_array</code> is <code>42</code>.</p><p>The program: <code>
  type MyArrayType of array [3] of integer;
  var my_array : MyArrayType;  
  func main () =&gt; integer
  begin
    my_array[3]=42;
    assert(my_array[3]==42);
    return 0;
  end
  </code> raises a typing error since we are trying to access index <code>3</code> of an array which has indexes <code>0</code>, <code>1</code> and <code>2</code> only.</p><h4 id="semanticsrule.erecord"><a href="#semanticsrule.erecord" class="anchor"></a>SemanticsRule.ERecord</h4><h5 id="rule_15"><a href="#rule_15" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a series of field names <code>names</code> and associated expressions <code>fields</code>;</li><li><code>fields</code> evaluates in <code>env</code> to <code>v_fields</code>;</li><li><code>v</code> is the record built by associating the names <code>names</code> to <code>v_fields</code>.</li></ul><h5 id="example_15"><a href="#example_15" class="anchor"></a>Example</h5><p>The expression <code>MyRecordType { a: 3, b: 42 }</code> evaluates to the value <code>{a: 3, b: 42}</code>.</p><h4 id="semanticsrule.egetfield"><a href="#semanticsrule.egetfield" class="anchor"></a>SemanticsRule.EGetField</h4><h5 id="rule_16"><a href="#rule_16" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a field name <code>field_name</code> in a vector <code>e_vec</code>;</li><li>the evaluation of <code>e_vec</code> in <code>env</code> is <code>v_vec</code>;</li><li><code>v</code> is the value mapped by <code>field_name</code> in <code>v_vec</code>.</li></ul><h5 id="example_16"><a href="#example_16" class="anchor"></a>Example</h5><p>In the program: <code>
  type MyRecordType of record {a: integer, b: integer};
  func main () =&gt; integer
  begin
    let my_record = MyRecordType{a=3, b=42};
    assert(my_record.a==3);
    return 0;
  end
  </code> The expression <code>(MyRecordType{a=3, b=42}).a</code> evaluates to the value <code>3</code>.</p><h4 id="semanticsrule.egetfields"><a href="#semanticsrule.egetfields" class="anchor"></a>SemanticsRule.EGetFields</h4><h5 id="rule_17"><a href="#rule_17" class="anchor"></a>Rule</h5><p>&lt;description&gt;</p><h5 id="example_17"><a href="#example_17" class="anchor"></a>Example</h5><p>&lt;minimal example&gt;</p><h4 id="semanticsrule.econcat"><a href="#semanticsrule.econcat" class="anchor"></a>SemanticsRule.EConcat</h4><h5 id="rule_18"><a href="#rule_18" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a list of expressions <code>e_list</code>;</li><li>the evaluation of <code>e_list</code> in <code>env</code> is <code>v_list</code>;</li><li><code>v</code> is the concatenation of <code>v_list</code>.</li></ul><h5 id="example_18"><a href="#example_18" class="anchor"></a>Example</h5><p>In the program: <code>
  func main () =&gt; integer
  begin
    let x = [['10','11']];
    assert(x=='1011');
    return 0;
  end
  </code> The expression <code>['10', '11']</code> evaluates to the value <code>'1011'</code>.</p><h4 id="semanticsrule.etuple"><a href="#semanticsrule.etuple" class="anchor"></a>SemanticsRule.ETuple</h4><h5 id="rule_19"><a href="#rule_19" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a list of expression <code>e_list</code>;</li><li>the evaluation of <code>e_list</code> in <code>env</code> is <code>v_list</code>;</li><li><code>v</code> is the vector built from <code>v_list</code>.</li></ul><h5 id="example_19"><a href="#example_19" class="anchor"></a>Example</h5><p>In the program: <code>
  func Return42() =&gt; integer
  begin
    return 42;
  end
  func main () =&gt; integer
  begin
    let (x,y) = (3, Return42());
    assert(x==3);
    assert(y==42);
    return 0;
  end
  </code> The expression <code>(3, Return42())</code> evaluates to the value <code>(3, 42)</code>.</p><h4 id="semanticsrule.eunknown"><a href="#semanticsrule.eunknown" class="anchor"></a>SemanticsRule.EUnknown</h4><h5 id="rule_20"><a href="#rule_20" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a type <code>t</code>;</li><li><code>v</code> is a value in the domain of <code>t</code>.</li></ul><h5 id="example_20"><a href="#example_20" class="anchor"></a>Example</h5><p>In the program: <code>
  func main () =&gt; integer
  begin
    let x = UNKNOWN:integer;
    assert(x==3);
    return 0;
  end
  </code> The expression <code>UNKNOWN : integer</code> evaluates to an integer value.</p><p>In the program: <code>
  func main () =&gt; integer
  begin
    let x = UNKNOWN:integer {3, 42};
    assert(x==3);
    return 0;
  end
  </code> The expression <code>UNKNOWN : integer {3, 42}</code> evaluates to either the value <code>3</code> or the value <code>42</code>.</p><h4 id="semanticsrule.epattern"><a href="#semanticsrule.epattern" class="anchor"></a>SemanticsRule.EPattern</h4><h5 id="rule_21"><a href="#rule_21" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>e</code> denotes a pattern <code>e,p</code>;</li><li><code>v</code> is the boolean determining whether the evaluation of <code>e</code> in <code>env</code> matches <code>p</code>.</li></ul><h5 id="example_21"><a href="#example_21" class="anchor"></a>Example</h5><p>In the program: <code>
  func main () =&gt; integer
  begin
    let x = 42 IN {0..3, -4};
    assert x == FALSE;
    return 0;
  end
  </code> The expression <code>42 IN {0..3, -4}</code> evaluates to the value <code>FALSE</code>.</p><p>In the program: <code>
  func main () =&gt; integer
  begin
    let x = 42 IN {0..3, 42};
    assert x == TRUE;
    return 0;
  end
  </code> The expression <code>42 IN {0..3, 42}</code> evaluates to <code>TRUE</code>.</p><h3 id="evaluation-of-side-effect-free-expressions"><a href="#evaluation-of-side-effect-free-expressions" class="anchor"></a>Evaluation of Side-Effect-Free Expressions</h3><h4 id="semanticsrule"><a href="#semanticsrule" class="anchor"></a>SemanticsRule</h4><p><code>eval_expr_sef</code> specifies how to evaluate a side-effect-free expression <code>e</code> in an environment <code>env</code>. More precisely, <code>eval_expr_sef env e</code> is <code>eval_expr
   env e</code>, if e is side-effect-free.</p><h4 id="example_22"><a href="#example_22" class="anchor"></a>Example</h4><p>&lt;minimal example&gt;</p><h3 id="evaluation-of-left-hand-side-expressions"><a href="#evaluation-of-left-hand-side-expressions" class="anchor"></a>Evaluation of Left-Hand-Side Expressions</h3><p><code>eval_lexpr version env le m</code> is <code>env[le --&gt; m]</code>.</p><p>The evaluation of the left-hand-side expression <code>le</code> associated with a value <code>v</code> under an environment <code>env</code> is either <code>new_env</code> or an error is raised and one of the following applies:</p><h4 id="semanticsrule.leignore"><a href="#semanticsrule.leignore" class="anchor"></a>SemanticsRule.LEIgnore</h4><h5 id="rule_22"><a href="#rule_22" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> can be ignored;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="example_23"><a href="#example_23" class="anchor"></a>Example</h5><p>The left-hand-side expression <code>-</code> within <code>- = 42;</code> evaluates to the value <code>42</code>.</p><h4 id="semanticsrule.lelocalvar"><a href="#semanticsrule.lelocalvar" class="anchor"></a>SemanticsRule.LELocalVar</h4><h5 id="rule_23"><a href="#rule_23" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes a variable <code>x</code>;</li><li><code>x</code> is locally bound in <code>env</code>;</li><li><code>new_env</code> is <code>env</code> where <code>x</code> has been assigned the value <code>v</code>.</li></ul><h5 id="example_24"><a href="#example_24" class="anchor"></a>Example</h5><p><code>
     func main () =&gt; integer
     begin
       var x: integer = 3;
       x = 42;
     end
    </code> The evaluation of the left-hand-side expression <code>x</code> within <code>x = 42;</code> uses Rule.LELocalVar.</p><h4 id="semanticsrule.leglobalvar"><a href="#semanticsrule.leglobalvar" class="anchor"></a>SemanticsRule.LEGlobalVar</h4><h5 id="rule_24"><a href="#rule_24" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes a variable <code>x</code>;</li><li><code>x</code> is globally bound in <code>env</code>;</li><li><code>new_env</code> is <code>env</code> where <code>x</code> has been assigned the value <code>v</code>.</li></ul><h5 id="example_25"><a href="#example_25" class="anchor"></a>Example</h5><p><code>
     var x: integer = 3;
     func main () =&gt; integer
     begin
       x = 42;
     end
    </code></p><p>The evaluation of the left-hand-side expression <code>x</code> within <code>x = 42;</code> uses Rule.LEGlobalVar.</p><h4 id="semanticsrule.leundefidentv1"><a href="#semanticsrule.leundefidentv1" class="anchor"></a>SemanticsRule.LEUndefIdentV1</h4><h5 id="rule_25"><a href="#rule_25" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes a variable <code>x</code> which is not bound in <code>env</code>;</li><li>the ASL language version is V1;</li><li>an Error &quot;UndefinedIdentifier&quot; is raised.</li></ul><h5 id="example_26"><a href="#example_26" class="anchor"></a>Example</h5><p>The evaluation of the left-hand-side expression <code>y</code> within <code>y = 3;</code> raises an &quot;Undefined Identifier&quot; error in the environment <code>x ⟶ 42</code>.</p><h4 id="semanticsrule.leundefidentv0"><a href="#semanticsrule.leundefidentv0" class="anchor"></a>SemanticsRule.LEUndefIdentV0</h4><h5 id="rule_26"><a href="#rule_26" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes a variable <code>x</code> which is not bound in <code>env</code>;</li><li>the ASL language version is V0;</li><li><code>new_env</code> is <code>env</code> where <code>x</code> has been declared a local identifier bound to the value <code>v</code>.</li></ul><h5 id="example_27"><a href="#example_27" class="anchor"></a>Example</h5><p><code>y = 3;</code> binds <code>y</code> to <code>3</code> in <code>x ⟶ 42</code> (<code>new_env</code> is here <code>y ⟶ 3, x ⟶ 42</code>).</p><h4 id="semanticsrule.leslice"><a href="#semanticsrule.leslice" class="anchor"></a>SemanticsRule.LESlice</h4><h5 id="rule_27"><a href="#rule_27" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes a left-hand-side expression sliced as per <code>slices</code>;</li><li>The right-hand-side expression corresponding to <code>le</code> is <code>e_bv</code>;</li><li>The evaluation of <code>re_bv</code> under <code>env</code> is <code>rv_bv</code>;</li><li>The evaluation of <code>slices</code> under <code>env</code> is <code>positions</code>;</li><li><code>new_m_bv</code> is <code>rv_bv</code> where the positions <code>positions</code> have been updated to <code>v</code></li><li><code>new_env</code> is <code>env</code> where <code>le</code> has been assigned the value <code>new_m_bv</code>.</li></ul><h5 id="example_28"><a href="#example_28" class="anchor"></a>Example</h5><p><code>x[3:0] = '0000'</code> binds <code>x</code> to <code>'11110000'</code> in <code>x ⟶ '11111111'</code>.</p><h4 id="semanticsrule.lesetarray"><a href="#semanticsrule.lesetarray" class="anchor"></a>SemanticsRule.LESetArray</h4><h5 id="rule_28"><a href="#rule_28" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes an array <code>le_array</code> and an index <code>e_index</code>;</li><li>The right-hand-side expression corresponding to <code>le_array</code> is <code>re_array</code>;</li><li>The evaluation of <code>re_array</code> under <code>env</code> is <code>rv_array</code>;</li><li>The evaluation of <code>e_index</code> under <code>env</code> is <code>v_index</code>;</li><li><code>new_v_array</code> is <code>rv_array</code> where the value at index <code>v_index</code> has been updated to <code>v</code>;</li><li><code>new_env</code> is <code>env</code> where <code>le_array</code> has been assigned the value <code>new_v_array</code>.</li></ul><h5 id="example_29"><a href="#example_29" class="anchor"></a>Example</h5><p><code>
     var my_array: array [42] of integer;
     my_array[3] = 53;
    </code> binds the <code>3rd</code> element of <code>my_array</code> to the value <code>53</code>.</p><h4 id="semanticsrule.lesetfield"><a href="#semanticsrule.lesetfield" class="anchor"></a>SemanticsRule.LESetField</h4><h5 id="rule_29"><a href="#rule_29" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes a field name <code>field_name</code> in a record <code>le_record</code>;</li><li>The right-hand-side expression corresponding to <code>le_record</code> is <code>re_record</code>;</li><li>The evaluation of <code>re_record</code> under <code>env</code> is <code>rv_record</code>;</li><li><code>new_v_record</code> is <code>rv_record</code> where the field <code>field_name</code> has been updated to <code>v</code>;</li><li><code>new_env</code> is <code>env</code> where <code>le_record</code> has been assigned the value <code>new_v_record</code>.</li></ul><h5 id="example_30"><a href="#example_30" class="anchor"></a>Example</h5><p><code>my_record.a = 42;</code> binds <code>my_record</code> to <code>{a: 42, b: 42}</code> in the environment <code>my_record ⟶ {a: 3, b: 42}</code>.</p><h4 id="semanticsrule.lesetfields"><a href="#semanticsrule.lesetfields" class="anchor"></a>SemanticsRule.LESetFields</h4><h5 id="rule_30"><a href="#rule_30" class="anchor"></a>Rule</h5><p>&lt;description&gt;</p><h5 id="example_31"><a href="#example_31" class="anchor"></a>Example</h5><p>&lt;minimal example&gt;</p><h4 id="semanticsrule.letuple"><a href="#semanticsrule.letuple" class="anchor"></a>SemanticsRule.LETuple</h4><h5 id="rule_31"><a href="#rule_31" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>le</code> denotes a list of left-hand-side expressions <code>le_list</code>;</li><li><code>new_env</code> is <code>env</code> where each left-hand-side expression in <code>le_list</code> has been assigned the value at the corresponding index in <code>v</code>.</li></ul><h5 id="example_32"><a href="#example_32" class="anchor"></a>Example</h5><p><code>(x, y) = (3, 42)</code> binds <code>x</code> to <code>3</code> and <code>y</code> to <code>42</code> in the environment <code>x ⟶ 42, y ⟶ 3</code>.</p><h3 id="evaluation-of-expression-lists"><a href="#evaluation-of-expression-lists" class="anchor"></a>Evaluation of Expression Lists</h3><p>&lt;description&gt; &lt;minimal example&gt;</p><h3 id="evaluation-of-slices"><a href="#evaluation-of-slices" class="anchor"></a>Evaluation of Slices</h3><p><code>eval_slices env slices</code> is the list of pair <code>(i_n, l_n)</code> that corresponds to the start (included) and the length of each slice in <code>slices</code>.</p><p><code>[3:2]</code> evaluates to <code>[(2, 2)]</code>.</p><p><code>[3:2, 42+:5]</code> evaluates to <code>[(2, 2), (42, 5)]</code>.</p><h3 id="evaluation-of-patterns"><a href="#evaluation-of-patterns" class="anchor"></a>Evaluation of Patterns</h3><p><code>eval_pattern env pos v p</code> determines if <code>v</code> matches the pattern <code>p</code>. Formally, one of the following applies:</p><h4 id="semanticsrule.pall"><a href="#semanticsrule.pall" class="anchor"></a>SemanticsRule.PAll</h4><h5 id="rule_32"><a href="#rule_32" class="anchor"></a>Rule</h5><p><code>p</code> is the pattern which matches everything.</p><h5 id="example_33"><a href="#example_33" class="anchor"></a>Example</h5><p><code>42 IN { - }</code> evaluates to <code>true</code>.</p><h4 id="semanticsrule.pany"><a href="#semanticsrule.pany" class="anchor"></a>SemanticsRule.PAny</h4><h5 id="rule_33"><a href="#rule_33" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> gives a list of patterns <code>li_patterns</code>;</li><li><code>v</code> is a record of values <code>li_values</code>;</li><li>each value in <code>li_values</code> matches the corresponding pattern in <code>li_patterns</code> in <code>env</code>.</li></ul><h5 id="example_34"><a href="#example_34" class="anchor"></a>Example</h5><p><code>42 IN { 3, 42 }</code> evaluates to <code>true</code>.</p><p><code>42 IN { 3, 4 }</code> evaluates to <code>false</code>.</p><h4 id="semanticsrule.pgeq"><a href="#semanticsrule.pgeq" class="anchor"></a>SemanticsRule.PGeq</h4><h5 id="rule_34"><a href="#rule_34" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> gives a side-effect-free expression <code>e</code>;</li><li><code>v</code> is greater than or equal to the evaluation of <code>e</code> in <code>env</code>.</li></ul><h5 id="example_35"><a href="#example_35" class="anchor"></a>Example</h5><p><code>42 IN { &gt;= 3 }</code> evaluates to <code>true</code>.</p><p><code>3 IN { &gt;= 42 }</code> evaluates to <code>false</code>.</p><h4 id="semanticsrule.pleq"><a href="#semanticsrule.pleq" class="anchor"></a>SemanticsRule.PLeq</h4><h5 id="rule_35"><a href="#rule_35" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> gives a side-effect-free expression <code>e</code>;</li><li><code>v</code> is lesser than or equal to the evaluation of <code>e</code> in <code>env</code>.</li></ul><h5 id="example_36"><a href="#example_36" class="anchor"></a>Example</h5><p><code>3 IN { &lt;= 42 }</code> evaluatest to <code>true</code>.</p><p><code>42 IN { &lt;= 3 }</code> evaluatest to <code>false</code>.</p><h4 id="semanticsrule.pnot"><a href="#semanticsrule.pnot" class="anchor"></a>SemanticsRule.PNot</h4><h5 id="rule_36"><a href="#rule_36" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> gives a pattern <code>p'</code>;</li><li><code>v</code> matches the negation of <code>p'</code> in <code>env</code>.</li></ul><h5 id="example_37"><a href="#example_37" class="anchor"></a>Example</h5><p><code>42 IN !{ 3 }</code> evaluates to <code>true</code>.</p><p><code>42 IN !{ 42 }</code> evaluates to <code>false</code>.</p><h4 id="semanticsrule.prange"><a href="#semanticsrule.prange" class="anchor"></a>SemanticsRule.PRange</h4><h5 id="rule_37"><a href="#rule_37" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> gives two side-effect-free expressions <code>e1</code> and <code>e2</code>;</li><li><code>v</code> is greater than or equal to <code>e1</code> in <code>env</code>;</li><li><code>v</code> is lesser than or equal to <code>e2</code> in <code>env</code>.</li></ul><h5 id="example_38"><a href="#example_38" class="anchor"></a>Example</h5><p><code>42 IN {3..42}</code> evaluates to <code>true</code>.</p><p><code>-3 IN {3..42}</code> evaluates to <code>false</code>.</p><h4 id="semanticsrule.psingle"><a href="#semanticsrule.psingle" class="anchor"></a>SemanticsRule.PSingle</h4><h5 id="rule_38"><a href="#rule_38" class="anchor"></a>Rule</h5><p>All of the following appplies:</p><ul><li><code>p</code> gives a side-effect-free expression <code>e</code>;</li><li><code>v</code> is equal to the evaluation of <code>e</code> in <code>env</code>.</li></ul><h5 id="example_39"><a href="#example_39" class="anchor"></a>Example</h5><p><code>42 IN { 3 }</code> evaluates to <code>false</code>.</p><h4 id="semanticsrule.pmask"><a href="#semanticsrule.pmask" class="anchor"></a>SemanticsRule.PMask</h4><h5 id="rule_39"><a href="#rule_39" class="anchor"></a>Rule</h5><p>All the following applies:</p><ul><li><code>p</code> gives a mask <code>m</code></li><li><code>v</code> is a bitvector that matches the mask <code>m</code></li></ul><h5 id="example_40"><a href="#example_40" class="anchor"></a>Example</h5><p><code>'101010' IN 'xx1010'</code> evaluates to <code>true</code>.</p><p><code>'101010' IN '0x1010'</code> evaluates to <code>false</code>.</p><h4 id="semanticsrule.ptuple"><a href="#semanticsrule.ptuple" class="anchor"></a>SemanticsRule.PTuple</h4><h5 id="rule_40"><a href="#rule_40" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>p</code> gives a list of patterns <code>li</code>;</li><li><code>v</code> matches the evaluation of all the patterns in the list <code>li</code> in <code>env</code>.</li></ul><h5 id="example_41"><a href="#example_41" class="anchor"></a>Example</h5><p><code>(3, '101010') IN {( &lt;= 42, 'xx1010')}</code> evaluates to <code>true</code>.</p><h3 id="evaluation-of-local-declarations"><a href="#evaluation-of-local-declarations" class="anchor"></a>Evaluation of Local Declarations</h3><p><code>eval_local_decl s ldi env m_init_opt</code> declares local identifiers <code>ldi</code> in <code>env</code> with an optional initialisation value <code>m_init_opt</code>. The evaluation of the local identifiers <code>ldi</code> under an environment <code>env</code> is either <code>new_env</code> or raises an error and one of the following applies:</p><h4 id="semanticsrule.ldignore"><a href="#semanticsrule.ldignore" class="anchor"></a>SemanticsRule.LDIgnore</h4><h5 id="rule_41"><a href="#rule_41" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> is an identifier which can be ignored;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="example_42"><a href="#example_42" class="anchor"></a>Example</h5><p><code>var - = 3;</code> evaluates <code>3</code>.</p><p><code>var - : integer;</code> does not modify the environment.</p><h4 id="semanticsrule.ldvar"><a href="#semanticsrule.ldvar" class="anchor"></a>SemanticsRule.LDVar</h4><h5 id="rule_42"><a href="#rule_42" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> is a variable <code>x</code>;</li><li><code>m_init_opt</code> is a value <code>m</code>;</li><li><code>new_env</code> is <code>env</code> modified to declare <code>x</code> as a local identifier bound to value <code>m</code>.</li></ul><h5 id="example_43"><a href="#example_43" class="anchor"></a>Example</h5><p><code>var x = 3;</code> binds <code>x</code> to the evaluation of <code>3</code> in <code>env</code>.</p><p><code>var x : integer = 3;</code> binds <code>x</code> to the evaluation of <code>3</code> in <code>env</code>, without type consideration at runtime.</p><h4 id="semanticsrule.ldtypedvar"><a href="#semanticsrule.ldtypedvar" class="anchor"></a>SemanticsRule.LDTypedVar</h4><h5 id="rule_43"><a href="#rule_43" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> is a variable <code>x</code> of type <code>ty</code>;</li><li><code>m_init_opt</code> is <code>None</code>;</li><li><code>new_env</code> is <code>env</code> modified to declare <code>x</code> as a local identifier bound to the base value of <code>ty</code>.</li></ul><h5 id="example_44"><a href="#example_44" class="anchor"></a>Example</h5><p><code>var x : integer;</code> binds <code>x</code> in <code>env</code> to the base value of <code>integer</code>.</p><h4 id="semanticsrule.lduninitialisedvar"><a href="#semanticsrule.lduninitialisedvar" class="anchor"></a>SemanticsRule.LDUninitialisedVar</h4><h5 id="rule_44"><a href="#rule_44" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> is a variable <code>x</code> without a type nor an initialisation value;</li><li>an error is raised.</li></ul><h5 id="example_45"><a href="#example_45" class="anchor"></a>Example</h5><p><code>var x;</code> raises an error.</p><h4 id="semanticsrule.ldtuple"><a href="#semanticsrule.ldtuple" class="anchor"></a>SemanticsRule.LDTuple</h4><h5 id="rule_45"><a href="#rule_45" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> gives a list of local identifiers <code>ldis</code>;</li><li><code>m_init_opt</code> is a list of values <code>nmonads</code>;</li><li><code>new_env</code> is <code>env</code> modified to declare each element of <code>ldis</code> to be bound to the corresponding value in <code>nmonads</code>.</li></ul><h5 id="example_46"><a href="#example_46" class="anchor"></a>Example</h5><p><code>var (x,y,z) = (1,2,3);</code> binds <code>x</code> (resp. <code>y</code>, <code>z</code>) to the evaluation of <code>1</code> (resp. <code>2</code>, <code>3</code>) in <code>env</code>.</p><h4 id="semanticsrule.ldtypedtuple"><a href="#semanticsrule.ldtypedtuple" class="anchor"></a>SemanticsRule.LDTypedTuple</h4><h5 id="rule_46"><a href="#rule_46" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> gives a list of local identifiers <code>ldis</code> and a type <code>ty</code>;</li><li><code>m_init_opt</code> is <code>None</code>;</li><li><code>new_env</code> is <code>env</code> modified to declare each element of <code>ldis</code> with type <code>ty</code>.</li></ul><h5 id="example_47"><a href="#example_47" class="anchor"></a>Example</h5><p><code>var (x,y,z) : integer;</code> binds <code>x</code>, <code>y</code> and <code>z</code> in <code>env</code> to the base value of <code>integer</code>.</p><h4 id="semanticsrule.lduninitialisedtuple"><a href="#semanticsrule.lduninitialisedtuple" class="anchor"></a>SemanticsRule.LDUninitialisedTuple</h4><h5 id="rule_47"><a href="#rule_47" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>ldi</code> gives a list of local identifiers <code>ldis</code>;</li><li><code>new_env</code> is <code>env</code> modified to declare each element of <code>ldis</code>.</li></ul><h5 id="example_48"><a href="#example_48" class="anchor"></a>Example</h5><p><code>var (x : integer, y : boolean);</code> binds <code>x</code> to the base value of <code>integer</code> and <code>y</code> to the base value of <code>boolean</code>.</p><h3 id="evaluation-of-statements"><a href="#evaluation-of-statements" class="anchor"></a>Evaluation of Statements</h3><p>The evaluation <code>eval_stmt env s</code> of a statement <code>s</code> under environment <code>env</code> is either a <code>Throwing</code>, an interruption <code>Returning vs</code> or a new environment <code>new_env</code>. Formally, one of the following applies:</p><h4 id="semanticsrule.spass"><a href="#semanticsrule.spass" class="anchor"></a>SemanticsRule.SPass</h4><h5 id="rule_48"><a href="#rule_48" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a pass statement;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="example_49"><a href="#example_49" class="anchor"></a>Example</h5><p><code>pass;</code> does nothing.</p><h4 id="semanticsrule.sassign"><a href="#semanticsrule.sassign" class="anchor"></a>SemanticsRule.SAssign</h4><h5 id="rule_49"><a href="#rule_49" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is an assignment <code>le = re</code>;</li><li><code>v</code> is the evaluation of <code>re</code> under <code>env</code>;</li><li><code>r_env</code> is <code>env</code> modified after evaluation of <code>re</code> under <code>env</code>;</li><li><code>new_env</code> is <code>r_env</code> modified after evaluation of <code>le</code> under <code>r_env</code> with <code>v</code>.</li></ul><h5 id="example_50"><a href="#example_50" class="anchor"></a>Example</h5><p><code>x = 3;</code> binds <code>x</code> to <code>3</code> in <code>x ⟶ 42</code> (<code>new_env</code> is here <code>x ⟶ 3</code>).</p><h4 id="semanticsrule.sassigncall"><a href="#semanticsrule.sassigncall" class="anchor"></a>SemanticsRule.SAssignCall</h4><h5 id="rule_50"><a href="#rule_50" class="anchor"></a>Rule</h5><p>&lt;description&gt;</p><h5 id="example_51"><a href="#example_51" class="anchor"></a>Example</h5><p>&lt;minimal example&gt;</p><h4 id="semanticsrule.sassigntuple"><a href="#semanticsrule.sassigntuple" class="anchor"></a>SemanticsRule.SAssignTuple</h4><h5 id="rule_51"><a href="#rule_51" class="anchor"></a>Rule</h5><p>&lt;description&gt;</p><h5 id="example_52"><a href="#example_52" class="anchor"></a>Example</h5><p>&lt;minimal example&gt;</p><h4 id="semanticsrule.sreturnnone"><a href="#semanticsrule.sreturnnone" class="anchor"></a>SemanticsRule.SReturnNone</h4><h5 id="rule_52"><a href="#rule_52" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a return statement;</li><li><code>vs</code> is <code>[]</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="example_53"><a href="#example_53" class="anchor"></a>Example</h5><p><code>return;</code> exits the current procedure.</p><p><code>func foo ()
     begin
       for i = 0 to 42 do
         if i &gt;= 3 then
           return;
         end
         print(i);
       end
     end
     func main () =&gt; integer begin foo (); return 0; end</code> prints &quot;012&quot;.</p><h4 id="semanticsrule.sreturnone"><a href="#semanticsrule.sreturnone" class="anchor"></a>SemanticsRule.SReturnOne</h4><h5 id="rule_53"><a href="#rule_53" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a return statement;</li><li><code>s</code> gives an expression <code>e</code>;</li><li><code>v</code> is the evaluation of <code>e</code> under <code>env</code>;</li><li><code>vs</code> is <code>[v]</code>;</li><li><code>new_env</code> is <code>env</code> modified after evaluation of <code>e</code> under <code>env</code>.</li></ul><h5 id="example_54"><a href="#example_54" class="anchor"></a>Example</h5><p><code>return 3;</code> exits the current function with value <code>3</code>.</p><h4 id="semanticsrule.sreturnsome"><a href="#semanticsrule.sreturnsome" class="anchor"></a>SemanticsRule.SReturnSome</h4><h5 id="rule_54"><a href="#rule_54" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a return statement;</li><li><code>s</code> gives a list of expressions <code>es</code>;</li><li><code>vs</code> is the piece-wise evaluation of the list <code>es</code> under <code>env</code>;</li><li><code>new_env</code> is <code>env</code> modified after evaluation of <code>e</code> under <code>env</code>.</li></ul><h5 id="example_55"><a href="#example_55" class="anchor"></a>Example</h5><p><code>return (3, 42);</code> exits the current function with value <code>(3, 42)</code>.</p><h4 id="semanticsrule.sthen"><a href="#semanticsrule.sthen" class="anchor"></a>SemanticsRule.SThen</h4><h5 id="rule_55"><a href="#rule_55" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a then statement;</li><li><code>s</code> gives two statements <code>s1</code> and <code>s2</code>;</li><li><code>env'</code> is <code>env</code> modified after evaluation of <code>s1</code>;</li><li><code>new_env</code> is <code>env'</code> modified after evaluation of <code>s2</code>.</li></ul><h5 id="example_56"><a href="#example_56" class="anchor"></a>Example</h5><p><code>print(3); print(42);</code> prints &quot;342&quot;.</p><h4 id="semanticsrule.scall"><a href="#semanticsrule.scall" class="anchor"></a>SemanticsRule.SCall</h4><h5 id="rule_56"><a href="#rule_56" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a call statement;</li><li><code>s</code> gives a function name <code>name</code>, actual arguments <code>actual_args</code> and parameters <code>params</code>;</li><li><code>env'</code> is <code>env</code> modified after evaluation of the function call;</li><li><code>new_env</code> is <code>env'</code>.</li></ul><h5 id="example_57"><a href="#example_57" class="anchor"></a>Example</h5><p><code>Zeros(3)</code> evaluates to <code>'000'</code>.</p><h4 id="semanticsrule.scond"><a href="#semanticsrule.scond" class="anchor"></a>SemanticsRule.SCond</h4><h5 id="rule_57"><a href="#rule_57" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a conditional statement;</li><li><code>s</code> gives a condition <code>cond</code> and two statements <code>s1</code> and <code>s2</code>;</li><li><code>v_cond</code> is the evaluation of <code>cond</code>;</li><li><code>new_env</code> is <code>env</code> modified after evaluation of <code>s1</code> or <code>s2</code> depending on <code>v_cond</code>.</li></ul><h5 id="example_58"><a href="#example_58" class="anchor"></a>Example</h5><p><code>if TRUE then print(3); else print(42); end</code> prints &quot;3&quot;.</p><h4 id="semanticsrule.scase"><a href="#semanticsrule.scase" class="anchor"></a>SemanticsRule.SCase</h4><h5 id="rule_58"><a href="#rule_58" class="anchor"></a>Rule</h5><p>&lt;description&gt;</p><h5 id="example_59"><a href="#example_59" class="anchor"></a>Example</h5><p><code>match 3 with
     case 42: print(&quot;equals 42.&quot;);
     case &lt;= 42: print(&quot;less than 42.&quot;);
     otherwise: print(&quot;bigger than 42.&quot;);</code> prints &quot;less than 42.&quot;</p><h4 id="semanticsrule.sassert"><a href="#semanticsrule.sassert" class="anchor"></a>SemanticsRule.SAssert</h4><h5 id="rule_59"><a href="#rule_59" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is an assert statement;</li><li><code>s</code> gives an expression <code>e</code>;</li><li><code>v</code> is the evaluation of <code>e</code>;</li><li>if <code>v</code> is true then <code>new_env</code> is <code>env</code>, otherwise an AssertionFailed error is raised.</li></ul><h5 id="example_60"><a href="#example_60" class="anchor"></a>Example</h5><p><code>assert (42 != 3);</code> ensures that <code>3</code> is not equal to <code>42</code>. <code>assert (42 == 3);</code> raises an <code>AssertionFailed</code> error.</p><h4 id="semanticsrule.swhile"><a href="#semanticsrule.swhile" class="anchor"></a>SemanticsRule.SWhile</h4><h5 id="rule_60"><a href="#rule_60" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a while statement;</li><li><code>s</code> gives an expression <code>e</code> and a loop body <code>body</code>;</li><li><code>new_env</code> is <code>env</code> modified after evaluation of the loop <code>(e,body)</code>.</li></ul><h5 id="example_61"><a href="#example_61" class="anchor"></a>Example</h5><p><code>var i: integer = 0;
     while i &lt;= 3 do
       print (i);
       i = i + 1;
     end</code> prints &quot;0123&quot;.</p><h4 id="semanticsrule.srepeat"><a href="#semanticsrule.srepeat" class="anchor"></a>SemanticsRule.SRepeat</h4><h5 id="rule_61"><a href="#rule_61" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a repeat statement;</li><li><code>s</code> gives an expression <code>e</code> and a loop body <code>body</code>;</li><li><code>new_env</code> is <code>env</code> modified after evaluation of the loop <code>(e,body)</code>.</li></ul><h5 id="example_62"><a href="#example_62" class="anchor"></a>Example</h5><p><code>var i: integer = 0;
     repeat
       print(i);
       i = i + 1;
     until i &gt; 3;</code> prints &quot;0123&quot;.</p><h4 id="semanticsrule.sfor"><a href="#semanticsrule.sfor" class="anchor"></a>SemanticsRule.SFor</h4><h5 id="rule_62"><a href="#rule_62" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a for statement;</li><li><code>s</code> gives <code>(id,e1,dir,e2,s)</code>;</li><li>&lt;description&gt;</li></ul><h5 id="example_63"><a href="#example_63" class="anchor"></a>Example</h5><p><code>for i = 0 to 3 do
       print (i);
     end</code> prints &quot;0123&quot;.</p><h4 id="semanticsrule.sthrownone"><a href="#semanticsrule.sthrownone" class="anchor"></a>SemanticsRule.SThrowNone</h4><h5 id="rule_63"><a href="#rule_63" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a throw statement;</li><li>&lt;description&gt;</li></ul><h5 id="example_64"><a href="#example_64" class="anchor"></a>Example</h5><p><code>try throw MyException;
     catch MyException: throw;</code> throws a <code>MyException</code> exception.</p><h4 id="semanticsrule.sthrowsometyped"><a href="#semanticsrule.sthrowsometyped" class="anchor"></a>SemanticsRule.SThrowSomeTyped</h4><h5 id="rule_64"><a href="#rule_64" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a throw statement;</li><li>&lt;description&gt;</li></ul><h5 id="example_65"><a href="#example_65" class="anchor"></a>Example</h5><p><code>thow MyException { a: 3, b: 42 };</code> throws a <code>MyException {a: 3, b: 42}</code> exception.</p><h4 id="semanticsrule.sthrowsome"><a href="#semanticsrule.sthrowsome" class="anchor"></a>SemanticsRule.SThrowSome</h4><h5 id="rule_65"><a href="#rule_65" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a throw statement;</li><li>&lt;description&gt;</li></ul><h5 id="example_66"><a href="#example_66" class="anchor"></a>Example</h5><p>&lt;minimal example&gt;</p><h4 id="semanticsrule.stry"><a href="#semanticsrule.stry" class="anchor"></a>SemanticsRule.STry</h4><h5 id="rule_66"><a href="#rule_66" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a try statement;</li><li><code>s</code> gives <code>(s', catchers, otherwise_opt)</code>;</li><li><code>s_m</code> is the evaluation of the block <code>s'</code> under <code>env</code>;</li><li><code>new_env</code> is <code>env</code> modified after evaluation of the catchers <code>(catchers
      otherwise_opt s_m)</code>.</li></ul><h5 id="example_67"><a href="#example_67" class="anchor"></a>Example</h5><p><code>try throw MyException;
     catch MyException: print(3);</code> prints &quot;3&quot;.</p><h4 id="semanticsrule.sdeclsome"><a href="#semanticsrule.sdeclsome" class="anchor"></a>SemanticsRule.SDeclSome</h4><h5 id="rule_67"><a href="#rule_67" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a declaration;</li><li><code>s</code> gives <code>(_ldk, ldi, Some e)</code>;</li><li><code>new_env</code> is <code>env</code> modified after evaluation of the local declaration <code>ldi env (Some m)</code>.</li></ul><h5 id="example_68"><a href="#example_68" class="anchor"></a>Example</h5><p><code>let x = 3;</code> binds <code>x</code> to <code>3</code> in the empty environment.</p><h4 id="semanticsrule.sdeclnone"><a href="#semanticsrule.sdeclnone" class="anchor"></a>SemanticsRule.SDeclNone</h4><h5 id="rule_68"><a href="#rule_68" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a declaration;</li><li><code>s</code> gives <code>(_dlk, ldi, None)</code>;</li><li><code>new_env</code> is <code>env</code> modified after evaluation of the local declaration <code>ldi env None</code>.</li></ul><h5 id="example_69"><a href="#example_69" class="anchor"></a>Example</h5><p><code>var x : integer;</code> binds <code>x</code> in <code>env</code> to the base value of <code>integer</code>.</p><h4 id="semanticsrule.sdebug"><a href="#semanticsrule.sdebug" class="anchor"></a>SemanticsRule.SDebug</h4><h5 id="rule_69"><a href="#rule_69" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s</code> is a debug statement;</li><li><code>s</code> gives a side-effect-free expression <code>e</code>;</li><li><code>v</code> is the evaluation of <code>e</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="example_70"><a href="#example_70" class="anchor"></a>Example</h5><p>&lt;minimal example&gt;</p><h3 id="evaluation-of-blocks"><a href="#evaluation-of-blocks" class="anchor"></a>Evaluation of Blocks</h3><h4 id="semanticsrule.block"><a href="#semanticsrule.block" class="anchor"></a>SemanticsRule.Block</h4><h5 id="rule_70"><a href="#rule_70" class="anchor"></a>Rule</h5><p><code>eval_block env stm</code> is <code>new_env</code> and all of the following applies:</p><ul><li><code>block_env</code> is <code>env</code> such that the scope given by <code>env</code> is pushed onto the declaration stack;</li><li><code>block_env'</code> is <code>env</code> modified after the evaluation of the statement <code>stm</code>;</li><li><code>new_env</code> is <code>block_env'</code> after restoring the variable bindings of <code>env</code>, with the updated values of <code>block_env'</code>.</li></ul><h5 id="example_71"><a href="#example_71" class="anchor"></a>Example</h5><p>&lt;minimal example&gt;</p><h3 id="evaluation-of-while-and-repeat-loops"><a href="#evaluation-of-while-and-repeat-loops" class="anchor"></a>Evaluation of <code>while</code> and <code>repeat</code> loops</h3><p><code>eval_loop is_while env e_cond body</code> evaluates <code>body</code> in <code>env</code>: this is either an interruption <code>Returning vs</code> or a new environment <code>new_env</code>.</p><h4 id="semanticsrule.loop"><a href="#semanticsrule.loop" class="anchor"></a>SemanticsRule.Loop</h4><h5 id="rule_71"><a href="#rule_71" class="anchor"></a>Rule</h5><p>Formally, <code>cond_m</code> evaluates to <code>e_cond</code> or <code>not e_cond</code> as determined by <code>is_while</code> and one of the following applies:</p><ul><li>All of the following applies: * <code>cond_m</code> evaluates to <code>false</code>; * <code>new_env</code> is <code>env</code>---the loop is exited.</li><li>All of the following applies: * <code>cond_m</code> evaluates to <code>true</code>; * <code>env1</code> is <code>env</code> modified after the evaluation of the statement <code>body</code>---this step might affect the value of <code>cond_m</code> eventually leading to exiting the loop; * <code>new_env</code> is <code>env1</code> modified after the evaluation of <code>eval_loop
        is_while env e_cond body</code>.</li></ul><h5 id="example_72"><a href="#example_72" class="anchor"></a>Example</h5><p><code>var i: integer = 0;
     while i &lt;= 3 do
       print (i);
       i = i + 1;
     end</code> prints &quot;0123&quot;.</p><h3 id="evaluation-of-for-loops"><a href="#evaluation-of-for-loops" class="anchor"></a>Evaluation of <code>for</code> loops</h3><p><code>eval_for undet env index_name v_start dir v_end body</code> evaluates <code>body</code> in <code>env</code>: this is either an interruption <code>Returning vs</code> or a new environment <code>new_env</code>.</p><h4 id="semanticsrule.for"><a href="#semanticsrule.for" class="anchor"></a>SemanticsRule.For</h4><h5 id="rule_72"><a href="#rule_72" class="anchor"></a>Rule</h5><p>Formally, <code>cond_m</code> evaluates to <code>leq v_end v_start</code> or <code>geq v_end v_start</code> as determined by <code>dir</code> and one of the following applies:</p><ul><li>All of the following applies: * <code>cond_m</code> evaluates to <code>true</code>; * <code>new_env</code> is <code>env</code> as the loop is exited.</li><li>All of the following applies: * <code>cond_m</code> evaluates to <code>false</code>; * <code>env1</code> is <code>env</code> modified after the evaluation of the statement <code>body</code>; * <code>env2</code> is <code>env1</code> modified such that <code>index_name</code> is bound to <code>v_step</code>; * <code>v_step</code> evaluates to <code>v_start+1</code> or <code>v_start-1</code> as determined by <code>dir</code>; * <code>new_env</code> is <code>env2</code> modified after the evaluation of <code>eval_for undet
        env index_name v_step dir v_end body</code>.</li></ul><h5 id="example_73"><a href="#example_73" class="anchor"></a>Example</h5><p><code>for i = 0 to 3 do
       print (i);
     end</code> prints &quot;3&quot;.</p><h3 id="evaluation-of-catchers"><a href="#evaluation-of-catchers" class="anchor"></a>Evaluation of Catchers</h3><p><code>eval_catchers env catchers otherwise_opt s_m</code>, given the result <code>s_m</code> of the evaluation of a statement under environment <code>env</code> is <code>res</code> which is either a <code>Throwing (v, v_ty, env_throw)</code>, an interruption <code>Returning vs</code> or a new environment <code>new_env</code>. Formally, one of the following applies:</p><h4 id="semanticsrule.catch"><a href="#semanticsrule.catch" class="anchor"></a>SemanticsRule.Catch</h4><h5 id="rule_73"><a href="#rule_73" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s_m</code> is <code>Throwing (v, v_ty, env_throw)</code>;</li><li><code>catcher</code> is the first catcher in <code>catchers</code> that matches <code>v_ty</code>;</li><li><code>catcher</code> does not declare a name;</li><li><code>catcher</code> gives a statement <code>s</code>;</li><li>One of the following applies:</li><li><code>env_throw</code> and <code>env</code> have the same scope, and <code>env1</code> is <code>env_throw</code>;</li><li><code>env1</code> is the environment formed with the global part of <code>env_throw</code> and the local part of <code>env</code>;</li><li>One of the following applies:</li><li><code>Throwing (None, None, env_throw1)</code> is the result of the evaluation of the block <code>s</code> in <code>env1</code>, and <code>res</code> is <code>Throwing (v, v_ty, env_throw1)</code>;</li><li><code>res</code> is the result of the evaluation of the block <code>s</code> in <code>env1</code>.</li></ul><h5 id="example_74"><a href="#example_74" class="anchor"></a>Example</h5><p><code>
    try throw 
      MyExceptionType {}; 
      print(&quot;No exception raised&quot;);
    catch
      when MyExceptionType =&gt; 
      print(&quot;MyException&quot;);
    otherwise =&gt; 
      print(&quot;Another exception&quot;);
    </code> prints &quot;MyException&quot;.</p><h4 id="semanticsrule.catchnamed"><a href="#semanticsrule.catchnamed" class="anchor"></a>SemanticsRule.CatchNamed</h4><h5 id="rule_74"><a href="#rule_74" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s_m</code> is <code>Throwing (v, v_ty, env_throw)</code>;</li><li><code>catcher</code> is the first catcher in <code>catchers</code> that matches <code>v_ty</code>;</li><li><code>catcher</code> declares a name <code>name</code>;</li><li><code>catcher</code> gives a statement <code>s</code>;</li><li>One of the following applies:</li><li><code>env_throw</code> and <code>env</code> have the same scope, and <code>env1</code> is <code>env_throw</code>;</li><li><code>env1</code> is the environment formed with the global part of <code>env_throw</code> and the local part of <code>env</code>;</li><li><code>env2</code> is <code>env1</code> modified after binding locally <code>name</code> to the exception <code>v</code> raised by <code>s_m</code>;</li><li>One of the following applies:</li><li><code>Throwing (None, None, env_throw1)</code> is the result of the evaluation of the block <code>s</code> in <code>env2</code>, and <code>res</code> is <code>Throwing (v, v_ty, env_throw1)</code>;</li><li><code>env3</code> is <code>env2</code> modified after the evaluation of the block <code>s</code> in <code>env2</code>, and <code>new_env</code> is <code>env3</code> modified after unbinding <code>name</code> from <code>env3</code>.</li><li><code>res</code> is the result of the evaluation of the block <code>s</code> in <code>env2</code>.</li></ul><h5 id="example_75"><a href="#example_75" class="anchor"></a>Example</h5><p><code>
    try throw 
      MyExceptionType { msg: &quot;My exception with my message&quot; };
    catch
      when MyExceptionType: exn =&gt; 
      print(exn.msg);
    otherwise =&gt; 
    print(&quot;Another exception&quot;);
    </code> prints &quot;My exception with my message&quot;.</p><h4 id="semanticsrule.catchotherwise"><a href="#semanticsrule.catchotherwise" class="anchor"></a>SemanticsRule.CatchOtherwise</h4><h5 id="rule_75"><a href="#rule_75" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s_m</code> is <code>Throwing (v, v_ty, env_throw)</code>;</li><li><code>otherwise_opt</code> is <code>Some s</code>;</li><li>no catcher matches <code>v_ty</code>;</li><li>One of the following applies:</li><li><code>env_throw</code> and <code>env</code> have the same scope, and <code>env1</code> is <code>env_throw</code>;</li><li><code>env1</code> is the environment formed with the global part of <code>env_throw</code> and the local part of <code>env</code>;</li><li>One of the following applies:</li><li><code>Throwing (None, None, env_throw1)</code> is the result of the evaluation of the block <code>s</code> in <code>env1</code>, and <code>res</code> is <code>Throwing (v, v_ty, env_throw1)</code>;</li><li><code>res</code> is the result of the evaluation of the block <code>s</code> in <code>env1</code>.</li></ul><h5 id="example_76"><a href="#example_76" class="anchor"></a>Example</h5><p><code>
     try throw 
       MyExceptionType1 {}; 
       print(&quot;No exception raised&quot;);
       catch
         when MyExceptionType2 =&gt; 
         print(&quot;MyException2&quot;);
       otherwise =&gt; 
         print(&quot;Another exception&quot;);
     </code> prints &quot;Another exception&quot;</p><h4 id="semanticsrule.catchnone"><a href="#semanticsrule.catchnone" class="anchor"></a>SemanticsRule.CatchNone</h4><h5 id="rule_76"><a href="#rule_76" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s_m</code> is <code>Throwing (v, v_ty, env_throw)</code>;</li><li><code>otherwise_opt</code> is <code>None</code>;</li><li>no catcher matches <code>v_ty</code>;</li><li><code>new_env</code> is <code>env</code>.</li></ul><h5 id="example_77"><a href="#example_77" class="anchor"></a>Example</h5><p><code>
     try throw 
       MyExceptionType1 {}; 
       print(&quot;No exception raised&quot;);
       catch
         when MyExceptionType2 =&gt; 
         print(&quot;MyException2&quot;);
    </code> does not print anything.</p><h4 id="semanticsrule.catchnothrow"><a href="#semanticsrule.catchnothrow" class="anchor"></a>SemanticsRule.CatchNoThrow</h4><h5 id="rule_77"><a href="#rule_77" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>s_m</code> is not <code>Throwing</code>;</li><li><code>res</code> is <code>s_m</code>.</li></ul><h5 id="example_78"><a href="#example_78" class="anchor"></a>Example</h5><p><code>
    try 
      print (&quot;No exception raised&quot;);
    catch
      when MyExceptionType =&gt; 
        print(&quot;MyException&quot;);
      otherwise =&gt; 
        print(&quot;Another exception&quot;);
    </code> prints &quot;No exception raised&quot;.</p><h3 id="evaluation-of-function-calls"><a href="#evaluation-of-function-calls" class="anchor"></a>Evaluation of Function Calls</h3><p><code>eval_call pos name env args named_args</code> evaluates the call to function <code>name</code> with arguments <code>args</code> and parameters <code>named_args</code>.</p><h5 id="rule_78"><a href="#rule_78" class="anchor"></a>Rule</h5><p>&lt;description&gt;</p><h5 id="example_79"><a href="#example_79" class="anchor"></a>Example</h5><p>At the begining of a program, the interpreter evaluates the function &quot;main&quot;.</p><h3 id="evaluation-of-functions"><a href="#evaluation-of-functions" class="anchor"></a>Evaluation of Functions</h3><p><code>eval_func genv name pos actual_args params</code> evaluates the function named <code>name</code> in the global environment <code>genv</code>, with <code>actual_args</code> the list of actual arguments, and <code>params</code> the list of arguments deduced by type equality. This is a new global environment <code>new_genv</code> and a list of values <code>vs</code>, or an error is raised. Formally, one of the following applies:</p><h4 id="semanticsrule.fundefident"><a href="#semanticsrule.fundefident" class="anchor"></a>SemanticsRule.FUndefIdent</h4><h5 id="rule_79"><a href="#rule_79" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>name</code> is undeclared in <code>genv</code>;</li><li>an <code>UndefinedIdentifier</code> error is raised.</li></ul><h5 id="example_80"><a href="#example_80" class="anchor"></a>Example</h5><p><code>func main () =&gt; integer
   begin
     Foo ();
   end</code> raises an <code>UndefinedIdentifier &quot;Foo&quot;</code> error.</p><h4 id="semanticsrule.fprimitive"><a href="#semanticsrule.fprimitive" class="anchor"></a>SemanticsRule.FPrimitive</h4><h5 id="rule_80"><a href="#rule_80" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>name</code> is bound in <code>genv</code> to a primitive function with a body <code>body</code>;</li><li><code>new_genv</code> is <code>genv</code>;</li><li><code>vs</code> is the application of <code>body</code> on <code>actual_args</code>.</li></ul><h5 id="example_81"><a href="#example_81" class="anchor"></a>Example</h5><p><code>print (2,3);</code> calls the primitive <code>print</code> on the evaluation of <code>(2,3)</code>.</p><h4 id="semanticsrule.fbadarity"><a href="#semanticsrule.fbadarity" class="anchor"></a>SemanticsRule.FBadArity</h4><h5 id="rule_81"><a href="#rule_81" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>name</code> is bound in <code>genv</code> to a function with a list of formal arguments <code>arg_decls</code>;</li><li>the lists <code>actual_args</code> and <code>arg_decls</code> do not have the same length;</li><li>a &quot;BadArity&quot; error is raised.</li></ul><h5 id="example_82"><a href="#example_82" class="anchor"></a>Example</h5><p><code>Zeros(3,4);</code> raises a <code>BadArity &quot;Zeros&quot; 1 2</code> error.</p><h4 id="semanticsrule.fcall"><a href="#semanticsrule.fcall" class="anchor"></a>SemanticsRule.FCall</h4><h5 id="rule_82"><a href="#rule_82" class="anchor"></a>Rule</h5><p>All of the following applies:</p><ul><li><code>name</code> is bound in <code>genv</code> to a function with a list of formal arguments <code>arg_decls</code> and a body statement <code>body</code>;</li><li><code>env1</code> is the environment made of <code>genv</code> and the empty local environment,</li><li><code>env2</code> is <code>env1</code> modified so that each formal argument in <code>arg_decls</code> is locally bound to the corresponding actual argument in <code>actual_args</code>;</li><li><code>env3</code> is <code>env2</code> modified so that each parameter in <code>params</code> is declared;</li><li><code>res</code> is the evaluation of <code>body</code> in <code>env3</code> and one of the following applies:</li></ul><ol><li><code>res</code> is an environment <code>env4</code> and <code>new_genv</code> is the global environment given by <code>env4</code>---e.g. where the function called is either a setter or a procedure as per Rule R_DFWZ;</li><li><code>res</code> is an interruption <code>Returning(xs,ret_genv)</code> and <code>new_genv</code> is <code>ret_genv</code>---this is the general case.</li></ol><h5 id="example_83"><a href="#example_83" class="anchor"></a>Example</h5><p><code>func foo (x : integer) =&gt; integer
   begin
     return x + 1;
   end
   func bar (x : integer) =&gt; integer
   begin
     print(x);
   end
   func main () =&gt; integer
   begin
     foo(2);
     bar(3);
    return 0;
   end</code></p></div></body></html>