{0
          ASL Semantics Reference
}

{1 Disclaimer}
This material covers both ASLv0 (viz, the existing ASL pseudocode language
which appears in the Arm Architecture Reference Manual) and ASLv1, a new,
experimental, and as yet unreleased version of ASL.

This material is work in progress, more precisely at pre-Alpha quality as
per Arm’s quality standards. In particular, this means that it would be
premature to base any production tool development on this material.

However, any feedback, question, query and feature request would be most
welcome; those can be sent to Arm’s Architecture Formal Team Lead Jade
Alglave <jade.alglave@arm.com> or by raising issues or PRs to the herdtools7
github repository.

{1
Environments
}

An environment is what the semantics operates over: a structure
which amongst other things associates values to variables.
Intuitively, the evaluation of a program makes an initial
environment evolve, with new values as given by the operations
of the program.

  {2 Base Value}
  [base_value] <description, minimal example>

  {2 Initial environment}
  The initial environment is built with the help of the [build_<object>]
  functions.  Each [build_<object>] function builds a specific object, as
  follows.

    {3 Function Calls}
    [build_func_call_ref] <description, minimal example>

    {3 Global Storage}
    [build_global_storage] <description, minimal example>

    {3 Global Environment}
    [build_global_env] <description, minimal example>

    {3 Bind Environment}
    [bind_env], also written [let*^], <description, minimal example>

  {2 Scopes}
  [push_scope] pushes a new scope on the declaration stack. Variables declared
  here will be stored until the corresponding [pop_scope].

  [pop_scope old new] restores the variable bindings of [old], with the updated
  values of [new].

{1
Evaluation
}
Evaluating a program is evaluating its main function.
Constructively, evaluating a program requires following its
Abstract Syntax Tree and evaluating each of its components.

Formally, the semantics of a program are given by applying a
set of eval_<object> functions. Each eval_<object> function
describes how to evaluate a specific object, as follows.

      - [eval_expr] evaluates expressions: it takes an
environment and an expression and returns a wrapped value and a
new environment;
      - [eval_expr_sef] evaluates expressions without side
effects;
      - [eval_expr_list] and [eval_expr_list_m] evaluate lists
of expressions;
      - [eval_slices] evaluates slices;
      - [eval_patterns] evaluates patterns;
      - [eval_local_decl] evaluates local declarations;
      - [eval_lexpr] evaluates left-hand sides of assignments:
it takes an environment, the left-hand side of an assignment
and a wrapped value to be written, and returns a wrapped
environment updated with the new value;
      - [eval_stmt] evaluates statements: it takes an
environment and a statement and returns a wrapped new
environment, viz, the environment updated with the side-effects
of the statement;
      - [eval_block] evaluates blocks;
      - [eval_loop] evaluates both while and repeat loops;
      - [eval_for] evaluates for loops;
      - [eval_catchers] evaluates catchers;
      - [eval_call] evaluates functions calls;
      - [eval_func] evaluates functions: it takes an
environment, a function name and its arguments, and returns a
wrapped list of the return values of the function. The
evaluation of a program is the evaluation of its main function.

{2
Evaluation of Expressions
}

[eval_expr] specifies how to evaluate an expression [e] in an
environment [env]. More precisely, [eval_expr env e] is the
monadic evaluation  of [e] in [env].

Evaluation of the expression [e] under an environment [env] is either a value
[v] or an error and one of the following applies:

{3 SemanticsRule.Lit}

  {4 Rule}
  [e] denotes a Literal [l] and [v] is the value of [l] in [env].

  {4 Comments}

  {4 Examples}
  The expression [3] evaluates to the value [3].

{3 SemanticsRule.TypedExpr}

  {4 Rule}
  [(e,_t)] denotes a typed expression and <description>

  {4 Comments}

  {4 Examples}
  The expression [(3 as integer)] evaluates to the value [3].

  The expression [(3 as integer {5:7})] raises a "Mismatched Value" error.

{3 SemanticsRule.ELocalVar}

  {4 Rule}
  All of the following applies:
  - [e] denotes a variable [x] which is bound locally in [env];
  - [v] is the value of [x] in [env].

  {4 Comments}

  {4 Examples}
  {@asl[
  func main () => integer
  begin
    var x: integer = 3;
    assert x == 3;
    return 0;
  end
  ]}

  The evaluation of [x] within [assert x == 3]; uses ELocalVar.

{3 SemanticsRule.EGlobalVar}
  {4 Rule}
  All of the following applies:
  - [e] denotes a variable [x] which is bound globally in [env];
  - [v] is the value of [x] in [env].

  {4 Comments}

  {4 Examples}
  {@asl[
   var global_x: integer = 3;

   func main () => integer
   begin
     assert global_x == 3;
     return 0;
   end
  ]}

  The evaluation of [global_x] within [assert global_x == 3;] uses EGlobalVar.

  {@asl[
   var x: integer = 3;

   func main () => integer
   begin
     assert x == 3;
   end
  ]}

  This raises a type error because [x] is already declared locally in [stdlib.asl].

{3 SemanticsRule.EUndefIdent}

  {4 Rule}
  All of the following applies:
  - [e] denotes a variable [x] which is not bound in [env];
  - an Error "UndefinedIdentifier" is raised.

  {4 Comments}

  {4 Examples}
  {@asl[
  func main () => integer
  begin
    let x = 42;
    print(y);
    return 0;
  end
  ]}
  raises an Undefined Identifier error: the variable [y] is undefined in the
  environment [x → 42].

{3 SemanticsRule.BinopAnd}

  {4 Rule}
  All of the following applies:
  - [e] denotes a conjunction over two expressions [e1] and [e2];
  - [e] is evaluated as [if e1 then e2 else false].

  {4 Comments}

  {4 Examples}

{3 SemanticsRule.BinopOr}

  {4 Rule}
  All of the following applies:
  - [e] denotes a disjunction over two expressions [e1] and [e2];
  - [e] is evaluated as [if e1 then true else e2].

  {4 Comments}

  {4 Examples}

{3 SemanticsRule.BinopImpl}

  {4 Rule}
  All of the following applies:
  - [e] denotes an implication over two expressions [e1] and [e2];
  - [e] is evaluated as [if e1 then e2 else true].

  {4 Comments}

  {4 Examples}

{3 SemanticsRule.Binop}

  {4 Rule}
  All of the following applies:
  - [e] denotes a Binary Operator [op] over two expressions [e1] and [e2];
  - The evaluation of the expression [e1] under [env] is [v1];
  - The evaluation of the expression [e2] under [env] is [v2];
  - [v] is the result of applying the Binary Operator [op] to [v1] and [v2].

  {4 Comments}

  {4 Examples}
  In this program:
  {@asl[
  func main () => integer
  begin
    let x = 3 + 2;
    assert(x==5);
    return 0;
  end
  ]}
  The expression [3 + 2] evaluates to the value [5].

  For the program:
  {@asl[
  func main () => integer
  begin
    let x = 3 DIV 0;
    return 0;
  end
  ]}

  Without type-checking, the expression [3 DIV 0] raises a backend-defined error,
  e.g.
  {@asl[
  ASL Execution error: Illegal application of operator DIV for values 3 and 0.
  ]}

  With type-checking, the expression [3 DIV 0] raises a type error.

{3 SemanticsRule.Unop}

  {4 Rule}
  All of the following applies:
  - [e] denotes a Unary Operator [op] over an expression [e];
  - The evaluation of the expression [e] under [env] is [t];
  - [v] is the result of applying the Unary Operator [op] to [t].

  {4 Comments}

  {4 Examples}
  The expression [NOT '1010'] evaluates to the value ['0101'].

{3 SemanticsRule.ECond}

  {4 Rule}
  All of the following applies:
  - [e] denotes a condition [e_cond] with two options [e1] and [e2];
  - The evaluation of the condition [e_cond] under [env] is [m_cond];
  - One of [e1] or [e2] is not a simple expression;
  - The evaluation of [e1] or [e2], depending on [m_cond], is [v].

  {4 Comments}

  {4 Examples}
  In the program:
  {@asl[
  func Return42() => integer
  begin
    return 42;
  end

  func main () => integer
  begin
    let x = if FALSE then Return42() else 3;
    assert(x==3);
    return 0;
  end
  ]}
  The expression [if FALSE then Return42() else 3] evaluates to the value [3].

  In the program:
  {@asl[
  func Return42() => integer
  begin
    return 42;
  end

  func main () => integer
  begin
    let x = if UNKNOWN: boolean then 3 else Return42();
    assert(x==3);
    return 0;
  end
  ]}
   The expression [if UNKNOWN: boolean then 3 else Return42()] will evaluate
  either [3] or [Return42()] depending on how UNKNOWN is implemented.

{3 SemanticsRule.ESlice}

  {4 Rule}
  All of the following applies:
  - [e] denotes an expression [e_bv] sliced as per [slices];
  - The evaluation of [e_bv] under [env] is [v_bv];
  - The evaluation of [slices] under [env] is [positions];
  - [v] is the value read in [v_bv] from [positions].

  {4 Comments}

  {4 Examples}
  The expression ['11110000'[5:2]] evaluates to the value ['1100'].

{3 SemanticsRule.ECall}

  {4 Rule}
  All of the following applies:
  - [e] denotes a function call [(name, actual_args, params)];
  - The evaluation of that function call under [env] is [ms];
  - [v] is the value read from [ms].

  {4 Comments}

  {4 Examples}
  In the program:
  {@asl[
  func Return42() => integer
  begin
    return 42;
  end

  func main () => integer
  begin
    let x = Return42();
    assert(x==42);
    return 0;
  end
  ]}
  The expression [Return42()] evaluates to the value [42] because the function
  [Return42()] is implemented to return the value [42].

{3 SemanticsRule.EGetArray}

  {4 Rule}
  All of the following applies:
  - [e] denotes an array [e_array] and an index [e_index];
  - The evaluation of [e_array] under [env] is [v_array];
  - The evaluation of [e_index] under [env] is [v_index];
  - [v] is the value found at the index [v_index] of [v_array].

  {4 Comments}

  {4 Examples}
  In the program:
  {@asl[
  type MyArrayType of array [3] of integer;

  var my_array : MyArrayType;

  func main () => integer
  begin
    my_array[2]=42;
    assert(my_array[2]==42);
    return 0;
  end
  ]}
  The expression [my_array[2]] evaluates to the value [42] since the element
  indexed by [2] in [my_array] is [42].

  The program:
  {@asl[
  type MyArrayType of array [3] of integer;

  var my_array : MyArrayType;

  func main () => integer
  begin
    my_array[3]=42;
    assert(my_array[3]==42);
    return 0;
  end
  ]}
  raises a typing error since we are trying to access index [3] of an array which has
  indexes [0], [1] and [2] only.

{3 SemanticsRule.ERecord}

  {4 Rule}
  All of the following applies:
  - [e] denotes a series of field names [names] and associated expressions
    [fields];
  - [fields] evaluates in [env] to [v_fields];
  - [v] is the record built by associating the names [names] to [v_fields].

  {4 Comments}

  {4 Examples}
  The expression [MyRecordType { a: 3, b: 42 }] evaluates to the value [{a: 3, b: 42}].

{3 SemanticsRule.EGetField}

  {4 Rule}
  All of the following applies:
  - [e] denotes a field name [field_name] in a vector [e_vec];
  - the evaluation of [e_vec] in [env] is [v_vec];
  - [v] is the value mapped by [field_name] in [v_vec].

  {4 Comments}

  {4 Examples}
  In the program:
  {@asl[
  type MyRecordType of record {a: integer, b: integer};

  func main () => integer
  begin
    let my_record = MyRecordType{a=3, b=42};
    assert(my_record.a==3);
    return 0;
  end
  ]}
  The expression [(MyRecordType{a=3, b=42}).a] evaluates to the value [3].

{3 SemanticsRule.EGetFields}

  {4 Rule}
  <description>

  {4 Comments}

  {4 Examples}
  <minimal example>

{3 SemanticsRule.EConcat}

  {4 Rule}
  All of the following applies:
  - [e] denotes a list of expressions [e_list];
  - the evaluation of [e_list] in [env] is [v_list];
  - [v] is the concatenation of [v_list].

  {4 Comments}

  {4 Examples}
  In the program:
  {@asl[
  func main () => integer
  begin
    let x = [['10','11']];
    assert(x=='1011');
    return 0;
  end
  ]}
  The expression [['10', '11']] evaluates to the value ['1011'].

{3 SemanticsRule.ETuple}

  {4 Rule}
  All of the following applies:
  - [e] denotes a list of expression [e_list];
  - the evaluation of [e_list] in [env] is [v_list];
  - [v] is the vector built from [v_list].

  {4 Comments}

  {4 Examples}
  In the program:
  {@asl[
  func Return42() => integer
  begin
    return 42;
  end

  func main () => integer
  begin
    let (x,y) = (3, Return42());
    assert(x==3);
    assert(y==42);
    return 0;
  end
  ]}
  The expression [(3, Return42())] evaluates to the value [(3, 42)].

{3 SemanticsRule.EUnknown}

  {4 Rule}
  All of the following applies:
  - [e] denotes a type [t];
  - [v] is a value in the domain of [t].

  {4 Comments}

  {4 Examples}
  In the program:
  {@asl[
  func main () => integer
  begin
    let x = UNKNOWN:integer;
    assert(x==3);
    return 0;
  end
  ]}
  The expression [UNKNOWN : integer] evaluates to an integer value.

  In the program:
  {@asl[
  func main () => integer
  begin
    let x = UNKNOWN:integer {3, 42};
    assert(x==3);
    return 0;
  end
  ]}
  The expression [UNKNOWN : integer {3, 42}] evaluates to either the value [3] or the value [42].

{3 SemanticsRule.EPattern}

  {4 Rule}
  All of the following applies:
  - [e] denotes a pattern [e,p];
  - [v] is the boolean determining whether the evaluation of [e] in [env]
    matches [p].

  {4 Comments}

  {4 Examples}
  In the program:
  {@asl[
  func main () => integer
  begin
    let x = 42 IN {0..3, -4};
    assert x == FALSE;
    return 0;
  end
  ]}
  The expression [42 IN {0..3, -4}] evaluates to the value [FALSE].

  In the program:
  {@asl[
  func main () => integer
  begin
    let x = 42 IN {0..3, 42};
    assert x == TRUE;
    return 0;
  end
  ]}
  The expression [42 IN {0..3, 42}] evaluates to [TRUE].

{2
Evaluation of Side-Effect-Free Expressions
}

  {3 SemanticsRule}
   [eval_expr_sef] specifies how to evaluate a side-effect-free expression [e]
   in an environment [env]. More precisely, [eval_expr_sef env e] is [eval_expr
   env e], if e is side-effect-free.

  {4 Comments}

  {3 Examples}
  <minimal example>

{2
Evaluation of Left-Hand-Side Expressions
}
[eval_lexpr version env le m] is [env[le --> m]].

The evaluation of the left-hand-side expression [le] associated with a value
[v] under an environment [env] is either [new_env] or an error is raised and
one of the following applies:

  {3 SemanticsRule.LEIgnore}

    {4 Rule}
    All of the following applies:
    - [le] can be ignored;
    - [new_env] is [env].

  {4 Comments}

  {4 Examples}
  The left-hand-side expression [-] within [- = 42;] evaluates to the value [42].

  {3 SemanticsRule.LELocalVar}

    {4 Rule}
    All of the following applies:
    - [le] denotes a variable [x];
    - [x] is locally bound in [env];
    - [new_env] is [env] where [x] has been assigned the value [v].

  {4 Comments}

    {4 Examples}
    {@asl[
     func main () => integer
     begin
       var x: integer = 3;
       x = 42;
     end
    ]}
    The evaluation of the left-hand-side expression [x] within [x = 42;] uses Rule.LELocalVar.

  {3 SemanticsRule.LEGlobalVar}

    {4 Rule}
    All of the following applies:
    - [le] denotes a variable [x];
    - [x] is globally bound in [env];
    - [new_env] is [env] where [x] has been assigned the value [v].

  {4 Comments}

    {4 Examples}
    {@asl[
     var x: integer = 3;

     func main () => integer
     begin
       x = 42;
     end
    ]}

    The evaluation of the left-hand-side expression [x] within [x = 42;] uses Rule.LEGlobalVar.

  {3 SemanticsRule.LEUndefIdentV1}

    {4 Rule}
    All of the following applies:
    - [le] denotes a variable [x] which is not bound in [env];
    - the ASL language version is V1;
    - an Error "UndefinedIdentifier" is raised.

  {4 Comments}

    {4 Examples}
    The evaluation of the left-hand-side expression [y] within [y = 3;] raises an "Undefined Identifier" error in the environment [x ⟶ 42].

  {3 SemanticsRule.LEUndefIdentV0}

    {4 Rule}
    All of the following applies:
    - [le] denotes a variable [x] which is not bound in [env];
    - the ASL language version is V0;
    - [new_env] is [env] where [x] has been declared a local identifier bound to
    the value [v].

  {4 Comments}

    {4 Examples}
    [y = 3;] binds [y] to [3] in [x ⟶ 42] ([new_env] is here [y ⟶ 3, x ⟶ 42]).

  {3 SemanticsRule.LESlice}

    {4 Rule}
    All of the following applies:
    - [le] denotes a left-hand-side expression sliced as per [slices];
    - The right-hand-side expression corresponding to [le] is [e_bv];
    - The evaluation of [re_bv] under [env] is [rv_bv];
    - The evaluation of [slices] under [env] is [positions];
    - [new_m_bv] is [rv_bv] where the positions [positions] have been updated to [v]
    - [new_env] is [env] where [le] has been assigned the value [new_m_bv].

  {4 Comments}

    {4 Examples}
    [x[3:0] = '0000'] binds [x] to ['11110000'] in [x ⟶ '11111111'].

  {3 SemanticsRule.LESetArray}

    {4 Rule}
    All of the following applies:
    - [le] denotes an array [le_array] and an index [e_index];
    - The right-hand-side expression corresponding to [le_array] is [re_array];
    - The evaluation of [re_array] under [env] is [rv_array];
    - The evaluation of [e_index] under [env] is [v_index];
    - [new_v_array] is [rv_array] where the value at index [v_index] has been
      updated to [v];
    - [new_env] is [env] where [le_array] has been assigned the value
      [new_v_array].

  {4 Comments}

    {4 Examples}
    {@asl[
     var my_array: array [42] of integer;
     my_array[3] = 53;
    ]}
    binds the [3rd] element of [my_array] to the value [53].

  {3 SemanticsRule.LESetField}

    {4 Rule}
    All of the following applies:
    - [le] denotes a field name [field_name] in a record [le_record];
    - The right-hand-side expression corresponding to [le_record] is
      [re_record];
    - The evaluation of [re_record] under [env] is [rv_record];
    - [new_v_record] is [rv_record] where the field [field_name] has been
      updated to [v];
    - [new_env] is [env] where [le_record] has been assigned the value
      [new_v_record].

  {4 Comments}

    {4 Examples}
    [my_record.a = 42;] binds [my_record] to [{a: 42, b: 42}] in the environment [my_record ⟶ {a: 3, b: 42}].

  {3 SemanticsRule.LESetFields}

    {4 Rule}
    <description>

  {4 Comments}

    {4 Examples}
    <minimal example>

  {3 SemanticsRule.LETuple}

    {4 Rule}
    All of the following applies:
    - [le] denotes a list of left-hand-side expressions [le_list];
    - [new_env] is [env] where each left-hand-side expression in [le_list] has
      been assigned the value at the corresponding index in [v].

    {4 Comments}

    {4 Examples}
    [(x, y) = (3, 42)] binds [x] to [3] and [y] to [42] in the environment [x ⟶ 42, y ⟶ 3].

{2
Evaluation of Expression Lists
}
  
  {3 Rule}

    {4 Rule}

    {4 Comments}

    {4 Examples}

{2
Evaluation of Slices
}
[eval_slices env slices] is the list of pair [(i_n, l_n)] that
corresponds to the start (included) and the length of each slice in
[slices].

[[3:2]] evaluates to [[(2, 2)]].

[[3:2, 42+:5]] evaluates to [[(2, 2), (42, 5)]].


{2
Evaluation of Patterns
}
[eval_pattern env pos v p] determines if [v] matches the pattern [p].
Formally, one of the following applies:

  {3 SemanticsRule.PAll}

    {4 Rule}
    [p] is the pattern which matches everything.

    {4 Comments}

    {4 Examples}
    [42 IN { - }] evaluates to [true].

  {3 SemanticsRule.PAny}

    {4 Rule}
    All of the following applies:
    - [p] gives a list of patterns [li_patterns];
    - [v] is a record of values [li_values];
    - each value in [li_values] matches the corresponding pattern in
      [li_patterns] in [env].

    {4 Comments}

    {4 Examples}
    [42 IN { 3, 42 }] evaluates to [true].

    [42 IN { 3, 4 }] evaluates to [false].

  {3 SemanticsRule.PGeq}

    {4 Rule}
    All of the following applies:
    - [p] gives a side-effect-free expression [e];
    - [v] is greater than or equal to the evaluation of [e] in [env].

    {4 Comments}

    {4 Examples}
    [42 IN { >= 3 }] evaluates to [true].

    [3 IN { >= 42 }] evaluates to [false].

  {3 SemanticsRule.PLeq}

    {4 Rule}
    All of the following applies:
    - [p] gives a side-effect-free expression [e];
    - [v] is lesser than or equal to the evaluation of [e] in [env].

    {4 Comments}

    {4 Examples}
    [3 IN { <= 42 }] evaluatest to [true].

    [42 IN { <= 3 }] evaluatest to [false].

  {3 SemanticsRule.PNot}

    {4 Rule}
    All of the following applies:
    - [p] gives a pattern [p'];
    - [v] matches the negation of [p'] in [env].

    {4 Comments}

    {4 Examples}
    [42 IN !{ 3 }] evaluates to [true].

    [42 IN !{ 42 }] evaluates to [false].

  {3 SemanticsRule.PRange}

    {4 Rule}
    All of the following applies:
    - [p] gives two side-effect-free expressions [e1] and [e2];
    - [v] is greater than or equal to [e1] in [env];
    - [v] is lesser than or equal to [e2] in [env].

    {4 Comments}

    {4 Examples}
    [42 IN {3..42}] evaluates to [true].

    [-3 IN {3..42}] evaluates to [false].

  {3 SemanticsRule.PSingle}

    {4 Rule}
    All of the following appplies:
    - [p] gives a side-effect-free expression [e];
    - [v] is equal to the evaluation of [e] in [env].

    {4 Comments}

    {4 Examples}
    [42 IN { 3 }] evaluates to [false].

  {3 SemanticsRule.PMask}

    {4 Rule}
    All the following applies:
    - [p] gives a mask [m]
    - [v] is a bitvector that matches the mask [m]

    {4 Comments}

    {4 Examples}
    ['101010' IN 'xx1010'] evaluates to [true].

    ['101010' IN '0x1010'] evaluates to [false].

  {3 SemanticsRule.PTuple}

    {4 Rule}
    All of the following applies:
    - [p] gives a list of patterns [li];
    - [v] matches the evaluation of all the patterns in the list [li] in [env].

    {4 Comments}

    {4 Examples}
    [(3, '101010') IN {( <= 42, 'xx1010')}] evaluates to [true].

{2
Evaluation of Local Declarations
}
[eval_local_decl s ldi env m_init_opt] declares local identifiers [ldi] in
[env] with an optional initialisation value [m_init_opt].  The evaluation of
the local identifiers [ldi] under an environment [env] is either [new_env] or
raises an error and one of the following applies:

  {3 SemanticsRule.LDIgnore}

    {4 Rule}
    All of the following applies:
    - [ldi] is an identifier which can be ignored;
    - [new_env] is [env].

    {4 Comments}

    {4 Examples}
    [var - = 3;] evaluates [3].

    [var - : integer;] does not modify the environment.

  {3 SemanticsRule.LDVar}

    {4 Rule}
    All of the following applies:
    - [ldi] is a variable [x];
    - [m_init_opt] is a value [m];
    - [new_env] is [env] modified to declare [x] as a local identifier bound to
      value [m].

    {4 Comments}

    {4 Examples}
    [var x = 3;] binds [x] to the evaluation of [3] in [env].

    [var x : integer = 3;] binds [x] to the evaluation of [3] in [env], without
    type consideration at runtime.

  {3 SemanticsRule.LDTypedVar}

    {4 Rule}
    All of the following applies:
    - [ldi] is a variable [x] of type [ty];
    - [m_init_opt] is [None];
    - [new_env] is [env] modified to declare [x] as a local identifier bound to
      the base value of [ty].

    {4 Comments}

    {4 Examples}
    [var x : integer;] binds [x] in [env] to the base value of [integer].

  {3 SemanticsRule.LDUninitialisedVar}

    {4 Rule}
    All of the following applies:
    - [ldi] is a variable [x] without a type nor an initialisation value;
    - an error is raised.

    {4 Comments}

    {4 Examples}
    [var x;] raises an error.

  {3 SemanticsRule.LDTuple}

    {4 Rule}
    All of the following applies:
    - [ldi] gives a list of local identifiers [ldis];
    - [m_init_opt] is a list of values [nmonads];
    - [new_env] is [env] modified to declare each element of [ldis] to be bound
      to the corresponding value in [nmonads].

    {4 Comments}

    {4 Examples}
    [var (x,y,z) = (1,2,3);] binds [x] (resp. [y], [z]) to the evaluation of
    [1] (resp. [2], [3]) in [env].

  {3 SemanticsRule.LDTypedTuple}

    {4 Rule}
    All of the following applies:
    - [ldi] gives a list of local identifiers [ldis] and a type [ty];
    - [m_init_opt] is [None];
    - [new_env] is [env] modified to declare each element of [ldis] with type
      [ty].

    {4 Comments}

    {4 Examples}
    [var (x,y,z) : integer;] binds [x], [y] and [z] in [env] to the base value
    of [integer].

  {3 SemanticsRule.LDUninitialisedTuple}

    {4 Rule}
    All of the following applies:
    - [ldi] gives a list of local identifiers [ldis];
    - [new_env] is [env] modified to declare each element of [ldis].

    {4 Comments}

    {4 Examples}
    [var (x : integer, y : boolean);] binds [x] to the base value of [integer]
    and [y] to the base value of [boolean].

{2
Evaluation of Statements
}
The evaluation [eval_stmt env s] of a statement [s] under environment [env] is
either a [Throwing], an interruption [Returning vs] or a new environment
[new_env]. Formally, one of the following applies:

  {3 SemanticsRule.SPass}

    {4 Rule}
    All of the following applies:
    - [s] is a pass statement;
    - [new_env] is [env].

    {4 Comments}

    {4 Examples}
    [pass;] does nothing.

  {3 SemanticsRule.SAssign}

    {4 Rule}
    All of the following applies:
    - [s] is an assignment [le = re];
    - [v] is the evaluation of [re] under [env];
    - [r_env] is [env] modified after evaluation of [re] under [env];
    - [new_env] is [r_env] modified after evaluation of [le] under [r_env] with
      [v].

    {4 Comments}

    {4 Examples}
    [x = 3;] binds [x] to [3] in [x ⟶ 42] ([new_env] is here [x ⟶ 3]).

  {3 SemanticsRule.SAssignCall}

    {4 Rule}
    <description>

    {4 Comments}

    {4 Examples}
    <minimal example>

  {3 SemanticsRule.SAssignTuple}

    {4 Rule}
    <description>

    {4 Comments}

    {4 Examples}
    <minimal example>

  {3 SemanticsRule.SReturnNone}

    {4 Rule}
    All of the following applies:
    - [s] is a return statement;
    - [vs] is [[]];
    - [new_env] is [env].

    {4 Comments}

    {4 Examples}
    [return;] exits the current procedure.

    [func foo ()
     begin
       for i = 0 to 42 do
         if i >= 3 then
           return;
         end
         print(i);
       end
     end
     func main () => integer begin foo (); return 0; end]
     prints "012".

  {3 SemanticsRule.SReturnOne}

    {4 Rule}
    All of the following applies:
    - [s] is a return statement;
    - [s] gives an expression [e];
    - [v] is the evaluation of [e] under [env];
    - [vs] is [[v]];
    - [new_env] is [env] modified after evaluation of [e] under [env].

    {4 Comments}

    {4 Examples}
    [return 3;] exits the current function with value [3].

  {3 SemanticsRule.SReturnSome}

    {4 Rule}
    All of the following applies:
    - [s] is a return statement;
    - [s] gives a list of expressions [es];
    - [vs] is the piece-wise evaluation of the list [es] under [env];
    - [new_env] is [env] modified after evaluation of [e] under [env].

    {4 Comments}

    {4 Examples}
    [return (3, 42);] exits the current function with value [(3, 42)].

  {3 SemanticsRule.SThen}

    {4 Rule}
    All of the following applies:
    - [s] is a then statement;
    - [s] gives two statements [s1] and [s2];
    - [env'] is [env] modified after evaluation of [s1];
    - [new_env] is [env'] modified after evaluation of [s2].

    {4 Comments}

    {4 Examples}
    [print(3); print(42);] prints "342".

  {3 SemanticsRule.SCall}

    {4 Rule}
    All of the following applies:
    - [s] is a call statement;
    - [s] gives a function name [name], actual arguments [actual_args] and
      parameters [params];
    - [env'] is [env] modified after evaluation of the function call;
    - [new_env] is [env'].

    {4 Comments}

    {4 Examples}
    [Zeros(3)] evaluates to ['000'].

  {3 SemanticsRule.SCond}

    {4 Rule}
    All of the following applies:
    - [s] is a conditional statement;
    - [s] gives a condition [cond] and two statements [s1] and [s2];
    - [v_cond] is the evaluation of [cond];
    - [new_env] is [env] modified after evaluation of [s1] or [s2] depending on
      [v_cond].

    {4 Comments}

    {4 Examples}
    [if TRUE then print(3); else print(42); end] prints "3".

  {3 SemanticsRule.SCase}

    {4 Rule}
    <description>

    {4 Comments}

    {4 Examples}
    [match 3 with
     case 42: print("equals 42.");
     case <= 42: print("less than 42.");
     otherwise: print("bigger than 42.");] prints "less than 42."

  {3 SemanticsRule.SAssert}

    {4 Rule}
    All of the following applies:
    - [s] is an assert statement;
    - [s] gives an expression [e];
    - [v] is the evaluation of [e];
    - if [v] is true then [new_env] is [env], otherwise an AssertionFailed
      error is raised.

    {4 Comments}

    {4 Examples}
    [assert (42 != 3);] ensures that [3] is not equal to [42].
    [assert (42 == 3);] raises an [AssertionFailed] error.

  {3 SemanticsRule.SWhile}

    {4 Rule}
    All of the following applies:
    - [s] is a while statement;
    - [s] gives an expression [e] and a loop body [body];
    - [new_env] is [env] modified after evaluation of the loop [(e,body)].

    {4 Comments}

    {4 Examples}
    [var i: integer = 0;
     while i <= 3 do
       print (i);
       i = i + 1;
     end] prints "0123".

  {3 SemanticsRule.SRepeat}

    {4 Rule}
    All of the following applies:
    - [s] is a repeat statement;
    - [s] gives an expression [e] and a loop body [body];
    - [new_env] is [env] modified after evaluation of the loop [(e,body)].

    {4 Comments}

    {4 Examples}
    [var i: integer = 0;
     repeat
       print(i);
       i = i + 1;
     until i > 3;] prints "0123".

  {3 SemanticsRule.SFor}

    {4 Rule}
    All of the following applies:
    - [s] is a for statement;
    - [s] gives [(id,e1,dir,e2,s)];
    - <description>

    {4 Comments}

    {4 Examples}
    [for i = 0 to 3 do
       print (i);
     end] prints "0123".

  {3 SemanticsRule.SThrowNone}

    {4 Rule}
    All of the following applies:
    - [s] is a throw statement;
    - <description>

    {4 Comments}

    {4 Examples}
    [try throw MyException;
     catch MyException: throw;] throws a [MyException] exception.

  {3 SemanticsRule.SThrowSomeTyped}

    {4 Rule}
    All of the following applies:
    - [s] is a throw statement;
    - <description>

    {4 Comments}

    {4 Examples}
    [thow MyException { a: 3, b: 42 };] throws a [MyException {a: 3, b: 42}] exception.

  {3 SemanticsRule.SThrowSome}

    {4 Rule}
    All of the following applies:
    - [s] is a throw statement;
    - <description>

    {4 Comments}

    {4 Examples}
    <minimal example>

  {3 SemanticsRule.STry}

    {4 Rule}
    All of the following applies:
    - [s] is a try statement;
    - [s] gives [(s', catchers, otherwise_opt)];
    - [s_m] is the evaluation of the block [s'] under [env];
    - [new_env] is [env] modified after evaluation of the catchers [(catchers
      otherwise_opt s_m)].

    {4 Comments}

    {4 Examples}
    [try throw MyException;
     catch MyException: print(3);] prints "3".

  {3 SemanticsRule.SDeclSome}

    {4 Rule}
    All of the following applies:
    - [s] is a declaration;
    - [s] gives [(_ldk, ldi, Some e)];
    - [new_env] is [env] modified after evaluation of the local declaration
      [ldi env (Some m)].

    {4 Comments}

    {4 Examples}
    [let x = 3;] binds [x] to [3] in the empty environment.

  {3 SemanticsRule.SDeclNone}

    {4 Rule}
    All of the following applies:
    - [s] is a declaration;
    - [s] gives [(_dlk, ldi, None)];
    - [new_env] is [env] modified after evaluation of the local declaration
      [ldi env None].

    {4 Comments}

    {4 Examples}
    [var x : integer;] binds [x] in [env] to the base value of [integer].

  {3 SemanticsRule.SDebug}

    {4 Rule}
    All of the following applies:
    - [s] is a debug statement;
    - [s] gives a side-effect-free expression [e];
    - [v] is the evaluation of [e];
    - [new_env] is [env].

    {4 Comments}

    {4 Examples}
    <minimal example>

{2
Evaluation of Blocks
}

  {3 SemanticsRule.Block}

    {4 Rule}
    [eval_block env stm] is [new_env] and all of the following applies:
    - [block_env] is [env] such that the scope given by [env] is pushed onto the
      declaration stack;
    - [block_env'] is [env] modified after the evaluation of the statement [stm];
    - [new_env] is [block_env'] after restoring the variable bindings of [env],
    with the updated values of [block_env'].

    {4 Comments}

    {4 Examples}
    <minimal example>

{2
Evaluation of [while] and [repeat] loops
}
[eval_loop is_while env e_cond body] evaluates [body] in [env]: this is either
an interruption [Returning vs] or a new environment [new_env].

  {3 SemanticsRule.Loop}

    {4 Rule}
    Formally, [cond_m] evaluates to [e_cond] or [not e_cond] as determined by
    [is_while] and one of the following applies:

    - All of the following applies:
      * [cond_m] evaluates to [false];
      * [new_env] is [env]---the loop is exited.
    - All of the following applies:
      * [cond_m] evaluates to [true];
      * [env1] is [env] modified after the evaluation of the statement
       [body]---this step might affect the value of [cond_m] eventually leading
       to exiting the loop;
      * [new_env] is [env1] modified after the evaluation of [eval_loop
        is_while env e_cond body].

    {4 Comments}

    {4 Examples}
    [var i: integer = 0;
     while i <= 3 do
       print (i);
       i = i + 1;
     end] prints "0123".

{2
Evaluation of [for] loops
}
[eval_for undet env index_name v_start dir v_end body] evaluates [body] in
[env]: this is either an interruption [Returning vs] or a new environment
[new_env].

  {3 SemanticsRule.For}

    {4 Rule}
    Formally, [cond_m] evaluates to [leq v_end v_start] or [geq v_end v_start]
    as determined by [dir] and one of the following applies:

    - All of the following applies:
      * [cond_m] evaluates to [true];
      * [new_env] is [env] as the loop is exited.
    - All of the following applies:
      * [cond_m] evaluates to [false];
      * [env1] is [env] modified after the evaluation of the statement [body];
      * [env2] is [env1] modified such that [index_name] is bound to [v_step];
      * [v_step] evaluates to [v_start+1] or [v_start-1] as determined by [dir];
      * [new_env] is [env2] modified after the evaluation of [eval_for undet
        env index_name v_step dir v_end body].

    {4 Comments}

    {4 Examples}
    [for i = 0 to 3 do
       print (i);
     end] prints "3".

{2
Evaluation of Catchers
}
[eval_catchers env catchers otherwise_opt s_m], given the result [s_m] of the
evaluation of a statement under environment [env] is [res] which is either a
[Throwing (v, v_ty, env_throw)], an interruption [Returning vs] or a new
environment [new_env]. Formally, one of the following applies:

  {3 SemanticsRule.Catch}

    {4 Rule}
    All of the following applies:
    - [s_m] is [Throwing (v, v_ty, env_throw)];
    - [catcher] is the first catcher in [catchers] that matches [v_ty];
    - [catcher] does not declare a name;
    - [catcher] gives a statement [s];
    - One of the following applies:
      - [env_throw] and [env] have the same scope, and [env1] is [env_throw];
      - [env1] is the environment formed with the global part of [env_throw]
        and the local part of [env];
    - One of the following applies:
      - [Throwing (None, None, env_throw1)] is the result of the evaluation of
        the block [s] in [env1], and [res] is [Throwing (v, v_ty, env_throw1)];
      - [res] is the result of the evaluation of the block [s] in [env1].

    {4 Comments}

    {4 Examples}
    {@asl[
    try throw
      MyExceptionType {};
      print("No exception raised");
    catch
      when MyExceptionType =>
      print("MyException");
    otherwise =>
      print("Another exception");
    ]}
    prints "MyException".

  {3 SemanticsRule.CatchNamed}

    {4 Rule}
    All of the following applies:
    - [s_m] is [Throwing (v, v_ty, env_throw)];
    - [catcher] is the first catcher in [catchers] that matches [v_ty];
    - [catcher] declares a name [name];
    - [catcher] gives a statement [s];
    - One of the following applies:
      - [env_throw] and [env] have the same scope, and [env1] is [env_throw];
      - [env1] is the environment formed with the global part of [env_throw]
        and the local part of [env];
    - [env2] is [env1] modified after binding locally [name] to the exception
      [v] raised by [s_m];
    - One of the following applies:
      - [Throwing (None, None, env_throw1)] is the result of the evaluation of
        the block [s] in [env2], and [res] is [Throwing (v, v_ty, env_throw1)];
      - [env3] is [env2] modified after the evaluation of the block [s] in
        [env2], and [new_env] is [env3] modified after unbinding [name] from
        [env3].
      - [res] is the result of the evaluation of the block [s] in [env2].

    {4 Comments}

    {4 Examples}
    {@asl[
    try throw
      MyExceptionType { msg: "My exception with my message" };
    catch
      when MyExceptionType: exn =>
      print(exn.msg);
    otherwise =>
    print("Another exception");
    ]}
    prints "My exception with my message".

  {3 SemanticsRule.CatchOtherwise}

    {4 Rule}
    All of the following applies:
    - [s_m] is [Throwing (v, v_ty, env_throw)];
    - [otherwise_opt] is [Some s];
    - no catcher matches [v_ty];
    - One of the following applies:
      - [env_throw] and [env] have the same scope, and [env1] is [env_throw];
      - [env1] is the environment formed with the global part of [env_throw]
        and the local part of [env];
    - One of the following applies:
      - [Throwing (None, None, env_throw1)] is the result of the evaluation of
        the block [s] in [env1], and [res] is [Throwing (v, v_ty, env_throw1)];
      - [res] is the result of the evaluation of the block [s] in [env1].

    {4 Comments}

    {4 Examples}
    {@asl[
     try throw
       MyExceptionType1 {};
       print("No exception raised");
       catch
         when MyExceptionType2 =>
         print("MyException2");
       otherwise =>
         print("Another exception");
     ]}
     prints "Another exception"

  {3 SemanticsRule.CatchNone}

    {4 Rule}
    All of the following applies:
    - [s_m] is [Throwing (v, v_ty, env_throw)];
    - [otherwise_opt] is [None];
    - no catcher matches [v_ty];
    - [new_env] is [env].

    {4 Comments}

    {4 Examples}
    {@asl[
     try throw
       MyExceptionType1 {};
       print("No exception raised");
       catch
         when MyExceptionType2 =>
         print("MyException2");
    ]}
    does not print anything.

  {3 SemanticsRule.CatchNoThrow}

    {4 Rule}
    All of the following applies:
    - [s_m] is not [Throwing];
    - [res] is [s_m].

    {4 Comments}

    {4 Examples}
    {@asl[
    try
      print ("No exception raised");
    catch
      when MyExceptionType =>
        print("MyException");
      otherwise =>
        print("Another exception");
    ]}
    prints "No exception raised".

{2
Evaluation of Function Calls
}
[eval_call pos name env args named_args] evaluates the call to function [name]
with arguments [args] and parameters [named_args].

  {4 Rule}
  <description>

  {4 Comments}

  {4 Examples}
  At the begining of a program, the interpreter evaluates the function "main".

{2
Evaluation of Functions
}
[eval_func genv name pos actual_args params] evaluates the function named
[name] in the global environment [genv], with [actual_args] the list of actual
arguments, and [params] the list of arguments deduced by type equality. This is
a new global environment [new_genv] and a list of values [vs], or an error is
raised. Formally, one of the following applies:

{3 SemanticsRule.FUndefIdent}

  {4 Rule}
  All of the following applies:
  - [name] is undeclared in [genv];
  - an [UndefinedIdentifier] error is raised.

  {4 Comments}

  {4 Examples}
  [func main () => integer
   begin
     Foo ();
   end]
  raises an [UndefinedIdentifier "Foo"] error.

{3 SemanticsRule.FPrimitive}

  {4 Rule}
  All of the following applies:
  - [name] is bound in [genv] to a primitive function with a body [body];
  - [new_genv] is [genv];
  - [vs] is the application of [body] on [actual_args].

  {4 Comments}

  {4 Examples}
  [print (2,3);] calls the primitive [print] on the evaluation of [(2,3)].

{3 SemanticsRule.FBadArity}

  {4 Rule}
  All of the following applies:
  - [name] is bound in [genv] to a function with a list of formal arguments
    [arg_decls];
  - the lists [actual_args] and [arg_decls] do not have the same length;
  - a "BadArity" error is raised.

  {4 Comments}

  {4 Examples}
  [Zeros(3,4);] raises a [BadArity "Zeros" 1 2] error.

{3 SemanticsRule.FCall}

  {4 Rule}
  All of the following applies:
  - [name] is bound in [genv] to a function with a list of formal arguments
    [arg_decls] and a body statement [body];
  - [env1] is the environment made of [genv] and the empty local environment,
  - [env2] is [env1] modified so that each formal argument in [arg_decls] is
    locally bound to the corresponding actual argument in [actual_args];
  - [env3] is [env2] modified so that each parameter in [params] is declared;
  - [res] is the evaluation of [body] in [env3] and one of the following
    applies:
      + [res] is an environment [env4] and [new_genv] is the global environment
        given by [env4]---e.g. where the function called is either a setter or
        a procedure as per Rule R_DFWZ;
      + [res] is an interruption [Returning(xs,ret_genv)] and [new_genv] is
        [ret_genv]---this is the general case.

  {4 Comments}

  {4 Examples}
  {@asl[
   func foo (x : integer) => integer
   begin
     return x + 1;
   end

   func bar (x : integer) => integer
   begin
     print(x);
   end

   func main () => integer
   begin
     foo(2);
     bar(3);
    return 0;
   end]}
