(*
 * SPDX-FileCopyrightText: Copyright 2022-2023 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: BSD-3-Clause
 *)
(*
    **DISCLAIMER**: The ASL reference implementation can be found in `herdtools7/asllib`. This tool and any files generated by it are **NOT** a reference ASL implementation!
    Modifications of generated files will lead to an **UNSUPPORTED** divergence from the reference implementation and should **NOT** be done!
*)

(*
    Translate ASL's grammar in ASLRef to a BNFC-style structure
 *)
open BNFC

(* Translate ids to be bnfc compliant (CamelCase) *)
let snake_case_to_camel_case id =
  String.split_on_char '_' id
  |> List.filter (function "" -> false | _ -> true)
  |> List.map (fun n -> String.lowercase_ascii n |> String.capitalize_ascii)
  |> String.concat ""

(** Convert a menhir cmly file to bnfc AST *)
module Convert (MenhirGrammar : MenhirSdk.Cmly_api.GRAMMAR) : sig
  val entrypoints : string list
  val decls : decl list
end = struct
  (* Load the grammar module *)
  open MenhirGrammar

  (* A hardcoded value of a common End-of-file token *)
  let eof_token = "EOF"

  (* Create useful mapping structures *)
  module ProductionMap = Map.Make (Production)
  module NonterminalMap = Map.Make (Nonterminal)

  (* Create a terminal set structure *)
  module TerminalSet = Set.Make (Terminal)

  (* Utility functions for easy name extraction *)
  let n_name nterm = Nonterminal.mangled_name nterm |> snake_case_to_camel_case
  let t_name = Terminal.name

  (* A utility function to check if a set of attributes contains any ones which signal the object being internal *)
  let is_external attrs =
    List.for_all (fun a -> not @@ Attribute.has_label "internal" a) attrs

  (*
     A utility function to check if a nonterminal is external
     A nonterminal is external if its attributes don't mark it as internal.
    *)
  let is_external_nterm nterm = is_external @@ Nonterminal.attributes nterm
  let is_external_term term = is_external @@ Terminal.attributes term

  (*
     A utility function to check if a production is external
     A production is external when:
         * Is a regular production (not a builtin special production such as error or #)
         * It doesn't contain an attribute marking it as internal
         * Its parent nonterminal is external
         * All its rhs symbols are external
    *)
  let is_external_prod prod =
    let is_regular =
      match Production.kind prod with `REGULAR -> true | _ -> false
    in
    let is_external_prod = is_external @@ Production.attributes prod in
    let parent_nterm_is_external = is_external_nterm @@ Production.lhs prod in
    let is_external_sym (sym, _, attrs) =
      let check_sym = match sym with | T t -> is_external_term t | N n -> is_external_nterm n in
      check_sym && is_external attrs
    in
    let rhs_all_external =
      Array.for_all is_external_sym
      @@ Production.rhs prod
    in
    is_regular && is_external_prod && parent_nterm_is_external && rhs_all_external

  (* 1. Collect entry points *)
  let entrypoints : string list =
    let is_allowed (nterm, _, _) =
      if is_external_nterm nterm then Some (n_name nterm) else None
    in
    List.filter_map is_allowed Grammar.entry_points

  (* 2. Infer operator precedence from the lr(1) state machine. *)
  (* 2.1. Crate a mapping linking each nonterminal to a mapping which contains
          all of that nonterminal's productions linked to the set of tokens which cause
          the productions to reduce *)
  let production_to_terminals : TerminalSet.t ProductionMap.t NonterminalMap.t =
    let build_map lr1 acc =
      let reductions = Lr1.get_reductions lr1 in
      List.fold_left
        (fun a (term, prod) ->
          let nterm = Production.lhs prod in
          NonterminalMap.update nterm
            (fun opt_prod_map ->
              let prod_map =
                Option.value ~default:ProductionMap.empty opt_prod_map
              in
              Some
                (ProductionMap.update prod
                   (fun opt_set ->
                     let set =
                       Option.value ~default:TerminalSet.empty opt_set
                     in
                     Some (TerminalSet.add term set))
                   prod_map))
            a)
        acc reductions
    in
    Lr1.fold build_map NonterminalMap.empty
    (* Only retain external nonterminals and productions *)
    |> NonterminalMap.filter (fun n _ -> is_external_nterm n)
    |> NonterminalMap.map (ProductionMap.filter (fun p _ -> is_external_prod p))

  (* 2.2. Determine the nonterminals with ambiguous precedence *)
  (* We do this by finding all the nonterminals whose productions are reduced by differing terminal sets *)
  let ambiguous_production_sets : TerminalSet.t ProductionMap.t NonterminalMap.t
      =
    NonterminalMap.filter
      (fun _ prod_map ->
        let opt_set = ProductionMap.choose_opt prod_map in
        match opt_set with
        | None -> false
        | Some (_, set) ->
            ProductionMap.exists
                (fun _ set2 -> not @@ TerminalSet.equal set set2)
                prod_map)
      production_to_terminals

  (* 2.3. (TODO) It may be necessary to verify that the nonterminals are actually related (are part of the same component on the parse graph *)
  (* The next steps should likely be run for each connected component and produce a `production list list` for each *)

  (* A utility function to get the last element of an array or None if the array is empty *)
  let get_last arr =
    let len = Array.length arr in
    if len = 0 then None else Some arr.(len - 1)

  (* 2.4. Determine if any of the detected nonterminals can be removed and do so if possible *)
  (* If a nonterminal has productions such that all but one production end in a recursive call, we observe that
     the tokens which reduce the final production must also reduce all the others, since they cannot build
     otherwise.

     This is sometimes possible. There seems to be an inefficiency in the LR(1) table which causes the following case to happen:

         A := ... B [t1, t2]
         A := ... A [t1, t2, t3, ...]

         B := ... A [t1, t2, t3, ...]

         C := ... A [t1, t2, t3, ...]
         ...

      In this case we can infer that all highlighted cases share the same terminal reduction set as `A := ... B` because:
          * `A := ... B` is the last reduction of `A` (as all others recurse as their last step), so its terminals are what reduces the wider `A`
          * `B := ... A` will always reduce with the last reduction terminal set of `A` (or the subset overlapping with `A`)
          * `C := ... A` will always reduce with the last reduction terminal set of `A` (or the subset overlapping with `A`)

     The following function therefore would remove the A nonterminal from consideration and update the terminal sets
     of the productions in B and C which terminate in A to match the [t1; t12] case.
  *)
  let reduced_production_sets : TerminalSet.t ProductionMap.t NonterminalMap.t =
    let get_last_rhs prod = get_last @@ Production.rhs prod in
    let prod_ends_with prod nterm =
      match get_last_rhs prod with
      | Some (N n, _, _) -> Nonterminal.equal n nterm
      | _ -> false
    in
    let get_last_set prod_map =
      let non_rec_only =
        ProductionMap.filter
          (fun prod _ -> not @@ prod_ends_with prod @@ Production.lhs prod)
          prod_map
      in
      if ProductionMap.cardinal non_rec_only = 1 then
        let _, set = ProductionMap.choose non_rec_only in
        Some set
      else None
    in
    let partition_has_last  =
      NonterminalMap.partition
        (fun _ prod_map -> get_last_set prod_map |> Option.is_some)
    in
    (* Filter out any terminating productions from the ambiguous precedence set *)
    let _, rest_map =
      partition_has_last ambiguous_production_sets
    in
    (* Collect all productions which have a single possible "final" token list *)
    let has_last_map, _ =
      partition_has_last production_to_terminals
    in
    let nterm_to_set : TerminalSet.t NonterminalMap.t =
      NonterminalMap.map
        (fun prod_map -> get_last_set prod_map |> Option.get)
        has_last_map
    in
    NonterminalMap.map
      (fun prod_map ->
        ProductionMap.mapi
          (fun prod set ->
            match get_last_rhs prod with
            | Some (N n, _, _) -> (
                match NonterminalMap.find_opt n nterm_to_set with
                | None -> set
                | Some s -> TerminalSet.inter set s)
            | _ -> set)
          prod_map)
      rest_map

  (* 2.5. We need to determine the associativity of each of the terminals in the ambiguous precedence cases *)
  (*
     For each production in the remaining set of the form

     expr := expr op (...)

     we look for an LR1 table entry at the end of the production rule:

     expr op (...) (HERE)

     For all entries at that location we assert associativity by checking if
     op is a shift rule (Right associativity), a reduce rule (Left associativity)
     or neither (Nonassoc) *)
  type associativity = Left | Right | Nonassoc

  let associativity_map : associativity ProductionMap.t =
    let target_productions : Production.t list =
      NonterminalMap.map
        (fun prod_map -> ProductionMap.bindings prod_map |> List.map fst)
        reduced_production_sets
      |> NonterminalMap.bindings |> List.map snd |> List.flatten
    in
    let is_rec n = NonterminalMap.mem n reduced_production_sets in
    let get_assoc p =
      let rhs = Production.rhs p |> Array.map (fun (s, _, _) -> s) in
      let len = Array.length rhs in
      let target_term =
        match Array.to_list rhs with
        | N n :: T t :: _ when is_rec n -> Some t
        | _ -> None
      in
      if Option.is_none target_term then Nonassoc
      else
        let target_term = Option.get target_term in
        let assoc_test assoc_type lr1 acc =
          let lr0 = Lr1.lr0 lr1 in
          let prod_locs = Lr0.items lr0 in
          let in_last =
            List.exists
              (fun (p2, i) -> Production.equal p p2 && Int.equal i len)
              prod_locs
          in
          if not in_last then acc
          else
            let reductions = Lr1.get_reductions lr1 in
            let shifts = Lr1.transitions lr1 in
            let is_reduced =
              List.exists
                (fun (t, p2) ->
                  Terminal.equal target_term t && Production.equal p p2)
                reductions
            in
            let is_shifted =
              List.exists
                (function T t, _ -> Terminal.equal t target_term | _ -> false)
                shifts
            in
            match assoc_type with
            | Nonassoc -> ((not is_shifted) && not is_reduced) && acc
            | Right -> is_shifted && (not is_reduced) && acc
            | Left -> is_reduced && (not is_shifted) && acc
        in
        let is_nassoc = Lr1.fold (assoc_test Nonassoc) true in
        let is_right = Lr1.fold (assoc_test Right) true in
        if is_nassoc then Nonassoc else if is_right then Right else Left
    in
    List.fold_left (fun acc p ->
        ProductionMap.add p (get_assoc p) acc)
    ProductionMap.empty target_productions

  (* 2.6. Generate a precedence list by sorting the productions by the
          length of terminals following them - shortest meaning lowest precedence *)
  (* An example of what this nested list could look like (production type being expanded for clarity):

       [
           [
               A := A "+" B
               B := B "+" B
           ];
           [
               A := A "*" B
               B := B "*" B
           ]
       ]

     Notes:
       * Since we could have more than one (related) nonterminal we expect
         the precedence levels of the nonterminals to overlap.
         Each nonterminal, however, could appear in a different part of the parse tree
         as such we need to only consider terminals coming from the target productions themselves.
         (Not where the A and B nonterminals are used, but only their recursive calls)
  *)
  let precedence_list : Production.t list list =
    (* First create a nested production list for each nonterminal.
       The lowest precedence is the one produced by the fewest terminals. *)
    let nterm_prec_levels : Production.t list list NonterminalMap.t =
      NonterminalMap.map
        (fun prod_map ->
          let simplified = ProductionMap.map TerminalSet.cardinal prod_map in
          let sorted =
            ProductionMap.bindings simplified
            |> List.sort (fun (_, c1) (_, c2) -> Int.compare c1 c2)
          in
          let rec loop prod_list =
            match prod_list with
            | [] -> []
            | (_, c1) :: _ ->
                let current_level, rest =
                  List.partition (fun (_, c2) -> Int.equal c1 c2) prod_list
                in
                let level = List.map fst current_level in
                level :: loop rest
          in
          loop sorted)
        reduced_production_sets
    in
    (* For each precedence level in each nonterminal we collect the set of terminals which cause a reduction in each production.
       In other words we collect all terminals which follow one of the target nonterminals
       We do this to determine which levels introduce which operands.

       Note: Ideally these sets would exactly match the binary ops which have a set precedence and associativity
             This is not the case as this approach is fairly naive (but is almost exact) a better one might be
             to try to build an LR1 parser and see near which terminals we get shift/reduce conflicts. *)
    let term_sets : TerminalSet.t list NonterminalMap.t =
      let rec collect_terms terms set =
        match terms with
        | (N n, _, _) :: (T t, _, _) :: tl
          when NonterminalMap.mem n nterm_prec_levels ->
            collect_terms tl (TerminalSet.add t set)
        | (N n, _, _) :: ((N n2, _, _) :: _ as tl)
          when NonterminalMap.mem n nterm_prec_levels ->
            let follow : TerminalSet.t =
              Nonterminal.first n2 |> TerminalSet.of_list
            in
            collect_terms tl (TerminalSet.union set follow)
        | _ :: tl -> collect_terms tl set
        | [] -> set
      in
      NonterminalMap.map
        (fun prec_list ->
          List.fold_right
            (fun level acc ->
              List.fold_right
                (fun prod set ->
                  let rhs = Production.rhs prod |> Array.to_list in
                  collect_terms rhs set)
                level TerminalSet.empty
              :: acc)
            prec_list [])
        nterm_prec_levels
    in
    (* Lastly we merge all the nonterminal precedence levels by matching them up against each other's
       terminal sets. If two sets overlap the they belong to the same precedence level.
       A nonterminal might skip a precedence level if it omits another nonterminal's operands or it
       could introduce its own operands at a new level.

       As we merge the new level with the accumulation in the case of a non-overlap
       we decide which one to prioritize based on whether the new level for consideration
       appears later in the accumulation. If yes, then all other old levels must come
       before it and have a relatively lower precedence. Otherwise if the new level does
       not appear in the accumulation we insert it expecting a later ovelrap *)
    NonterminalMap.fold
      (fun nterm prec_levels acc ->
        let other_ops_per_level = NonterminalMap.find nterm term_sets in
        let new_levels = List.combine prec_levels other_ops_per_level in
        let is_inter s1 s2 =
          not @@ TerminalSet.is_empty @@ TerminalSet.inter s1 s2
        in
        let rec merge_levels old_levels new_levels =
          match (old_levels, new_levels) with
          | _, [] -> old_levels
          | [], _ -> new_levels
          | (old_l, old_s) :: old_tl, (new_l, new_s) :: new_tl
            when is_inter old_s new_s ->
              (old_l @ new_l, TerminalSet.union old_s new_s)
              :: merge_levels old_tl new_tl
          | (old_l, old_s) :: old_tl, (new_l, new_s) :: new_tl ->
              if
                List.exists
                  (fun (_, next_old_s) -> is_inter next_old_s new_s)
                  old_tl
              then (old_l, old_s) :: merge_levels old_tl new_levels
              else (new_l, new_s) :: merge_levels old_levels new_tl
        in
        merge_levels acc new_levels)
      nterm_prec_levels []
    |> List.split |> fst

  (* 2.7. Split off any non left recursive rules from each precedence level to their own lower one (e.g. unary ops) *)
  (* Unary ops don't produce other unary ops, which means unary ops always end up in a precedence level above thier own.
     They must be separate to avoid shift/reduce conflicts *)
  let with_unary_precedence_levels : Production.t list list =
    let split_l_rec prec_grp acc =
      let is_not_l_rec prod =
        let rhs = Production.rhs prod in
        let is_rec (sym, _, _) =
          match sym with
          | N n -> NonterminalMap.mem n reduced_production_sets
          | _ -> false
        in
        Array.length rhs > 0 && is_rec rhs.(0)
      in
      let l_rec, rest = List.partition is_not_l_rec prec_grp in
      match (l_rec, rest) with
      | [], _ -> rest :: acc
      | _, [] -> l_rec :: acc
      | _ -> l_rec :: rest :: acc
    in
    List.fold_right split_l_rec precedence_list []

  (* 2.8. Correct any binary expr productions which are in the wrong level *)
  (* Binary ops of the form:

       A := A op TERMINAL

     appear to not mirror the precedence level of other occurances of op where

       A := A op A

     these must be at the same level to avoid shift/reduce conflicts *)
  let final_precedence_levels : Production.t list list =
    let get_binary_op p =
      let nterm = Production.lhs p in
      let is_nterm sym =
        match sym with N n -> Nonterminal.equal nterm n | _ -> false
      in
      match Production.rhs p |> Array.map (fun (s, _, _) -> s) with
      | [| s1; T op; s2 |] when is_nterm s1 || is_nterm s2 -> Some op
      | _ -> None
    in
    let rec reorder_binops ?(seen = TerminalSet.empty) prec_levels =
      match prec_levels with
      | [] -> []
      | level :: rest ->
          let ops, level =
            List.fold_right
              (fun p (ops, level) ->
                match get_binary_op p with
                | None -> (ops, p :: level)
                | Some t when TerminalSet.mem t seen -> (ops, level)
                | Some t -> (TerminalSet.add t ops, p :: level))
              level (TerminalSet.empty, [])
          in
          let same_binary_ops =
            List.filter
              (fun prod ->
                match get_binary_op prod with
                | Some op -> TerminalSet.mem op ops
                | None -> false)
              (List.concat rest)
          in
          let seen = TerminalSet.union ops seen in
          (level @ same_binary_ops) :: reorder_binops ~seen rest
    in
    reorder_binops with_unary_precedence_levels
    (* Sort the productions in definition order for consistency *)
    |> List.map (List.sort Production.compare)

  (* 3. Convert all productions to bnfc *)
  (* We first convert the precedence related tokens by adding a new bnf level for each entry in the precedence list
     while keeping track of which level we are at for each nonterminal *)
  (* Last we trivailly convert all remaining productions. They are all a 1:1 mapping from menhir productions to bnfc lines *)

  (* Define some common case suffixes *)
  let single_rule_suffix = "_Rule"
  let none_rule_suffix = "_None"
  let some_rule_suffix = "_Some"

  (* A utility function to create a list of suffixes from a list of productions *)
  let mk_short_suffixes (prod_list : Production.t list) : string list =
    let mk_verbose_suffix prod =
      let rhs = Production.rhs prod in
      if Array.length rhs = 0 then [ none_rule_suffix ]
      else
        Array.map
          (function N n, _, _ -> n_name n | T t, _, _ -> t_name t |> snake_case_to_camel_case)
          rhs
        |> Array.to_list
    in
    let suffix_list = List.map mk_verbose_suffix prod_list in
    let rec trim_prefix suff_ls =
      let same_prefix =
        if List.for_all (fun l -> List.length l > 1) suff_ls then
          let prefix = List.hd @@ List.hd suff_ls in
          List.for_all (fun l -> String.equal (List.hd l) prefix)
          @@ List.tl suff_ls
        else false
      in
      if same_prefix then trim_prefix (List.map List.tl suff_ls) else suff_ls
    in
    let trim_suffix suff_ls =
      let shorten name_list =
        let rec cmp_lists test ls =
          match (test, ls) with
          | hd1 :: tl1, hd2 :: tl2 when String.equal hd1 hd2 ->
              cmp_lists tl1 tl2
          | [], _ -> 1
          | _ -> 0
        in
        let count_prefixed_by test acc ls =
          if List.length test > List.length ls then acc
          else cmp_lists test ls + acc
        in
        let rec find_shortest test rem =
          match rem with
          | hd :: tl
            when not (List.fold_left (count_prefixed_by test) 0 suff_ls = 1) ->
              find_shortest (test @ [ hd ]) tl
          | _ -> test
        in
        match name_list with [] -> [] | hd :: tl -> find_shortest [ hd ] tl
      in
      List.map shorten suff_ls
    in
    let mk_suffix ls = String.concat "_" ls in
    trim_prefix suffix_list |> trim_suffix |> List.map mk_suffix

  (* A utility function to build a decl from a production and an ast name suffix *)
  let mk_decl prod suffix =
    let name = Production.lhs prod |> n_name in
    let mk_terms prod =
      let rhs = Production.rhs prod in
      let mk_term (s, _, _) acc =
        match s with
        | N n -> Reference (n_name n) :: acc
        | T t when String.equal (t_name t) eof_token -> acc
        | T t -> LitReference (t_name t) :: acc
      in
      Array.fold_right mk_term rhs []
    in
    let ast_name = name ^ "_" ^ suffix in
    let terms = mk_terms prod in
    Decl { ast_name; name; terms }

  (* A utility function to create named bnfc nodes for a specific nonterminal's productions *)
  let mk_productions prod_list =
    let is_empty prod = Array.length @@ Production.rhs prod = 0 in
    match prod_list with
    | [] -> []
    | [ p ] -> [ mk_decl p single_rule_suffix ]
    | [ p1; p2 ] when is_empty p1 ->
        [ mk_decl p1 none_rule_suffix; mk_decl p2 some_rule_suffix ]
    | [ p1; p2 ] when is_empty p2 ->
        [ mk_decl p1 some_rule_suffix; mk_decl p2 none_rule_suffix ]
    | _ ->
        let short_suffixes = mk_short_suffixes prod_list in
        List.map2 mk_decl prod_list short_suffixes

  (* A utility function to check if a production is a unary op *)
  let is_unary expected_nterms prod =
    let rev_terms = Array.to_list @@ Production.rhs prod |> List.rev in
    match rev_terms with
    | (N n, _, _) :: tl ->
        List.exists (Nonterminal.equal n) expected_nterms
        && List.for_all (function T _, _, _ -> true | _ -> false) tl
    | _ -> false

  (* A utility function to create precedence related bnfc decl data *)
  let mk_precedence_productions prec_levels ast_name_map =
    (* Create a mapping between each nonterminal and the number of precedence levels it occurs in *)
    let nterm_level_count : int NonterminalMap.t =
      let loop acc level =
        let nterms =
          List.map Production.lhs level |> List.sort_uniq Nonterminal.compare
        in
        List.fold_left
          (fun acc nterm ->
            NonterminalMap.update nterm
              (function Some idx -> Some (idx + 1) | None -> Some 0)
              acc)
          acc nterms
      in
      List.fold_left loop NonterminalMap.empty prec_levels
    in
    (* Initialize the indexes for each nonterminal at 0 *)
    let indexes = NonterminalMap.map (fun _ -> 0) nterm_level_count in
    let is_last_idx nterm idx =
      Int.equal (NonterminalMap.find nterm nterm_level_count) idx
    in
    (* Build a single precedence level *)
    let mk_decls (acc, indexes) level =

      (* Update a nontemrinal reference:
          * Leave it as the nonterminal name if the current index is 0
          * Append the current index if succ is false
          * Append the current index + 1 if succ is true *)
      let mk_name ?(succ = false) nterm =
        let nterm_idx =
          let i = NonterminalMap.find nterm indexes in
          if succ then i + 1 else i
        in
        let base_name = n_name nterm in
        if nterm_idx = 0 then base_name else base_name ^ Int.to_string nterm_idx
      in
      let used_nterms =
        List.map Production.lhs level |> List.sort_uniq Nonterminal.compare
      in
      (* For each nonterminal used at the current level generate a fallthrough state
         to the next index if a next index exists. e.g. `_. Expr2 := Expr3`  *)
      let fallback_states =
        List.filter_map
          (fun n ->
            let current_idx = NonterminalMap.find n indexes in
            if is_last_idx n current_idx then None
            else
              Some
                (Decl
                   {
                     ast_name = "_";
                     name = mk_name n;
                     terms = [ Reference (mk_name ~succ:true n) ];
                   }))
          used_nterms
      in
      (* Build all the non-fallback productions in a precedence level *)
      let mk_prec_decls level =
        let mk_decl prod =
          let nterm = Production.lhs prod in
          let name = mk_name nterm in
          let ast_name = ProductionMap.find prod ast_name_map in
          let fst_is_rec =
            let rhs = Production.rhs prod in
            let is_rec (sym, _, _) =
              match sym with N n -> Nonterminal.equal n nterm | _ -> false
            in
            Array.length rhs > 0 && is_rec rhs.(0)
          in

          let binop_comps =
            match Array.map (fun (s, _, _) -> s) @@ Production.rhs prod with
            | [| N n1; T op; N n2 |]
              when List.exists (Nonterminal.equal n1) used_nterms
                   && List.exists (Nonterminal.equal n2) used_nterms ->
                Some (n1, op, n2)
            | _ -> None
          in

          let mk_simple_lit (sym, _, _) =
            match sym with
            | N n -> Reference (n_name n)
            | T t -> LitReference (t_name t)
          in

          (* If it's a binary op, use the inferred associativity rules to name the recursive calls in the following way:
              * Left associative: `Expr<N> := Expr<N> op Expr<N+1>`
              * Right associative: `Expr<N> := Expr<N+1> op Expr<N>`
              * Non associative: `Expr<N> := Expr<N+1> op Expr<N+1>` *)
          if Option.is_some binop_comps then
            let lhs, op, rhs = Option.get binop_comps in
            let l_succ, r_succ =
              match ProductionMap.find prod associativity_map with
              | Left -> (false, true)
              | Nonassoc -> (true, true)
              | Right -> (true, false)
            in
            let l_term = Reference (mk_name ~succ:l_succ lhs) in
            let op_term = LitReference (t_name op) in
            let r_term = Reference (mk_name ~succ:r_succ rhs) in
            let terms = [ l_term; op_term; r_term ] in
            Decl { ast_name; name; terms }

          (* If it's a unary op rename the nonterminal reference to recurse at
             the current level `Expr<N> := op Expr<N>` *)
          else if is_unary used_nterms prod then
            let mk_lit (sym, _, _) =
              match sym with
              | N n -> Reference (mk_name n)
              | T t -> LitReference (t_name t)
            in
            let terms =
              Array.map mk_lit (Production.rhs prod) |> Array.to_list
            in
            Decl { ast_name; name; terms }

          (* If a production starts with a self refenrece rename the recursion to be at the current level
             `Expr<N> := Expr<N> ...` *)
          else if fst_is_rec then
            let rhs = Production.rhs prod |> Array.to_list in
            let fst_term =
              match List.hd rhs with
              | N n, _, _ -> Reference (mk_name n)
              | _ -> assert false
            in
            let rem_terms = List.map mk_simple_lit (List.tl rhs) in
            let terms = fst_term :: rem_terms in
            Decl { ast_name; name; terms }

          (* In all other cases - no renaming to be done, build simple decl *)
          else
            let terms =
              Array.map mk_simple_lit (Production.rhs prod) |> Array.to_list
            in
            Decl { ast_name; name; terms }
        in
        List.map mk_decl level
      in
      let level_decls = mk_prec_decls level in
      (* Add the new decls, increment the used nonterminal indexes and move to the next level *)
      let acc = acc @ level_decls @ fallback_states in
      (* Increment all used indexes *)
      let indexes =
        List.fold_left
          (fun acc nterm ->
            NonterminalMap.update nterm
              (function Some i -> Some (i + 1) | None -> assert false)
              acc)
          indexes used_nterms
      in
      (acc, indexes)
    in
    List.fold_left mk_decls ([], indexes) prec_levels |> fst

  let decls : decl list =
    (* 3.1. Build precedence related productions *)
    (* First I build the ast names for each precedence production.
       This is done to minimize the change in ast names if a new precedence level is added *)
    let prec_prod_ast_names : string ProductionMap.t =
      NonterminalMap.fold
        (fun nterm prod_map acc ->
          let name = n_name nterm in
          let prods = List.map fst (ProductionMap.bindings prod_map) in
          let suffixes = mk_short_suffixes prods in
          let names = List.map (Printf.sprintf "%s_%s" name) suffixes in
          let ast_name_map = List.combine prods names in
          List.fold_left
            (fun acc (prod, name) -> ProductionMap.add prod name acc)
            acc ast_name_map)
        reduced_production_sets ProductionMap.empty
    in
    let prec_decls =
      let sort_by_name (Decl { name = n1 }) (Decl { name = n2 }) =
        String.compare n1 n2
      in
      mk_precedence_productions final_precedence_levels prec_prod_ast_names
      |> List.sort sort_by_name
    in

    (* 3.2. Build all other productions *)
    let decls : decl list =
      NonterminalMap.filter
        (fun nterm _ -> not @@ NonterminalMap.mem nterm reduced_production_sets)
        production_to_terminals
      |> NonterminalMap.map (fun m ->
             List.map fst (ProductionMap.bindings m) |> mk_productions)
      |> NonterminalMap.bindings |> List.map snd |> List.concat
    in
    decls @ prec_decls
end
