# `menhir2bnfc` tool

# **DISCLAIMER**: The ASL reference implementation can be found in `herdtools7/asllib`. This tool and any files generated by it are **NOT** a reference ASL implementation! Modifications of generated files will lead to an **UNSUPPORTED** divergence from the reference implementation and should **NOT** be done!

## Input data
To use this tool you need the following input files:
    * A Menhir `.cmly` file (see `menhir --help` on instructions on building a cmly file from mly file(s))

## Usage with AslRef

To build and run this script make sure you have `bnfc` (https://github.com/BNFC/bnfc) installed.

Then from the `herdtools7` root directory you can run the following:
```
make
dune build asllib/menhir2bnfc
```

To run the bnfc parser tests run:
```
dune build @bnfc_test
```
You should now have a `_build/default/asllib/menhir2bnfc/tests/integration/bnfc_parser/grammar.cf` file built.
If all you're looking for an aslref bnfc file - that's it.

The rest of the steps are how to build the bnfc file from scratch.

> Note: The following command succeds with errors related to type inference.
> Since we don't care about the backend this is not relevant.
```
menhir --cmly --base Parser asllib/Parser.mly asllib/Tokens.mly
```
At this point you should have a Parser.cmly and Lexer.ml file
To build the grammar run:
```
./_build/default/asllib/menhir2bnfc/menhir2bnfc.exe --with-lexer Parser.cmly grammar.cf
```

You should now have a bnfc compliant grammar.cf file!

## Tests

The `dune build @bnfc_test` builds a menhir parser from the bnfc grammar
and runs it against all files under `asllib/tests/**/*.asl`

Failing tests are recorded in `asllib/menhir2bnfc/tests/integration/parser_cmp.expected`

Currently the following tests are recorded:
```
FAIL - aslref false | bnfc true: asllib/tests/regressions.t/lhs-tuple-fields-same-field.asl
```

Aslref produces the following error:

>  File lhs-tuple-fields-same-field.asl, line 8, characters 2 to 4:
>  ASL Typing error: multiple writes to "bv.fld".

The following statement parses correctly, but is rejected by a check while removing the syntactic sugar in the aslref parser:
`bv.(fld, -, fld) = ('11', TRUE, '11');`. This is parser valid, but fails in post-processing.

```
FAIL - aslref false | bnfc true: asllib/tests/regressions.t/lhs-tuple-same-var.asl
```

Aslref produces the following error:

>  File lhs-tuple-same-var.asl, line 8, characters 2 to 20:
>  ASL Typing error: multiple writes to "bv".

The following statement parses correctly, but is rejected by a check while removing the syntactic sugar in the aslref parser:
`(bv[7], -, bv.fld) = ('1', TRUE, '11');`. This is parser valid, but fails in post-processing.

```
FAIL - aslref false | bnfc true: asllib/tests/regressions.t/same-precedence.asl
FAIL - aslref false | bnfc true: asllib/tests/regressions.t/same-precedence2.asl
```

Aslref produces the following errors:

>  File same-precedence.asl, line 6, characters 10 to 15:
>  ASL Error: Cannot parse.

>  File same-precedence2.asl, line 6, characters 10 to 17:
>  ASL Error: Cannot parse.

This parse error is coming from a check inside the aslref parser, where equal precedence operators
are required to be wrapped in parenthesis to disambiguate operation order.

## Building and running the script

To build you simply run `dune build`.

The script can be run using:
```
menhir2bnfc <cmly file> <output file>
```

For example:
```
menhir2bnfc Parser.cmly out.cf
```

See `menhir2bnfc --help` for more details.

## Transforming the Grammar to BNFC

### Terms used

 * `terminal` - a reference to a lexer token
 * `nonterminal` - a reference to the name of a set of `productions`
 * `production` - a recipe describing one of the ways a `nonterminal` is built (reduced) from a set of terminal and nonterminal symbols
 * `LR(1) state machine` - A graph where each node has a set of `shift` rules which map the next `terminal` or `nonterminal` to the next node in the
   state machine and `reduce` rules which map the next `terminal` or `nonterminal` to the `production` it results in. The state machine chooses whether
   to shift or reduce based on the next token given by the lexer until the parse succeeds (a reduction marking the complete parse happens) or fails
   (no valid next step exists)

### Algorithm outline

 1. Collect entry points directly from the `cmly` data.
    * These produce an `entrypoints` bnfc entry.

 2. Infer operator precedence from the lr(1) state machine.

    1. Create an associative list linking each production to the set of terminals which cause the parser to reduce to that production.
    2. Determine the nonterminals with ambiguous precedence
        * This is done by grouping productions by their nonterminal identifiers. Nonterminals with ambiguous precedence have varying sets of
          tokens following different productions
    3. (TODO) Verify that the nonterminals are actually related (are part of the same component on the parse graph)
        * The next steps likely want to be done for each component
    4. Determine if any of the detected nonterminals can be removed and remove them
        * In cases where a nonterminal has a "final" production (all but one production end with a recursive reference) we can infer that the set of
          terminals which follow that final case must follow all other cases. Similarly, any other rule which terminates by that nonterminal is followed
          by the same set. This feels like an inefficiency in the LR(1) state machine menhir generates?
        * For example consider the following productions:
            * `e_else := ELSE expr` with set of tokens which reduce it {T1, T2, T3}
            * `e_else := ELSEIF e_expr` with set of tokens which reduce it {T1, T2, T3, T4, T5}
            * `expr := IF expr THEN expr e_else` with set of tokens which reduce it {T1, T2, T3, T4, T5}
            * In this case - we can infer that `e_else := ELSE expr` must always reduce first before the other two productions can.
              This is because the other two recurse back into `e_else` and the `ELSE` case is effectively the last production before a final
              `expr` can be reduced. We can therefore infer that the other two productions must also only reduce if the following tokens are {T1, T2, T3}
              since those are the only ones which reduce the `ELSE` case and all other productions can be reduced all the way to `expr` since `e_else` has terminated.\ff
    5. Determine the associativity of each of the operands in the ambiguous productions
        * We determine associativity based on what the LR1 state at `expr op expr .` is.
           * If `op` is a shift rule - right associativity
           * if `op` is a reduce rule - left associativity
           * if `op` is neither shifted nor reduced - non-associative
    6. Generate a precedence lists by sorting the productions by the length of terminals following them - shortest meaning lowest precedence
        * In order to compare the different nonterminals in the same component for each nonterminal's productions we subtract the shortest set from
          all productions. This is done to remove terminals which come from outside the component.
    7. Split off unary ops as their own precedence group (if necessary)
        * Since unary ops don't usually produce other unary ops (`!Expr !Expr` is not usually valid syntax) any production which starts
          with leading terminals and ends with a recursive reference will appear a level above its precedence level unless the unary op is
          the highest precedence
    8. Correct any binary expr productions which are in the wrong level
        * Cases such as `Expr Op <terminal>` appear to mismatch the set of tokens which follow `Expr Op Expr` for the same `Op`.
          Such cases are grouped with ther corresponding `Op` to avoid conflicts

 3. Generate bnfc-style lines from the grammar productions
    1. For the precedence order productions - update their terms such that
	    * Unary ops recurse to their own precedence level
	    * (assumption) Binary ops are left associative.
    2. All remaining productions are trivially mapped onto bnfc equivallents

### Limitations

The algorithm implemented has some limitations worth noting:
    1. It assumes that ambiguous precedence expressions follow a `expr op expr`/`<terminals> expr`/`expr <non op> ...` structure
       If somebody was to create an in-between production `expr opexpr` where `opexpr := op expr` the algorithm may not be sufficient to detect this.

Possible future work/ideas for each of these
    1. Identifying which operands actually control precedence and associativity would be a more scalable approach than working on productions only
        * Actually calculating where shift/reduce conflicts would happen if the productions generated a parser without precedence rules might give us this
