\chapter{Pattern Matching\label{chap:PatternMatching}}

The construct \texttt{$e$ IN $p$} tests whether the value calculated by the expression $e$,
which is referred to as the \emph{discriminant},
matches a value specified by the \emph{pattern} $p$.

\ExampleDef{Patterns}
\listingref{Patterns} shows examples of some patterns.
\ASLListing{Examples of patterns}{Patterns}{\definitiontests/Patterns.asl}

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Patterns} defines the formal relations for patterns;
  \item \secref{MatchingAllValues} defines the match-all-values pattern;
  \item \secref{MatchingASingleValue} defines the match-a-single-value pattern;
  \item \secref{MatchingARangeOfIntegers} defines the match-a-range-of-integers pattern;
  \item \secref{MatchingAnUpperBoundedRangeOfIntegers} defines the match-integers-less-than pattern;
  \item \secref{MatchingALowerBoundedRangeOfIntegers} defines the match-integers-greater-than pattern;
  \item \secref{MatchingABitmask} defines the bitmask pattern;
  \item \secref{MatchingATupleOfPatterns} defines the match-a-tuple pattern;
  \item \secref{MatchingAnyPatternInASetOfPatterns} defines the match-any pattern;
  \item \secref{MatchingANegatedPattern} defines the negation pattern;
  \item \secref{ASTRulesForPatternExpressions} defines the expressions that may appear inside patterns.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Patterns}
\paragraph{Syntax:} Patterns are grammatically derived from $\Npattern$.

\paragraph{Abstract Syntax:} Patterns are derived in the abstract grammar from $\pattern$
  and generated from $\buildpattern$.
  \hypertarget{build-pattern}{}
  The function
\[
  \buildpattern(\overname{\parsenode{\Npattern}}{\vparsednode}) \;\aslto\;
  \overname{\pattern}{\vastnode}
\]
transforms a pattern parse node $\vparsednode$ into a pattern AST node $\vastnode$.

\paragraph{Typing:} Patterns are annotated by $\annotatepattern$.
\RenderRelation{annotate_pattern}
\BackupOriginalRelation{
The function
\[
  \annotatepattern(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\vt} \aslsep
    \overname{\pattern}{\vp}) \aslto
    (\overname{\pattern}{\newp} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\typeerror}{\TypeErrorConfig}
\]
annotates a pattern $\vp$ in a \staticenvironmentterm{} $\tenv$ given a type $\vt$,
resulting in $\newp$, which is the typed AST node for $\vp$
and the inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError.
} % END_OF_BACKUP_RELATION
\paragraph{Semantics:} Patterns are evaluated by $\evalpattern$.
\RenderRelation{eval_pattern}
\BackupOriginalRelation{
The relation
\[
  \evalpattern(\overname{\envs}{\env} \aslsep \overname{\nativevalue}{\vv} \aslsep \overname{\pattern}{\vp}) \;\aslrel\;
  \left(
  \begin{array}{ll}
  \ResultPattern(\overname{\tbool}{\vb}, \overname{\XGraphs}{\newg}) & \cup\\
  \overname{\TDynError}{\DynErrorConfig} & \cup\\
  \overname{\TDiverging}{\DivergingConfig} &
  \end{array}
  \right)
\]
determines whether a value $\vv$ matches the pattern $\vp$ in an environment $\env$
resulting in either $\ResultPattern(\vb, \newg)$ or an abnormal configuration.
} % END_OF_BACKUP_RELATION


\section{Matching All Values\label{sec:MatchingAllValues}}
\ASLListing{Matching any value}{semantics-pall}{\semanticstests/SemanticsRule.PAll.asl}

\subsection{Syntax}
\begin{flalign*}
\Npattern \derives\ & \Tminus &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{pattern_all}
\BackupOriginalAST{
\begin{flalign*}
\pattern \derives\ & \PatternAll &
\end{flalign*}
}

\ASTRuleDef{PAll}
\begin{mathpar}
\inferrule{}{
  \buildpattern(\Npattern(\Tminus)) \astarrow
  \overname{\PatternAll}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{PAll}
The pattern \verb|-| in \listingref{semantics-pall} is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ is the pattern matching everything, that is, $\PatternAll$;
  \item \Proseeqdef{$\newp$}{$\vp$};
  \item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatepattern(\tenv, \vt, \overname{\PatternAll}{\vp}) \typearrow (\overname{\PatternAll}{\newp}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\PAllBegin}{\PAllEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{PAll}
\ExampleDef{Evaluation of a Match-all Pattern}
In \listingref{semantics-pall}, \texttt{match\_me} evaluates to \True,
since \texttt{-} matches any value and \texttt{42} in particular.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ is the pattern which matches everything, $\PatternAll$, and therefore
    matches $\vv$;
  \item $\vb$ is the native Boolean value \True;
  \item $\newg$ is the empty graph.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \evalpattern(\env, \Ignore, \PatternAll) \evalarrow \ResultPattern(\nvbool(\True), \emptygraph)
}
\end{mathpar}
\CodeSubsection{\EvalPAllBegin}{\EvalPAllEnd}{../Interpreter.ml}

\section{Matching a Single Value\label{sec:MatchingASingleValue}}
\subsection{Syntax}
\begin{flalign*}
\Npattern \derives\ & \Nexprpattern &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{pattern_single}
\BackupOriginalAST{
\begin{flalign*}
\pattern \derives\ & \PatternSingle(\expr) &
\end{flalign*}
}

\ASTRuleDef{PSingle}
\begin{mathpar}
\inferrule{}{
  \buildpattern(\Npattern(\punnode{\Nexprpattern})) \astarrow
  \overname{\PatternSingle(\astof{\vexprpattern})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{PSingle}
\ExampleDef{Typing Single-expression Patterns}
\listingref{typing-psingle} shows examples of well-typed single-expression patterns.
\ASLListing{Typing single-expression patterns}{typing-psingle}{\typingtests/TypingRule.PSingle.asl}

\listingref{typing-psingle-bad} shows an ill-typed single-expression pattern.
\ASLListing{Ill-typed single-expression pattern}{typing-psingle-bad}{\typingtests/TypingRule.PSingle.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ is the pattern that matches the expression $\ve$, that is, $\PatternSingle(\ve)$;
  \item annotating the expression $\ve$ in $\tenv$ yields $(\vte, \vep, \vses)$\ProseOrTypeError;
  \item \Prosechecksymbolicallyevaluable{$\vses$};
  \item obtaining the \underlyingtypeterm\ of $\vt$ yields $\vtstruct$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vte$ yields $\testruct$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{t\_bool, t\_real, t\_int, t\_string}
    \begin{itemize}
      \item the AST label of $\vtstruct$ is one of $\TBool$, $\TReal$, $\TInt$, or $\TString$;
      \item checking that the labels of $\vtstruct$ and $\testruct$ are equal yields $\True$\ProseOrTypeError;
    \end{itemize}

    \item \AllApplyCase{t\_bits}
    \begin{itemize}
      \item the AST label of $\vtstruct$ is $\TBits$;
      \item checking that the labels of $\vtstruct$ and $\testruct$ are equal yields $\True$\ProseOrTypeError;
      \item determining whether the bitwidths of $\vtstruct$ and $\testruct$ are equal yields $\True$\ProseOrTypeError;
    \end{itemize}

    \item \AllApplyCase{t\_enum}
    \begin{itemize}
      \item the AST label of $\vtstruct$ is $\TEnum$;
      \item checking that the labels of $\vtstruct$ and $\testruct$ are equal yields $\True$\ProseOrTypeError;
      \item determining whether the lists of enumeration literals of $\vtstruct$ and $\testruct$ are equal yields $\True$\ProseOrTypeError;
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item determining whether the labels of $\vtstruct$ and $\testruct$ are the same yields $\True$\ProseOrTypeError;
      \item the label of $\vtstruct$ is not one of $\TBool$, $\TReal$, $\TInt$, $\TBits$, or $\TEnum$;
      \item the result is a \typingerrorterm{} indicating that the types $\vt$ and $\vte$ are inappropriate for this pattern.
    \end{itemize}
  \end{itemize}
  \item $\newp$ is the pattern that matches the expression $\vep$, that is, $\PatternSingle(\vep)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[t\_bool, t\_real, t\_int, t\_string]{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  \commonprefixline\\\\
  \astlabel(\vtstruct) \in \{\TBool, \TReal, \TInt, \TString\}\\
  \checktrans{\astlabel(\vtstruct) = \astlabel(\testruct)}{\BadOperands} \checktransarrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternSingle(\ve)}{\vp}) \typearrow (\overname{\PatternSingle(\vep)}{\newp}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vte) \typearrow \vtestruct \OrTypeError\\\\
  \commonprefixline\\\\
  \astlabel(\vtstruct) = \TBits\\
  \checktrans{\astlabel(\vtstruct) = \astlabel(\testruct)}{\BadOperands} \checktransarrow \True \OrTypeError\\
  \bitwidthequal(\tenv, \vtstruct, \testruct) \typearrow \vb\\
  \checktrans{\vb}{BitvectorsDifferentWidths} \checktransarrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternSingle(\ve)}{\vp}) \typearrow (\overname{\PatternSingle(\vep)}{\newp}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vte) \typearrow \vtestruct \OrTypeError\\\\
  \commonprefixline\\\\
  \astlabel(\vtstruct) = \TEnum\\
  \checktrans{\astlabel(\vtstruct) = \astlabel(\testruct)}{\BadOperands} \checktransarrow \True \OrTypeError\\
  \vtstruct \eqname \TEnum(\vlione)\\
  \vtestruct \eqname \TEnum(\vlitwo)\\
  \checktrans{\vlione = \vlitwo}{EnumDifferentLabels} \checktransarrow \True \OrTypeError\\
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternSingle(\ve)}{\vp}) \typearrow (\overname{\PatternSingle(\vep)}{\newp}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  \commonprefixline\\\\
  \checktrans{\astlabel(\vtstruct) = \astlabel(\testruct)}{\BadOperands} \checktransarrow \True \OrTypeError\\
  \astlabel(\vtstruct) \not\in \{\TBool, \TReal, \TInt, \TBits, \TEnum\}
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternSingle(\ve)}{\vp}) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\PSingleBegin}{\PSingleEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{PSingle}
\ExampleDef{Evaluation of a Single-expression Pattern}
In \listingref{semantics-psingle},
\texttt{match\_true} evaluates to \True, since \texttt{42} matches \verb|{42}|,
whereas \\
\texttt{match\_false} evaluates to \False, since \texttt{42} does no match \verb|{3}|.
\ASLListing{Matching against a single value}{semantics-psingle}{\semanticstests/SemanticsRule.PSingle.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ is the condition corresponding to being equal to the
    side-effect-free expression $\ve$, $\PatternSingle(\ve)$;
  \item the side-effect-free evaluation of $\ve$ in
    environment $\env$ is \\ $\ResultExprSEF(\vvone, \newg)$\ProseOrDynErrorDiverging;
  \item $\vb$ is the Boolean value corresponding to whether $\vv$
    is equal to $\vvone$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexprsef(\env, \ve) \evalarrow \ResultExprSEF(\vvone, \newg) \OrDynErrorDiverging\\\\
  \evalbinop(\EQ, \vv, \vvone) \evalarrow \vb
}{
  \evalpattern(\env, \vv, \overname{\PatternSingle(\ve)}{\vp}) \evalarrow \ResultPattern(\vb, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalPSingleBegin}{\EvalPSingleEnd}{../Interpreter.ml}

\section{Matching a Range of Integers\label{sec:MatchingARangeOfIntegers}}
\subsection{Syntax}
\begin{flalign*}
\Npattern \derives\ & \Nexprpattern \parsesep \Tslicing \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{pattern_range}
\BackupOriginalAST{
\begin{flalign*}
\pattern \derives\ & \PatternRange(\overtext{\expr}{lower}, \overtext{\expr}{upper}) &
\end{flalign*}
}

\ASTRuleDef{PRange}
\begin{mathpar}
\inferrule{}{
  {
    \begin{array}{r}
  \buildpattern(\Npattern(\punnode{\Nexprpattern}, \Tslicing, \punnode{\Nexpr})) \astarrow\\
  \overname{\PatternRange(\astof{\vexprpattern}, \astof{\vexpr})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{PRange}
\ExampleDef{Typing Range Patterns}
\listingref{typing-prange} shows examples of well-typed range patterns.
\ASLListing{Well-typed range patterns}{typing-prange}{\typingtests/TypingRule.PRange.asl}

\listingref{typing-prange-bad} shows ill-typed range patterns.
\ASLListing{Ill-typed range patterns}{typing-prange-bad}{\typingtests/TypingRule.PRange.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ is the pattern which matches anything within the range given by
  expressions $\veone$ and $\vetwo$, that is, $\PatternRange(\veone, \vetwo)$;
  \item \Proseannotatesymbolicallyevaluableexpr{$\tenv$}{$\veone$}{$(\vteone, \veonep, \vsesone)$}\ProseOrTypeError;
  \item \Proseannotatesymbolicallyevaluableexpr{$\tenv$}{$\vetwo$}{$(\vtetwo, \vetwop, \vsestwo)$}\ProseOrTypeError;
  \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$;
  \item determining whether both $\veonep$ and $\vetwop$ are compile-time constant expressions yields $\True$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ for $\vt$, $\vteone$, and $\vtetwo$ yields
        $\vtstruct$, $\vteonestruct$, and $\vtetwostruct$, respectively\ProseOrTypeError;
  \item a check the AST labels of $\vtstruct$, $\vteonestruct$, and $\vtetwostruct$ are all the same and are either
        $\TInt$ or $\TReal$ yields $\True$. Otherwise, the result is a \typingerrorterm{}, which short-circuits the entire rule.
        The \typingerrorterm{} indicates that the types of
        $\veone$, $\vetwo$ and the type $\vt$ must be either of integer type or of \realtypeterm{}.
  \item $\newp$ is a range pattern with bounds $\veonep$ and $\vetwop$, that is, $\PatternRange(\veonep, \vetwop)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatesymbolicallyevaluableexpr(\tenv, \veone) \typearrow (\vteone, \veonep, \vsesone) \OrTypeError\\\\
  \annotatesymbolicallyevaluableexpr(\tenv, \vetwo) \typearrow (\vtetwo, \vetwop, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo\\
  \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vteonestruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vtetwo) \typearrow \vtetwostruct \OrTypeError\\\\
  {
    \begin{array}{rl}
      \vb \eqdef& \astlabel(\vtstruct) = \astlabel(\vteonestruct) = \astlabel(\vtetwostruct)\ \land\\
                & \astlabel(\vtstruct) \in \{\TInt, \TReal\}
    \end{array}
  }\\
  \checktrans{\vb}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternRange(\veone, \vetwo)}{\vp}) \typearrow (\overname{\PatternRange(\veonep, \vetwop)}{\newp}, \vses)
}
\end{mathpar}
\CodeSubsection{\PRangeBegin}{\PRangeEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{PRange}
\ExampleDef{Evaluation of a Range Pattern}
In \listingref{semantics-prange},
\texttt{match\_true} evaluates to \True, since \texttt{42} is in the range given by
\texttt{3..42},
whereas \texttt{match\_false} evaluates to \False, since \texttt{1} is outside the
range given by \texttt{3..42}.
\ASLListing{Matching against a range of values}{semantics-prange}{\semanticstests/SemanticsRule.PRange.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ is the condition corresponding to being greater than or equal
    to $\veone$, and lesser or equal to $\vetwo$, that is, $\PatternRange(\veone, \vetwo)$;
  \item $\veone$ and $\vetwo$ are side-effect-free expressions;
  \item the side-effect-free evaluation of $\veone$ in $\env$ is $\ResultExprSEF(\vvone, \vgone)$\ProseOrDynErrorDiverging;
  \item the side-effect-free evaluation of $\vetwo$ in $\env$ is $\ResultExprSEF(\vvtwo, \vgtwo)$\ProseOrDynErrorDiverging;
  \item $\vbone$ is the Boolean value corresponding to whether
    $\vv$ is greater than or equal to $\vvone$;
    \item $\vbtwo$ is the Boolean value corresponding to whether
    $\vv$ is less than or equal to $\vvtwo$;
  \item $\vb$ is the Boolean conjunction of $\vbone$ and
  $\vbtwo$;
  \item $\newg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexprsef(\env, \veone) \evalarrow \ResultExprSEF(\vvone, \vgone) \OrDynErrorDiverging\\\\
  \evalbinop(\GE, \vv, \vvone) \evalarrow \vbone\\
  \evalexprsef(\env, \veone) \evalarrow \ResultExprSEF(\vvtwo, \vgtwo) \OrDynErrorDiverging\\\\
  \evalbinop(\LE, \vv, \vvtwo) \evalarrow \vbtwo\\
  \evalbinop(\BAND, \vbone, \vbtwo) \evalarrow \vb\\
  \newg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalpattern(\env, \vv, \PatternRange(\veone, \vetwo)) \evalarrow \ResultPattern(\vb, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalPRangeBegin}{\EvalPRangeEnd}{../Interpreter.ml}

\section{Matching an Upper Bounded Range of Integers\label{sec:MatchingAnUpperBoundedRangeOfIntegers}}
\subsection{Syntax}
\begin{flalign*}
\Npattern \derives\ & \Tleq \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{pattern_leq}
\BackupOriginalAST{
\begin{flalign*}
\pattern \derives\ & \PatternLeq(\expr) &
\end{flalign*}
}

\ASTRuleDef{PLeq}
\begin{mathpar}
\inferrule{}{
  \buildpattern(\Npattern(\Tleq, \punnode{\Nexpr})) \astarrow
  \overname{\PatternLeq(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{PLeq}
\ExampleDef{Typing Less-or-equal Patterns}
\listingref{typing-pleq} shows examples of well-typed less-or-equal patterns.
\ASLListing{Well-typed less-or-equal patterns}{typing-pleq}{\typingtests/TypingRule.PLeq.asl}

\listingref{typing-pleq-bad} shows examples of ill-typed less-or-equal patterns.
\ASLListing{Ill-typed less-or-equal patterns}{typing-pleq-bad}{\typingtests/TypingRule.PLeq.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vp$ is the pattern which matches anything less than or equal to an expression $\ve$,
that is, $\PatternLeq(\ve)$;
\item annotating the expression $\ve$ in $\tenv$ yields $(\vte, \vep, \vses)$\ProseOrTypeError;
\item \Prosechecksymbolicallyevaluable{$\vses$};
\item obtaining the \underlyingtypeterm\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
\item obtaining the \underlyingtypeterm\ of $\vte$ in $\tenv$ yields $\testruct$\ProseOrTypeError;
\item $\vb$ is true if and only if $\vtstruct$ and $\testruct$ are both integer types or both the \realtypeterm{};
\item if $\vb$ is $\False$ a \typingerrorterm{} (\BadOperands) is returned (indicating that the types of $\vt$ and $\vte$
      are inappropriate for the $\LE$ operator),
      which short-circuits the entire rule;
\item $\newp$ is the pattern which matches anything less than or equal to $\vep$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  {
    \begin{array}{rl}
      \vb \eqdef& \astlabel(\vtstruct) = \astlabel(\testruct)\ \land\\
                & \astlabel(\vtstruct) \in \{\TInt, \TReal\}
    \end{array}
  }\\
  \checktrans{\vb}{\BadOperands} \checktransarrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternLeq(\ve)}{\vp}) \typearrow (\overname{\PatternLeq(\vep)}{\newp}, \vses)
}
\end{mathpar}
\CodeSubsection{\PLeqBegin}{\PLeqEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{PLeq}
\ExampleDef{Evaluation of a Less-or-equal Pattern}
In \listingref{semantics-pleq},
\texttt{match\_true} evaluates to \True, since \texttt{3} is less than or equal to \texttt{42},
whereas \texttt{match\_false} evaluates to \False, since \texttt{42} is not less than or equal to \texttt{3}.
\ASLListing{Matching against an upper bound value}{semantics-pleq}{\semanticstests/SemanticsRule.PLeq.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vp$ is the condition corresponding to being less than or equal
      to the side-effect-free expression $\ve$, $\PatternLeq(\ve)$;
\item the side-effect-free evaluation of $\ve$ is
      $\ResultExprSEF(\vvone, \newg)$\ProseOrDynErrorDiverging;
\item $\vb$ is the Boolean value corresponding to whether $\vv$
      is less than or equal to $\vvone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexprsef(\env, \ve) \evalarrow \ResultExprSEF(\vvone, \newg) \OrDynErrorDiverging\\\\
  \evalbinop(\LE, \vv, \vvone) \evalarrow \vb
}{
  \evalpattern(\env, \vv, \PatternLeq(\ve)) \evalarrow \ResultPattern(\vb, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalPLeqBegin}{\EvalPLeqEnd}{../Interpreter.ml}

\section{Matching a Lower Bounded Range of Integers\label{sec:MatchingALowerBoundedRangeOfIntegers}}
\subsection{Syntax}
\begin{flalign*}
\Npattern \derives\ & \Tgeq \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{pattern_geq}
\BackupOriginalAST{
\begin{flalign*}
\pattern \derives\ & \PatternGeq(\expr) &
\end{flalign*}
}

\ASTRuleDef{PGeq}
\begin{mathpar}
\inferrule{}{
  \buildpattern(\Npattern(\Tgeq, \punnode{\Nexpr})) \astarrow
  \overname{\PatternGeq(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{PGeq}
\ExampleDef{Typing Greater-or-equal Patterns}
\listingref{typing-pgeq} shows examples of well-typed greater-or-equal patterns.
\ASLListing{Well-typed greater-or-equal patterns}{typing-pgeq}{\typingtests/TypingRule.PGeq.asl}

\listingref{typing-pgeq-bad} shows examples of ill-typed greater-or-equal patterns.
\ASLListing{Ill-typed greater-or-equal patterns}{typing-pgeq-bad}{\typingtests/TypingRule.PGeq.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vp$ is the pattern which matches anything greater than or equal to an expression $\ve$,
      that is, $\PatternGeq(\ve)$;
\item annotating the expression $\ve$ in $\tenv$ yields $(\vte, \vep, \vses)$\ProseOrTypeError;
\item \Prosechecksymbolicallyevaluable{$\vses$};
\item obtaining the \underlyingtypeterm\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
\item obtaining the \underlyingtypeterm\ of $\vte$ in $\tenv$ yields $\testruct$\ProseOrTypeError;
\item $\vb$ is true if and only if $\vtstruct$ and $\testruct$ are both integer types or both the \realtypeterm{};
\item if $\vb$ is $\False$ a \typingerrorterm{} is returned (indicating that the types of $\vt$ and $\vte$
      are inappropriate for the $\GE$ operator),
      which short-circuits the entire rule;
\item $\newp$ is the pattern which matches anything greater than or equal to $\vep$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  {
    \begin{array}{rl}
      \vb \eqdef& \astlabel(\vtstruct) = \astlabel(\testruct)\ \land\\
                & \astlabel(\vtstruct) \in \{\TInt, \TReal\}
    \end{array}
  }\\
  \checktrans{\vb}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternGeq(\ve)}{\vp}) \typearrow (\overname{\PatternGeq(\vep)}{\newp}, \vses)
}
\end{mathpar}
\CodeSubsection{\PGeqBegin}{\PGeqEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{PGeq}
\ExampleDef{Evaluation of a Greater-or-equal Pattern}
In \listingref{semantics-pgeq},
\texttt{match\_true} evaluates to \True, since \texttt{42} is greater or equal to \texttt{3},
whereas \texttt{match\_false} evaluates to \False, since \texttt{3} is not greater or equal to \texttt{42}.
\ASLListing{Matching against a lower bound}{semantics-pgeq}{\semanticstests/SemanticsRule.PGeq.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vp$ is the condition corresponding to being greater than or equal
      than the side-effect-free expression $\ve$, $\PatternGeq(\ve)$;
\item the side-effect-free evaluation of $\ve$ is either
      $\ResultExprSEF(\vvone, \newg)$\ProseOrDynErrorDiverging;
\item $\vb$ is the Boolean value corresponding to whether $\vv$
      is greater than or equal to $\vvone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexprsef(\env, \ve) \evalarrow \ResultExprSEF(\vvone, \newg) \OrDynErrorDiverging\\\\
  \evalbinop(\GE, \vv, \vvone) \evalarrow \vb
}{
  \evalpattern(\env, \vv, \PatternGeq(\ve)) \evalarrow \ResultPattern(\vb, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalPGeqBegin}{\EvalPGeqEnd}{../Interpreter.ml}

\section{Matching a Bitmask\label{sec:MatchingABitmask}}
\subsection{Syntax}
\begin{flalign*}
\Npattern \derives\ & \Tmasklit &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{pattern_mask}
\BackupOriginalAST{
\begin{flalign*}
\pattern \derives\ & \PatternMask(\overtext{\KleeneStar{\{\texttt{0},\texttt{1},\texttt{x}\}}}{mask constant}) &
\end{flalign*}
}

\ASTRuleDef{PMask}
\begin{mathpar}
\inferrule{}{
  \buildpattern(\Npattern(\Tmasklit(\vm))) \astarrow
  \overname{\PatternMask(\vm)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{PMask}
\ExampleDef{Typing Mask Patterns}
\listingref{typing-pmask} shows examples of well-typed mask patterns.
\ASLListing{Well-typed mask patterns}{typing-pmask}{\typingtests/TypingRule.PMask.asl}

\listingref{typing-pmask-bad} shows examples of ill-typed mask patterns.
\ASLListing{An Ill-typed mask pattern}{typing-pmask-bad}{\typingtests/TypingRule.PMask.bad.asl}

\ProseParagraph
\AllApply
  \begin{itemize}
  \item $\vp$ is the pattern which matches a mask $\vm$, that is, $\PatternMask(\vm)$;
  \item determining whether $\vt$ has the structure of a bitvector type yields $\True$\ProseOrTypeError;
  \item $\vn$ is the length of mask $\vm$;
  \item determining whether $\vt$ \typesatisfiesterm\ the bitvector type of length $\vn$ \\
        (that is, $\TBits(\vn, \emptylist)$), yields $\True$\ProseOrTypeError;
  \item $\newp$ is $\vp$;
  \item define $\vses$ as the empty set.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checkstructurelabel(\tenv, \vt, \TBits) \typearrow \True \OrTypeError\\\\
  \vn \eqdef \listlen{\vm}\\
  \checktypesat(\tenv, \vt, \TBits(\vn, \emptylist)) \typearrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternMask(\vm)}{\vp}) \typearrow (\overname{\PatternMask(\vm)}{\newp}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\PMaskBegin}{\PMaskEnd}{../Typing.ml}
\identi{VMKF}

\subsection{Semantics}
\SemanticsRuleDef{PMask}
\ExampleDef{Evaluation of a Mask Pattern}
In \listingref{semantics-pmask}, \texttt{match\_true} evaluates to \True, since
\texttt{101010} matches the bitmask \texttt{xx1010},
whereas \texttt{match\_false} evaluates to \False, since
\texttt{101010} does not match the bitmask \texttt{0x1010}
\ASLListing{Matching against a bitmask}{semantics-pmask}{\semanticstests/SemanticsRule.PMask.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vp$ is an empty mask pattern, $\PatternMask(\emptylist)$ (with spaces removed);
    \item $\vv$ is an empty native bitvector ($\nvbitvector(\emptylist)$);
    \item \Proseeqdef{$\vb$}{$\True$};
    \item $\newg$ is the empty graph.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vp$ is a mask pattern, $\PatternMask(\vm)$,
    of length $n$ (with spaces removed);
    \item $\vv$ is a native bitvector of bits $\vu_{1..n}$;
    \item $\vb$ is the native Boolean formed from the conjunction of Boolean values for each $i$,
    where the bit $\vu_i$ is checked for matching the mask character $\vm_i$;
    \item $\newg$ is the empty graph.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\hypertarget{def-maskmatch}{}
The function $\maskmatch : \{0, 1, \vx\} \times \{0,1\} \rightarrow \Bool$,
checks whether a bit value (second operand) matches a mask value (first operand),
is defined by the following table:
\[
\begin{array}{|c|c|c|c|}
  \hline
  \textbf{$\maskmatch$} & 0 & 1 & \vx\\
  \hline
  0 & \True & \False & \True\\
  \hline
  1 & \False & \True & \True\\
  \hline
\end{array}
\]

\begin{mathpar}
\inferrule[empty]{}{
  \evalpattern(\env, \overname{\nvbitvector(\emptylist)}{\vv}, \PatternMask(\emptylist)) \evalarrow \ResultPattern(\True, \emptygraph)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vm = \vm_{1..n}\\
  \vv = \nvbitvector(\vu_{1..n})\\
  \vb \eqdef \nvbool(\bigwedge_{i=1..n} \maskmatch(\vm_i, \vu_i))
}{
  \evalpattern(\env, \vv, \PatternMask(\vm)) \evalarrow \ResultPattern(\vb, \emptygraph)
}
\end{mathpar}
\CodeSubsection{\EvalPMaskBegin}{\EvalPMaskEnd}{../Interpreter.ml}

\section{Matching a Tuple of Patterns\label{sec:MatchingATupleOfPatterns}}
\subsection{Syntax}
\begin{flalign*}
\Npattern \derives\ & \Plisttwo{\Npattern} &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{pattern_tuple}
\BackupOriginalAST{
\begin{flalign*}
\pattern \derives\ & \PatternTuple(\pattern^{*}) &
\end{flalign*}
}

\ASTRuleDef{PTuple}
\begin{mathpar}
\inferrule{
  \buildplist[\buildpattern](\vpatterns) \astarrow \vpatternasts
}{
  \buildpattern(\Npattern(\namednode{\vpatterns}{\Plisttwo{\Npattern}})) \astarrow
  \overname{\PatternTuple(\vpatternasts)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{PTuple}
\ExampleDef{Typing Tuple Patterns}
The tuple patterns in \listingref{semantics-ptuple} are well-typed.

The tuple patterns in \listingref{typing-ptuple-bad} are ill-typed.
\ASLListing{Ill-typed tuple patterns}{typing-ptuple-bad}{\typingtests/TypingRule.PTuple.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ is the pattern which matches a tuple $\vli$, that is, $\PatternTuple(\vli)$;
  \item obtaining the \structureterm\ of $\vt$ yields $\vtstruct$\ProseOrTypeError;
  \item determining whether $\vtstruct$ is a \tupletypeterm{} yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item $\vtstruct$ is a \tupletypeterm{} with list of tuple $\vts$;
  \item determining whether $\vts$ is a list of the same size as $\vli$ yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item annotating each pattern in $\vli$ with the corresponding type in $\vts$ for each \Proselistrange{$i$}{$\vli$},
        yields $(\vlip[i], \vxs_i)$\ProseOrTypeError;
  \item $\newli$ is the list of annotated patterns $\vlip[\vi]$ at the same positions those of $\vli$;
  \item $\newp$ is the pattern which matches the tuple $\newli$, that is, $\PatternTuple(\newli)$;
  \item define $\vses$ as the union of all $\vxs_i$, for each \Proselistrange{$i$}{$\vli$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \checktrans{\astlabel(\vtstruct) = \TTuple}{\UnexpectedType} \checktransarrow \True \OrTypeError\\\\
  \vtstruct \eqname \TTuple(\vts)\\
  \checktrans{\equallength(\vli, \vts)}{\UnexpectedType} \checktransarrow \True \OrTypeError\\\\
  i\in\listrange(\vli): \annotatepattern(\tenv, \vts[i], \vli[i]) \typearrow (\vlip[i], \vxs_i) \OrTypeError\\\\
  \newli \eqdef i\in\listrange(\vli): \vlip[i]\\
  \vses \eqdef \bigcup_{i\in\listrange(\vli)} \vxs_i
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternTuple(\vli)}{\vp}) \typearrow (\overname{\PatternTuple(\newli)}{\newp}, \vses)
}
\end{mathpar}
\CodeSubsection{\PTupleBegin}{\PTupleEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{PTuple}
\ExampleDef{Evaluation of a Tuple Pattern}
In \listingref{semantics-ptuple},
\texttt{match\_true} evaluates to \True, since
the tuple of expression \\
\texttt{(3, '1101010')} matches the tuple of patterns \texttt{(<= 42, 'xx101010')},
whereas \\
\texttt{match\_false} evaluates to \False, since
the tuple of expression \texttt{(3, '1101010')} does not match the tuple of patterns \texttt{(>= 42, 'xx101010')}.
\ASLListing{Matching against a tuple of patterns}{semantics-ptuple}{\semanticstests/SemanticsRule.PTuple.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ gives a list of patterns $\vps$ of length $k$, $\PatternTuple(\vps)$;
  \item $\vv$ gives a tuple of values $\vvs$ of length $k$;
  \item for all $1 \leq i \leq n$, $\vb_i$ is the evaluation result
        of $\vp_i$ with respect to the value $\vv_i$ in
        environment $\env$\ProseOrDynErrorDiverging;
  \item $\vbs$ is the list of all $\vb_i$ for $1 \leq i \leq k$;
  \item $\vb$ is the conjunction of the Boolean values of $\vbs$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vps \eqname \vp_{1..k}\\
  i=1..k: \getindex(i, \vv) \evalarrow \vvs_i\\
  i=1..k: \evalpattern(\env, \vvs_i, \vp_i) \evalarrow \ResultPattern(\nvbool(\vbs_i), \vg_i) \OrDynErrorDiverging\\\\
  \vres \eqdef \nvbool(\bigwedge_{i=1..k} \vbs_i)\\
  \vg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k
}{
  \evalpattern(\env, \vv, \PatternTuple(\vps)) \evalarrow \ResultPattern(\vres, \emptygraph)
}
\end{mathpar}
\CodeSubsection{\EvalPTupleBegin}{\EvalPTupleEnd}{../Interpreter.ml}

\section{Matching Any Pattern in a Set of Patterns\label{sec:MatchingAnyPatternInASetOfPatterns}}
\subsection{Syntax}
\begin{flalign*}
\Npattern     \derives\   & \Npatternset &\\
\Npatternset  \derives \  & \Tbnot \parsesep \Tlbrace \parsesep \Npatternlist \parsesep \Trbrace &\\
                  |\      & \Tlbrace \parsesep \Npatternlist \parsesep \Trbrace &\\
\Npatternlist \derives \ & \ClistOne{\Npattern} &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{pattern_any}
\BackupOriginalAST{
\begin{flalign*}
\pattern \derives\ & \PatternAny(\pattern^{*}) &
\end{flalign*}
}

\ASTRuleDef{PatternSet}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-patternset}{}
The function
\[
  \buildpatternset(\overname{\parsenode{\Npatternset}}{\vparsednode}) \;\aslto\; \overname{\pattern}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[not]{}{
  {
    \begin{array}{r}
  \buildpatternset(\Npatternset(\Tbnot, \Tlbrace, \punnode{\Npatternlist}, \Trbrace)) \astarrow\\
  \overname{\PatternNot(\astof{\vpatternlist})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[list]{}{
  \buildpatternset(\Npatternset(\Tlbrace, \punnode{\Npatternlist}, \Trbrace)) \astarrow
  \overname{\astof{\vpatternlist}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{PatternList}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-patternlist}{}
The function
\[
  \buildpatternlist(\overname{\parsenode{\Npatternlist}}{\vparsednode}) \;\aslto\; \overname{\pattern}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildclist[\buildpattern](\vpatterns) \astarrow \vpatternasts
}{
  {
    \begin{array}{r}
  \buildpatternlist(\Npatternlist(\namednode{\vpatterns}{\ClistOne{\Npattern}})) \astarrow\\
  \overname{\PatternAny(\vpatternasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{PAny}
\ExampleDef{Typing Any Patterns}
\listingref{typing-pany} shows examples of well-typed Any patterns.
\ASLListing{Well-typed Any patterns}{typing-pany}{\typingtests/TypingRule.PAny.asl}

\listingref{typing-pany-bad} shows an example of an ill-typed Any pattern.
\ASLListing{An ill-typed Any pattern}{typing-pany-bad}{\typingtests/TypingRule.PAny.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vp$ is the pattern which matches anything in a list $\vli$, that is, $\PatternAny(\vli)$;
\item annotating each pattern $\vl$ in $\vli$ yields $(\newl_\vl, \vxs_\vl)$\ProseOrTypeError;
\item define $\newli$ as the list of patterns $\newl_\vl$, for each $\vl$ in $\vli$;
\item $\newp$ is the pattern which matches anything in $\newli$, that is, \\ $\PatternAny(\newli)$;
\item define $\vses$ as the union of all $\vxs_\vl$, for each $\vl$ in $\vli$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vl\in\vli: \annotatepattern(\tenv, \vt, \vl) \typearrow (\newl_\vl, \vxs_\vl) \OrTypeError\\\\
  \newli \eqdef [\vl\in\vli: \newl_\vl]\\
  \vses \eqdef \bigcup_{\vl\in\vli} \vxs_\vl
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternAny(\vli)}{\vp}) \typearrow (\overname{\PatternAny(\newli)}{\newp}, \vses)
}
\end{mathpar}
\CodeSubsection{\PAnyBegin}{\PAnyEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{PAny}
\ExampleDef{Evaluation of a Match-any Pattern}
In \listingref{semantics-pany},
\texttt{match\_true} evaluates to \True, since \texttt{42} matches the second pattern in \verb|{3, 42}|,
whereas \texttt{match\_false} evaluates to \False, since \texttt{42} does not match
any pattern in \verb|{3, 4}|.
\ASLListing{Matching against any pattern in a list of patterns}{semantics-pany}{\semanticstests/SemanticsRule.PAny.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ is a list of patterns, $\PatternAny(\vps)$;
  \item $\vps$ is $\vp_{1..k}$;
  \item evaluating each pattern $\vp_i$ in $\env$ results in $\ResultPattern(\nvbool(\vb_i), \vg_i)$\ProseOrDynErrorDiverging;
  \item $\vb$ is the native Boolean which is the disjunction of $\vb_i$, for $i=1..k$;
  \item $\newg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vps \eqname \vp_{1..k}\\
  i=1..k : \evalpattern(\env, \vv, \vp_i) \evalarrow \ResultPattern(\nvbool(\vb_i), \vg_i) \OrDynErrorDiverging\\\\
  \vb \eqdef \nvbool(\bigvee_{i=1..k} \vb_i)\\
  \newg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k
}{
  \evalpattern(\env, \vv, \PatternAny(\vps)) \evalarrow \ResultPattern(\vb, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalPAnyBegin}{\EvalPAnyEnd}{../Interpreter.ml}

\section{Matching a Negated Pattern\label{sec:MatchingANegatedPattern}}
\subsection{Syntax}
\begin{flalign*}
\Npatternset \derives \  & \Tbnot \parsesep \Tlbrace \parsesep \Npatternlist \parsesep \Trbrace &\\
                  |\    & \Tlbrace \parsesep \Npatternlist \parsesep \Trbrace &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{pattern_not}
\BackupOriginalAST{
\begin{flalign*}
\pattern \derives\ & \PatternNot(\pattern) &
\end{flalign*}
}

The AST building rule is \ASTRuleRef{PatternSet} (the \textsc{NOT} case).

\subsection{Typing}
\TypingRuleDef{PNot}
\listingref{semantics-pnot} shows an example of a well-typed Negated pattern.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vp$ is the pattern which matches the negation of a pattern $\vq$, that is, $\PatternNot(\vq)$;
  \item annotating $\vq$ in $\tenv$ yields $(\newq, \vses)$\ProseOrTypeError;
  \item $\newp$ is pattern which matches the negation of $\newq$, that is, $\PatternNot(\newq)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatepattern(\tenv, \vq) \typearrow (\newq, \vses) \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \overname{\PatternNot(\vq)}{\vp}) \typearrow (\overname{\PatternNot(\newq)}{\newp}, \vses)
}
\end{mathpar}
\CodeSubsection{\PNotBegin}{\PNotEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{PNot}
\ExampleDef{Evaluation of a Negated Pattern}
In \listingref{semantics-pnot},
\texttt{match\_true} evaluates to \True, since \texttt{42} does not match the pattern \verb|{3}|,
whereas \texttt{match\_false} evaluates to \False, since \texttt{42} does match the pattern \verb|{42}|.
\ASLListing{Matching against a negated pattern}{semantics-pnot}{\semanticstests/SemanticsRule.PNot.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vp$ is a negation pattern, $\PatternNot(\vpone)$;
\item evaluating the pattern $\vpone$ in an environment $\env$ is \\
      $\ResultPattern(\vbone, \newg)$\ProseOrDynErrorDiverging;
\item $\vb$ is the Boolean negation of $\vbone$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexprsef(\env, \vpone) \evalarrow \ResultExprSEF(\vbone, \newg) \OrDynErrorDiverging\\\\
  \evalunop(\BNOT, \vbone) \evalarrow \vb
}{
  \evalpattern(\env, \vv, \PatternNot(\vpone)) \evalarrow \ResultPattern(\vb, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalPNotBegin}{\EvalPNotEnd}{../Interpreter.ml}

\section{Pattern Expressions\label{sec:ASTRulesForPatternExpressions}}
The set of expressions appearing inside patterns are grammatically derived
from \\
$\Nexprpattern$.
These are slightly restricted with respect to the set of all expressions,
which are grammatically derived from $\Nexpr$.
%
The grammar is almost identical to that of $\Nexpr$, except that pattern expressions
for matching a single value and for matching a range of values, exclude tuples
(for which the tuple expression is used).

The AST for these expressions is $\expr$ --- same as the AST for $\Nexpr$.
The builders for $\Nexprpattern$ are identical to those of $\Nexpr$. For completeness,
we list them below.

The type rules and dynamic semantics rules for both sets of expressions is the same,
as the same AST is generated for both.

Pattern expressions are side-effect-free, as guaranteed by the checks to \\
$\checksymbolicallyevaluable$, and thus in the dynamic semantics
they are evaluated via $\evalexprsef$.

\subsection{ASTRule.ExprPattern\label{sec:ASTRule.ExprPattern}}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-exprpattern}{}
The function
\[
  \buildexprpattern(\overname{\parsenode{\Nexprpattern}}{\vparsednode}) \;\aslto\; \overname{\expr}{\vastnode}
\]
transforms a pattern expression parse node $\vparsednode$ into a pattern AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[literal]{}{
  \buildexprpattern(\Nexprpattern(\punnode{\Nvalue})) \astarrow
  \overname{\ELiteral(\astof{\vvalue})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[var]{}{
  \buildexprpattern(\Nexprpattern(\Tidentifier(\id))) \astarrow
  \overname{\EVar(\id)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[binop]{}{
    {
      \begin{array}{r}
  \buildexprpattern(\Nexprpattern(\punnode{\Nexprpattern}, \punnode{\Nbinop}, \punnode{\Nexpr})) \astarrow\\
  \overname{\EBinop(\astof{\vexprpattern}, \astof{\vbinop}, \astof{\vexpr})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[unop]{}{
  \buildexprpattern(\Nexprpattern(\punnode{\Nunop}, \punnode{\Nexpr})) \astarrow
  \overname{\EUnop(\astof{\vunop}, \astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[cond]{
    \buildexpr(\vcondexpr) \astarrow \astversion{\vcondexpr}\\
    \buildexpr(\vthenexpr) \astarrow \astversion{\vthenexpr}\\
    \buildexpr(\velseexpr) \astarrow \astversion{\velseexpr}
  }{
    {
      \begin{array}{r}
  \buildexprpattern\left(\Nexprpattern\left(
    \begin{array}{l}
    \Tif, \namednode{\vcondexpr}{\Nexpr}, \Tthen, \\
    \wrappedline\ \namednode{\vthenexpr}{\Nexpr}, \Telse, \namednode{\velseexpr}{\Nexpr}
    \end{array}
    \right)\right) \astarrow\\
  \overname{\ECond(\astversion{\vcondexpr}, \astversion{\vthenexpr}, \astversion{\velseexpr})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[call]{
    \buildplist[\buildexpr](\vargs) \astarrow \vexprasts
  }{
  \buildexprpattern(\Nexprpattern(\punnode{\Ncall})) \astarrow
  \overname{\ECall(\astof{\vcall})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[slice]{}{
    {
      \begin{array}{r}
  \buildexprpattern(\Nexprpattern(\punnode{\Nexprpattern}, \punnode{\Nslice})) \astarrow\\
  \overname{\ESlice(\astof{\vexprpattern}, \astof{\vslice})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[set\_array]{}{
    {
      \begin{array}{r}
  \buildexprpattern(\Nexprpattern(\punnode{\Nexprpattern}, \Tllbracket, \punnode{\Nexpr}, \Trrbracket)) \astarrow\\
  \overname{\LESetArray(\astof{\vexprpattern}, \astof{\vexpr})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[get\_field]{}{
  \buildexprpattern(\Nexprpattern(\Nexprpattern, \Tdot, \Tidentifier(\id))) \astarrow
  \overname{\EGetField(\astof{\vexpr}, \id)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[get\_fields]{
    \buildclist[\buildidentity](\vids) \astarrow \vidasts
  }{
    {
      \begin{array}{r}
  \buildexprpattern(\Nexprpattern(\punnode{\Nexprpattern}, \Tdot, \Tlbracket, \namednode{\vids}{\ClistOne{\Tidentifier}}, \Trbracket)) \astarrow\\
  \overname{\EGetFields(\astof{\vexprpattern}, \vidasts)}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[atc]{}{
    {
      \begin{array}{r}
  \buildexprpattern(\Nexprpattern(\punnode{\Nexprpattern}, \Tas, \punnode{\Nty})) \astarrow\\
  \overname{\EATC(\astof{\vexprpattern}, \astof{\tty})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\begin{mathpar}
\inferrule[atc\_int\_constraints]{}{
  {
  \begin{array}{r}
    \buildexprpattern(\Nexprpattern(\punnode{\Nexprpattern}, \Tas, \punnode{\Nconstraintkind})) \astarrow\\
    \overname{\EATC(\astof{\vexprpattern}, \TInt(\astof{\vconstraintkind}))}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pattern\_in]{}{
  {
  \begin{array}{r}
    \buildexprpattern(\Nexprpattern(\punnode{\Nexprpattern}, \Tin, \punnode{\Npatternset})) \astarrow\\
    \overname{\EPattern(\astof{\vexprpattern}, \astof{\vpatternset})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pattern\_eq]{}{
  {
    \begin{array}{r}
      \buildexprpattern(\overname{\Nexprpattern(\punnode{\Nexprpattern}, \Teqop, \Tmasklit(\vm))}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astof{\vexprpattern}, \PatternMask(\vm))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pattern\_neq]{}{
  {
    \begin{array}{r}
      \buildexprpattern(\overname{\Nexprpattern(\punnode{\Nexprpattern}, \Tneq, \Tmasklit(\vm))}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astof{\vexprpattern}, \PatternNot(\PatternMask(\vm)))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[arbitrary]{}{
  \buildexprpattern(\Nexprpattern(\Tarbitrary, \Tcolon, \punnode{\Nty})) \astarrow
  \overname{\EArbitrary(\astof{\tty})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[record\_empty]{}{
  {
  \begin{array}{r}
  \buildexprpattern\left(\Nexprpattern\left(
    \begin{array}{l}
    \Tidentifier(\vt), \Tlbrace, \Tminus, \Trbrace \\
    \end{array}
    \right)\right) \\
    \astarrow\ \overname{\ERecord(\TNamed(\vt), \emptylist)}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[record\_non\_empty]{
    \buildclist[\buildfieldassign](\vfieldassigns) \astarrow \vfieldassignasts
  }{
    {
    \begin{array}{r}
      \buildexprpattern\left(\Nexprpattern\left(
      \begin{array}{l}
      \Tidentifier(\vt), \Tlbrace, \\
      \wrappedline\ \namednode{\vfieldassigns}{\ClistZero{\Nfieldassign}}, \\
      \wrappedline\ \Trbrace
      \end{array}
      \right)\right) \\
      \astarrow\ \overname{\ERecord(\TNamed(\vt), \vfieldassignasts)}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_expr]{}{
  {
    \begin{array}{r}
      \buildexprpattern(\Nexprpattern(\Tlpar, \punnode{\Nexprpattern}, \Trpar)) \astarrow\\
      \overname{\ETuple([\ \astof{\vexprpattern}\ ])}{\vastnode}
    \end{array}
  }
}
\end{mathpar}
