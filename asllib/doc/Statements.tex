\chapter{Statements\label{chap:Statements}}
Statements update storage elements and determine the flow of control in a subprogram.

\ExampleDef{Statements}
\listingref{Statements} shows some examples of statements.
\ASLListing{Examples of statements}{Statements}{\definitiontests/Statements.asl}

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Statements} defines the formal relations used for statements;
  \item \secref{PassStatements} defines pass statements;
  \item \secref{AssignmentStatements} defines assignment statements;
  \item \secref{SetterAssignmentStatements} defines setter assignment statements;
  \item \secref{DeclarationStatements} defines declaration statements;
  \item \secref{DeclarationStatementsElidedParameter} defines declaration statements with an elided parameter;
  \item \secref{SequencingStatement} defines sequencing statements;
  \item \secref{CallStatements} defines call statements;
  \item \secref{ConditionalStatements} defines conditional statements;
  \item \secref{CaseStatements} defines case statements;
  \item \secref{AssertionStatements} defines assertion statements;
  \item \secref{WhileStatements} defines while statements;
  \item \secref{RepeatStatements} defines repeat statements;
  \item \secref{ForStatements} defines for-looping statements;
  \item \secref{ThrowStatements} defines throw statements;
  \item \secref{TryStatements} defines try statements;
  \item \secref{ReturnStatements} defines return statements;
  \item \secref{PrintStatements} defines print statements;
  \item \secref{UnreachableStatement} defines unreachable statements;
  \item \secref{PragmaStatements} defines pragma statements.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Statements}
\paragraph{Syntax:} Statements are grammatically derived from $\Nstmt$.

\paragraph{Abstract Syntax:} Statements are derived in the abstract syntax from $\stmt$
and generated by $\buildstmt$.
\MarkedIgnoredRelationDefinition{
\hypertarget{build-stmt}{}
The function
\[
\buildstmt(\overname{\parsenode{\Nstmt}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a statement parse node $\vparsednode$ into a statement AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\paragraph{Typing:} Statements are annotated by $\annotatestmt$.
\RenderRelation{annotate_stmt}
\BackupOriginalRelation{
The function
\[
  \annotatestmt(\overname{\staticenvs}{\tenv} \aslsep \overname{\stmt}{\vs}) \aslto
  (\overname{\stmt}{\news} \times \overname{\staticenvs}{\newtenv} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\typeerror}{\TypeErrorConfig}
\]
annotates a statement $\vs$ in an environment $\tenv$, resulting in $\news$ ---
the \typedast\ for $\vs$, which is also known as the \emph{annotated statement} ---
a modified environment $\newtenv$, and \sideeffectsetterm\ $\vses$. \ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\paragraph{Semantics:} Statements are evaluated by $\evalstmt$.
\RenderRelation{eval_stmt}
\BackupOriginalRelation{
The relation
\[
  \evalstmt(\overname{\envs}{\env} \aslsep \overname{\stmt}{\vs}) \;\aslrel\;
  \left(
  \begin{array}{cl}
  \overname{\TReturning}{\Returning((\vvs,\newg), \newenv)} & \cup\\
  \overname{\TContinuing}{\Continuing(\newg,\newenv)} & \cup\\
  \overname{\TThrowing}{\ThrowingConfig} & \cup \\
  \overname{\TDynError}{\DynErrorConfig} & \cup \\
  \overname{\TDiverging}{\DivergingConfig} & \\
  \end{array}
  \right)
\]
evaluates a statement $\vs$ in an environment $\env$, resulting in one of four types of configurations
(see more details in \secref{KindsOfSemanticConfigurations}):
\begin{itemize}
  \item returning configurations with values $\vvs$, execution graph $\newg$, and a modified environment $\newenv$;
  \item continuing configurations with an execution graph $\newg$ and modified environment $\newenv$;
  \item throwing configurations;
  \item error configurations;
  \item diverging configurations.
\end{itemize}
} % END_OF_BACKUP_RELATION

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pass Statements\label{sec:PassStatements}}
\hypertarget{def-passstatementterm}{}

\ASLListing{A \texttt{pass} statement}{semantics-spass}{\semanticstests/SemanticsRule.SPass.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tpass \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_pass}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SPass &
\end{flalign*}
}

\ASTRuleDef{SPass}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tpass, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPass}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SPass}
\ExampleDef{Typing a Pass Statement}
Annotating the \passstatementterm{} in \listingref{semantics-spass} does
not modify the \staticenvironmentterm{}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a pass statement, that is, $\SPass$;
  \item $\news$ is $\vs$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}{\annotatestmt(\tenv, \SPass) \typearrow (\SPass, \tenv, \overname{\emptyset}{\vses})}
\end{mathpar}
\CodeSubsection{\SPassBegin}{\SPassEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SPass}
\ExampleDef{Evaluation of Pass Statements}
In \listingref{semantics-spass}, \texttt{pass;} does not modify the environment.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vs$ is a \passstatementterm, $\SPass$;
\item $\newg$ is the empty graph;
\item $\newenv$ is $\env$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \evalstmt(\env, \SPass) \evalarrow \Continuing(\overname{\emptygraph}{\newg}, \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalSPassBegin}{\EvalSPassEnd}{../Interpreter.ml}

\hypertarget{def-assignmentstatementterm}{}
\section{Assignment Statements\label{sec:AssignmentStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Nlexpr \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_assign}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SAssign(\lexpr, \expr) &
\end{flalign*}
}

\ASTRuleDef{SAssign}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\punnode{\Nlexpr}, \Teq, \punnode{\Nexpr}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SAssign(\astof{\vlexpr}, \astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SAssign}
\ExampleDef{Typing an Assignment Statement}
In \listingref{semantics-sassign}, the assignment \verb|x = 3;|
is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assignment \texttt{le = re}, that is, $\SAssign(\vle, \vre)$;
  \item annotating the \rhsexpression{} $\vre$ in $\tenv$ yields $(\vtre, \vreone, \vsesre)$\ProseOrTypeError;
  \item annotating the \assignableexpression\ $\vle$ with the type $\vtre$ in $\tenv$ yields \\ $(\vleone, \vsesle)$\ProseOrTypeError;
  \item $\news$ is the assignment \texttt{le1 = re1}, that is, $\SAssign(\vleone, \vreone)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesre$ and $\vsesle$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \vre) \typearrow (\vtre, \vreone, \vsesre) \OrTypeError\\\\
  \annotatelexpr(\tenv, \vle, \vtre) \typearrow (\vleone, \vsesle) \OrTypeError\\\\
  \vses \eqdef \vsesre \cup \vsesle
}{
  \annotatestmt(\tenv, \overname{\SAssign(\vle, \vre)}{\vs}) \typearrow
  (\overname{\SAssign(\vleone, \vreone)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SAssignBegin}{\SAssignEnd}{../Typing.ml}

\subsection{Semantics}
There are two rules for evaluating assignments:
\begin{itemize}
\item \SemanticsRuleRef{SAssignCall} handles assignments where the \rhsexpression{}
      is a \callexpressionterm{} and the left-hand-side expression is a tuple.
\item \SemanticsRuleRef{SAssign} handles all other assignments.
\end{itemize}

Although the sequential semantics of both types of statements is the same,
\SemanticsRuleRef{SAssignCall} generates a different execution graph ---
one where each value of the left-hand-side tuple depends on the \executiongraphterm{}
for the corresponding (that is, at the same position) value returned from the \callexpressionterm{}.
In contrast, the \executiongraphterm{} generated by \SemanticsRuleRef{SAssign}
creates dependencies between the entire \executiongraphterm{} for the evaluated right-hand-side
expression and the entire \executiongraphterm{} for the left-hand-side \executiongraphterm{}.

The rules for assignments first produce a value for the right-hand side expression
and then complete the update to the environment via an appropriate rule for evaluating the
\assignableexpression{} on the left-hand-side of the assignment,
which in turn handles variables, tuples, bitvectors, etc.

\SemanticsRuleDef{SAssignCall}
\ExampleDef{Evaluation of Multi-variable Assignment from Subprogram Calls}
In \listingref{assigncallsemantics}, given that the function call \texttt{f(1)} returns a triple of values ---
$\nvint(1)$, $\nvint(2)$, and $\nvint(3)$
(each with its own associated execution graph),
the statement \texttt{(a,b,-) = f(1)} assigns the value $\nvint(1)$ to the mutable variable \texttt{a},
$\nvint(2)$ to the mutable variable~\texttt{b}, and discards $\nvint(3)$.

\ASLListing{Assignment from a call expression.}{assigncallsemantics}{\semanticstests/SemanticsRule.SAssignCall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ assigns an \assignableexpression\ list from a subprogram call, \\
        $\SAssign(\LEDestructuring(\les),\ECall(\vcall))$;
  \item $\les$ is a list of \assignableexpressions, each of which is either \\ a variable ($\LEVar(\Ignore)$)
        or a discarded variable ($\LEDiscard$);
  \item evaluating the subprogram call as per \chapref{SubprogramCalls} is
        $\ResultCall(\vms, \envone)$\ProseOrAbnormal;
  \item assigning each value in $\vms$ to the respective element of the tuple $\les$ is \\
        $\ResultLexpr(\vgtwo, \newg)$\ProseOrAbnormal.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vles \eqdef \vle_{1..k}\\
  i=1..k: \lexprisvar(\vle_i) \evalarrow \True\\
  \evalcall(\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs) \evalarrow \ResultCall(\vms, \envone) \OrAbnormal\\\\
  \evalmultiassignment(\envone, \vles, \vms) \evalarrow \ResultLexpr(\newg, \newenv) \OrAbnormal
}{
  \evalstmt(\env, \SAssign(\LEDestructuring(\les),\ECall(\vcall))) \\
  \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSAssignCallBegin}{\EvalSAssignCallEnd}{../Interpreter.ml}

\SemanticsRuleDef{SAssign}
\ExampleDef{Evaluation of Assignment Statements}
In \listingref{semantics-sassign},
\texttt{x = 3;} binds \texttt{x} to $\nvint(3)$ in the environment where \texttt{x} is bound to
$\nvint(42)$, and $\newenv$ is such that \texttt{x} is bound to $\nvint(3)$.
\ASLListing{Evaluating an assignment}{semantics-sassign}{\semanticstests/SemanticsRule.SAssign.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assignment statement, $\SAssign(\vle, \vre)$;
  \item \OneApplies
  \begin{itemize}
    \item $\vre$ is not a call expression;
    \item $\vle$ is not a multi-var expression (that is, not a $\LEDestructuring$);
    \item $\vle$ is a multi-var expression, but one of its components is neither a variable
          nor a discarded variable.
  \end{itemize}
  \item evaluating the expression $\vre$ in $\env$ yields
        $\ResultExpr(\vm, \envone)$ (here, $\vm$ is a pair consisting of a value and an execution graph)\ProseOrAbnormal;
  \item evaluating the \assignableexpression\ $\vle$ with $\vm$ in $\envone$,
        as per \chapref{AssignableExpressions}, yields $\ResultLexpr(\newg, \newenv)$\ProseOrAbnormal.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {\left(
  \begin{array}{c}
  \astlabel(\vle) \neq \LEDestructuring\ \lor \\
  \astlabel(\vre) \neq \ECall\ \lor\\
  \vle = \LEDestructuring(\les) \land \exists \vi\in\listrange(\vle).\ \neg\lexprisvar(\vle[\vi])
  \end{array}
  \right)
  }\\
  \evalexpr(\env, \vre) \evalarrow \ResultExpr(\vm, \envone) \OrAbnormal\\
  \evallexpr(\envone, \vle, \vm) \evalarrow \ResultLexpr(\newg, \newenv) \OrAbnormal
}{
  \evalstmt(\env, \SAssign(\vle, \vre)) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSAssignBegin}{\EvalSAssignEnd}{../Interpreter.ml}

\SemanticsRuleDef{LexprIsVar}
\RenderRelation{lexpr_is_var}
\BackupOriginalRelation{
The rule uses the syntactic predicate defined as follows:
\[
  \lexprisvar(\lexpr) \aslto \True
\]
which holds when a left-hand side expression
represents a variable or a discarded left-hand-side expression
} % END_OF_BACKUP_RELATION

In \ExampleRef{Evaluation of Multi-variable Assignment from Subprogram Calls},
the \assignableexpressions{} \verb|a|, \verb|b| are variables,
and \verb|-| is a discarded \assignableexpression{}.

\ProseParagraph
\ProseEqdef{$\vle$}{$\True$ if and only if $\vle$ is either a variable or a discarded left-hand-side expression.}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{ \lexprisvar(\vle) \evalarrow \astlabel(\vle) \in \{\LEVar, \LEDiscard\}}
\end{mathpar}

\section{Setter Assignment Statements\label{sec:SetterAssignmentStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \
   & \Ncall \parsesep \Nsetteraccess \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Ncall \parsesep \Nsetteraccess \parsesep \Nslices \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Ncall \parsesep \Tdot \parsesep \Tlbracket \parsesep \Clisttwo{{\Tidentifier}} \parsesep \Trbracket \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
\Nsetteraccess \derives \
   & \emptysentence &\\
|\ & \Tdot \parsesep \Tidentifier \parsesep \Nsetteraccess &
\end{flalign*}

\SyntacticSugarDef{Setter Calls Followed by a Slice or a Field Access}
A call to a setter, followed by a slice or a field access is \syntacticsugar{}
for a sequence of statements, which first call the corresponding getter,
apply the corresponding slice of field, and then call the setter with the new value.
See \ExampleRef{A Setter Call as a Read-Modify-Write}.
Setter calls are desugared by \ASTRuleRef{DesugarSetter}.

\ASTRuleDef{MakeSetter}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-makesetter}{}
The function
\[
\makesetter(
  \overname{\call}{\vcall} \aslsep
  \overname{\expr}{\varg}) \aslto \overname{\call}{\vcallp}
\]
constructs a setter call $\vcallp$ using a base call $\vcall$ and right-hand side $\varg$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{}{
  \makesetter(\vcall, \varg) \aslto
    \overname{\left\{
      \begin{array}{rcl}
        \callname &:& \vcall.\callname,\\
        \callparams &:& \vcall.\callparams,\\
        \callargs &:& [\varg]\concat\vcall.\callargs,\\
        \callcalltype &:& \STSetter
      \end{array}
    \right\}}{\vcallp}
}
\end{mathpar}

\ASTRuleDef{DesugarSetter}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-desugarsetter}{}
The function
\[
\desugarsetter(
  \overname{\call}{\vcall} \aslsep
  \overname{\lhsaccess}{\vlhsaccess} \aslsep
  \overname{\expr}{\rhs}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from an assignment of expression $\rhs$ to a setter invocation $\vcall.\callname$ with accesses given by $\vlhsaccess$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[empty]{
  \vlhsaccess.\lhsaccessaccess = \emptylist \\
  \vlhsaccess.\lhsaccessslices = \emptylist \\\\
  \makesetter(\vcall, \rhs) \aslto \vcallp
}{
  \desugarsetter(\vcall, \vlhsaccess, \rhs)
  \astarrow
  \SCall(\vcallp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vlhsaccess.\lhsaccessaccess \neq \emptylist \lor
  \vlhsaccess.\lhsaccessslices \neq \emptylist \\\\
  \vx \in \Identifier \text{ is fresh} \\\\
  \desugarlhsaccess(\vx, \vlhsaccess) \astarrow \lhs \\
  \vmodify \eqdef \SAssign(\lhs, \rhs) \\
  \readmodifywrite(\vcall, \vx, \vmodify) \astarrow \vcallp
}{
  \desugarsetter(\vcall, \vlhsaccess, \rhs)
  \astarrow
  \vcallp
}
\end{mathpar}

\ASTRuleDef{DesugarSetterSetfields}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-desugarsettersetfields}{}
The function
\[
\desugarsettersetfields(
  \overname{\call}{\vcall} \aslsep
  \overname{\KleeneStar{\Identifier}}{\vfields} \aslsep
  \overname{\expr}{\rhs}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from an assignment of $\rhs$ to a setter invocation $\vcall.\callname$ with concatenated field accesses given by $\vfields$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \vx \in \Identifier \text{ is fresh} \\\\
  \lhs \eqdef \LESetFields(\LEVar(\vx), \vfields) \\
  \vmodify \eqdef \SAssign(\lhs, \rhs) \\
  \readmodifywrite(\vcall, \vx, \vmodify) \astarrow \vcallp
}{
  \desugarsettersetfields(\vcall, \fields, \rhs)
  \astarrow
  \vcallp
}
\end{mathpar}

\ASTRuleDef{ReadModifyWrite}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-readmodifywrite}{}
The function
\[
\readmodifywrite(
  \overname{\call}{\vcall} \aslsep
  \overname{\Identifier}{\vx} \aslsep
  \overname{\stmt}{\vmodify}) \aslto \overname{\stmt}{\news}
\]
builds a sequence of statements to read from the getter invocation $\vcall.\callname$, modify the resulting value using $\vmodify$, and write it to a setter invocation $\vcall.\callname$.
} % END_OF_IGNORED_RELATION


\ExampleDef{A Setter Call as a Read-Modify-Write}
\listingref{ReadModifyWriteSlice} shows how a setter call followed by a slice is
\desugared.
\ASLListing{A Setter followed by a Slice}{ReadModifyWriteSlice}{\syntaxtests/ASTRule.ReadModifyWriteSlice.asl}

\listingref{ReadModifyWriteSlice} shows how a setter call followed by a field access is
\desugared.
\ASLListing{A Setter followed by a Field Access}{ReadModifyWriteField}{\syntaxtests/ASTRule.ReadModifyWriteField.asl}

\begin{mathpar}
\inferrule{
  \setcalltype(\vcall, \STGetter) \aslto \vgetter \\\\
  \vread \eqdef \SDecl(\LDKVar, \LDIVar(\vx), \None, \some{\ECall(\vgetter)}) \\\\
  \makesetter(\vcall, \EVar(\vx)) \aslto \vsetter
}{
  \readmodifywrite(\vcall, \vx, \vmodify)
  \astarrow
  \overname{\SSeq (\SSeq(\vread, \vmodify), \SCall(\vsetter))}{\news}
}
\end{mathpar}

\ASTRuleDef{SetterAssign}
\begin{mathpar}
\inferrule[no\_slices]{
  \buildaccess(\vsetteraccess) \astarrow \vaccess \\\\
  {
  \vlhsaccess \eqdef
    \left\{
      \begin{array}{rcl}
        \lhsaccessaccess &:& \vaccess,\\
        \lhsaccessslices &:& \emptylist
      \end{array}
    \right\}
  } \\
  \desugarsetter(\astof{\vcall}, \vlhsaccess, \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\Ncall}, \namednode{\vsetteraccess}{\Nsetteraccess}, \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule[slices]{
  \buildaccess(\vsetteraccess) \astarrow \vaccess \\\\
  {
  \vlhsaccess \eqdef
    \left\{
      \begin{array}{rcl}
        \lhsaccessaccess &:& \vaccess,\\
        \lhsaccessslices &:& \astof{\vslices}
      \end{array}
    \right\}
  } \\
  \desugarsetter(\astof{\vcall}, \vlhsaccess, \astof{\vexpr}) \astarrow \vastnode
}{
  {
    \begin{array}{r}
      \buildstmt(\overname{\Nstmt(\punnode{\Ncall}, \namednode{\vsetteraccess}{\Nsetteraccess}, \punnode{\Nslices}, \Teq, \punnode{\Nexpr}, \Tsemicolon
      )}{\vparsednode})
      \astarrow \\ \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[setfields]{
  \buildclist[\buildidentity](\vfields) \astarrow \vfieldasts \\
  \desugarsettersetfields(\astof{\vcall}, \vfieldasts, \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\Ncall}, \Tdot,
    \Tlbracket, \namednode{\vfields}{\Clisttwo{\Tidentifier}}, \Trbracket, \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\subsection{Typing and semantics}
As given by applying the relevant rules to the desugared AST.

\hypertarget{def-declarationstatementterm}{}
\section{Declaration Statements\label{sec:DeclarationStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \option{\Nasty} \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Ndeclitem \parsesep \Nasty \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Clisttwo{\Tidentifier} \parsesep \Nasty \parsesep \Tsemicolon &\\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_decl}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SDecl(\localdeclkeyword, \localdeclitem, \ty?, \expr?)
\end{flalign*}
}

\ASTRuleDef{SDecl}
\begin{mathpar}
\inferrule[let\_constant]{
  \buildoption[\buildasty](\vt) \astarrow \astversion{\vt}
}{
  {
  \begin{array}{r}
  \buildstmt(\overname{\Nstmt(\Nlocaldeclkeyword, \Ndeclitem, \namednode{\vt}{\option{\Nasty}}, \Teq, \punnode{\Nexpr}, \Tsemicolon)}{\vparsednode})
  \astarrow\\
  \overname{\SDecl(\astof{\vlocaldeclkeyword}, \astof{\vdeclitem}, \astversion{\vt}, \some{\astof{\vexpr}})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[uninit\_var]{}{
  {
  \begin{array}{r}
    \buildstmt(\overname{\Nstmt(\Tvar, \Ndeclitem, \punnode{\Nasty}, \Tsemicolon)}{\vparsednode})
    \astarrow \\
    \overname{\SDecl(\LDKVar, \astof{\vdeclitem}, \astof{\vasty}, \None)}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[multi\_var]{
  \buildclist[\buildidentity](\vids) \astarrow \astversion{\vids}\\
  \buildasty(\vt) \astarrow \astversion{\vt} \\
  \vstmts \eqdef [\vx\in\astversion{\vids}: \SDecl(\LDKVar, \vx, \astversion{\vt}, \None)]\\
  \stmtfromlist(\vstmts) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\Tvar, \namednode{\vids}{\Clisttwo{\Tidentifier}}, \namednode{\vt}{\Nasty}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \vastnode
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SDecl}
\ExampleDef{Typing Declaration Statements}
\listingref{typing-sdecl} shows well-typed declaration statements.
\ASLListing{Typing declaration statements}{typing-sdecl}{\typingtests/TypingRule.SDecl.asl}

The specifications in \listingref{typing-sdecl-bad1} ill-typed,
since local constant storage elements are not allowed.
\ASLListing{A (illegal) local constant declaration}{typing-sdecl-bad1}{\typingtests/TypingRule.SDecl.bad1.asl}

The specification in \listingref{typing-sdecl-bad2} is ill-typed,
since immutable local storage elements require an initializing expression.
\ASLListing{An uninitialized immutable local storage declaration}{typing-sdecl-bad2}{\typingtests/TypingRule.SDecl.bad2.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a declaration with an initializing expression $\ve$,
          that is, \\
          $\SDecl(\ldk, \ldi, \tyopt, \some{\ve})$;
    \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields $(\vte,\vep, \vsese)$\ProseOrTypeError;
    \item applying $\annotatelocaldecltypeannot$ to the environment $\tenv$, type annotation $\tyopt$, type $\vte$, local declaration keyword $\ldk$, expression $\vep$, and local declaration item $\ldi$ yields $(\tenvone, \tyoptp, \vsesldi)$\ProseOrTypeError;
    \item \Proseeqdef{$\vses$}{the union of $\vsese$ and $\vsesldi$};
    \item $\news$ is a declaration with $\ldk$, $\ldi$, type annotation $\tyoptp$, and an expression $\vep$;
    \item $\newtenv$ is $\tenvone$.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
  \item $\vs$ is a local declaration statement with a variable keyword and no initializing expression,
        that is, $\SDecl(\LDKVar, \ldi, \tyopt, \None)$ (local declarations of \texttt{let} variables require
        an initializing expression, otherwise they are rejected by an ASL parser);
  \item checking that $\tyopt$ is not $\None$, that is, the declaration has a type annotation, yields $\True$\ProseOrTypeError;
  \item $\tyopt$ is $\some{\vt}$;
  \item annotating $\vt$ in $\tenv$ yields $(\vtp, \vses)$\ProseOrTypeError;
  \item applying $\basevalue$ to $\vtp$ in $\tenv$ yields $\veinit$\ProseOrTypeError;
  \item annotating the local declaration item $\ldi$ with the type $\vtp$ and local declaration keyword $\LDIVar$
        yields $\newtenv$\ProseOrTypeError;
  \item define $\news$ as local declaration statement with variable keyword, local declaration item $\ldi$, type annotation $\vtp$, and initializing expression $\veinit$, that is, $\SDecl(\LDKVar, \ldi, \some{\veinit})$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[some]{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vsese) \OrTypeError\\\\
  {
  \begin{array}{r}
  \annotatelocaldecltypeannot(\tenv, \tyopt, \vte, \ldk, \vep, \ldi) \typearrow \\
  (\tenvone, \tyoptp, \vsesldi) \OrTypeError
  \end{array}
  }\\
  \vses \eqdef \vsese \cup \vsesldi\\
  \news \eqdef \SDecl(\ldk, \ldi, \tyoptp, \some{\vep})
}{
  \annotatestmt(\tenv, \overname{\SDecl(\ldk, \ldi, \tyopt, \some{\ve})}{\vs}) \typearrow (\news, \overname{\tenvone}{\newtenv}, \vses)
}
\end{mathpar}
\identr{YSPM}

\begin{mathpar}
\inferrule[none]{
  \techeck(\tyopt \neq \None, \TypeErrorVal{\BadDeclaration}) \typearrow \True \OrTypeError \\
  \tyopt \eqname \some{\vt} \\
  \annotatetype(\tenv, \vt) \typearrow (\vtp, \vses) \OrTypeError\\\\
  \basevalue(\tenv, \vtp) \typearrow \veinit \OrTypeError\\\\
  \annotatelocaldeclitem(\tenv, \vtp, \LDKVar, \None, \ldip) \typearrow \newtenv \OrTypeError \\
  \news \eqdef \SDecl(\LDKVar, \ldi, \some{\vtp}, \some{\veinit})
}{
  \annotatestmt(\tenv, \overname{\SDecl(\LDKVar, \ldi, \tyopt, \None)}{\vs}) \typearrow (\news, \newtenv, \vses)
}
\end{mathpar}
\CodeSubsection{\SDeclegin}{\SDeclEnd}{../Typing.ml}

\TypingRuleDef{AnnotateLocalDeclTypeAnnot}
\RenderRelation{annotate_local_decl_type_annot}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
  \annotatelocaldecltypeannot
  \left(
  \begin{array}{c}
    \overname{\staticenvs}{\tenv} \aslsep \\
    \overname{\Option{\ty}}{\tyopt} \aslsep \\
    \overname{\ty}{\vte} \aslsep \\
    \overname{\localdeclkeyword}{\ldk} \aslsep \\
    \overname{\expr}{\vep} \aslsep\\
    \overname{\localdeclitem}{\ldi}
  \end{array}
  \right)
  \aslto \\
  \begin{array}{cl}
    \left(\overname{\staticenvs}{\newtenv} \aslsep \overname{\Option{\ty}}{\tyoptp} \aslsep \overname{\TSideEffectSet}{\vses}\right)
    & \cup \\
    \overname{\typeerror}{\TypeErrorConfig} &
  \end{array}
\end{array}
\]
annotates the type annotation $\tyopt$ in the \staticenvironmentterm{} $\tenv$ within the context of a local declaration with keyword $\ldk$, item $\ldi$, and initializing expression $\vep$ with type $\vte$.
It yields the modified \staticenvironmentterm{} $\newtenv$, the annotated type annotation $\tyoptp$, and the inferred \sideeffectsetterm{} $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

See \ExampleRef{Typing Declaration Statements}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\tyopt$ is $\None$;
    \item \Prosenoprecisionloss{\vte};
    \item $\newtenv$ is the result of $\annotatelocaldeclitem(\tenv, \vte, \ldk, \some{\vep}, \ldi)$\ProseOrTypeError;
    \item $\tyoptp$ is $\tyopt$;
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\tyopt$ is $\some{\vt}$;
    \item determining the \structureterm{} of $\vte$ in $\tenv$ yields $\vtep$\ProseOrTypeError;
    \item propagating integer constraints from $\vtep$ to $\vt$ using $\inheritintegerconstraints$ yields $\vtp$\ProseOrTypeError;
    \item annotating the type $\vtp$ in $\tenv$ yields $(\vtpp, \vses)$\ProseOrTypeError;
  \item determining whether $\vtpp$ can be initialized with $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the local declaration item $\ldi$ with the local declaration keyword $\ldk$, given
  the expression $\vep$, in the environment $\tenv$, yields $\newtenv$;
  \item $\tyoptp$ is $\some{\vtpp}$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{
  \annotatelocaldeclitem(\tenv, \vte, \ldk, \some{\vep}, \ldi) \typearrow \newtenv \OrTypeError
}{
  \annotatelocaldecltypeannot(\tenv, \overname{\None}{\tyopt}, \vte, \ldk, \vep, \ldi) \typearrow (\newtenv, \overname{\None}{\tyoptp}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \tstruct(\tenv, \vte) \typearrow \vtep \OrTypeError \\
  \inheritintegerconstraints(\vt, \vtep) \typearrow \vtp \OrTypeError \\
  \annotatetype(\tenv, \vtp) \typearrow (\vtpp, \vses) \OrTypeError\\\\
  \checkcanbeinitializedwith(\tenv, \vtpp, \vte) \typearrow \True \OrTypeError\\\\
  \annotatelocaldeclitem(\tenv, \vtpp, \ldk, \some{ \vep }, \ldip) \typearrow \newtenv \OrTypeError
}{
  \annotatelocaldecltypeannot(\tenv, \overname{\some{\vt}}{\tyopt}, \vte, \ldk, \vep, \ldi) \typearrow (\newtenv, \overname{\some{\vtpp}}{\tyoptp}, \vses)
}
\end{mathpar}

\TypingRuleDef{InheritIntegerConstraints}
\RenderRelation{inherit_integer_constraints}
\BackupOriginalRelation{
The function
\[
\inheritintegerconstraints(\overname{\ty}{\lhs} \aslsep \overname{\ty}{\rhs})
\aslto \overname{\ty}{\lhsp} \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
propagates integer constraints from the right-hand side type $\rhs$ to the left-hand side type annotation $\lhs$.
In particular, each occurrence of \pendingconstrainedintegertypeterm{} on the left-hand side should inherit constraints from a corresponding \wellconstrainedintegertypeterm{} on the right-hand side.
If the corresponding right-hand side type is not a \wellconstrainedintegertypeterm{} (including if it is an \unconstrainedintegertypeterm{}), the result is a \typingerrorterm{}.
} % END_OF_BACKUP_RELATION

\listingref{typing-pendingconstrained} shows examples of pending-constrained
integer types.

\ExampleDef{Pending-constrained integer type vs. unconstrained integer type}
\listingref{pending-constrained-unconstrained} corresponds to the \typingerrorterm{}
in the \CaseName{int} below.
\ASLListing{An ill-typed pending-constrained integer type}{pending-constrained-unconstrained}
{\typingtests/TypingRule.InheritIntegerConstraints.unconstrained.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{int}
  \begin{itemize}
    \item $\lhs$ is a \pendingconstrainedintegertypeterm{};
    \item \Prosenoprecisionloss{$\rhs$};
    \item checking that $\rhs$ is a \wellconstrainedintegertypeterm{} yields $\True$\ProseOrTypeError;
    \item \Proseeqdef{$\lhsp$}{$\rhs$}.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\lhs$ is a tuple of types $\vlhstys$;
    \item $\rhs$ is a tuple of types $\vrhstys$;
    \item checking that the lengths of $\vlhstys$ and $\vrhstys$ are equal yields $\True$\ProseOrTypeError;
    \item define $\vlhstysp$ by applying $\inheritintegerconstraints$ to each element of \\
         $ \vlhstys$ and $\vrhstys$\ProseOrTypeError;
    \item \Proseeqdef{$\lhsp$}{$\TTuple(\vlhstysp)$}.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\lhs$ is not a \pendingconstrainedintegertypeterm{}, or one of $\lhs$ and $\rhs$ is not a \tupletypeterm{};
    \item \Proseeqdef{$\lhsp$}{$\lhs$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[int]{
  \checknoprecisionloss(\rhs) \typearrow \True \OrTypeError\\\\
  \techeck(\iswellconstrainedinteger(\rhs), \UnexpectedType) \typearrow \True\OrTypeError
}{
  \inheritintegerconstraints(\overname{\TInt(\PendingConstrained)}{\lhs}, \rhs) \typearrow \overname{\rhs}{\lhsp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \lhs = \TTuple(\vlhstys) \\
  \rhs = \TTuple(\vrhstys) \\\\
  \techeck(\equallength(\vlhstys, \vrhstys), \UnexpectedType) \typearrow \True \OrTypeError \\\\
  {
  \begin{array}{r}
  \vi \in \listrange(\lhs): \inheritintegerconstraints(\vlhstys_\vi, \vrhstys_\vi) \typearrow \\
  \vlhstysp_\vi \OrTypeError
  \end{array}
  }
}{
  \inheritintegerconstraints(\lhs, \rhs) \typearrow \overname{\TTuple(\vlhstysp)}{\lhsp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \lhs \neq \TInt(\PendingConstrained) \lor \astlabel(\lhs) \neq \TTuple \lor \astlabel(\rhs) \neq \TTuple
}{
  \inheritintegerconstraints(\lhs, \rhs) \typearrow \overname{\lhs}{\lhsp}
}
\end{mathpar}

\TypingRuleDef{CheckNoPrecisionLoss}
\RenderRelation{check_no_precision_loss}
\BackupOriginalRelation{
The function
\[
  \checknoprecisionloss(\overname{\ty}{\vt})
  \typearrow \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether the type $\vt$ is the result of a precision loss in its
constraint computation (see for example \TypingRuleRef{ApplyBinopTypes}).
} % END_OF_BACKUP_RELATION

\ExampleDef{Rejected Declaration Because of Precision Loss}
In \listingref{typing-imprecisetype}, the statement \verb|var b = a * a;|
corresponds to the \typingerrorterm{} raised in the \CaseName{Well-Constrained}
below.
The type of the right-hand-side (\texttt{a * a}) is imprecise because the multiplication of two
constant types would result in more than $2^17$ elements, see
\TypingRuleRef{ApplyBinopTypes}.
\ASLListing{Type-checking a declaration with an imprecise type}{typing-imprecisetype}{\typingtests/TypingRule.CheckNoPrecisionLoss.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{Well-Constrained}
    \begin{itemize}
      \item $\vt$ is a \wellconstrainedintegertypeterm{} with a precision $\PrecisionFull$ or $\vt$ is a \wellconstrainedintegertypeterm{} with a precision $\PrecisionLost$
      \item a \typingerrorterm{} is raised;
    \end{itemize}
  \item \AllApplyCase{Integer}
    \begin{itemize}
      \item $\vt$ is not a \wellconstrainedintegertypeterm{};
      \item no \typingerrorterm{} is raised.
    \end{itemize}
  \item \AllApplyCase{Other}
    \begin{itemize}
      \item $\vt$ is not an \integertypeterm{};
      \item no \typingerrorterm{} is raised.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[Well-Constrained]{%
    \techeck(p = \PrecisionFull, PrecisionLostDefining) \typearrow \True\OrTypeError
  }{%
    \checknoprecisionloss(\overname{\TInt(\WellConstrained(\Ignore, p))}{\vt}) \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Integer]{%
    \astlabel(\vc) \neq \WellConstrained
  }{%
    \checknoprecisionloss(\overname{\TInt(\vc)}{\vt}) \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Other]{%
    \astlabel(\vt) \neq \TInt
  }{%
    \checknoprecisionloss(\vt) \typearrow \True
  }
\end{mathpar}

\CodeSubsection{\CheckNoPrecisionLossBegin}{\CheckNoPreciisonLossEnd}{../Typing.ml}

\TypingRuleDef{CheckCanBeInitializedWith}
\RenderRelation{check_can_be_initialized_with}
\BackupOriginalRelation{
The function
\[
\checkcanbeinitializedwith(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vs} \aslsep \overname{\ty}{\vt})
\typearrow \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether an expression of type $\vs$ can be used to initialize a storage element of type $\vt$ in the \staticenvironmentterm{}
$\tenv$.
If the answer if $\False$, the result is a \typingerrorterm.
} % END_OF_BACKUP_RELATION

See \ExampleRef{Type-satisfaction Examples}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item testing whether $\vt$ \typesatisfiesterm\ $\vs$ in $\tenv$ yields $\True$;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item testing whether $\vt$ \typesatisfiesterm\ $\vs$ in $\tenv$ yields $\False$;
    \item the result is a \typingerrorterm{} indicating that an expression of type $\vs$ cannot
          be used to initialize a storage element of type $\vt$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \typesatisfies(\tenv, \vt, \vs) \typearrow \True
}{
  \checkcanbeinitializedwith(\tenv, \vs, \vt) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \typesatisfies(\tenv, \vt, \vs) \typearrow \False
}{
  \checkcanbeinitializedwith(\tenv, \vs, \vt) \typearrow \TypeErrorVal{\TypeSatisfactionFailure}
}
\end{mathpar}
\identr{ZCVD}  \identr{LXQZ}


\subsection{Semantics}
\SemanticsRuleDef{SDeclSome}
\ExampleDef{Declaration With an Initializing Value}
In \listingref{semantics-sdeclsome},
\texttt{let x = 3;} binds \texttt{x} to $\nvint(3)$ in the empty environment.
\ASLListing{Evaluating a declaration with a given initial value}{semantics-sdeclsome}{\semanticstests/SemanticsRule.SDeclSome.asl}

\ExampleDef{Declaration Without an Initializing Value}
In \listingref{semantics-sdeclnone},
\texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.
\ASLListing{Evaluating a declaration without a given initial value}{semantics-sdeclnone}{\semanticstests/SemanticsRule.SDeclNone.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a declaration with an initial value,
          $\SDecl(\Ignore, \ldi, \Ignore, \some{\ve})$;
    \item evaluating $\ve$ in $\env$ is $\ResultExpr(\vm, \envone)$\ProseOrAbnormal;
    \item evaluating the local declaration $\ldi$ with $\vm$ as the initializing
          value in $\envone$ as per \chapref{LocalStorageDeclarations} is
          $\ResultLexpr(\newg, \newenv)$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a declaration without an initial value, $\SDecl(\Ignore, \ldi, \Ignore, \None)$;
    \item the result is a \DynamicErrorConfigurationTerm{}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[some]{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr(\vm, \envone) \OrAbnormal\\
  \evallocaldecl(\envone, \ldi, \vm) \evalarrow \ResultLexpr(\newg, \newenv)\\
}{
  \evalstmt(\env, \SDecl(\Ignore, \ldi, \Ignore, \some{\ve})) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[none]{}{
  \evalstmt(\env, \SDecl(\Ignore, \ldi, \Ignore, \None)) \evalarrow \DynamicErrorVal{UninitialisedDecl}
}
\end{mathpar}
\CodeSubsection{\EvalSDeclBegin}{\EvalSDeclEnd}{../Interpreter.ml}

\section{Declaration Statements with an Elided Parameter\label{sec:DeclarationStatementsElidedParameter}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \
   & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \Nasty \parsesep \Teq \\
   & \wrappedline\ \Nelidedparamcall \parsesep \Tsemicolon &\\
\end{flalign*}

\begin{flalign*}
\Nelidedparamcall \derives \
     & \Tidentifier \parsesep \Tlbrace \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Trbrace \parsesep \PlistZero{\Nexpr} &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Tcomma \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Tcomma \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace \parsesep \PlistZero{\Nexpr}&
\end{flalign*}

\SyntacticSugarDef{ParameterElision}
In a call to a parameterized subprogram, a parameter can be elided,
if it can be inferred from the left-hand-side type annotation,
as detailed by \ASTRuleRef{ElidedParamCall} (See also \secref{ParameterElision}).

\ASTRuleDef{ElidedParamCall}
\hypertarget{build-elided-param-call}{}
The function $\buildelidedparamcall$ builds a $\call$ from a parsed \\
$\Nelidedparamcall$.

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlpar, \Trpar))
  \astarrow \vastnode
}{
  \buildelidedparamcall(\Nelidedparamcall (\Tidentifier(\id), \Tlbrace, \Trbrace))
  \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \vargs))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
      \buildelidedparamcall(\Nelidedparamcall \\
        \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}}))
      \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlbrace, \vparams, \Trbrace))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
      \buildelidedparamcall(\Nelidedparamcall \\
        \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Tcomma, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace))
        \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlbrace, \vparams, \Trbrace, \vargs))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
    \buildelidedparamcall (\Nelidedparamcall \\
      \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Tcomma, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}}))
      \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarElidedParameter}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-desugarelidedparameter}{}
The function
\[
\desugarelidedparameter(
  \overname{\ty}{\vt} \aslsep
  \overname{\call}{\vcall})
\aslto
\overname{\Option{\expr}}{\vexpr}
\cup\ \overname{\TBuildError}{\ParseErrorConfig}
\]
builds an expression $\vexpr$ from an assignment of the call $\vcall$ to the left-hand side with type annotation $\vt$, where the call has an elided parameter.
Otherwise, the result is a parse error.
} % END_OF_IGNORED_RELATION


\ExampleDef{Desugaring Parameter Elision Based on Declared Type Annotation}
\listingref{DesugarElidedParameter} shows examples of how parameters can be elided
if they can be copied from the type annotation in declaration statements.
\ASLListing{Desugaring parameter elision based on declared type annotation}{DesugarElidedParameter}{\syntaxtests/ASTRule.DesugarElidedParameter.asl}

\begin{mathpar}
\inferrule{
  \becheck(\vt = \TBits(\Ignore, \Ignore), \ParseError) \typearrow \True \;\terminateas \ParseErrorConfig \\
  \vt \eqname \TBits(\ve, \Ignore) \\
  \vcallp \eqdef \vcall[\callparams\mapsto [\ve] \concat \vcall.\callparams ]
}{
  \desugarelidedparameter(\ldk, \ldi, \vt, \vcall)
  \astarrow
  \some{\ECall(\vcallp)}
}
\end{mathpar}

\ASTRuleDef{ElidedParamDecl}
\begin{mathpar}
\inferrule{
  \buildelidedparamcall (\vcall) \astarrow \astversion{\vcall} \\
  \desugarelidedparameter(\astof{\vasty}, \astversion{\vcall}) \astarrow \vexpr
}{
  {
    \begin{array}{r}
    \buildstmt\left(
      \Nstmt\left(
        \begin{array}{l}
          \punnode{\Nlocaldeclkeyword}, \\
          \wrappedline\ \punnode{\Ndeclitem}, \punnode{\Nasty}, \Teq, \\
          \wrappedline\ \namednode{\vcall}{\Nelidedparamcall}, \Tsemicolon
        \end{array}
      \right)
    \right) \astarrow \\ \overname{\SDecl(\astof{\vlocaldeclkeyword}, \astof{\vdeclitem}, \some{\vasty}, \vexpr)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing and semantics}
As given by the applying the relevant rules to the desugared AST (see \secref{DeclarationStatements}).

\section{Sequencing Statements\label{sec:SequencingStatement}}
\hypertarget{def-sequencestatementterm}{}

\ASLListing{A sequence of statements}{semantics-sseq}{\semanticstests/SemanticsRule.SSeq.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmtlist \derives \ & \ListOne{\Nstmt} &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_seq}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SSeq(\stmt, \stmt) &
\end{flalign*}
}

\ASTRuleDef{StmtList}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-stmtlist}{}
The function
\[
  \buildstmtlist(\overname{\parsenode{\Nstmtlist}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildlist[\Nstmt](\vstmts) \astarrow \vstmtlist\\
  \stmtfromlist(\vstmtlist) \astarrow \vastnode
}{
  \buildstmtlist(\Nstmtlist(\namednode{\vstmts}{\ListOne{\Nstmt}})) \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{StmtFromList}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-stmtfromlist}{}
The function
\[
\stmtfromlist(\overname{\KleeneStar{\stmt}}{\vstmts}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from a possibly-empty list of statements $\vstmts$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[empty]{
}{
  \stmtfromlist(\overname{\emptylist}{\vstmts}) \astarrow \overname{\SPass}{\news}
}
\and
\inferrule[non\_empty]{
  \stmtfromlist(\vstmtsone) \astarrow \vsone\\
  \sequencestmts(\vs, \vsone) \astarrow \news
}{
  \stmtfromlist(\overname{[\vs] \concat \vstmtsone}{\vstmts}) \astarrow \news
}
\end{mathpar}

\ASTRuleDef{SequenceStmts}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-sequencestmts}{}
The function
\[
\sequencestmts(\overname{\stmt}{\vsone}, \overname{\stmt}{\vstwo}) \aslto \overname{\stmt}{\news}
\]
Combines the statement $\vsone$ with $\vstwo$ into the statement $\news$, while filtering away
instances of $\SPass$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[s1\_spass]{}{
  \sequencestmts(\overname{\SPass}{\vsone}, \vstwo) \astarrow \overname{\vstwo}{\news}
}
\and
\inferrule[s2\_spass]{
  \vsone \neq \SPass
}{
  \sequencestmts(\vsone, \overname{\SPass}{\vstwo}) \astarrow \overname{\vsone}{\news}
}
\and
\inferrule[no\_spass]{
  \vsone \neq \SPass\\
  \vstwo \neq \SPass
}{
  \sequencestmts(\vsone, \vstwo) \astarrow \overname{\SSeq(\vsone, \vstwo)}{\news}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SSeq}
\ExampleDef{Typing Sequencing Statements}
In \listingref{semantics-sseq}, the statement \verb|let x=3;| is
annotated first in the \staticenvironmentterm{} where the \localstaticenvironmentterm{} is empty.
Then, the statement \verb|let y = x + 1;|
is annotated in the \staticenvironmentterm{} where
\verb|x| has been declared and associated with the type \verb|integer{3}|,
and also recorded to be equivalent to $\LInt(3)$ (in the $\exprequiv$ map).

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is the AST node for the sequence of statements $\vsone$ and $\vstwo$, that is, $\SSeq(\vsone, \vstwo)$;
  \item annotating $\vsone$ in $\tenv$ yields $(\newsone, \tenvone, \vsesone)$\ProseOrTypeError;
  \item annotating $\vstwo$ in $\tenvone$ yields $(\newstwo, \newtenv, \vsestwo)$\ProseOrTypeError;
  \item $\news$ is the AST node for the sequence of statements $\newsone$ and $\newstwo$, that is, $\SSeq(\newsone, \newstwo)$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesone$ and $\vsestwo$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatestmt(\tenv, \vs1) \typearrow (\newsone, \tenvone, \vsesone) \OrTypeError\\\\
  \annotatestmt(\tenvone, \vs2) \typearrow (\newstwo, \newtenv, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotatestmt(\tenv, \overname{\SSeq(\vsone, \vstwo)}{\vs}) \typearrow (\overname{\SSeq(\newsone, \newstwo)}{\news}, \newtenv, \vses)
}
\end{mathpar}
\CodeSubsection{\SSeqBegin}{\SSeqEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SSeq}
\ExampleDef{Evaluation of Sequencing Statements}
In \listingref{semantics-sseq},
the evaluation of \texttt{let x = 3; let y = x + 1} first evaluates \texttt{let x = 3} and only then
evaluates \texttt{let y = x + 1}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \sequencingstatementterm{} \texttt{s1; s2}, that is, $\SSeq(\vsone, \vstwo)$;
  \item evaluating $\vsone$ in $\env$ is either $\Continuing(\vgone, \envone)$ in which case
        the evaluation continues,
        or a returning configuration ($\Returning((\vvs, \newg), \newenv)$)
        or an abnormal configuration, which short-circuit the entire evaluation;
  \item evaluating $\vstwo$ in $\envone$ yields a non-abnormal configuration \\
        (either $\Returning$ or $\Continuing$) $C$\ProseOrAbnormal;
  \item $\newg$ is the ordered composition of $\vgone$ and the execution graph of $C$ with the
        $\aslpo$ edge;
  \item $D$ is the configuration $C$ with the execution graph component replaced with $\newg$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalstmt(\env, \vsone) \evalarrow \Continuing(\vgone, \envone) \OrAbnormal,\ReturningConfig\\\\
  \evalstmt(\envone, \vstwo) \evalarrow C \OrAbnormal\\\\
  \newg \eqdef \ordered{\vgone}{\aslpo}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\newg}
}{
  \evalstmt(\env, \SSeq(\vsone, \vstwo)) \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSSeqBegin}{\EvalSSeqEnd}{../Interpreter.ml}

\section{Call Statements\label{sec:CallStatements}}
\hypertarget{def-callstatementterm}{}
Call statements are used to invoke procedures and setters.

\ASLListing{Call Statements}{scall}{\semanticstests/SemanticsRule.SCall.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Ncall \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_call}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SCall(\call) &
\end{flalign*}
}

\ASTRuleDef{SCall}
\begin{mathpar}
\inferrule{
  \buildcall(\vcall) \astarrow \astversion{\vcall} \\
  \setcalltype(\astversion{\vcall}) \aslto \vcallp
}{
  \buildstmt(
  \overname{\Nstmt(\namednode{\vcall}{\Ncall}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SCall(\vcallp)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SCall}
The call statement \verb|catenate_into_g{4, 3}(x, y, TRUE);|
in \listingref{scall} is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a call to a subprogram, that is, $\SCall(\vcall)$;
  \item annotating the subprogram call $\vcall$ as per \chapref{SubprogramCalls}
        yields \\
        $(\vcallp, \None, \vses)$\ProseOrTypeError;
  \item $\news$ is the call using $\vcallp$, that is, $\SCall(\vcallp)$;
  \item $\newtenv$ is $\tenv$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \begin{array}{r}
      \annotatecall(\vcall) \typearrow (\vcallp, \None, \vses) \OrTypeError
    \end{array}
  }
}{
  {
    \begin{array}{r}
  \annotatestmt(\tenv, \overname{\SCall(\vcall)}{\vs}) \typearrow
  (\overname{\SCall(\vcallp)}{\news}, \tenv, \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SCallBegin}{\SCallEnd}{../Typing.ml}
\identd{VXKM}

\subsection{Semantics}
\SemanticsRuleDef{SCall}
\ExampleDef{Evaluation of Call Statements}
The call statement \verb|catenate_into_g{4, 3}(x, y, TRUE);|
assigns the global variable \verb|g| to \verb|'1101 111'|.

A call statement \verb|zero();| is ill-typed, since call statements
can only be used for procedures, not functions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a call statement, $\SCall(\vcall)$;
  \item evaluating the subprogram call as per \chapref{SubprogramCalls} is
  \\ $\ResultCall(\newg, \newenv)$\ProseOrAbnormal;
  \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
{
\begin{array}{r}
  \evalcall(\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs) \evalarrow \\
  \ResultCall(\newg, \newenv) \OrAbnormal
\end{array}
}
}{
  \evalstmt(\env, \overname{\SCall(\vcall)}{\vs}) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSCallBegin}{\EvalSCallEnd}{../Interpreter.ml}
\identd{KCYT}

\hypertarget{def-conditionalstatementterm}{}
\section{Conditional Statements\label{sec:ConditionalStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nstmtlist \parsesep \Nselse \parsesep \Tend \parsesep \Tsemicolon &\\
\Nselse \derives\ & \Telseif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nstmtlist \parsesep \Nselse &\\
        |\ & \Telse \parsesep \Nstmtlist &\\
        |\ & \emptysentence &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_cond}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SCond(\expr, \stmt, \stmt)
\end{flalign*}
}

\ASTRuleDef{SCond}
\begin{mathpar}
\inferrule{}{
  {
    \begin{array}{r}
  \buildstmt(\overname{\Nstmt(\Tif, \punnode{\Nexpr}, \Tthen, \punnode{\Nstmtlist}, \punnode{\Nselse}, \Tend, \Tsemicolon)}{\vparsednode})
  \astarrow \\
  \overname{\SCond(\astof{\vexpr}, \astof{\vstmtlist}, \astof{\velse})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{SElse}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-selse}{}
The function
\[
  \buildselse(\overname{\parsenode{\Nselse}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[elseif]{}{
  {
    \begin{array}{r}
  \buildselse(\Nselse(\Telseif, \Nexpr, \Twhen, \Nstmtlist, \Nselse)) \astarrow \\
  \overname{\SCond(\astof{\vexpr}, \astof{\vstmtlist}, \astof{\vselse})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pass]{}{
  \buildselse(\Nselse(\emptysentence)) \astarrow \overname{\SPass}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[else]{}{
  \buildselse(\Nselse(\Telse, \punnode{\Nstmtlist})) \astarrow \overname{\astof{\vstmtlist}}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SCond}
The specifications in \listingref{semantics-scond},
\listingref{semantics-scond2},
\listingref{semantics-scond3}, and
\listingref{semantics-scond4} are all well-typed.

\ExampleDef{Typing Conditional Statements with Two Bitvector Types}
The specification in \listingref{SCond} is well-typed
and shows examples of how \bitvectortypesterm{} either \typesatisfyterm{}
the return type or do not \typesatisfyterm{} the return type and require
an \atcexpressionterm{}.
\ASLListing{Typing conditional statements with two bitvector types}{SCond}{\typingtests/TypingRule.SCond.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a condition $\ve$ with the statements $\vsone$ and $\vstwo$, that is, $\SCond(\ve, \vsone, \vstwo)$;
  \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields \\
        $(\tcond, \econd, \vsescond)$\ProseOrTypeError;
  \item checking that $\tcond$ \typesatisfiesterm\ $\TBool$ yields $\True$\ProseOrTypeError;
  \item annotating the statement $\vsone$ in $\tenv$ yields $(\vsonep, \vsesone)$\ProseOrTypeError;
  \item annotating the statement $\vstwo$ in $\tenv$ yields $(\vstwop, \vsestwo)$\ProseOrTypeError;
  \item $\news$ is the condition $\econd$ with the statements $\vsonep$ and $\vstwop$, that is, \\ $\SCond(\econd, \vsonep, \vstwop)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsescond$, $\vsesone$, and $\vsestwo$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ve) \typearrow (\tcond, \econd, \vsescond) \OrTypeError\\\\
  \checktypesat(\tenv, \tcond, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock(\tenv, \vsone) \typearrow (\vsonep, \vsesone) \OrTypeError\\\\
  \annotateblock(\tenv, \vstwo) \typearrow (\vstwop, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsescond \cup \vsesone \cup \vsestwo
}{
  \annotatestmt(\tenv, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \typearrow
  (\overname{\SCond(\econd, \vsonep, \vstwop)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\CodeSubsection{\SCondBegin}{\SCondEnd}{../Typing.ml}
\identr{NBDJ}

\subsection{Semantics}
\SemanticsRuleDef{SCond}
\ExampleDef{Conditional Statements}
The specification in \listingref{semantics-scond} does not result in any Assertion Error.
\ASLListing{Evaluating a conditional statement}{semantics-scond}{\semanticstests/SemanticsRule.SCond.asl}

The specification in \listingref{semantics-scond2}
does not result in any error.
\ASLListing{Evaluating a condition statement with \texttt{elsif}}{semantics-scond2}{\semanticstests/SemanticsRule.SCond2.asl}

The specification in \listingref{semantics-scond3}
results in an Assertion Error.
\ASLListing{Evaluating a condition statement that results in an Assertion Error}{semantics-scond3}{\semanticstests/SemanticsRule.SCond3.asl}

The specification in \listingref{semantics-scond4} does not result in any error.
\ASLListing{Evaluating a condition statement with only a \texttt{then} branch}{semantics-scond4}{\semanticstests/SemanticsRule.SCond4.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vs$ is a condition statement, $\SCond(\ve, \vsone, \vstwo)$;
\item evaluating $\ve$ in $\env$ yields $\ResultExpr((\vv, \vgone), \envone)$\ProseOrAbnormal;
\item $\vv$ is a native Boolean for $\vb$;
\item the statement $\vsp$ is $\vsone$ is $\vb$ is $\True$ and $\vstwo$ otherwise
      (so that $\vsone$ will be evaluated if the condition evaluates to $\True$ and otherwise
      $\vstwo$ will be evaluated);
\item evaluating $\vsp$ in $\envone$ as per \chapref{BlockStatements} is a non-abnormal configuration
      (either $\Returning$ or $\Continuing$) $C$\ProseOrAbnormal;
\item $\vg$ is the ordered composition of $\vgone$ and the execution graph of the configuration $C$;
\item $D$ is the configuration $C$ with the execution graph component updated to be $\vg$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \vgone), \envone) \OrAbnormal\\\\
  \vv \eqname \nvbool(\vb)\\
  \vsp \eqdef \choice{\vb}{\vsone}{\vstwo}\\
  \evalblock(\envone, \vsp) \evalarrow C \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\aslctrl}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\vg}
}{
  \evalstmt(\env, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSCondBegin}{\EvalSCondEnd}{../Interpreter.ml}

\hypertarget{def-casestatementterm}{}
\section{Case Statements\label{sec:CaseStatements}}
Case statements allow executing different statements, based on which
condition an expression satisfies.

\listingref{case-discriminant} shows an example of a \casestatementterm{}
and the output to a console when it is evaluated.

\ASLListing{A side-effecting case discriminant}{case-discriminant}{\definitiontests/CaseStatement.discriminant.asl}
% CONSOLE_BEGIN aslref \definitiontests/CaseStatement.discriminant.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
num_tests: 0
selected case 2
\end{Verbatim}
% CONSOLE_END
\listingref{case-discriminant} shows an example of a \casestatementterm{}
and the output to a console when it is evaluated.

\hypertarget{def-casediscriminantterm}{}
\hypertarget{def-casealternativeterm}{}
\hypertarget{def-otherwisecaseterm}{}
The expression following the \Tcase\ keyword is called the \emph{\casediscriminantterm}.
The list following the \Tof\ keyword consists of \emph{\casealternativesterm},
optionally ending with an \emph{\otherwisecaseterm}, which follows the \Totherwise\ keyword.

Case statements obey the following requirements:

\RequirementDef{CaseDiscriminant} The \casediscriminantterm\ of a \texttt{case}
statement should be evaluated only once each time the case statement is evaluated.
%
\listingref{case-discriminant} demonstrates how the \casediscriminantterm{}
is evaluated only once.

\RequirementDef{CaseAlternatives} The \casealternativesterm\ are examined
one after another, in the order they are listed.
If any of the patterns match the \casediscriminantterm{} (and the guard
expression is true, if present) then this \casealternativeterm{} is considered selected,
its statement list is executed, and the \texttt{case} statement ends without examining any further
\casealternativesterm.
%
\listingref{case-discriminant} demonstrates how only one \casealternativeterm{} is selected
for execution.

\RequirementDef{CaseDiscriminantTesting} Testing the \casediscriminantterm{} against a \\
pattern list
follows the semantics of pattern matching defined in \chapref{PatternMatching}.
It is not a static error if it can be statically determined that none of the patterns in a
\casealternativeterm\ can match the discriminant.
%
\listingref{case-discriminant} exemplifies a \casestatementterm{} with pattern matching.

\RequirementDef{CaseOtherwise} If no \casealternativeterm\ is selected, and there is an
\otherwisecaseterm\, the \otherwisecaseterm\ is executed.
%
\listingref{case-otherwise} demonstrates how the \otherwisecaseterm{} is evaluated.

\ASLListing{Executing the \texttt{otherwise} case alternative}{case-otherwise}{\definitiontests/CaseStatement.otherwise.asl}
% CONSOLE_BEGIN aslref \definitiontests/CaseStatement.otherwise.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
num_tests: 0
selected otherwise
\end{Verbatim}
% CONSOLE_END

\RequirementDef{CaseNoOtherwiseError} If no \casealternativeterm\ is selected,
and there is no \otherwisecaseterm, it is a \dynamicerrorterm{}.
%
\listingref{case-no-otherwise} shows a specification that, when evaluated,
yields a \dynamicerrorterm{}.

\ASLListing{A case statement with no \texttt{otherwise} case}{case-no-otherwise}{\definitiontests/CaseStatement.no_otherwise.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tcase \parsesep \Nexpr \parsesep \Tof \parsesep \Ncasealtlist \parsesep \Tend \parsesep \Tsemicolon &\\
|\ & \Tcase \parsesep \Nexpr \parsesep \Tof \parsesep \Ncasealtlist \parsesep \Totherwise \parsesep \Tarrow &\\
   & \wrappedline\ \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Ncasealtlist \derives \ & \ClistOne{\Ncasealt} \parsesep &\\
\Ncasealt \derives \ & \Twhen \parsesep \Npatternlist \parsesep \option{\Twhere \parsesep \Nexpr} \parsesep \Tarrow \parsesep \Nstmtlist &\\
\end{flalign*}

\listingref{CaseStatement-bad} shows an example of an erroneous case statement
where a \casealternativeterm{} is missing a statement.
\ASLListing{Invalid case statement syntax}{CaseStatement-bad}{\syntaxtests/CaseStatement.bad.asl}

\subsection{Abstract Syntax}

\SyntacticSugarDef{CaseStatement}
Case statements are considered \\ \syntacticsugar{}.
That is, there is no explicit representation for \texttt{case} statements
as they are represented in AST via a \conditionalstatementterm.
Case statements are \desugared{} by \ASTRuleRef{DesugarCaseStmt}.

\ExampleDef{Case Statement Desugaring}
\listingref{ast-case1} shows an example of how a \texttt{case} statement can be transformed into a corresponding
compound condition statement.
\ASLListing{Transforming a case statement with a variable as the case discriminant}{ast-case1}{\syntaxtests/ASTRule.Desugar_SCase1.asl}

\listingref{ast-case2} shows an example of how a \texttt{case} statement can be transformed into
a statement that does not contain any \text{case} statement.
By storing the \casediscriminantterm\ in a variable and by adding
an \unreachablestatementterm{}, the transformation ensures that a \dynamicerrorterm{} occurs when no
\casealternativeterm\ is selected.
\ASLListing{Transforming a case statement with a non-variable as the case discriminant
and no otherwise case}{ast-case2}{\syntaxtests/ASTRule.Desugar_SCase2.asl}

The untyped AST contains non-terminals for \casealternativesterm, which exist
only as a data type used by $\desugarcasestmt$ and do not later appear in the untyped
AST:

\RenderType[remove_hypertargets]{case_alt}

\ASTRuleDef{SCase}
To satisfy \RequirementRef{CaseNoOtherwiseError}, when no \otherwisecaseterm\ exists,
$\SUnreachable$ is used instead:
\begin{mathpar}
\inferrule[no\_otherwise]{
  \buildlist[\buildcasealt](\vcasealtlist) \astarrow \vcasealtlistast\\
  \buildexpr(\vediscriminant) \astarrow \astversion{\vediscriminant}\\
  {
  \begin{array}{r}
  \desugarcasestmt(\astversion{\vediscriminant}, \vcasealtlistast, \SUnreachable) \astarrow \\
  \vastnode
  \end{array}
  }
}{
  {
  \buildstmt\left(\overname{
    \Nstmt\left(
      \begin{array}{l}
        \Tcase, \namednode{\vediscriminant}{\Nexpr}, \Tof, \\
        \wrappedline\ \namednode{\vcasealtlist}{\Ncasealtlist}, \\
        \wrappedline\ \Tend, \Tsemicolon
      \end{array}
    \right)
    }{\vparsednode}\right)
  \astarrow
  \vastnode
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise]{
  \buildlist[\buildcasealt](\vcasealtlist) \astarrow \vcasealtlistast\\
  \buildexpr(\vediscriminant) \astarrow \astversion{\vediscriminant}\\
  \buildstmtlist(\votherwise) \astarrow \astversion{\votherwise}\\
  {
  \begin{array}{r}
  \desugarcasestmt(\astversion{\vediscriminant}, \vcasealtlistast, \astversion{\votherwise}) \astarrow \\
  \vastnode
  \end{array}
  }
}{
  {
  \buildstmt\left(\overname{
    \Nstmt\left(
      \begin{array}{l}
        \Tcase, \namednode{\vediscriminant}{\Nexpr}, \Tof, \\
        \wrappedline\ \namednode{\vcasealtlist}{\Ncasealtlist}, \\
        \wrappedline\ \Totherwise, \Tarrow, \namednode{\votherwise}{\Nstmtlist}, \\
        \wrappedline\ \Tend, \Tsemicolon
      \end{array}
    \right)
    }{\vparsednode}\right)
  \astarrow
  \vastnode
  }
}
\end{mathpar}

\ASTRuleDef{CaseAltList}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-casealtlist}{}
The function
\[
\buildcasealtlist(\overname{\parsenode{\Ncasealtlist}}{\vparsednode}) \;\aslto\; \overname{\KleenePlus{\casealt}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildclist[\buildcasealt](\vcases) \typearrow \vastnode
}{
  \buildcasealtlist(\overname{\Ncasealtlist(\vcases : \ClistOne{\Ncasealt})}{\vparsednode}) \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{CaseAlt}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-casealt}{}
The function
\[
\buildcasealt(\overname{\parsenode{\Ncasealt}}{\vparsednode}) \;\aslto\; \overname{\casealt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildoption[\buildexpr](\vwhereopt) \astarrow \vwhereast
}{
  {
    \begin{array}{r}
  \buildcasealt\left(\overname{\Ncasealt\left(
    \begin{array}{l}
    \Twhen, \punnode{\Npatternlist}, \\
    \wrappedline\ \namednode{\vwhereopt}{\option{\Twhere, \Nexpr}}, \Tarrow, \\
    \wrappedline\ \namednode{\vstmts}{\Nstmtlist}
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{\casealt(\CasePattern: \astof{\vpatternlist}, \CaseWhere: \vwhereast, \CaseStmt: \astof{\vstmtlist})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarCaseStmt}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-desugarcasestmt}{}
The relation
\[
\desugarcasestmt(
  \overname{\expr}{\vezero},
  \overname{\KleeneStar{\casealt}}{\vcases},
  \overname{\stmt}{\votherwise}) \;\aslrel\; \overname{\stmt}{\news}
\]
transforms a \casediscriminantterm\ $\vezero$, a list of \casealternativesterm\ $\vcases$,
and a statement $\votherwise$ into a statement $\news$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[var]{
  \astlabel(\vezero) = \EVar\\
  \casestocond(\vezero, \vcases, \votherwise) \typearrow \news
}{
  \desugarcasestmt(\vezero, \vcases, \votherwise) \astarrow \news
}
\end{mathpar}

To satisfy \RequirementRef{CaseDiscriminant}, the transformation assigns the
\casediscriminantterm\ to a temporary variable, which is then used in a
compound conditional statement (see \listingref{ast-case2} for an example):
\begin{mathpar}
\inferrule[non\_var]{
  \astlabel(\vezero) \neq \EVar\\
  \vx \in \Identifier \text{ is fresh}\\
  \vdeclx \eqname \SDecl(\LDKLet, \LDIVar(\vx), \None, \some{\vezero})\\
  \casestocond(\EVar(\vx), \vcases, \votherwise) \typearrow \vscond
}{
  \desugarcasestmt(\vezero, \vcases, \votherwise) \astarrow \overname{\SSeq(\vdeclx, \vscond)}{\news}
}
\end{mathpar}
\CodeSubsection{\DesugarCaseStmtBegin}{\DesugarCaseStmtEnd}{../desugar.ml}

\ASTRuleDef{CasesToCond}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-casestocond}{}
The function
\[
\casestocond(
  \overname{\expr}{\ve} \aslsep
  \overname{\KleeneStar{\casealt}}{\vcases} \aslsep
  \overname{\stmt}{\votherwise})
\;\aslrel\; \overname{\stmt}{\news}
\]
transforms an expression $\ve$, a list of \texttt{case} alternatives $\vcases$,
and a statement $\votherwise$
into a statement $\news$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[last]{
  \casetocond(\ve, \vcase, \votherwise) \astarrow \news
}{
  \casestocond(\ve, \overname{[\vcase]}{\vcases}, \votherwise) \astarrow \news
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_last]{
  \vcasesone \neq \emptylist\\
  \casestocond(\ve, \vcasesone) \typearrow \vsone\\
  \casetocond(\ve, \vcase, \vsone) \typearrow \news
}{
  \casestocond(\ve, \overname{[\vcase] \concat \vcasesone}{\vcases}, \votherwise) \astarrow \news
}
\end{mathpar}
\CodeSubsection{\CasesToCondBegin}{\CasesToCondEnd}{../desugar.ml}

\ASTRuleDef{CaseToCond}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-casetocond}{}
The function
\[
\casetocond(\overname{\expr}{\vezero} \aslsep \overname{\casealt}{\vcase} \aslsep \overname{\stmt}{\vtail})
\;\aslrel\; \overname{\stmt}{\news}
\]
transforms an expression $\vezero$ (the condition used for a \texttt{case} statement),
a single \texttt{case} alternative $\vcase$, and a statement $\vtail$, which represents
a list of \texttt{case} alternatives already converted to conditionals, into a condition statement $\news$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \vcase \eqname \{ \CasePattern : \vpattern, \CaseWhere : \vwhere, \CaseStmt : \vstmt \}\\
  \vepattern \eqdef \EPattern(\vezero, \vpattern)\\
  \vcond \eqdef \choice{\vwhere = \some{\vewhere}}{\EBinop(\BAND, \vepattern, \vewhere)}{\vepattern}
}{
  \casetocond(\vezero, \vcase, \vtail) \astarrow \overname{\SCond(\vcond, \vstmt, \vtail)}{\news}
}
\end{mathpar}
\CodeSubsection{\CaseToCondBegin}{\CaseToCondEnd}{../desugar.ml}

\subsection{Typing}
Since case statements are transformed into other statements,
they do not require type system rules.
\identr{WGSY}

\subsection{Semantics}
Since case statements are transformed into other statements,
they do not appear in the typed AST and thus are not associated with a semantics.

In \listingref{CaseStatement.where} the expression \verb|a| will be evaluated twice.
\ASLListing{Evaluating case alternative sub-expressions}{CaseStatement.where}{\definitiontests/CaseStatement.where.asl}

\hypertarget{def-assertionstatementterm}{}
\section{Assertion Statements\label{sec:AssertionStatements}}
Assertion statements are used to check that certain conditions are satisfied.
They take a single \booleantypeterm{} operand, which we refer to as the
\emph{condition}. If the condition is \False, the statement fails with a
\dynamicerrorterm{} (\errorcodeterm{} $\DynamicAssertionFailure$).

\listingref{AssertionStatement} shows a possible use of
\assertionstatementterm{} to check the inputs to a function
(also known as a \emph{precondition})
and ensure the output satisfies expectations (also known as a \emph{postcondition}).
%
The first call to \verb|checked_8bit_add| succeeds, whereas the second call fails the
\assertionstatementterm{} \verb|assert a + b < 256;|

\ASLListing{Example of using \texttt{assert} statements}{AssertionStatement}{\definitiontests/AssertionStatement.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tassert \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_assert}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SAssert(\expr) &
\end{flalign*}
}

\ASTRuleDef{SAssert}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tassert, \Nexpr, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SAssert(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SAssert}
\ExampleDef{Type Assertion Statements}
The specifications in \listingref{semantics-sasertok} and \listingref{semantics-sassertno}
are well-typed.

The assertion statements in \listingref{assert-ill-typed} are ill-typed,
since the expression needs to be both of a \booleantypeterm{} and \readonlyterm{}.
\ASLListing{Ill-typed assertion statements}{assert-ill-typed}{\typingtests/TypingRule.SAssert.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assert statement with expression $\ve$, that is, $\SAssert(\ve)$;
  \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields $(\tep,\vep, \vsese)$\ProseOrTypeError;
  \item checking that $\vsese$ is \readonlyterm{} via $\sesisreadonly$ yields $\True$\ProseOrTypeError;
  \item checking that $\vtep$ \typesatisfiesterm\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is an assert statement with expression $\vep$, that is, $\SAssert(\vep)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{$\vsese$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ve) \typearrow (\vtep, \vep, \vsese) \OrTypeError\\\\
  \techeck(\sesisreadonly(\vsese) \typearrow \True, \SideEffectViolation) \typearrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vtep, \TBool) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsese
  }{
  \annotatestmt(\tenv, \overname{\SAssert(\ve)}{\vs}) \typearrow (\overname{\SAssert(\vep)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SAssertBegin}{\SAssertEnd}{../Typing.ml}
\identr{JQYF}

\subsection{Semantics}
\SemanticsRuleDef{SAssert}
\ExampleDef{Evaluation of Assertions: Success}
In \listingref{semantics-sasertok},
\texttt{assert (42 != 3);} ensures that \texttt{3} is not equal to \texttt{42}.
\ASLListing{Evaluating an assertion that succeeds}{semantics-sasertok}{\semanticstests/SemanticsRule.SAssertOk.asl}

\ExampleDef{Evaluation of Assertions: Failure}
In \listingref{semantics-sassertno},
evaluating \texttt{assert (42 == 3);} results in an \DynamicAssertionFailure{} error.
\ASLListing{Evaluating an assertion that fails}{semantics-sassertno}{\semanticstests/SemanticsRule.SAssertNo.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assertion statement, $\SAssert(\ve)$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{okay}
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ is $\ResultExpr((\vv, \newg), \newenv)$\ProseOrAbnormal;
      \item $\vv$ is a native Boolean value for $\True$;
      \item the resulting configuration is $\Continuing(\newg, \newenv)$.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ is $\ResultExpr((\vv, \newg), \newenv)$;
      \item $\vv$ is a native Boolean value for $\False$;
      \item the result is a \DynamicErrorConfigurationTerm{} indicating the assertion failure returned (\DynamicAssertionFailure).
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \newg), \newenv) \OrAbnormal\\\\
  \vv \eqname \nvbool(\True)
}{
  \evalstmt(\env, \SAssert(\ve)) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
  \inferrule[error]{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \Ignore), \Ignore)\\
  \vv \eqname \nvbool(\False)
}{
  \evalstmt(\env, \SAssert(\ve)) \evalarrow \DynamicErrorVal{\DynamicAssertionFailure}
}
\end{mathpar}
\CodeSubsection{\EvalSAssertBegin}{\EvalSAssertEnd}{../Interpreter.ml}
\identd{QJYV} \identr{WZSL} \identr{WQRN}

\section{While Statements\label{sec:WhileStatements}}
\hypertarget{def-whilestatementterm}{}

\ASLListing{A \texttt{while} statement}{semantics-swhile}{\semanticstests/SemanticsRule.SWhile.asl}

\ConventionDef{Loop Limits}
Conventionally, all loop kinds should specify a limit expression.
For example, the loops in \listingref{semantics-swhile} specifies a limit via
the expression \verb|limit_loop()|.

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Twhile \parsesep \Nexpr \parsesep \Nlooplimit \parsesep \Tdo \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_while}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SWhile(\overtext{\expr}{condition}, \overtext{\expr?}{loop limit}, \overtext{\stmt}{loop body}) &
\end{flalign*}
}

\ASTRuleDef{SWhile}
\begin{mathpar}
\inferrule{
  \buildexpr(\vlimitexpr) \astarrow \astversion{\vlimitexpr}\\
  \buildlooplimit(\voptlimit) \astarrow \astversion{\voptlimit}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Twhile, \econd: \Nexpr, \voptlimit : \Nlooplimit, \Tdo, \\
    \wrappedline\ \punnode{\Nstmtlist}, \Tend, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow\\
  \overname{\SWhile(\astof{\vexpr}, \astversion{\voptlimit}, \astof{\vstmtlist})}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{LoopLimit}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-looplimit}{}
The function
\[
\buildlooplimit(\overname{\parsenode{\Nlooplimit}}{\vparsednode}) \aslto \overname{\Option{\expr}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[limit]{}{
  \buildlooplimit\left(\overname{\Nlooplimit(\Tlooplimit, \punnode{\Nexpr})}{\vparsednode}\right)
  \astarrow
  \overname{\some{\astof{\vexpr}}}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_limit]{}{
  \buildlooplimit\left(\overname{\Nlooplimit(\emptysentence)}{\vparsednode}\right)
  \astarrow
  \overname{\None}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SWhile}
\ExampleDef{Typing While Loops}
The specification in \listingref{typing-swhile} is well-typed
and shows two \whilestatementterm{} --- the first one without a loop limit
and the second one with a loop limit.
\ASLListing{Typing while statements}{typing-swhile}{\typingtests/TypingRule.SWhile.asl}

The specification in \listingref{typing-swhile-bad-limit}
is ill-typed, since the loop limit is not a \constrainedintegerterm.
\ASLListing{An ill-typed loop limit}{typing-swhile-bad-limit}{\typingtests/TypingRule.SWhile.bad_limit.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vs$ is a \texttt{while} statement with expression $\veone$, optional limit expression $\vlimitone$,
      and statement block $\vsone$, that is, $\SWhile(\veone, \vsone)$;
\item annotating the \rhsexpression{} $\veone$ in $\tenv$ yields $(\vt, \vetwo, \vsese)$\ProseOrTypeError;
\item annotating the optional limit expression $\vlimitone$ via $\annotatelimitexpr$ in $\tenv$ yields $(\vlimittwo, \vseslimit)$\ProseOrTypeError;
\item checking that $\vt$ \typesatisfiesterm\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item annotating $\vsone$ as a block statement as per \TypingRuleRef{Block} in $\tenv$ yields \\
      $(\vstwo, \vsesblock)$\ProseOrTypeError;
\item $\news$ is a \texttt{while} statement with expression $\vetwo$, optional limit expression $\vlimittwo$,
      and statement block $\vstwo$, that is, $\SWhile(\vetwo, \vstwo)$;
\item $\newtenv$ is $\tenv$;
\item \Proseeqdef{$\vses$}{the union of $\vsesblock$, $\vsese$, and $\vseslimit$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vt, \vetwo, \vsese) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimitone) \typearrow (\vlimittwo, \vseslimit) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock(\tenv, \vsone) \typearrow (\vstwo, \vsesblock) \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsese \cup \vseslimit
}{
  \annotatestmt(\tenv, \overname{\SWhile(\veone, \vlimitone, \vsone)}{\vs}) \typearrow
  (\overname{\SWhile(\vetwo, \vlimittwo, \vstwo)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SWhileBegin}{\SWhileEnd}{../Typing.ml}
\identr{FTVN}

\TypingRuleDef{AnnotateLimitExpr}
\RenderRelation{annotate_limit_expr}
\BackupOriginalRelation{
The function
\[
  \annotatelimitexpr(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Option{\expr}}{\ve}
  ) \aslto
  (\Option{\overname{\expr}{\vep}} \times \overname{\TSideEffectSet}{\vses}) \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
annotates an optional expression $\ve$ serving as the limit of a loop or a recursive subprogram in $\tenv$,
yielding a pair consisting of an expression $\vep$ and a \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Limit Expressions}
The specification in \listingref{typing-swhile} has two loops.
The loop in \verb|scan| is limited by the constrained integer
expression \verb|N|, while the loop in \verb|main| does not
have a loop limit.

The loop in \listingref{typing-swhile-bad-limit} uses
the limit expression \verb|i_limit| whose type the
\unconstrainedintegertypeterm, which is illegal for
limit expressions.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\ve$ is $\None$;
    \item \Proseeqdef{$\vep$}{$\None$};
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\ve$ is $\some{\vlimit}$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\vlimit$ in $\tenv$ yields \\
          $(\vlimitp, \vses)$\ProseOrTypeError;
    \item \Proseeqdef{$\vep$}{$\some{\vlimitp}$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \annotatelimitexpr(\tenv, \overname{\None}{\ve}) \typearrow (\overname{\None}{\vep}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\begin{mathpar}
\inferrule[some]{
  \annotatesymbolicconstrainedinteger(\tenv, \vlimit) \typearrow (\vlimitp, \vses) \OrTypeError
}{
  \annotatelimitexpr(\tenv, \overname{\some{\vlimit}}{\ve}) \typearrow (\overname{\some{\vlimitp}}{\vep}, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateLimitExprBegin}{\AnnotateLimitExprEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SWhile}
\ExampleDef{Evaluation of While Statements}
The specification in \listingref{semantics-swhile} prints the
following to the console:
% CONSOLE_BEGIN aslref \semanticstests/SemanticsRule.SWhile.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
i = 0
i = 1
i = 2
i = 3
\end{Verbatim}
% CONSOLE_END

The specification in \listingref{swhile-limit-reached} yields a dynamic
error once the loop limit for the \whilestatementterm{} is reached.
\ASLListing{Reaching a while loop limit}{swhile-limit-reached}{\semanticstests/SemanticsRule.SWhile.limit_reached.asl}

\ProseParagraph
Evaluation of the statement $\vs$ in an environment $\env$ yields
the output configuration $C$.
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{while} statement, $\SWhile(\ve, \velimitopt, \vbody)$;
  \item evaluating the optional limit expression $\velimitopt$ via $\evallimit$ in $\env$
        yields $(\vlimitopt, \vgone)$\ProseOrDynErrorDiverging;
  \item evaluating the loop as per \SemanticsRuleRef{Loop} in an environment $\env$,
  with the arguments $\True$ (which conveys that this is a \texttt{while} statement), $\vlimitopt$, $\ve$, and $\vbody$
  yields the (non-error configuration) $C$\ProseOrDynErrorDiverging;
  \item $\vgtwo$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge;
  \item the output configuration $D$ is the output configuration $C$ with its execution graph
        substituted with $\vgtwo$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitopt, \vgone) \OrDynErrorDiverging\\\\
  \evalloop(\env, \True, \vlimitopt, \ve, \vbody) \evalarrow C \OrDynErrorDiverging\\\\
  \vgtwo \eqdef \ordered{\vgone}{\asldata}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\vgtwo}
}{
  \evalstmt(\env, \overname{\SWhile(\ve, \velimitopt, \vbody)}{\vs}) \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSWhileBegin}{\EvalSWhileEnd}{../Interpreter.ml}

\SemanticsRuleDef{Loop}
\RenderRelation{eval_loop}
\BackupOriginalRelation{
The relation
\[
  \evalloop(
    \overname{\envs}{\env} \aslsep
    \overname{\Bool}{\iswhile} \aslsep
    \overname{\Option{\N}}{\vlimitopt} \aslsep
    \overname{\expr}{\econd} \aslsep
    \overname{\stmt}{\vbody})
  \;\aslrel\;
  \left(
    \begin{array}{cl}
      \Continuing(\overname{\XGraphs}{\newg} \aslsep \overname{\envs}{\newenv}) & \cup \\
      \overname{\TReturning}{\ReturningConfig} & \cup \\
      \overname{\TThrowing}{\ThrowingConfig} & \cup \\
      \overname{\TDynError}{\DynErrorConfig} &
    \end{array}
  \right)
\]
to evaluate both \texttt{while} statements and \texttt{repeat} statements.
} % END_OF_BACKUP_RELATION

More specifically, $\evalloop(\env, \iswhile, \velimitopt, \econd, \vbody)$
evaluates $\vbody$ in $\env$ as long as $\econd$ holds when $\iswhile$ is $\True$
or until $\econd$ holds when $\iswhile$ is $\False$.
If the number of iterations exceeds the optional value specified by $\vlimitopt$,
the result is a \dynamicerrorterm{}.
The result is either the continuing configuration \\ $\Continuing(\newg,\newenv)$,
an early return configuration, or an abnormal configuration.

\ExampleDef{Evaluation of Loops}
The specification in \listingref{semantics-loop} does not result in any Assertion Error
and the specification terminates with exit code $0$.
\ASLListing{Evaluating a loop}{semantics-loop}{\semanticstests/SemanticsRule.Loop.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
\item \AllApplyCase{exit}
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is $\ResultExpr(\condm, \newenv)$\ProseOrAbnormal;
    \item $\condm$ consists of a native Boolean for $\vb$ and an execution graph $\newg$;
    \item $\vb$ is not equal to $\iswhile$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$
    and the loop is exited.
  \end{itemize}
\item \AllApplyCase{continue}
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is $\ResultExpr(\condm, \envone)$\ProseOrAbnormal;
    \item $\mcond$ consists of a native Boolean for $\vb$ and an execution graph $\vgone$;
    \item $\vb$ is equal to $\iswhile$;
    \item \Proseticklooplimit{$\vlimitopt$}{$\vlimitoptp$}\ProseOrError;
    \item evaluating $\vbody$ in $\envone$ as per \SemanticsRuleRef{Block} is either \\
          $\Continuing(\vgtwo, \envtwo)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig, \TDiverging};
    \item evaluating $(\iswhile, \vlimitoptp, \econd, \vbody)$ in $\envtwo$ as a loop is \\
          $\Continuing(\vgthree, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig, \TDiverging};
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label
          and then the ordered composition of the result and $\vgthree$ with the $\aslpo$ edge;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
The premise $\vb \neq \iswhile$ is $\True$ in the case of a \texttt{while} loop
and the loop condition $\ve$ not holding, which is exactly when we want the
loop to exit. The opposite holds for a \texttt{repeat} loop.
The negation of the condition is used to decide whether to continue the loop iteration.

\begin{mathpar}
\inferrule[exit]{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\condm, \newenv) \OrAbnormal\\\\
  \condm \eqname (\nvbool(\vb), \newg)\\
  \vb \neq \iswhile
}{
  \evalloop(\env, \iswhile, \vlimitopt, \econd, \vbody) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[continue]{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\condm, \envone) \OrAbnormal\\\\
  \condm \eqname (\nvbool(\vb), \vgone)\\
  \vb = \iswhile\\
  \ticklooplimit(\vlimitopt) \evalarrow \vlimitoptp \OrDynError\\\\
  \evalblock(\envone, \vbody) \evalarrow \Continuing(\vgtwo, \envtwo) \OrAbnormal, \ReturningConfig\\\\
  {
    \begin{array}{r}
      \evalloop(\envtwo, \iswhile, \vlimitoptp, \econd, \vbody) \evalarrow \\
      \Continuing(\vgthree, \newenv) \OrAbnormal, \ReturningConfig\\
    \end{array}
  }\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslctrl}{\vgtwo}}{\aslpo}{\vgthree}
}{
  \evalloop(\env, \iswhile, \vlimitopt, \econd, \vbody) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalLoopBegin}{\EvalLoopEnd}{../Interpreter.ml}

\SemanticsRuleDef{EvalLimit}
\RenderRelation{eval_limit}
\BackupOriginalRelation{
The relation
\[
\evallimit(\overname{\env}{\envs} \aslsep \overname{\velimitopt}{\Option{\expr}})
\;\aslrel\;
\left(
\begin{array}{ll}
(\overname{\Option{\N}}{\vvopt}, \overname{\XGraphs}{\vg}) & \cup\\
\overname{\TDynError}{\DynErrorConfig} & \cup\\
\overname{\TDiverging}{\DivergingConfig} & \\
\end{array}
\right)
\]
evaluates the optional expression $\velimitopt$ in the environment $\env$, yielding
the optional integer value $\vvopt$ and execution graph $\vg$.
\ProseOtherwiseDynamicErrorOrDiverging
} % END_OF_BACKUP_RELATION

The evaluation uses the function $\evalexprsef$ because limit expressions are
guaranteed side-effect-free by the typechecker,
see \TypingRuleRef{AnnotateLimitExpr}.

See \ExampleRef{Evaluation of While Statements} to see how the
limit expression is evaluated just once for the entire evaluation
of the \whilestatementterm.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\velimitopt$ is $\None$;
    \item $\vvopt$ is $\None$;
    \item $\vg$ is the empty execution graph.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\velimitopt$ is the expression $\velimit$;
    \item evaluating the side-effect-free expression $\velimitopt$ in $\denv$ yields the native integer for $\vv$ and
          the execution graph $\vg$\ProseOrDynErrorDiverging;
    \item $\vvopt$ is $\some{\vv}$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \evallimit(\env, \overname{\None}{\velimitopt}) \evalarrow (\overname{\None}{\vvopt}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \evalexprsef(\env, \velimit) \evalarrow (\nvint(\vv), \vg) \OrDynErrorDiverging
}{
  \evallimit(\env, \overname{\some{\velimit}}{\velimitopt}) \evalarrow (\overname{\some{\vv}}{\vvopt}, \vg)
}
\end{mathpar}

\SemanticsRuleDef{TickLoopLimit}
\RenderRelation{tick_loop_limit}
\BackupOriginalRelation{
The relation
\[
\ticklooplimit(\overname{\Option{\N}}{\vvopt}) \aslto \overname{\Option{\N}}{\Option{\vvoptp}}
\cup \overname{\TDynError}{\DynErrorConfig}
\]
decrements the optional integer $\vvopt$, yielding
the optional integer value $\vvopt$.
If the value is $0$, the result is a \DynamicErrorConfigurationTerm{}.
} % END_OF_BACKUP_RELATION

\ExampleDef{Decrementing a Loop Limit Value}
In \listingref{semantics-swhile}, the loop limit value
starts at $\nvint(20)$ and decrements towards $\nvint(0)$,
stopping at $\nvint(1)$ on the last iteration of the loop.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vvopt$ is $\None$;
    \item $\vvoptp$ is $\None$.
  \end{itemize}

  \item \AllApplyCase{some\_ok}
  \begin{itemize}
    \item $\vvopt$ is the positive integer $\vv$;
    \item $\vvoptp$ is $\some{\vv-1}$.
  \end{itemize}

  \item \AllApplyCase{some\_error}
  \begin{itemize}
    \item $\vvopt$ is the integer $0$;
    \item the result is a \DynamicErrorConfigurationTerm{} indicating that a limit has been reached
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \ticklooplimit(\overname{\None}{\vvopt}) \evalarrow \overname{\None}{\vvoptp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_ok]{
  \vv > 0
}{
  \ticklooplimit(\overname{\some{\vv}}{\vvopt}) \evalarrow \overname{\some{\vv-1}}{\vvoptp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_error]{}{
  \ticklooplimit(\overname{\some{ 0 }}{\vvopt}) \evalarrow \DynamicErrorVal{\LimitExceeded}
}
\end{mathpar}

\section{Repeat Statements\label{sec:RepeatStatements}}
\hypertarget{def-repeatstatementterm}{}

\ASLListing{A repeat statement}{semantics-srepeat}{\semanticstests/SemanticsRule.SRepeat.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Trepeat \parsesep \Nstmtlist \parsesep \Tuntil \parsesep \Nexpr \parsesep \Nlooplimit \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_repeat}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SRepeat(\overtext{\stmt}{loop body}, \overtext{\expr}{condition}, \overtext{\expr?}{loop limit}) &
\end{flalign*}
}

\ASTRuleDef{SRepeat}
\begin{mathpar}
\inferrule{
  \buildexpr(\vlimitexpr) \astarrow \astversion{\vlimitexpr}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Tlooplimit, \Tlpar, \namednode{\vlimitexpr}{\Nexpr}, \Trpar, \Trepeat, \\
    \wrappedline\ \Nstmtlist, \Tuntil, \punnode{\Nexpr}, \punnode{\Nlooplimit}, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow\\
  \overname{\SRepeat(\astof{\vstmtlist}, \astof{\vexpr}, \astof{\vlooplimit})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SRepeat}
\ExampleDef{Typing a Repeat Statement}
The \repeatstatementsterm{} in \listingref{semantics-srepeat} are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement with statement block $\vsone$,
        optional limit expression $\vlimitone$, and expression $\veone$, that is, $\SRepeat(\vsone, \veone, \vlimitone)$;
  \item annotating $\vsone$ as a block statement per \TypingRuleRef{Block} in $\tenv$ yields \\
        $(\vstwo, \vsesblock)$\ProseOrTypeError;
  \item annotating the optional limit expression $\vlimitone$ via $\annotatelimitexpr$ in $\tenv$ yields $(\vlimittwo, \vseslimit)$\ProseOrTypeError;
  \item annotating the \rhsexpression{} $\veone$ in $\tenv$ yields $(\vt, \vetwo, \vsese)$\ProseOrTypeError;
  \item checking that $\vt$ \typesatisfiesterm\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is a \texttt{repeat} statement with statement block $\vstwo$, optional limit expression $\vlimittwo$,
        and condition expression $\vetwo$ and , that is, $\SRepeat(\vstwo, \vetwo, \vlimittwo)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesblock$, $\vsese$, and $\vseslimit$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateblock(\tenv, \vsone) \typearrow (\vstwo, \vsesblock) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimitone) \typearrow (\vlimittwo, \vseslimit) \OrTypeError\\\\
  \annotateexpr(\tenv, \veone) \typearrow (\vt, \vetwo, \vsese) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsese \cup \vseslimit
}{
  {
  \begin{array}{r}
    \annotatestmt(\tenv, \overname{\SRepeat(\vsone, \veone, \vlimitone)}{\vs}) \typearrow\\
    (\overname{\SRepeat(\vstwo, \vetwo, \vlimittwo)}{\news}, \overname{\tenv}{\newtenv}, \vses)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SRepeatBegin}{\SRepeatEnd}{../Typing.ml}
\identr{FTVN}

\subsection{Semantics}
\SemanticsRuleDef{SRepeat}
\ExampleDef{Evaluation of Repeat Statements}
The specification in \listingref{semantics-srepeat} produces the following output to the console.
% CONSOLE_BEGIN aslref  --type-check-no-warn \semanticstests/SemanticsRule.SRepeat.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
j = 0
j = 1
j = 2
j = 3
j = 4
#ones in x = 5
i = 0
i = 1
i = 2
i = 3
i = 4
#ones in x = 5
\end{Verbatim}
% CONSOLE_END

\ProseParagraph
Evaluation of the statement $\vs$ in an environment $\env$ yields
either \\ $\Returning((\vvs, \newg), \newenv)$ or an output configuration $D$.

\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement, $\SRepeat(\ve, \vbody, \velimitopt)$;
  \item evaluating the optional limit expression $\velimitopt$ via $\evallimit$ in $\env$
        yields $(\vlimitopt, \vgone)$\ProseOrDynErrorDiverging;
  \item \Proseticklooplimit{$\vlimitoptone$}{$\vlimitopttwo$}\ProseOrError;
  \item evaluating $\vbody$ in $\env$ as per \chapref{BlockStatements}
        yields $\Continuing(\vgtwo, \envone)$\ProseTerminateAs{\ReturningConfig,\ThrowingConfig,\DynErrorConfig,\DivergingConfig};
  \item evaluating the loop as per \secref{SemanticsRule.Loop} in an environment $\envone$,
        with the arguments $\False$ (which conveys that this is a \texttt{repeat} statement),
        $\vlimitopttwo$,
        $\ve$,
        and $\vbody$
        results in $C$;
  \item $\vgthree$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ and the graph of $C$
        with the $\aslpo$ edge;
  \item the output configuration $D$ is the output configuration $C$ with its execution graph
        substituted with $\vgthree$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitoptone, \vgone) \OrDynErrorDiverging\\\\
  \ticklooplimit(\vlimitoptone) \evalarrow \vlimitopttwo \OrDynError\\\\
  \evalblock(\env, \vbody) \evalarrow \Continuing(\vgtwo, \envone) \OrAbnormal, \ReturningConfig\\\\
  \evalloop(\envone, \False, \vlimitopttwo, \ve, \vbody) \evalarrow C\\
  \vgthree \eqdef \ordered{\vgone}{\asldata}{\ordered{\vgtwo}{\aslpo}{\graphof{C}}}\\
  D \eqdef \withgraph{C}{\vgthree}
}{
  \evalstmt(\env, \overname{\SRepeat(\ve, \vbody, \velimitopt)}{\vs}) \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSRepeatBegin}{\EvalSRepeatEnd}{../Interpreter.ml}

\section{For Statements\label{sec:ForStatements}}
\hypertarget{def-forstatementterm}{}

\ASLListing{\texttt{for} loops}{semantics-sfor}{\semanticstests/SemanticsRule.SFor.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tfor \parsesep \Tidentifier \parsesep \Teq \parsesep \Nexpr \parsesep \Ndirection \parsesep
                    \Nexpr \parsesep \Nlooplimit \parsesep \Tdo &\\
                        & \wrappedline\ \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Ndirection \derives \ & \Tto \;|\; \Tdownto &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_for}
\BackupOriginalAST{
\begin{flalign*}
\fordirection \derives\ & \UP \;|\; \DOWN &\\
\stmt \derives\ & \SFor\left\{
      \begin{array}{rcl}
      \Forindexname  &:& \identifier,\\
      \Forstarte     &:& \expr,\\
      \Fordir        &:& \fordirection,\\
      \Forende       &:& \expr,\\
      \Forbody       &:& \stmt,\\
      \Forlimit      &:& \expr?
      \end{array}
    \right\} &
\end{flalign*}
}

\ASTRuleDef{SFor}
\begin{mathpar}
\inferrule{
  \buildexpr(\vstarte) \astarrow \astversion{\vstarte}\\
  \buildexpr(\vende) \astarrow \astversion{\vende}\\
}{
  {
    \begin{array}{r}
      \buildstmt\left(\overname{\Nstmt\left(
        \begin{array}{l}
        \Tfor, \Tidentifier(\vindexname), \Teq, \namednode{\vstarte}{\Nexpr},  \\
        \wrappedline\ \Ndirection, \namednode{\vende}{\Nexpr}, \punnode{\Nlooplimit}, \Tdo, \\
        \wrappedline\ \punnode{\Nstmtlist}, \Tend, \Tsemicolon
        \end{array}
        \right)}{\vparsednode}\right)
      \astarrow \\
        \overname{
        \SFor\left(\left\{
          \begin{array}{rcl}
            \Forindexname &:& \vindexname\\
            \Forstarte &:& \astversion{\vstarte}\\
            \Fordir &:& \astof{\vdirection}\\
            \Forende &:& \astversion{\vende}\\
            \Forbody &:& \astof{\vstmtlist}\\
            \Forlimit &:& \astof{\vlooplimit}\\
          \end{array}
            \right\}\right)
    }{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{Direction}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-direction}{}
The function
\[
\builddirection(\overname{\parsenode{\Ndirection}}{\vparsednode}) \;\aslto\; \overname{\fordirection}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[to]{}{
  \builddirection(\overname{\Ndirection(\Tto)}{\vparsednode}) \astarrow \overname{\UP}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[downto]{}{
  \builddirection(\overname{\Ndirection(\Tdownto)}{\vparsednode}) \astarrow \overname{\DOWN}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SFor}
The \texttt{for} loops in \listingref{semantics-sfor} are well-typed.

\ExampleDef{Ill-typed for loop}
\listingref{typing-forloop-bad1},
\listingref{typing-forloop-bad2},
\listingref{typing-forloop-bad3}, and
\listingref{typing-forloop-bad4}
show examples of ill-typed \texttt{for} loops.

\ASLListing{Ill-typed for loop 1}{typing-forloop-bad1}{\typingtests/TypingRule.SFor.bad1.asl}
\ASLListing{Ill-typed for loop 2}{typing-forloop-bad2}{\typingtests/TypingRule.SFor.bad2.asl}
\ASLListing{Ill-typed for loop 3}{typing-forloop-bad3}{\typingtests/TypingRule.SFor.bad3.asl}
\ASLListing{Ill-typed for loop 4}{typing-forloop-bad4}{\typingtests/TypingRule.SFor.bad4.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement with index $\vindexname$,
        start expression $\vstarte$,
        direction $\dir$,
        end expression $\vende$,
        body statement (block) $\vbody$,
        and optional limit expression $\vlimit$,
        that is, $\SFor\left\{\begin{array}{rcl}
          \Forindexname &:& \vindexname\\
          \Forstarte &:& \vstarte\\
          \fordirection &:& \vdir\\
          \Forende &:& \vende\\
          \Forbody &:& \vbody\\
          \Forlimit &:& \vlimit
        \end{array}\right\}$;
  \item annotating the \rhsexpression{} $\vstarte$ in $\tenv$ yields \\
        $(\vstartt, \vstartep, \vsesstart)$\ProseOrTypeError;
  \item annotating the \rhsexpression{} $\vende$ in $\tenv$ yields \\ $(\vendt, \vendep, \vsesend)$\ProseOrTypeError;
  \item annotating the optional loop limit expression $\vlimit$ via $\annotatelimitexpr$ in $\tenv$
        yields $(\vlimitp, \vseslimit)$\ProseOrTypeError;
  \item checking that $\vsesstart$ is \readonlyterm{} via $\sesisreadonly$ yields $\True$\ProseOrTypeError;
  \item checking that $\vsesend$ is \readonlyterm{} via $\sesisreadonly$ yields $\True$\ProseOrTypeError;
  \item \Proseeqdef{$\vsescond$}{the union of $\vsesstart$, $\vsesend$, and $\vseslimit$};
  \item obtaining the \underlyingtypeterm\ of $\vstartt$ in $\tenv$ yields $\vstartstruct$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vendt$ in $\tenv$ yields $\vendstruct$\ProseOrTypeError;
  \item applying $\getforconstraints$ to $\vstartstruct$, $\vendstruct$,
        $\vstartep$, $\vendep$, and $\dir$ in $\tenv$,
        to obtain the constraints on the loop index $\vindexname$,
        yields $\cs$\ProseOrTypeError;
  \item $\tty$ is the integer type with constraints $\cs$;
  \item checking that $\vindexname$ is not already declared in $\tenv$ yields $\True$\ProseOrTypeError;
  \item adding $\vindexname$ as a local immutable variable with type $\tty$ to $\tenv$ yields $\tenvp$;
  \item annotating $\vbody$ as a block statement in $\tenvp$ yields $(\vbodyp, \vsesblock)$\ProseOrTypeError;
  \item $\news$ is the \texttt{for} statement with index $\vindexname$,
        start expression $\vstartep$, direction $\dir$,
        end expression $\vendep$,
        body statement (block) $\vbodyp$, and
        optional limit expression $\vlimit$;
  \item $\newtenv$ is $\tenv$ (notice that this means $\vindexname$ is only declared for annotating $\vbodyp$ but then goes
        out of scope);
  \item define $\vses$ as the union of $\vsesblock$ and $\vsescond$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \vstarte) \typearrow (\vstartt, \vstartep, \vsesstart) \OrTypeError\\\\
  \annotateexpr(\tenv, \vende) \typearrow (\vendt, \vendep, \vsesend) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimit) \typearrow (\vlimitp, \vseslimit) \OrTypeError\\\\
  \techeck(\sesisreadonly(\vsesstart), \SideEffectViolation) \typearrow \True\OrTypeError\\\\
  \techeck(\sesisreadonly(\vsesend), \SideEffectViolation) \typearrow \True\OrTypeError\\\\
  \vsescond \eqdef \vsesstart \cup \vsesend \cup \vseslimit\\
  \makeanonymous(\tenv, \vstartt) \typearrow \vstartstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vendt) \typearrow \vendstruct \OrTypeError\\\\
  {
    \begin{array}{r}
  \getforconstraints(\tenv, \vstartstruct, \vendstruct, \vstartep, \vendep, \dir) \typearrow \\
    \cs \OrTypeError
    \end{array}
  }\\\\
  \tty \eqdef \TInt(\cs)\\
  \checkvarnotinenv(\tenv, \vindexname) \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \tty, \vindexname, \LDKLet) \typearrow \tenvp\\
  \annotateblock(\tenvp, \vbody) \typearrow (\vbodyp, \vsesblock) \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsescond
}{
  {
    \begin{array}{r}
  \annotatestmt\left(\tenv, \overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \Fordir &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \vlimit
  \end{array}\right\}}{\vs}\right) \typearrow \\
  \left(\overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstartep\\
    \Fordir &:& \vdir\\
    \Forende &:& \vendep\\
    \Forbody &:& \vbodyp\\
    \Forlimit &:& \vlimitp
  \end{array}\right\}}{\news}, \overname{\tenv}{\newtenv}, \vses\right)
\end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SForBegin}{\SForEnd}{../Typing.ml}
\identr{SSBD} \identr{ZSND} \identr{VTJW}

\TypingRuleDef{SForConstraints}
\RenderRelation{get_for_constraints}
\BackupOriginalRelation{
The function
\[
  \getforconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\structone} \aslsep
    \overname{\ty}{\structtwo} \aslsep
    \overname{\expr}{\veonep} \aslsep
    \overname{\expr}{\vetwop} \aslsep
    \overname{\fordirection}{\dir}
  ) \aslto
  \overname{\constraintkind}{\vis} \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
infers the integer constraints for a \texttt{for} loop index variable from the following:
\begin{itemize}
  \item the \wellconstrainedversionterm\ of the type of the start expression --- $\structone$
  \item the \wellconstrainedversionterm\ of the type of the end expression --- $\structtwo$
  \item the annotated start expression --- $\veonep$
  \item the annotated end expression --- $\vetwop$
  \item the loop direction --- $\dir$
\end{itemize}
The result is $\vis$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Inferring the Constraints of a for Loop Index}
In \listingref{semantics-sfor} the constraints for the loop index variable
\verb|j| in \verb|scan| are \verb|0..N-1|,
and the constraints for the loop index variable \verb|i| in \verb|main| are \verb|0..4|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{not\_integers}
  \begin{itemize}
    \item at least one of $\structone$ and $\structtwo$ is not an integer type;
    \item the result is a \typingerrorterm{} indicating that the start expression and end expression of \texttt{for} loops
          must have the \structureterm\ of integer types.
  \end{itemize}

  \item \AllApplyCase{unconstrained}
  \begin{itemize}
    \item both of $\structone$ and $\structtwo$ are integer types;
    \item at least one of $\structone$ and $\structtwo$ is the unconstrained integer type;
    \item define $\vis$ as $\Unconstrained$.
  \end{itemize}

  \item \AllApplyCase{well\_constrained}
  \begin{itemize}
    \item both of $\structone$ and $\structtwo$ are integer types;
    \item neither $\structone$ nor $\structtwo$ is the unconstrained integer type;
    \item symbolically simplifying $\veonep$ in $\tenv$ yields $\eonen$\ProseOrTypeError;
    \item symbolically simplifying $\vetwop$ in $\tenv$ yields $\etwon$\ProseOrTypeError;
    \item define $\icsup$ as the single range constraint with expressions $\eonen$ and $\etwon$;
    \item define $\icsdown$ as the single range constraint with expressions $\etwon$ and $\eonen$;
    \item define $\vis$ as $\icsup$ if $\dir$ is $\UP$ and $\icsdown$ otherwise.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_integers]{
  \astlabel(\structone) \neq \TInt \lor \astlabel(\structtwo) \neq \TInt
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  \astlabel(\structone) = \TInt \land \astlabel(\structtwo) = \TInt\\
  \structone = \unconstrainedinteger \lor \structtwo = \unconstrainedinteger\\
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \overname{\Unconstrained}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \astlabel(\structone) = \TInt \land \astlabel(\structtwo) = \TInt\\
  \structone \neq \unconstrainedinteger \land \structtwo \neq \unconstrainedinteger\\
  \normalize(\tenv, \veonep) \typearrow \eonen \OrTypeError\\\\
  \normalize(\tenv, \vetwop) \typearrow \etwon \OrTypeError\\\\
  \icsup \eqdef \WellConstrained([\ConstraintRange(\eonen, \etwon)])\\
  \icsdown \eqdef \WellConstrained([\ConstraintRange(\etwon, \eonen)])\\
  \vis \eqdef \choice{\dir=\UP}{\icsup}{\icsdown}
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \vis
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{SFor}
Evaluating a \texttt{for} statement involves introducing an index variable to the
environment. The type system ensures, via \TypingRuleRef{SFor}, that the index variable
is not already declared in the scope of the subprogram containing the \texttt{for}
statement.

\ExampleDef{Evaluation of For Statements}
The specification in \listingref{semantics-sfor} is followed by its output to the console.
% CONSOLE_BEGIN aslref \semanticstests/SemanticsRule.SFor.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
j = 0
j = 1
j = 2
j = 3
j = 4
#ones in x = 5
i = 4
i = 3
i = 2
i = 1
i = 0
#ones in x = 5
\end{Verbatim}
% CONSOLE_END

The specification in \listingref{SFor-nop} shows a \forstatementterm{}
whose body does not evaluate since its lower bound is greater than its upper bound.
\ASLListing{A for loop with no iterations}{SFor-nop}{\semanticstests/SemanticsRule.SFor.nop.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement, $\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \Ignore
  \end{array}\right\}$;
  \item evaluating the side-effect-free expression $\vstarte$ in $\env$ yields\\
        $\ResultExprSEF(\vstartv, \vgone)$\ProseOrDynErrorDiverging;
  \item evaluating the side-effect-free expression $\vende$ in $\env$ yields\\
        $\ResultExprSEF(\vendv, \vgtwo)$\ProseOrError;
  \item \Proseevallimit{$\env$}{$\velimitopt$}{$(\vlimitopt, \vgthree)$}\ProseOrDynErrorDiverging;
  \item declaring the local identifier $\vindexname$ in $\env$ with value $\vstartv$ is $(\vgfour, \envone)$;
  \item applying the \texttt{for} loop with arguments \\
        $(\vindexname, \vlimitopt, \vstartv, \dir, \vendv, \vbody)$ in $\envone$,
        as per \\
        \SemanticsRuleRef{EvalFor} yields $\Continuing(\vgfive, \envtwo)$\ProseReturningOrAbnormal;
  \item removing the local $\vindexname$ from $\envtwo$ is $\envthree$;
  \item $\newg$ is formed as follows:
        the parallel composition of $\vgone$, $\vgtwo$, and $\vgthree$;
        followed by the ordered composition of the result with $\vgfour$ using the $\asldata$ edge;
        followed by the ordered composition of the result with $\vgfive$ using the $\aslpo$ edge.
  \item $\newenv$ is $\envthree$.
  \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
\end{itemize}

\FormallyParagraph
Recall that the expressions for the \texttt{for} loop range are
side-effect-free, as guaranteed by \TypingRuleRef{SFor}, which is why
they are evaluated via the rule for evaluating side-effect-free expressions.
\begin{mathpar}
\inferrule{
  \evalexprsef(\env, \vstarte) \evalarrow \ResultExprSEF(\vstartv, \vgone) \OrDynErrorDiverging\\\\
  \evalexprsef(\env, \vende) \evalarrow \ResultExprSEF(\vendv, \vgtwo) \OrDynErrorDiverging\\\\
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitopt, \vgthree) \OrDynErrorDiverging\\\\
  \declarelocalidentifier(\env, \vindexname, \vstartv) \evalarrow (\vgfour,\envone)\\
  {
    \begin{array}{r}
      \evalfor(\envone, \vindexname, \vlimitopt, \vstartv, \dir, \vendv, \vbody) \evalarrow \\
      \Continuing(\vgfive, \envtwo) \OrReturningOrAbnormal
    \end{array}
  }\\
  \removelocal(\envtwo, \vindexname) \evalarrow \envthree\\
  \newg \eqdef \ordered{(\vgone \parallelcomp \vgtwo \parallelcomp \vgthree)}{\asldata}{ \ordered{\vgfour}{\aslpo}{\vgfive}   }\\
  \newenv \eqdef \envthree
}{
  {
  \begin{array}{r}
  \evalstmt\left(\env,
  \overname{
  \SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \velimitopt\\
  \end{array}\right\}}{\vs}
  \right) \evalarrow \\ \Continuing(\newg, \newenv)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EvalSForBegin}{\EvalSForEnd}{../Interpreter.ml}

\SemanticsRuleDef{EvalFor}
\RenderRelation{eval_for}
\BackupOriginalRelation{
The relation
\[
  \evalfor\left(
  \begin{array}{cl}
    \overname{\envs}{\env}                      & \aslsep\\
    \overname{\Identifier}{\vindexname}        & \aslsep\\
    \overname{\Option{\tint}}{\vlimitopt}  & \aslsep\\
    \overname{\tint}{\vstart}                   & \aslsep\\
    \overname{\{\UP, \DOWN\}}{\dir}             & \aslsep\\
    \overname{\tint}{\vend}                     & \aslsep\\
    \overname{\stmt}{\vbody}                    &
  \end{array}
  \right)
  \;\aslrel\;
  \left(
    \begin{array}{cl}
    \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TContinuing}{\ContinuingConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup\\
    \overname{\TDynError}{\DynErrorConfig} & \cup\\
    \overname{\TDiverging}{\DivergingConfig} & \\
    \end{array}
    \right)
\]
evaluates the \texttt{for} loop with the index variable $\vindexname$,
optional limit value $\vlimitopt$,
starting from the value
$\vstart$ going in the direction given by $\dir$ until the value given by $\vend$,
executing $\vbody$ on each iteration.
%
The evaluation utilizes two helper relations: $\evalforstep$ and $\evalforloop$.
} % END_OF_BACKUP_RELATION


\RenderRelation{eval_for_step}
\BackupOriginalRelation{
The relation
\[
  \evalforstep\left(
  \begin{array}{cl}
  \overname{\envs}{\env}                      & \aslsep\\
  \overname{\Identifier}{\vindexname}        & \aslsep\\
  \overname{\Option{\tint}}{\vlimitopt}  & \aslsep\\
  \overname{\tint}{\vstart}                   & \aslsep\\
  \overname{\{\UP,\DOWN\}}{\dir}              &
  \end{array}
  \right)
  \;\aslrel\;
  \left(
  \begin{array}{cl}
  ((\overname{\tint}{\vstep} \times \overname{\envs}{\newenv}) \times \overname{\XGraphs}{\newg}) & \cup\\
  \overname{\TReturning}{\ReturningConfig}  & \cup\\
  \overname{\TThrowing}{\ThrowingConfig}    & \cup \\
  \overname{\TDynError}{\DynErrorConfig}    & \cup\\
  \overname{\TDiverging}{\DivergingConfig}  &
  \end{array}
  \right)
\]
either increments or decrements the index variable,
returning the new value of the index variable, the modified environment,
and the resulting execution graph.
\ProseOtherwiseReturningOrAbnormal
} % END_OF_BACKUP_RELATION

\RenderRelation{eval_for_loop}
\BackupOriginalRelation{
The relation
\[
  \evalforloop\left(
    \begin{array}{cl}
    \overname{\envs}{\env} \aslsep &\\
    \overname{\Identifier}{\vindexname} \aslsep &\\
    \overname{\Option{\tint}}{\vlimitopt} \aslsep &\\
    \overname{\tint}{\vstart} \aslsep &\\
    \overname{\{\UP,\DOWN\}}{\dir} \aslsep &\\
    \overname{\tint}{\vend} \aslsep &\\
    \overname{\stmt}{\vbody} &
    \end{array}
    \right) \;\aslrel\;
    \left(
    \begin{array}{cl}
    \Continuing(\overname{\XGraphs}{\newg}, \overname{\envs}{\newenv}) & \cup\\
    \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup \\
    \overname{\TDynError}{\DynErrorConfig} & \cup\\
    \overname{\TDiverging}{\DivergingConfig} &
    \end{array}
    \right)
\]
executes one iteration of the loop body and then uses $\texttt{eval\_for}$ to execute the remaining
iterations.
} % END_OF_BACKUP_RELATION

\ProseParagraph
\subsubsection{Stepping the Index Variable}
\AllApply
\begin{itemize}
  \item $\opfordir$ is either $\ADD$ when $\dir$ is $\UP$ or $\SUB$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item applying the binary operator $\opfordir$ to $\vstart$ and the native integer for $1$ is $\vstep$;
  \item the execution graph for writing $\vstep$ into the identifier $\vindexname$ gives $\vgtwo$;
  \item updating the local component of the dynamic environment of $\env$ by binding \\ $\vindexname$ to $\vstep$
  gives $\newenv$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}

\subsubsection{Running the Loop Body}
\AllApply
\begin{itemize}
  \item evaluating $\vbody$ as a block statement (see \SemanticsRuleRef{Block}) in $\env$
        yields \\ $\Continuing(\vgone, \envone)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
  \item stepping the index $\vindexname$ with $\vstart$ and the direction $\dir$ in $\envone$,
        that is, $\evalforstep(\envone, \vindexname, \vlimitopt, \vstart, \dir)$ yields \\
        $((\vstep, \envtwo), \vgtwo)$;
  \item evaluating the \texttt{for} loop with $(\vindexname, \vlimitopt, \vstep, \dir, \vend, \vbody)$
        in $\envtwo$ results in a continuing configuration $\Continuing(\vgthree, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
  \item $\newg$ is the ordered composition of $\vgone$, $\vgtwo$, and $\vgthree$ with the $\aslpo$
        edge.
\end{itemize}

\subsubsection{Overall Evaluation}
\ExampleDef{Overall Evaluation of For Statements}
The specification in \listingref{semantics-sfor}
does not result in any assertion error, and terminates with exit-code $0$.

Evaluating $(\vindexname, \vstart, \dir, \vend, \vbody)$ in $\env$ yields either
a continuing configuration $\Continuing(\newg, \newenv)$, or a returning configuration
(in case the body of the loop results in an early return),
or an abnormal configuration.

\AllApply
\begin{itemize}
  \item $\compfordir$ is either $\LT$ when $\dir$ is $\UP$ or $\GT$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item \OneApplies
    \begin{itemize}
    \item \AllApplyCase{return}
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native \\
            Boolean for $\True$;
      \item $\newg$ is $\vgone$;
      \item $\newenv$ is $\env$;
      \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}
    \item \AllApplyCase{continue}
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native \\
            Boolean for $\False$;
      \item \Proseticklooplimit{$\vlimitopt$}{$\vnextlimitopt$}\ProseOrError;
      \item evaluating the loop body via $\evalforloop$ with \\ $(\vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody)$
      in $\env$ is \\ $\Continuing(\vgtwo, \newenv)$\ProseOrAbnormalReturning;
      \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
Advancing the loop counter one step towards the end of its range is achieved via the following rule:
\begin{mathpar}
\inferrule{
  \opfordir \eqdef \choice{\dir = \UP}{\ADD}{\SUB}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\
  \evalbinop(\opfordir, \vstart, \nvint(1)) \evalarrow \vstep\\
  \writeidentifier(\vindex, \vstep) \evalarrow \vgtwo\\
  \env \eqname (\tenv, \denv)\\
  \newenv \eqdef (\tenv, (G^\denv, L^\denv[\vindexname\mapsto\vstep]))\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  {
    \begin{array}{r}
      \evalforstep(\env, \vindexname, \vlimitopt, \vstart, \dir) \evalarrow \\
      ((\vstep, \newenv), \newg)
    \end{array}
  }
}
\end{mathpar}

Running the loop body is achieved via the following rule:
\begin{mathpar}
\inferrule{
  \evalblock(\env, \vbody) \evalarrow \Continuing(\vgone, \envone) \OrAbnormalReturning\\\\
  \evalforstep(\envone, \vindexname, \vlimitopt, \vstart, \dir) \evalarrow ((\vstep, \envtwo), \vgtwo)\\
  {
    \begin{array}{r}
      \evalfor(\envtwo, \vindexname, \vlimitopt, \vstep, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\vgthree, \newenv) \OrAbnormalReturning
    \end{array}
  }\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\vgthree}
}{
  {
    \begin{array}{r}
      \evalforloop(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\newg, \newenv)
    \end{array}
  }
}
\end{mathpar}

Finally, the rules for evaluating a \texttt{for} loop utilize both $\evalforstep$
and \\
$\evalforloop$ (the latter in a mutually recursive manner):
\begin{mathpar}
\inferrule[return]{
  \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\\\
  \commonprefixline\\\\
  \evalbinop(\compfordir, \vend, \vstart) \evalarrow \nvbool(\True)
}{
  {
    \begin{array}{r}
      \evalfor(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\overname{\vgone}{\newg}, \overname{\env}{\newenv})
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[continue]{
  \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\\\
  \commonprefixline\\\\
  \evalbinop(\compfordir, \vend, \vstart) \evalarrow \nvint(\False)\\
  \ticklooplimit(\vlimitopt) \evalarrow \vnextlimitopt \OrDynError\\\\
  \evalforloop(\env, \vindexname, \vnextlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
  \Continuing(\vgtwo, \newenv) \OrAbnormalReturning\\\\
  \newg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
}{
  {
    \begin{array}{r}
      \evalfor(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\newg, \newenv)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EvalForBegin}{\EvalForEnd}{../Interpreter.ml}

\hypertarget{def-throwstatementterm}{}
\section{Throw Statements\label{sec:ThrowStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tthrow \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_throw}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SThrow(\expr) &
\end{flalign*}
}

\ASTRuleDef{SThrow}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tthrow, \Nexpr, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SThrow(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SThrow}
\listingref{semantics-sthrowsometyped}
shows examples of well-typed \throwstatementsterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a throw statement with expression $\ve$, that is, $\SThrow(\ve)$;
  \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields $(\vte, \vep, \vsesone)$\ProseOrTypeError;
  \item checking that $\vte$ has the structure of an exception type yields $\True$\ProseOrTypeError;
  \item view $\vte$ as the named type for $\exnname$;
  \item $\news$ is a throw statement with expression $\vep$ and type $\vte$, that is, \\
        $\SThrow(\vep, \vte)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesone$ and the set containing a \LocalEffectTerm{} and a \GlobalEffectTerm{}, both with \purity{} $\SEImpure$.}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vsesone) \OrTypeError\\\\
  \checkstructurelabel(\tenv, \vte, \TException) \typearrow \True \OrTypeError\\\\
  \vte \eqname \TNamed(\exnname)\\
  \vses \eqdef \vsesone \cup \{\LocalEffect(\SEImpure), \GlobalEffect(\SEImpure)\}
}{
  \annotatestmt(\tenv, \overname{\SThrow(\ve)}{\vs}) \typearrow
  (\overname{\SThrow(\vep, \vte)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\identr{NXRC}
\CodeSubsection{\SThrowBegin}{\SThrowEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SThrow}
\ExampleDef{Throwing a Typed Exception}
The specification in \listingref{semantics-sthrowsometyped}
terminates successfully. That is, no \dynamicerrorterm{} occurs.
\ASLListing{Throwing an exception}{semantics-sthrowsometyped}{\semanticstests/SemanticsRule.SThrowSomeTyped.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{throw} statement, \\
        $\SThrow(\ve, \vt)$;
  \item evaluating $\ve$ in $\env$ is $\ResultExpr((\vv, \vgone), \newenv)$\ProseOrAbnormal;
  \item $\name$ is a fresh identifier (which conceptually holds the exception value);
  \item $\vgtwo$ is a Write Effect to $\name$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge;
  \item $\vex$ consists of the exception value $\vv$ and the name of the variable holding it ---
        $\name$;
  \item the result of the entire evaluation is $\Throwing(\vex, \vt, \newg, \env)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \name\in\Identifier \text{ is fresh}\\
  \vgtwo \eqdef \WriteEffect(\name)\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}\\
  \vex \eqdef \valuereadfrom(\vv, \name)
}{
  \evalstmt(\env, \SThrow(\ve, \vt)) \evalarrow
  \Throwing(\vex, \vt, \newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSThrowBegin}{\EvalSThrowEnd}{../Interpreter.ml}

\hypertarget{def-trystatementterm}{}
\section{Try Statements\label{sec:TryStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Ttry \parsesep \Nstmtlist \parsesep \Tcatch \parsesep \ListOne{\Ncatcher} \parsesep \Notherwiseopt &\\
                  & \wrappedline\ \parsesep \Tend \parsesep \Tsemicolon &\\
\Notherwiseopt \derives\ & \Totherwise \parsesep \Tarrow \parsesep \Nstmtlist &\\
               |\ & \emptysentence &\\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_try}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \STry(\stmt, \KleeneStar{\catcher}, \overtext{\stmt?}{otherwise}) &
\end{flalign*}
}

\ASTRuleDef{STry}
\begin{mathpar}
\inferrule{
  \buildlist[\Ncatcher] \astarrow \astversion{\vcatcherlist}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Ttry, \Nstmtlist, \Tcatch,  \\
    \wrappedline\ \namednode{\vcatcherlist}{\ListOne{\Ncatcher}}, \\
    \wrappedline\ \Notherwiseopt, \Tend, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{\STry(\astof{\vstmtlist}, \astversion{\vcatcherlist}, \astof{\votherwiseopt})}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{OtherwiseOpt}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-otherwiseopt}{}
The function
\[
   \buildotherwiseopt(\overname{\parsenode{\Notherwiseopt}}{\vparsednode}) \aslto
    \overname{\Option{\stmt}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[non\_empty]{
  \buildstmtlist(\vstmts) \astarrow \astversion{\vstmts}
}{
  {
  \begin{array}{r}
    \buildotherwiseopt(\overname{\Notherwiseopt(\Totherwise, \Tarrow, \namednode{\vstmts}{\Nstmtlist})}{\vparsednode}) \astarrow\\
    \astversion{\vstmts}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty]{}{
  \buildotherwiseopt(\overname{\Notherwiseopt(\emptysentence)}{\vparsednode}) \astarrow \None
}
\end{mathpar}

\subsection{Typing}

\TypingRuleDef{STry}
\ExampleDef{Typing Try Statements}
In
\listingref{semantics-catchnamed},
\listingref{semantics-catchotherwise},
\listingref{semantics-catchnone},
\listingref{semantics-nothrow}, and
\listingref{semantics-stry},
the \trystatementsterm{} are all well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a try statement with statement $\vsp$, list of catchers $\catchers$ and an \optionalterm\ \texttt{otherwise} block;
  \item annotating the statement $\vsp$ as a block statement yields $(\vspp, \vsesone)$\ProseOrTypeError;
  \item annotating each catcher $\catchers[\vi]$, for each $\vi$ in $\listrange(\catchers)$ in $\tenv$ yields $\vc\_\vi$
        and $\vxs_i$\ProseOrTypeError;
  \item $\catchersp$ is the list of annotated catchers $\vc\_\vi$ for each $\vi\in\listrange(\catchers)$;
  \item \Proseeqdef{$\vsescatchers$}{the union of all $\vxs_\vi$, for \Proselistrange{$\vi$}{$\catchers$}};
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{no\_otherwise}
    \begin{itemize}
      \item there is no \texttt{otherwise} statement;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and no \texttt{otherwise} statement,
            that is \\
            $\STry(\vspp, \catchersp, \None)$;
      \item \Proseeqdef{$\vsesotherwise$}{the empty set};
      \item \Proseeqdef{$\vsesthree$}{$\vsestwo$}.
    \end{itemize}

    \item \AllApplyCase{otherwise}
    \begin{itemize}
      \item there is an \texttt{otherwise} statement $\otherwise$;
      \item annotating the statement $\otherwise$ as a block statement in $\tenv$ yields $\otherwisep$\ProseOrTypeError;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and \texttt{otherwise} statement
            $\otherwisep$, that is \\
            $\STry(\vspp, \catchersp, \some{\otherwisep})$;
      \item \Proseeqdef{$\vsesotherwise$}{$\vsesblock$};
      \item \Proseeqdef{$\vsesthree$}{$\vsestwo$}.
    \end{itemize}

    \item \Proseeqdef{$\vses$}{the union of $\vsesthree$, $\vsescatchers$, and $\vsesotherwise$}.
  \end{itemize}
  \item $\newtenv$ is $\tenv$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_otherwise]{
  \annotateblock(\tenv, \vsp) \typearrow (\vspp, \vsesone) \OrTypeError\\\\
  \vi\in\listrange(\catchers): \annotatecatcher(\tenv, \catchers[\vi]) \typearrow (\vc_\vi, \vxs_\vi) \OrTypeError\\\\
  \catchersp \eqdef [\vi\in\listrange(\catchers) : \vc_\vi]\\\\
  \vsescatchers \eqdef \bigcup_{\vi\in\listrange(\catchers)} \vxs_\vi\\\\
  \commonprefixline\\\\
  \news \eqdef \STry(\vspp, \catchersp, \None)\\
  \vsesotherwise \eqdef \emptyset\\
  \vsesthree \eqdef \vsestwo\\\\
  \commonsuffixline\\\\
  \vses \eqdef \vsesthree \cup \vsescatchers \cup \vsesotherwise
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \None)}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv}, \vses)
}
\and
\inferrule[otherwise]{
  \annotateblock(\tenv, \vsp) \typearrow (\vspp, \vsesone) \OrTypeError\\\\
  \vi\in\listrange(\catchers): \annotatecatcher(\tenv, \catchers[\vi]) \typearrow (\vc_\vi, \vxs_\vi) \OrTypeError\\\\
  \catchersp \eqdef [\vi\in\listrange(\catchers) : \vc_\vi]\\\\
  \vsescatchers \eqdef \bigcup_{\vi\in\listrange(\catchers)} \vxs_\vi\\\\
  \commonprefixline\\\\
  \annotateblock(\tenv, \otherwise) \typearrow (\otherwisep, \vsesblock) \OrTypeError\\\\
  \news \eqdef \STry(\vspp, \catchersp, \otherwise')\\
  \vsesotherwise \eqdef \vsesblock\\
  \vsesthree \eqdef \vsestwo \\\\
  \commonsuffixline\\\\
  \vses \eqdef \vsescatchers \cup \vsesotherwise
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \some{\otherwise})}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\STryBegin}{\STryEnd}{../Typing.ml}
\identr{WVXS}

\subsection{Semantics}
\SemanticsRuleDef{STry}
\ExampleDef{Evaluation of Try Statements}
Evaluating the specification in \listingref{semantics-stry}
does not result in any Assertion error, and the specification terminates with the exit code $0$.
\ASLListing{Evaluating a \texttt{try} statement}{semantics-stry}{\semanticstests/SemanticsRule.STry.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{try} statement, $\STry(\vs, \catchers, \otherwiseopt)$;
  \item evaluating $\vsone$ in $\env$ as per \chapref{BlockStatements}
        yields the configuration $\sm$\ProseOrDynErrorDiverging;
  \item evaluating $(\catchers, \otherwiseopt, \sm)$ as per \chapref{CatchingExceptions}
        is $C$, which is the result of the entire evaluation.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalblock(\env, \vsone) \evalarrow \sm \OrDynErrorDiverging\\\\
  \evalcatchers(\env, \catchers, \otherwiseopt, \sm) \evalarrow C
}{
  \evalstmt(\env, \STry(\vsone, \catchers, \otherwiseopt)) \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalSTryBegin}{\EvalSTryEnd}{../Interpreter.ml}

\hypertarget{def-returnstatementterm}{}
\section{Return Statements\label{sec:ReturnStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Treturn \parsesep \option{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_return}
\BackupOriginalAST{
\begin{flalign*}
  \stmt \derives\ & \SReturn(\expr?) &
\end{flalign*}
}

\ASTRuleDef{SReturn}
\begin{mathpar}
\inferrule{
  \buildoption[\Nexpr](\vexpr) \astarrow \astversion{\vexpr}
}{
  \buildstmt(\overname{\Nstmt(\Treturn, \namednode{\vexpr}{\option{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SReturn(\astversion{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SReturn}

\ExampleDef{Typing Return Statements}
The \returnstatementsterm{} in
\listingref{semantics-sreturn},
\listingref{semantic-ssreturnone}, and
\listingref{semantics-sreturntuple}
are all well-typed.

The return statement \verb|return 0;| in \listingref{typing-return-bad} is ill-typed,
since \verb|proc| is not a function but a procedure.
\ASLListing{An ill-typed return statement}{typing-return-bad}{\typingtests/TypingRule.SReturn.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{error}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with an optional expression $\veopt$, that is, \\
          $\SReturn(\veopt)$;
    \item the condition that $\veopt$ is $\None$ if and only if the enclosing subprogram does not have a return type
          (that is, $\returntype$ in the \localstaticenvironmentterm{} is $\None$) does not hold;
    \item the result is an error indicating the mismatch between the declared (existence of the) return type
          and the (existence of the) return expression.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
    \item the enclosing subprogram does not have a \texttt{return} type (it is either a setter
          or a procedure);
    \item $\news$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
    \item $\newtenv$ is $\tenv$;
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with an expression $\ve$, that is, $\SReturn(\some{ \vep })$;
    \item the enclosing subprogram has a return type $\vt$;
    \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields $(\tep,\vep,\vses)$\ProseOrTypeError;
    \item checking whether $\vtep$ \typesatisfiesterm\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\news$ is a \texttt{return} statement with value $\vep$, that is, $\SReturn(\some{ \vep })$;
    \item $\newtenv$ is $\tenv$.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[error]{
  \vb \eqdef (L^\tenv.\returntype = \None \leftrightarrow \veopt = \None) \\
  \vb = \False
}{
  \annotatestmt(\tenv, \overname{\SReturn(\veopt)}{\vs}) \typearrow \TypeErrorVal{\BadSubprogramDeclaration}
}
\end{mathpar}

\begin{mathpar}
\inferrule[none]{
  L^\tenv.\returntype = \None
}{
  \annotatestmt(\tenv, \overname{\SReturn(\None)}{\vs}) \typearrow
  (\overname{\SReturn(\None)}{\news}, \overname{\tenv}{\newtenv}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  L^\tenv.\returntype = \some{ \vt }\\
  \annotateexpr(\tenv, \ve) \typearrow (\vtep, \vep, \vses) \OrTypeError\\\\
  \checktypesat(\tenv, \vtep, \vt) \typearrow \True \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SReturn(\some{ \ve })}{\vs}) \typearrow
  (\overname{\SReturn(\some{ \vep })}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SReturn}{\SReturnEnd}{../Typing.ml}
\identr{FTPK}

\subsection{Semantics}
\SemanticsRuleDef{SReturn}
\ExampleDef{No Return Value}
The specification in \listingref{semantics-sreturn} exits the procedure \texttt{println\_me}
by evaluating the \texttt{return;} statement.
\ASLListing{Evaluating a \texttt{return} statement with no value}{semantics-sreturn}{\semanticstests/SemanticsRule.SReturnNone.asl}

\ExampleDef{Returning a Single Value}
In \listingref{semantic-ssreturnone},
\texttt{return 3;} exits the function \texttt{f} with value \texttt{3}.
\ASLListing{Evaluating a \texttt{return} statement with a single value}{semantic-ssreturnone}{\semanticstests/SemanticsRule.SReturnOne.asl}

\ExampleDef{Returning a Tuple of Values}
In \listingref{semantics-sreturntuple},
\texttt{return (3, 42);} exits the function \texttt{f} with the value \texttt{(3, 42)}.
\ASLListing{Evaluating a \texttt{return} statement with a tuple of values}{semantics-sreturntuple}{\semanticstests/SemanticsRule.SReturnSome.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement, $\SReturn(\None)$;
    \item $\vvs$ is the empty list, $\emptylist$;
    \item $\newg$ is the empty graph;
    \item $\newenv$ is $\env$.
  \end{itemize}

  \item \AllApplyCase{one}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement;
    \item $\vs$ is a \texttt{return} statement for a single expression, $\SReturn(\some{\ve})$;
    \item evaluating $\ve$ in $\env$ is $\ResultExpr((\vv, \vgone), \newenv)$\ProseOrAbnormal;
    \item $\vvs$ is $[\vv]$;
    \item $\vgtwo$ is the result of adding a Write Effect for a fresh identifier and the value $\vv$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement for a list of expressions, $\SReturn(\some{\ETuple(\es)})$;
    \item evaluating each expression in $\es$ separately as per \secref{SemanticsRule.EExprListM}
    is \\ $\ResultExprListM(\ms, \newenv)$\ProseOrAbnormal;
    \item writing the list of values in $\vms$ results in $(\vvs, \newg)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}
{
  \evalstmt(\env, \SReturn(\None)) \evalarrow \Returning((\emptylist, \emptygraph), \env)
}
\end{mathpar}

\begin{mathpar}
\inferrule[one]{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \wid \in \Identifier\text{ is fresh}\\
  \writeidentifier(\wid, \vv) \evalarrow \vgtwo\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalstmt(\env, \SReturn(\some{\ve})) \evalarrow \Returning(([\vv], \newg), \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \evalexprlistm(\env, \es) \evalarrow \ResultExprListM(\ms, \newenv) \OrAbnormal\\
  \writefolder(\ms) \evalarrow (\vvs, \newg)
}{
  \evalstmt(\env, \SReturn(\some{\ETuple(\es)})) \evalarrow \Returning((\vvs, \newg), \newenv)
}
\end{mathpar}
\CodeSubsubsection{\SReturnBegin}{\EvalSReturnEnd}{../Interpreter.ml}

\SemanticsRuleDef{EExprListM}
\RenderRelation{eval_expr_list_m}
\BackupOriginalRelation{
The relation
\[
\evalexprlistm(\overname{\envs}{\env} \aslsep \overname{\KleeneStar{\expr}}{\vEs}) \;\aslrel\;
\left(
\begin{array}{cl}
\ResultExprListM(\overname{\KleeneStar{(\nativevalue\times\XGraphs)}}{\vms} \aslsep \overname{\envs}{\newenv}) & \cup\\
\overname{\TThrowing}{\ThrowingConfig} & \cup \\
\overname{\TDynError}{\DynErrorConfig} & \cup \\
\overname{\TDiverging}{\DivergingConfig}
\end{array}
\right)
\]
evaluates a list of expressions $\vEs$ in left-to-right in the initial environment $\env$
and returns the list of values associated with graphs $\vms$ and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.
} % END_OF_BACKUP_RELATION

\ExampleDef{Seperately Evaluating a List of Expressions}
In \listingref{semantics-sreturntuple}, the expressions \verb|3| and \verb|42|
are evaluated in left-to-right order in the statement \verb|return (3 , 42);|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vEs$ is an empty list;
    \item $\vms$ is then empty list.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vEs$ is a list with \head\ $\ve$ and \tail\ $\vesone$;
    \item evaluating $\ve$ in $\env$ yields $\ResultExpr(\vmone, \envone)$\ProseOrAbnormal;
    \item evaluating $\vesone$ in $\envone$ via $\evalexprlistm$ yields \\
          $\ResultExprListM(\vmsone, \newenv)$\ProseOrAbnormal;
    \item the result is a configuration consisting of a list with $\vmone$ as its \head\ and $\vmsone$
          as its \tail\ and $\newenv$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \evalexprlistm(\env, \overname{\emptylist}{\vEs}) \evalarrow \ResultExprListM(\overname{\emptylist}{\vms}, \overname{\env}{\newenv})
}
\end{mathpar}

\subsubsection{Semantics}
\begin{mathpar}
\inferrule[non\_empty]{
  \vEs = [\ve] \concat \vesone\\
  \evalexpr(\env, \ve) \evalarrow \ResultExpr(\vmone, \envone) \OrAbnormal\\
  \evalexprlistm(\envone, \vesone) \evalarrow \ResultExprListM(\vmsone, \newenv) \OrAbnormal
}{
  \evalexprlistm(\env, \vEs) \evalarrow \ResultExprListM([\vmone]\concat\vmsone, \newenv)
}
\end{mathpar}

\SemanticsRuleDef{WriteFolder}
\RenderRelation{write_folder}
\BackupOriginalRelation{
The relation
\[
  \writefolder(\overname{\KleeneStar{(\nativevalue\times\XGraphs)}}{\vms}) \aslrel (\overname{\KleeneStar{\nativevalue}}{\vvs}, \overname{\XGraphs}{\newg})
\]
concatenates the input values in $\vms$ and generates an execution graph
by composing the graphs in $\vms$ with Write Effects for the respective values.
} % END_OF_BACKUP_RELATION

\ExampleDef{Folding a List of Pairs with Values and Execution Graphs}
In \listingref{semantics-sreturntuple}, the statement \verb|return (3 , 42);|
uses $\writefolder$ to generate \\
$([\nvint(3), \nvint(42)], \emptygraph)$.
The \executiongraphterm{} is empty, since literal expressions do not yield
\executiongraphs{} and composing empty \executiongraphs{} yields an
empty \executiongraphterm{}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vms$ is the empty list;
    \item \Proseeqdef{$\vvs$}{the empty list};
    \item \Proseeqdef{$\newg$}{the empty graph}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vms$ is a list with \head{} $\vm$ and \tail{} $\vmsone$;
    \item view $\vm$ as the \nativevalueterm{} $\vv$ and the \executiongraphterm{} $\vg$;
    \item \Proseeqdef{$\wid$}{a fresh identifier};
    \item applying $\writeidentifier$ to $\wid$ and $\vv$ yields $\vgone$;
    \item applying $\writefolder$ to $\vms$ and $\vgone$ yields the pair $(\vvsone, \vgtwo)$;
    \item \Proseeqdef{$\vvs$}{the list with \head{} $\vv$ and \tail{} $\vvsone$};
    \item \Proseeqdef{$\newg$}{the ordered composition of $\vg$ and $\vgone$ with the $\aslpo$ edge
          and $\vgtwo$ with the $\asldata$ edge}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \writefolder(\overname{\emptylist}{\vms}) \evalarrow (\overname{\emptylist}{\vvs}, \overname{\emptygraph}{\newg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vms = [\vm] \concat \vmsone\\
  \vm \eqdef (\vv, \vg)\\
  \wid \in \Identifier\text{ is fresh}\\
  \writeidentifier(\wid, \vv) \evalarrow \vgone\\
  \writefolder(\vmsone, \vgone) \evalarrow (\vvsone, \vgtwo)\\
  \vvs \eqdef [\vv] \concat \vvsone\\
  \newg \eqdef \ordered{\vg}{\aslpo}{\ordered{\vgone}{\asldata}{\vgtwo}}
}{
  \writefolder(\vms) \evalarrow (\vvs, \newg)
}
\end{mathpar}

\hypertarget{def-printstatementterm}{}
\section{Print Statements\label{sec:PrintStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tprint \parsesep \ClistZero{\Nexpr} \parsesep \Tsemicolon & \\
\Nstmt \derives \ & \Tprintln \parsesep \ClistZero{\Nexpr} \parsesep \Tsemicolon & \\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_print}
\BackupOriginalAST{
\begin{flalign*}
  \stmt \derives\ & \SPrint(\overtext{\KleeneStar{\expr}}{args}, \overtext{\Bool}{newline}) &
\end{flalign*}
}

\ASTRuleDef{SPrint}
\begin{mathpar}
\inferrule{%
  \buildclist[\Nexpr](\vargs) \astarrow \astversion{\vargs} \\
  \vnewline \eqdef \False \\
}{%
  \buildstmt(\overname{\Nstmt(\Tprint, \namednode{\vargs}{\ClistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPrint(\astversion{\vargs}, \vnewline)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule{%
  \buildclist[\Nexpr](\vargs) \astarrow \astversion{\vargs} \\
  \vnewline \eqdef \True \\
  \vdebug \eqdef \False \\
}{%
  \buildstmt(\overname{\Nstmt(\Tprintln, \namednode{\vargs}{\ClistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPrint(\astversion{\vargs}, \vnewline)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SPrint}
\listingref{literals1} shows literals and their corresponding types in comments.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ denotes the print statement with arguments $\vargs$ and newline indicator $\vnewline$;
  \item annotating for each \Proselistrange{$i$}{$\vargs$}, the expression $\vargs_i$ in $\tenv$ yields $(\vt_i, \vargsp_i, \vxs_i)$\ProseOrTypeError;
  \item checking for each \Proselistrange{$i$}{$\vargs$}, that $\vt_i$ is a singular type yields $\True$\ProseOrTypeError;
  \item $\news$ denotes the print statement with arguments $\vargsp$ and newline indicator $\vnewline$;
  \item $\newtenv$ is $\tenv$;
  \item define $\vses$ as the union of the set containing a \GlobalEffectTerm{} with \purity{} $\SEImpure$ and a \LocalEffectTerm{} with \purity{} $\SEImpure$, and each set $\vxs_i$, for \Proselistrange{$i$}{$\vargs$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule{%
    \vi\in\listrange(\vargs): \annotateexpr(\tenv, \vargs[i]) \typearrow (\vt_i, \vargsp[i], \vxs_i)\OrTypeError \\\\
    \vi\in\listrange(\vargs): \techeck(\issingular(\vt_i), \UnexpectedType) \typearrow \True \OrTypeError \\\\
    \vses \eqdef \{\LocalEffect(\SEImpure), \GlobalEffect(\SEImpure)\} \cup \bigcup_{\vi\in\listrange(\vargs)} \vxs_i
  }{%
    \annotatestmt (\tenv, \overname{\SPrint(\vargs, \vnewline)}{\vs}) \typearrow (\SPrint(\vargsp, \vnewline), \tenv, \vses)
  }
\end{mathpar}
\CodeSubsection{\SPrintBegin}{\SPrintEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SPrint}

\ExampleDef{Printing Literals}
\listingref{semantics-literals} shows examples of printing various types of literals,
followed by the output to the console resulting from running the specification.
\ASLListing{Literals and how they are displayed}{semantics-literals}{\semanticstests/SemanticsRule.SPrint.asl}
% CONSOLE_BEGIN aslref \semanticstests/SemanticsRule.SPrint.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
string_number_1
0
1000000
53170898287292728730499578000
TRUE
FALSE
12345678900123456789/10000000000
0
hello\world
	 "here I am "
0xd
0x
LABEL_B
\end{Verbatim}
% CONSOLE_END

Notice that empty bitvectors are displayed as \verb|0x|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{print}
  \begin{itemize}
    \item $\vs$ denotes a \printstatementterm{} with arguments $\elist$ and newline indicator $\False$;
    \item the evaluation of $\elist$ in $\env$ is $\ResultExprList((\vlist, \vg), \newenv)$\ProseOrAbnormal;
    \item \Proseoutputtoconsole{all the elements in $\elist$, without a separator,};
    \item if $\vnewline$ is $\True$, \Proseoutputtoconsole{a newline character};
  \end{itemize}

  \item \AllApplyCase{println}
  \begin{itemize}
    \item $\vs$ denotes a \printstatementterm{} with arguments $\elist$ and newline indicator $\True$;
    \item the evaluation of the same statement with a newline indicator set to $\False$, that is,
          $\SPrint(\elist, \False)$ yields the configuration \\
          $\Continuing(\vg, \envone)$\ProseOrAbnormal;
    \item \Proseoutputtoconsole{a newline character};
  \end{itemize}
  \item the resulting configuration is $\Continuing(\vg, \newenv)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[print]{
  \evalexprlist(\env, \elist) \evalarrow \ResultExprList((\vlist, \vg), \env_1) \OrAbnormal\\
  \vi\in\listrange(\vlist): \outputtoconsole(\env_\vi, \vlist[i]) \evalarrow \env_{\vi + 1} \\
  n \eqdef \listlen{\vlist}\\
  \newenv \eqdef \env_{n + 1}
}{
  \evalstmt(\env, \SPrint(\elist, \False)) \evalarrow \Continuing(\vg, \newenv)
}
\end{mathpar}

\hypertarget{def-newline}{}
We define the newline character $\vnewline \triangleq \ascii{10}$.

\begin{mathpar}
\inferrule[println]{
  \evalstmt(\env, \SPrint(\elist, \False)) \evalarrow \Continuing(\vg, \envone) \OrAbnormal\\\\
  \outputtoconsole(\envone, \nvstring(\vnewline)) \evalarrow \newenv
}{
  \evalstmt(\env, \SPrint(\elist, \True)) \evalarrow \Continuing(\vg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSPrintBegin}{\EvalSPrintEnd}{../Interpreter.ml}

Not all ASL runtimes support printing to a console (see \RequirementRef{Printing}).
%
Therefore, the semantics is parameterized by the following function.
\RenderRelation{output_to_console}
\BackupOriginalRelation{
\[
\outputtoconsole(\overname{\envs}{\env} \aslsep \overname{\nativevalue}{\vv}) \aslto
  \overname{\envs}{\newenv}
\]
which takes a string and communicates it to a console, where one exists.
} % END_OF_BACKUP_RELATION

We now explain how printing is modelled when the runtime supports a console
(\SemanticsRuleRef{SupportedOutputToConsole})
and how it is modelled when the runtime does not support a console
(\SemanticsRuleRef{UnsupportedOutputToConsole}).

\SemanticsRuleDef{SupportedOutputToConsole}
To support a console, the definition of environments needs
to include an extra component to capture the string of characters sent to the console:
\[
\envs \triangleq \staticenvs \times \dynamicenvs \times \Strings \enspace.
\]
We omit this component in the rest of this document to avoid clutter, and include it
only here to explain the modeling of a console.

\ExampleRef{Printing Literals} shows the output to the console in a case it is supported.

\RenderRelation{literal_to_string}
\BackupOriginalRelation{
The function $\literaltostring : \literal \aslto \Strings$,
which defines how a literal is represented by a string,
} % END_OF_BACKUP_RELATION
The function is defined by \taref{literaltostringtable}.
%
Please note that surrounding quotations marks that appear in ASL text (for example, \verb|"hello"|)
are not included in string literals, and thus will not appear in the printed string.

\begin{table}
\caption{How literals should be represented as strings\label{ta:literaltostringtable}}
\begin{tabular}{rl}
\textbf{literal $\vl$} & \textbf{$\literaltostring(\vl)$} \\
\hline
$\LInt(n)$        & $n$ in decimal format, without any leading zeros, \\
                  & preceded by a ``\texttt{-}'' sign if $n$ is negative. \\
$\LBool(\True)$   & \texttt{TRUE} \\
$\LBool(\False)$  & \texttt{FALSE} \\
$\LReal(q)$       & $q$ as an irreducible fraction of positive integers, \\
                  & preceded by a ``\texttt{-}'' sign when $q$ is negative, \\
                  & with the denominator omitted if it is equal to 1. \\
$\LBitvector(b)$  & $b$ in hexadecimal, preceded by ``\texttt{0x}'', with enough leading \\
                  & zeros to make the number of hexadecimal digits printed \\
                  & equal to the width of $b$ divided by 4, and rounded up to \\
                  & the following integer.\\
$\LString(S)$     & $S$. \\
$\LLabel(s)$      & $s$. \\
\end{tabular}
\end{table}

\ProseParagraph
\AllApply
\begin{itemize}
  \item view $\env$ as the environment consisting of the \staticenvironmentterm{} $\tenv$,
        dynamic environment $\denv$, and console string $\vconsolestream$;
  \item view $\vv$ as a native literal for the literal $\vl$;
  \item \Proseeqdef{$\newenv$}{the environment consisting of the \staticenvironmentterm{} $\tenv$,
        dynamic environment $\denv$, and console string
        define as the concatenation of \\
        $\vconsolestream$ and $\literaltostring(\vl)$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqname (\tenv, \denv, \vconsolestream)\\
  \newenv \eqdef (\tenv, \denv, \vconsolestream \concat \literaltostring(\vl))
}{
  \outputtoconsole(\env, \NVLiteral(\vl)) \evalarrow (\newenv)
}
\end{mathpar}

\SemanticsRuleDef{UnsupportedOutputToConsole}
The function ignores the string value and returns the environment unchanged.

In a runtime without support for a console, the \printstatementsterm{}
in \listingref{semantics-literals} evaluate their list of expressions
with no other effect.

\ProseParagraph
\ProseEqdef{$\newenv$}{$\env$}.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \outputtoconsole(\env, \Ignore) \evalarrow \overname{\env}{\newenv}
}
\end{mathpar}

\section{The Unreachable Statement\label{sec:UnreachableStatement}}
\hypertarget{def-unreachablestatementterm}{}
\listingref{UnreachableStatement} shows an example of using an \unreachablestatementterm{}
to implement a custom form of assertion checking.
\ASLListing{An example use of an \texttt{unreachable} statement}{UnreachableStatement}{\definitiontests/UnreachableStatement.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tunreachable \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_unreachable}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SUnreachable &
\end{flalign*}
}

\ASTRuleDef{SUnreachable}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tunreachable, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SUnreachable}{\vastnode}
}
\end{mathpar}

\TypingRuleDef{SUnreachable}
\ExampleDef{Typing an Unreachable Statement}
The \unreachablestatementterm{} in \listingref{UnreachableStatement} is well-typed.

\ProseParagraph
Annotating $\SUnreachable$ in the \staticenvironmentterm{} $\tenv$ yields $(\SUnreachable, \tenv, \emptyset)$.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \annotatestmt(\tenv, \SUnreachable) \typearrow (\SUnreachable, \tenv, \overname{\emptyset}{\vses})
}
\end{mathpar}

\SemanticsRuleDef{SUnreachable}
\ExampleDef{Evaluating an Unreachable Statement}
Evaluating the specification in \listingref{UnreachableStatement} results in a \dynamicerrorterm,
since the \unreachablestatementterm{} is evaluated.

\ProseParagraph
Evaluating $\SUnreachable$ in an environment $\env$ results in a \DynamicErrorConfigurationTerm{} indicating this ($\UnreachableError$).
\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \evalstmt(\env, \SUnreachable) \evalarrow \DynamicErrorVal{\UnreachableError}
}
\end{mathpar}

\section{Pragma Statements\label{sec:PragmaStatements}}
\hypertarget{def-pragmastatementterm}{}

\ASLListing{A pragma statement}{typing-spragma}{\typingtests/TypingRule.SPragma.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tpragma \parsesep \Tidentifier \parsesep \ClistZero{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_pragma}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SPragma(\Tidentifier, \overtext{\KleeneStar{\expr}}{args}) &
\end{flalign*}
}

\ASTRuleDef{SPragma}
\begin{mathpar}
\inferrule{
  \buildclist[\Nexpr](\vargs) \astarrow \astversion{\vargs}
}{
  {
  \begin{array}{r}
    \buildstmt(\overname{\Nstmt(\Tpragma, \Tidentifier(\id), \namednode{\vargs}{\ClistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow \\
    \overname{\SPragma(\id, \astversion{\vargs})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{SPragma}
\ExampleDef{Typing a Pragma Statement}
The \pragmastatementterm{} in \listingref{typing-spragma} is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a pragma statement with identifier $\id$ and expression list $\vargs$. that is, $\SPragma(\id, \vargs)$;
  \item for each \Proselistrange{$i$}{$\vargs$}, \Proseannotateexpr{$\tenv$}{$\vargs[i]$}{$(\Ignore, \Ignore, \vxs_i)$}\ProseOrTypeError;
  \item define $\vses$ as the union of $\vxs_i$, for every \Proselistrange{$i$}{$\vargs$};
  \item define $\news$ as the \passstatementterm, that is, $\SPass$
  \item $\newtenv$ is $\tenv$;
  \item define $\vses$ as the union of $\vsess$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  i\in\listrange(\vargs): \annotateexpr(\tenv, \vargs[i]) \typearrow (\Ignore, \Ignore, \vxs_i) \OrTypeError\\\\
  \vses \eqdef \bigcup_{i\in\listrange(\vargs)} \vxs_i
}{
  \annotatestmt(\tenv, \overname{\SPragma(\id, \vargs)}{\vs}) \typearrow (\overname{\SPass}{\news}, \tenv)
}
\end{mathpar}
\CodeSubsection{\SPragmaBegin}{\SPragmaEnd}{../Typing.ml}

\subsection{Semantics\label{sec:PragmaSemantics}}
Pragmas are structures present in the \untypedast{} that are designed to be used
by third-party tools.

To avoid conflicts between different ASL parsers, it is recommended that the pragma's identifier $\Tidentifier(\id)$ be prefixed by the name of the ASL tool that supports that pragma
(e.g. ARM for Arm's internal ASL tools). An ASL language processor that does not recognise a pragma directive should generate a warning for that pragma.

Pragmas are not associated with semantics and are discarded from the \typedast.
