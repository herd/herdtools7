\chapter{Statements\label{chap:Statements}}
Statements update storage elements and determine the flow of control of a subprogram.

Statements are grammatically derived from $\Nstmt$ and represented as ASTs by $\stmt$.

\hypertarget{build-stmt}{}
The function
\[
\buildstmt(\overname{\parsenode{\Nstmt}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a statement parse node $\vparsednode$ into a statement AST node $\vastnode$.

\hypertarget{def-annotatestmt}{}
The function
\[
  \annotatestmt(\overname{\staticenvs}{\tenv} \aslsep \overname{\stmt}{\vs}) \aslto
  (\overname{\stmt}{\news} \times \overname{\staticenvs}{\newtenv} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a statement $\vs$ in an environment $\tenv$, resulting in $\news$ ---
the \typedast\ for $\vs$, which is also known as the \emph{annotated statement} ---
a modified environment $\newtenv$, and \sideeffectsetterm\ $\vses$. \ProseOtherwiseTypeError

The relation
\hypertarget{def-evalstmt}{}
\[
  \evalstmt{\overname{\envs}{\env} \aslsep \overname{\stmt}{\vs}} \;\aslrel\;
  \left(
  \begin{array}{cl}
  \overname{\TReturning}{\Returning((\vvs,\newg), \newenv)} & \cup\\
  \overname{\TContinuing}{\Continuing(\newg,\newenv)} & \cup\\
  \overname{\TThrowing}{\ThrowingConfig} & \cup \\
  \overname{\TDynError}{\DynErrorConfig} &
  \end{array}
  \right)
\]
evaluates a statement $\vs$ in an environment $\env$, resulting in one of four types of configurations
(see more details in \secref{KindsOfSemanticConfigurations}):
\begin{itemize}
  \item returning configurations with values $\vvs$, execution graph $\newg$, and a modified environment $\newenv$;
  \item continuing configurations with an execution graph $\newg$ and modified environment $\newenv$;
  \item throwing configurations;
  \item error configurations.
\end{itemize}

The rest of this chapter defines the syntax, abstract syntax, typing,
and semantics for the following kinds of statements:
\begin{itemize}
\item Pass statements (see \secref{PassStatements})
\item Assignment statements (see \secref{AssignmentStatements})
\item Setter assignment statements (see \secref{SetterAssignmentStatements})
\item Declaration statements (see \secref{DeclarationStatements})
\item Declaration statements with an elided parameter (see \secref{DeclarationStatementsElidedParameter})
\item Sequencing statements (see \secref{SequencingStatement})
\item Call statements (see \secref{CallStatements})
\item Conditional statements (see \secref{ConditionalStatements})
\item Case statements (see \secref{CaseStatements})
\item Assertion statements (see \secref{AssertionStatements})
\item While statements (see \secref{WhileStatements})
\item Repeat statements (see \secref{RepeatStatements})
\item For statements (see \secref{ForStatements})
\item Throw statements (see \secref{ThrowStatements})
\item Try statements (see \secref{TryStatements})
\item Return statements (see \secref{ReturnStatements})
\item Print statements (see \secref{PrintStatements})
\item Unreachable statements (see \secref{UnreachableStatement})
\item Pragma statements (see \secref{PragmaStatements})
\end{itemize}

\section{Pass Statements\label{sec:PassStatements}}
\hypertarget{def-passstatementterm}{}

\ASLListing{A \texttt{pass} statement}{semantics-spass}{\semanticstests/SemanticsRule.SPass.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tpass \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SPass &
\end{flalign*}

\ASTRuleDef{SPass}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tpass, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPass}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SPass}
\ExampleDef{Typing a Pass Statement}
Annotating the \passstatementterm{} in \listingref{semantics-spass} does
not modify the static environment.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a pass statement, that is, $\SPass$;
  \item $\news$ is $\vs$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}{\annotatestmt(\tenv, \SPass) \typearrow (\SPass, \tenv, \overname{\emptyset}{\vses})}
\end{mathpar}
\CodeSubsection{\SPassBegin}{\SPassEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SPass}
\ExampleDef{Evaluation of Pass Statements}
In \listingref{semantics-spass}, \texttt{pass;} does not modify the environment.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vs$ is a \passstatementterm, $\SPass$;
\item $\newg$ is the empty graph;
\item $\newenv$ is $\env$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \evalstmt{\env, \SPass} \evalarrow \Continuing(\overname{\emptygraph}{\newg}, \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalSPassBegin}{\EvalSPassEnd}{../Interpreter.ml}

\hypertarget{def-assignmentstatementterm}{}
\section{Assignment Statements\label{sec:AssignmentStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Nlexpr \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SAssign(\lexpr, \expr) &
\end{flalign*}

\ASTRuleDef{SAssign}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\punnode{\Nlexpr}, \Teq, \punnode{\Nexpr}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SAssign(\astof{\vlexpr}, \astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SAssign}
\ExampleDef{Typing an Assignment Statement}
In \listingref{semantics-sassign}, the assignment \verb|x = 3;|
is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assignment \texttt{le = re}, that is, $\SAssign(\vle, \vre)$;
  \item annotating the right-hand-side expression $\vre$ in $\tenv$ yields $(\vtre, \vreone, \vsesre)$\ProseOrTypeError;
  \item annotating the \assignableexpression\ $\vle$ with the type $\vtre$ in $\tenv$ yields \\ $(\vleone, \vsesle)$\ProseOrTypeError;
  \item $\news$ is the assignment \texttt{le1 = re1}, that is, $\SAssign(\vleone, \vreone)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesre$ and $\vsesle$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vre} \typearrow (\vtre, \vreone, \vsesre) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vle, \vtre} \typearrow (\vleone, \vsesle) \OrTypeError\\\\
  \vses \eqdef \vsesre \cup \vsesle
}{
  \annotatestmt(\tenv, \overname{\SAssign(\vle, \vre)}{\vs}) \typearrow
  (\overname{\SAssign(\vleone, \vreone)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SAssignBegin}{\SAssignEnd}{../Typing.ml}

\subsection{Semantics}
There are two rules for evaluating assignments:
\begin{itemize}
\item \SemanticsRuleRef{SAssignCall} handles assignments where the right-hand-side expression
      is a \callexpressionterm{} and the left-hand-side expression is a tuple.
\item \SemanticsRuleRef{SAssign} handles all other assignments.
\end{itemize}

Although the sequential semantics of both types of statements is the same,
\SemanticsRuleRef{SAssignCall} generates a different execution graph ---
one where each value of the left-hand-side tuple depends on the \executiongraph{}
for the corresponding (that is, at the same position) value returned from the \callexpressionterm{}.
In contrast, the \executiongraph{} generated by \SemanticsRuleRef{SAssign}
creates dependencies between the entire \executiongraph{} for the evaluated right-hand-side
expression and the entire \executiongraph{} for the left-hand-side \executiongraph{}.

The rules for assignments first produce a value for the right-hand side expression
and then complete the update to the environment via an appropriate rule for evaluating the
\assignableexpression{} on the left-hand-side of the assignment,
which in turn handles variables, tuples, bitvectors, etc.

\SemanticsRuleDef{SAssignCall}
\ExampleDef{Evaluation of Multi-variable Assignment from Subprogram Calls}
In \listingref{assigncallsemantics}, given that the function call \texttt{f(1)} returns a triple of values ---
$\nvint(1)$, $\nvint(2)$, and $\nvint(3)$
(each with its own associated execution graph),
the statement \texttt{(a,b,-) = f(1)} assigns the value $\nvint(1)$ to the mutable variable \texttt{a},
$\nvint(2)$ to the mutable variable~\texttt{b}, and discards $\nvint(3)$.

\ASLListing{Assignment from a call expression.}{assigncallsemantics}{\semanticstests/SemanticsRule.SAssignCall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ assigns an \assignableexpression\ list from a subprogram call, \\
        $\SAssign(\LEDestructuring(\les),\ECall(\vcall))$;
  \item $\les$ is a list of \assignableexpressions, each of which is either \\ a variable ($\LEVar(\Ignore)$)
        or a discarded variable (\LEDiscard);
  \item evaluating the subprogram call as per \chapref{SubprogramCalls} is
        $\Normal(\vms, \envone)$\ProseOrAbnormal;
  \item assigning each value in $\vms$ to the respective element of the tuple $\les$ is \\
        $\Normal(\vgtwo, \newg)$\ProseOrAbnormal.
\end{itemize}

\FormallyParagraph
\hypertarget{def-lexprisvar}{}
The rule uses the syntactic predicate defined as follows:
\[
  \lexprisvar(\lexpr) \aslto \True
\]
which holds when a left-hand side expression
represents a variable or a discarded left-hand-side expression:
\begin{mathpar}
\inferrule{}{ \lexprisvar(\vle) \evalarrow \astlabel(\vle) \in \{\LEVar, \LEDiscard\}}
\end{mathpar}

The inference rules defining the evaluation of assigning
from a subprogram call are as follows:
\begin{mathpar}
\inferrule{
  \vles \eqdef \vle_{1..k}\\
  i=1..k: \lexprisvar(\vle_i) \evalarrow \True\\
  \evalcall(\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs) \evalarrow \Normal(\vms, \envone) \OrAbnormal\\\\
  \evalmultiassignment(\envone, \vles, \vms) \evalarrow \Normal(\newg, \newenv) \OrAbnormal
}{
  \evalstmt{\env, \SAssign(\LEDestructuring(\les),\ECall(\vcall))} \\
  \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSAssignCallBegin}{\EvalSAssignCallEnd}{../Interpreter.ml}

\SemanticsRuleDef{SAssign}
\ExampleDef{Evaluation of Assignment Statements}
In \listingref{semantics-sassign},
\texttt{x = 3;} binds \texttt{x} to $\nvint(3)$ in the environment where \texttt{x} is bound to
$\nvint(42)$, and $\newenv$ is such that \texttt{x} is bound to $\nvint(3)$.
\ASLListing{Evaluating an assignment}{semantics-sassign}{\semanticstests/SemanticsRule.SAssign.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assignment statement, $\SAssign(\vle, \vre)$;
  \item \OneApplies
  \begin{itemize}
    \item $\vre$ is not a call expression;
    \item $\vle$ is not a multi-var expression (that is, not a $\LEDestructuring$);
    \item $\vle$ is a multi-var expression, but one of its components is neither a variable
          nor a discarded variable.
  \end{itemize}
  \item evaluating the expression $\vre$ in $\env$ yields
        $\Normal(\vm, \envone)$ (here, $\vm$ is a pair consisting of a value and an execution graph)\ProseOrAbnormal;
  \item evaluating the \assignableexpression\ $\vle$ with $\vm$ in $\envone$,
        as per \chapref{AssignableExpressions}, yields $\Normal(\newg, \newenv)$\ProseOrAbnormal.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {\left(
  \begin{array}{c}
  \astlabel(\vle) \neq \LEDestructuring\ \lor \\
  \astlabel(\vre) \neq \ECall\ \lor\\
  \vle = \LEDestructuring(\les) \land \exists \vi\in\listrange(\vle).\ \neg\lexprisvar(\vle[\vi])
  \end{array}
  \right)
  }\\
  \evalexpr{\env, \vre} \evalarrow \Normal(\vm, \envone) \OrAbnormal\\
  \evallexpr{\envone, \vle, \vm} \evalarrow \Normal(\newg, \newenv) \OrAbnormal
}{
  \evalstmt{\env, \SAssign(\vle, \vre)} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSAssignBegin}{\EvalSAssignEnd}{../Interpreter.ml}

\section{Setter Assignment Statements\label{sec:SetterAssignmentStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \
   & \Ncall \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Ncall \parsesep \Tdot \parsesep \Tidentifier \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Ncall \parsesep \Tdot \parsesep \Tlbracket \parsesep \Clisttwo{{\Tidentifier}} \parsesep \Trbracket \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
\end{flalign*}

\ASTRuleDef{MakeSetter}
\hypertarget{def-makesetter}{}
The helper function
\[
\makesetter(
  \overname{\call}{\vcall} \aslsep
  \overname{\expr}{\varg}) \aslto \overname{\call}{\vcallp}
\]
constructs a setter call $\vcallp$ using a base call $\vcall$ and right-hand side $\varg$.

\begin{mathpar}
\inferrule{}{
  \makesetter(\vcall, \varg) \aslto
    \overname{\left\{
      \begin{array}{rcl}
        \callname &:& \vcall.\callname,\\
        \callparams &:& \vcall.\callparams,\\
        \callargs &:& [\varg]\concat\vcall.\callargs,\\
        \callcalltype &:& \STSetter
      \end{array}
    \right\}}{\vcallp}
}
\end{mathpar}

\ASTRuleDef{DesugarSetter}
\hypertarget{def-desugarsetter}{}
The helper function
\[
\desugarsetter(
  \overname{\call}{\vcall} \aslsep
  \overname{\identifier^*}{\fields} \aslsep
  \overname{\expr}{\rhs}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from an assignment of expression $\rhs$ to a setter invocation $\vcall$$\name$ with field accesses $\fields$.

\begin{mathpar}
\inferrule[empty]{
  \fields \eqname \emptylist \\
  \makesetter(\vcall, \rhs) \aslto \vcallp
}{
  \desugarsetter(\vcall, \fields, \rhs)
  \astarrow
  \SCall(\vcallp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[singleton]{
  \fields \eqname [\field] \\
  \vx \in \Identifiers \text{ is fresh} \\\\
  \setcalltype(\vcall, \STGetter) \aslto \vgetter \\\\
  \vread \eqdef \SDecl(\LDKVar, \LDIVar(\vx), \None, \langle\vgetter\rangle) \\\\
  \vmodify \eqdef \SAssign(\LESetField(\LEVar(\vx), \field), \rhs) \\\\
  \makesetter(\vcall, \EVar(\vx)) \aslto \vsetter
}{
  \desugarsetter(\vcall, \fields, \rhs)
  \astarrow
  \SSeq (\SSeq(\vread, \vmodify), \SCall(\vsetter))
}
\end{mathpar}

\begin{mathpar}
\inferrule[multiple]{
  \listlen{\fields} > 1 \\
  \vx \in \Identifiers \text{ is fresh} \\\\
  \setcalltype(\vcall, \STGetter) \aslto \vgetter \\\\
  \vread \eqdef \SDecl(\LDKVar, \LDIVar(\vx), \None, \langle\vgetter\rangle) \\\\
  \vmodify \eqdef \SAssign(\LESetFields(\LEVar(\vx), \fields), \rhs) \\\\
  \makesetter(\vcall, \EVar(\vx)) \aslto \vsetter
}{
  \desugarsetter(\vcall, \fields, \rhs)
  \astarrow
  \SSeq (\SSeq(\vread, \vmodify), \SCall(\vsetter))
}
\end{mathpar}

\ASTRuleDef{SetterAssign}
\begin{mathpar}
\inferrule{
  \desugarsetter(\astof{\vcall}, \emptylist, \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\call}, \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \desugarsetter(\astof{\vcall}, [\vfield], \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\call}, \Tdot,
    \Tidentifier(\vfield), \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildclist[\buildidentity](\vfields) \astarrow \vfieldasts \\
  \desugarsetter(\astof{\vcall}, \vfieldasts, \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\call}, \Tdot,
    \Tlbracket, \namednode{\vfields}{\Clisttwo{\Tidentifier}}, \Trbracket, \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\subsection{Typing and semantics}
As given by applying the relevant rules to the desugared AST.

\hypertarget{def-declarationstatementterm}{}
\section{Declaration Statements\label{sec:DeclarationStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \option{\Nasty} \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Ndeclitem \parsesep \option{\Nasty} \parsesep \option{\Teq \parsesep \Nexpr} \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Clisttwo{\Tidentifier} \parsesep \Nasty \parsesep \Tsemicolon &\\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SDecl(\localdeclkeyword, \localdeclitem, \ty?, \expr?)
\end{flalign*}

\ASTRuleDef{SDecl}
\begin{mathpar}
\inferrule[let\_constant]{
  \buildoption[\buildasty](\vt) \astarrow \astversion{\vt}
}{
  {
  \begin{array}{r}
  \buildstmt(\overname{\Nstmt(\Nlocaldeclkeyword, \Ndeclitem, \namednode{\vt}{\option{\Nasty}}, \Teq, \punnode{\Nexpr}, \Tsemicolon)}{\vparsednode})
  \astarrow\\
  \overname{\SDecl(\astof{\vlocaldeclkeyword}, \astof{\vdeclitem}, \astversion{\vt}, \langle\astof{\vexpr}\rangle)}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[var]{
  \buildoption[\buildasty](\vt) \astarrow \astversion{\vt} \\
  \buildoption[\buildexpr](\ve) \astarrow \astversion{\ve}
}{
  {
  \begin{array}{r}
    \buildstmt(\overname{\Nstmt(\Tvar, \Ndeclitem, \namednode{\vt}{\option{\Nasty}}, \namednode{\ve}{\option{\Teq, \Nexpr}}, \Tsemicolon)}{\vparsednode})
    \astarrow \\
    \overname{\SDecl(\LDKVar, \astof{\vdeclitem}, \astversion{\vt}, \astversion{\ve})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[multi\_var]{
  \buildclist[\buildidentity](\vids) \astarrow \astversion{\vids}\\
  \buildasty(\vt) \astarrow \astversion{\vt} \\
  \vstmts \eqdef [\vx\in\astversion{\vids}: \SDecl(\LDKVar, \vx, \astversion{\vt}, \None)]\\
  \stmtfromlist(\vstmts) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\Tvar, \namednode{\vids}{\Clisttwo{\Tidentifier}}, \namednode{\vt}{\Nasty}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \vastnode
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SDecl}
\ExampleDef{Typing Declaration Statements}
\listingref{typing-sdecl} shows well-typed declaration statements
and ill-typed declaration statements in comments.
\ASLListing{Typing declaration statements}{typing-sdecl}{\typingtests/TypingRule.SDecl.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApply
  \begin{itemize}
    \item $\vs$ is a declaration with an initializing expression $\ve$,
          that is, \\
          $\SDecl(\ldk, \ldi, \tyopt, \langle\ve\rangle)$;
    \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte,\vep, \vsese)$\ProseOrTypeError;
    \item applying $\annotatelocaldecltypeannot$ to the environment $\tenv$, type annotation $\tyopt$, type $\vte$, local declaration keyword $\ldk$, expression $\vep$, and local declaration item $\ldi$ yields $(\tenvone, \tyoptp, \vsesldi)$\ProseOrTypeError;
    \item \Proseeqdef{$\vses$}{the union of $\vsese$ and $\vsesldi$};
    \item \OneApplies
    \begin{itemize}
      \item \AllApplyCase{constant}
      \begin{itemize}
        \item $\ldk$ indicates a local constant declaration, that is, $\LDKConstant$;
        \item checking that all \timeframesterm\ in $\vsese$ are before \timeframeconstant\ yields \\
              $\True$\ProseOrTypeError;
        \item symbolically simplifying $\ve$ in $\tenvone$ yields the literal $\vv$\ProseOrTypeError;
        \item declaring a local constant with literal $\vv$ and local declaration item $\ldi$ in $\tenvone$ yields $\newtenv$;
        \item $\news$ is a declaration with $\ldk$, $\ldi$, type annotation $\tyoptp$, and an expression $\vep$.
      \end{itemize}

      \item \AllApplyCase{non\_constant}
      \begin{itemize}
        \item $\ldk$ indicates that this is not a local constant declaration, that is, $\ldk\neq\LDKConstant$;
        \item $\news$ is a declaration with $\ldk$, $\ldi$, type annotation $\tyoptp$, and an expression $\vep$;
        \item $\newtenv$ is $\tenvone$.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
  \item $\vs$ is a local declaration statement with a variable keyword and no initializing expression,
        that is, $\SDecl(\LDKVar, \ldi, \tyopt, \None)$ (local declarations of \texttt{let} variables and constants require
        an initializing expression, otherwise they are rejected by an ASL parser);
  \item $\tyopt$ is $\langle\vt\rangle$\ProseOrTypeError;
  \item annotating $\vt$ in $\tenv$ yields $(\vtp, \vses)$\ProseOrTypeError;
  \item applying $\basevalue$ to $\vtp$ in $\tenv$ yields $\veinit$\ProseOrTypeError;
  \item annotating the local declaration item $\ldi$ with the type $\vtp$ and local declaration keyword $\LDIVar$
        yields $\newtenv$\ProseOrTypeError;
  \item define $\news$ as local declaration statement with variable keyword, local declaration item $\ldi$, type annotation $\vtp$, and initializing expression $\veinit$, that is, $\SDecl(\LDKVar, \ldi, \langle\veinit\rangle)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[constant]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep, \vsese) \OrTypeError\\\\
  {
  \begin{array}{r}
  \annotatelocaldecltypeannot(\tenv, \tyopt, \vte, \ldk, \vep, \ldi) \typearrow \\
  (\tenvone, \tyoptp, \vsesldi) \OrTypeError
  \end{array}
  }\\
  \vses \eqdef \vsese \cup \vsesldi\\\\
  \commonprefixline\\\\
  \ldk = \LDKConstant\\
  \checktrans{\sesisbefore(\vsese, \timeframeconstant)}{\SideEffectViolation} \typearrow \True \OrTypeError\\\\
  \staticeval(\tenvone, \ve) \typearrow \vv \OrTypeError\\\\
  \declarelocalconstant(\tenvone, \vv, \ldi) \typearrow \newtenv\\
  \news \eqdef \SDecl(\LDKConstant, \ldi, \tyoptp, \langle\vep\rangle)
}{
  \annotatestmt(\tenv, \overname{\SDecl(\ldk, \ldi, \tyopt, \langle\ve\rangle)}{\vs}) \typearrow (\news, \newtenv, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_constant]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep, \vsese) \OrTypeError\\\\
  {
  \begin{array}{r}
  \annotatelocaldecltypeannot(\tenv, \tyopt, \vte, \ldk, \vep, \ldi) \typearrow \\
  (\tenvone, \tyoptp, \vsesldi) \OrTypeError
  \end{array}
  }\\
  \vses \eqdef \vsese \cup \vsesldi\\\\
  \commonprefixline\\\\
  \ldk \neq \LDKConstant\\
  \news \eqdef \SDecl(\ldk, \ldi, \tyoptp, \langle\vep\rangle)
}{
  \annotatestmt(\tenv, \overname{\SDecl(\ldk, \ldi, \tyopt, \langle\ve\rangle)}{\vs}) \typearrow (\news, \overname{\tenvone}{\newtenv}, \vses)
}
\end{mathpar}
\identr{YSPM}

\begin{mathpar}
\inferrule[none]{
  \checktrans{\tyopt = \langle\Ignore\rangle}{\TypeErrorVal{\BadDeclaration}} \typearrow \True \OrTypeError \\
  \tyopt \eqname \langle\vt\rangle \\
  \annotatetype{\tenv, \vt} \typearrow (\vtp, \vses) \OrTypeError\\\\
  \basevalue(\tenv, \vtp) \typearrow \veinit \OrTypeError\\\\
  \annotatelocaldeclitem(\tenv, \vtp, \LDKVar, \None, \ldip) \typearrow \newtenv \OrTypeError \\
  \news \eqdef \SDecl(\LDKVar, \ldi, \langle\vtp\rangle, \langle\veinit\rangle)
}{
  \annotatestmt(\tenv, \overname{\SDecl(\LDKVar, \ldi, \tyopt, \None)}{\vs}) \typearrow (\news, \newtenv, \vses)
}
\end{mathpar}
\CodeSubsection{\SDeclegin}{\SDeclEnd}{../Typing.ml}

\TypingRuleDef{DeclareLocalConstant}
\hypertarget{def-declarelocalconstant}{}
The helper function
\[
\declarelocalconstant(\overname{\staticenvs}{\tenv} \aslsep \overname{\literal}{\vv} \aslsep \overname{\localdeclitem}{\ldi})
\typearrow \overname{\staticenvs}{\newtenv}
\]
adds the literal $\vv$ with the local declaration item $\ldi$ as a constant to the local component of the static environment $\tenv$,
yielding the modified static environment $\newtenv$.

\ExampleDef{Typing Local Constant Declarations}
In \listingref{typing-sdecl},
the declaration statement
\verb|constant c1 : integer{1..1000} = 42;|
updates the static environment by binding \verb|c1| to $\lint(42)$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{var}
  \begin{itemize}
    \item $\ldi$ corresponds to a variable declaration for $\vx$, that is, $\LDIVar(\vx)$;
    \item applying $\addlocalconstant$ to $\vx$ and $\vv$ in $\tenv$ yields $\newtenv$.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\ldi$ corresponds to a tuple declaration, that is, $\LDIVar(\Ignore)$;
    \item this case is not yet implemented.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[var]{
  \addlocalconstant(\tenv, \vx, \vv) \typearrow \newtenv
}{
  \declarelocalconstant(\tenv, \vv, \overname{\LDIVar(\vx)}{\ldi}) \typearrow \newtenv
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{}{
  \declarelocalconstant(\tenv, \vv, \overname{\LDITuple(\Ignore)}{\ldi}) \typearrow \tododefine{not implemented yet}
}
\end{mathpar}
\CodeSubsection{\DeclareLocalConstantBegin}{\DeclareLocalConstantEnd}{../Typing.ml}

\TypingRuleDef{AnnotateLocalDeclTypeAnnot}
\hypertarget{def-annotatelocaldecltypeannot}{}
The helper function
\[
\begin{array}{r}
  \annotatelocaldecltypeannot
  \left(
  \begin{array}{c}
    \overname{\staticenvs}{\tenv} \aslsep \\
    \overname{\langle\ty\rangle}{\tyopt} \aslsep \\
    \overname{\ty}{\vte} \aslsep \\
    \overname{\localdeclkeyword}{\ldk} \aslsep \\
    \overname{\expr}{\vep} \aslsep\\
    \overname{\localdeclitem}{\ldi}
  \end{array}
  \right)
  \typearrow \\
  \left(
  \begin{array}{cl}
    \left(\overname{\staticenvs}{\newtenv} \aslsep \overname{\langle\ty\rangle}{\tyoptp} \aslsep \overname{\TSideEffectSet}{\vses}\right)
    & \cup \\
    \overname{\TTypeError}{\TypeErrorConfig} &
  \end{array}
  \right)
\end{array}
\]
annotates the type annotation $\tyopt$ in the static environment $\tenv$ within the context of a local declaration with keyword $\ldk$, item $\ldi$, and initializing expression $\vep$ with type $\vte$.
It yields the modified static environment $\newtenv$, the annotated type annotation $\tyoptp$, and the inferred \sideeffectsetterm{} $\vses$.
\ProseOtherwiseTypeError

See \ExampleRef{Typing Declaration Statements}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\tyopt$ is $\None$;
    \item \Prosenoprecisionloss{\vte};
    \item $\newtenv$ is the result of $\annotatelocaldeclitem(\tenv, \vte, \ldk, \langle\vep\rangle, \ldi)$\ProseOrTypeError;
    \item $\tyoptp$ is $\tyopt$;
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\tyopt$ is $\langle\vt\rangle$;
    \item determining the \structure{} of $\vte$ in $\tenv$ yields $\vtep$\ProseOrTypeError;
    \item propagating integer constraints from $\vtep$ to $\vt$ using $\inheritintegerconstraints$ yields $\vtp$\ProseOrTypeError;
    \item annotating the type $\vtp$ in $\tenv$ yields $(\vtpp, \vses)$\ProseOrTypeError;
  \item determining whether $\vtpp$ can be initialized with $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the local declaration item $\ldi$ with the local declaration keyword $\ldk$, given
  the expression $\vep$, in the environment $\tenv$, yields $\newtenv$;
  \item $\tyoptp$ is $\langle\vtpp\rangle$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{
  \annotatelocaldeclitem(\tenv, \vte, \ldk, \langle\vep\rangle, \ldi) \typearrow \newtenv \OrTypeError
}{
  \annotatelocaldecltypeannot(\tenv, \None, \vte, \ldk, \vep, \ldi) \typearrow (\newtenv, \overname{\None}{\tyoptp}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \tstruct(\tenv, \vte) \typearrow \vtep \OrTypeError \\
  \inheritintegerconstraints(\vt, \vtep) \typearrow \vtp \OrTypeError \\
  \annotatetype{\tenv, \vtp} \typearrow (\vtpp, \vses) \OrTypeError\\\\
  \checkcanbeinitializedwith(\tenv, \vtpp, \vte) \typearrow \True \OrTypeError\\\\
  \annotatelocaldeclitem(\tenv, \vtpp, \ldk, \langle \vep \rangle, \ldip) \typearrow \newtenv \OrTypeError
}{
  \annotatelocaldecltypeannot(\tenv, \langle\vt\rangle, \vte, \ldk, \vep, \ldi) \typearrow (\newtenv, \overname{\langle\vtpp\rangle}{\tyoptp}, \vses)
}
\end{mathpar}

\TypingRuleDef{InheritIntegerConstraints}
\hypertarget{def-inheritintegerconstraints}{}
The helper function
\[
\inheritintegerconstraints(\overname{\ty}{\lhs} \aslsep \overname{\ty}{\rhs})
\aslto \overname{\ty}{\lhsp} \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
propagates integer constraints from the right-hand side type $\rhs$ to the left-hand side type annotation $\lhs$.
In particular, each occurrence of \pendingconstrainedintegertype{} on the left-hand side should inherit constraints from a corresponding \wellconstrainedintegertype{} on the right-hand side.
If the corresponding right-hand side type is not a \wellconstrainedintegertype{} (including if it is an \unconstrainedintegertype{}), the result is a \typingerrorterm{}.

\listingref{typing-pendingconstrained} shows examples of pending-constrained
integer types.

\ExampleDef{Pending-constrained integer type vs. unconstrained integer type}
\listingref{pending-constrained-unconstrained} corresponds to the \typingerrorterm{}
in the \CaseName{int} below.
\ASLListing{An ill-typed pending-constrained integer type}{pending-constrained-unconstrained}
{\typingtests/TypingRule.InheritIntegerConstraints.unconstrained.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{int}
  \begin{itemize}
    \item $\lhs$ is a \pendingconstrainedintegertype{};
    \item \Prosenoprecisionloss{$\rhs$};
    \item checking that $\rhs$ is a \wellconstrainedintegertype{} yields $\True$\ProseOrTypeError;
    \item \Proseeqdef{$\lhsp$}{$\rhs$}.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\lhs$ is a tuple of types $\vlhstys$;
    \item $\rhs$ is a tuple of types $\vrhstys$;
    \item checking that the lengths of $\vlhstys$ and $\vrhstys$ are equal yields $\True$\ProseOrTypeError;
    \item define $\vlhstysp$ by applying $\inheritintegerconstraints$ to each element of \\
         $ \vlhstys$ and $\vrhstys$\ProseOrTypeError;
    \item \Proseeqdef{$\lhsp$}{$\TTuple(\vlhstysp)$}.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\lhs$ is not a \pendingconstrainedintegertype{}, or one of $\lhs$ and $\rhs$ is not a \tupletypeterm{};
    \item \Proseeqdef{$\lhsp$}{$\lhs$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[int]{
  \checknoprecisionloss{\rhs} \typearrow \True \OrTypeError\\\\
  \checktrans{\iswellconstrainedinteger(\rhs)}{\UnexpectedType} \checktransarrow \True\OrTypeError
}{
  \inheritintegerconstraints(\overname{\TInt(\pendingconstrained)}{\lhs}, \rhs) \typearrow \overname{\rhs}{\lhsp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \lhs = \TTuple(\vlhstys) \\
  \rhs = \TTuple(\vrhstys) \\\\
  \checktrans{\equallength(\vlhstys, \vrhstys)}{\UnexpectedType} \typearrow \True \OrTypeError \\\\
  {
  \begin{array}{r}
  \vi \in \listrange(\lhs): \inheritintegerconstraints(\vlhstys_\vi, \vrhstys_\vi) \typearrow \\
  \vlhstysp_\vi \OrTypeError
  \end{array}
  }
}{
  \inheritintegerconstraints(\lhs, \rhs) \typearrow \overname{\TTuple(\vlhstysp)}{\lhsp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \lhs \neq \TInt(\pendingconstrained) \lor \astlabel(\lhs) \neq \TTuple \lor \astlabel(\rhs) \neq \TTuple
}{
  \inheritintegerconstraints(\lhs, \rhs) \typearrow \overname{\lhs}{\lhsp}
}
\end{mathpar}

\TypingRuleDef{CheckNoPrecisionLoss}
\hypertarget{def-checknoprecisionloss}{}
The helper function
\[
  \checknoprecisionloss{\overname{\ty}{\vt}}
  \typearrow \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the type $\vt$ is the result of a precision loss in its
constraint computation (see for example \TypingRuleRef{ApplyBinopTypes}).

\ExampleDef{Rejected Declaration Because of Precision Loss}
In \listingref{typing-imprecisetype}, the statement \verb|var b = a * a;|
corresponds to the \typingerrorterm{} raised in the \CaseName{Well-Constrained}
below.
The type of the right-hand-side (\texttt{a * a}) is imprecise because the multiplication of two
constant types would result in more than $2^17$ elements, see
\TypingRuleRef{ApplyBinopTypes}.
\ASLListing{Type-checking a declaration with an imprecise type}{typing-imprecisetype}{\typingtests/TypingRule.CheckNoPrecisionLoss.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{Well-Constrained}
    \begin{itemize}
      \item $\vt$ is a \wellconstrainedintegertype{} with a precision $\PrecisionFull$ or $\vt$ is a \wellconstrainedintegertype{} with a precision $\PrecisionLost$
      \item a \typingerrorterm{} is raised;
    \end{itemize}
  \item \AllApplyCase{Integer}
    \begin{itemize}
      \item $\vt$ is not a \wellconstrainedintegertype{};
      \item no \typingerrorterm{} is raised.
    \end{itemize}
  \item \AllApplyCase{Other}
    \begin{itemize}
      \item $\vt$ is not an \integertypeterm{};
      \item no \typingerrorterm{} is raised.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[Well-Constrained]{%
    \checktrans{p = \PrecisionFull}{PrecisionLostDefining}
  }{%
    \checknoprecisionloss{\overname{\TInt(\wellconstrained(\Ignore, p))}{\vt}} \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Integer]{%
    \astlabel(\vc) \neq \wellconstrained
  }{%
    \checknoprecisionloss{\overname{\TInt(\vc)}{\vt}} \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Other]{%
    \astlabel(\vt) \neq \TInt
  }{%
    \checknoprecisionloss{\vt} \typearrow \True
  }
\end{mathpar}

\CodeSubsection{\CheckNoPrecisionLossBegin}{\CheckNoPreciisonLossEnd}{../Typing.ml}

\TypingRuleDef{CheckCanBeInitializedWith}
\hypertarget{def-checkcanbeinitializedwith}{}
The helper function
\[
\checkcanbeinitializedwith(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vs} \aslsep \overname{\ty}{\vt})
\typearrow \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether an expression of type $\vs$ can be used to initialize a storage element of type $\vt$ in the static environment
$\tenv$.
If the answer if $\False$, the result is a \typingerrorterm.

See \ExampleRef{Type-satisfaction Examples}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item testing whether $\vt$ \typesatisfies\ $\vs$ in $\tenv$ yields $\True$;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item testing whether $\vt$ \typesatisfies\ $\vs$ in $\tenv$ yields $\False$;
    \item the result is a \typingerrorterm{} indicating that an expression of type $\vs$ cannot
          be used to initialize a storage element of type $\vt$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}{
  \checkcanbeinitializedwith(\tenv, \vs, \vt) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \typesat(\tenv, \vt, \vs) \typearrow \False
}{
  \checkcanbeinitializedwith(\tenv, \vs, \vt) \typearrow \TypeErrorVal{\TypeSatisfactionFailure}
}
\end{mathpar}
\identr{ZCVD}  \identr{LXQZ}


\subsection{Semantics}
\SemanticsRuleDef{SDeclSome}
\ExampleDef{Declaration With an Initializing Value}
In \listingref{semantics-sdeclsome},
\texttt{let x = 3;} binds \texttt{x} to $\nvint(3)$ in the empty environment.
\ASLListing{Evaluating a declaration with a given initial value}{semantics-sdeclsome}{\semanticstests/SemanticsRule.SDeclSome.asl}

\ExampleDef{Declaration Without an Initializing Value}
In \listingref{semantics-sdeclnone},
\texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.
\ASLListing{Evaluating a declaration without a given initial value}{semantics-sdeclnone}{\semanticstests/SemanticsRule.SDeclNone.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a declaration with an initial value,
    $\SDecl(\Ignore, \ldi, \Ignore, \langle\ve\rangle)$;
    \item evaluating $\ve$ in $\env$ is $\Normal(\vm, \envone)$\ProseOrAbnormal;
    \item evaluating the local declaration $\ldi$ with $\vm$ as the initializing
    value in $\envone$ as per \chapref{LocalStorageDeclarations} is $\Normal(\newg, \newenv)$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a declaration without an initial value, $\SDecl(\Ignore, \ldi, \Ignore, \None)$;
    \item the result is a dynamic error.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[some]{
  \evalexpr{\env, \ve} \evalarrow \Normal(\vm, \envone) \OrAbnormal\\
  \evallocaldecl{\envone, \ldi, \vm} \evalarrow \Normal(\newg, \newenv)\\
}{
  \evalstmt{\env, \SDecl(\Ignore, \ldi, \Ignore, \langle\ve\rangle)} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[none]{}{
  \evalstmt{\env, \SDecl(\Ignore, \ldi, \Ignore, \None)} \evalarrow \DynamicErrorVal{UninitialisedDecl}
}
\end{mathpar}
\CodeSubsection{\EvalSDeclBegin}{\EvalSDeclEnd}{../Interpreter.ml}

\section{Declaration statements with an elided parameter \label{sec:DeclarationStatementsElidedParameter}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \
   & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \Nasty \parsesep \Teq \\
   & \wrappedline\ \Nelidedparamcall \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Ndeclitem \parsesep \Nasty \parsesep \Teq \parsesep \Nelidedparamcall \parsesep \Tsemicolon &\\
\end{flalign*}

\begin{flalign*}
\Nelidedparamcall \derives \
     & \Tidentifier \parsesep \Tlbrace \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Trbrace \parsesep \PlistZero{\Nexpr} &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Tcomma \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Tcomma \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace \parsesep \PlistZero{\Nexpr}&
\end{flalign*}

\ASTRuleDef{ElidedParamCall}
\hypertarget{build-elided-param-call}{}
The helper function $\buildelidedparamcall$ builds a $\call$ from a parsed \\
$\Nelidedparamcall$.

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlpar, \Trpar))
  \astarrow \vastnode
}{
  \buildelidedparamcall(\Nelidedparamcall (\Tidentifier(\id), \Tlbrace, \Trbrace))
  \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \vargs))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
      \buildelidedparamcall(\Nelidedparamcall \\
        \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}}))
      \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlbrace, \vparams, \Trbrace))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
      \buildelidedparamcall(\Nelidedparamcall \\
        \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Tcomma, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace))
        \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlbrace, \vparams, \Trbrace, \vargs))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
    \buildelidedparamcall (\Nelidedparamcall \\
      \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Tcomma, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}}))
      \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarElidedParameter}
\hypertarget{def-desugarelidedparameter}{}
The helper function
\[
\begin{array}{r}
\desugarelidedparameter(
  \overname{\localdeclkeyword}{\ldk} \aslsep
  \overname{\localdeclitem}{\ldi} \aslsep
  \overname{\ty}{\vt} \aslsep
  \overname{\call}{\vcall})
\aslto \\
\overname{\stmt}{\news}
\cup\ \overname{\TBuildError}{\ParseErrorConfig}
\end{array}
\]
builds a declaration statement $\news$ from an assignment of the call $\vcall$ to the left-hand side $\ldi$ with keyword $\ldk$ and type annotation $\vt$, where the call has an elided parameter.
Otherwise, the result is a parse error.

\ExampleDef{Desugaring Parameter Elision Based on Declared Type Annotation}
\listingref{DesugarElidedParameter} shows examples of how parameters can be elided
if they can be copied from the type annotation in declaration statements.
\ASLListing{Desugaring parameter elision based on declared type annotation}{DesugarElidedParameter}{\syntaxtests/ASTRule.DesugarElidedParameter.asl}

\begin{mathpar}
\inferrule{
  \checktrans{\vt = \TBits(\Ignore, \Ignore)}{\ParseErrorConfig} \typearrow \True \;\terminateas \ParseErrorConfig \\
  \vt \eqname \TBits(\ve, \Ignore) \\
  \vcallp \eqdef \vcall[\callparams\mapsto [\ve] \concat \vcall.\callparams ]
}{
  \desugarelidedparameter(\ldk, \ldi, \vt, \vcall)
  \astarrow
  \SDecl(\ldk, \ldi, \langle\vt\rangle, \ECall(\vcallp))
}
\end{mathpar}

\ASTRuleDef{ElidedParamDecl}
\begin{mathpar}
\inferrule{
  \buildelidedparamcall (\vcall) \astarrow \astversion{\vcall} \\
  {
    \begin{array}{r}
      \desugarelidedparameter(\astof{\vlocaldeclkeyword}, \astof{\vdeclitem}, \astof{\vasty}, \astversion{\vcall}) \astarrow \\
      \vastnode
    \end{array}
  }
}{
  {
    \buildstmt\left(
      \Nstmt\left(
        \begin{array}{l}
          \punnode{\Nlocaldeclkeyword}, \\
          \wrappedline\ \punnode{\Ndeclitem}, \punnode{\Nasty}, \Teq, \\
          \wrappedline\ \namednode{\vcall}{\Nelidedparamcall}, \Tsemicolon
        \end{array}
      \right)
    \right) \astarrow \vastnode
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildelidedparamcall (\vcall) \astarrow \astversion{\vcall} \\
  \desugarelidedparameter(\LDKVar, \astof{\vdeclitem}, \astof{\vasty}, \astversion{\vcall}) \astarrow \vastnode
}{
  {
    \begin{array}{r}
    \buildstmt(\Nstmt(\Tvar, \punnode{\Ndeclitem}, \punnode{\Nasty}, \Teq, \namednode{\vcall}{\Nelidedparamcall}, \Tsemicolon)) \astarrow\\
     \vastnode
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing and semantics}
As given by the applying the relevant rules to the desugared AST (see \secref{DeclarationStatements}).

\section{Sequencing Statements\label{sec:SequencingStatement}}
\hypertarget{def-sequencestatementterm}{}

\ASLListing{A sequence of statements}{semantics-sseq}{\semanticstests/SemanticsRule.SSeq.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmtlist \derives \ & \ListOne{\Nstmt} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SSeq(\stmt, \stmt) &
\end{flalign*}

\ASTRuleDef{StmtList}
\hypertarget{build-stmtlist}{}
The function
\[
  \buildstmtlist(\overname{\parsenode{\Nstmtlist}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildlist[\Nstmt](\vstmts) \astarrow \vstmtlist\\
  \stmtfromlist(\vstmtlist) \astarrow \vastnode
}{
  \buildstmtlist(\Nstmtlist(\namednode{\vstmts}{\ListOne{\Nstmt}})) \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{StmtFromList}
\hypertarget{def-stmtfromlist}{}
The helper function
\[
\stmtfromlist(\overname{\stmt^*}{\vstmts}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from a possibly-empty list of statements $\vstmts$.

\begin{mathpar}
\inferrule[empty]{
}{
  \stmtfromlist(\overname{\emptylist}{\vstmts}) \astarrow \overname{\SPass}{\news}
}
\and
\inferrule[non\_empty]{
  \stmtfromlist(\vstmtsone) \astarrow \vsone\\
  \sequencestmts(\vs, \vsone) \astarrow \news
}{
  \stmtfromlist(\overname{[\vs] \concat \vstmtsone}{\vstmts}) \astarrow \news
}
\end{mathpar}

\ASTRuleDef{SequenceStmts}
\hypertarget{def-sequencestmts}{}
The helper function
\[
\sequencestmts(\overname{\stmt}{\vsone}, \overname{\stmt}{\vstwo}) \aslto \overname{\stmt}{\news}
\]
Combines the statement $\vsone$ with $\vstwo$ into the statement $\news$, while filtering away
instances of $\SPass$.

\begin{mathpar}
\inferrule[s1\_spass]{}{
  \sequencestmts(\overname{\SPass}{\vsone}, \vstwo) \astarrow \overname{\vstwo}{\news}
}
\and
\inferrule[s2\_spass]{
  \vsone \neq \SPass
}{
  \sequencestmts(\vsone, \overname{\SPass}{\vstwo}) \astarrow \overname{\vsone}{\news}
}
\and
\inferrule[no\_spass]{
  \vsone \neq \SPass\\
  \vstwo \neq \SPass
}{
  \sequencestmts(\vsone, \vstwo) \astarrow \overname{\SSeq(\vsone, \vstwo)}{\news}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SSeq}
\ExampleDef{Typing Sequencing Statements}
In \listingref{semantics-sseq}, the statement \verb|let x=3;| is
annotated first in the static environment where the local static environment is empty.
Then, the statement \verb|let y = x + 1;|
is annotated in the static environment where
\verb|x| has been declared and associated with the type \verb|integer{3}|,
and also recorded to be equivalent to $\lint(3)$ (in the $\exprequiv$ map).

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is the AST node for the sequence of statements $\vsone$ and $\vstwo$, that is, $\SSeq(\vsone, \vstwo)$;
  \item annotating $\vsone$ in $\tenv$ yields $(\newsone, \tenvone, \vsesone)$\ProseOrTypeError;
  \item annotating $\vstwo$ in $\tenvone$ yields $(\newstwo, \newtenv, \vsestwo)$\ProseOrTypeError;
  \item $\news$ is the AST node for the sequence of statements $\newsone$ and $\newstwo$, that is, $\SSeq(\newsone, \newstwo)$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesone$ and $\vsestwo$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatestmt(\tenv, \vs1) \typearrow (\newsone, \tenvone, \vsesone) \OrTypeError\\\\
  \annotatestmt(\tenvone, \vs2) \typearrow (\newstwo, \newtenv, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotatestmt(\tenv, \overname{\SSeq(\vsone, \vstwo)}{\vs}) \typearrow (\overname{\SSeq(\newsone, \newstwo)}{\news}, \newtenv, \vses)
}
\end{mathpar}
\CodeSubsection{\SSeqBegin}{\SSeqEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SSeq}
\ExampleDef{Evaluation of Sequencing Statements}
In \listingref{semantics-sseq},
the evaluation of \texttt{let x = 3; let y = x + 1} first evaluates \texttt{let x = 3} and only then
evaluates \texttt{let y = x + 1}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \emph{sequencing statement} \texttt{s1; s2}, that is, $\SSeq(\vsone, \vstwo)$;
  \item evaluating $\vsone$ in $\env$ is either $\Continuing(\vgone, \envone)$ in which case
  the evaluation continues,
  or a returning configuration ($\Returning((\vvs, \newg), \newenv)$)\ProseOrAbnormal;
  \item evaluating $\vstwo$ in $\envone$ yields a non-abnormal configuration \\
        (either $\Normal$ or $\Continuing$) $C$\ProseOrAbnormal;
  \item $\newg$ is the ordered composition of $\vgone$ and the execution graph of $C$ with the
  $\aslpo$ edge;
  \item $D$ is the configuration $C$ with the execution graph component replaced with $\newg$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
  \inferrule{
    \evalstmt{\env, \vsone} \evalarrow \Continuing(\vgone, \envone) \terminateas \ReturningConfig,\ThrowingConfig,\DynErrorConfig\\
    \evalstmt{\envone, \vstwo} \evalarrow C \OrAbnormal\\
    \newg \eqdef \ordered{\vgone}{\aslpo}{\graphof{C}}\\
    D \eqdef \withgraph{C}{\newg}
  }
  {
    \evalstmt{\env, \SSeq(\vsone, \vstwo)} \evalarrow D
  }
\end{mathpar}
\CodeSubsection{\EvalSSeqBegin}{\EvalSSeqEnd}{../Interpreter.ml}

\section{Call Statements\label{sec:CallStatements}}
\hypertarget{def-callstatementterm}{}
Call statements are used to invoke procedures and setters.

\ASLListing{Call Statements}{scall}{\semanticstests/SemanticsRule.SCall.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Ncall \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SCall(\call) &
\end{flalign*}

\ASTRuleDef{SCall}
\begin{mathpar}
\inferrule{
  \buildcall(\vcall) \astarrow \astversion{\vcall} \\
  \setcalltype(\astversion{\vcall}) \aslto \vcallp
}{
  \buildstmt(
  \overname{\Nstmt(\namednode{\vcall}{\Ncall}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SCall(\vcallp)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SCall}
The call statement \verb|catenate_into_g{4, 3}(x, y, TRUE);|
in \listingref{scall} is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a call to a subprogram, that is, $\SCall(\vcall)$;
  \item annotating the subprogram call $\vcall$ as per \chapref{SubprogramCalls}
        yields \\
        $(\vcallp, \None, \vses)$\ProseOrTypeError;
  \item $\news$ is the call using $\vcallp$, that is, $\SCall(\vcallp)$;
  \item $\newtenv$ is $\tenv$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \begin{array}{r}
      \annotatecall(\vcall) \typearrow (\vcallp, \None, \vses) \OrTypeError
    \end{array}
  }
}{
  {
    \begin{array}{r}
  \annotatestmt(\tenv, \overname{\SCall(\vcall)}{\vs}) \typearrow
  (\overname{\SCall(\vcallp)}{\news}, \tenv, \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SCallBegin}{\SCallEnd}{../Typing.ml}
\identd{VXKM}

\subsection{Semantics}
\SemanticsRuleDef{SCall}
\ExampleDef{Evaluation of Call Statements}
The call statement \verb|catenate_into_g{4, 3}(x, y, TRUE);|
assigns the global variable \verb|g| to \verb|'1101 111'|.

A call statement \verb|zero();| is ill-typed, since call statements
can only be used for procedures, not functions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a call statement, $\SCall(\vcall)$;
  \item evaluating the subprogram call as per \chapref{SubprogramCalls} is
  \\ $\Normal(\newg, \newenv)$\ProseOrAbnormal;
  \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
{
\begin{array}{r}
  \evalcall(\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs) \evalarrow \\
  \Normal(\newg, \newenv) \OrAbnormal
\end{array}
}
}{
  \evalstmt{\env, \overname{\SCall(\vcall)}{\vs}} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSCallBegin}{\EvalSCallEnd}{../Interpreter.ml}
\identd{KCYT}

\hypertarget{def-conditionalstatementterm}{}
\section{Conditional Statements\label{sec:ConditionalStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nstmtlist \parsesep \Nselse \parsesep \Tend \parsesep \Tsemicolon &\\
\Nselse \derives\ & \Telseif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nstmtlist \parsesep \Nselse &\\
        |\ & \Telse \parsesep \Nstmtlist &\\
        |\ & \emptysentence &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SCond(\expr, \stmt, \stmt)
\end{flalign*}

\ASTRuleDef{SCond}
\begin{mathpar}
\inferrule{}{
  {
    \begin{array}{r}
  \buildstmt(\overname{\Nstmt(\Tif, \punnode{\Nexpr}, \Tthen, \punnode{\Nstmtlist}, \punnode{\Nselse}, \Tend, \Tsemicolon)}{\vparsednode})
  \astarrow \\
  \overname{\SCond(\astof{\vexpr}, \astof{\vstmtlist}, \astof{\velse})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{SElse}
\hypertarget{build-selse}{}
The function
\[
  \buildselse(\overname{\parsenode{\Nselse}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[elseif]{}{
  {
    \begin{array}{r}
  \buildselse(\Nselse(\Telseif, \Nexpr, \Twhen, \Nstmtlist, \Nselse)) \astarrow \\
  \overname{\SCond(\astof{\vexpr}, \astof{\vstmtlist}, \astof{\vselse})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pass]{}{
  \buildselse(\Nselse(\emptysentence)) \astarrow \overname{\SPass}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[else]{}{
  \buildselse(\Nselse(\Telse, \punnode{\Nstmtlist})) \astarrow \overname{\astof{\vstmtlist}}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SCond}
The specifications in \listingref{semantics-scond},
\listingref{semantics-scond2},
\listingref{semantics-scond3}, and
\listingref{semantics-scond4} are all well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a condition $\ve$ with the statements $\vsone$ and $\vstwo$, that is, $\SCond(\ve, \vsone, \vstwo)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields \\
        $(\tcond, \econd, \vsescond)$\ProseOrTypeError;
  \item checking that $\tcond$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
  \item annotating the statement $\vsone$ in $\tenv$ yields $(\vsonep, \vsesone)$\ProseOrTypeError;
  \item annotating the statement $\vstwo$ in $\tenv$ yields $(\vstwop, \vsestwo)$\ProseOrTypeError;
  \item $\news$ is the condition $\econd$ with the statements $\vsonep$ and $\vstwop$, that is, \\ $\SCond(\econd, \vsonep, \vstwop)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsescond$, $\vsesone$, and $\vsestwo$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\tcond, \econd, \vsescond) \OrTypeError\\\\
  \checktypesat(\tenv, \tcond, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock{\tenv, \vsone} \typearrow (\vsonep, \vsesone) \OrTypeError\\\\
  \annotateblock{\tenv, \vstwo} \typearrow (\vstwop, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsescond \cup \vsesone \cup \vsestwo
}{
  \annotatestmt(\tenv, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \typearrow
  (\overname{\SCond(\econd, \vsonep, \vstwop)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\CodeSubsection{\SCondBegin}{\SCondEnd}{../Typing.ml}
\identr{NBDJ}

\subsection{Semantics}
\SemanticsRuleDef{SCond}
\ExampleDef{Conditional Statements}
The specification in \listingref{semantics-scond} does not result in any Assertion Error.
\ASLListing{Evaluating a conditional statement}{semantics-scond}{\semanticstests/SemanticsRule.SCond.asl}

The specification in \listingref{semantics-scond2}
does not result in any error.
\ASLListing{Evaluating a condition statement with \texttt{elsif}}{semantics-scond2}{\semanticstests/SemanticsRule.SCond2.asl}

The specification in \listingref{semantics-scond3}
results in an Assertion Error.
\ASLListing{Evaluating a condition statement that results in an Assertion Error}{semantics-scond3}{\semanticstests/SemanticsRule.SCond3.asl}

The specification in \listingref{semantics-scond4} does not result in any error.
\ASLListing{Evaluating a condition statement with only a \texttt{then} branch}{semantics-scond4}{\semanticstests/SemanticsRule.SCond4.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vs$ is a condition statement, $\SCond(\ve, \vsone, \vstwo)$;
\item evaluating $\ve$ in $\env$ is $\Normal(\vv, \vgone)$\ProseOrAbnormal;
\item $\vv$ is a native Boolean for $\vb$;
\item the statement $\vsp$ is $\vsone$ is $\vb$ is $\True$ and $\vstwo$ otherwise
(so that $\vsone$ will be evaluated if the condition evaluates to $\True$ and otherwise
$\vstwo$ will be evaluated);
\item evaluating $\vsp$ in $\envone$ as per \chapref{BlockStatements} is a non-abnormal configuration
      (either $\Normal$ or $\Continuing$) $C$\ProseOrAbnormal;
\item $\vg$ is the ordered composition of $\vgone$ and the execution graph of the configuration $C$;
\item $D$ is the configuration $C$ with the execution graph component updated to be $\vg$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \envone) \OrAbnormal\\
  \vv \eqname \nvbool(\vb)\\
  \vsp \eqdef \choice{\vb}{\vsone}{\vstwo}\\
  \evalblock{\envone, \vsp} \evalarrow C \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\aslctrl}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\vg}
}{
  \evalstmt{\env, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}} \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSCondBegin}{\EvalSCondEnd}{../Interpreter.ml}

\hypertarget{def-casestatementterm}{}
\section{Case Statements\label{sec:CaseStatements}}
Case statements allow executing different statements, based on which
condition an expression satisfies.

\listingref{case-discriminant} shows an example of a \casestatementterm{}
and the output to a console when it is evaluated.

\ASLListing{A side-effecting case discriminant}{case-discriminant}{\definitiontests/CaseStatement.discriminant.asl}
% CONSOLE_BEGIN aslref \definitiontests/CaseStatement.discriminant.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
num_tests: 0
selected case 2
\end{Verbatim}
% CONSOLE_END
\listingref{case-discriminant} shows an example of a \casestatementterm{}
and the output to a console when it is evaluated.

\hypertarget{def-casediscriminantterm}{}
\hypertarget{def-casealternativeterm}{}
\hypertarget{def-otherwisecaseterm}{}
The expression following the \Tcase\ keyword is called the \emph{\casediscriminantterm}.
The list following the \Tof\ keyword consists of \emph{\casealternativesterm},
optionally ending with an \emph{\otherwisecaseterm}, which follows the \Totherwise\ keyword.

Case statements obey the following requirements:

\RequirementDef{CaseDiscriminant} The \casediscriminantterm\ of a \texttt{case}
statement should be evaluated only once each time the case statement is evaluated.
%
\listingref{case-discriminant} demonstrates how the \casediscriminantterm{}
is evaluated only once.

\RequirementDef{CaseAlternatives} The \casealternativesterm\ are examined
one after another, in the order they are listed.
If any of the patterns match the \casediscriminantterm{} (and the guard
expression is true, if present) then this \casealternativeterm{} is considered selected,
its statement list is executed, and the \texttt{case} statement ends without examining any further
\casealternativesterm.
%
\listingref{case-discriminant} demonstrates how only one \casealternativeterm{} is selected
for execution.

\RequirementDef{CaseDiscriminantTesting} Testing the \casediscriminantterm{} against a \\
pattern list
follows the semantics of pattern matching defined in \chapref{PatternMatching}.
It is not a static error if it can be statically determined that none of the patterns in a
\casealternativeterm\ can match the discriminant.
%
\listingref{case-discriminant} exemplifies a \casestatementterm{} with pattern matching.

\RequirementDef{CaseOtherwise} If no \casealternativeterm\ is selected, and there is an
\otherwisecaseterm\, the \otherwisecaseterm\ is executed.
%
\listingref{case-otherwise} demonstrates how the \otherwisecaseterm{} is evaluated.

\ASLListing{Executing the \texttt{otherwise} case alternative}{case-otherwise}{\definitiontests/CaseStatement.otherwise.asl}
% CONSOLE_BEGIN aslref \definitiontests/CaseStatement.otherwise.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
num_tests: 0
selected otherwise
\end{Verbatim}
% CONSOLE_END

\RequirementDef{CaseNoOtherwiseError} If no \casealternativeterm\ is selected,
and there is no \otherwisecaseterm, it is a dynamic error.
%
\listingref{case-no-otherwise} shows a specification that, when evaluated,
yields a dynamic error.

\ASLListing{A case statement with no \texttt{otherwise} case}{case-no-otherwise}{\definitiontests/CaseStatement.no_otherwise.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tcase \parsesep \Nexpr \parsesep \Tof \parsesep \Ncasealtlist \parsesep \Tend \parsesep \Tsemicolon &\\
|\ & \Tcase \parsesep \Nexpr \parsesep \Tof \parsesep \Ncasealtlist \parsesep \Totherwise \parsesep \Tarrow &\\
   & \wrappedline\ \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Ncasealtlist \derives \ & \ClistOne{\Ncasealt} \parsesep &\\
\Ncasealt \derives \ & \Twhen \parsesep \Npatternlist \parsesep \option{\Twhere \parsesep \Nexpr} \parsesep \Tarrow \parsesep \Nstmtlist &\\
\end{flalign*}

\subsection{Abstract Syntax}
Case statements are considered syntactic sugar and are \emph{desugared}.
That is, they are transformed into an untyped AST node that does not have
an explicit representation for \texttt{case} statements.
This is achieved via \ASTRuleRef{DesugarCaseStmt}.

\ExampleDef{Case Statement Desugaring}
\listingref{ast-case1} shows an example of how a \texttt{case} statement can be transformed into a corresponding
compound condition statement.
\ASLListing{Transforming a case statement with a variable as the case discriminant}{ast-case1}{\syntaxtests/ASTRule.Desugar_SCase1.asl}

\listingref{ast-case2} shows an example of how a \texttt{case} statement can be transformed into
a statement that does not contain any \text{case} statement.
By storing the \casediscriminantterm\ in a variable and by adding
a call to \texttt{Unreachable()}, the transformation ensures that a dynamic error occurs when no
\casealternativeterm\ is selected.
\ASLListing{Transforming a case statement with a non-variable as the case discriminant
and no otherwise case}{ast-case2}{\syntaxtests/ASTRule.Desugar_SCase2.asl}

The untyped AST contains non-terminals for \casealternativesterm, which exist
only as a data type used by $\desugarcasestmt$ and do not later appear in the untyped
AST:

\begin{flalign*}
\casealt \derives\ & \{ \CasePattern : \pattern, \CaseWhere : \expr?, \CaseStmt : \stmt \} &
\end{flalign*}

\ASTRuleDef{SCase}
To satisfy \RequirementRef{CaseNoOtherwiseError}, when no \otherwisecaseterm\ exists,
$\SUnreachable$ is used instead:
\begin{mathpar}
\inferrule[no\_otherwise]{
  \buildlist[\buildcasealt](\vcasealtlist) \astarrow \vcasealtlistast\\
  \buildexpr(\vediscriminant) \astarrow \astversion{\vediscriminant}\\
  {
  \begin{array}{r}
  \desugarcasestmt(\astversion{\vediscriminant}, \vcasealtlistast, \SUnreachable) \astarrow \\
  \vastnode
  \end{array}
  }
}{
  {
  \buildstmt\left(\overname{
    \Nstmt\left(
      \begin{array}{l}
        \Tcase, \namednode{\vediscriminant}{\Nexpr}, \Tof, \\
        \wrappedline\ \namednode{\vcasealtlist}{\Ncasealtlist}, \\
        \wrappedline\ \Tend, \Tsemicolon
      \end{array}
    \right)
    }{\vparsednode}\right)
  \astarrow
  \vastnode
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise]{
  \buildlist[\buildcasealt](\vcasealtlist) \astarrow \vcasealtlistast\\
  \buildexpr(\vediscriminant) \astarrow \astversion{\vediscriminant}\\
  \buildstmtlist(\votherwise) \astarrow \astversion{\votherwise}\\
  {
  \begin{array}{r}
  \desugarcasestmt(\astversion{\vediscriminant}, \vcasealtlistast, \astversion{\votherwise}) \astarrow \\
  \vastnode
  \end{array}
  }
}{
  {
  \buildstmt\left(\overname{
    \Nstmt\left(
      \begin{array}{l}
        \Tcase, \namednode{\vediscriminant}{\Nexpr}, \Tof, \\
        \wrappedline\ \namednode{\vcasealtlist}{\Ncasealtlist}, \\
        \wrappedline\ \Totherwise, \Tarrow, \namednode{\votherwise}{\Nstmtlist}, \\
        \wrappedline\ \Tend, \Tsemicolon
      \end{array}
    \right)
    }{\vparsednode}\right)
  \astarrow
  \vastnode
  }
}
\end{mathpar}

\ASTRuleDef{CaseAltList}
\hypertarget{build-casealtlist}{}
The function
\[
\buildcasealtlist(\overname{\parsenode{\Ncasealtlist}}{\vparsednode}) \;\aslto\; \overname{\casealt^+}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildclist[\buildcasealt](\vcases) \typearrow \vastnode
}{
  \buildcasealtlist(\overname{\Ncasealtlist(\vcases : \ClistOne{\Ncasealt})}{\vparsednode}) \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{CaseAlt}
\hypertarget{build-casealt}{}
The function
\[
\buildcasealt(\overname{\parsenode{\Ncasealt}}{\vparsednode}) \;\aslto\; \overname{\casealt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildoption[\buildexpr](\vwhereopt) \astarrow \vwhereast
}{
  {
    \begin{array}{r}
  \buildcasealt\left(\overname{\Ncasealt\left(
    \begin{array}{l}
    \Twhen, \punnode{\Npatternlist}, \\
    \wrappedline\ \namednode{\vwhereopt}{\option{\Twhere, \Nexpr}}, \Tarrow, \\
    \wrappedline\ \namednode{\vstmts}{\Nstmtlist}
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{\casealt(\CasePattern: \astof{\vpatternlist}, \CaseWhere: \vwhereast, \CaseStmt: \astof{\vstmtlist})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarCaseStmt}
\hypertarget{def-desugarcasestmt}{}
The relation
\[
\desugarcasestmt(
  \overname{\expr}{\vezero},
  \overname{\casealt^*}{\vcases},
  \overname{\stmt}{\votherwise}) \;\aslrel\; \overname{\stmt}{\news}
\]
transforms a \casediscriminantterm\ $\vezero$, a list of \casealternativesterm\ $\vcases$,
and a statement $\votherwise$ into a statement $\news$.

\begin{mathpar}
\inferrule[var]{
  \astlabel(\vezero) = \EVar\\
  \casestocond(\vezero, \vcases, \votherwise) \typearrow \news
}{
  \desugarcasestmt(\vezero, \vcases, \votherwise) \astarrow \news
}
\end{mathpar}

To satisfy \RequirementRef{CaseDiscriminant}, the transformation assigns the
\casediscriminantterm\ to a temporary variable, which is then used in a
compound conditional statement (see \listingref{ast-case2} for an example):
\begin{mathpar}
\inferrule[non\_var]{
  \astlabel(\vezero) \neq \EVar\\
  \vx \in \Identifiers \text{ is fresh}\\
  \vdeclx \eqname \SDecl(\LDKLet, \LDIVar(\vx), \None, \langle\vezero\rangle)\\
  \casestocond(\EVar(\vx), \vcases, \votherwise) \typearrow \vscond
}{
  \desugarcasestmt(\vezero, \vcases, \votherwise) \astarrow \overname{\SSeq(\vdeclx, \vscond)}{\news}
}
\end{mathpar}
\CodeSubsection{\DesugarCaseStmtBegin}{\DesugarCaseStmtEnd}{../desugar.ml}

\ASTRuleDef{CasesToCond}
\hypertarget{def-casestocond}{}
The function
\[
\casestocond(
  \overname{\expr}{\ve} \aslsep
  \overname{\casealt^*}{\vcases} \aslsep
  \overname{\stmt}{\votherwise})
\;\aslrel\; \overname{\stmt}{\news}
\]
transforms an expression $\ve$, a list of \texttt{case} alternatives $\vcases$,
and a statement $\votherwise$
into a statement $\news$.

\begin{mathpar}
\inferrule[last]{
  \casetocond(\ve, \vcase, \votherwise) \astarrow \news
}{
  \casestocond(\ve, \overname{[\vcase]}{\vcases}, \votherwise) \astarrow \news
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_last]{
  \vcasesone \neq \emptylist\\
  \casestocond(\ve, \vcasesone) \typearrow \vsone\\
  \casetocond(\ve, \vcase, \vsone) \typearrow \news
}{
  \casestocond(\ve, \overname{[\vcase] \concat \vcasesone}{\vcases}, \votherwise) \astarrow \news
}
\end{mathpar}
\CodeSubsection{\CasesToCondBegin}{\CasesToCondEnd}{../desugar.ml}

\ASTRuleDef{CaseToCond}
\hypertarget{def-casetocond}{}
The function
\[
\casetocond(\overname{\expr}{\vezero} \aslsep \overname{\casealt}{\vcase} \aslsep \overname{\stmt}{\vtail})
\;\aslrel\; \overname{\stmt}{\news}
\]
transforms an expression $\vezero$ (the condition used for a \texttt{case} statement),
a single \texttt{case} alternative $\vcase$, and a statement $\vtail$, which represents
a list of \texttt{case} alternatives already converted to conditionals, into a condition statement $\news$.

\begin{mathpar}
\inferrule{
  \vcase \eqname \{ \CasePattern : \vpattern, \CaseWhere : \vwhere, \CaseStmt : \vstmt \}\\
  \vepattern \eqdef \EPattern(\vezero, \vpattern)\\
  \vcond \eqdef \choice{\vwhere = \langle\vewhere\rangle}{\EBinop(\BAND, \vepattern, \vewhere)}{\vepattern}
}{
  \casetocond(\vezero, \vcase, \vtail) \astarrow \overname{\SCond(\vcond, \vstmt, \vtail)}{\news}
}
\end{mathpar}
\CodeSubsection{\CaseToCondBegin}{\CaseToCondEnd}{../desugar.ml}

\subsection{Typing}
Since case statements are transformed into other statements,
they do not require type system rules.
\identr{WGSY}

\subsection{Semantics}
Since case statements are transformed into other statements,
they do not appear in the typed AST and thus are not associated with a semantics.

\hypertarget{def-assertionstatementterm}{}
\section{Assertion Statements\label{sec:AssertionStatements}}
Assertion statements are used to check that certain conditions are satisfied.
They take a single \booleantypeterm{} operand, which we refer to as the
\emph{condition}. If the condition is \False, the statement fails with a
\dynamicerrorterm{} (\errorcodeterm{} $\DynamicAssertionFailure$).

\listingref{AssertionStatement} shows a possible use of
\assertionstatementterm{} to check the inputs to a function
(also known as a \emph{precondition})
and ensure the output satisfies expectations (also known as a \emph{postcondition}).
%
The first call to \verb|checked_8bit_add| succeeds, whereas the second call fails the
\assertionstatementterm{} \verb|assert a + b < 256;|

\ASLListing{Example of using \texttt{assert} statements}{AssertionStatement}{\definitiontests/AssertionStatement.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tassert \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SAssert(\expr) &
\end{flalign*}

\ASTRuleDef{SAssert}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tassert, \Nexpr, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SAssert(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SAssert}
\ExampleDef{Typing Assertion Statements}
The specifications in \listingref{semantics-sasertok} and \listingref{semantics-sassertno}
are well-typed.

The assertion statements in \listingref{assert-ill-typed} are ill-typed,
since the expression needs to be both of a \booleantypeterm{} and pure.
\ASLListing{Ill-typed assertion statements}{assert-ill-typed}{\typingtests/TypingRule.SAssert.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assert statement with expression $\ve$, that is, $\SAssert(\ve)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tep,\vep, \vsese)$\ProseOrTypeError;
  \item checking that $\vsese$ is pure via $\sesispure$ yields $\True$\ProseOrTypeError;
  \item checking that $\vtep$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is an assert statement with expression $\vep$, that is, $\SAssert(\vep)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsese$ and the singleton set for \PerformsAssertionsTerm}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vtep, \vep, \vsese) \OrTypeError\\\\
  \checktrans{\sesispure(\vsese) \typearrow \True}{\SideEffectViolation}\\\\
  \checktypesat(\tenv, \vtep, \TBool) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsese \cup \{\PerformsAssertions\}
}{
  \annotatestmt(\tenv, \overname{\SAssert(\ve)}{\vs}) \typearrow (\overname{\SAssert(\vep)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SAssertBegin}{\SAssertEnd}{../Typing.ml}
\identr{JQYF}

\subsection{Semantics}
\SemanticsRuleDef{SAssert}
\ExampleDef{Evaluation of Assertions: Success}
In \listingref{semantics-sasertok},
\texttt{assert (42 != 3);} ensures that \texttt{3} is not equal to \texttt{42}.
\ASLListing{Evaluating an assertion that succeeds}{semantics-sasertok}{\semanticstests/SemanticsRule.SAssertOk.asl}

\ExampleDef{Evaluation of Assertions: Failure}
In \listingref{semantics-sassertno},
evaluating \texttt{assert (42 == 3);} results in an \DynamicAssertionFailure{} error.
\ASLListing{Evaluating an assertion that fails}{semantics-sassertno}{\semanticstests/SemanticsRule.SAssertNo.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assertion statement, $\SAssert(\ve)$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{okay}
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ is $\Normal((\vv, \newg), \newenv)$\ProseOrAbnormal;
      \item $\vv$ is a native Boolean value for $\True$;
      \item the resulting configuration is $\Continuing(\newg, \newenv)$.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ is $\Normal((\vv, \newg), \newenv)$;
      \item $\vv$ is a native Boolean value for $\False$;
      \item the result is a dynamic error indicating the assertion failure returned (\DynamicAssertionFailure).
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \newg), \newenv) \OrAbnormal\\\\
  \vv \eqname \nvbool(\True)
}{
  \evalstmt{\env, \SAssert(\ve)} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
  \inferrule[error]{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \Ignore), \Ignore)\\
  \vv \eqname \nvbool(\False)
}{
  \evalstmt{\env, \SAssert(\ve)} \evalarrow \DynamicErrorVal{\DynamicAssertionFailure}
}
\end{mathpar}
\CodeSubsection{\EvalSAssertBegin}{\EvalSAssertEnd}{../Interpreter.ml}
\identd{QJYV} \identr{WZSL} \identr{WQRN}

\section{While Statements\label{sec:WhileStatements}}
\hypertarget{def-whilestatementterm}{}

\ASLListing{A \texttt{while} statement}{semantics-swhile}{\semanticstests/SemanticsRule.SWhile.asl}

\ConventionDef{Loop Limits}
Conventionally, all loop kinds should specify a limit expression.
For example, the loops in \listingref{semantics-swhile} specifies a limit via
the expression \verb|limit_loop()|.

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Twhile \parsesep \Nexpr \parsesep \Nlooplimit \parsesep \Tdo \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SWhile(\overtext{\expr}{condition}, \overtext{\expr?}{loop limit}, \overtext{\stmt}{loop body}) &
\end{flalign*}

\ASTRuleDef{SWhile}
\begin{mathpar}
\inferrule{
  \buildexpr(\vlimitexpr) \astarrow \astversion{\vlimitexpr}\\
  \buildlooplimit(\voptlimit) \astarrow \astversion{\voptlimit}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Twhile, \econd: \Nexpr, \voptlimit : \Nlooplimit, \Tdo, \\
    \wrappedline\ \punnode{\Nstmtlist}, \Tend, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow\\
  \overname{\SWhile(\astof{\vexpr}, \astversion{\voptlimit}, \astof{\vstmtlist})}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{LoopLimit}
\hypertarget{build-looplimit}{}
The function
\[
\buildlooplimit(\overname{\parsenode{\Nlooplimit}}{\vparsednode}) \aslto \overname{\langle\expr\rangle}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[limit]{}{
  \buildlooplimit\left(\overname{\Nlooplimit(\Tlooplimit, \punnode{\Nexpr})}{\vparsednode}\right)
  \astarrow
  \overname{\langle\astof{\vexpr}\rangle}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_limit]{}{
  \buildlooplimit\left(\overname{\Nlooplimit(\emptysentence)}{\vparsednode}\right)
  \astarrow
  \overname{\None}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SWhile}
\ExampleDef{Typing While Loops}
The specification in \listingref{typing-swhile} is well-typed
and shows two \whilestatementterm{} --- the first one without a loop limit
and the second one with a loop limit.
\ASLListing{Typing while statements}{typing-swhile}{\typingtests/TypingRule.SWhile.asl}

The specification in \listingref{typing-swhile-bad-limit}
is ill-typed, since the loop limit is not a \constrainedinteger.
\ASLListing{An ill-typed loop limit}{typing-swhile-bad-limit}{\typingtests/TypingRule.SWhile.bad_limit.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vs$ is a \texttt{while} statement with expression $\veone$, optional limit expression $\vlimitone$,
      and statement block $\vsone$, that is, $\SWhile(\veone, \vsone)$;
\item annotating the right-hand-side expression $\veone$ in $\tenv$ yields $(\vt, \vetwo, \vsese)$\ProseOrTypeError;
\item annotating the optional limit expression $\vlimitone$ via $\annotatelimitexpr$ in $\tenv$ yields $(\vlimittwo, \vseslimit)$\ProseOrTypeError;
\item checking that $\vt$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item annotating $\vsone$ as a block statement as per \TypingRuleRef{Block} in $\tenv$ yields \\
      $(\vstwo, \vsesblock)$\ProseOrTypeError;
\item $\news$ is a \texttt{while} statement with expression $\vetwo$, optional limit expression $\vlimittwo$,
      and statement block $\vstwo$, that is, $\SWhile(\vetwo, \vstwo)$;
\item $\newtenv$ is $\tenv$;
\item \Proseeqdef{$\vses$}{the union of $\vsesblock$, $\vsese$, and $\vseslimit$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo, \vsese) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimitone) \typearrow (\vlimittwo, \vseslimit) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock{\tenv, \vsone} \typearrow (\vstwo, \vsesblock) \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsese \cup \vseslimit
}{
  \annotatestmt(\tenv, \overname{\SWhile(\veone, \vlimitone, \vsone)}{\vs}) \typearrow
  (\overname{\SWhile(\vetwo, \vlimittwo, \vstwo)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SWhileBegin}{\SWhileEnd}{../Typing.ml}
\identr{FTVN}

\TypingRuleDef{AnnotateLimitExpr}
\hypertarget{def-annotatelimitexpr}{}
The function
\[
  \annotatelimitexpr(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\langle\expr\rangle}{\ve} \aslsep
  ) \aslto
  (\langle\overname{\expr}{\vep}\rangle \times \overname{\TSideEffectSet}{\vses}) \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates an optional expression $\ve$ serving as the limit of a loop or a recursive subprogram in $\tenv$,
yielding a pair consisting of an expression $\vep$ and a \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Limit Expressions}
The specification in \listingref{typing-swhile} has two loops.
The loop in \verb|scan| is limited by the constrained integer
expression \verb|N|, while the loop in \verb|main| does not
have a loop limit.

The loop in \listingref{typing-swhile-bad-limit} uses
the limit expression \verb|i_limit| whose type the
\unconstrainedintegertype, which is illegal for
limit expressions.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\ve$ is $\None$;
    \item \Proseeqdef{$\vep$}{$\None$};
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\ve$ is $\langle\vlimit\rangle$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\vlimit$ in $\tenv$ yields \\
          $(\vlimitp, \vses)$\ProseOrTypeError;
    \item \Proseeqdef{$\vep$}{$\langle\vlimitp\rangle$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \annotatelimitexpr(\tenv, \overname{\None}{\ve}) \typearrow (\overname{\None}{\vep}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\begin{mathpar}
\inferrule[some]{
  \annotatesymbolicconstrainedinteger(\tenv, \vlimit) \typearrow (\vlimitp, \vses) \OrTypeError
}{
  \annotatelimitexpr(\tenv, \overname{\langle\vlimit\rangle}{\ve}) \typearrow (\overname{\langle\vlimitp\rangle}{\vep}, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateLimitExprBegin}{\AnnotateLimitExprEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SWhile}
\ExampleDef{Evaluation of While Statements}
The specification in \listingref{semantics-swhile} prints the
following to the console:
% CONSOLE_BEGIN aslref \semanticstests/SemanticsRule.SWhile.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
evaluated limit = 4
testing 0 <= 3
i = 0
testing 1 <= 3
i = 1
testing 2 <= 3
i = 2
testing 3 <= 3
i = 3
testing 4 <= 3
\end{Verbatim}
% CONSOLE_END

The specification in \listingref{swhile-limit-reached} yields a dynamic
error once the loop limit for the \whilestatementterm{} is reached.
\ASLListing{Reaching a while loop limit}{swhile-limit-reached}{\semanticstests/SemanticsRule.SWhile.limit_reached.asl}

\ProseParagraph
Evaluation of the statement $\vs$ in an environment $\env$ yields
the output configuration $C$.
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{while} statement, $\SWhile(\ve, \velimitopt, \vbody)$;
  \item evaluating the optional limit expression $\velimitopt$ via $\evallimit$ in $\env$
        yields $(\vlimitopt, \vgone)$\ProseOrError;
  \item evaluating the loop as per \SemanticsRuleRef{Loop} in an environment $\env$,
  with the arguments $\True$ (which conveys that this is a \texttt{while} statement), $\vlimitopt$, $\ve$, and $\vbody$
  yields the (non-error configuration) $C$\ProseOrError;
  \item $\vgtwo$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge;
  \item the output configuration $D$ is the output configuration $C$ with its execution graph
        substituted with $\vgtwo$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitopt, \vgone) \OrDynError\\\\
  \evalloop{\env, \True, \vlimitopt, \ve, \vbody} \evalarrow C \OrDynError\\\\
  \vgtwo \eqdef \ordered{\vgone}{\asldata}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\vgtwo}
}{
  \evalstmt{\env, \overname{\SWhile(\ve, \velimitopt, \vbody)}{\vs}} \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSWhileBegin}{\EvalSWhileEnd}{../Interpreter.ml}

\SemanticsRuleDef{Loop}
The relation
\hypertarget{def-evalloop}{}
\[
  \evalloop{
    \overname{\envs}{\env} \aslsep
    \overname{\Bool}{\iswhile} \aslsep
    \overname{\N?}{\vlimitopt} \aslsep
    \overname{\expr}{\econd} \aslsep
    \overname{\stmt}{\vbody}}
  \;\aslrel\;
  \left(
    \begin{array}{cl}
      \Continuing(\overname{\XGraphs}{\newg} \aslsep \overname{\envs}{\newenv}) & \cup \\
      \overname{\TReturning}{\ReturningConfig} & \cup \\
      \overname{\TThrowing}{\ThrowingConfig} & \cup \\
      \overname{\TDynError}{\DynErrorConfig} &
    \end{array}
  \right)
\]
to evaluate both \texttt{while} statements and \texttt{repeat} statements.

More specifically, $\evalloop{\env, \iswhile, \velimitopt, \econd, \vbody}$
evaluates $\vbody$ in $\env$ as long as $\econd$ holds when $\iswhile$ is $\True$
or until $\econd$ holds when $\iswhile$ is $\False$.
If the number of iterations exceeds the optional value specified by $\vlimitopt$,
the result is a dynamic error.
The result is either the continuing configuration \\ $\Continuing(\newg,\newenv)$,
an early return configuration, or an abnormal configuration.

\ExampleDef{Evaluation of Loops}
The specification in \listingref{semantics-loop} does not result in any Assertion Error
and the specification terminates with exit code $0$.
\ASLListing{Evaluating a loop}{semantics-loop}{\semanticstests/SemanticsRule.Loop.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
\item \AllApplyCase{exit}
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is $\Normal(\condm, \newenv)$\ProseOrAbnormal;
    \item $\condm$ consists of a native Boolean for $\vb$ and an execution graph $\newg$;
    \item $\vb$ is not equal to $\iswhile$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$
    and the loop is exited.
  \end{itemize}
\item \AllApplyCase{continue}
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is $\Normal(\condm, \envone)$;
    \item $\mcond$ consists of a native Boolean for $\vb$ and an execution graph $\vgone$;
    \item $\vb$ is equal to $\iswhile$;
    \item \Proseticklooplimit{$\vlimitopt$}{$\vlimitoptp$}\ProseOrError;
    \item evaluating $\vbody$ in $\envone$ as per \SemanticsRuleRef{Block} is either \\
    $\Continuing(\vgtwo, \envtwo)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
    \item evaluating $(\iswhile, \vlimitoptp, \econd, \vbody)$ in $\envtwo$ as a loop is \\
    $\Continuing(\vgthree, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label
    and then the ordered composition of the result and $\vgthree$ with the $\aslpo$ edge;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
The premise $\vb \neq \iswhile$ is $\True$ in the case of a \texttt{while} loop
and the loop condition $\ve$ not holding, which is exactly when we want the
loop to exit. The opposite holds for a \texttt{repeat} loop.
The negation of the condition is used to decide whether to continue the loop iteration.

\begin{mathpar}
\inferrule[exit]{
  \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \newenv) \OrAbnormal\\
  \condm \eqname (\nvbool(\vb), \newg)\\
  \vb \neq \iswhile
}{
  \evalloop{\env, \iswhile, \vlimitopt, \econd, \vbody} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[continue]{
  \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \envone)\\
  \condm \eqname (\nvbool(\vb), \vgone)\\
  \vb = \iswhile\\
  \ticklooplimit(\vlimitopt) \evalarrow \vlimitoptp \OrDynError\\\\
  \evalblock{\envone, \vbody} \evalarrow \Continuing(\vgtwo, \envtwo) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig\\
  {
    \begin{array}{r}
      \evalloop{\envtwo, \iswhile, \vlimitoptp, \econd, \vbody} \evalarrow \\
      \Continuing(\vgthree, \newenv) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig\\
    \end{array}
  }\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslctrl}{\vgtwo}}{\aslpo}{\vgthree}
}{
  \evalloop{\env, \iswhile, \vlimitopt, \econd, \vbody} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalLoopBegin}{\EvalLoopEnd}{../Interpreter.ml}

\SemanticsRuleDef{EvalLimit}
The relation
\hypertarget{def-evallimit}{}
\[
\evallimit(\overname{\env}{\envs} \aslsep \overname{\velimitopt}{\expr?})
\aslto (\overname{\langle\N\rangle}{\vvopt}, \overname{\vg}{\XGraphs})
\cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the optional expression $\velimitopt$ in the environment $\env$, yielding
the optional integer value $\vvopt$ and execution graph $\vg$.
\ProseOrError

The evaluation uses the function $\evalexprsef$ because limit expressions are
guaranteed side-effect-free by the typechecker,
see \TypingRuleRef{AnnotateLimitExpr}.

See \ExampleRef{Evaluation of While Statements} to see how the
limit expression is evaluated just once for the entire evaluation
of the \whilestatementterm.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\velimitopt$ is $\None$;
    \item $\vvopt$ is $\None$;
    \item $\vg$ is the empty execution graph.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\velimitopt$ is the expression $\velimit$;
    \item evaluating the side-effect-free expression $\velimitopt$ in $denv$ yields the native integer for $\vv$ and
          the execution graph $\vg$;
    \item $\vvopt$ is $\langle\vv\rangle$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \evallimit(\env, \overname{\None}{\velimitopt}) \evalarrow (\overname{\None}{\vvopt}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \evalexprsef{\env, \velimit} \evalarrow (\nvint(\vv), \vg) \OrDynError
}{
  \evallimit(\env, \overname{\langle\velimit\rangle}{\velimitopt}) \evalarrow (\overname{\langle\vv\rangle}{\vvopt}, \vg)
}
\end{mathpar}

\SemanticsRuleDef{TickLoopLimit}
The relation
\hypertarget{def-ticklooplimit}{}
\[
\ticklooplimit(\overname{\vvopt}{\N?}) \aslto \overname{\langle\vvoptp\rangle}{\N?}
\cup \overname{\TDynError}{\DynErrorConfig}
\]
decrements the optional integer $\vvopt$, yielding
the optional integer value $\vvopt$.
If the value is $0$, the result is a dynamic error.

\ExampleDef{Decrementing a Loop Limit Value}
In \listingref{semantics-swhile}, the loop limit value
starts at $\nvint(20)$ and decrements towards $\nvint(0)$,
stopping at $\nvint(1)$ on the last iteration of the loop.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vvopt$ is $\None$;
    \item $\vvoptp$ is $\None$.
  \end{itemize}

  \item \AllApplyCase{some\_ok}
  \begin{itemize}
    \item $\vvopt$ is the positive integer $\vv$;
    \item $\vvoptp$ is $\langle\vv-1\rangle$.
  \end{itemize}

  \item \AllApplyCase{some\_error}
  \begin{itemize}
    \item $\vvopt$ is the integer $0$;
    \item the result is a dynamic error indicating that a limit has been reached
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \ticklooplimit(\overname{\None}{\vvopt}) \evalarrow \overname{\None}{\vvoptp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_ok]{
  \vv > 0
}{
  \ticklooplimit(\overname{\langle\vv\rangle}{\vvopt}) \evalarrow \overname{\langle\vv-1\rangle}{\vvoptp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_error]{}{
  \ticklooplimit(\overname{\langle 0 \rangle}{\vvopt}) \evalarrow \DynamicErrorVal{\LimitExceeded}
}
\end{mathpar}

\section{Repeat Statements\label{sec:RepeatStatements}}
\hypertarget{def-repeatstatementterm}{}

\ASLListing{A repeat statement}{semantics-srepeat}{\semanticstests/SemanticsRule.SRepeat.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Trepeat \parsesep \Nstmtlist \parsesep \Tuntil \parsesep \Nexpr \parsesep \Nlooplimit \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SRepeat(\overtext{\stmt}{loop body}, \overtext{\expr}{condition}, \overtext{\expr?}{loop limit}) &
\end{flalign*}

\ASTRuleDef{SRepeat}
\begin{mathpar}
\inferrule{
  \buildexpr(\vlimitexpr) \astarrow \astversion{\vlimitexpr}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Tlooplimit, \Tlpar, \namednode{\vlimitexpr}{\Nexpr}, \Trpar, \Trepeat, \\
    \wrappedline\ \Nstmtlist, \Tuntil, \punnode{\Nexpr}, \punnode{\Nlooplimit}, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow\\
  \overname{\SRepeat(\astof{\vstmtlist}, \astof{\vexpr}, \astof{\vlooplimit})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SRepeat}
\ExampleDef{Typing a Repeat Statement}
The \repeatstatementsterm{} in \listingref{semantics-srepeat} are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement with statement block $\vsone$,
        optional limit expression $\vlimitone$, and expression $\veone$, that is, $\SRepeat(\vsone, \veone, \vlimitone)$;
  \item annotating $\vsone$ as a block statement per \TypingRuleRef{Block} in $\tenv$ yields \\
        $(\vstwo, \vsesblock)$\ProseOrTypeError;
  \item annotating the optional limit expression $\vlimitone$ via $\annotatelimitexpr$ in $\tenv$ yields $(\vlimittwo, \vseslimit)$\ProseOrTypeError;
  \item annotating the right-hand-side expression $\veone$ in $\tenv$ yields $(\vt, \vetwo, \vsese)$\ProseOrTypeError;
  \item checking that $\vt$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is a \texttt{repeat} statement with statement block $\vstwo$, optional limit expression $\vlimittwo$,
        and condition expression $\vetwo$ and , that is, $\SRepeat(\vstwo, \vetwo, \vlimittwo)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesblock$, $\vsese$, and $\vseslimit$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateblock{\tenv, \vsone} \typearrow (\vstwo, \vsesblock) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimitone) \typearrow (\vlimittwo, \vseslimit) \OrTypeError\\\\
  \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo, \vsese) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsese \cup \vseslimit
}{
  {
  \begin{array}{r}
    \annotatestmt(\tenv, \overname{\SRepeat(\vsone, \veone, \vlimitone)}{\vs}) \typearrow\\
    (\overname{\SRepeat(\vstwo, \vetwo, \vlimittwo)}{\news}, \overname{\tenv}{\newtenv}, \vses)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SRepeatBegin}{\SRepeatEnd}{../Typing.ml}
\identr{FTVN}

\subsection{Semantics}
\SemanticsRuleDef{SRepeat}
\ExampleDef{Evaluation of Repeat Statements}
The specification in \listingref{semantics-srepeat} produces the following output to the console.
% CONSOLE_BEGIN aslref  --type-check-no-warn \semanticstests/SemanticsRule.SRepeat.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
j = 0
j = 1
j = 2
j = 3
j = 4
#ones in x = 5
i = 0
i = 1
i = 2
i = 3
i = 4
#ones in x = 5
\end{Verbatim}
% CONSOLE_END

\ProseParagraph
Evaluation of the statement $\vs$ in an environment $\env$ yields
either \\ $\Returning((\vvs, \newg), \newenv)$ or an output configuration $D$.

\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement, $\SRepeat(\ve, \vbody, \velimitopt)$;
  \item evaluating the optional limit expression $\velimitopt$ via $\evallimit$ in $\env$
        yields $(\vlimitopt, \vgone)$\ProseOrError;
  \item \Proseticklooplimit{$\vlimitoptone$}{$\vlimitopttwo$}\ProseOrError;
  \item evaluating $\vbody$ in $\env$ as per \chapref{BlockStatements}
        yields $\Continuing(\vgtwo, \envone)$\ProseTerminateAs{\ReturningConfig,\ThrowingConfig,\DynErrorConfig};
  \item evaluating the loop as per \secref{SemanticsRule.Loop} in an environment $\envone$,
        with the arguments $\False$ (which conveys that this is a \texttt{repeat} statement),
        $\vlimitopttwo$,
        $\ve$,
        and $\vbody$
        results in $C$;
  \item $\vgthree$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ and the graph of $C$
        with the $\aslpo$ edge;
  \item the output configuration $D$ is the output configuration $C$ with its execution graph
        substituted with $\vgthree$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitoptone, \vgone) \OrDynError\\\\
  \ticklooplimit(\vlimitoptone) \evalarrow \vlimitopttwo \OrDynError\\\\
  \evalblock{\env, \vbody} \evalarrow \Continuing(\vgtwo, \envone) \terminateas \ReturningConfig,\ThrowingConfig,\DynErrorConfig\\\\
  \evalloop{\envone, \False, \vlimitopttwo, \ve, \vbody} \evalarrow C\\
  \vgthree \eqdef \ordered{\vgone}{\asldata}{\ordered{\vgtwo}{\aslpo}{\graphof{C}}}\\
  D \eqdef \withgraph{C}{\vgthree}
}{
  \evalstmt{\env, \overname{\SRepeat(\ve, \vbody, \velimitopt)}{\vs}} \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSRepeatBegin}{\EvalSRepeatEnd}{../Interpreter.ml}

\section{For Statements\label{sec:ForStatements}}
\hypertarget{def-forstatementterm}{}

\ASLListing{\texttt{for} loops}{semantics-sfor}{\semanticstests/SemanticsRule.SFor.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tfor \parsesep \Tidentifier \parsesep \Teq \parsesep \Nexpr \parsesep \Ndirection \parsesep
                    \Nexpr \parsesep \Nlooplimit \parsesep \Tdo &\\
                        & \wrappedline\ \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Ndirection \derives \ & \Tto \;|\; \Tdownto &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\fordirection \derives\ & \UP \;|\; \DOWN &\\
\stmt \derives\ & \SFor\left\{
      \begin{array}{rcl}
      \Forindexname  &:& \identifier,\\
      \Forstarte     &:& \expr,\\
      \Fordir        &:& \fordirection,\\
      \Forende       &:& \expr,\\
      \Forbody       &:& \stmt,\\
      \Forlimit      &:& \expr?
      \end{array}
    \right\} &
\end{flalign*}

\ASTRuleDef{SFor}
\begin{mathpar}
\inferrule{
  \buildexpr(\vstarte) \astarrow \astversion{\vstarte}\\
  \buildexpr(\vende) \astarrow \astversion{\vende}\\
}{
  {
    \begin{array}{r}
      \buildstmt\left(\overname{\Nstmt\left(
        \begin{array}{l}
        \Tfor, \Tidentifier(\vindexname), \Teq, \namednode{\vstarte}{\Nexpr},  \\
        \wrappedline\ \Ndirection, \namednode{\vende}{\Nexpr}, \punnode{\Nlooplimit}, \Tdo, \\
        \wrappedline\ \punnode{\Nstmtlist}, \Tend, \Tsemicolon
        \end{array}
        \right)}{\vparsednode}\right)
      \astarrow \\
        \overname{
        \SFor\left(\left\{
          \begin{array}{rcl}
            \Forindexname &:& \vindexname\\
            \Forstarte &:& \astversion{\vstarte}\\
            \Forende &:& \astversion{\vende}\\
            \Forbody &:& \astof{\vstmtlist}\\
            \Forlimit &:& \astof{\vlooplimit}\\
          \end{array}
            \right\}\right)
    }{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{Direction}
\hypertarget{build-direction}{}
The function
\[
\builddirection(\overname{\parsenode{\Ndirection}}{\vparsednode}) \;\aslto\; \overname{\fordirection}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[to]{}{
  \builddirection(\overname{\Ndirection(\Tto)}{\vparsednode}) \astarrow \overname{\UP}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[downto]{}{
  \builddirection(\overname{\Ndirection(\Tdownto)}{\vparsednode}) \astarrow \overname{\DOWN}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SFor}
The \texttt{for} loops in \listingref{semantics-sfor} are well-typed.

\ExampleDef{Ill-typed for loop}
\listingref{typing-forloop-bad1},
\listingref{typing-forloop-bad2},
\listingref{typing-forloop-bad3}, and
\listingref{typing-forloop-bad4}
show examples of ill-typed \texttt{for} loops.

\ASLListing{Ill-typed for loop 1}{typing-forloop-bad1}{\typingtests/TypingRule.SFor.bad1.asl}
\ASLListing{Ill-typed for loop 2}{typing-forloop-bad2}{\typingtests/TypingRule.SFor.bad2.asl}
\ASLListing{Ill-typed for loop 3}{typing-forloop-bad3}{\typingtests/TypingRule.SFor.bad3.asl}
\ASLListing{Ill-typed for loop 4}{typing-forloop-bad4}{\typingtests/TypingRule.SFor.bad4.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement with index $\vindexname$,
        start expression $\vstarte$,
        direction $\dir$,
        end expression $\vende$,
        body statement (block) $\vbody$,
        and optional limit expression $\vlimit$,
        that is, $\SFor\left\{\begin{array}{rcl}
          \Forindexname &:& \vindexname\\
          \Forstarte &:& \vstarte\\
          \fordirection &:& \vdir\\
          \Forende &:& \vende\\
          \Forbody &:& \vbody\\
          \Forlimit &:& \vlimit
        \end{array}\right\}$;
  \item annotating the right-hand-side expression $\vstarte$ in $\tenv$ yields \\
        $(\vstartt, \vstartep, \vsesstart)$\ProseOrTypeError;
  \item annotating the right-hand-side expression $\vende$ in $\tenv$ yields \\ $(\vendt, \vendep, \vsesend)$\ProseOrTypeError;
  \item annotating the optional loop limit expression $\vlimit$ via $\annotatelimitexpr$ in $\tenv$
        yields $(\vlimitp, \vseslimit)$\ProseOrTypeError;
  \item checking that $\vsesstart$ is pure via $\sesispure$ yields $\True$\ProseOrTypeError;
  \item checking that $\vsesstart$ is deterministic via $\sesisdeterministic$ yields $\True$\ProseOrTypeError;
  \item checking that $\vsesend$ is pure via $\sesispure$ yields $\True$\ProseOrTypeError;
  \item checking that $\vsesend$ is deterministic via $\sesisdeterministic$ yields $\True$\ProseOrTypeError;
  \item \Proseeqdef{$\vsescond$}{the union of $\vsesstart$, $\vsesend$, and $\vseslimit$};
  \item obtaining the \underlyingtype\ of $\vstartt$ in $\tenv$ yields $\vstartstruct$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vendt$ in $\tenv$ yields $\vendstruct$\ProseOrTypeError;
  \item applying $\getforconstraints$ to $\vstartstruct$, $\vendstruct$,
        $\vstartep$, $\vendep$, and $\dir$ in $\tenv$,
        to obtain the constraints on the loop index $\vindexname$,
        yields $\cs$\ProseOrTypeError;
  \item $\tty$ is the integer type with constraints $\cs$;
  \item checking that $\vindexname$ is not already declared in $\tenv$ yields $\True$\ProseOrTypeError;
  \item adding $\vindexname$ as a local immutable variable with type $\tty$ to $\tenv$ yields $\tenvp$;
  \item annotating $\vbody$ as a block statement in $\tenvp$ yields $(\vbodyp, \vsesblock)$\ProseOrTypeError;
  \item $\news$ is the \texttt{for} statement with index $\vindexname$,
        start expression $\vstartep$, direction $\dir$,
        end expression $\vendep$,
        body statement (block) $\vbodyp$, and
        optional limit expression $\vlimit$;
  \item $\newtenv$ is $\tenv$ (notice that this means $\vindexname$ is only declared for annotating $\vbodyp$ but then goes
        out of scope);
  \item define $\vses$ as the union of $\vsesblock$ and $\vsescond$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vstarte} \typearrow (\vstartt, \vstartep, \vsesstart) \OrTypeError\\\\
  \annotateexpr{\tenv, \vende} \typearrow (\vendt, \vendep, \vsesend) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimit) \typearrow (\vlimitp, \vseslimit) \OrTypeError\\\\
  \checktrans{\sesispure(\vsesstart)}{\SideEffectViolation} \typearrow \OrTypeError\\\\
  \checktrans{\sesisdeterministic(\vsesstart)}{\SideEffectViolation} \typearrow \OrTypeError\\\\
  \checktrans{\sesispure(\vsesend)}{\SideEffectViolation} \typearrow \OrTypeError\\\\
  \checktrans{\sesisdeterministic(\vsesend)}{\SideEffectViolation} \typearrow \OrTypeError\\\\
  \vsescond \eqdef \vsesstart \cup \vsesend \cup \vseslimit\\
  \makeanonymous(\tenv, \vstartt) \typearrow \vstartstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vendt) \typearrow \vendstruct \OrTypeError\\\\
  {
    \begin{array}{r}
  \getforconstraints(\tenv, \vstartstruct, \vendstruct, \vstartep, \vendep, \dir) \typearrow \\
    \cs \OrTypeError
    \end{array}
  }\\\\
  \tty \eqdef \TInt(\cs)\\
  \checkvarnotinenv{\tenv, \vindexname} \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \tty, \vindexname, \LDKLet) \typearrow \tenvp\\
  \annotateblock{\tenvp, \vbody} \typearrow (\vbodyp, \vsesblock) \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsescond
}{
  {
    \begin{array}{r}
  \annotatestmt\left(\tenv, \overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \vlimit
  \end{array}\right\}}{\vs}\right) \typearrow \\
  \left(\overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstartep\\
    \fordirection &:& \vdir\\
    \Forende &:& \vendep\\
    \Forbody &:& \vbodyp\\
    \Forlimit &:& \vlimitp
  \end{array}\right\}}{\news}, \overname{\tenv}{\newtenv}, \vses\right)
\end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SForBegin}{\SForEnd}{../Typing.ml}
\identr{SSBD} \identr{ZSND} \identr{VTJW}

\TypingRuleDef{SForConstraints}
\hypertarget{def-getforconstraints}{}
The function
\[
  \getforconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\structone} \aslsep
    \overname{\ty}{\structtwo} \aslsep
    \overname{\expr}{\veonep} \aslsep
    \overname{\expr}{\vetwop} \aslsep
    \overname{\dir}{\dir}
  ) \aslto
  \overname{\constraintkind}{\vis} \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
infers the integer constraints for a \texttt{for} loop index variable from the following:
\begin{itemize}
  \item the \wellconstrainedversion\ of the type of the start expression --- $\structone$
  \item the \wellconstrainedversion\ of the type of the end expression --- $\structtwo$
  \item the annotated start expression --- $\veonep$
  \item the annotated end expression --- $\vetwop$
  \item the loop direction --- $\dir$
\end{itemize}
The result is $\vis$.
\ProseOtherwiseTypeError

\ExampleDef{Inferring the Constraints of a for Loop Index}
In \listingref{semantics-sfor} the constraints for the loop index variable
\verb|j| in \verb|scan| are \verb|0..N-1|,
and the constraints for the loop index variable \verb|i| in \verb|main| are \verb|0..4|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{not\_integers}
  \begin{itemize}
    \item at least one of $\structone$ and $\structtwo$ is not an integer type;
    \item the result is a \typingerrorterm{} indicating that the start expression and end expression of \texttt{for} loops
          must have the \structure\ of integer types.
  \end{itemize}

  \item \AllApplyCase{unconstrained}
  \begin{itemize}
    \item both of $\structone$ and $\structtwo$ are integer types;
    \item at least one of $\structone$ and $\structtwo$ is the unconstrained integer type;
    \item define $\vis$ as $\unconstrained$.
  \end{itemize}

  \item \AllApplyCase{well\_constrained}
  \begin{itemize}
    \item both of $\structone$ and $\structtwo$ are integer types;
    \item neither $\structone$ nor $\structtwo$ is the unconstrained integer type;
    \item symbolically simplifying $\veonep$ in $\tenv$ yields $\eonen$\ProseOrTypeError;
    \item symbolically simplifying $\vetwop$ in $\tenv$ yields $\etwon$\ProseOrTypeError;
    \item define $\icsup$ as the single range constraint with expressions $\eonen$ and $\etwon$;
    \item define $\icsdown$ as the single range constraint with expressions $\etwon$ and $\eonen$;
    \item define $\vis$ as $\icsup$ if $\dir$ is $\UP$ and $\icsdown$ otherwise.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_integers]{
  \astlabel(\structone) \neq \TInt \lor \astlabel(\structtwo) \neq \TInt
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  \astlabel(\structone) = \TInt \land \astlabel(\structtwo) = \TInt\\
  \structone = \unconstrainedinteger \lor \structtwo = \unconstrainedinteger\\
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \overname{\unconstrained}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \astlabel(\structone) = \TInt \land \astlabel(\structtwo) = \TInt\\
  \structone \neq \unconstrainedinteger \land \structtwo \neq \unconstrainedinteger\\
  \normalize(\tenv, \veonep) \typearrow \eonen \OrTypeError\\\\
  \normalize(\tenv, \vetwop) \typearrow \etwon \OrTypeError\\\\
  \icsup \eqdef \wellconstrained([\ConstraintRange(\eonen, \etwon)])\\
  \icsdown \eqdef \wellconstrained([\ConstraintRange(\etwon, \eonen)])\\
  \vis \eqdef \choice{\dir=\UP}{\icsup}{\icsdown}
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \vis
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{SFor}
Evaluating a \texttt{for} statement involves introducing an index variable to the
environment. The type system ensures, via \TypingRuleRef{SFor}, that the index variable
is not already declared in the scope of the subprogram containing the \texttt{for}
statement.

\ExampleDef{Evaluation of For Statements}
The specification in \listingref{semantics-sfor} is followed by its output to the console.
% CONSOLE_BEGIN aslref \semanticstests/SemanticsRule.SFor.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
j = 0
j = 1
j = 2
j = 3
j = 4
#ones in x = 5
i = 4
i = 3
i = 2
i = 1
i = 0
#ones in x = 5
\end{Verbatim}
% CONSOLE_END

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement, $\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \Ignore
  \end{array}\right\}$;
  \item evaluating the side-effect-free expression $\vstarte$ in $\env$ yields
        $\Normal(\vstartv, \vgone)$\ProseOrError;
  \item evaluating the side-effect-free expression $\vende$ in $\env$ yields
        $\Normal(\vendv, \vgtwo)$\ProseOrError;
  \item \Proseevallimit{$\env$}{$\velimitopt$}{$\Normal(\vlimitopt, \vgthree)$}\ProseOrError;
  \item declaring the local identifier $\vindexname$ in $\env$ with value $\vstartv$ is $(\vgfour, \envone)$;
  \item evaluating the \texttt{for} loop with arguments $(\vindexname, \vlimitopt, \vstartv, \dir, \vendv, \vbody)$ in $\envone$,
        as per \SemanticsRuleRef{EvalFor} yields $\Normal(\vgfive, \envtwo)$\ProseOrAbnormal;
  \item removing the local $\vindexname$ from $\envtwo$ is $\envthree$;
  \item $\newg$ is formed as follows:
        the parallel composition of $\vgone$, $\vgtwo$, and $\vgthree$;
        followed by the ordered composition of the result with $\vgfour$ using the $\asldata$ edge;
        followed by the ordered composition of the result with $\vgfive$ using the $\aslpo$ edge.
  \item $\newenv$ is $\envthree$.
  \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
\end{itemize}

\FormallyParagraph
Recall that the expressions for the \texttt{for} loop range are
side-effect-free, as guaranteed by \TypingRuleRef{SFor}, which is why
they are evaluated via the rule for evaluating side-effect-free expressions.
\begin{mathpar}
\inferrule{
  \evalexprsef{\env, \vstarte} \evalarrow \Normal(\vstartv, \vgone) \OrDynError\\\\
  \evalexprsef{\env, \vende} \evalarrow \Normal(\vendv, \vgtwo) \OrDynError\\\\
  \evallimit(\env, \velimitopt) \evalarrow \Normal(\vlimitopt, \vgthree) \OrDynError\\\\
  \declarelocalidentifier(\env, \vindexname, \vstartv) \evalarrow (\vgfour,\envone)\\
  {
    \begin{array}{r}
      \evalfor(\envone, \vindexname, \vlimitopt, \vstartv, \dir, \vendv, \vbody) \evalarrow \\
      \Normal(\vgfive, \envtwo) \OrAbnormal
    \end{array}
  }\\
  \removelocal(\envtwo, \vindexname) \evalarrow \envthree\\
  \newg \eqdef \ordered{(\vgone \parallelcomp \vgtwo \parallelcomp \vgthree)}{\asldata}{ \ordered{\vgfour}{\aslpo}{\vgfive}   }\\
  \newenv \eqdef \envthree
}{
  {
  \begin{array}{r}
  \evalstmt{\env,
  \overname{
  \SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \velimitopt\\
  \end{array}\right\}}{\vs}} \evalarrow \\ \Continuing(\newg, \newenv)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EvalSForBegin}{\EvalSForEnd}{../Interpreter.ml}

\SemanticsRuleDef{EvalFor}
The relation
\hypertarget{def-evalfor}{}
\[
  \evalfor(
    \overname{\envs}{\env} \aslsep
    \overname{\Identifiers}{\vindexname} \aslsep
    \overname{\langle\tint\rangle}{\vlimitopt} \aslsep
    \overname{\tint}{\vstart} \aslsep
    \overname{\{\UP, \DOWN\}}{\dir} \aslsep
    \overname{\tint}{\vend} \aslsep
    \overname{\stmt}{\vbody})
  \;\aslrel\;
  \left(
    \begin{array}{cl}
    \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TContinuing}{\ContinuingConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup\\
    \overname{\TDynError}{\DynErrorConfig} &
    \end{array}
    \right)
\]
evaluates the \texttt{for} loop with the index variable $\vindexname$,
optional limit value $\vlimitopt$,
starting from the value
$\vstart$ going in the direction given by $\dir$ until the value given by $\vend$,
executing $\vbody$ on each iteration.
%
The evaluation utilizes two helper relations: $\evalforstep$ and $\evalforloop$.

\hypertarget{def-evalforstep}{}
The helper relation
\[
  \evalforstep(
    \overname{\envs}{\env},
    \overname{\Identifiers}{\vindexname},
    \overname{\langle\tint\rangle}{\vlimitopt} \aslsep
    \overname{\tint}{\vstart},
    \overname{\{\UP,\DOWN\}}{\dir})
    \;\aslrel\;
    ((\overname{\tint}{\vstep} \times \overname{\envs}{\newenv}) \times \overname{\XGraphs}{\newg})
\]
either increments or decrements the index variable,
returning the new value of the index variable, the modified environment,
and the resulting execution graph.

\hypertarget{def-evalforloop}{}
The helper relation
\[
  \evalforloop(\overname{
    \envs}{\env},
    \overname{\Identifiers}{\vindexname},
    \overname{\langle\tint\rangle}{\vlimitopt},
    \overname{\tint}{\vstart},
    \overname{\{\UP,\DOWN\}}{\dir},
    \overname{\tint}{\vend},
    \overname{\stmt}{\vbody}) \;\aslrel\;
    \left(
    \begin{array}{cl}
      \overname{\TContinuing}{\Continuing(\newg, \newenv)} & \cup\\
      \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup \\
    \overname{\TDynError}{\DynErrorConfig} &
    \end{array}
    \right)
\]
executes one iteration of the loop body and then uses $\texttt{eval\_for}$ to execute the remaining
iterations.

\ProseParagraph
\subsubsection{Stepping the Index Variable}
\AllApply
\begin{itemize}
  \item $\opfordir$ is either $\PLUS$ when $\dir$ is $\UP$ or $\MINUS$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item applying the binary operator $\opfordir$ to $\vstart$ and the native integer for $1$ is $\vstep$;
  \item the execution graph for writing $\vstep$ into the identifier $\vindexname$ gives $\vgtwo$;
  \item updating the local component of the dynamic environment of $\env$ by binding \\ $\vindexname$ to $\vstep$
  gives $\newenv$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}

\subsubsection{Running the Loop Body}
\AllApply
\begin{itemize}
  \item evaluating $\vbody$ as a block statement (see \SemanticsRuleRef{Block}) in $\env$
        yields \\ $\Continuing(\vgone, \envone)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
  \item stepping the index $\vindexname$ with $\vstart$ and the direction $\dir$ in $\envone$,
        that is, $\evalforstep(\envone, \vindexname, \vlimitopt, \vstart, \dir)$ yields \\
        $((\vstep, \envtwo), \vgtwo)$;
  \item evaluating the \texttt{for} loop with $(\vindexname, \vlimitopt, \vstep, \dir, \vend, \vbody)$
        in $\envtwo$ results in a continuing configuration $\Continuing(\vgthree, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
  \item $\newg$ is the ordered composition of $\vgone$, $\vgtwo$, and $\vgthree$ with the $\aslpo$
        edge.
\end{itemize}

\subsubsection{Overall Evaluation}
\ExampleDef{Overall Evaluation of For Statements}
The specification in \listingref{semantics-sfor}
does not result in any assertion error, and terminates with exit-code $0$.

Evaluating $(\vindexname, \vstart, \dir, \vend, \vbody)$ in $\env$ yields either
a continuing configuration $\Continuing(\newg, \newenv)$, or a returning configuration
(in case the body of the loop results in an early return),
or an abnormal configuration.

\AllApply
\begin{itemize}
  \item \Proseticklooplimit{$\vlimitopt$}{$\vnextlimitopt$}\ProseOrError;
  \item $\compfordir$ is either $\LT$ when $\dir$ is $\UP$ or $\GT$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item \OneApplies
    \begin{itemize}
    \item \AllApplyCase{return}
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native Boolean for $\True$;
      \item $\newg$ is $\vgone$;
      \item $\newenv$ is $\env$;
      \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}
    \item \AllApplyCase{continue}
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native Boolean for $\False$;
      \item evaluating the loop body via $\evalforloop$ with \\ $(\vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody)$
      in $\env$ is \\ $\Continuing(\vgtwo, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
      \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
Advancing the loop counter one step towards the end of its range is achieved via the following rule:
\begin{mathpar}
\inferrule{
  \opfordir \eqdef \choice{\dir = \UP}{\PLUS}{\MINUS}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\
  \binoprel(\opfordir, \vstart, \nvint(1)) \evalarrow \vstep\\
  \writeidentifier(\vindex, \vstep) \evalarrow \vgtwo\\
  \env \eqname (\tenv, \denv)\\
  \newenv \eqdef (\tenv, (G^\denv, L^\denv[\vindexname\mapsto\vstep]))\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  {
    \begin{array}{r}
      \evalforstep(\env, \vindexname, \vlimitopt, \vstart, \dir) \evalarrow \\
      ((\vstep, \newenv), \newg)
    \end{array}
  }
}
\end{mathpar}

Running the loop body is achieved via the following rule:
\begin{mathpar}
\inferrule{
  \evalblock{\env, \vbody} \evalarrow \Continuing(\vgone, \envone) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig\\
  \evalforstep(\envone, \vindexname, \vlimitopt, \vstart, \dir) \evalarrow ((\vstep, \envtwo), \vgtwo)\\
  {
    \begin{array}{r}
      \evalfor(\envtwo, \vindexname, \vlimitopt, \vstep, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\vgthree, \newenv) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig
    \end{array}
  }\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\vgthree}
}{
  {
    \begin{array}{r}
      \evalforloop(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\newg, \newenv)
    \end{array}
  }
}
\end{mathpar}

Finally, the rules for evaluating a \texttt{for} loop utilize both $\evalforstep$
and \\
$\evalforloop$ (the latter in a mutually recursive manner):
\begin{mathpar}
\inferrule[return]{
  \ticklooplimit(\vlimitopt) \evalarrow \vnextlimitopt \OrDynError\\\\
  \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\\\
  \commonprefixline\\\\
  \binoprel(\compfordir, \vend, \vstart) \evalarrow \nvbool(\True)
}{
  {
    \begin{array}{r}
      \evalfor(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\overname{\vgone}{\newg}, \overname{\env}{\newenv})
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[continue]{
  \ticklooplimit(\vlimitopt) \evalarrow \vnextlimitopt \OrDynError\\\\
  \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\\\
  \commonprefixline\\\\
  \binoprel(\compfordir, \vend, \vstart) \evalarrow \nvint(\False)\\
  \evalforloop(\env, \vindexname, \vnextlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
  \Continuing(\vgtwo, \newenv) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig\\\\
  \newg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
}{
  {
    \begin{array}{r}
      \evalfor(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\newg, \newenv)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EvalForBegin}{\EvalForEnd}{../Interpreter.ml}

\hypertarget{def-throwstatementterm}{}
\section{Throw Statements\label{sec:ThrowStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tthrow \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Tthrow \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SThrow(\expr?) &
\end{flalign*}

\ASTRuleDef{SThrow}
\begin{mathpar}
\inferrule[throw\_some]{}{
  \buildstmt(\overname{\Nstmt(\Tthrow, \Nexpr, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SThrow(\langle\astof{\vexpr}\rangle)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[throw\_none]{}{
  \buildstmt(\overname{\Nstmt(\Tthrow, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SThrow(\None)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SThrow}
\listingref{semantics-sthrownone} and \listingref{semantics-sthrowsometyped}
show examples of well-typed \throwstatementsterm.

\newcommand\NoNameException[0]{\texttt{\_}}
\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a throw statement with no expression, that is, $\SThrow(\None)$;
    \item $\news$ is $\vs$;
    \item $\newtenv$ is $\tenv$;
    \item \Proseeqdef{$\vses$}{the singleton set for $\ThrowException(\NoNameException)$}
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a throw statement with expression $\ve$, that is, $\SThrow(\langle\ve\rangle)$;
    \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte, \vep, \vsesone)$\ProseOrTypeError;
    \item checking that $\vte$ has the structure of an exception type yields $\True$\ProseOrTypeError;
    \item view $\vte$ as the named type for $\exnname$;
    \item $\news$ is a throw statement with expression $\vep$ and type $\vte$, that is, \\
          $\SThrow(\langle (\vep, \vte) \rangle)$;
    \item $\newtenv$ is $\tenv$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesone$ and the singleton set for \\
          $\ThrowException(\exnname)$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \annotatestmt(\tenv, \overname{\SThrow(\None)}{\vs}) \typearrow
  (\overname{\SThrow(\None)}{\news}, \overname{\tenv}{\newtenv}, \overname{\{\ThrowException(\NoNameException)\}}{\vses})
}
\end{mathpar}
\lrmcomment{Note that \identr{BRCJ} is done in~\cite[SemanticsRule.TopLevel]{ASLSemanticsReference}.}

\begin{mathpar}
\inferrule[some]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep, \vsesone) \OrTypeError\\\\
  \checkstructurelabel(\tenv, \vte, \TException) \typearrow \True \OrTypeError\\\\
  \vte \eqname \TNamed(\exnname)\\
  \vses \eqdef \vsesone \cup \{\ThrowException(\exnname)\}
}{
  \annotatestmt(\tenv, \overname{\SThrow(\langle\ve\rangle)}{\vs}) \typearrow
  (\overname{\SThrow(\langle (\vep, \vte) \rangle)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\identr{NXRC}
\CodeSubsection{\SThrowBegin}{\SThrowEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SThrow}
\ExampleDef{Rethrowing an Exception}
The specification in \listingref{semantics-sthrownone}
first catches the exception raised by \\
\verb|throw MyExceptionType{a=42}|
and then raises it in the catch clause via \verb|throw;|,
catching it again in the outer \texttt{try-catch} statement.
\ASLListing{Rethrowing an exception}{semantics-sthrownone}{\semanticstests/SemanticsRule.SThrowNone.asl}

\ExampleDef{Throwing a Typed Exception}
The specification in \listingref{semantics-sthrowsometyped}
terminates successfully. That is, no dynamic error occurs.
\ASLListing{Throwing an exception}{semantics-sthrowsometyped}{\semanticstests/SemanticsRule.SThrowSomeTyped.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
  \item $\vs$ is a \texttt{throw} statement that does not provide an expression, $\SThrow(\None)$;
  \item $\newenv$ is $\env$;
  \item $\vex$ is $\None$;
  \item $\newg$ is the empty graph;
  \item an exception is thrown with $\newenv$.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a \texttt{throw} statement that provides an expression and a type, \\
          $\SThrow(\langle(\ve, \vt)\rangle)$;
    \item evaluating $\ve$ in $\env$ is $\Normal((\vv, \vgone), \newenv)$\ProseOrAbnormal;
    \item $\name$ is a fresh identifier (which conceptually holds the exception value);
    \item $\vgtwo$ is a Write Effect to $\name$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge;
    \item $\vex$ consists of the exception value $\vv$, the name of the variable holding it ---
          $\name$, and the type annotation for the exception --- $\vt$;
    \item the result of the entire evaluation is $\Throwing((\vex, \newg), \env)$.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}
{
  \evalstmt{\env, \SThrow(\None)} \evalarrow \Throwing((\None, \emptygraph), \env)
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\
  \name\in\Identifiers \text{ is fresh}\\
  \vgtwo \eqdef \WriteEffect(\name)\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}\\
  \vex \eqdef \langle(\valuereadfrom(\vv, \name),\vt)\rangle
}{
  \evalstmt{\env, \SThrow(\langle(\ve, \vt)\rangle)} \evalarrow
  \Throwing((\vex, \newg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSThrowBegin}{\EvalSThrowEnd}{../Interpreter.ml}

\hypertarget{def-trystatementterm}{}
\section{Try Statements\label{sec:TryStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Ttry \parsesep \Nstmtlist \parsesep \Tcatch \parsesep \ListOne{\Ncatcher} \parsesep \Notherwiseopt &\\
                  & \wrappedline\ \parsesep \Tend \parsesep \Tsemicolon &\\
\Notherwiseopt \derives\ & \Totherwise \parsesep \Tarrow \parsesep \Nstmtlist &\\
               |\ & \emptysentence &\\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \STry(\stmt, \catcher^*, \overtext{\stmt?}{otherwise}) &
\end{flalign*}

\ASTRuleDef{STry}
\begin{mathpar}
\inferrule{
  \buildlist[\Ncatcher] \astarrow \astversion{\vcatcherlist}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Ttry, \Nstmtlist, \Tcatch,  \\
    \wrappedline\ \namednode{\vcatcherlist}{\ListOne{\Ncatcher}}, \\
    \wrappedline\ \Notherwiseopt, \Tend, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{\STry(\astof{\vstmtlist}, \astversion{\vcatcherlist}, \astof{\votherwiseopt})}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{OtherwiseOpt}
\hypertarget{build-otherwiseopt}{}
The function
\[
   \buildotherwiseopt(\overname{\parsenode{\Notherwiseopt}}{\vparsednode}) \aslto
    \overname{\langle\stmt\rangle}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[non\_empty]{
  \buildstmtlist(\vstmts) \astarrow \astversion{\vstmts}
}{
  {
  \begin{array}{r}
    \buildotherwiseopt(\overname{\Notherwiseopt(\Totherwise, \Tarrow, \namednode{\vstmts}{\Nstmtlist})}{\vparsednode}) \astarrow\\
    \astversion{\vstmts}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty]{}{
  \buildotherwiseopt(\overname{\Notherwiseopt(\emptysentence)}{\vparsednode}) \astarrow \None
}
\end{mathpar}

\subsection{Typing}

\ExampleDef{Typing Try Statements}
\TypingRuleDef{STry}
In
\listingref{semantics-catchnamed},
\listingref{semantics-catchotherwise},
\listingref{semantics-catchnone},
\listingref{semantics-nothrow}, and
\listingref{semantics-stry},
the \trystatementsterm{} are all well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a try statement with statement $\vsp$, list of catchers $\catchers$ and an \optional\ \texttt{otherwise} block;
  \item annotating the statement $\vsp$ as a block statement yields $(\vspp, \vsesone)$\ProseOrTypeError;
  \item annotating each catcher $\catchers[\vi]$, for each $\vi$ in $\listrange(\catchers)$ in $\tenv$ yields $\vc\_\vi$
        and $\vxs_i$\ProseOrTypeError;
  \item $\catchersp$ is the list of annotated catchers $\vc\_\vi$ for each $\vi\in\listrange(\catchers)$;
  \item \Proseeqdef{$\vsescatchers$}{the union of all $\vxs_\vi$, for \Proselistrange{$\vi$}{$\catchers$}};
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{no\_otherwise}
    \begin{itemize}
      \item there is no \texttt{otherwise} statement;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and no \texttt{otherwise} statement,
            that is \\
            $\STry(\vspp, \catchersp, \None)$;
      \item \Proseeqdef{$\vsesotherwise$}{the empty set};
      \item \Proseeqdef{$\vsesthree$}{$\vsestwo$}.
    \end{itemize}

    \item \AllApplyCase{otherwise}
    \begin{itemize}
      \item there is an \texttt{otherwise} statement $\otherwise$;
      \item annotating the statement $\otherwise$ as a block statement in $\tenv$ yields $\otherwisep$\ProseOrTypeError;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and \texttt{otherwise} statement
            $\otherwisep$, that is \\
            $\STry(\vspp, \catchersp, \langle\otherwisep\rangle)$;
      \item \Proseeqdef{$\vsesotherwise$}{$\vsesblock$};
      \item \Proseeqdef{$\vsesthree$}{$\vsestwo$, excluding any \ThrowExceptionTerm}.
    \end{itemize}

    \item \Proseeqdef{$\vses$}{the union of $\vsesthree$, $\vsescatchers$, and $\vsesotherwise$}.
  \end{itemize}
  \item $\newtenv$ is $\tenv$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_otherwise]{
  \annotateblock{\tenv, \vsp} \typearrow (\vspp, \vsesone) \OrTypeError\\\\
  \vi\in\listrange(\catchers): \annotatecatcher{\tenv, \catchers[\vi]} \typearrow (\vc_\vi, \vxs_vi) \OrTypeError\\\\
  \catchersp \eqdef [\vi\in\listrange(\catchers) : \vc_\vi]\\\\
  \vsescatchers \eqdef \bigcup_{\vi\in\listrange(\catchers)} \vxs_vi\\\\
  \commonprefixline\\\\
  \news \eqdef \STry(\vspp, \catchersp, \None)\\
  \vsesotherwise \eqdef \emptyset\\
  \vsesthree \eqdef \vsestwo\\\\
  \commonsuffixline\\\\
  \vses \eqdef \vsesthree \cup \vsescatchers \cup \vsesotherwise
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \None)}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv}, \vses)
}
\and
\inferrule[otherwise]{
  \annotateblock{\tenv, \vsp} \typearrow (\vspp, \vsesone) \OrTypeError\\\\
  \vi\in\listrange(\catchers): \annotatecatcher{\tenv, \catchers[\vi]} \typearrow (\vc_\vi, \vxs_vi) \OrTypeError\\\\
  \catchersp \eqdef [\vi\in\listrange(\catchers) : \vc_\vi]\\\\
  \vsescatchers \eqdef \bigcup_{\vi\in\listrange(\catchers)} \vxs_i\\\\
  \commonprefixline\\\\
  \annotateblock{\tenv, \otherwise} \typearrow (\otherwisep, \vsesblock) \OrTypeError\\\\
  \news \eqdef \STry(\vspp, \catchersp, \otherwise')\\
  \vsesotherwise \eqdef \vsesblock\\
  \vsesthree \eqdef \vsestwo \setminus \{ \vs \in \TSideEffectSet \;|\; \configdomain{\vs} = \ThrowException\} \\\\
  \commonsuffixline\\\\
  \vses \eqdef \vsescatchers \cup \vsesotherwise
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \langle\otherwise\rangle)}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\STryBegin}{\STryEnd}{../Typing.ml}
\identr{WVXS}

\subsection{Semantics}
\SemanticsRuleDef{STry}
\ExampleDef{Evaluation of Try Statements}
Evaluating the specification in \listingref{semantics-stry}
does not result in any Assertion error, and the specification terminates with the exit code $0$.
\ASLListing{Evaluating a \texttt{try} statement}{semantics-stry}{\semanticstests/SemanticsRule.STry.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{try} statement, $\STry(\vs, \catchers, \otherwiseopt)$;
  \item evaluating $\vsone$ in $\env$ as per \chapref{BlockStatements}
        yields the configuration $\sm$\ProseOrError;
  \item evaluating $(\catchers, \otherwiseopt, \sm)$ as per \chapref{CatchingExceptions}
        is $C$, which is the result of the entire evaluation.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalblock{\env, \vsone} \evalarrow \sm \OrDynError\\\\
  \evalcatchers{\env, \catchers, \otherwiseopt, \sm} \evalarrow C
}{
  \evalstmt{\env, \STry(\vsone, \catchers, \otherwiseopt)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalSTryBegin}{\EvalSTryEnd}{../Interpreter.ml}

\hypertarget{def-returnstatementterm}{}
\section{Return Statements\label{sec:ReturnStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Treturn \parsesep \option{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
  \stmt \derives\ & \SReturn(\expr?) &
\end{flalign*}

\ASTRuleDef{SReturn}
\begin{mathpar}
\inferrule{
  \buildoption[\Nexpr](\vexpr) \astarrow \astversion{\vexpr}
}{
  \buildstmt(\overname{\Nstmt(\Treturn, \namednode{\vexpr}{\option{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SReturn(\astversion{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SReturn}

\ExampleDef{Typing Return Statements}
The \returnstatementsterm{} in
\listingref{semantics-sreturn},
\listingref{semantic-ssreturnone}, and
\listingref{semantics-sreturntuple}
are all well-typed.

The return statement \verb|return 0;| in \listingref{typing-return-bad} is ill-typed,
since \verb|proc| is not a function but a procedure.
\ASLListing{An ill-typed return statement}{typing-return-bad}{\typingtests/TypingRule.SReturn.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{error}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with an optional expression $\veopt$, that is, \\
          $\SReturn(\veopt)$;
    \item the condition that $\veopt$ is $\None$ if and only if the enclosing subprogram does not have a return type
          (that is, $\returntype$ in the local static environment is $\None$) does not hold;
    \item the result is an error indicating the mismatch between the declared (existence of the) return type
          and the (existence of the) return expression.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
    \item the enclosing subprogram does not have a \texttt{return} type (it is either a setter
          or a procedure);
    \item $\news$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
    \item $\newtenv$ is $\tenv$;
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with an expression $\ve$, that is, $\SReturn(\langle \vep \rangle)$;
    \item the enclosing subprogram has a return type $\vt$;
    \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tep,\vep,\vses)$\ProseOrTypeError;
    \item checking whether $\vtep$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\news$ is a \texttt{return} statement with value $\vep$, that is, $\SReturn(\langle \vep \rangle)$;
    \item $\newtenv$ is $\tenv$.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[error]{
  \vb \eqdef (L^\tenv.\returntype = \None \leftrightarrow \veopt = \None) \\
  \vb = \False
}{
  \annotatestmt(\tenv, \overname{\SReturn(\veopt)}{\vs}) \typearrow \TypeErrorVal{\BadSubprogramDeclaration}
}
\end{mathpar}

\begin{mathpar}
\inferrule[none]{
  L^\tenv.\returntype = \None
}{
  \annotatestmt(\tenv, \overname{\SReturn(\None)}{\vs}) \typearrow
  (\overname{\SReturn(\None)}{\news}, \overname{\tenv}{\newtenv}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  L^\tenv.\returntype = \langle \vt \rangle\\
  \annotateexpr{\tenv, \ve} \typearrow (\vtep, \vep, \vses) \OrTypeError\\\\
  \checktypesat(\tenv, \vtep, \vt) \typearrow \True \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SReturn(\langle \ve \rangle)}{\vs}) \typearrow
  (\overname{\SReturn(\langle \vep \rangle)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SReturn}{\SReturnEnd}{../Typing.ml}
\identr{FTPK}

\subsection{Semantics}
\SemanticsRuleDef{SReturn}
\ExampleDef{No Return Value}
The specification in \listingref{semantics-sreturn} exits the procedure \texttt{println\_me}
by evaluating the \texttt{return;} statement.
\ASLListing{Evaluating a \texttt{return} statement with no value}{semantics-sreturn}{\semanticstests/SemanticsRule.SReturnNone.asl}

\ExampleDef{Returning a Single Value}
In \listingref{semantic-ssreturnone},
\texttt{return 3;} exits the function \texttt{f} with value \texttt{3}.
\ASLListing{Evaluating a \texttt{return} statement with a single value}{semantic-ssreturnone}{\semanticstests/SemanticsRule.SReturnOne.asl}

\ExampleDef{Returning a Tuple of Values}
In \listingref{semantics-sreturntuple},
\texttt{return (3, 42);} exits the function \texttt{f} with the value \texttt{(3, 42)}.
\ASLListing{Evaluating a \texttt{return} statement with a tuple of values}{semantics-sreturntuple}{\semanticstests/SemanticsRule.SReturnSome.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement, $\SReturn(\None)$;
    \item $\vvs$ is the empty list, $\emptylist$;
    \item $\newg$ is the empty graph;
    \item $\newenv$ is $\env$.
  \end{itemize}

  \item \AllApplyCase{one}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement;
    \item $\vs$ is a \texttt{return} statement for a single expression, $\SReturn(\langle\ve\rangle)$;
    \item evaluating $\ve$ in $\env$ is $\Normal((\vv, \vgone), \newenv)$\ProseOrAbnormal;
    \item $\vvs$ is $[\vv]$;
    \item $\vgtwo$ is the result of adding a Write Effect for a fresh identifier and the value $\vv$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement for a list of expressions, $\SReturn(\langle\ETuple(\es)\rangle)$;
    \item evaluating each expression in $\es$ separately as per \secref{SemanticsRule.EExprListM}
    is \\ $\Normal(\ms, \newenv)$\ProseOrAbnormal;
    \item writing the list of values in $\vms$ results in $(\vvs, \newg)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}
{
  \evalstmt{\env, \SReturn(\None)} \evalarrow \Returning((\emptylist, \emptygraph), \env)
}
\end{mathpar}

\begin{mathpar}
\inferrule[one]{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \wid \in \Identifiers\text{ is fresh}\\
  \writeidentifier(\wid, \vv) \evalarrow \vgtwo\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalstmt{\env, \SReturn(\langle\ve\rangle)} \evalarrow \Returning(([\vv], \newg), \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \evalexprlistm(\env, \es) \evalarrow \Normal(\ms, \newenv) \OrAbnormal\\
  \writefolder(\ms) \evalarrow (\vvs, \newg)
}{
  \evalstmt{\env, \SReturn(\langle\ETuple(\es)\rangle)} \evalarrow \Returning((\vvs, \newg), \newenv)
}
\end{mathpar}
\CodeSubsubsection{\SReturnBegin}{\EvalSReturnEnd}{../Interpreter.ml}

\SemanticsRuleDef{EExprListM}
\hypertarget{def-evalexprlistm}{}
The helper relation
\[
  \evalexprlistm(\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vEs}) \;\aslrel\;
          \Normal(\overname{(\vals\times\XGraphs)^* }{\vms} \aslsep \overname{\envs}{\newenv}) \cup
          \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates a list of expressions $\vEs$ in left-to-right in the initial environment $\env$
and returns the list of values associated with graphs $\vms$ and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.

\ExampleDef{Seperately Evaluating a List of Expressions}
In \listingref{semantics-sreturntuple}, the expressions \verb|3| and \verb|42|
are evaluated in left-to-right order in the statement \verb|return (3 , 42);|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vEs$ is an empty list;
    \item $\vms$ is then empty list.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vEs$ is a list with \head\ $\ve$ and \tail\ $\vesone$;
    \item evaluating $\ve$ in $\env$ yields $\Normal(\vmone, \envone)$\ProseOrAbnormal;
    \item evaluating $\vesone$ in $\envone$ via $\evalexprlistm$ yields \\
          $\Normal(\vmsone, \newenv)$\ProseOrAbnormal;
    \item the result is the normal configuration with the list consisting of $\vmone$ as its \head\ and $\vmsone$
          as its \tail\ and $\newenv$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \evalexprlistm(\env, \overname{\emptylist}{\vEs}) \evalarrow \Normal(\overname{\emptylist}{\vms}, \overname{\env}{\newenv})
}
\end{mathpar}

\subsubsection{Semantics}
\begin{mathpar}
\inferrule[non\_empty]{
  \vEs \eqname [\ve] \concat \vesone\\
  \evalexpr{\env, \ve} \evalarrow \Normal(\vmone, \envone) \OrAbnormal\\
  \evalexprlistm(\envone, \vesone) \evalarrow \Normal(\vmsone, \newenv) \OrAbnormal
}{
  \evalexprlistm(\env, \vEs) \evalarrow \Normal([\vmone]\concat\vmsone, \newenv)
}
\end{mathpar}

\SemanticsRuleDef{WriteFolder}
\hypertarget{def-writefolder}{}
The helper relation
\[
  \writefolder(\overname{(\vals\times\XGraphs)^*}{\vms}) \aslrel (\overname{\vals^*}{\vvs}, \overname{\XGraphs}{\newg}) \enspace,
\]
concatenates the input values in $\vms$ and generates an execution graph
by composing the graphs in $\vms$ with Write Effects for the respective values.

\ExampleDef{Folding a List of Pairs with Values and Execution Graphs}
In \listingref{semantics-sreturntuple}, the statement \verb|return (3 , 42);|
uses $\writefolder$ to generate \\
$([\nvint(3), \nvint(42)], \emptygraph)$.
The \executiongraph{} is empty, since literal expressions do not yield
\executiongraphs{} and composing empty \executiongraphs{} yields an
empty \executiongraph{}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vms$ is the empty list;
    \item \Proseeqdef{$\vvs$}{the empty list};
    \item \Proseeqdef{$\newg$}{the empty graph}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vms$ is a list with \head{} $\vm$ and \tail{} $\vmsone$;
    \item view $\vm$ as the \nativevalue{} $\vv$ and the \executiongraph{} $\vg$;
    \item \Proseeqdef{$\wid$}{a fresh identifier};
    \item applying $\writeidentifier$ to $\wid$ and $\vv$ yields $\vgone$;
    \item applying $\writefolder$ to $\vms$ and $\vgone$ yields the pair $(\vvsone, \vgtwo)$;
    \item \Proseeqdef{$\vvs$}{the list with \head{} $\vv$ and \tail{} $\vvsone$};
    \item \Proseeqdef{$\newg$}{the ordered composition of $\vg$ and $\vgone$ with the $\aslpo$ edge
          and $\vgtwo$ with the $\asldata$ edge}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \writefolder(\overname{\emptylist}{\vms}) \evalarrow (\overname{\emptylist}{\vvs}, \overname{\emptygraph}{\newg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vms \eqname [\vm] \concat \vmsone\\
  \vm \eqdef (\vv, \vg)\\
  \wid \in \Identifiers\text{ is fresh}\\
  \writeidentifier(\wid, \vv) \evalarrow \vgone\\
  \writefolder(\vmsone, \vgone) \evalarrow (\vvsone, \vgtwo)\\
  \vvs \eqdef [\vv] \concat \vvsone\\
  \newg \eqdef \ordered{\vg}{\aslpo}{\ordered{\vgone}{\asldata}{\vgtwo}}
}{
  \writefolder(\vms) \evalarrow (\vvs, \newg)
}
\end{mathpar}

\hypertarget{def-printstatementterm}{}
\section{Print Statements\label{sec:PrintStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tprint \parsesep \PlistZero{\Nexpr} \parsesep \Tsemicolon & \\
\Nstmt \derives \ & \Tprintln \parsesep \PlistZero{\Nexpr} \parsesep \Tsemicolon & \\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
  \stmt \derives\ & \SPrint(\overtext{\expr^*}{args}, \overtext{\Bool}{newline}) &
\end{flalign*}

\ASTRuleDef{SPrint}
\begin{mathpar}
\inferrule{%
  \buildplist[\Nexpr](\vargs) \astarrow \astversion{\vargs} \\
  \vnewline \eqdef \False \\
}{%
  \buildstmt(\overname{\Nstmt(\Tprint, \namednode{\vargs}{\PlistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPrint(\astversion{\vargs}, \vnewline)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule{%
  \buildplist[\Nexpr](\vargs) \astarrow \astversion{\vargs} \\
  \vnewline \eqdef \True \\
  \vdebug \eqdef \False \\
}{%
  \buildstmt(\overname{\Nstmt(\Tprintln, \namednode{\vargs}{\PlistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPrint(\astversion{\vargs}, \vnewline)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SPrint}
\listingref{literals1} shows literals and their corresponding types in comments.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ denotes the print statement with arguments $\vargs$ and newline indicator $\vnewline$;
  \item annotating for each \Proselistrange{$i$}{$\vargs$}, the expression $\vargs_i$ in $\tenv$ yields $(\vt_i, \vargsp_i, \vxs_i)$\ProseOrTypeError;
  \item checking for each \Proselistrange{$i$}{$\vargs$}, that $\vt_i$ is a singular type yields $\True$\ProseOrTypeError;
  \item $\news$ denotes the print statement with arguments $\vargsp$ and newline indicator $\vnewline$;
  \item $\newtenv$ is $\tenv$;
  \item define $\vses$ as the union of $\vxs_i$, \Proselistrange{$i$}{$\vargs$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule{%
    \vi\in\listrange(\vargs): \annotateexpr{\vargs[i], \tenv} \typearrow (\vt_i, \vargsp[i], \vxs_i)\OrTypeError \\\\
    \vi\in\listrange(\vargs): \checktrans{\issingular(\vt_i)}{\UnexpectedType} \typearrow \True \OrTypeError \\\\
    \vses \eqdef \bigcup_{\vi\in\listrange(\vargs)} \vxs_i
  }{%
    \annotatestmt (\tenv, \overname{\SPrint(\vargs, \vnewline)}{\vs}) \typearrow (\SPrint(\vargsp, \vnewline), \tenv, \vses)
  }
\end{mathpar}
\CodeSubsection{\SPrintBegin}{\SPrintEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SPrint}

\ExampleDef{Printing Literals}
\listingref{semantics-literals} shows examples of printing various types of literals,
followed by the output to the console resulting from running the specification.
\ASLListing{Literals and how they are displayed}{semantics-literals}{\semanticstests/SemanticsRule.SPrint.asl}
% CONSOLE_BEGIN aslref \semanticstests/SemanticsRule.SPrint.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
string_number_1
0
1000000
53170898287292728730499578000
TRUE
FALSE
12345678900123456789/10000000000
0
hello\world
	 "here I am "
0xd
0x
LABEL_B
\end{Verbatim}
% CONSOLE_END

Notice that empty bitvectors are displayed as \verb|0x|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{print}
  \begin{itemize}
    \item $\vs$ denotes a Print statement with arguments $\elist$ and newline indicator $\False$;
    \item the evaluation of $\elist$ in $\env$ is $\Normal((\vlist, \vg), \newenv)$\ProseOrAbnormal;
    \item \Proseoutputtoconsole{all the elements in $\elist$, without a separator,};
    \item if $\vnewline$ is $\True$, \Proseoutputtoconsole{a newline character};
  \end{itemize}

  \item \AllApplyCase{println}
  \begin{itemize}
    \item $\vs$ denotes a Print statement with arguments $\elist$ and newline indicator $\True$;
    \item the evaluation of the same statement with a newline indicator set to $\False$, that is,
          $\SPrint(\elist, \False)$ yields the configuration $\Continuing(\vg, \envone)$\ProseOrAbnormal;
    \item \Proseoutputtoconsole{a newline character};
  \end{itemize}
  \item the resulting configuration is $\Continuing(\vg, \newenv)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[print]{
  \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \env_1) \OrAbnormal\\
  \vi\in\listrange(\vlist): \outputtoconsole(\env_\vi, \vlist[i]) \evalarrow \env_{\vi + 1} \\
  n \eqdef \listlen{\vlist}\\
  \newenv \eqdef \env_{n + 1}
}{
  \evalstmt{\env, \SPrint(\elist, \False)} \evalarrow \Continuing(\vg, \newenv)
}
\end{mathpar}

We define the newline character $\vnewline \triangleq \ascii{10}$.

\begin{mathpar}
\inferrule[println]{
  \evalstmt{\env, \SPrint(\elist, \False)} \evalarrow \Continuing(\vg, \envone) \OrAbnormal\\\\
  \outputtoconsole(\envone, \nvstring(\vnewline)) \evalarrow \newenv
}{
  \evalstmt{\env, \SPrint(\elist, \True)} \evalarrow \Continuing(\vg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSPrintBegin}{\EvalSPrintEnd}{../Interpreter.ml}

Not all ASL runtimes support printing to a console (see \RequirementRef{Printing}).
%
Therefore, the semantics is parameterized by the function
\hypertarget{def-outputtoconsole}{}
\[
\outputtoconsole(\overname{\envs}{\env} \aslsep \overname{\vals}{\vv}) \aslto
  \overname{\envs}{\newenv}
\]
which takes a string and communicates it to a console, where one exists.

We now explain how printing is modelled when the runtime supports a console
(\SemanticsRuleRef{SupportedOutputToConsole})
and how it is modelled when the runtime does not support a console
(\SemanticsRuleRef{UnsupportedOutputToConsole}).

\SemanticsRuleDef{SupportedOutputToConsole}
To support a console, the definition of environments needs
to include an extra component to capture the string of characters sent to the console:
\[
\envs \triangleq \staticenvs \times \dynamicenvs \times \Strings \enspace.
\]
We omit this component in the rest of this document to avoid clutter, and include it
only here to explain the modeling of a console.

\ExampleRef{Printing Literals} shows the output to the console in a case it is supported.

\hypertarget{def-literaltostring}{}
The helper function $\literaltostring : \literal \aslto \Strings$,
which defines how a literal is represented by a string,
is defined by \taref{literaltostringtable}.
%
Please note that surrounding quotations mark for $\lstring(S)$ are not included
in $\literaltostring(S)$, so they will appear in the printed string.

\begin{table}
\caption{How literals should be represented as strings\label{ta:literaltostringtable}}
\begin{tabular}{rl}
\textbf{literal $\vl$} & \textbf{$\literaltostring(\vl)$} \\
\hline
$\lint(n)$        & $n$ in decimal format, without any leading zeros, \\
                  & preceded by a ``\texttt{-}'' sign if $n$ is negative. \\
$\lbool(\True)$   & \texttt{TRUE} \\
$\lbool(\False)$  & \texttt{FALSE} \\
$\lreal(q)$       & $q$ as an irreducible fraction of positive integers, \\
                  & preceded by a ``\texttt{-}'' sign when $q$ is negative, \\
                  & with the denominator omitted if it is equal to 1. \\
$\lbitvector(b)$  & $b$ in hexadecimal, preceded by ``\texttt{0x}'', with enough leading \\
                  & zeros to make the number of hexadecimal digits printed \\
                  & equal to the width of $b$ divided by 4, and rounded up to \\
                  & the following integer.\\
$\lstring(S)$     & $S$. \\
$\llabel(s)$      & $s$. \\
\end{tabular}
\end{table}

\ProseParagraph
\AllApply
\begin{itemize}
  \item view $\env$ as the environment consisting of the static environment $\tenv$,
        dynamic environment $\denv$, and console string $\vconsolestream$;
  \item view $\vv$ as a native literal for the literal $\vl$;
  \item \Proseeqdef{$\newenv$}{the environment consisting of the static environment $\tenv$,
        dynamic environment $\denv$, and console string
        define as the concatenation of \\
        $\vconsolestream$ and $\literaltostring(\vl)$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqname (\tenv, \denv, \vconsolestream)\\
  \newenv \eqdef (\tenv, \denv, \vconsolestream \concat \literaltostring(\vl))
}{
  \outputtoconsole(\env, \nvliteral{\vl}) \evalarrow (\newenv)
}
\end{mathpar}

\SemanticsRuleDef{UnsupportedOutputToConsole}
The function ignores the string value and returns the environment unchanged.

In a runtime without support for a console, the \printstatementsterm{}
in \listingref{semantics-literals} evaluate their list of expressions
with no other effect.

\ProseParagraph
\ProseEqdef{$\newenv$}{$\env$}.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \outputtoconsole(\env, \Ignore) \evalarrow \overname{\env}{\newenv}
}
\end{mathpar}

\section{The Unreachable Statement\label{sec:UnreachableStatement}}
\hypertarget{def-unreachablestatementterm}{}
\listingref{UnreachableStatement} shows an example of using an \unreachablestatementterm{}
to implement a custom form of assertion checking.
\ASLListing{An example use of an \texttt{Unreachable} statement}{UnreachableStatement}{\definitiontests/UnreachableStatement.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tunreachable \parsesep \Tlpar \parsesep \Trpar \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SUnreachable &
\end{flalign*}

\ASTRuleDef{SUnreachable}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tunreachable, \Tlpar, \Trpar, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SUnreachable}{\vastnode}
}
\end{mathpar}

\TypingRuleDef{SUnreachable}
\ExampleDef{Typing an Unreachable Statement}
The \unreachablestatementterm{} in \listingref{UnreachableStatement} is well-typed.

\ProseParagraph
Annotating $\SUnreachable$ in the static environment $\tenv$ yields $(\SUnreachable, \tenv, \emptyset)$.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \annotatestmt(\tenv, \SUnreachable) \typearrow (\SUnreachable, \tenv, \overname{\emptyset}{\vses})
}
\end{mathpar}

\SemanticsRuleDef{SUnreachable}
\ExampleDef{Evaluating an Unreachable Statement}
Evaluating the specification in \listingref{UnreachableStatement} results in a \dynamicerrorterm,
since the \unreachablestatementterm{} is evaluated.

\ProseParagraph
Evaluating $\SUnreachable$ in an environment $\env$ results in a dynamic error indicating this ($\UnreachableError$).
\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \evalstmt{\env, \SUnreachable} \evalarrow \DynamicErrorVal{\UnreachableError}
}
\end{mathpar}

\section{Pragma Statements\label{sec:PragmaStatements}}
\hypertarget{def-pragmastatementterm}{}

\ASLListing{A pragma statement}{typing-spragma}{\typingtests/TypingRule.SPragma.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tpragma \parsesep \Tidentifier \parsesep \ClistZero{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SPragma(\Tidentifier, \overtext{\expr^*}{args}) &
\end{flalign*}

\ASTRuleDef{SPragma}
\begin{mathpar}
\inferrule{
  \buildclist[\Nexpr](\vargs) \astarrow \astversion{\vargs}
}{
  {
  \begin{array}{r}
    \buildstmt(\overname{\Nstmt(\Tpragma, \Tidentifier(\id), \namednode{\vargs}{\ClistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow \\
    \overname{\SPragma(\id, \astversion{\vargs})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{SPragma}
\ExampleDef{Typing a Pragma Statement}
The \pragmastatementterm{} in \listingref{typing-spragma} is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a pragma statement with identifier $\id$ and expression list $\vargs$. that is, $\SPragma(\id, \vargs)$;
  \item for each \Proselistrange{$i$}{$\vargs$}, \Proseannotateexpr{$\tenv$}{$\vargs[i]$}{$(\Ignore, \Ignore, \vxs_i)$}\ProseOrTypeError;
  \item define $\vses$ as the union of $\vxs_i$, for every \Proselistrange{$i$}{$\vargs$};
  \item define $\news$ as the \passstatementterm, that is, $\SPass$
  \item $\newtenv$ is $\tenv$;
  \item define $\vses$ as the union of $\vsess$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  i\in\listrange(\vargs): \annotateexpr{\tenv, \vargs[i]} \typearrow (\Ignore, \Ignore, \vxs_i) \OrTypeError\\\\
  \vses \eqdef \bigcup_{i\in\listrange(\vargs)} \vxs_i
}{
  \annotatestmt(\tenv, \overname{\SPragma(\id, \vargs)}{\vs}) \typearrow (\overname{\SPass}{\news}, \tenv)
}
\end{mathpar}
\CodeSubsection{\SPragmaBegin}{\SPragmaEnd}{../Typing.ml}

\subsection{Semantics\label{sec:PragmaSemantics}}
\ProseParagraph
Pragmas are structures present in the \untypedast{} that are designed to be used
by third-party tools.

To avoid conflicts between different ASL parsers, it is recommended that the pragma's identifier $\Tidentifier(\id)$ be prefixed by the name of the ASL tool that supports that pragma
(e.g. ARM for Arm's internal ASL tools). An ASL language processor that does not recognise a pragma directive should generate a warning for that pragma.

Pragmas are not associated with semantics and are discarded from the \typedast.
