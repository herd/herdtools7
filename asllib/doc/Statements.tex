\chapter{Statements\label{chap:Statements}}
Statements update storage elements and determine the flow of control in a subprogram.

\ExampleDef{Statements}
\listingref{Statements} shows some examples of statements.
\ASLListing{Examples of statements}{Statements}{\definitiontests/Statements.asl}

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Statements} defines the formal relations used for statements;
  \item \secref{PassStatements} defines pass statements;
  \item \secref{AssignmentStatements} defines assignment statements;
  \item \secref{SetterAssignmentStatements} defines setter assignment statements;
  \item \secref{DeclarationStatements} defines declaration statements;
  \item \secref{DeclarationStatementsElidedParameter} defines declaration statements with an elided parameter;
  \item \secref{SequencingStatement} defines sequencing statements;
  \item \secref{CallStatements} defines call statements;
  \item \secref{ConditionalStatements} defines conditional statements;
  \item \secref{CaseStatements} defines case statements;
  \item \secref{AssertionStatements} defines assertion statements;
  \item \secref{WhileStatements} defines while statements;
  \item \secref{RepeatStatements} defines repeat statements;
  \item \secref{ForStatements} defines for-looping statements;
  \item \secref{ThrowStatements} defines throw statements;
  \item \secref{TryStatements} defines try statements;
  \item \secref{ReturnStatements} defines return statements;
  \item \secref{PrintStatements} defines print statements;
  \item \secref{UnreachableStatement} defines unreachable statements;
  \item \secref{PragmaStatements} defines pragma statements.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Statements}
\paragraph{Syntax:} Statements are grammatically derived from $\Nstmt$.

\paragraph{Abstract Syntax:} Statements are derived in the abstract syntax from $\stmt$
and generated by $\buildstmt$.
\MarkedIgnoredRelationDefinition{
\hypertarget{build-stmt}{}
The function
\[
\buildstmt(\overname{\parsenode{\Nstmt}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a statement parse node $\vparsednode$ into a statement AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\paragraph{Typing:} Statements are annotated by $\annotatestmt$.
\RenderRelation{annotate_stmt}
\BackupOriginalRelation{
The function
\[
  \annotatestmt(\overname{\staticenvs}{\tenv} \aslsep \overname{\stmt}{\vs}) \aslto
  (\overname{\stmt}{\news} \times \overname{\staticenvs}{\newtenv} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\typeerror}{\TypeErrorConfig}
\]
annotates a statement $\vs$ in an environment $\tenv$, resulting in $\news$ ---
the \typedast\ for $\vs$, which is also known as the \emph{annotated statement} ---
a modified environment $\newtenv$, and \sideeffectsetterm\ $\vses$. \ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\paragraph{Semantics:} Statements are evaluated by $\evalstmt$.
\RenderRelation{eval_stmt}
\BackupOriginalRelation{
The relation
\[
  \evalstmt(\overname{\envs}{\env} \aslsep \overname{\stmt}{\vs}) \;\aslrel\;
  \left(
  \begin{array}{cl}
  \overname{\TReturning}{\Returning((\vvs,\newg), \newenv)} & \cup\\
  \overname{\TContinuing}{\Continuing(\newg,\newenv)} & \cup\\
  \overname{\TThrowing}{\ThrowingConfig} & \cup \\
  \overname{\TDynError}{\DynErrorConfig} & \cup \\
  \overname{\TDiverging}{\DivergingConfig} & \\
  \end{array}
  \right)
\]
evaluates a statement $\vs$ in an environment $\env$, resulting in one of four types of configurations
(see more details in \secref{KindsOfSemanticConfigurations}):
\begin{itemize}
  \item returning configurations with values $\vvs$, execution graph $\newg$, and a modified environment $\newenv$;
  \item continuing configurations with an execution graph $\newg$ and modified environment $\newenv$;
  \item throwing configurations;
  \item error configurations;
  \item diverging configurations.
\end{itemize}
} % END_OF_BACKUP_RELATION

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pass Statements\label{sec:PassStatements}}
\hypertarget{def-passstatementterm}{}

\ASLListing{A \texttt{pass} statement}{semantics-spass}{\semanticstests/SemanticsRule.SPass.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tpass \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_pass}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SPass &
\end{flalign*}
}

\ASTRuleDef{SPass}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tpass, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPass}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SPass}
\ExampleDef{Typing a Pass Statement}
Annotating the \passstatementterm{} in \listingref{semantics-spass} does
not modify the \staticenvironmentterm{}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a pass statement, that is, $\SPass$;
  \item $\news$ is $\vs$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}{\annotatestmt(\tenv, \SPass) \typearrow (\SPass, \tenv, \overname{\emptyset}{\vses})}
\end{mathpar}
\CodeSubsection{\SPassBegin}{\SPassEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SPass}
\ExampleDef{Evaluation of Pass Statements}
In \listingref{semantics-spass}, \texttt{pass;} does not modify the environment.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vs$ is a \passstatementterm, $\SPass$;
\item $\newg$ is the empty graph;
\item $\newenv$ is $\env$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \evalstmt(\env, \SPass) \evalarrow \Continuing(\overname{\emptygraph}{\newg}, \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalSPassBegin}{\EvalSPassEnd}{../Interpreter.ml}

\hypertarget{def-assignmentstatementterm}{}
\section{Assignment Statements\label{sec:AssignmentStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Nlexpr \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_assign}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SAssign(\lexpr, \expr) &
\end{flalign*}
}

\ASTRuleDef{SAssign}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\punnode{\Nlexpr}, \Teq, \punnode{\Nexpr}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SAssign(\astof{\vlexpr}, \astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SAssign}
\ExampleDef{Typing an Assignment Statement}
In \listingref{semantics-sassign}, the assignment \verb|x = 3;|
is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assignment \texttt{le = re}, that is, $\SAssign(\vle, \vre)$;
  \item annotating the \rhsexpression{} $\vre$ in $\tenv$ yields $(\vtre, \vreone, \vsesre)$\ProseOrTypeError;
  \item annotating the \assignableexpression\ $\vle$ with the type $\vtre$ in $\tenv$ yields \\ $(\vleone, \vsesle)$\ProseOrTypeError;
  \item $\news$ is the assignment \texttt{le1 = re1}, that is, $\SAssign(\vleone, \vreone)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesre$ and $\vsesle$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \vre) \typearrow (\vtre, \vreone, \vsesre) \OrTypeError\\\\
  \annotatelexpr(\tenv, \vle, \vtre) \typearrow (\vleone, \vsesle) \OrTypeError\\\\
  \vses \eqdef \vsesre \cup \vsesle
}{
  \annotatestmt(\tenv, \overname{\SAssign(\vle, \vre)}{\vs}) \typearrow
  (\overname{\SAssign(\vleone, \vreone)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SAssignBegin}{\SAssignEnd}{../Typing.ml}

\subsection{Semantics}
There are two rules for evaluating assignments:
\begin{itemize}
\item \SemanticsRuleRef{SAssignCall} handles assignments where the \rhsexpression{}
      is a \callexpressionterm{} and the left-hand-side expression is a tuple.
\item \SemanticsRuleRef{SAssign} handles all other assignments.
\end{itemize}

Although the sequential semantics of both types of statements is the same,
\SemanticsRuleRef{SAssignCall} generates a different execution graph ---
one where each value of the left-hand-side tuple depends on the \executiongraphterm{}
for the corresponding (that is, at the same position) value returned from the \callexpressionterm{}.
In contrast, the \executiongraphterm{} generated by \SemanticsRuleRef{SAssign}
creates dependencies between the entire \executiongraphterm{} for the evaluated right-hand-side
expression and the entire \executiongraphterm{} for the left-hand-side \executiongraphterm{}.

The rules for assignments first produce a value for the right-hand side expression
and then complete the update to the environment via an appropriate rule for evaluating the
\assignableexpression{} on the left-hand-side of the assignment,
which in turn handles variables, tuples, bitvectors, etc.

\SemanticsRuleDef{SAssignCall}
\ExampleDef{Evaluation of Multi-variable Assignment from Subprogram Calls}
In \listingref{assigncallsemantics}, given that the function call \texttt{f(1)} returns a triple of values ---
$\nvint(1)$, $\nvint(2)$, and $\nvint(3)$
(each with its own associated execution graph),
the statement \texttt{(a,b,-) = f(1)} assigns the value $\nvint(1)$ to the mutable variable \texttt{a},
$\nvint(2)$ to the mutable variable~\texttt{b}, and discards $\nvint(3)$.

\ASLListing{Assignment from a call expression.}{assigncallsemantics}{\semanticstests/SemanticsRule.SAssignCall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ assigns an \assignableexpression\ list from a subprogram call, \\
        $\SAssign(\LEDestructuring(\les),\ECall(\vcall))$;
  \item $\les$ is a list of \assignableexpressions, each of which is either \\ a variable ($\LEVar(\Ignore)$)
        or a discarded variable ($\LEDiscard$);
  \item evaluating the subprogram call as per \chapref{SubprogramCalls} is
        $\ResultCall(\vms, \envone)$\ProseOrAbnormal;
  \item assigning each value in $\vms$ to the respective element of the tuple $\les$ is \\
        $\ResultLexpr(\vgtwo, \newg)$\ProseOrAbnormal.
\end{itemize}

\FormallyParagraph
\hypertarget{def-lexprisvar}{}
The rule uses the syntactic predicate defined as follows:
\[
  \lexprisvar(\lexpr) \aslto \True
\]
which holds when a left-hand side expression
represents a variable or a discarded left-hand-side expression:
\begin{mathpar}
\inferrule{}{ \lexprisvar(\vle) \evalarrow \astlabel(\vle) \in \{\LEVar, \LEDiscard\}}
\end{mathpar}

The inference rules defining the evaluation of assigning
from a subprogram call are as follows:
\begin{mathpar}
\inferrule{
  \vles \eqdef \vle_{1..k}\\
  i=1..k: \lexprisvar(\vle_i) \evalarrow \True\\
  \evalcall(\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs) \evalarrow \ResultCall(\vms, \envone) \OrAbnormal\\\\
  \evalmultiassignment(\envone, \vles, \vms) \evalarrow \ResultLexpr(\newg, \newenv) \OrAbnormal
}{
  \evalstmt(\env, \SAssign(\LEDestructuring(\les),\ECall(\vcall))) \\
  \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSAssignCallBegin}{\EvalSAssignCallEnd}{../Interpreter.ml}

\SemanticsRuleDef{SAssign}
\ExampleDef{Evaluation of Assignment Statements}
In \listingref{semantics-sassign},
\texttt{x = 3;} binds \texttt{x} to $\nvint(3)$ in the environment where \texttt{x} is bound to
$\nvint(42)$, and $\newenv$ is such that \texttt{x} is bound to $\nvint(3)$.
\ASLListing{Evaluating an assignment}{semantics-sassign}{\semanticstests/SemanticsRule.SAssign.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assignment statement, $\SAssign(\vle, \vre)$;
  \item \OneApplies
  \begin{itemize}
    \item $\vre$ is not a call expression;
    \item $\vle$ is not a multi-var expression (that is, not a $\LEDestructuring$);
    \item $\vle$ is a multi-var expression, but one of its components is neither a variable
          nor a discarded variable.
  \end{itemize}
  \item evaluating the expression $\vre$ in $\env$ yields
        $\ResultExpr(\vm, \envone)$ (here, $\vm$ is a pair consisting of a value and an execution graph)\ProseOrAbnormal;
  \item evaluating the \assignableexpression\ $\vle$ with $\vm$ in $\envone$,
        as per \chapref{AssignableExpressions}, yields $\ResultLexpr(\newg, \newenv)$\ProseOrAbnormal.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {\left(
  \begin{array}{c}
  \astlabel(\vle) \neq \LEDestructuring\ \lor \\
  \astlabel(\vre) \neq \ECall\ \lor\\
  \vle = \LEDestructuring(\les) \land \exists \vi\in\listrange(\vle).\ \neg\lexprisvar(\vle[\vi])
  \end{array}
  \right)
  }\\
  \evalexpr(\env, \vre) \evalarrow \ResultExpr(\vm, \envone) \OrAbnormal\\
  \evallexpr(\envone, \vle, \vm) \evalarrow \ResultLexpr(\newg, \newenv) \OrAbnormal
}{
  \evalstmt(\env, \SAssign(\vle, \vre)) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSAssignBegin}{\EvalSAssignEnd}{../Interpreter.ml}

\section{Setter Assignment Statements\label{sec:SetterAssignmentStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \
   & \Ncall \parsesep \Nsetteraccess \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Ncall \parsesep \Nsetteraccess \parsesep \Nslices \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Ncall \parsesep \Tdot \parsesep \Tlbracket \parsesep \Clisttwo{{\Tidentifier}} \parsesep \Trbracket \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
\Nsetteraccess \derives \
   & \emptysentence &\\
|\ & \Tdot \parsesep \Tidentifier \parsesep \Nsetteraccess &
\end{flalign*}

\SyntacticSugarDef{Setter Calls Followed by a Slice or a Field Access}
A call to a setter, followed by a slice or a field access is \syntacticsugar{}
for a sequence of statements, which first call the corresponding getter,
apply the corresponding slice of field, and then call the setter with the new value.
See \ExampleRef{A Setter Call as a Read-Modify-Write}.
Setter calls are desugared by \ASTRuleRef{DesugarSetter}.

\ASTRuleDef{MakeSetter}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-makesetter}{}
The function
\[
\makesetter(
  \overname{\call}{\vcall} \aslsep
  \overname{\expr}{\varg}) \aslto \overname{\call}{\vcallp}
\]
constructs a setter call $\vcallp$ using a base call $\vcall$ and right-hand side $\varg$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{}{
  \makesetter(\vcall, \varg) \aslto
    \overname{\left\{
      \begin{array}{rcl}
        \callname &:& \vcall.\callname,\\
        \callparams &:& \vcall.\callparams,\\
        \callargs &:& [\varg]\concat\vcall.\callargs,\\
        \callcalltype &:& \STSetter
      \end{array}
    \right\}}{\vcallp}
}
\end{mathpar}

\ASTRuleDef{DesugarSetter}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-desugarsetter}{}
The function
\[
\desugarsetter(
  \overname{\call}{\vcall} \aslsep
  \overname{\lhsaccess}{\vlhsaccess} \aslsep
  \overname{\expr}{\rhs}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from an assignment of expression $\rhs$ to a setter invocation $\vcall.\callname$ with accesses given by $\vlhsaccess$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[empty]{
  \vlhsaccess.\lhsaccessaccess = \emptylist \\
  \vlhsaccess.\lhsaccessslices = \emptylist \\\\
  \makesetter(\vcall, \rhs) \aslto \vcallp
}{
  \desugarsetter(\vcall, \vlhsaccess, \rhs)
  \astarrow
  \SCall(\vcallp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vlhsaccess.\lhsaccessaccess \neq \emptylist \lor
  \vlhsaccess.\lhsaccessslices \neq \emptylist \\\\
  \vx \in \Identifier \text{ is fresh} \\\\
  \desugarlhsaccess(\vx, \vlhsaccess) \astarrow \lhs \\
  \vmodify \eqdef \SAssign(\lhs, \rhs) \\
  \readmodifywrite(\vcall, \vx, \vmodify) \astarrow \vcallp
}{
  \desugarsetter(\vcall, \vlhsaccess, \rhs)
  \astarrow
  \vcallp
}
\end{mathpar}

\ASTRuleDef{DesugarSetterSetfields}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-desugarsettersetfields}{}
The function
\[
\desugarsettersetfields(
  \overname{\call}{\vcall} \aslsep
  \overname{\KleeneStar{\Identifier}}{\vfields} \aslsep
  \overname{\expr}{\rhs}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from an assignment of $\rhs$ to a setter invocation $\vcall.\callname$ with concatenated field accesses given by $\vfields$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \vx \in \Identifier \text{ is fresh} \\\\
  \lhs \eqdef \LESetFields(\LEVar(\vx), \vfields) \\
  \vmodify \eqdef \SAssign(\lhs, \rhs) \\
  \readmodifywrite(\vcall, \vx, \vmodify) \astarrow \vcallp
}{
  \desugarsettersetfields(\vcall, \fields, \rhs)
  \astarrow
  \vcallp
}
\end{mathpar}

\ASTRuleDef{ReadModifyWrite}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-readmodifywrite}{}
The function
\[
\readmodifywrite(
  \overname{\call}{\vcall} \aslsep
  \overname{\Identifier}{\vx} \aslsep
  \overname{\stmt}{\vmodify}) \aslto \overname{\stmt}{\news}
\]
builds a sequence of statements to read from the getter invocation $\vcall.\callname$, modify the resulting value using $\vmodify$, and write it to a setter invocation $\vcall.\callname$.
} % END_OF_IGNORED_RELATION


\ExampleDef{A Setter Call as a Read-Modify-Write}
\listingref{ReadModifyWriteSlice} shows how a setter call followed by a slice is
\desugared.
\ASLListing{A Setter followed by a Slice}{ReadModifyWriteSlice}{\syntaxtests/ASTRule.ReadModifyWriteSlice.asl}

\listingref{ReadModifyWriteSlice} shows how a setter call followed by a field access is
\desugared.
\ASLListing{A Setter followed by a Field Access}{ReadModifyWriteField}{\syntaxtests/ASTRule.ReadModifyWriteField.asl}

\begin{mathpar}
\inferrule{
  \setcalltype(\vcall, \STGetter) \aslto \vgetter \\\\
  \vread \eqdef \SDecl(\LDKVar, \LDIVar(\vx), \None, \some{\ECall(\vgetter)}) \\\\
  \makesetter(\vcall, \EVar(\vx)) \aslto \vsetter
}{
  \readmodifywrite(\vcall, \vx, \vmodify)
  \astarrow
  \overname{\SSeq (\SSeq(\vread, \vmodify), \SCall(\vsetter))}{\news}
}
\end{mathpar}

\ASTRuleDef{SetterAssign}
\begin{mathpar}
\inferrule[no\_slices]{
  \buildaccess(\vsetteraccess) \astarrow \vaccess \\\\
  {
  \vlhsaccess \eqdef
    \left\{
      \begin{array}{rcl}
        \lhsaccessaccess &:& \vaccess,\\
        \lhsaccessslices &:& \emptylist
      \end{array}
    \right\}
  } \\
  \desugarsetter(\astof{\vcall}, \vlhsaccess, \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\Ncall}, \namednode{\vsetteraccess}{\Nsetteraccess}, \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule[slices]{
  \buildaccess(\vsetteraccess) \astarrow \vaccess \\\\
  {
  \vlhsaccess \eqdef
    \left\{
      \begin{array}{rcl}
        \lhsaccessaccess &:& \vaccess,\\
        \lhsaccessslices &:& \astof{\vslices}
      \end{array}
    \right\}
  } \\
  \desugarsetter(\astof{\vcall}, \vlhsaccess, \astof{\vexpr}) \astarrow \vastnode
}{
  {
    \begin{array}{r}
      \buildstmt(\overname{\Nstmt(\punnode{\Ncall}, \namednode{\vsetteraccess}{\Nsetteraccess}, \punnode{\Nslices}, \Teq, \punnode{\Nexpr}, \Tsemicolon
      )}{\vparsednode})
      \astarrow \\ \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[setfields]{
  \buildclist[\buildidentity](\vfields) \astarrow \vfieldasts \\
  \desugarsettersetfields(\astof{\vcall}, \vfieldasts, \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\Ncall}, \Tdot,
    \Tlbracket, \namednode{\vfields}{\Clisttwo{\Tidentifier}}, \Trbracket, \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\subsection{Typing and semantics}
As given by applying the relevant rules to the desugared AST.

\hypertarget{def-declarationstatementterm}{}
\section{Declaration Statements\label{sec:DeclarationStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \option{\Nasty} \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Ndeclitem \parsesep \Nasty \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Clisttwo{\Tidentifier} \parsesep \Nasty \parsesep \Tsemicolon &\\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_decl}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SDecl(\localdeclkeyword, \localdeclitem, \ty?, \expr?)
\end{flalign*}
}

\ASTRuleDef{SDecl}
\begin{mathpar}
\inferrule[let\_constant]{
  \buildoption[\buildasty](\vt) \astarrow \astversion{\vt}
}{
  {
  \begin{array}{r}
  \buildstmt(\overname{\Nstmt(\Nlocaldeclkeyword, \Ndeclitem, \namednode{\vt}{\option{\Nasty}}, \Teq, \punnode{\Nexpr}, \Tsemicolon)}{\vparsednode})
  \astarrow\\
  \overname{\SDecl(\astof{\vlocaldeclkeyword}, \astof{\vdeclitem}, \astversion{\vt}, \some{\astof{\vexpr}})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[uninit\_var]{}{
  {
  \begin{array}{r}
    \buildstmt(\overname{\Nstmt(\Tvar, \Ndeclitem, \punnode{\Nasty}, \Tsemicolon)}{\vparsednode})
    \astarrow \\
    \overname{\SDecl(\LDKVar, \astof{\vdeclitem}, \astof{\vasty}, \None)}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[multi\_var]{
  \buildclist[\buildidentity](\vids) \astarrow \astversion{\vids}\\
  \buildasty(\vt) \astarrow \astversion{\vt} \\
  \vstmts \eqdef [\vx\in\astversion{\vids}: \SDecl(\LDKVar, \vx, \astversion{\vt}, \None)]\\
  \stmtfromlist(\vstmts) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\Tvar, \namednode{\vids}{\Clisttwo{\Tidentifier}}, \namednode{\vt}{\Nasty}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \vastnode
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SDecl}
\ExampleDef{Typing Declaration Statements}
\listingref{typing-sdecl} shows well-typed declaration statements.
\ASLListing{Typing declaration statements}{typing-sdecl}{\typingtests/TypingRule.SDecl.asl}

The specifications in \listingref{typing-sdecl-bad1} ill-typed,
since local constant storage elements are not allowed.
\ASLListing{A (illegal) local constant declaration}{typing-sdecl-bad1}{\typingtests/TypingRule.SDecl.bad1.asl}

The specification in \listingref{typing-sdecl-bad2} is ill-typed,
since immutable local storage elements require an initializing expression.
\ASLListing{An uninitialized immutable local storage declaration}{typing-sdecl-bad2}{\typingtests/TypingRule.SDecl.bad2.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a declaration with an initializing expression $\ve$,
          that is, \\
          $\SDecl(\ldk, \ldi, \tyopt, \some{\ve})$;
    \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields $(\vte,\vep, \vsese)$\ProseOrTypeError;
    \item applying $\annotatelocaldecltypeannot$ to the environment $\tenv$, type annotation $\tyopt$, type $\vte$, local declaration keyword $\ldk$, expression $\vep$, and local declaration item $\ldi$ yields $(\tenvone, \tyoptp, \vsesldi)$\ProseOrTypeError;
    \item \Proseeqdef{$\vses$}{the union of $\vsese$ and $\vsesldi$};
    \item $\news$ is a declaration with $\ldk$, $\ldi$, type annotation $\tyoptp$, and an expression $\vep$;
    \item $\newtenv$ is $\tenvone$.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
  \item $\vs$ is a local declaration statement with a variable keyword and no initializing expression,
        that is, $\SDecl(\LDKVar, \ldi, \tyopt, \None)$ (local declarations of \texttt{let} variables require
        an initializing expression, otherwise they are rejected by an ASL parser);
  \item checking that $\tyopt$ is not $\None$, that is, the declaration has a type annotation, yields $\True$\ProseOrTypeError;
  \item $\tyopt$ is $\some{\vt}$;
  \item annotating $\vt$ in $\tenv$ yields $(\vtp, \vses)$\ProseOrTypeError;
  \item applying $\basevalue$ to $\vtp$ in $\tenv$ yields $\veinit$\ProseOrTypeError;
  \item annotating the local declaration item $\ldi$ with the type $\vtp$ and local declaration keyword $\LDIVar$
        yields $\newtenv$\ProseOrTypeError;
  \item define $\news$ as local declaration statement with variable keyword, local declaration item $\ldi$, type annotation $\vtp$, and initializing expression $\veinit$, that is, $\SDecl(\LDKVar, \ldi, \some{\veinit})$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[some]{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vsese) \OrTypeError\\\\
  {
  \begin{array}{r}
  \annotatelocaldecltypeannot(\tenv, \tyopt, \vte, \ldk, \vep, \ldi) \typearrow \\
  (\tenvone, \tyoptp, \vsesldi) \OrTypeError
  \end{array}
  }\\
  \vses \eqdef \vsese \cup \vsesldi\\
  \news \eqdef \SDecl(\ldk, \ldi, \tyoptp, \some{\vep})
}{
  \annotatestmt(\tenv, \overname{\SDecl(\ldk, \ldi, \tyopt, \some{\ve})}{\vs}) \typearrow (\news, \overname{\tenvone}{\newtenv}, \vses)
}
\end{mathpar}
\identr{YSPM}

\begin{mathpar}
\inferrule[none]{
  \checktrans{\tyopt \neq \None}{\TypeErrorVal{\BadDeclaration}} \typearrow \True \OrTypeError \\
  \tyopt \eqname \some{\vt} \\
  \annotatetype(\tenv, \vt) \typearrow (\vtp, \vses) \OrTypeError\\\\
  \basevalue(\tenv, \vtp) \typearrow \veinit \OrTypeError\\\\
  \annotatelocaldeclitem(\tenv, \vtp, \LDKVar, \None, \ldip) \typearrow \newtenv \OrTypeError \\
  \news \eqdef \SDecl(\LDKVar, \ldi, \some{\vtp}, \some{\veinit})
}{
  \annotatestmt(\tenv, \overname{\SDecl(\LDKVar, \ldi, \tyopt, \None)}{\vs}) \typearrow (\news, \newtenv, \vses)
}
\end{mathpar}
\CodeSubsection{\SDeclegin}{\SDeclEnd}{../Typing.ml}

\TypingRuleDef{AnnotateLocalDeclTypeAnnot}
\RenderRelation{annotate_local_decl_type_annot}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
  \annotatelocaldecltypeannot
  \left(
  \begin{array}{c}
    \overname{\staticenvs}{\tenv} \aslsep \\
    \overname{\Option(\ty)}{\tyopt} \aslsep \\
    \overname{\ty}{\vte} \aslsep \\
    \overname{\localdeclkeyword}{\ldk} \aslsep \\
    \overname{\expr}{\vep} \aslsep\\
    \overname{\localdeclitem}{\ldi}
  \end{array}
  \right)
  \aslto \\
  \begin{array}{cl}
    \left(\overname{\staticenvs}{\newtenv} \aslsep \overname{\Option(\ty)}{\tyoptp} \aslsep \overname{\TSideEffectSet}{\vses}\right)
    & \cup \\
    \overname{\typeerror}{\TypeErrorConfig} &
  \end{array}
\end{array}
\]
annotates the type annotation $\tyopt$ in the \staticenvironmentterm{} $\tenv$ within the context of a local declaration with keyword $\ldk$, item $\ldi$, and initializing expression $\vep$ with type $\vte$.
It yields the modified \staticenvironmentterm{} $\newtenv$, the annotated type annotation $\tyoptp$, and the inferred \sideeffectsetterm{} $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

See \ExampleRef{Typing Declaration Statements}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\tyopt$ is $\None$;
    \item \Prosenoprecisionloss{\vte};
    \item $\newtenv$ is the result of $\annotatelocaldeclitem(\tenv, \vte, \ldk, \some{\vep}, \ldi)$\ProseOrTypeError;
    \item $\tyoptp$ is $\tyopt$;
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\tyopt$ is $\some{\vt}$;
    \item determining the \structureterm{} of $\vte$ in $\tenv$ yields $\vtep$\ProseOrTypeError;
    \item propagating integer constraints from $\vtep$ to $\vt$ using $\inheritintegerconstraints$ yields $\vtp$\ProseOrTypeError;
    \item annotating the type $\vtp$ in $\tenv$ yields $(\vtpp, \vses)$\ProseOrTypeError;
  \item determining whether $\vtpp$ can be initialized with $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the local declaration item $\ldi$ with the local declaration keyword $\ldk$, given
  the expression $\vep$, in the environment $\tenv$, yields $\newtenv$;
  \item $\tyoptp$ is $\some{\vtpp}$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{
  \annotatelocaldeclitem(\tenv, \vte, \ldk, \some{\vep}, \ldi) \typearrow \newtenv \OrTypeError
}{
  \annotatelocaldecltypeannot(\tenv, \None, \vte, \ldk, \vep, \ldi) \typearrow (\newtenv, \overname{\None}{\tyoptp}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \tstruct(\tenv, \vte) \typearrow \vtep \OrTypeError \\
  \inheritintegerconstraints(\vt, \vtep) \typearrow \vtp \OrTypeError \\
  \annotatetype(\tenv, \vtp) \typearrow (\vtpp, \vses) \OrTypeError\\\\
  \checkcanbeinitializedwith(\tenv, \vtpp, \vte) \typearrow \True \OrTypeError\\\\
  \annotatelocaldeclitem(\tenv, \vtpp, \ldk, \some{ \vep }, \ldip) \typearrow \newtenv \OrTypeError
}{
  \annotatelocaldecltypeannot(\tenv, \some{\vt}, \vte, \ldk, \vep, \ldi) \typearrow (\newtenv, \overname{\some{\vtpp}}{\tyoptp}, \vses)
}
\end{mathpar}

\TypingRuleDef{InheritIntegerConstraints}
\RenderRelation{inherit_integer_constraints}
\BackupOriginalRelation{
The function
\[
\inheritintegerconstraints(\overname{\ty}{\lhs} \aslsep \overname{\ty}{\rhs})
\aslto \overname{\ty}{\lhsp} \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
propagates integer constraints from the right-hand side type $\rhs$ to the left-hand side type annotation $\lhs$.
In particular, each occurrence of \pendingconstrainedintegertypeterm{} on the left-hand side should inherit constraints from a corresponding \wellconstrainedintegertypeterm{} on the right-hand side.
If the corresponding right-hand side type is not a \wellconstrainedintegertypeterm{} (including if it is an \unconstrainedintegertypeterm{}), the result is a \typingerrorterm{}.
} % END_OF_BACKUP_RELATION

\listingref{typing-pendingconstrained} shows examples of pending-constrained
integer types.

\ExampleDef{Pending-constrained integer type vs. unconstrained integer type}
\listingref{pending-constrained-unconstrained} corresponds to the \typingerrorterm{}
in the \CaseName{int} below.
\ASLListing{An ill-typed pending-constrained integer type}{pending-constrained-unconstrained}
{\typingtests/TypingRule.InheritIntegerConstraints.unconstrained.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{int}
  \begin{itemize}
    \item $\lhs$ is a \pendingconstrainedintegertypeterm{};
    \item \Prosenoprecisionloss{$\rhs$};
    \item checking that $\rhs$ is a \wellconstrainedintegertypeterm{} yields $\True$\ProseOrTypeError;
    \item \Proseeqdef{$\lhsp$}{$\rhs$}.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\lhs$ is a tuple of types $\vlhstys$;
    \item $\rhs$ is a tuple of types $\vrhstys$;
    \item checking that the lengths of $\vlhstys$ and $\vrhstys$ are equal yields $\True$\ProseOrTypeError;
    \item define $\vlhstysp$ by applying $\inheritintegerconstraints$ to each element of \\
         $ \vlhstys$ and $\vrhstys$\ProseOrTypeError;
    \item \Proseeqdef{$\lhsp$}{$\TTuple(\vlhstysp)$}.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\lhs$ is not a \pendingconstrainedintegertypeterm{}, or one of $\lhs$ and $\rhs$ is not a \tupletypeterm{};
    \item \Proseeqdef{$\lhsp$}{$\lhs$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[int]{
  \checknoprecisionloss(\rhs) \typearrow \True \OrTypeError\\\\
  \checktrans{\iswellconstrainedinteger(\rhs)}{\UnexpectedType} \checktransarrow \True\OrTypeError
}{
  \inheritintegerconstraints(\overname{\TInt(\PendingConstrained)}{\lhs}, \rhs) \typearrow \overname{\rhs}{\lhsp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \lhs = \TTuple(\vlhstys) \\
  \rhs = \TTuple(\vrhstys) \\\\
  \checktrans{\equallength(\vlhstys, \vrhstys)}{\UnexpectedType} \typearrow \True \OrTypeError \\\\
  {
  \begin{array}{r}
  \vi \in \listrange(\lhs): \inheritintegerconstraints(\vlhstys_\vi, \vrhstys_\vi) \typearrow \\
  \vlhstysp_\vi \OrTypeError
  \end{array}
  }
}{
  \inheritintegerconstraints(\lhs, \rhs) \typearrow \overname{\TTuple(\vlhstysp)}{\lhsp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \lhs \neq \TInt(\PendingConstrained) \lor \astlabel(\lhs) \neq \TTuple \lor \astlabel(\rhs) \neq \TTuple
}{
  \inheritintegerconstraints(\lhs, \rhs) \typearrow \overname{\lhs}{\lhsp}
}
\end{mathpar}

\TypingRuleDef{CheckNoPrecisionLoss}
\RenderRelation{check_no_precision_loss}
\BackupOriginalRelation{
The function
\[
  \checknoprecisionloss(\overname{\ty}{\vt})
  \typearrow \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether the type $\vt$ is the result of a precision loss in its
constraint computation (see for example \TypingRuleRef{ApplyBinopTypes}).
} % END_OF_BACKUP_RELATION

\ExampleDef{Rejected Declaration Because of Precision Loss}
In \listingref{typing-imprecisetype}, the statement \verb|var b = a * a;|
corresponds to the \typingerrorterm{} raised in the \CaseName{Well-Constrained}
below.
The type of the right-hand-side (\texttt{a * a}) is imprecise because the multiplication of two
constant types would result in more than $2^17$ elements, see
\TypingRuleRef{ApplyBinopTypes}.
\ASLListing{Type-checking a declaration with an imprecise type}{typing-imprecisetype}{\typingtests/TypingRule.CheckNoPrecisionLoss.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{Well-Constrained}
    \begin{itemize}
      \item $\vt$ is a \wellconstrainedintegertypeterm{} with a precision $\PrecisionFull$ or $\vt$ is a \wellconstrainedintegertypeterm{} with a precision $\PrecisionLost$
      \item a \typingerrorterm{} is raised;
    \end{itemize}
  \item \AllApplyCase{Integer}
    \begin{itemize}
      \item $\vt$ is not a \wellconstrainedintegertypeterm{};
      \item no \typingerrorterm{} is raised.
    \end{itemize}
  \item \AllApplyCase{Other}
    \begin{itemize}
      \item $\vt$ is not an \integertypeterm{};
      \item no \typingerrorterm{} is raised.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[Well-Constrained]{%
    \checktrans{p = \PrecisionFull}{PrecisionLostDefining}
  }{%
    \checknoprecisionloss(\overname{\TInt(\WellConstrained(\Ignore, p))}{\vt}) \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Integer]{%
    \astlabel(\vc) \neq \WellConstrained
  }{%
    \checknoprecisionloss(\overname{\TInt(\vc)}{\vt}) \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Other]{%
    \astlabel(\vt) \neq \TInt
  }{%
    \checknoprecisionloss(\vt) \typearrow \True
  }
\end{mathpar}

\CodeSubsection{\CheckNoPrecisionLossBegin}{\CheckNoPreciisonLossEnd}{../Typing.ml}

\TypingRuleDef{CheckCanBeInitializedWith}
\RenderRelation{check_can_be_initialized_with}
\BackupOriginalRelation{
The function
\[
\checkcanbeinitializedwith(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vs} \aslsep \overname{\ty}{\vt})
\typearrow \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether an expression of type $\vs$ can be used to initialize a storage element of type $\vt$ in the \staticenvironmentterm{}
$\tenv$.
If the answer if $\False$, the result is a \typingerrorterm.
} % END_OF_BACKUP_RELATION

See \ExampleRef{Type-satisfaction Examples}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item testing whether $\vt$ \typesatisfiesterm\ $\vs$ in $\tenv$ yields $\True$;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item testing whether $\vt$ \typesatisfiesterm\ $\vs$ in $\tenv$ yields $\False$;
    \item the result is a \typingerrorterm{} indicating that an expression of type $\vs$ cannot
          be used to initialize a storage element of type $\vt$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}{
  \checkcanbeinitializedwith(\tenv, \vs, \vt) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \typesat(\tenv, \vt, \vs) \typearrow \False
}{
  \checkcanbeinitializedwith(\tenv, \vs, \vt) \typearrow \TypeErrorVal{\TypeSatisfactionFailure}
}
\end{mathpar}
\identr{ZCVD}  \identr{LXQZ}


\subsection{Semantics}
\SemanticsRuleDef{SDeclSome}
\ExampleDef{Declaration With an Initializing Value}
In \listingref{semantics-sdeclsome},
\texttt{let x = 3;} binds \texttt{x} to $\nvint(3)$ in the empty environment.
\ASLListing{Evaluating a declaration with a given initial value}{semantics-sdeclsome}{\semanticstests/SemanticsRule.SDeclSome.asl}

\ExampleDef{Declaration Without an Initializing Value}
In \listingref{semantics-sdeclnone},
\texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.
\ASLListing{Evaluating a declaration without a given initial value}{semantics-sdeclnone}{\semanticstests/SemanticsRule.SDeclNone.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a declaration with an initial value,
          $\SDecl(\Ignore, \ldi, \Ignore, \some{\ve})$;
    \item evaluating $\ve$ in $\env$ is $\ResultExpr(\vm, \envone)$\ProseOrAbnormal;
    \item evaluating the local declaration $\ldi$ with $\vm$ as the initializing
          value in $\envone$ as per \chapref{LocalStorageDeclarations} is
          $\ResultLexpr(\newg, \newenv)$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a declaration without an initial value, $\SDecl(\Ignore, \ldi, \Ignore, \None)$;
    \item the result is a \DynamicErrorConfigurationTerm{}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[some]{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr(\vm, \envone) \OrAbnormal\\
  \evallocaldecl(\envone, \ldi, \vm) \evalarrow \ResultLexpr(\newg, \newenv)\\
}{
  \evalstmt(\env, \SDecl(\Ignore, \ldi, \Ignore, \some{\ve})) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[none]{}{
  \evalstmt(\env, \SDecl(\Ignore, \ldi, \Ignore, \None)) \evalarrow \DynamicErrorVal{UninitialisedDecl}
}
\end{mathpar}
\CodeSubsection{\EvalSDeclBegin}{\EvalSDeclEnd}{../Interpreter.ml}

\section{Declaration Statements with an Elided Parameter\label{sec:DeclarationStatementsElidedParameter}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \
   & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \Nasty \parsesep \Teq \\
   & \wrappedline\ \Nelidedparamcall \parsesep \Tsemicolon &\\
\end{flalign*}

\begin{flalign*}
\Nelidedparamcall \derives \
     & \Tidentifier \parsesep \Tlbrace \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Trbrace \parsesep \PlistZero{\Nexpr} &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Tcomma \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Tcomma \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace \parsesep \PlistZero{\Nexpr}&
\end{flalign*}

\SyntacticSugarDef{ParameterElision}
In a call to a parameterized subprogram, a parameter can be elided,
if it can be inferred from the left-hand-side type annotation,
as detailed by \ASTRuleRef{ElidedParamCall} (See also \secref{ParameterElision}).

\ASTRuleDef{ElidedParamCall}
\hypertarget{build-elided-param-call}{}
The function $\buildelidedparamcall$ builds a $\call$ from a parsed \\
$\Nelidedparamcall$.

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlpar, \Trpar))
  \astarrow \vastnode
}{
  \buildelidedparamcall(\Nelidedparamcall (\Tidentifier(\id), \Tlbrace, \Trbrace))
  \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \vargs))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
      \buildelidedparamcall(\Nelidedparamcall \\
        \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}}))
      \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlbrace, \vparams, \Trbrace))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
      \buildelidedparamcall(\Nelidedparamcall \\
        \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Tcomma, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace))
        \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlbrace, \vparams, \Trbrace, \vargs))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
    \buildelidedparamcall (\Nelidedparamcall \\
      \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Tcomma, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}}))
      \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarElidedParameter}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-desugarelidedparameter}{}
The function
\[
\desugarelidedparameter(
  \overname{\ty}{\vt} \aslsep
  \overname{\call}{\vcall})
\aslto
\overname{\Option(\expr)}{\vexpr}
\cup\ \overname{\TBuildError}{\ParseErrorConfig}
\]
builds an expression $\vexpr$ from an assignment of the call $\vcall$ to the left-hand side with type annotation $\vt$, where the call has an elided parameter.
Otherwise, the result is a parse error.
} % END_OF_IGNORED_RELATION


\ExampleDef{Desugaring Parameter Elision Based on Declared Type Annotation}
\listingref{DesugarElidedParameter} shows examples of how parameters can be elided
if they can be copied from the type annotation in declaration statements.
\ASLListing{Desugaring parameter elision based on declared type annotation}{DesugarElidedParameter}{\syntaxtests/ASTRule.DesugarElidedParameter.asl}

\begin{mathpar}
\inferrule{
  \checktrans{\vt = \TBits(\Ignore, \Ignore)}{\ParseErrorConfig} \typearrow \True \;\terminateas \ParseErrorConfig \\
  \vt \eqname \TBits(\ve, \Ignore) \\
  \vcallp \eqdef \vcall[\callparams\mapsto [\ve] \concat \vcall.\callparams ]
}{
  \desugarelidedparameter(\ldk, \ldi, \vt, \vcall)
  \astarrow
  \some{\ECall(\vcallp)}
}
\end{mathpar}

\ASTRuleDef{ElidedParamDecl}
\begin{mathpar}
\inferrule{
  \buildelidedparamcall (\vcall) \astarrow \astversion{\vcall} \\
  \desugarelidedparameter(\astof{\vasty}, \astversion{\vcall}) \astarrow \vexpr
}{
  {
    \begin{array}{r}
    \buildstmt\left(
      \Nstmt\left(
        \begin{array}{l}
          \punnode{\Nlocaldeclkeyword}, \\
          \wrappedline\ \punnode{\Ndeclitem}, \punnode{\Nasty}, \Teq, \\
          \wrappedline\ \namednode{\vcall}{\Nelidedparamcall}, \Tsemicolon
        \end{array}
      \right)
    \right) \astarrow \\ \overname{\SDecl(\astof{\vlocaldeclkeyword}, \astof{\vdeclitem}, \some{\vasty}, \vexpr)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing and semantics}
As given by the applying the relevant rules to the desugared AST (see \secref{DeclarationStatements}).

\section{Sequencing Statements\label{sec:SequencingStatement}}
\hypertarget{def-sequencestatementterm}{}

\ASLListing{A sequence of statements}{semantics-sseq}{\semanticstests/SemanticsRule.SSeq.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmtlist \derives \ & \ListOne{\Nstmt} &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_seq}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SSeq(\stmt, \stmt) &
\end{flalign*}
}

\ASTRuleDef{StmtList}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-stmtlist}{}
The function
\[
  \buildstmtlist(\overname{\parsenode{\Nstmtlist}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildlist[\Nstmt](\vstmts) \astarrow \vstmtlist\\
  \stmtfromlist(\vstmtlist) \astarrow \vastnode
}{
  \buildstmtlist(\Nstmtlist(\namednode{\vstmts}{\ListOne{\Nstmt}})) \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{StmtFromList}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-stmtfromlist}{}
The function
\[
\stmtfromlist(\overname{\KleeneStar{\stmt}}{\vstmts}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from a possibly-empty list of statements $\vstmts$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[empty]{
}{
  \stmtfromlist(\overname{\emptylist}{\vstmts}) \astarrow \overname{\SPass}{\news}
}
\and
\inferrule[non\_empty]{
  \stmtfromlist(\vstmtsone) \astarrow \vsone\\
  \sequencestmts(\vs, \vsone) \astarrow \news
}{
  \stmtfromlist(\overname{[\vs] \concat \vstmtsone}{\vstmts}) \astarrow \news
}
\end{mathpar}

\ASTRuleDef{SequenceStmts}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-sequencestmts}{}
The function
\[
\sequencestmts(\overname{\stmt}{\vsone}, \overname{\stmt}{\vstwo}) \aslto \overname{\stmt}{\news}
\]
Combines the statement $\vsone$ with $\vstwo$ into the statement $\news$, while filtering away
instances of $\SPass$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[s1\_spass]{}{
  \sequencestmts(\overname{\SPass}{\vsone}, \vstwo) \astarrow \overname{\vstwo}{\news}
}
\and
\inferrule[s2\_spass]{
  \vsone \neq \SPass
}{
  \sequencestmts(\vsone, \overname{\SPass}{\vstwo}) \astarrow \overname{\vsone}{\news}
}
\and
\inferrule[no\_spass]{
  \vsone \neq \SPass\\
  \vstwo \neq \SPass
}{
  \sequencestmts(\vsone, \vstwo) \astarrow \overname{\SSeq(\vsone, \vstwo)}{\news}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SSeq}
\ExampleDef{Typing Sequencing Statements}
In \listingref{semantics-sseq}, the statement \verb|let x=3;| is
annotated first in the \staticenvironmentterm{} where the \localstaticenvironmentterm{} is empty.
Then, the statement \verb|let y = x + 1;|
is annotated in the \staticenvironmentterm{} where
\verb|x| has been declared and associated with the type \verb|integer{3}|,
and also recorded to be equivalent to $\LInt(3)$ (in the $\exprequiv$ map).

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is the AST node for the sequence of statements $\vsone$ and $\vstwo$, that is, $\SSeq(\vsone, \vstwo)$;
  \item annotating $\vsone$ in $\tenv$ yields $(\newsone, \tenvone, \vsesone)$\ProseOrTypeError;
  \item annotating $\vstwo$ in $\tenvone$ yields $(\newstwo, \newtenv, \vsestwo)$\ProseOrTypeError;
  \item $\news$ is the AST node for the sequence of statements $\newsone$ and $\newstwo$, that is, $\SSeq(\newsone, \newstwo)$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesone$ and $\vsestwo$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatestmt(\tenv, \vs1) \typearrow (\newsone, \tenvone, \vsesone) \OrTypeError\\\\
  \annotatestmt(\tenvone, \vs2) \typearrow (\newstwo, \newtenv, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotatestmt(\tenv, \overname{\SSeq(\vsone, \vstwo)}{\vs}) \typearrow (\overname{\SSeq(\newsone, \newstwo)}{\news}, \newtenv, \vses)
}
\end{mathpar}
\CodeSubsection{\SSeqBegin}{\SSeqEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SSeq}
\ExampleDef{Evaluation of Sequencing Statements}
In \listingref{semantics-sseq},
the evaluation of \texttt{let x = 3; let y = x + 1} first evaluates \texttt{let x = 3} and only then
evaluates \texttt{let y = x + 1}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \sequencingstatementterm{} \texttt{s1; s2}, that is, $\SSeq(\vsone, \vstwo)$;
  \item evaluating $\vsone$ in $\env$ is either $\Continuing(\vgone, \envone)$ in which case
        the evaluation continues,
        or a returning configuration ($\Returning((\vvs, \newg), \newenv)$)
        or an abnormal configuration, which short-circuit the entire evaluation;
  \item evaluating $\vstwo$ in $\envone$ yields a non-abnormal configuration \\
        (either $\Returning$ or $\Continuing$) $C$\ProseOrAbnormal;
  \item $\newg$ is the ordered composition of $\vgone$ and the execution graph of $C$ with the
        $\aslpo$ edge;
  \item $D$ is the configuration $C$ with the execution graph component replaced with $\newg$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalstmt(\env, \vsone) \evalarrow \Continuing(\vgone, \envone) \OrAbnormal,\ReturningConfig\\\\
  \evalstmt(\envone, \vstwo) \evalarrow C \OrAbnormal\\\\
  \newg \eqdef \ordered{\vgone}{\aslpo}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\newg}
}{
  \evalstmt(\env, \SSeq(\vsone, \vstwo)) \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSSeqBegin}{\EvalSSeqEnd}{../Interpreter.ml}

\section{Call Statements\label{sec:CallStatements}}
\hypertarget{def-callstatementterm}{}
Call statements are used to invoke procedures and setters.

\ASLListing{Call Statements}{scall}{\semanticstests/SemanticsRule.SCall.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Ncall \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_call}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SCall(\call) &
\end{flalign*}
}

\ASTRuleDef{SCall}
\begin{mathpar}
\inferrule{
  \buildcall(\vcall) \astarrow \astversion{\vcall} \\
  \setcalltype(\astversion{\vcall}) \aslto \vcallp
}{
  \buildstmt(
  \overname{\Nstmt(\namednode{\vcall}{\Ncall}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SCall(\vcallp)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SCall}
The call statement \verb|catenate_into_g{4, 3}(x, y, TRUE);|
in \listingref{scall} is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a call to a subprogram, that is, $\SCall(\vcall)$;
  \item annotating the subprogram call $\vcall$ as per \chapref{SubprogramCalls}
        yields \\
        $(\vcallp, \None, \vses)$\ProseOrTypeError;
  \item $\news$ is the call using $\vcallp$, that is, $\SCall(\vcallp)$;
  \item $\newtenv$ is $\tenv$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \begin{array}{r}
      \annotatecall(\vcall) \typearrow (\vcallp, \None, \vses) \OrTypeError
    \end{array}
  }
}{
  {
    \begin{array}{r}
  \annotatestmt(\tenv, \overname{\SCall(\vcall)}{\vs}) \typearrow
  (\overname{\SCall(\vcallp)}{\news}, \tenv, \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SCallBegin}{\SCallEnd}{../Typing.ml}
\identd{VXKM}

\subsection{Semantics}
\SemanticsRuleDef{SCall}
\ExampleDef{Evaluation of Call Statements}
The call statement \verb|catenate_into_g{4, 3}(x, y, TRUE);|
assigns the global variable \verb|g| to \verb|'1101 111'|.

A call statement \verb|zero();| is ill-typed, since call statements
can only be used for procedures, not functions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a call statement, $\SCall(\vcall)$;
  \item evaluating the subprogram call as per \chapref{SubprogramCalls} is
  \\ $\ResultCall(\newg, \newenv)$\ProseOrAbnormal;
  \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
{
\begin{array}{r}
  \evalcall(\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs) \evalarrow \\
  \ResultCall(\newg, \newenv) \OrAbnormal
\end{array}
}
}{
  \evalstmt(\env, \overname{\SCall(\vcall)}{\vs}) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSCallBegin}{\EvalSCallEnd}{../Interpreter.ml}
\identd{KCYT}

\hypertarget{def-conditionalstatementterm}{}
\section{Conditional Statements\label{sec:ConditionalStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nstmtlist \parsesep \Nselse \parsesep \Tend \parsesep \Tsemicolon &\\
\Nselse \derives\ & \Telseif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nstmtlist \parsesep \Nselse &\\
        |\ & \Telse \parsesep \Nstmtlist &\\
        |\ & \emptysentence &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_cond}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SCond(\expr, \stmt, \stmt)
\end{flalign*}
}

\ASTRuleDef{SCond}
\begin{mathpar}
\inferrule{}{
  {
    \begin{array}{r}
  \buildstmt(\overname{\Nstmt(\Tif, \punnode{\Nexpr}, \Tthen, \punnode{\Nstmtlist}, \punnode{\Nselse}, \Tend, \Tsemicolon)}{\vparsednode})
  \astarrow \\
  \overname{\SCond(\astof{\vexpr}, \astof{\vstmtlist}, \astof{\velse})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{SElse}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-selse}{}
The function
\[
  \buildselse(\overname{\parsenode{\Nselse}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[elseif]{}{
  {
    \begin{array}{r}
  \buildselse(\Nselse(\Telseif, \Nexpr, \Twhen, \Nstmtlist, \Nselse)) \astarrow \\
  \overname{\SCond(\astof{\vexpr}, \astof{\vstmtlist}, \astof{\vselse})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pass]{}{
  \buildselse(\Nselse(\emptysentence)) \astarrow \overname{\SPass}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[else]{}{
  \buildselse(\Nselse(\Telse, \punnode{\Nstmtlist})) \astarrow \overname{\astof{\vstmtlist}}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SCond}
The specifications in \listingref{semantics-scond},
\listingref{semantics-scond2},
\listingref{semantics-scond3}, and
\listingref{semantics-scond4} are all well-typed.

\ExampleDef{Typing Conditional Statements with Two Bitvector Types}
The specification in \listingref{SCond} is well-typed
and shows examples of how \bitvectortypesterm{} either \typesatisfyterm{}
the return type or do not \typesatisfyterm{} the return type and require
an \atcexpressionterm{}.
\ASLListing{Typing conditional statements with two bitvector types}{SCond}{\typingtests/TypingRule.SCond.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a condition $\ve$ with the statements $\vsone$ and $\vstwo$, that is, $\SCond(\ve, \vsone, \vstwo)$;
  \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields \\
        $(\tcond, \econd, \vsescond)$\ProseOrTypeError;
  \item checking that $\tcond$ \typesatisfiesterm\ $\TBool$ yields $\True$\ProseOrTypeError;
  \item annotating the statement $\vsone$ in $\tenv$ yields $(\vsonep, \vsesone)$\ProseOrTypeError;
  \item annotating the statement $\vstwo$ in $\tenv$ yields $(\vstwop, \vsestwo)$\ProseOrTypeError;
  \item $\news$ is the condition $\econd$ with the statements $\vsonep$ and $\vstwop$, that is, \\ $\SCond(\econd, \vsonep, \vstwop)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsescond$, $\vsesone$, and $\vsestwo$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ve) \typearrow (\tcond, \econd, \vsescond) \OrTypeError\\\\
  \checktypesat(\tenv, \tcond, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock(\tenv, \vsone) \typearrow (\vsonep, \vsesone) \OrTypeError\\\\
  \annotateblock(\tenv, \vstwo) \typearrow (\vstwop, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsescond \cup \vsesone \cup \vsestwo
}{
  \annotatestmt(\tenv, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \typearrow
  (\overname{\SCond(\econd, \vsonep, \vstwop)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\CodeSubsection{\SCondBegin}{\SCondEnd}{../Typing.ml}
\identr{NBDJ}

\subsection{Semantics}
\SemanticsRuleDef{SCond}
\ExampleDef{Conditional Statements}
The specification in \listingref{semantics-scond} does not result in any Assertion Error.
\ASLListing{Evaluating a conditional statement}{semantics-scond}{\semanticstests/SemanticsRule.SCond.asl}

The specification in \listingref{semantics-scond2}
does not result in any error.
\ASLListing{Evaluating a condition statement with \texttt{elsif}}{semantics-scond2}{\semanticstests/SemanticsRule.SCond2.asl}

The specification in \listingref{semantics-scond3}
results in an Assertion Error.
\ASLListing{Evaluating a condition statement that results in an Assertion Error}{semantics-scond3}{\semanticstests/SemanticsRule.SCond3.asl}

The specification in \listingref{semantics-scond4} does not result in any error.
\ASLListing{Evaluating a condition statement with only a \texttt{then} branch}{semantics-scond4}{\semanticstests/SemanticsRule.SCond4.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vs$ is a condition statement, $\SCond(\ve, \vsone, \vstwo)$;
\item evaluating $\ve$ in $\env$ yields $\ResultExpr((\vv, \vgone), \envone)$\ProseOrAbnormal;
\item $\vv$ is a native Boolean for $\vb$;
\item the statement $\vsp$ is $\vsone$ is $\vb$ is $\True$ and $\vstwo$ otherwise
      (so that $\vsone$ will be evaluated if the condition evaluates to $\True$ and otherwise
      $\vstwo$ will be evaluated);
\item evaluating $\vsp$ in $\envone$ as per \chapref{BlockStatements} is a non-abnormal configuration
      (either $\Returning$ or $\Continuing$) $C$\ProseOrAbnormal;
\item $\vg$ is the ordered composition of $\vgone$ and the execution graph of the configuration $C$;
\item $D$ is the configuration $C$ with the execution graph component updated to be $\vg$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \vgone), \envone) \OrAbnormal\\\\
  \vv \eqname \nvbool(\vb)\\
  \vsp \eqdef \choice{\vb}{\vsone}{\vstwo}\\
  \evalblock(\envone, \vsp) \evalarrow C \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\aslctrl}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\vg}
}{
  \evalstmt(\env, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSCondBegin}{\EvalSCondEnd}{../Interpreter.ml}

\hypertarget{def-casestatementterm}{}
\section{Case Statements\label{sec:CaseStatements}}
Case statements allow executing different statements, based on which
condition an expression satisfies.

\listingref{case-discriminant} shows an example of a \casestatementterm{}
and the output to a console when it is evaluated.

\ASLListing{A side-effecting case discriminant}{case-discriminant}{\definitiontests/CaseStatement.discriminant.asl}
% CONSOLE_BEGIN aslref \definitiontests/CaseStatement.discriminant.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
num_tests: 0
selected case 2
\end{Verbatim}
% CONSOLE_END
\listingref{case-discriminant} shows an example of a \casestatementterm{}
and the output to a console when it is evaluated.

\hypertarget{def-casediscriminantterm}{}
\hypertarget{def-casealternativeterm}{}
\hypertarget{def-otherwisecaseterm}{}
The expression following the \Tcase\ keyword is called the \emph{\casediscriminantterm}.
The list following the \Tof\ keyword consists of \emph{\casealternativesterm},
optionally ending with an \emph{\otherwisecaseterm}, which follows the \Totherwise\ keyword.

Case statements obey the following requirements:

\RequirementDef{CaseDiscriminant} The \casediscriminantterm\ of a \texttt{case}
statement should be evaluated only once each time the case statement is evaluated.
%
\listingref{case-discriminant} demonstrates how the \casediscriminantterm{}
is evaluated only once.

\RequirementDef{CaseAlternatives} The \casealternativesterm\ are examined
one after another, in the order they are listed.
If any of the patterns match the \casediscriminantterm{} (and the guard
expression is true, if present) then this \casealternativeterm{} is considered selected,
its statement list is executed, and the \texttt{case} statement ends without examining any further
\casealternativesterm.
%
\listingref{case-discriminant} demonstrates how only one \casealternativeterm{} is selected
for execution.

\RequirementDef{CaseDiscriminantTesting} Testing the \casediscriminantterm{} against a \\
pattern list
follows the semantics of pattern matching defined in \chapref{PatternMatching}.
It is not a static error if it can be statically determined that none of the patterns in a
\casealternativeterm\ can match the discriminant.
%
\listingref{case-discriminant} exemplifies a \casestatementterm{} with pattern matching.

\RequirementDef{CaseOtherwise} If no \casealternativeterm\ is selected, and there is an
\otherwisecaseterm\, the \otherwisecaseterm\ is executed.
%
\listingref{case-otherwise} demonstrates how the \otherwisecaseterm{} is evaluated.

\ASLListing{Executing the \texttt{otherwise} case alternative}{case-otherwise}{\definitiontests/CaseStatement.otherwise.asl}
% CONSOLE_BEGIN aslref \definitiontests/CaseStatement.otherwise.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
num_tests: 0
selected otherwise
\end{Verbatim}
% CONSOLE_END

\RequirementDef{CaseNoOtherwiseError} If no \casealternativeterm\ is selected,
and there is no \otherwisecaseterm, it is a \dynamicerrorterm{}.
%
\listingref{case-no-otherwise} shows a specification that, when evaluated,
yields a \dynamicerrorterm{}.

\ASLListing{A case statement with no \texttt{otherwise} case}{case-no-otherwise}{\definitiontests/CaseStatement.no_otherwise.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tcase \parsesep \Nexpr \parsesep \Tof \parsesep \Ncasealtlist \parsesep \Tend \parsesep \Tsemicolon &\\
|\ & \Tcase \parsesep \Nexpr \parsesep \Tof \parsesep \Ncasealtlist \parsesep \Totherwise \parsesep \Tarrow &\\
   & \wrappedline\ \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Ncasealtlist \derives \ & \ClistOne{\Ncasealt} \parsesep &\\
\Ncasealt \derives \ & \Twhen \parsesep \Npatternlist \parsesep \option{\Twhere \parsesep \Nexpr} \parsesep \Tarrow \parsesep \Nstmtlist &\\
\end{flalign*}

\listingref{CaseStatement-bad} shows an example of an erroneous case statement
where a \casealternativeterm{} is missing a statement.
\ASLListing{Invalid case statement syntax}{CaseStatement-bad}{\syntaxtests/CaseStatement.bad.asl}

\subsection{Abstract Syntax}

\SyntacticSugarDef{CaseStatement}
Case statements are considered \\ \syntacticsugar{}.
That is, there is no explicit representation for \texttt{case} statements
as they are represented in AST via a \conditionalstatementterm.
Case statements are \desugared{} by \ASTRuleRef{DesugarCaseStmt}.

\ExampleDef{Case Statement Desugaring}
\listingref{ast-case1} shows an example of how a \texttt{case} statement can be transformed into a corresponding
compound condition statement.
\ASLListing{Transforming a case statement with a variable as the case discriminant}{ast-case1}{\syntaxtests/ASTRule.Desugar_SCase1.asl}

\listingref{ast-case2} shows an example of how a \texttt{case} statement can be transformed into
a statement that does not contain any \text{case} statement.
By storing the \casediscriminantterm\ in a variable and by adding
an \unreachablestatementterm{}, the transformation ensures that a \dynamicerrorterm{} occurs when no
\casealternativeterm\ is selected.
\ASLListing{Transforming a case statement with a non-variable as the case discriminant
and no otherwise case}{ast-case2}{\syntaxtests/ASTRule.Desugar_SCase2.asl}

The untyped AST contains non-terminals for \casealternativesterm, which exist
only as a data type used by $\desugarcasestmt$ and do not later appear in the untyped
AST:

\RenderType[remove_hypertargets]{case_alt}

\ASTRuleDef{SCase}
To satisfy \RequirementRef{CaseNoOtherwiseError}, when no \otherwisecaseterm\ exists,
$\SUnreachable$ is used instead:
\begin{mathpar}
\inferrule[no\_otherwise]{
  \buildlist[\buildcasealt](\vcasealtlist) \astarrow \vcasealtlistast\\
  \buildexpr(\vediscriminant) \astarrow \astversion{\vediscriminant}\\
  {
  \begin{array}{r}
  \desugarcasestmt(\astversion{\vediscriminant}, \vcasealtlistast, \SUnreachable) \astarrow \\
  \vastnode
  \end{array}
  }
}{
  {
  \buildstmt\left(\overname{
    \Nstmt\left(
      \begin{array}{l}
        \Tcase, \namednode{\vediscriminant}{\Nexpr}, \Tof, \\
        \wrappedline\ \namednode{\vcasealtlist}{\Ncasealtlist}, \\
        \wrappedline\ \Tend, \Tsemicolon
      \end{array}
    \right)
    }{\vparsednode}\right)
  \astarrow
  \vastnode
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise]{
  \buildlist[\buildcasealt](\vcasealtlist) \astarrow \vcasealtlistast\\
  \buildexpr(\vediscriminant) \astarrow \astversion{\vediscriminant}\\
  \buildstmtlist(\votherwise) \astarrow \astversion{\votherwise}\\
  {
  \begin{array}{r}
  \desugarcasestmt(\astversion{\vediscriminant}, \vcasealtlistast, \astversion{\votherwise}) \astarrow \\
  \vastnode
  \end{array}
  }
}{
  {
  \buildstmt\left(\overname{
    \Nstmt\left(
      \begin{array}{l}
        \Tcase, \namednode{\vediscriminant}{\Nexpr}, \Tof, \\
        \wrappedline\ \namednode{\vcasealtlist}{\Ncasealtlist}, \\
        \wrappedline\ \Totherwise, \Tarrow, \namednode{\votherwise}{\Nstmtlist}, \\
        \wrappedline\ \Tend, \Tsemicolon
      \end{array}
    \right)
    }{\vparsednode}\right)
  \astarrow
  \vastnode
  }
}
\end{mathpar}

\ASTRuleDef{CaseAltList}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-casealtlist}{}
The function
\[
\buildcasealtlist(\overname{\parsenode{\Ncasealtlist}}{\vparsednode}) \;\aslto\; \overname{\KleenePlus{\casealt}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildclist[\buildcasealt](\vcases) \typearrow \vastnode
}{
  \buildcasealtlist(\overname{\Ncasealtlist(\vcases : \ClistOne{\Ncasealt})}{\vparsednode}) \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{CaseAlt}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-casealt}{}
The function
\[
\buildcasealt(\overname{\parsenode{\Ncasealt}}{\vparsednode}) \;\aslto\; \overname{\casealt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildoption[\buildexpr](\vwhereopt) \astarrow \vwhereast
}{
  {
    \begin{array}{r}
  \buildcasealt\left(\overname{\Ncasealt\left(
    \begin{array}{l}
    \Twhen, \punnode{\Npatternlist}, \\
    \wrappedline\ \namednode{\vwhereopt}{\option{\Twhere, \Nexpr}}, \Tarrow, \\
    \wrappedline\ \namednode{\vstmts}{\Nstmtlist}
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{\casealt(\CasePattern: \astof{\vpatternlist}, \CaseWhere: \vwhereast, \CaseStmt: \astof{\vstmtlist})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarCaseStmt}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-desugarcasestmt}{}
The relation
\[
\desugarcasestmt(
  \overname{\expr}{\vezero},
  \overname{\KleeneStar{\casealt}}{\vcases},
  \overname{\stmt}{\votherwise}) \;\aslrel\; \overname{\stmt}{\news}
\]
transforms a \casediscriminantterm\ $\vezero$, a list of \casealternativesterm\ $\vcases$,
and a statement $\votherwise$ into a statement $\news$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[var]{
  \astlabel(\vezero) = \EVar\\
  \casestocond(\vezero, \vcases, \votherwise) \typearrow \news
}{
  \desugarcasestmt(\vezero, \vcases, \votherwise) \astarrow \news
}
\end{mathpar}

To satisfy \RequirementRef{CaseDiscriminant}, the transformation assigns the
\casediscriminantterm\ to a temporary variable, which is then used in a
compound conditional statement (see \listingref{ast-case2} for an example):
\begin{mathpar}
\inferrule[non\_var]{
  \astlabel(\vezero) \neq \EVar\\
  \vx \in \Identifier \text{ is fresh}\\
  \vdeclx \eqname \SDecl(\LDKLet, \LDIVar(\vx), \None, \some{\vezero})\\
  \casestocond(\EVar(\vx), \vcases, \votherwise) \typearrow \vscond
}{
  \desugarcasestmt(\vezero, \vcases, \votherwise) \astarrow \overname{\SSeq(\vdeclx, \vscond)}{\news}
}
\end{mathpar}
\CodeSubsection{\DesugarCaseStmtBegin}{\DesugarCaseStmtEnd}{../desugar.ml}

\ASTRuleDef{CasesToCond}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-casestocond}{}
The function
\[
\casestocond(
  \overname{\expr}{\ve} \aslsep
  \overname{\KleeneStar{\casealt}}{\vcases} \aslsep
  \overname{\stmt}{\votherwise})
\;\aslrel\; \overname{\stmt}{\news}
\]
transforms an expression $\ve$, a list of \texttt{case} alternatives $\vcases$,
and a statement $\votherwise$
into a statement $\news$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[last]{
  \casetocond(\ve, \vcase, \votherwise) \astarrow \news
}{
  \casestocond(\ve, \overname{[\vcase]}{\vcases}, \votherwise) \astarrow \news
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_last]{
  \vcasesone \neq \emptylist\\
  \casestocond(\ve, \vcasesone) \typearrow \vsone\\
  \casetocond(\ve, \vcase, \vsone) \typearrow \news
}{
  \casestocond(\ve, \overname{[\vcase] \concat \vcasesone}{\vcases}, \votherwise) \astarrow \news
}
\end{mathpar}
\CodeSubsection{\CasesToCondBegin}{\CasesToCondEnd}{../desugar.ml}

\ASTRuleDef{CaseToCond}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-casetocond}{}
The function
\[
\casetocond(\overname{\expr}{\vezero} \aslsep \overname{\casealt}{\vcase} \aslsep \overname{\stmt}{\vtail})
\;\aslrel\; \overname{\stmt}{\news}
\]
transforms an expression $\vezero$ (the condition used for a \texttt{case} statement),
a single \texttt{case} alternative $\vcase$, and a statement $\vtail$, which represents
a list of \texttt{case} alternatives already converted to conditionals, into a condition statement $\news$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \vcase \eqname \{ \CasePattern : \vpattern, \CaseWhere : \vwhere, \CaseStmt : \vstmt \}\\
  \vepattern \eqdef \EPattern(\vezero, \vpattern)\\
  \vcond \eqdef \choice{\vwhere = \some{\vewhere}}{\EBinop(\BAND, \vepattern, \vewhere)}{\vepattern}
}{
  \casetocond(\vezero, \vcase, \vtail) \astarrow \overname{\SCond(\vcond, \vstmt, \vtail)}{\news}
}
\end{mathpar}
\CodeSubsection{\CaseToCondBegin}{\CaseToCondEnd}{../desugar.ml}

\subsection{Typing}
Since case statements are transformed into other statements,
they do not require type system rules.
\identr{WGSY}

\subsection{Semantics}
Since case statements are transformed into other statements,
they do not appear in the typed AST and thus are not associated with a semantics.

In \listingref{CaseStatement.where} the expression \verb|a| will be evaluated twice.
\ASLListing{Evaluating case alternative sub-expressions}{CaseStatement.where}{\definitiontests/CaseStatement.where.asl}

\hypertarget{def-assertionstatementterm}{}
\section{Assertion Statements\label{sec:AssertionStatements}}
Assertion statements are used to check that certain conditions are satisfied.
They take a single \booleantypeterm{} operand, which we refer to as the
\emph{condition}. If the condition is \False, the statement fails with a
\dynamicerrorterm{} (\errorcodeterm{} $\DynamicAssertionFailure$).

\listingref{AssertionStatement} shows a possible use of
\assertionstatementterm{} to check the inputs to a function
(also known as a \emph{precondition})
and ensure the output satisfies expectations (also known as a \emph{postcondition}).
%
The first call to \verb|checked_8bit_add| succeeds, whereas the second call fails the
\assertionstatementterm{} \verb|assert a + b < 256;|

\ASLListing{Example of using \texttt{assert} statements}{AssertionStatement}{\definitiontests/AssertionStatement.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tassert \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_assert}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SAssert(\expr) &
\end{flalign*}
}

\ASTRuleDef{SAssert}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tassert, \Nexpr, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SAssert(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SAssert}
\ExampleDef{Type Assertion Statements}
The specifications in \listingref{semantics-sasertok} and \listingref{semantics-sassertno}
are well-typed.

The assertion statements in \listingref{assert-ill-typed} are ill-typed,
since the expression needs to be both of a \booleantypeterm{} and \readonlyterm{}.
\ASLListing{Ill-typed assertion statements}{assert-ill-typed}{\typingtests/TypingRule.SAssert.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assert statement with expression $\ve$, that is, $\SAssert(\ve)$;
  \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields $(\tep,\vep, \vsese)$\ProseOrTypeError;
  \item checking that $\vsese$ is \readonlyterm{} via $\sesisreadonly$ yields $\True$\ProseOrTypeError;
  \item checking that $\vtep$ \typesatisfiesterm\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is an assert statement with expression $\vep$, that is, $\SAssert(\vep)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{$\vsese$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ve) \typearrow (\vtep, \vep, \vsese) \OrTypeError\\\\
  \checktrans{\sesisreadonly(\vsese) \typearrow \True}{\SideEffectViolation}\\\\
  \checktypesat(\tenv, \vtep, \TBool) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsese
  }{
  \annotatestmt(\tenv, \overname{\SAssert(\ve)}{\vs}) \typearrow (\overname{\SAssert(\vep)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SAssertBegin}{\SAssertEnd}{../Typing.ml}
\identr{JQYF}

\subsection{Semantics}
\SemanticsRuleDef{SAssert}
\ExampleDef{Evaluation of Assertions: Success}
In \listingref{semantics-sasertok},
\texttt{assert (42 != 3);} ensures that \texttt{3} is not equal to \texttt{42}.
\ASLListing{Evaluating an assertion that succeeds}{semantics-sasertok}{\semanticstests/SemanticsRule.SAssertOk.asl}

\ExampleDef{Evaluation of Assertions: Failure}
In \listingref{semantics-sassertno},
evaluating \texttt{assert (42 == 3);} results in an \DynamicAssertionFailure{} error.
\ASLListing{Evaluating an assertion that fails}{semantics-sassertno}{\semanticstests/SemanticsRule.SAssertNo.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is an assertion statement, $\SAssert(\ve)$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{okay}
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ is $\ResultExpr((\vv, \newg), \newenv)$\ProseOrAbnormal;
      \item $\vv$ is a native Boolean value for $\True$;
      \item the resulting configuration is $\Continuing(\newg, \newenv)$.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ is $\ResultExpr((\vv, \newg), \newenv)$;
      \item $\vv$ is a native Boolean value for $\False$;
      \item the result is a \DynamicErrorConfigurationTerm{} indicating the assertion failure returned (\DynamicAssertionFailure).
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \newg), \newenv) \OrAbnormal\\\\
  \vv \eqname \nvbool(\True)
}{
  \evalstmt(\env, \SAssert(\ve)) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
  \inferrule[error]{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \Ignore), \Ignore)\\
  \vv \eqname \nvbool(\False)
}{
  \evalstmt(\env, \SAssert(\ve)) \evalarrow \DynamicErrorVal{\DynamicAssertionFailure}
}
\end{mathpar}
\CodeSubsection{\EvalSAssertBegin}{\EvalSAssertEnd}{../Interpreter.ml}
\identd{QJYV} \identr{WZSL} \identr{WQRN}

\section{While Statements\label{sec:WhileStatements}}
\hypertarget{def-whilestatementterm}{}

\ASLListing{A \texttt{while} statement}{semantics-swhile}{\semanticstests/SemanticsRule.SWhile.asl}

\ConventionDef{Loop Limits}
Conventionally, all loop kinds should specify a limit expression.
For example, the loops in \listingref{semantics-swhile} specifies a limit via
the expression \verb|limit_loop()|.

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Twhile \parsesep \Nexpr \parsesep \Nlooplimit \parsesep \Tdo \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_while}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SWhile(\overtext{\expr}{condition}, \overtext{\expr?}{loop limit}, \overtext{\stmt}{loop body}) &
\end{flalign*}
}

\ASTRuleDef{SWhile}
\begin{mathpar}
\inferrule{
  \buildexpr(\vlimitexpr) \astarrow \astversion{\vlimitexpr}\\
  \buildlooplimit(\voptlimit) \astarrow \astversion{\voptlimit}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Twhile, \econd: \Nexpr, \voptlimit : \Nlooplimit, \Tdo, \\
    \wrappedline\ \punnode{\Nstmtlist}, \Tend, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow\\
  \overname{\SWhile(\astof{\vexpr}, \astversion{\voptlimit}, \astof{\vstmtlist})}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{LoopLimit}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-looplimit}{}
The function
\[
\buildlooplimit(\overname{\parsenode{\Nlooplimit}}{\vparsednode}) \aslto \overname{\Option(\expr)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[limit]{}{
  \buildlooplimit\left(\overname{\Nlooplimit(\Tlooplimit, \punnode{\Nexpr})}{\vparsednode}\right)
  \astarrow
  \overname{\some{\astof{\vexpr}}}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_limit]{}{
  \buildlooplimit\left(\overname{\Nlooplimit(\emptysentence)}{\vparsednode}\right)
  \astarrow
  \overname{\None}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SWhile}
\ExampleDef{Typing While Loops}
The specification in \listingref{typing-swhile} is well-typed
and shows two \whilestatementterm{} --- the first one without a loop limit
and the second one with a loop limit.
\ASLListing{Typing while statements}{typing-swhile}{\typingtests/TypingRule.SWhile.asl}

The specification in \listingref{typing-swhile-bad-limit}
is ill-typed, since the loop limit is not a \constrainedintegerterm.
\ASLListing{An ill-typed loop limit}{typing-swhile-bad-limit}{\typingtests/TypingRule.SWhile.bad_limit.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\vs$ is a \texttt{while} statement with expression $\veone$, optional limit expression $\vlimitone$,
      and statement block $\vsone$, that is, $\SWhile(\veone, \vsone)$;
\item annotating the \rhsexpression{} $\veone$ in $\tenv$ yields $(\vt, \vetwo, \vsese)$\ProseOrTypeError;
\item annotating the optional limit expression $\vlimitone$ via $\annotatelimitexpr$ in $\tenv$ yields $(\vlimittwo, \vseslimit)$\ProseOrTypeError;
\item checking that $\vt$ \typesatisfiesterm\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item annotating $\vsone$ as a block statement as per \TypingRuleRef{Block} in $\tenv$ yields \\
      $(\vstwo, \vsesblock)$\ProseOrTypeError;
\item $\news$ is a \texttt{while} statement with expression $\vetwo$, optional limit expression $\vlimittwo$,
      and statement block $\vstwo$, that is, $\SWhile(\vetwo, \vstwo)$;
\item $\newtenv$ is $\tenv$;
\item \Proseeqdef{$\vses$}{the union of $\vsesblock$, $\vsese$, and $\vseslimit$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vt, \vetwo, \vsese) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimitone) \typearrow (\vlimittwo, \vseslimit) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock(\tenv, \vsone) \typearrow (\vstwo, \vsesblock) \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsese \cup \vseslimit
}{
  \annotatestmt(\tenv, \overname{\SWhile(\veone, \vlimitone, \vsone)}{\vs}) \typearrow
  (\overname{\SWhile(\vetwo, \vlimittwo, \vstwo)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SWhileBegin}{\SWhileEnd}{../Typing.ml}
\identr{FTVN}

\TypingRuleDef{AnnotateLimitExpr}
\RenderRelation{annotate_limit_expr}
\BackupOriginalRelation{
The function
\[
  \annotatelimitexpr(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Option(\expr)}{\ve}
  ) \aslto
  (\Option(\overname{\expr}{\vep}) \times \overname{\TSideEffectSet}{\vses}) \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
annotates an optional expression $\ve$ serving as the limit of a loop or a recursive subprogram in $\tenv$,
yielding a pair consisting of an expression $\vep$ and a \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Limit Expressions}
The specification in \listingref{typing-swhile} has two loops.
The loop in \verb|scan| is limited by the constrained integer
expression \verb|N|, while the loop in \verb|main| does not
have a loop limit.

The loop in \listingref{typing-swhile-bad-limit} uses
the limit expression \verb|i_limit| whose type the
\unconstrainedintegertypeterm, which is illegal for
limit expressions.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\ve$ is $\None$;
    \item \Proseeqdef{$\vep$}{$\None$};
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\ve$ is $\some{\vlimit}$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\vlimit$ in $\tenv$ yields \\
          $(\vlimitp, \vses)$\ProseOrTypeError;
    \item \Proseeqdef{$\vep$}{$\some{\vlimitp}$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \annotatelimitexpr(\tenv, \overname{\None}{\ve}) \typearrow (\overname{\None}{\vep}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\begin{mathpar}
\inferrule[some]{
  \annotatesymbolicconstrainedinteger(\tenv, \vlimit) \typearrow (\vlimitp, \vses) \OrTypeError
}{
  \annotatelimitexpr(\tenv, \overname{\some{\vlimit}}{\ve}) \typearrow (\overname{\some{\vlimitp}}{\vep}, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateLimitExprBegin}{\AnnotateLimitExprEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SWhile}
\ExampleDef{Evaluation of While Statements}
The specification in \listingref{semantics-swhile} prints the
following to the console:
% CONSOLE_BEGIN aslref \semanticstests/SemanticsRule.SWhile.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
i = 0
i = 1
i = 2
i = 3
\end{Verbatim}
% CONSOLE_END

The specification in \listingref{swhile-limit-reached} yields a dynamic
error once the loop limit for the \whilestatementterm{} is reached.
\ASLListing{Reaching a while loop limit}{swhile-limit-reached}{\semanticstests/SemanticsRule.SWhile.limit_reached.asl}

\ProseParagraph
Evaluation of the statement $\vs$ in an environment $\env$ yields
the output configuration $C$.
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{while} statement, $\SWhile(\ve, \velimitopt, \vbody)$;
  \item evaluating the optional limit expression $\velimitopt$ via $\evallimit$ in $\env$
        yields $(\vlimitopt, \vgone)$\ProseOrDynErrorDiverging;
  \item evaluating the loop as per \SemanticsRuleRef{Loop} in an environment $\env$,
  with the arguments $\True$ (which conveys that this is a \texttt{while} statement), $\vlimitopt$, $\ve$, and $\vbody$
  yields the (non-error configuration) $C$\ProseOrDynErrorDiverging;
  \item $\vgtwo$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge;
  \item the output configuration $D$ is the output configuration $C$ with its execution graph
        substituted with $\vgtwo$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitopt, \vgone) \OrDynErrorDiverging\\\\
  \evalloop(\env, \True, \vlimitopt, \ve, \vbody) \evalarrow C \OrDynErrorDiverging\\\\
  \vgtwo \eqdef \ordered{\vgone}{\asldata}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\vgtwo}
}{
  \evalstmt(\env, \overname{\SWhile(\ve, \velimitopt, \vbody)}{\vs}) \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSWhileBegin}{\EvalSWhileEnd}{../Interpreter.ml}

\SemanticsRuleDef{Loop}
\RenderRelation{eval_loop}
\BackupOriginalRelation{
The relation
\[
  \evalloop(
    \overname{\envs}{\env} \aslsep
    \overname{\Bool}{\iswhile} \aslsep
    \overname{\Option(\N)}{\vlimitopt} \aslsep
    \overname{\expr}{\econd} \aslsep
    \overname{\stmt}{\vbody})
  \;\aslrel\;
  \left(
    \begin{array}{cl}
      \Continuing(\overname{\XGraphs}{\newg} \aslsep \overname{\envs}{\newenv}) & \cup \\
      \overname{\TReturning}{\ReturningConfig} & \cup \\
      \overname{\TThrowing}{\ThrowingConfig} & \cup \\
      \overname{\TDynError}{\DynErrorConfig} &
    \end{array}
  \right)
\]
to evaluate both \texttt{while} statements and \texttt{repeat} statements.
} % END_OF_BACKUP_RELATION

More specifically, $\evalloop(\env, \iswhile, \velimitopt, \econd, \vbody)$
evaluates $\vbody$ in $\env$ as long as $\econd$ holds when $\iswhile$ is $\True$
or until $\econd$ holds when $\iswhile$ is $\False$.
If the number of iterations exceeds the optional value specified by $\vlimitopt$,
the result is a \dynamicerrorterm{}.
The result is either the continuing configuration \\ $\Continuing(\newg,\newenv)$,
an early return configuration, or an abnormal configuration.

\ExampleDef{Evaluation of Loops}
The specification in \listingref{semantics-loop} does not result in any Assertion Error
and the specification terminates with exit code $0$.
\ASLListing{Evaluating a loop}{semantics-loop}{\semanticstests/SemanticsRule.Loop.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
\item \AllApplyCase{exit}
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is $\ResultExpr(\condm, \newenv)$\ProseOrAbnormal;
    \item $\condm$ consists of a native Boolean for $\vb$ and an execution graph $\newg$;
    \item $\vb$ is not equal to $\iswhile$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$
    and the loop is exited.
  \end{itemize}
\item \AllApplyCase{continue}
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is $\ResultExpr(\condm, \envone)$\ProseOrAbnormal;
    \item $\mcond$ consists of a native Boolean for $\vb$ and an execution graph $\vgone$;
    \item $\vb$ is equal to $\iswhile$;
    \item \Proseticklooplimit{$\vlimitopt$}{$\vlimitoptp$}\ProseOrError;
    \item evaluating $\vbody$ in $\envone$ as per \SemanticsRuleRef{Block} is either \\
          $\Continuing(\vgtwo, \envtwo)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig, \TDiverging};
    \item evaluating $(\iswhile, \vlimitoptp, \econd, \vbody)$ in $\envtwo$ as a loop is \\
          $\Continuing(\vgthree, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig, \TDiverging};
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label
          and then the ordered composition of the result and $\vgthree$ with the $\aslpo$ edge;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
The premise $\vb \neq \iswhile$ is $\True$ in the case of a \texttt{while} loop
and the loop condition $\ve$ not holding, which is exactly when we want the
loop to exit. The opposite holds for a \texttt{repeat} loop.
The negation of the condition is used to decide whether to continue the loop iteration.

\begin{mathpar}
\inferrule[exit]{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\condm, \newenv) \OrAbnormal\\\\
  \condm \eqname (\nvbool(\vb), \newg)\\
  \vb \neq \iswhile
}{
  \evalloop(\env, \iswhile, \vlimitopt, \econd, \vbody) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[continue]{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\condm, \envone) \OrAbnormal\\\\
  \condm \eqname (\nvbool(\vb), \vgone)\\
  \vb = \iswhile\\
  \ticklooplimit(\vlimitopt) \evalarrow \vlimitoptp \OrDynError\\\\
  \evalblock(\envone, \vbody) \evalarrow \Continuing(\vgtwo, \envtwo) \OrAbnormal, \ReturningConfig\\\\
  {
    \begin{array}{r}
      \evalloop(\envtwo, \iswhile, \vlimitoptp, \econd, \vbody) \evalarrow \\
      \Continuing(\vgthree, \newenv) \OrAbnormal, \ReturningConfig\\
    \end{array}
  }\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslctrl}{\vgtwo}}{\aslpo}{\vgthree}
}{
  \evalloop(\env, \iswhile, \vlimitopt, \econd, \vbody) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalLoopBegin}{\EvalLoopEnd}{../Interpreter.ml}

\SemanticsRuleDef{EvalLimit}
\RenderRelation{eval_limit}
\BackupOriginalRelation{
The relation
\[
\evallimit(\overname{\env}{\envs} \aslsep \overname{\velimitopt}{\Option(\expr)})
\;\aslrel\;
\left(
\begin{array}{ll}
(\overname{\Option(\N)}{\vvopt}, \overname{\XGraphs}{\vg}) & \cup\\
\overname{\TDynError}{\DynErrorConfig} & \cup\\
\overname{\TDiverging}{\DivergingConfig} & \\
\end{array}
\right)
\]
evaluates the optional expression $\velimitopt$ in the environment $\env$, yielding
the optional integer value $\vvopt$ and execution graph $\vg$.
\ProseOtherwiseDynamicErrorOrDiverging
} % END_OF_BACKUP_RELATION

The evaluation uses the function $\evalexprsef$ because limit expressions are
guaranteed side-effect-free by the typechecker,
see \TypingRuleRef{AnnotateLimitExpr}.

See \ExampleRef{Evaluation of While Statements} to see how the
limit expression is evaluated just once for the entire evaluation
of the \whilestatementterm.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\velimitopt$ is $\None$;
    \item $\vvopt$ is $\None$;
    \item $\vg$ is the empty execution graph.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\velimitopt$ is the expression $\velimit$;
    \item evaluating the side-effect-free expression $\velimitopt$ in $\denv$ yields the native integer for $\vv$ and
          the execution graph $\vg$\ProseOrDynErrorDiverging;
    \item $\vvopt$ is $\some{\vv}$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \evallimit(\env, \overname{\None}{\velimitopt}) \evalarrow (\overname{\None}{\vvopt}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \evalexprsef(\env, \velimit) \evalarrow (\nvint(\vv), \vg) \OrDynErrorDiverging
}{
  \evallimit(\env, \overname{\some{\velimit}}{\velimitopt}) \evalarrow (\overname{\some{\vv}}{\vvopt}, \vg)
}
\end{mathpar}

\SemanticsRuleDef{TickLoopLimit}
\RenderRelation{tick_loop_limit}
\BackupOriginalRelation{
The relation
\[
\ticklooplimit(\overname{\Option(\N)}{\vvopt}) \aslto \overname{\Option(\N)}{\Option(\vvoptp)}
\cup \overname{\TDynError}{\DynErrorConfig}
\]
decrements the optional integer $\vvopt$, yielding
the optional integer value $\vvopt$.
If the value is $0$, the result is a \DynamicErrorConfigurationTerm{}.
} % END_OF_BACKUP_RELATION

\ExampleDef{Decrementing a Loop Limit Value}
In \listingref{semantics-swhile}, the loop limit value
starts at $\nvint(20)$ and decrements towards $\nvint(0)$,
stopping at $\nvint(1)$ on the last iteration of the loop.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vvopt$ is $\None$;
    \item $\vvoptp$ is $\None$.
  \end{itemize}

  \item \AllApplyCase{some\_ok}
  \begin{itemize}
    \item $\vvopt$ is the positive integer $\vv$;
    \item $\vvoptp$ is $\some{\vv-1}$.
  \end{itemize}

  \item \AllApplyCase{some\_error}
  \begin{itemize}
    \item $\vvopt$ is the integer $0$;
    \item the result is a \DynamicErrorConfigurationTerm{} indicating that a limit has been reached
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \ticklooplimit(\overname{\None}{\vvopt}) \evalarrow \overname{\None}{\vvoptp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_ok]{
  \vv > 0
}{
  \ticklooplimit(\overname{\some{\vv}}{\vvopt}) \evalarrow \overname{\some{\vv-1}}{\vvoptp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_error]{}{
  \ticklooplimit(\overname{\some{ 0 }}{\vvopt}) \evalarrow \DynamicErrorVal{\LimitExceeded}
}
\end{mathpar}

\section{Repeat Statements\label{sec:RepeatStatements}}
\hypertarget{def-repeatstatementterm}{}

\ASLListing{A repeat statement}{semantics-srepeat}{\semanticstests/SemanticsRule.SRepeat.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Trepeat \parsesep \Nstmtlist \parsesep \Tuntil \parsesep \Nexpr \parsesep \Nlooplimit \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_repeat}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SRepeat(\overtext{\stmt}{loop body}, \overtext{\expr}{condition}, \overtext{\expr?}{loop limit}) &
\end{flalign*}
}

\ASTRuleDef{SRepeat}
\begin{mathpar}
\inferrule{
  \buildexpr(\vlimitexpr) \astarrow \astversion{\vlimitexpr}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Tlooplimit, \Tlpar, \namednode{\vlimitexpr}{\Nexpr}, \Trpar, \Trepeat, \\
    \wrappedline\ \Nstmtlist, \Tuntil, \punnode{\Nexpr}, \punnode{\Nlooplimit}, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow\\
  \overname{\SRepeat(\astof{\vstmtlist}, \astof{\vexpr}, \astof{\vlooplimit})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SRepeat}
\ExampleDef{Typing a Repeat Statement}
The \repeatstatementsterm{} in \listingref{semantics-srepeat} are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement with statement block $\vsone$,
        optional limit expression $\vlimitone$, and expression $\veone$, that is, $\SRepeat(\vsone, \veone, \vlimitone)$;
  \item annotating $\vsone$ as a block statement per \TypingRuleRef{Block} in $\tenv$ yields \\
        $(\vstwo, \vsesblock)$\ProseOrTypeError;
  \item annotating the optional limit expression $\vlimitone$ via $\annotatelimitexpr$ in $\tenv$ yields $(\vlimittwo, \vseslimit)$\ProseOrTypeError;
  \item annotating the \rhsexpression{} $\veone$ in $\tenv$ yields $(\vt, \vetwo, \vsese)$\ProseOrTypeError;
  \item checking that $\vt$ \typesatisfiesterm\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is a \texttt{repeat} statement with statement block $\vstwo$, optional limit expression $\vlimittwo$,
        and condition expression $\vetwo$ and , that is, $\SRepeat(\vstwo, \vetwo, \vlimittwo)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesblock$, $\vsese$, and $\vseslimit$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateblock(\tenv, \vsone) \typearrow (\vstwo, \vsesblock) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimitone) \typearrow (\vlimittwo, \vseslimit) \OrTypeError\\\\
  \annotateexpr(\tenv, \veone) \typearrow (\vt, \vetwo, \vsese) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsese \cup \vseslimit
}{
  {
  \begin{array}{r}
    \annotatestmt(\tenv, \overname{\SRepeat(\vsone, \veone, \vlimitone)}{\vs}) \typearrow\\
    (\overname{\SRepeat(\vstwo, \vetwo, \vlimittwo)}{\news}, \overname{\tenv}{\newtenv}, \vses)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SRepeatBegin}{\SRepeatEnd}{../Typing.ml}
\identr{FTVN}

\subsection{Semantics}
\SemanticsRuleDef{SRepeat}
\ExampleDef{Evaluation of Repeat Statements}
The specification in \listingref{semantics-srepeat} produces the following output to the console.
% CONSOLE_BEGIN aslref  --type-check-no-warn \semanticstests/SemanticsRule.SRepeat.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
j = 0
j = 1
j = 2
j = 3
j = 4
#ones in x = 5
i = 0
i = 1
i = 2
i = 3
i = 4
#ones in x = 5
\end{Verbatim}
% CONSOLE_END

\ProseParagraph
Evaluation of the statement $\vs$ in an environment $\env$ yields
either \\ $\Returning((\vvs, \newg), \newenv)$ or an output configuration $D$.

\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement, $\SRepeat(\ve, \vbody, \velimitopt)$;
  \item evaluating the optional limit expression $\velimitopt$ via $\evallimit$ in $\env$
        yields $(\vlimitopt, \vgone)$\ProseOrDynErrorDiverging;
  \item \Proseticklooplimit{$\vlimitoptone$}{$\vlimitopttwo$}\ProseOrError;
  \item evaluating $\vbody$ in $\env$ as per \chapref{BlockStatements}
        yields $\Continuing(\vgtwo, \envone)$\ProseTerminateAs{\ReturningConfig,\ThrowingConfig,\DynErrorConfig,\DivergingConfig};
  \item evaluating the loop as per \secref{SemanticsRule.Loop} in an environment $\envone$,
        with the arguments $\False$ (which conveys that this is a \texttt{repeat} statement),
        $\vlimitopttwo$,
        $\ve$,
        and $\vbody$
        results in $C$;
  \item $\vgthree$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ and the graph of $C$
        with the $\aslpo$ edge;
  \item the output configuration $D$ is the output configuration $C$ with its execution graph
        substituted with $\vgthree$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitoptone, \vgone) \OrDynErrorDiverging\\\\
  \ticklooplimit(\vlimitoptone) \evalarrow \vlimitopttwo \OrDynError\\\\
  \evalblock(\env, \vbody) \evalarrow \Continuing(\vgtwo, \envone) \OrAbnormal, \ReturningConfig\\\\
  \evalloop(\envone, \False, \vlimitopttwo, \ve, \vbody) \evalarrow C\\
  \vgthree \eqdef \ordered{\vgone}{\asldata}{\ordered{\vgtwo}{\aslpo}{\graphof{C}}}\\
  D \eqdef \withgraph{C}{\vgthree}
}{
  \evalstmt(\env, \overname{\SRepeat(\ve, \vbody, \velimitopt)}{\vs}) \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSRepeatBegin}{\EvalSRepeatEnd}{../Interpreter.ml}

\section{For Statements\label{sec:ForStatements}}
\hypertarget{def-forstatementterm}{}

\ASLListing{\texttt{for} loops}{semantics-sfor}{\semanticstests/SemanticsRule.SFor.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tfor \parsesep \Tidentifier \parsesep \Teq \parsesep \Nexpr \parsesep \Ndirection \parsesep
                    \Nexpr \parsesep \Nlooplimit \parsesep \Tdo &\\
                        & \wrappedline\ \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Ndirection \derives \ & \Tto \;|\; \Tdownto &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_for}
\BackupOriginalAST{
\begin{flalign*}
\fordirection \derives\ & \UP \;|\; \DOWN &\\
\stmt \derives\ & \SFor\left\{
      \begin{array}{rcl}
      \Forindexname  &:& \identifier,\\
      \Forstarte     &:& \expr,\\
      \Fordir        &:& \fordirection,\\
      \Forende       &:& \expr,\\
      \Forbody       &:& \stmt,\\
      \Forlimit      &:& \expr?
      \end{array}
    \right\} &
\end{flalign*}
}

\ASTRuleDef{SFor}
\begin{mathpar}
\inferrule{
  \buildexpr(\vstarte) \astarrow \astversion{\vstarte}\\
  \buildexpr(\vende) \astarrow \astversion{\vende}\\
}{
  {
    \begin{array}{r}
      \buildstmt\left(\overname{\Nstmt\left(
        \begin{array}{l}
        \Tfor, \Tidentifier(\vindexname), \Teq, \namednode{\vstarte}{\Nexpr},  \\
        \wrappedline\ \Ndirection, \namednode{\vende}{\Nexpr}, \punnode{\Nlooplimit}, \Tdo, \\
        \wrappedline\ \punnode{\Nstmtlist}, \Tend, \Tsemicolon
        \end{array}
        \right)}{\vparsednode}\right)
      \astarrow \\
        \overname{
        \SFor\left(\left\{
          \begin{array}{rcl}
            \Forindexname &:& \vindexname\\
            \Forstarte &:& \astversion{\vstarte}\\
            \Fordir &:& \astof{\vdirection}\\
            \Forende &:& \astversion{\vende}\\
            \Forbody &:& \astof{\vstmtlist}\\
            \Forlimit &:& \astof{\vlooplimit}\\
          \end{array}
            \right\}\right)
    }{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{Direction}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-direction}{}
The function
\[
\builddirection(\overname{\parsenode{\Ndirection}}{\vparsednode}) \;\aslto\; \overname{\fordirection}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[to]{}{
  \builddirection(\overname{\Ndirection(\Tto)}{\vparsednode}) \astarrow \overname{\UP}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[downto]{}{
  \builddirection(\overname{\Ndirection(\Tdownto)}{\vparsednode}) \astarrow \overname{\DOWN}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SFor}
The \texttt{for} loops in \listingref{semantics-sfor} are well-typed.

\ExampleDef{Ill-typed for loop}
\listingref{typing-forloop-bad1},
\listingref{typing-forloop-bad2},
\listingref{typing-forloop-bad3}, and
\listingref{typing-forloop-bad4}
show examples of ill-typed \texttt{for} loops.

\ASLListing{Ill-typed for loop 1}{typing-forloop-bad1}{\typingtests/TypingRule.SFor.bad1.asl}
\ASLListing{Ill-typed for loop 2}{typing-forloop-bad2}{\typingtests/TypingRule.SFor.bad2.asl}
\ASLListing{Ill-typed for loop 3}{typing-forloop-bad3}{\typingtests/TypingRule.SFor.bad3.asl}
\ASLListing{Ill-typed for loop 4}{typing-forloop-bad4}{\typingtests/TypingRule.SFor.bad4.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement with index $\vindexname$,
        start expression $\vstarte$,
        direction $\dir$,
        end expression $\vende$,
        body statement (block) $\vbody$,
        and optional limit expression $\vlimit$,
        that is, $\SFor\left\{\begin{array}{rcl}
          \Forindexname &:& \vindexname\\
          \Forstarte &:& \vstarte\\
          \fordirection &:& \vdir\\
          \Forende &:& \vende\\
          \Forbody &:& \vbody\\
          \Forlimit &:& \vlimit
        \end{array}\right\}$;
  \item annotating the \rhsexpression{} $\vstarte$ in $\tenv$ yields \\
        $(\vstartt, \vstartep, \vsesstart)$\ProseOrTypeError;
  \item annotating the \rhsexpression{} $\vende$ in $\tenv$ yields \\ $(\vendt, \vendep, \vsesend)$\ProseOrTypeError;
  \item annotating the optional loop limit expression $\vlimit$ via $\annotatelimitexpr$ in $\tenv$
        yields $(\vlimitp, \vseslimit)$\ProseOrTypeError;
  \item checking that $\vsesstart$ is \readonlyterm{} via $\sesisreadonly$ yields $\True$\ProseOrTypeError;
  \item checking that $\vsesend$ is \readonlyterm{} via $\sesisreadonly$ yields $\True$\ProseOrTypeError;
  \item \Proseeqdef{$\vsescond$}{the union of $\vsesstart$, $\vsesend$, and $\vseslimit$};
  \item obtaining the \underlyingtypeterm\ of $\vstartt$ in $\tenv$ yields $\vstartstruct$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vendt$ in $\tenv$ yields $\vendstruct$\ProseOrTypeError;
  \item applying $\getforconstraints$ to $\vstartstruct$, $\vendstruct$,
        $\vstartep$, $\vendep$, and $\dir$ in $\tenv$,
        to obtain the constraints on the loop index $\vindexname$,
        yields $\cs$\ProseOrTypeError;
  \item $\tty$ is the integer type with constraints $\cs$;
  \item checking that $\vindexname$ is not already declared in $\tenv$ yields $\True$\ProseOrTypeError;
  \item adding $\vindexname$ as a local immutable variable with type $\tty$ to $\tenv$ yields $\tenvp$;
  \item annotating $\vbody$ as a block statement in $\tenvp$ yields $(\vbodyp, \vsesblock)$\ProseOrTypeError;
  \item $\news$ is the \texttt{for} statement with index $\vindexname$,
        start expression $\vstartep$, direction $\dir$,
        end expression $\vendep$,
        body statement (block) $\vbodyp$, and
        optional limit expression $\vlimit$;
  \item $\newtenv$ is $\tenv$ (notice that this means $\vindexname$ is only declared for annotating $\vbodyp$ but then goes
        out of scope);
  \item define $\vses$ as the union of $\vsesblock$ and $\vsescond$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \vstarte) \typearrow (\vstartt, \vstartep, \vsesstart) \OrTypeError\\\\
  \annotateexpr(\tenv, \vende) \typearrow (\vendt, \vendep, \vsesend) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimit) \typearrow (\vlimitp, \vseslimit) \OrTypeError\\\\
  \checktrans{\sesisreadonly(\vsesstart)}{\SideEffectViolation} \typearrow \True\OrTypeError\\\\
  \checktrans{\sesisreadonly(\vsesend)}{\SideEffectViolation} \typearrow \True\OrTypeError\\\\
  \vsescond \eqdef \vsesstart \cup \vsesend \cup \vseslimit\\
  \makeanonymous(\tenv, \vstartt) \typearrow \vstartstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vendt) \typearrow \vendstruct \OrTypeError\\\\
  {
    \begin{array}{r}
  \getforconstraints(\tenv, \vstartstruct, \vendstruct, \vstartep, \vendep, \dir) \typearrow \\
    \cs \OrTypeError
    \end{array}
  }\\\\
  \tty \eqdef \TInt(\cs)\\
  \checkvarnotinenv(\tenv, \vindexname) \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \tty, \vindexname, \LDKLet) \typearrow \tenvp\\
  \annotateblock(\tenvp, \vbody) \typearrow (\vbodyp, \vsesblock) \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsescond
}{
  {
    \begin{array}{r}
  \annotatestmt\left(\tenv, \overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \Fordir &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \vlimit
  \end{array}\right\}}{\vs}\right) \typearrow \\
  \left(\overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstartep\\
    \Fordir &:& \vdir\\
    \Forende &:& \vendep\\
    \Forbody &:& \vbodyp\\
    \Forlimit &:& \vlimitp
  \end{array}\right\}}{\news}, \overname{\tenv}{\newtenv}, \vses\right)
\end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SForBegin}{\SForEnd}{../Typing.ml}
\identr{SSBD} \identr{ZSND} \identr{VTJW}

\TypingRuleDef{SForConstraints}
\RenderRelation{get_for_constraints}
\BackupOriginalRelation{
The function
\[
  \getforconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\structone} \aslsep
    \overname{\ty}{\structtwo} \aslsep
    \overname{\expr}{\veonep} \aslsep
    \overname{\expr}{\vetwop} \aslsep
    \overname{\fordirection}{\dir}
  ) \aslto
  \overname{\constraintkind}{\vis} \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
infers the integer constraints for a \texttt{for} loop index variable from the following:
\begin{itemize}
  \item the \wellconstrainedversionterm\ of the type of the start expression --- $\structone$
  \item the \wellconstrainedversionterm\ of the type of the end expression --- $\structtwo$
  \item the annotated start expression --- $\veonep$
  \item the annotated end expression --- $\vetwop$
  \item the loop direction --- $\dir$
\end{itemize}
The result is $\vis$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Inferring the Constraints of a for Loop Index}
In \listingref{semantics-sfor} the constraints for the loop index variable
\verb|j| in \verb|scan| are \verb|0..N-1|,
and the constraints for the loop index variable \verb|i| in \verb|main| are \verb|0..4|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{not\_integers}
  \begin{itemize}
    \item at least one of $\structone$ and $\structtwo$ is not an integer type;
    \item the result is a \typingerrorterm{} indicating that the start expression and end expression of \texttt{for} loops
          must have the \structureterm\ of integer types.
  \end{itemize}

  \item \AllApplyCase{unconstrained}
  \begin{itemize}
    \item both of $\structone$ and $\structtwo$ are integer types;
    \item at least one of $\structone$ and $\structtwo$ is the unconstrained integer type;
    \item define $\vis$ as $\Unconstrained$.
  \end{itemize}

  \item \AllApplyCase{well\_constrained}
  \begin{itemize}
    \item both of $\structone$ and $\structtwo$ are integer types;
    \item neither $\structone$ nor $\structtwo$ is the unconstrained integer type;
    \item symbolically simplifying $\veonep$ in $\tenv$ yields $\eonen$\ProseOrTypeError;
    \item symbolically simplifying $\vetwop$ in $\tenv$ yields $\etwon$\ProseOrTypeError;
    \item define $\icsup$ as the single range constraint with expressions $\eonen$ and $\etwon$;
    \item define $\icsdown$ as the single range constraint with expressions $\etwon$ and $\eonen$;
    \item define $\vis$ as $\icsup$ if $\dir$ is $\UP$ and $\icsdown$ otherwise.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_integers]{
  \astlabel(\structone) \neq \TInt \lor \astlabel(\structtwo) \neq \TInt
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  \astlabel(\structone) = \TInt \land \astlabel(\structtwo) = \TInt\\
  \structone = \unconstrainedinteger \lor \structtwo = \unconstrainedinteger\\
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \overname{\Unconstrained}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \astlabel(\structone) = \TInt \land \astlabel(\structtwo) = \TInt\\
  \structone \neq \unconstrainedinteger \land \structtwo \neq \unconstrainedinteger\\
  \normalize(\tenv, \veonep) \typearrow \eonen \OrTypeError\\\\
  \normalize(\tenv, \vetwop) \typearrow \etwon \OrTypeError\\\\
  \icsup \eqdef \WellConstrained([\ConstraintRange(\eonen, \etwon)])\\
  \icsdown \eqdef \WellConstrained([\ConstraintRange(\etwon, \eonen)])\\
  \vis \eqdef \choice{\dir=\UP}{\icsup}{\icsdown}
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \vis
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{SFor}
Evaluating a \texttt{for} statement involves introducing an index variable to the
environment. The type system ensures, via \TypingRuleRef{SFor}, that the index variable
is not already declared in the scope of the subprogram containing the \texttt{for}
statement.

\ExampleDef{Evaluation of For Statements}
The specification in \listingref{semantics-sfor} is followed by its output to the console.
% CONSOLE_BEGIN aslref \semanticstests/SemanticsRule.SFor.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
j = 0
j = 1
j = 2
j = 3
j = 4
#ones in x = 5
i = 4
i = 3
i = 2
i = 1
i = 0
#ones in x = 5
\end{Verbatim}
% CONSOLE_END

The specification in \listingref{SFor-nop} shows a \forstatementterm{}
whose body does not evaluate since its lower bound is greater than its upper bound.
\ASLListing{A for loop with no iterations}{SFor-nop}{\semanticstests/SemanticsRule.SFor.nop.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement, $\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \Ignore
  \end{array}\right\}$;
  \item evaluating the side-effect-free expression $\vstarte$ in $\env$ yields\\
        $\ResultExprSEF(\vstartv, \vgone)$\ProseOrDynErrorDiverging;
  \item evaluating the side-effect-free expression $\vende$ in $\env$ yields\\
        $\ResultExprSEF(\vendv, \vgtwo)$\ProseOrError;
  \item \Proseevallimit{$\env$}{$\velimitopt$}{$(\vlimitopt, \vgthree)$}\ProseOrDynErrorDiverging;
  \item declaring the local identifier $\vindexname$ in $\env$ with value $\vstartv$ is $(\vgfour, \envone)$;
  \item applying the \texttt{for} loop with arguments \\
        $(\vindexname, \vlimitopt, \vstartv, \dir, \vendv, \vbody)$ in $\envone$,
        as per \\
        \SemanticsRuleRef{EvalFor} yields $\Continuing(\vgfive, \envtwo)$\ProseReturningOrAbnormal;
  \item removing the local $\vindexname$ from $\envtwo$ is $\envthree$;
  \item $\newg$ is formed as follows:
        the parallel composition of $\vgone$, $\vgtwo$, and $\vgthree$;
        followed by the ordered composition of the result with $\vgfour$ using the $\asldata$ edge;
        followed by the ordered composition of the result with $\vgfive$ using the $\aslpo$ edge.
  \item $\newenv$ is $\envthree$.
  \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
\end{itemize}

\FormallyParagraph
Recall that the expressions for the \texttt{for} loop range are
side-effect-free, as guaranteed by \TypingRuleRef{SFor}, which is why
they are evaluated via the rule for evaluating side-effect-free expressions.
\begin{mathpar}
\inferrule{
  \evalexprsef(\env, \vstarte) \evalarrow \ResultExprSEF(\vstartv, \vgone) \OrDynErrorDiverging\\\\
  \evalexprsef(\env, \vende) \evalarrow \ResultExprSEF(\vendv, \vgtwo) \OrDynErrorDiverging\\\\
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitopt, \vgthree) \OrDynErrorDiverging\\\\
  \declarelocalidentifier(\env, \vindexname, \vstartv) \evalarrow (\vgfour,\envone)\\
  {
    \begin{array}{r}
      \evalfor(\envone, \vindexname, \vlimitopt, \vstartv, \dir, \vendv, \vbody) \evalarrow \\
      \Continuing(\vgfive, \envtwo) \OrReturningOrAbnormal
    \end{array}
  }\\
  \removelocal(\envtwo, \vindexname) \evalarrow \envthree\\
  \newg \eqdef \ordered{(\vgone \parallelcomp \vgtwo \parallelcomp \vgthree)}{\asldata}{ \ordered{\vgfour}{\aslpo}{\vgfive}   }\\
  \newenv \eqdef \envthree
}{
  {
  \begin{array}{r}
  \evalstmt\left(\env,
  \overname{
  \SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \velimitopt\\
  \end{array}\right\}}{\vs}
  \right) \evalarrow \\ \Continuing(\newg, \newenv)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EvalSForBegin}{\EvalSForEnd}{../Interpreter.ml}

\SemanticsRuleDef{EvalFor}
\RenderRelation{eval_for}
\BackupOriginalRelation{
The relation
\[
  \evalfor\left(
  \begin{array}{cl}
    \overname{\envs}{\env}                      & \aslsep\\
    \overname{\Identifier}{\vindexname}        & \aslsep\\
    \overname{\Option(\tint)}{\vlimitopt}  & \aslsep\\
    \overname{\tint}{\vstart}                   & \aslsep\\
    \overname{\{\UP, \DOWN\}}{\dir}             & \aslsep\\
    \overname{\tint}{\vend}                     & \aslsep\\
    \overname{\stmt}{\vbody}                    &
  \end{array}
  \right)
  \;\aslrel\;
  \left(
    \begin{array}{cl}
    \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TContinuing}{\ContinuingConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup\\
    \overname{\TDynError}{\DynErrorConfig} & \cup\\
    \overname{\TDiverging}{\DivergingConfig} & \\
    \end{array}
    \right)
\]
evaluates the \texttt{for} loop with the index variable $\vindexname$,
optional limit value $\vlimitopt$,
starting from the value
$\vstart$ going in the direction given by $\dir$ until the value given by $\vend$,
executing $\vbody$ on each iteration.
%
The evaluation utilizes two helper relations: $\evalforstep$ and $\evalforloop$.
} % END_OF_BACKUP_RELATION


\RenderRelation{eval_for_step}
\BackupOriginalRelation{
The relation
\[
  \evalforstep\left(
  \begin{array}{cl}
  \overname{\envs}{\env}                      & \aslsep\\
  \overname{\Identifier}{\vindexname}        & \aslsep\\
  \overname{\Option(\tint)}{\vlimitopt}  & \aslsep\\
  \overname{\tint}{\vstart}                   & \aslsep\\
  \overname{\{\UP,\DOWN\}}{\dir}              &
  \end{array}
  \right)
  \;\aslrel\;
  \left(
  \begin{array}{cl}
  ((\overname{\tint}{\vstep} \times \overname{\envs}{\newenv}) \times \overname{\XGraphs}{\newg}) & \cup\\
  \overname{\TReturning}{\ReturningConfig}  & \cup\\
  \overname{\TThrowing}{\ThrowingConfig}    & \cup \\
  \overname{\TDynError}{\DynErrorConfig}    & \cup\\
  \overname{\TDiverging}{\DivergingConfig}  &
  \end{array}
  \right)
\]
either increments or decrements the index variable,
returning the new value of the index variable, the modified environment,
and the resulting execution graph.
\ProseOtherwiseReturningOrAbnormal
} % END_OF_BACKUP_RELATION

\RenderRelation{eval_for_loop}
\BackupOriginalRelation{
The relation
\[
  \evalforloop\left(
    \begin{array}{cl}
    \overname{\envs}{\env} \aslsep &\\
    \overname{\Identifier}{\vindexname} \aslsep &\\
    \overname{\Option(\tint)}{\vlimitopt} \aslsep &\\
    \overname{\tint}{\vstart} \aslsep &\\
    \overname{\{\UP,\DOWN\}}{\dir} \aslsep &\\
    \overname{\tint}{\vend} \aslsep &\\
    \overname{\stmt}{\vbody} &
    \end{array}
    \right) \;\aslrel\;
    \left(
    \begin{array}{cl}
    \Continuing(\overname{\XGraphs}{\newg}, \overname{\envs}{\newenv}) & \cup\\
    \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup \\
    \overname{\TDynError}{\DynErrorConfig} & \cup\\
    \overname{\TDiverging}{\DivergingConfig} &
    \end{array}
    \right)
\]
executes one iteration of the loop body and then uses $\texttt{eval\_for}$ to execute the remaining
iterations.
} % END_OF_BACKUP_RELATION

\ProseParagraph
\subsubsection{Stepping the Index Variable}
\AllApply
\begin{itemize}
  \item $\opfordir$ is either $\ADD$ when $\dir$ is $\UP$ or $\SUB$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item applying the binary operator $\opfordir$ to $\vstart$ and the native integer for $1$ is $\vstep$;
  \item the execution graph for writing $\vstep$ into the identifier $\vindexname$ gives $\vgtwo$;
  \item updating the local component of the dynamic environment of $\env$ by binding \\ $\vindexname$ to $\vstep$
  gives $\newenv$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}

\subsubsection{Running the Loop Body}
\AllApply
\begin{itemize}
  \item evaluating $\vbody$ as a block statement (see \SemanticsRuleRef{Block}) in $\env$
        yields \\ $\Continuing(\vgone, \envone)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
  \item stepping the index $\vindexname$ with $\vstart$ and the direction $\dir$ in $\envone$,
        that is, $\evalforstep(\envone, \vindexname, \vlimitopt, \vstart, \dir)$ yields \\
        $((\vstep, \envtwo), \vgtwo)$;
  \item evaluating the \texttt{for} loop with $(\vindexname, \vlimitopt, \vstep, \dir, \vend, \vbody)$
        in $\envtwo$ results in a continuing configuration $\Continuing(\vgthree, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
  \item $\newg$ is the ordered composition of $\vgone$, $\vgtwo$, and $\vgthree$ with the $\aslpo$
        edge.
\end{itemize}

\subsubsection{Overall Evaluation}
\ExampleDef{Overall Evaluation of For Statements}
The specification in \listingref{semantics-sfor}
does not result in any assertion error, and terminates with exit-code $0$.

Evaluating $(\vindexname, \vstart, \dir, \vend, \vbody)$ in $\env$ yields either
a continuing configuration $\Continuing(\newg, \newenv)$, or a returning configuration
(in case the body of the loop results in an early return),
or an abnormal configuration.

\AllApply
\begin{itemize}
  \item $\compfordir$ is either $\LT$ when $\dir$ is $\UP$ or $\GT$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item \OneApplies
    \begin{itemize}
    \item \AllApplyCase{return}
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native \\
            Boolean for $\True$;
      \item $\newg$ is $\vgone$;
      \item $\newenv$ is $\env$;
      \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}
    \item \AllApplyCase{continue}
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native \\
            Boolean for $\False$;
      \item \Proseticklooplimit{$\vlimitopt$}{$\vnextlimitopt$}\ProseOrError;
      \item evaluating the loop body via $\evalforloop$ with \\ $(\vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody)$
      in $\env$ is \\ $\Continuing(\vgtwo, \newenv)$\ProseOrAbnormalReturning;
      \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
Advancing the loop counter one step towards the end of its range is achieved via the following rule:
\begin{mathpar}
\inferrule{
  \opfordir \eqdef \choice{\dir = \UP}{\ADD}{\SUB}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\
  \evalbinop(\opfordir, \vstart, \nvint(1)) \evalarrow \vstep\\
  \writeidentifier(\vindex, \vstep) \evalarrow \vgtwo\\
  \env \eqname (\tenv, \denv)\\
  \newenv \eqdef (\tenv, (G^\denv, L^\denv[\vindexname\mapsto\vstep]))\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  {
    \begin{array}{r}
      \evalforstep(\env, \vindexname, \vlimitopt, \vstart, \dir) \evalarrow \\
      ((\vstep, \newenv), \newg)
    \end{array}
  }
}
\end{mathpar}

Running the loop body is achieved via the following rule:
\begin{mathpar}
\inferrule{
  \evalblock(\env, \vbody) \evalarrow \Continuing(\vgone, \envone) \OrAbnormalReturning\\\\
  \evalforstep(\envone, \vindexname, \vlimitopt, \vstart, \dir) \evalarrow ((\vstep, \envtwo), \vgtwo)\\
  {
    \begin{array}{r}
      \evalfor(\envtwo, \vindexname, \vlimitopt, \vstep, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\vgthree, \newenv) \OrAbnormalReturning
    \end{array}
  }\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\vgthree}
}{
  {
    \begin{array}{r}
      \evalforloop(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\newg, \newenv)
    \end{array}
  }
}
\end{mathpar}

Finally, the rules for evaluating a \texttt{for} loop utilize both $\evalforstep$
and \\
$\evalforloop$ (the latter in a mutually recursive manner):
\begin{mathpar}
\inferrule[return]{
  \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\\\
  \commonprefixline\\\\
  \evalbinop(\compfordir, \vend, \vstart) \evalarrow \nvbool(\True)
}{
  {
    \begin{array}{r}
      \evalfor(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\overname{\vgone}{\newg}, \overname{\env}{\newenv})
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[continue]{
  \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\\\
  \commonprefixline\\\\
  \evalbinop(\compfordir, \vend, \vstart) \evalarrow \nvint(\False)\\
  \ticklooplimit(\vlimitopt) \evalarrow \vnextlimitopt \OrDynError\\\\
  \evalforloop(\env, \vindexname, \vnextlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
  \Continuing(\vgtwo, \newenv) \OrAbnormalReturning\\\\
  \newg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
}{
  {
    \begin{array}{r}
      \evalfor(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\newg, \newenv)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EvalForBegin}{\EvalForEnd}{../Interpreter.ml}

\hypertarget{def-throwstatementterm}{}
\section{Throw Statements\label{sec:ThrowStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tthrow \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_throw}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SThrow(\expr) &
\end{flalign*}
}

\ASTRuleDef{SThrow}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tthrow, \Nexpr, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SThrow(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SThrow}
\listingref{semantics-sthrowsometyped}
shows examples of well-typed \throwstatementsterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a throw statement with expression $\ve$, that is, $\SThrow(\ve)$;
  \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields $(\vte, \vep, \vsesone)$\ProseOrTypeError;
  \item checking that $\vte$ has the structure of an exception type yields $\True$\ProseOrTypeError;
  \item view $\vte$ as the named type for $\exnname$;
  \item $\news$ is a throw statement with expression $\vep$ and type $\vte$, that is, \\
        $\SThrow(\vep, \vte)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesone$ and the set containing a \LocalEffectTerm{} and a \GlobalEffectTerm{}, both with \purity{} $\SEImpure$.}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ve) \typearrow (\vte, \vep, \vsesone) \OrTypeError\\\\
  \checkstructurelabel(\tenv, \vte, \TException) \typearrow \True \OrTypeError\\\\
  \vte \eqname \TNamed(\exnname)\\
  \vses \eqdef \vsesone \cup \{\LocalEffect(\SEImpure), \GlobalEffect(\SEImpure)\}
}{
  \annotatestmt(\tenv, \overname{\SThrow(\ve)}{\vs}) \typearrow
  (\overname{\SThrow(\vep, \vte)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\identr{NXRC}
\CodeSubsection{\SThrowBegin}{\SThrowEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SThrow}
\ExampleDef{Throwing a Typed Exception}
The specification in \listingref{semantics-sthrowsometyped}
terminates successfully. That is, no \dynamicerrorterm{} occurs.
\ASLListing{Throwing an exception}{semantics-sthrowsometyped}{\semanticstests/SemanticsRule.SThrowSomeTyped.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{throw} statement, \\
        $\SThrow(\ve, \vt)$;
  \item evaluating $\ve$ in $\env$ is $\ResultExpr((\vv, \vgone), \newenv)$\ProseOrAbnormal;
  \item $\name$ is a fresh identifier (which conceptually holds the exception value);
  \item $\vgtwo$ is a Write Effect to $\name$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge;
  \item $\vex$ consists of the exception value $\vv$ and the name of the variable holding it ---
        $\name$;
  \item the result of the entire evaluation is $\Throwing(\vex, \vt, \newg, \env)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \name\in\Identifier \text{ is fresh}\\
  \vgtwo \eqdef \WriteEffect(\name)\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}\\
  \vex \eqdef \valuereadfrom(\vv, \name)
}{
  \evalstmt(\env, \SThrow(\ve, \vt)) \evalarrow
  \Throwing(\vex, \vt, \newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSThrowBegin}{\EvalSThrowEnd}{../Interpreter.ml}

\hypertarget{def-trystatementterm}{}
\section{Try Statements\label{sec:TryStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Ttry \parsesep \Nstmtlist \parsesep \Tcatch \parsesep \ListOne{\Ncatcher} \parsesep \Notherwiseopt &\\
                  & \wrappedline\ \parsesep \Tend \parsesep \Tsemicolon &\\
\Notherwiseopt \derives\ & \Totherwise \parsesep \Tarrow \parsesep \Nstmtlist &\\
               |\ & \emptysentence &\\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_try}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \STry(\stmt, \KleeneStar{\catcher}, \overtext{\stmt?}{otherwise}) &
\end{flalign*}
}

\ASTRuleDef{STry}
\begin{mathpar}
\inferrule{
  \buildlist[\Ncatcher] \astarrow \astversion{\vcatcherlist}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Ttry, \Nstmtlist, \Tcatch,  \\
    \wrappedline\ \namednode{\vcatcherlist}{\ListOne{\Ncatcher}}, \\
    \wrappedline\ \Notherwiseopt, \Tend, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{\STry(\astof{\vstmtlist}, \astversion{\vcatcherlist}, \astof{\votherwiseopt})}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{OtherwiseOpt}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-otherwiseopt}{}
The function
\[
   \buildotherwiseopt(\overname{\parsenode{\Notherwiseopt}}{\vparsednode}) \aslto
    \overname{\Option(\stmt)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[non\_empty]{
  \buildstmtlist(\vstmts) \astarrow \astversion{\vstmts}
}{
  {
  \begin{array}{r}
    \buildotherwiseopt(\overname{\Notherwiseopt(\Totherwise, \Tarrow, \namednode{\vstmts}{\Nstmtlist})}{\vparsednode}) \astarrow\\
    \astversion{\vstmts}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty]{}{
  \buildotherwiseopt(\overname{\Notherwiseopt(\emptysentence)}{\vparsednode}) \astarrow \None
}
\end{mathpar}

\subsection{Typing}

\TypingRuleDef{STry}
\ExampleDef{Typing Try Statements}
In
\listingref{semantics-catchnamed},
\listingref{semantics-catchotherwise},
\listingref{semantics-catchnone},
\listingref{semantics-nothrow}, and
\listingref{semantics-stry},
the \trystatementsterm{} are all well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a try statement with statement $\vsp$, list of catchers $\catchers$ and an \optionalterm\ \texttt{otherwise} block;
  \item annotating the statement $\vsp$ as a block statement yields $(\vspp, \vsesone)$\ProseOrTypeError;
  \item annotating each catcher $\catchers[\vi]$, for each $\vi$ in $\listrange(\catchers)$ in $\tenv$ yields $\vc\_\vi$
        and $\vxs_i$\ProseOrTypeError;
  \item $\catchersp$ is the list of annotated catchers $\vc\_\vi$ for each $\vi\in\listrange(\catchers)$;
  \item \Proseeqdef{$\vsescatchers$}{the union of all $\vxs_\vi$, for \Proselistrange{$\vi$}{$\catchers$}};
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{no\_otherwise}
    \begin{itemize}
      \item there is no \texttt{otherwise} statement;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and no \texttt{otherwise} statement,
            that is \\
            $\STry(\vspp, \catchersp, \None)$;
      \item \Proseeqdef{$\vsesotherwise$}{the empty set};
      \item \Proseeqdef{$\vsesthree$}{$\vsestwo$}.
    \end{itemize}

    \item \AllApplyCase{otherwise}
    \begin{itemize}
      \item there is an \texttt{otherwise} statement $\otherwise$;
      \item annotating the statement $\otherwise$ as a block statement in $\tenv$ yields $\otherwisep$\ProseOrTypeError;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and \texttt{otherwise} statement
            $\otherwisep$, that is \\
            $\STry(\vspp, \catchersp, \some{\otherwisep})$;
      \item \Proseeqdef{$\vsesotherwise$}{$\vsesblock$};
      \item \Proseeqdef{$\vsesthree$}{$\vsestwo$}.
    \end{itemize}

    \item \Proseeqdef{$\vses$}{the union of $\vsesthree$, $\vsescatchers$, and $\vsesotherwise$}.
  \end{itemize}
  \item $\newtenv$ is $\tenv$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_otherwise]{
  \annotateblock(\tenv, \vsp) \typearrow (\vspp, \vsesone) \OrTypeError\\\\
  \vi\in\listrange(\catchers): \annotatecatcher(\tenv, \catchers[\vi]) \typearrow (\vc_\vi, \vxs_\vi) \OrTypeError\\\\
  \catchersp \eqdef [\vi\in\listrange(\catchers) : \vc_\vi]\\\\
  \vsescatchers \eqdef \bigcup_{\vi\in\listrange(\catchers)} \vxs_\vi\\\\
  \commonprefixline\\\\
  \news \eqdef \STry(\vspp, \catchersp, \None)\\
  \vsesotherwise \eqdef \emptyset\\
  \vsesthree \eqdef \vsestwo\\\\
  \commonsuffixline\\\\
  \vses \eqdef \vsesthree \cup \vsescatchers \cup \vsesotherwise
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \None)}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv}, \vses)
}
\and
\inferrule[otherwise]{
  \annotateblock(\tenv, \vsp) \typearrow (\vspp, \vsesone) \OrTypeError\\\\
  \vi\in\listrange(\catchers): \annotatecatcher(\tenv, \catchers[\vi]) \typearrow (\vc_\vi, \vxs_\vi) \OrTypeError\\\\
  \catchersp \eqdef [\vi\in\listrange(\catchers) : \vc_\vi]\\\\
  \vsescatchers \eqdef \bigcup_{\vi\in\listrange(\catchers)} \vxs_\vi\\\\
  \commonprefixline\\\\
  \annotateblock(\tenv, \otherwise) \typearrow (\otherwisep, \vsesblock) \OrTypeError\\\\
  \news \eqdef \STry(\vspp, \catchersp, \otherwise')\\
  \vsesotherwise \eqdef \vsesblock\\
  \vsesthree \eqdef \vsestwo \\\\
  \commonsuffixline\\\\
  \vses \eqdef \vsescatchers \cup \vsesotherwise
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \some{\otherwise})}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\STryBegin}{\STryEnd}{../Typing.ml}
\identr{WVXS}

\subsection{Semantics}
\SemanticsRuleDef{STry}
\ExampleDef{Evaluation of Try Statements}
Evaluating the specification in \listingref{semantics-stry}
does not result in any Assertion error, and the specification terminates with the exit code $0$.
\ASLListing{Evaluating a \texttt{try} statement}{semantics-stry}{\semanticstests/SemanticsRule.STry.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \texttt{try} statement, $\STry(\vs, \catchers, \otherwiseopt)$;
  \item evaluating $\vsone$ in $\env$ as per \chapref{BlockStatements}
        yields the configuration $\sm$\ProseOrDynErrorDiverging;
  \item evaluating $(\catchers, \otherwiseopt, \sm)$ as per \chapref{CatchingExceptions}
        is $C$, which is the result of the entire evaluation.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalblock(\env, \vsone) \evalarrow \sm \OrDynErrorDiverging\\\\
  \evalcatchers(\env, \catchers, \otherwiseopt, \sm) \evalarrow C
}{
  \evalstmt(\env, \STry(\vsone, \catchers, \otherwiseopt)) \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalSTryBegin}{\EvalSTryEnd}{../Interpreter.ml}

\hypertarget{def-returnstatementterm}{}
\section{Return Statements\label{sec:ReturnStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Treturn \parsesep \option{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_return}
\BackupOriginalAST{
\begin{flalign*}
  \stmt \derives\ & \SReturn(\expr?) &
\end{flalign*}
}

\ASTRuleDef{SReturn}
\begin{mathpar}
\inferrule{
  \buildoption[\Nexpr](\vexpr) \astarrow \astversion{\vexpr}
}{
  \buildstmt(\overname{\Nstmt(\Treturn, \namednode{\vexpr}{\option{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SReturn(\astversion{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SReturn}

\ExampleDef{Typing Return Statements}
The \returnstatementsterm{} in
\listingref{semantics-sreturn},
\listingref{semantic-ssreturnone}, and
\listingref{semantics-sreturntuple}
are all well-typed.

The return statement \verb|return 0;| in \listingref{typing-return-bad} is ill-typed,
since \verb|proc| is not a function but a procedure.
\ASLListing{An ill-typed return statement}{typing-return-bad}{\typingtests/TypingRule.SReturn.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{error}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with an optional expression $\veopt$, that is, \\
          $\SReturn(\veopt)$;
    \item the condition that $\veopt$ is $\None$ if and only if the enclosing subprogram does not have a return type
          (that is, $\returntype$ in the \localstaticenvironmentterm{} is $\None$) does not hold;
    \item the result is an error indicating the mismatch between the declared (existence of the) return type
          and the (existence of the) return expression.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
    \item the enclosing subprogram does not have a \texttt{return} type (it is either a setter
          or a procedure);
    \item $\news$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
    \item $\newtenv$ is $\tenv$;
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with an expression $\ve$, that is, $\SReturn(\some{ \vep })$;
    \item the enclosing subprogram has a return type $\vt$;
    \item annotating the \rhsexpression{} $\ve$ in $\tenv$ yields $(\tep,\vep,\vses)$\ProseOrTypeError;
    \item checking whether $\vtep$ \typesatisfiesterm\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\news$ is a \texttt{return} statement with value $\vep$, that is, $\SReturn(\some{ \vep })$;
    \item $\newtenv$ is $\tenv$.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[error]{
  \vb \eqdef (L^\tenv.\returntype = \None \leftrightarrow \veopt = \None) \\
  \vb = \False
}{
  \annotatestmt(\tenv, \overname{\SReturn(\veopt)}{\vs}) \typearrow \TypeErrorVal{\BadSubprogramDeclaration}
}
\end{mathpar}

\begin{mathpar}
\inferrule[none]{
  L^\tenv.\returntype = \None
}{
  \annotatestmt(\tenv, \overname{\SReturn(\None)}{\vs}) \typearrow
  (\overname{\SReturn(\None)}{\news}, \overname{\tenv}{\newtenv}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  L^\tenv.\returntype = \some{ \vt }\\
  \annotateexpr(\tenv, \ve) \typearrow (\vtep, \vep, \vses) \OrTypeError\\\\
  \checktypesat(\tenv, \vtep, \vt) \typearrow \True \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SReturn(\some{ \ve })}{\vs}) \typearrow
  (\overname{\SReturn(\some{ \vep })}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SReturn}{\SReturnEnd}{../Typing.ml}
\identr{FTPK}

\subsection{Semantics}
\SemanticsRuleDef{SReturn}
\ExampleDef{No Return Value}
The specification in \listingref{semantics-sreturn} exits the procedure \texttt{println\_me}
by evaluating the \texttt{return;} statement.
\ASLListing{Evaluating a \texttt{return} statement with no value}{semantics-sreturn}{\semanticstests/SemanticsRule.SReturnNone.asl}

\ExampleDef{Returning a Single Value}
In \listingref{semantic-ssreturnone},
\texttt{return 3;} exits the function \texttt{f} with value \texttt{3}.
\ASLListing{Evaluating a \texttt{return} statement with a single value}{semantic-ssreturnone}{\semanticstests/SemanticsRule.SReturnOne.asl}

\ExampleDef{Returning a Tuple of Values}
In \listingref{semantics-sreturntuple},
\texttt{return (3, 42);} exits the function \texttt{f} with the value \texttt{(3, 42)}.
\ASLListing{Evaluating a \texttt{return} statement with a tuple of values}{semantics-sreturntuple}{\semanticstests/SemanticsRule.SReturnSome.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement, $\SReturn(\None)$;
    \item $\vvs$ is the empty list, $\emptylist$;
    \item $\newg$ is the empty graph;
    \item $\newenv$ is $\env$.
  \end{itemize}

  \item \AllApplyCase{one}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement;
    \item $\vs$ is a \texttt{return} statement for a single expression, $\SReturn(\some{\ve})$;
    \item evaluating $\ve$ in $\env$ is $\ResultExpr((\vv, \vgone), \newenv)$\ProseOrAbnormal;
    \item $\vvs$ is $[\vv]$;
    \item $\vgtwo$ is the result of adding a Write Effect for a fresh identifier and the value $\vv$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement for a list of expressions, $\SReturn(\some{\ETuple(\es)})$;
    \item evaluating each expression in $\es$ separately as per \secref{SemanticsRule.EExprListM}
    is \\ $\ResultExprListM(\ms, \newenv)$\ProseOrAbnormal;
    \item writing the list of values in $\vms$ results in $(\vvs, \newg)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}
{
  \evalstmt(\env, \SReturn(\None)) \evalarrow \Returning((\emptylist, \emptygraph), \env)
}
\end{mathpar}

\begin{mathpar}
\inferrule[one]{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \wid \in \Identifier\text{ is fresh}\\
  \writeidentifier(\wid, \vv) \evalarrow \vgtwo\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalstmt(\env, \SReturn(\some{\ve})) \evalarrow \Returning(([\vv], \newg), \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \evalexprlistm(\env, \es) \evalarrow \ResultExprListM(\ms, \newenv) \OrAbnormal\\
  \writefolder(\ms) \evalarrow (\vvs, \newg)
}{
  \evalstmt(\env, \SReturn(\some{\ETuple(\es)})) \evalarrow \Returning((\vvs, \newg), \newenv)
}
\end{mathpar}
\CodeSubsubsection{\SReturnBegin}{\EvalSReturnEnd}{../Interpreter.ml}

\SemanticsRuleDef{EExprListM}
\RenderRelation{eval_expr_list_m}
\BackupOriginalRelation{
The relation
\[
\evalexprlistm(\overname{\envs}{\env} \aslsep \overname{\KleeneStar{\expr}}{\vEs}) \;\aslrel\;
\left(
\begin{array}{cl}
\ResultExprListM(\overname{\KleeneStar{(\nativevalue\times\XGraphs)}}{\vms} \aslsep \overname{\envs}{\newenv}) & \cup\\
\overname{\TThrowing}{\ThrowingConfig} & \cup \\
\overname{\TDynError}{\DynErrorConfig} & \cup \\
\overname{\TDiverging}{\DivergingConfig}
\end{array}
\right)
\]
evaluates a list of expressions $\vEs$ in left-to-right in the initial environment $\env$
and returns the list of values associated with graphs $\vms$ and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.
} % END_OF_BACKUP_RELATION

\ExampleDef{Seperately Evaluating a List of Expressions}
In \listingref{semantics-sreturntuple}, the expressions \verb|3| and \verb|42|
are evaluated in left-to-right order in the statement \verb|return (3 , 42);|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vEs$ is an empty list;
    \item $\vms$ is then empty list.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vEs$ is a list with \head\ $\ve$ and \tail\ $\vesone$;
    \item evaluating $\ve$ in $\env$ yields $\ResultExpr(\vmone, \envone)$\ProseOrAbnormal;
    \item evaluating $\vesone$ in $\envone$ via $\evalexprlistm$ yields \\
          $\ResultExprListM(\vmsone, \newenv)$\ProseOrAbnormal;
    \item the result is a configuration consisting of a list with $\vmone$ as its \head\ and $\vmsone$
          as its \tail\ and $\newenv$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \evalexprlistm(\env, \overname{\emptylist}{\vEs}) \evalarrow \ResultExprListM(\overname{\emptylist}{\vms}, \overname{\env}{\newenv})
}
\end{mathpar}

\subsubsection{Semantics}
\begin{mathpar}
\inferrule[non\_empty]{
  \vEs = [\ve] \concat \vesone\\
  \evalexpr(\env, \ve) \evalarrow \ResultExpr(\vmone, \envone) \OrAbnormal\\
  \evalexprlistm(\envone, \vesone) \evalarrow \ResultExprListM(\vmsone, \newenv) \OrAbnormal
}{
  \evalexprlistm(\env, \vEs) \evalarrow \ResultExprListM([\vmone]\concat\vmsone, \newenv)
}
\end{mathpar}

\SemanticsRuleDef{WriteFolder}
\RenderRelation{write_folder}
\BackupOriginalRelation{
The relation
\[
  \writefolder(\overname{\KleeneStar{(\nativevalue\times\XGraphs)}}{\vms}) \aslrel (\overname{\KleeneStar{\nativevalue}}{\vvs}, \overname{\XGraphs}{\newg})
\]
concatenates the input values in $\vms$ and generates an execution graph
by composing the graphs in $\vms$ with Write Effects for the respective values.
} % END_OF_BACKUP_RELATION

\ExampleDef{Folding a List of Pairs with Values and Execution Graphs}
In \listingref{semantics-sreturntuple}, the statement \verb|return (3 , 42);|
uses $\writefolder$ to generate \\
$([\nvint(3), \nvint(42)], \emptygraph)$.
The \executiongraphterm{} is empty, since literal expressions do not yield
\executiongraphs{} and composing empty \executiongraphs{} yields an
empty \executiongraphterm{}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vms$ is the empty list;
    \item \Proseeqdef{$\vvs$}{the empty list};
    \item \Proseeqdef{$\newg$}{the empty graph}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vms$ is a list with \head{} $\vm$ and \tail{} $\vmsone$;
    \item view $\vm$ as the \nativevalueterm{} $\vv$ and the \executiongraphterm{} $\vg$;
    \item \Proseeqdef{$\wid$}{a fresh identifier};
    \item applying $\writeidentifier$ to $\wid$ and $\vv$ yields $\vgone$;
    \item applying $\writefolder$ to $\vms$ and $\vgone$ yields the pair $(\vvsone, \vgtwo)$;
    \item \Proseeqdef{$\vvs$}{the list with \head{} $\vv$ and \tail{} $\vvsone$};
    \item \Proseeqdef{$\newg$}{the ordered composition of $\vg$ and $\vgone$ with the $\aslpo$ edge
          and $\vgtwo$ with the $\asldata$ edge}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \writefolder(\overname{\emptylist}{\vms}) \evalarrow (\overname{\emptylist}{\vvs}, \overname{\emptygraph}{\newg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vms = [\vm] \concat \vmsone\\
  \vm \eqdef (\vv, \vg)\\
  \wid \in \Identifier\text{ is fresh}\\
  \writeidentifier(\wid, \vv) \evalarrow \vgone\\
  \writefolder(\vmsone, \vgone) \evalarrow (\vvsone, \vgtwo)\\
  \vvs \eqdef [\vv] \concat \vvsone\\
  \newg \eqdef \ordered{\vg}{\aslpo}{\ordered{\vgone}{\asldata}{\vgtwo}}
}{
  \writefolder(\vms) \evalarrow (\vvs, \newg)
}
\end{mathpar}

\hypertarget{def-printstatementterm}{}
\section{Print Statements\label{sec:PrintStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tprint \parsesep \ClistZero{\Nexpr} \parsesep \Tsemicolon & \\
\Nstmt \derives \ & \Tprintln \parsesep \ClistZero{\Nexpr} \parsesep \Tsemicolon & \\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_print}
\BackupOriginalAST{
\begin{flalign*}
  \stmt \derives\ & \SPrint(\overtext{\KleeneStar{\expr}}{args}, \overtext{\Bool}{newline}) &
\end{flalign*}
}

\ASTRuleDef{SPrint}
\begin{mathpar}
\inferrule{%
  \buildclist[\Nexpr](\vargs) \astarrow \astversion{\vargs} \\
  \vnewline \eqdef \False \\
}{%
  \buildstmt(\overname{\Nstmt(\Tprint, \namednode{\vargs}{\ClistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPrint(\astversion{\vargs}, \vnewline)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule{%
  \buildclist[\Nexpr](\vargs) \astarrow \astversion{\vargs} \\
  \vnewline \eqdef \True \\
  \vdebug \eqdef \False \\
}{%
  \buildstmt(\overname{\Nstmt(\Tprintln, \namednode{\vargs}{\ClistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPrint(\astversion{\vargs}, \vnewline)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SPrint}
\listingref{literals1} shows literals and their corresponding types in comments.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ denotes the print statement with arguments $\vargs$ and newline indicator $\vnewline$;
  \item annotating for each \Proselistrange{$i$}{$\vargs$}, the expression $\vargs_i$ in $\tenv$ yields $(\vt_i, \vargsp_i, \vxs_i)$\ProseOrTypeError;
  \item checking for each \Proselistrange{$i$}{$\vargs$}, that $\vt_i$ is a singular type yields $\True$\ProseOrTypeError;
  \item $\news$ denotes the print statement with arguments $\vargsp$ and newline indicator $\vnewline$;
  \item $\newtenv$ is $\tenv$;
  \item define $\vses$ as the union of the set containing a \GlobalEffectTerm{} with \purity{} $\SEImpure$ and a \LocalEffectTerm{} with \purity{} $\SEImpure$, and each set $\vxs_i$, for \Proselistrange{$i$}{$\vargs$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule{%
    \vi\in\listrange(\vargs): \annotateexpr(\tenv, \vargs[i]) \typearrow (\vt_i, \vargsp[i], \vxs_i)\OrTypeError \\\\
    \vi\in\listrange(\vargs): \checktrans{\issingular(\vt_i)}{\UnexpectedType} \typearrow \True \OrTypeError \\\\
    \vses \eqdef \{\LocalEffect(\SEImpure), \GlobalEffect(\SEImpure)\} \cup \bigcup_{\vi\in\listrange(\vargs)} \vxs_i
  }{%
    \annotatestmt (\tenv, \overname{\SPrint(\vargs, \vnewline)}{\vs}) \typearrow (\SPrint(\vargsp, \vnewline), \tenv, \vses)
  }
\end{mathpar}
\CodeSubsection{\SPrintBegin}{\SPrintEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SPrint}

\ExampleDef{Printing Literals}
\listingref{semantics-literals} shows examples of printing various types of literals,
followed by the output to the console resulting from running the specification.
\ASLListing{Literals and how they are displayed}{semantics-literals}{\semanticstests/SemanticsRule.SPrint.asl}
% CONSOLE_BEGIN aslref \semanticstests/SemanticsRule.SPrint.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
string_number_1
0
1000000
53170898287292728730499578000
TRUE
FALSE
12345678900123456789/10000000000
0
hello\world
	 "here I am "
0xd
0x
LABEL_B
\end{Verbatim}
% CONSOLE_END

Notice that empty bitvectors are displayed as \verb|0x|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{print}
  \begin{itemize}
    \item $\vs$ denotes a \printstatementterm{} with arguments $\elist$ and newline indicator $\False$;
    \item the evaluation of $\elist$ in $\env$ is $\ResultExprList((\vlist, \vg), \newenv)$\ProseOrAbnormal;
    \item \Proseoutputtoconsole{all the elements in $\elist$, without a separator,};
    \item if $\vnewline$ is $\True$, \Proseoutputtoconsole{a newline character};
  \end{itemize}

  \item \AllApplyCase{println}
  \begin{itemize}
    \item $\vs$ denotes a \printstatementterm{} with arguments $\elist$ and newline indicator $\True$;
    \item the evaluation of the same statement with a newline indicator set to $\False$, that is,
          $\SPrint(\elist, \False)$ yields the configuration \\
          $\Continuing(\vg, \envone)$\ProseOrAbnormal;
    \item \Proseoutputtoconsole{a newline character};
  \end{itemize}
  \item the resulting configuration is $\Continuing(\vg, \newenv)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[print]{
  \evalexprlist(\env, \elist) \evalarrow \ResultExprList((\vlist, \vg), \env_1) \OrAbnormal\\
  \vi\in\listrange(\vlist): \outputtoconsole(\env_\vi, \vlist[i]) \evalarrow \env_{\vi + 1} \\
  n \eqdef \listlen{\vlist}\\
  \newenv \eqdef \env_{n + 1}
}{
  \evalstmt(\env, \SPrint(\elist, \False)) \evalarrow \Continuing(\vg, \newenv)
}
\end{mathpar}

\hypertarget{def-newline}{}
We define the newline character $\vnewline \triangleq \ascii{10}$.

\begin{mathpar}
\inferrule[println]{
  \evalstmt(\env, \SPrint(\elist, \False)) \evalarrow \Continuing(\vg, \envone) \OrAbnormal\\\\
  \outputtoconsole(\envone, \nvstring(\vnewline)) \evalarrow \newenv
}{
  \evalstmt(\env, \SPrint(\elist, \True)) \evalarrow \Continuing(\vg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSPrintBegin}{\EvalSPrintEnd}{../Interpreter.ml}

Not all ASL runtimes support printing to a console (see \RequirementRef{Printing}).
%
Therefore, the semantics is parameterized by the function
\hypertarget{def-outputtoconsole}{}
\[
\outputtoconsole(\overname{\envs}{\env} \aslsep \overname{\nativevalue}{\vv}) \aslto
  \overname{\envs}{\newenv}
\]
which takes a string and communicates it to a console, where one exists.

We now explain how printing is modelled when the runtime supports a console
(\SemanticsRuleRef{SupportedOutputToConsole})
and how it is modelled when the runtime does not support a console
(\SemanticsRuleRef{UnsupportedOutputToConsole}).

\SemanticsRuleDef{SupportedOutputToConsole}
To support a console, the definition of environments needs
to include an extra component to capture the string of characters sent to the console:
\[
\envs \triangleq \staticenvs \times \dynamicenvs \times \Strings \enspace.
\]
We omit this component in the rest of this document to avoid clutter, and include it
only here to explain the modeling of a console.

\ExampleRef{Printing Literals} shows the output to the console in a case it is supported.

\hypertarget{def-literaltostring}{}
The function $\literaltostring : \literal \aslto \Strings$,
which defines how a literal is represented by a string,
is defined by \taref{literaltostringtable}.
%
Please note that surrounding quotations mark for $\LString(S)$ are not included
in $\literaltostring(S)$, so they will appear in the printed string.

\begin{table}
\caption{How literals should be represented as strings\label{ta:literaltostringtable}}
\begin{tabular}{rl}
\textbf{literal $\vl$} & \textbf{$\literaltostring(\vl)$} \\
\hline
$\LInt(n)$        & $n$ in decimal format, without any leading zeros, \\
                  & preceded by a ``\texttt{-}'' sign if $n$ is negative. \\
$\LBool(\True)$   & \texttt{TRUE} \\
$\LBool(\False)$  & \texttt{FALSE} \\
$\LReal(q)$       & $q$ as an irreducible fraction of positive integers, \\
                  & preceded by a ``\texttt{-}'' sign when $q$ is negative, \\
                  & with the denominator omitted if it is equal to 1. \\
$\LBitvector(b)$  & $b$ in hexadecimal, preceded by ``\texttt{0x}'', with enough leading \\
                  & zeros to make the number of hexadecimal digits printed \\
                  & equal to the width of $b$ divided by 4, and rounded up to \\
                  & the following integer.\\
$\LString(S)$     & $S$. \\
$\LLabel(s)$      & $s$. \\
\end{tabular}
\end{table}

\ProseParagraph
\AllApply
\begin{itemize}
  \item view $\env$ as the environment consisting of the \staticenvironmentterm{} $\tenv$,
        dynamic environment $\denv$, and console string $\vconsolestream$;
  \item view $\vv$ as a native literal for the literal $\vl$;
  \item \Proseeqdef{$\newenv$}{the environment consisting of the \staticenvironmentterm{} $\tenv$,
        dynamic environment $\denv$, and console string
        define as the concatenation of \\
        $\vconsolestream$ and $\literaltostring(\vl)$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqname (\tenv, \denv, \vconsolestream)\\
  \newenv \eqdef (\tenv, \denv, \vconsolestream \concat \literaltostring(\vl))
}{
  \outputtoconsole(\env, \NVLiteral(\vl)) \evalarrow (\newenv)
}
\end{mathpar}

\SemanticsRuleDef{UnsupportedOutputToConsole}
The function ignores the string value and returns the environment unchanged.

In a runtime without support for a console, the \printstatementsterm{}
in \listingref{semantics-literals} evaluate their list of expressions
with no other effect.

\ProseParagraph
\ProseEqdef{$\newenv$}{$\env$}.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \outputtoconsole(\env, \Ignore) \evalarrow \overname{\env}{\newenv}
}
\end{mathpar}

\section{The Unreachable Statement\label{sec:UnreachableStatement}}
\hypertarget{def-unreachablestatementterm}{}
\listingref{UnreachableStatement} shows an example of using an \unreachablestatementterm{}
to implement a custom form of assertion checking.
\ASLListing{An example use of an \texttt{unreachable} statement}{UnreachableStatement}{\definitiontests/UnreachableStatement.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tunreachable \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_unreachable}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SUnreachable &
\end{flalign*}
}

\ASTRuleDef{SUnreachable}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tunreachable, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SUnreachable}{\vastnode}
}
\end{mathpar}

\TypingRuleDef{SUnreachable}
\ExampleDef{Typing an Unreachable Statement}
The \unreachablestatementterm{} in \listingref{UnreachableStatement} is well-typed.

\ProseParagraph
Annotating $\SUnreachable$ in the \staticenvironmentterm{} $\tenv$ yields $(\SUnreachable, \tenv, \emptyset)$.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \annotatestmt(\tenv, \SUnreachable) \typearrow (\SUnreachable, \tenv, \overname{\emptyset}{\vses})
}
\end{mathpar}

\SemanticsRuleDef{SUnreachable}
\ExampleDef{Evaluating an Unreachable Statement}
Evaluating the specification in \listingref{UnreachableStatement} results in a \dynamicerrorterm,
since the \unreachablestatementterm{} is evaluated.

\ProseParagraph
Evaluating $\SUnreachable$ in an environment $\env$ results in a \DynamicErrorConfigurationTerm{} indicating this ($\UnreachableError$).
\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \evalstmt(\env, \SUnreachable) \evalarrow \DynamicErrorVal{\UnreachableError}
}
\end{mathpar}

\section{Pragma Statements\label{sec:PragmaStatements}}
\hypertarget{def-pragmastatementterm}{}

\ASLListing{A pragma statement}{typing-spragma}{\typingtests/TypingRule.SPragma.asl}

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tpragma \parsesep \Tidentifier \parsesep \ClistZero{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{stmt_pragma}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SPragma(\Tidentifier, \overtext{\KleeneStar{\expr}}{args}) &
\end{flalign*}
}

\ASTRuleDef{SPragma}
\begin{mathpar}
\inferrule{
  \buildclist[\Nexpr](\vargs) \astarrow \astversion{\vargs}
}{
  {
  \begin{array}{r}
    \buildstmt(\overname{\Nstmt(\Tpragma, \Tidentifier(\id), \namednode{\vargs}{\ClistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow \\
    \overname{\SPragma(\id, \astversion{\vargs})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{SPragma}
\ExampleDef{Typing a Pragma Statement}
The \pragmastatementterm{} in \listingref{typing-spragma} is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a pragma statement with identifier $\id$ and expression list $\vargs$. that is, $\SPragma(\id, \vargs)$;
  \item for each \Proselistrange{$i$}{$\vargs$}, \Proseannotateexpr{$\tenv$}{$\vargs[i]$}{$(\Ignore, \Ignore, \vxs_i)$}\ProseOrTypeError;
  \item define $\vses$ as the union of $\vxs_i$, for every \Proselistrange{$i$}{$\vargs$};
  \item define $\news$ as the \passstatementterm, that is, $\SPass$
  \item $\newtenv$ is $\tenv$;
  \item define $\vses$ as the union of $\vsess$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  i\in\listrange(\vargs): \annotateexpr(\tenv, \vargs[i]) \typearrow (\Ignore, \Ignore, \vxs_i) \OrTypeError\\\\
  \vses \eqdef \bigcup_{i\in\listrange(\vargs)} \vxs_i
}{
  \annotatestmt(\tenv, \overname{\SPragma(\id, \vargs)}{\vs}) \typearrow (\overname{\SPass}{\news}, \tenv)
}
\end{mathpar}
\CodeSubsection{\SPragmaBegin}{\SPragmaEnd}{../Typing.ml}

\subsection{Semantics\label{sec:PragmaSemantics}}
Pragmas are structures present in the \untypedast{} that are designed to be used
by third-party tools.

To avoid conflicts between different ASL parsers, it is recommended that the pragma's identifier $\Tidentifier(\id)$ be prefixed by the name of the ASL tool that supports that pragma
(e.g. ARM for Arm's internal ASL tools). An ASL language processor that does not recognise a pragma directive should generate a warning for that pragma.

Pragmas are not associated with semantics and are discarded from the \typedast.
