\chapter{Statements\label{chap:Statements}}
Statements update storage elements and determine the flow of control of a subprogram.

Statements are grammatically derived from $\Nstmt$ and represented as ASTs by $\stmt$.

\hypertarget{build-stmt}{}
The function
\[
\buildstmt(\overname{\parsenode{\Nstmt}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a statement parse node $\vparsednode$ into a statement AST node $\vastnode$.

\hypertarget{def-annotatestmt}{}
The function
\[
  \annotatestmt(\overname{\staticenvs}{\tenv} \aslsep \overname{\stmt}{\vs}) \aslto
  (\overname{\stmt}{\news} \times \overname{\staticenvs}{\newtenv} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a statement $\vs$ in an environment $\tenv$, resulting in $\news$ ---
the \typedast\ for $\vs$, which is also known as the \emph{annotated statement} ---
a modified environment $\newtenv$, and \sideeffectsetterm\ $\vses$. \ProseOtherwiseTypeError

The relation
\hypertarget{def-evalstmt}{}
\[
  \evalstmt{\overname{\envs}{\env} \aslsep \overname{\stmt}{\vs}} \;\aslrel\;
  \left(
  \begin{array}{cl}
  \overname{\TReturning}{\Returning((\vvs,\newg), \newenv)} & \cup\\
  \overname{\TContinuing}{\Continuing(\newg,\newenv)} & \cup\\
  \overname{\TThrowing}{\ThrowingConfig} & \cup \\
  \overname{\TDynError}{\DynErrorConfig} &
  \end{array}
  \right)
\]
evaluates a statement $\vs$ in an environment $\env$, resulting in one of four types of configurations
(see more details in \secref{KindsOfSemanticConfigurations}):
\begin{itemize}
  \item returning configurations with values $\vvs$, execution graph $\newg$, and a modified environment $\newenv$;
  \item continuing configurations with an execution graph $\newg$ and modified environment $\newenv$;
  \item throwing configurations;
  \item error configurations.
\end{itemize}

We now define the syntax, abstract syntax, typing, and semantics for the following kinds of statements:
\begin{itemize}
\item Pass statements (see \secref{PassStatements})
\item Assignment statements (see \secref{AssignmentStatements})
\item Setter assignment statements (see \secref{SetterAssignmentStatements})
\item Declaration statements (see \secref{DeclarationStatements})
\item Declaration statements with an elided parameter (see \secref{DeclarationStatementsElidedParameter})
\item Sequencing statements (see \secref{SequencingStatement})
\item Call statements (see \secref{CallStatements})
\item Conditional statements (see \secref{ConditionalStatements})
\item Case statements (see \secref{CaseStatements})
\item Assertion statements (see \secref{AssertionStatements})
\item While statements (see \secref{WhileStatements})
\item Repeat statements (see \secref{RepeatStatements})
\item For statements (see \secref{ForStatements})
\item Throw statements (see \secref{ThrowStatements})
\item Try statements (see \secref{TryStatements})
\item Return statements (see \secref{ReturnStatements})
\item Print statements (see \secref{PrintStatements})
\item Unreachable statements (see \secref{UnreachableStatement})
\item Pragma statements (see \secref{PragmaStatements})
\end{itemize}

\hypertarget{def-passstatementterm}{}
\section{Pass Statements\label{sec:PassStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tpass \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SPass &
\end{flalign*}

\ASTRuleDef{SPass}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tpass, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPass}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SPass}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a pass statement, that is, $\SPass$;
  \item $\news$ is $\vs$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{\annotatestmt(\tenv, \SPass) \typearrow (\SPass, \tenv, \overname{\emptyset}{\vses})}
\end{mathpar}
\CodeSubsection{\SPassBegin}{\SPassEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SPass}
\subsubsection{Example}
In \listingref{semantics-spass}, \texttt{pass;} does nothing.:
\ASLListing{Evaluating a \texttt{pass} statement}{semantics-spass}{\semanticstests/SemanticsRule.SPass.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vs$ is a \passstatementterm, $\SPass$;
\item $\newg$ is the empty graph;
\item $\newenv$ is $\env$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \evalstmt{\env, \SPass} \evalarrow \Continuing(\overname{\emptygraph}{\newg}, \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalSPassBegin}{\EvalSPassEnd}{../Interpreter.ml}

\hypertarget{def-assignmentstatementterm}{}
\section{Assignment Statements\label{sec:AssignmentStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Nlexpr \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SAssign(\lexpr, \expr) &
\end{flalign*}

\ASTRuleDef{SAssign}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\punnode{\Nlexpr}, \Teq, \punnode{\Nexpr}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SAssign(\astof{\vlexpr}, \astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SAssign}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is an assignment \texttt{le = re}, that is, $\SAssign(\vle, \vre)$;
  \item annotating the right-hand-side expression $\vre$ in $\tenv$ yields $(\vtre, \vreone, \vsesre)$\ProseOrTypeError;
  \item annotating the \assignableexpression\ $\vle$ with the type $\vtre$ in $\tenv$ yields \\ $(\vleone, \vsesle)$\ProseOrTypeError;
  \item $\news$ is the assignment \texttt{le1 = re1}, that is, $\SAssign(\vleone, \vreone)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesre$ and $\vsesle$}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vre} \typearrow (\vtre, \vreone, \vsesre) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vle, \vtre} \typearrow (\vleone, \vsesle) \OrTypeError\\\\
  \vses \eqdef \vsesre \cup \vsesle
}{
  \annotatestmt(\tenv, \overname{\SAssign(\vle, \vre)}{\vs}) \typearrow
  (\overname{\SAssign(\vleone, \vreone)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SAssignBegin}{\SAssignEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SAssign}
\subsubsection{Example}
In \listingref{semantics-sassign},
\texttt{x = 3;} binds \texttt{x} to $\nvint(3)$ in the environment where \texttt{x} is bound to
$\nvint(42)$, and $\newenv$ is such that \texttt{x} is bound to $\nvint(3)$.
\ASLListing{Evaluating an assignment}{semantics-sassign}{\semanticstests/SemanticsRule.SAssign.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is an assignment statement, $\SAssign(\vle, \vre)$;
  \item $\vre$ is not a call expression;
  \item evaluating the expression $\vre$ in $\env$ yields
        $\Normal(\vm, \envone)$ (here, $\vm$ is a pair consisting of a value and an execution graph)\ProseOrAbnormal;
  \item evaluating the \assignableexpression\ $\vle$ with $\vm$ in $\envone$,
        as per \chapref{AssignableExpressions}, yields $\Normal(\newg, \newenv)$\ProseOrAbnormal.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \astlabel(\vre) \neq \ECall\\
  \evalexpr{\env, \vre} \evalarrow \Normal(\vm, \envone) \OrAbnormal\\
  \evallexpr{\envone, \vle, \vm} \evalarrow \Normal(\newg, \newenv) \OrAbnormal
}{
  \evalstmt{\env, \SAssign(\vle, \vre)} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSAssignBegin}{\EvalSAssignEnd}{../Interpreter.ml}

\subsubsection{Comments}
This rule covers all assignment statements, except the ones where the
right-hand side expression is a function call, which is covered by
\SemanticsRuleRef{SAssignCall}.  Although
the sequential semantics of both statements is the same,
SemanticsRule.SAssignCall generates a different execution graph.

Notice that this rule first produces a value for the right-hand side expression
and then completes the update via an appropriate rule for evaluating the
\assignableexpression, which in turn handles variables, tuples, bitvectors,
etc.

\SemanticsRuleDef{SAssignCall}
\subsubsection{Example}
In \listingref{assigncallsemantics}, given that the function call \texttt{f(1)} returns a triple of values ---
$\nvint(1)$, $\nvint(2)$, and $\nvint(3)$
(each with its own associated execution graph),
the statement \texttt{(a,b,-) = f(1)} assigns the value $\nvint(1)$ to the mutable variable \texttt{a}
and the value $\nvint(2)$ to the mutable variable~\texttt{b}, and discards $\nvint(3)$.

\ASLListing{Assignment from a call expression.}{assigncallsemantics}{\semanticstests/SemanticsRule.SAssignCall.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ assigns an \assignableexpression\ list from a subprogram call, \\
        $\SAssign(\LEDestructuring(\les),\ECall(\vcall))$;
  \item $\les$ is a list of \assignableexpressions, each of which is either \\ a variable ($\LEVar(\Ignore)$)
        or a discarded variable (\LEDiscard);
  \item evaluating the subprogram call as per \chapref{SubprogramCalls} is
        $\Normal(\vms, \envone)$\ProseOrAbnormal;
  \item assigning each value in $\vms$ to the respective element of the tuple $\les$ is \\
        $\Normal(\vgtwo, \newg)$\ProseOrAbnormal.
\end{itemize}

\subsubsection{Formally}
\hypertarget{def-lexprisvar}{}
We first define the syntactic predicate
\[
  \lexprisvar(\lexpr) \aslto \True
\]
which holds when a left-hand side expression
represents a variable or a discarded left-hand-side expression:
\begin{mathpar}
\inferrule{}{ \lexprisvar(\vle) \evalarrow \astlabel(\vle) \in \{\LEVar, \LEDiscard\}}
\end{mathpar}

We now define the evaluation of assigning from a subprogram call:
\begin{mathpar}
\inferrule{
  \vles \eqdef \vle_{1..k}\\
  i=1..k: \lexprisvar(\vle_i) \evalarrow \True\\
  \evalcall{\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs} \evalarrow \Normal(\vms, \envone) \OrAbnormal\\\\
  \evalmultiassignment(\envone, \vles, \vms) \evalarrow \Normal(\newg, \newenv) \OrAbnormal
}{
  \evalstmt{\env, \SAssign(\LEDestructuring(\les),\ECall(\vcall))} \\
  \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSAssignCallBegin}{\EvalSAssignCallEnd}{../Interpreter.ml}

\hypertarget{def-setterassignmentstatementterm}{}
\section{Setter Assignment Statements\label{sec:SetterAssignmentStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \
   & \Ncall \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Ncall \parsesep \Tdot \parsesep \Tidentifier \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Ncall \parsesep \Tdot \parsesep \Tlbracket \parsesep \Clisttwo{{\Tidentifier}} \parsesep \Trbracket \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
\end{flalign*}

\ASTRuleDef{MakeSetter}
\hypertarget{def-makesetter}{}
The helper function
\[
\makesetter(
  \overname{\call}{\vcall} \aslsep
  \overname{\expr}{\varg}) \aslto \overname{\call}{\vcallp}
\]
constructs a setter call $\vcallp$ using a base call $\vcall$ and right-hand side $\varg$.

\begin{mathpar}
\inferrule{}{
  \makesetter(\vcall, \varg) \aslto
    \overname{\left\{
      \begin{array}{rcl}
        \callname &:& \vcall.\callname,\\
        \callparams &:& \vcall.\callparams,\\
        \callargs &:& [\varg]\concat\vcall.\callargs,\\
        \callcalltype &:& \STSetter
      \end{array}
    \right\}}{\vcallp}
}
\end{mathpar}

\ASTRuleDef{DesugarSetter}
\hypertarget{def-desugarsetter}{}
The helper function
\[
\desugarsetter(
  \overname{\call}{\vcall} \aslsep
  \overname{\identifier^*}{\fields} \aslsep
  \overname{\expr}{\rhs}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from an assignment of expression $\rhs$ to a setter invocation $\vcall$$\name$ with field accesses $\fields$.

\begin{mathpar}
\inferrule[empty]{
  \fields \eqname \emptylist \\
  \makesetter(\vcall, \rhs) \aslto \vcallp
}{
  \desugarsetter(\vcall, \fields, \rhs)
  \astarrow
  \SCall(\vcallp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[singleton]{
  \fields \eqname [\field] \\
  \vx \in \Identifiers \text{ is fresh} \\\\
  \setcalltype(\vcall, \STGetter) \aslto \texttt{getter} \\\\
  \texttt{read} \eqdef \SDecl(\LDKVar, \LDIVar(\vx), \None, \langle\texttt{getter}\rangle) \\\\
  \texttt{modify} \eqdef \SAssign(\LESetField(\LEVar(\vx), \field), \rhs) \\\\
  \makesetter(\vcall, \EVar(\vx)) \aslto \texttt{setter}
}{
  \desugarsetter(\vcall, \fields, \rhs)
  \astarrow
  \SSeq (\SSeq(\texttt{read}, \texttt{modify}), \SCall(\texttt{setter}))
}
\end{mathpar}

\begin{mathpar}
\inferrule[multiple]{
  \listlen{\fields} > 1 \\
  \vx \in \Identifiers \text{ is fresh} \\\\
  \setcalltype(\vcall, \STGetter) \aslto \texttt{getter} \\\\
  \texttt{read} \eqdef \SDecl(\LDKVar, \LDIVar(\vx), \None, \langle\texttt{getter}\rangle) \\\\
  \texttt{modify} \eqdef \SAssign(\LESetFields(\LEVar(\vx), \fields), \rhs) \\\\
  \makesetter(\vcall, \EVar(\vx)) \aslto \texttt{setter}
}{
  \desugarsetter(\vcall, \fields, \rhs)
  \astarrow
  \SSeq (\SSeq(\texttt{read}, \texttt{modify}), \SCall(\texttt{setter}))
}
\end{mathpar}

\ASTRuleDef{SetterAssign}
\begin{mathpar}
\inferrule{
  \desugarsetter(\astof{\vcall}, \emptylist, \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\call}, \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \desugarsetter(\astof{\vcall}, [\vfield], \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\call}, \Tdot,
    \Tidentifier(\vfield), \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildclist[\buildidentity](\vfields) \astarrow \vfieldasts \\
  \desugarsetter(\astof{\vcall}, \vfieldasts, \astof{\vexpr}) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\punnode{\call}, \Tdot,
    \Tlbracket, \namednode{\vfields}{\Clisttwo{\Tidentifier}}, \Trbracket, \Teq, \punnode{\Nexpr}, \Tsemicolon
  )}{\vparsednode})
  \astarrow \vastnode
}
\end{mathpar}

\subsection{Typing and semantics}
As given by applying the relevant rules to the desugared AST.

\hypertarget{def-declarationstatementterm}{}
\section{Declaration Statements\label{sec:DeclarationStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \option{\Nasty} \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Ndeclitem \parsesep \option{\Nasty} \parsesep \option{\Teq \parsesep \Nexpr} \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Clisttwo{\Tidentifier} \parsesep \Nasty \parsesep \Tsemicolon &\\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SDecl(\localdeclkeyword, \localdeclitem, \ty?, \expr?)
\end{flalign*}

\ASTRuleDef{SDecl}
\begin{mathpar}
\inferrule[let\_constant]{
  \buildoption[\buildasty](\vt) \astarrow \astversion{\vt}
}{
  {
  \begin{array}{r}
  \buildstmt(\overname{\Nstmt(\Nlocaldeclkeyword, \Ndeclitem, \namednode{\vt}{\option{\Nasty}}, \Teq, \punnode{\Nexpr}, \Tsemicolon)}{\vparsednode})
  \astarrow\\
  \overname{\SDecl(\astof{\vlocaldeclkeyword}, \astof{\vdeclitem}, \astversion{\vt}, \langle\astof{\vexpr}\rangle)}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[var]{
  \buildoption[\buildasty](\vt) \astarrow \astversion{\vt} \\
  \buildoption[\buildexpr](\ve) \astarrow \astversion{\ve}
}{
  {
    \begin{array}{r}
  \buildstmt(\overname{\Nstmt(\Tvar, \Ndeclitem, \namednode{\vt}{\option{\Nasty}}, \namednode{\ve}{\option{\Teq, \Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow \\
  \overname{\SDecl(\LDKVar, \astof{\vdeclitem}, \astversion{\vt}, \astversion{\ve})}{\vastnode}
\end{array}
}
}
\end{mathpar}

\begin{mathpar}
\inferrule[multi\_var]{
  \buildclist[\buildidentity](\vids) \astarrow \astversion{\vids}\\
  \buildasty(\vt) \astarrow \astversion{\vt} \\
  \vstmts \eqdef [\vx\in\astversion{\vids}: \SDecl(\LDKVar, \vx, \astversion{\vt}, \None)]\\
  \stmtfromlist(\vstmts) \astarrow \vastnode
}{
  \buildstmt(\overname{\Nstmt(\Tvar, \namednode{\vids}{\Clisttwo{\Tidentifier}}, \namednode{\vt}{\Nasty}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \vastnode
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SDecl}
\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\vs$ is a declaration with an initializing expression $\ve$,
          that is, $\SDecl(\ldk, \ldi, \tyopt, \langle\ve\rangle)$;
    \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte,\vep, \vsese)$\ProseOrTypeError;
    \item applying $\annotatelocaldecltypeannot$ to the environment $\tenv$, type annotation $\tyopt$, type $\vte$, local declaration keyword $\ldk$, expression $\vep$, and local declaration item $\ldi$ yields $(\tenvone, \tyoptp, \vsesldi)$\ProseOrTypeError;
    \item \Proseeqdef{$\vses$}{the union of $\vsese$ and $\vsesldi$};
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply (\textsc{constant}):
      \begin{itemize}
        \item $\ldk$ indicates a local constant declaration, that is, $\LDKConstant$;
        \item checking that all \timeframesterm\ in $\vsese$ are before \timeframeconstant\ yields $\True$\ProseOrTypeError;
        \item symbolically simplifying $\ve$ in $\tenvone$ yields the literal $\vv$\ProseOrTypeError;
        \item declaring a local constant with literal $\vv$ and local declaration item $\ldi$ in $\tenvone$ yields $\newtenv$;
        \item $\news$ is a declaration with $\ldk$, $\ldi$, type annotation $\tyoptp$, and an expression $\vep$.
      \end{itemize}

      \item All of the following apply (\textsc{non\_constant}):
      \begin{itemize}
        \item $\ldk$ indicates that this is not a local constant declaration, that is, $\ldk\neq\LDKConstant$;
        \item $\news$ is a declaration with $\ldk$, $\ldi$, type annotation $\tyoptp$, and an expression $\vep$;
        \item $\newtenv$ is $\tenvone$.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \item All of the following apply (\textsc{none}):
  \begin{itemize}
  \item $\vs$ is a local declaration statement with a variable keyword and no initializing expression,
        that is, $\SDecl(\LDKVar, \ldi, \tyopt, \None)$ (local declarations of \texttt{let} variables and constants require
        an initializing expression, otherwise they are rejected by an ASL parser);
  \item $\tyopt$ is $\langle\vt\rangle$\ProseOrTypeError;
  \item annotating $\vt$ in $\tenv$ yields $(\vtp, \vses)$\ProseOrTypeError;
  \item applying $\basevalue$ to $\vtp$ in $\tenv$ yields $\veinit$\ProseOrTypeError;
  \item annotating the local declaration item $\ldi$ with the type $\vtp$ and local declaration keyword $\LDIVar$
        yields $\newtenv$\ProseOrTypeError;
  \item define $\news$ as local declaration statement with variable keyword, local declaration item $\ldi$, type annotation $\vtp$, and initializing expression $\veinit$, that is, $\SDecl(\LDKVar, \ldi, \langle\veinit\rangle)$.
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[constant]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep, \vsese) \OrTypeError\\\\
  \annotatelocaldecltypeannot(\tenv, \tyopt, \vte, \ldk, \vep, \ldi) \typearrow (\tenvone, \tyoptp, \vsesldi) \OrTypeError\\\\
  \vses \eqdef \vsese \cup \vsesldi\\\\
  \commonprefixline\\\\
  \ldk = \LDKConstant\\
  \checktrans{\sesisbefore(\vsese, \timeframeconstant)}{\SideEffectViolation} \typearrow \True \OrTypeError\\\\
  \staticeval(\tenvone, \ve) \typearrow \vv \OrTypeError\\\\
  \declarelocalconstant(\tenvone, \vv, \ldi) \typearrow \newtenv\\
  \news \eqdef \SDecl(\LDKConstant, \ldi, \tyoptp, \langle\vep\rangle)
}{
  \annotatestmt(\tenv, \overname{\SDecl(\ldk, \ldi, \tyopt, \langle\ve\rangle)}{\vs}) \typearrow (\news, \newtenv, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_constant]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep, \vsese) \OrTypeError\\\\
  \annotatelocaldecltypeannot(\tenv, \tyopt, \vte, \ldk, \vep, \ldi) \typearrow (\tenvone, \tyoptp, \vsesldi) \OrTypeError\\\\
  \vses \eqdef \vsese \cup \vsesldi\\\\
  \commonprefixline\\\\
  \ldk \neq \LDKConstant\\
  \news \eqdef \SDecl(\ldk, \ldi, \tyoptp, \langle\vep\rangle)
}{
  \annotatestmt(\tenv, \overname{\SDecl(\ldk, \ldi, \tyopt, \langle\ve\rangle)}{\vs}) \typearrow (\news, \overname{\tenvone}{\newtenv}, \vses)
}
\end{mathpar}
\lrmcomment{This is related to \identr{YSPM}.}

\begin{mathpar}
\inferrule[none]{
  \checktrans{\tyopt = \langle\Ignore\rangle}{\TypeErrorVal{\BadDeclaration}} \typearrow \True \OrTypeError \\
  \tyopt \eqname \langle\vt\rangle \\
  \annotatetype{\tenv, \vt} \typearrow (\vtp, \vses) \OrTypeError\\\\
  \basevalue(\tenv, \vtp) \typearrow \veinit \OrTypeError\\\\
  \annotatelocaldeclitem{\tenv, \vtp, \LDKVar, \None, \ldip} \typearrow \newtenv \OrTypeError \\
  \news \eqdef \SDecl(\LDKVar, \ldi, \langle\vtp\rangle, \langle\veinit\rangle)
}{
  \annotatestmt(\tenv, \overname{\SDecl(\LDKVar, \ldi, \tyopt, \None)}{\vs}) \typearrow (\news, \newtenv, \vses)
}
\end{mathpar}
\CodeSubsection{\SDeclegin}{\SDeclEnd}{../Typing.ml}

\TypingRuleDef{DeclareLocalConstant}
\hypertarget{def-declarelocalconstant}{}
The helper function
\[
\declarelocalconstant(\overname{\staticenvs}{\tenv} \aslsep \overname{\literal}{\vv} \aslsep \overname{\localdeclitem}{\ldi})
\typearrow \overname{\staticenvs}{\newtenv}
\]
adds the literal $\vv$ with the local declaration item $\ldi$ as a constant to the local component of the static environment $\tenv$,
yielding the modified static environment $\newtenv$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{var}):
  \begin{itemize}
    \item $\ldi$ corresponds to a variable declaration for $\vx$, that is, $\LDIVar(\vx)$;
    \item applying $\addlocalconstant$ to $\vx$ and $\vv$ in $\tenv$ yields $\newtenv$.
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\ldi$ corresponds to a tuple declaration, that is, $\LDIVar(\Ignore)$;
    \item this case is not yet implemented.
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[var]{
  \addlocalconstant(\tenv, \vx, \vv) \typearrow \newtenv
}{
  \declarelocalconstant(\tenv, \vv, \overname{\LDIVar(\vx)}{\ldi}) \typearrow \newtenv
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{}{
  \declarelocalconstant(\tenv, \vv, \overname{\LDITuple(\Ignore)}{\ldi}) \typearrow \tododefine{not implemented yet}
}
\end{mathpar}
\CodeSubsection{\DeclareLocalConstantBegin}{\DeclareLocalConstantEnd}{../Typing.ml}

\TypingRuleDef{AnnotateLocalDeclTypeAnnot}
\hypertarget{def-annotatelocaldecltypeannot}{}
The helper function
\[
\begin{array}{r}
  \annotatelocaldecltypeannot
  \left(
  \begin{array}{c}
    \overname{\staticenvs}{\tenv} \aslsep \\
    \overname{\langle\ty\rangle}{\tyopt} \aslsep \\
    \overname{\ty}{\vte} \aslsep \\
    \overname{\localdeclkeyword}{\ldk} \aslsep \\
    \overname{\expr}{\vep} \aslsep\\
    \overname{\localdeclitem}{\ldi}
  \end{array}
  \right)
  \typearrow \\
  \left(
  \begin{array}{cl}
    \left(\overname{\staticenvs}{\newtenv} \aslsep \overname{\langle\ty\rangle}{\tyoptp} \aslsep \overname{\TSideEffectSet}{\vses}\right)
    & \cup \\
    \overname{\TTypeError}{\TypeErrorConfig} &
  \end{array}
  \right)
\end{array}
\]
annotates the type annotation $\tyopt$ in the static environment $\tenv$ within the context of a local declaration with keyword $\ldk$, item $\ldi$, and initializing expression $\vep$ with type $\vte$.
It yields the modified static environment $\newtenv$, the annotated type annotation $\tyoptp$, and the inferred \sideeffectsetterm{} $\vses$.
\ProseOtherwiseTypeError

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\tyopt$ is $\None$;
    \item $\newtenv$ is the result of $\annotatelocaldeclitem{\tenv, \vte, \ldk, \langle\vep\rangle, \ldi}$\ProseOrTypeError;
    \item $\tyoptp$ is $\tyopt$;
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\tyopt$ is $\langle\vt\rangle$;
    \item determining the \structure{} of $\vte$ in $\tenv$ yields $\vtep$\ProseOrTypeError;
    \item propagating integer constraints from $\vtep$ to $\vt$ using $\inheritintegerconstraints$ yields $\vtp$\ProseOrTypeError;
    \item annotating the type $\vtp$ in $\tenv$ yields $(\vtpp, \vses)$\ProseOrTypeError;
  \item determining whether $\vtpp$ can be initialized with $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the local declaration item $\ldi$ with the local declaration keyword $\ldk$, given
  the expression $\vep$, in the environment $\tenv$, yields $\newtenv$;
  \item $\tyoptp$ is $\langle\vtpp\rangle$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[none]{
  \annotatelocaldeclitem(\tenv, \vte, \ldk, \langle\vep\rangle, \ldi) \typearrow \newtenv \OrTypeError
}{
  \annotatelocaldecltypeannot(\tenv, \None, \vte, \ldk, \vep, \ldi) \typearrow (\newtenv, \overname{\None}{\tyoptp}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \tstruct(\tenv, \vte) \typearrow \vtep \OrTypeError \\
  \inheritintegerconstraints(\vt, \vtep) \typearrow \vtp \OrTypeError \\
  \annotatetype{\tenv, \vtp} \typearrow (\vtpp, \vses) \OrTypeError\\\\
  \checkcanbeinitializedwith(\tenv, \vtpp, \vte) \typearrow \True \OrTypeError\\\\
  \annotatelocaldeclitem(\tenv, \vtpp, \ldk, \langle \vep \rangle, \ldip) \typearrow \newtenv \OrTypeError
}{
  \annotatelocaldecltypeannot(\tenv, \langle\vt\rangle, \vte, \ldk, \vep, \ldi) \typearrow (\newtenv, \overname{\langle\vtpp\rangle}{\tyoptp}, \vses)
}
\end{mathpar}

\TypingRuleDef{InheritIntegerConstraints}
\hypertarget{def-inheritintegerconstraints}{}
The helper function
\[
\inheritintegerconstraints(\overname{\ty}{\lhs} \aslsep \overname{\ty}{\rhs})
\typearrow \lhsp \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
propagates integer constraints from the right-hand side type $\rhs$ to the left-hand side type annotation $\lhs$.
In particular, each occurence of \pendingconstrainedintegertype{} on the left-hand side should inherit constraints from a corresponding \wellconstrainedintegertype{} on the right-hand side.
If the corresponding right-hand side type is not a \wellconstrainedintegertype{} (including if it is an \unconstrainedintegertype{}), the result is a type error.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{int}):
  \begin{itemize}
    \item $\lhs$ is a \pendingconstrainedintegertype{};
    \item $\rhs$ is a \wellconstrainedintegertype{}\ProseOrTypeError;
    \item $\lhsp$ is $\rhs$.
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\lhs$ is a tuple of types \texttt{lhs\_tys};
    \item $\rhs$ is a tuple of types \texttt{rhs\_tys};
    \item the lengths of \texttt{lhs\_tys} and \texttt{rhs\_tys} are equal\ProseOrTypeError;
    \item define \texttt{lhs\_tys'} by applying $\inheritintegerconstraints$ to each element of \texttt{lhs\_tys} and \texttt{rhs\_tys}\ProseOrTypeError;
    \item $\lhsp$ is $\TTuple(\texttt{lhs\_tys'})$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\lhs$ is not a \pendingconstrainedintegertype{}, or one of $\lhs$ and $\rhs$ is not a tuple type;
    \item $\lhsp$ is $\lhs$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[int]{
  \rhs \eqname \TInt(\wellconstrained(\Ignore)) \OrTypeError
}{
  \inheritintegerconstraints(\overname{\TInt(\pendingconstrained)}{\lhs}, \rhs) \typearrow \overname{\rhs}{\lhsp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \lhs \eqname \TTuple(\texttt{lhs\_tys}) \\
  \rhs \eqname \TTuple(\texttt{rhs\_tys}) \\\\
  \equallength(\texttt{lhs\_tys}, \texttt{rhs\_tys}) \typearrow \True \OrTypeError \\
  \vi \in \listrange(\lhs): \inheritintegerconstraints(\texttt{lhs\_tys}_i, \texttt{rhs\_tys}_i) \typearrow \texttt{lhs\_tys'}_i \OrTypeError \\
}{
  \inheritintegerconstraints(\lhs, \rhs) \typearrow \overname{\TTuple(\texttt{lhs\_tys'})}{\lhsp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \lhs \neq \TInt(\pendingconstrained) \;\lor\; \astlabel(\lhs) \neq \TTuple \;\lor\; \astlabel(\rhs) \neq \TTuple
}{
  \inheritintegerconstraints(\lhs, \rhs) \typearrow \overname{\lhs}{\lhsp}
}
\end{mathpar}

\TypingRuleDef{CheckCanBeInitializedWith}
\hypertarget{def-checkcanbeinitializedwith}{}
The helper function
\[
\checkcanbeinitializedwith(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vs} \aslsep \overname{\ty}{\vt})
\typearrow \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether an expression of type $\vs$ can be used to initialize a storage element of type $\vt$ in the static environment
$\tenv$.
If the answer if $\False$, the result is a type error.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item testing whether $\vt$ \typesatisfies\ $\vs$ in $\tenv$ yields $\True$;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item testing whether $\vt$ \typesatisfies\ $\vs$ in $\tenv$ yields $\False$;
    \item the result is a type error indicating that an expression of type $\vs$ cannot
          be used to initialize a storage element of type $\vt$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}{
  \checkcanbeinitializedwith(\tenv, \vs, \vt) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \typesat(\tenv, \vt, \vs) \typearrow \False
}{
  \checkcanbeinitializedwith(\tenv, \vs, \vt) \typearrow \TypeErrorVal{\TypeSatisfactionFailure}
}
\end{mathpar}
\lrmcomment{This is related to \identr{ZCVD} and \identr{LXQZ}.}


\subsection{Semantics}
\SemanticsRuleDef{SDeclSome}
\subsubsection{Example (Declaration With an Initializing Value)}
In \listingref{semantics-sdeclsome},
\texttt{let x = 3;} binds \texttt{x} to $\nvint(3)$ in the empty environment.
\ASLListing{Evaluating a declaration with a given initial value}{semantics-sdeclsome}{\semanticstests/SemanticsRule.SDeclSome.asl}

\subsubsection{Example (Declaration Without an Initializing Value)}
In \listingref{semantics-sdeclnone},
\texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.
\ASLListing{Evaluating a declaration without a given initial value}{semantics-sdeclnone}{\semanticstests/SemanticsRule.SDeclNone.asl}

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\vs$ is a declaration with an initial value,
    $\SDecl(\Ignore, \ldi, \Ignore, \langle\ve\rangle)$;
    \item evaluating $\ve$ in $\env$ is $\Normal(\vm, \envone)$\ProseOrAbnormal;
    \item evaluating the local declaration $\ldi$ with $\vm$ as the initializing
    value in $\envone$ as per \chapref{LocalStorageDeclarations} is $\Normal(\newg, \newenv)$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
  \end{itemize}

  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vs$ is a declaration without an initial value, $\SDecl(\Ignore, \ldi, \Ignore, \None)$;
    \item the result is a dynamic error.
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[some]{
  \evalexpr{\env, \ve} \evalarrow \Normal(\vm, \envone) \OrAbnormal\\
  \evallocaldecl{\envone, \ldi, \vm} \evalarrow \Normal(\newg, \newenv)\\
}{
  \evalstmt{\env, \SDecl(\Ignore, \ldi, \Ignore, \langle\ve\rangle)} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[none]{}{
  \evalstmt{\env, \SDecl(\Ignore, \ldi, \Ignore, \None)} \evalarrow \DynamicErrorVal{UninitialisedDecl}
}
\end{mathpar}
\CodeSubsection{\EvalSDeclBegin}{\EvalSDeclEnd}{../Interpreter.ml}

\hypertarget{def-declarationstatementelidedparameterterm}{}
\section{Declaration statements with an elided parameter \label{sec:DeclarationStatementsElidedParameter}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \
   & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \Nasty \parsesep \Teq \\
   & \wrappedline\ \Nelidedparamcall \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Ndeclitem \parsesep \Nasty \parsesep \Teq \parsesep \Nelidedparamcall \parsesep \Tsemicolon &\\
\end{flalign*}

\begin{flalign*}
\Nelidedparamcall \derives \
     & \Tidentifier \parsesep \Tlbrace \parsesep \Trbrace \parsesep \PlistZero{\Nexpr} &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Tcomma \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \Tcomma \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace \parsesep \PlistZero{\Nexpr}&
\end{flalign*}

\ASTRuleDef{ElidedParamCall}
\hypertarget{build-elided-param-call}{}
The helper function $\buildelidedparamcall$ builds a $\call$ from a parsed $\Nelidedparamcall$.

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \vargs))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
      \buildelidedparamcall(\Nelidedparamcall \\
        \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}}))
      \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlbrace, \vparams, \Trbrace))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
      \buildelidedparamcall(\Nelidedparamcall \\
        \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Tcomma, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace))
        \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildcall(\Ncall(\Tidentifier(\id), \Tlbrace, \vparams, \Trbrace, \vargs))
  \astarrow \vastnode
}{
  {
    \begin{array}{l}
    \buildelidedparamcall (\Nelidedparamcall \\
      \qquad \qquad (\Tidentifier(\id), \Tlbrace, \Tcomma, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}}))
      \astarrow \vastnode
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarElidedParameter}
\hypertarget{def-desugarelidedparameter}{}
The helper function
\[
\desugarelidedparameter(
  \overname{\localdeclkeyword}{\ldk} \aslsep
  \overname{\localdeclitem}{\ldi} \aslsep
  \overname{\ty}{\vt} \aslsep
  \overname{\call}{\vcall})
\aslto \overname{\stmt}{\news}
\cup\ \{\ParseErrorConfig\}
\]
builds a declaration statement $\news$ from an assignment of the call $\vcall$ to the left-hand side $\ldi$ with keyword $\ldk$ and type annotation $\vt$, where the call has an elided parameter.
Otherwise, the result is a parse error.

\begin{mathpar}
\inferrule{
  \checktrans{\vt = \TBits(\Ignore, \Ignore)}{\ParseErrorConfig} \typearrow \True \;\terminateas \ParseErrorConfig \\
  \vt \eqname \TBits(\ve, \Ignore) \\
  \vcallp \eqdef \vcall[\callparams\mapsto [\ve] \concat \vcall.\callparams ]
}{
  \desugarelidedparameter(\ldk, \ldi, \vt, \vcall)
  \astarrow
  \SDecl(\ldk, \ldi, \langle\vt\rangle, \ECall(\vcallp))
}
\end{mathpar}

\ASTRuleDef{ElidedParamDecl}
\begin{mathpar}
\inferrule{
  \buildelidedparamcall (\vcall) \astarrow \astversion{\vcall} \\
  {
    \begin{array}{r}
      \desugarelidedparameter(\astof{\vlocaldeclkeyword}, \astof{\vdeclitem}, \astof{\vasty}, \astversion{\vcall}) \astarrow \\
      \vastnode
    \end{array}
  }
}{
  {
    \buildstmt\left(
      \Nstmt\left(
        \begin{array}{l}
          \punnode{\Nlocaldeclkeyword}, \\
          \wrappedline\ \punnode{\Ndeclitem}, \punnode{\Nasty}, \Teq, \\
          \wrappedline\ \namednode{\vcall}{\Nelidedparamcall}, \Tsemicolon
        \end{array}
      \right)
    \right) \astarrow \vastnode
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildelidedparamcall (\vcall) \astarrow \astversion{\vcall} \\
  \desugarelidedparameter(\LDKVar, \astof{\vdeclitem}, \astof{\vasty}, \astversion{\vcall}) \astarrow \vastnode
}{
  {
    \begin{array}{r}
    \buildstmt(\Nstmt(\Tvar, \punnode{\Ndeclitem}, \punnode{\Nasty}, \Teq, \namednode{\vcall}{\Nelidedparamcall}, \Tsemicolon)) \astarrow\\
     \vastnode
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing and semantics}
As given by the applying the relevant rules to the desugared AST (see \secref{DeclarationStatements}).

\hypertarget{def-sequencestatementterm}{}
\section{Sequencing Statements\label{sec:SequencingStatement}}
\subsection{Syntax}
\begin{flalign*}
\Nstmtlist \derives \ & \ListOne{\Nstmt} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SSeq(\stmt, \stmt) &
\end{flalign*}

\ASTRuleDef{StmtList}
\hypertarget{build-stmtlist}{}
The function
\[
  \buildstmtlist(\overname{\parsenode{\Nstmtlist}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildlist[\Nstmt](\vstmts) \astarrow \vstmtlist\\
  \stmtfromlist(\vstmtlist) \astarrow \vastnode
}{
  \buildstmtlist(\Nstmtlist(\namednode{\vstmts}{\ListOne{\Nstmt}})) \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{StmtFromList}
\hypertarget{def-stmtfromlist}{}
The helper function
\[
\stmtfromlist(\overname{\stmt^*}{\vstmts}) \aslto \overname{\stmt}{\news}
\]
builds a statement $\news$ from a possibly-empty list of statements $\vstmts$.

\begin{mathpar}
\inferrule[empty]{
}{
  \stmtfromlist(\overname{\emptylist}{\vstmts}) \astarrow \overname{\SPass}{\news}
}
\and
\inferrule[non\_empty]{
  \stmtfromlist(\vstmtsone) \astarrow \vsone\\
  \sequencestmts(\vs, \vsone) \astarrow \news
}{
  \stmtfromlist(\overname{[\vs] \concat \vstmtsone}{\vstmts}) \astarrow \news
}
\end{mathpar}

\ASTRuleDef{SequenceStmts}
\hypertarget{def-sequencestmts}{}
The helper function
\[
\sequencestmts(\overname{\stmt}{\vsone}, \overname{\stmt}{\vstwo}) \aslto \overname{\stmt}{\news}
\]
Combines the statement $\vsone$ with $\vstwo$ into the statement $\news$, while filtering away
instances of $\SPass$.

\begin{mathpar}
\inferrule[s1\_spass]{}{
  \sequencestmts(\overname{\SPass}{\vsone}, \vstwo) \astarrow \overname{\vstwo}{\news}
}
\and
\inferrule[s2\_spass]{
  \vsone \neq \SPass
}{
  \sequencestmts(\vsone, \overname{\SPass}{\vstwo}) \astarrow \overname{\vsone}{\news}
}
\and
\inferrule[no\_spass]{
  \vsone \neq \SPass\\
  \vstwo \neq \SPass
}{
  \sequencestmts(\vsone, \vstwo) \astarrow \overname{\SSeq(\vsone, \vstwo)}{\news}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SSeq}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is the AST node for the sequence of statements $\vsone$ and $\vstwo$, that is, $\SSeq(\vsone, \vstwo)$;
  \item annotating $\vsone$ in $\tenv$ yields $(\newsone, \tenvone, \vsesone)$\ProseOrTypeError;
  \item annotating $\vstwo$ in $\tenvone$ yields $(\newstwo, \newtenv, \vsestwo)$\ProseOrTypeError;
  \item $\news$ is the AST node for the sequence of statements $\newsone$ and $\newstwo$, that is, $\SSeq(\newsone, \newstwo)$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesone$ and $\vsestwo$}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatestmt(\tenv, \vs1) \typearrow (\newsone, \tenvone, \vsesone) \OrTypeError\\\\
  \annotatestmt(\tenvone, \vs2) \typearrow (\newstwo, \newtenv, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotatestmt(\tenv, \overname{\SSeq(\vsone, \vstwo)}{\vs}) \typearrow (\overname{\SSeq(\newsone, \newstwo)}{\news}, \newtenv, \vses)
}
\end{mathpar}
\CodeSubsection{\SSeqBegin}{\SSeqEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SSeq}
\subsubsection{Example}
In \listingref{semantics-sseq},
the evaluation of \texttt{let x = 3; let y = x + 1} first evaluates \texttt{let x = 3} and only then
evaluates \texttt{let y = x + 1}.
\ASLListing{Evaluating a sequence of statements}{semantics-sseq}{\semanticstests/SemanticsRule.SSeq.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \emph{sequencing statement} \texttt{s1; s2}, that is, $\SSeq(\vsone, \vstwo)$;
  \item evaluating $\vsone$ in $\env$ is either $\Continuing(\vgone, \envone)$ in which case
  the evaluation continues,
  or a returning configuration ($\Returning((\vvs, \newg), \newenv)$)\ProseOrAbnormal;
  \item evaluating $\vstwo$ in $\envone$ yields a non-abnormal configuration \\
        (either $\Normal$ or $\Continuing$) $C$\ProseOrAbnormal;
  \item $\newg$ is the ordered composition of $\vgone$ and the execution graph of $C$ with the
  $\aslpo$ edge;
  \item $D$ is the configuration $C$ with the execution graph component replaced with $\newg$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalstmt{\env, \vsone} \evalarrow \Continuing(\vgone, \envone) \terminateas \ReturningConfig,\ThrowingConfig,\DynErrorConfig\\
    \evalstmt{\envone, \vstwo} \evalarrow C \OrAbnormal\\
    \newg \eqdef \ordered{\vgone}{\aslpo}{\graphof{C}}\\
    D \eqdef \withgraph{C}{\newg}
  }
  {
    \evalstmt{\env, \SSeq(\vsone, \vstwo)} \evalarrow D
  }
\end{mathpar}
\CodeSubsection{\EvalSSeqBegin}{\EvalSSeqEnd}{../Interpreter.ml}

\hypertarget{def-callstatementterm}{}
\section{Call Statements\label{sec:CallStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Ncall \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SCall(\call) &
\end{flalign*}

\ASTRuleDef{SCall}
\begin{mathpar}
\inferrule{
  \buildcall(\vcall) \astarrow \astversion{\vcall} \\
  \setcalltype(\astversion{\vcall}) \aslto \vcallp
}{
  \buildstmt(
  \overname{\Nstmt(\namednode{\vcall}{\Ncall}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SCall(\vcallp)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SCall}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a call to a subprogram, that is, $\SCall(\vcall)$;
  \item annotating the subprogram call $\vcall$ as per \chapref{SubprogramCalls}
        yields $(\vcallp, \None, \vses)$\ProseOrTypeError;
  \item $\news$ is the call using $\vcallp$, that is, $\SCall(\vcallp)$;
  \item $\newtenv$ is $\tenv$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{r}
      \annotatecall(\vcall) \typearrow (\vcallp, \None, \vses) \OrTypeError
    \end{array}
  }
}{
  {
    \begin{array}{r}
  \annotatestmt(\tenv, \overname{\SCall(\vcall)}{\vs}) \typearrow
  (\overname{\SCall(\vcallp)}{\news}, \tenv, \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SCallBegin}{\SCallEnd}{../Typing.ml}
\lrmcomment{This is related to \identd{VXKM}.}

\subsection{Semantics}
\SemanticsRuleDef{SCall}
\subsubsection{Example}
In \listingref{semantics-scall},
\verb|Zeros{3}| evaluates to \texttt{'000'}.
\ASLListing{Evaluating a call statement}{semantics-scall}{\semanticstests/SemanticsRule.SCall.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a call statement, $\SCall(\vcall)$;
  \item evaluating the subprogram call as per \chapref{SubprogramCalls} is
  \\ $\Normal(\newg, \newenv)$\ProseOrAbnormal;
  \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalcall{\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs} \evalarrow \Normal(\newg, \newenv) \OrAbnormal
}{
  \evalstmt{\env, \overname{\SCall(\vcall)}{\vs}} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSCallBegin}{\EvalSCallEnd}{../Interpreter.ml}
% \lrmcomment{This is related to \identd{KCYT}:}

\hypertarget{def-conditionalstatementterm}{}
\section{Conditional Statements\label{sec:ConditionalStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nstmtlist \parsesep \Nselse \parsesep \Tend \parsesep \Tsemicolon &\\
\Nselse \derives\ & \Telseif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nstmtlist \parsesep \Nselse &\\
        |\ & \Telse \parsesep \Nstmtlist &\\
        |\ & \emptysentence &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SCond(\expr, \stmt, \stmt)
\end{flalign*}

\ASTRuleDef{SCond}
\begin{mathpar}
\inferrule{}{
  {
    \begin{array}{r}
  \buildstmt(\overname{\Nstmt(\Tif, \punnode{\Nexpr}, \Tthen, \punnode{\Nstmtlist}, \punnode{\Nselse}, \Tend, \Tsemicolon)}{\vparsednode})
  \astarrow \\
  \overname{\SCond(\astof{\vexpr}, \astof{\vstmtlist}, \astof{\velse})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{SElse}
\hypertarget{build-selse}{}
The function
\[
  \buildselse(\overname{\parsenode{\Nselse}}{\vparsednode}) \;\aslto\; \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[elseif]{}{
  {
    \begin{array}{r}
  \buildselse(\Nselse(\Telseif, \Nexpr, \Twhen, \Nstmtlist, \Nselse)) \astarrow \\
  \overname{\SCond(\astof{\vexpr}, \astof{\vstmtlist}, \astof{\vselse})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pass]{}{
  \buildselse(\Nselse(\emptysentence)) \astarrow \overname{\SPass}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[else]{}{
  \buildselse(\Nselse(\Telse, \punnode{\Nstmtlist})) \astarrow \overname{\astof{\vstmtlist}}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SCond}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a condition $\ve$ with the statements $\vsone$ and $\vstwo$, that is, $\SCond(\ve, \vsone, \vstwo)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tcond, \econd, \vsescond)$\ProseOrTypeError;
  \item checking that $\tcond$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
  \item annotating the statement $\vsone$ in $\tenv$ yields $(\vsonep, \vsesone)$\ProseOrTypeError;
  \item annotating the statement $\vstwo$ in $\tenv$ yields $(\vstwop, \vsestwo)$\ProseOrTypeError;
  \item $\news$ is the condition $\econd$ with the statements $\vsonep$ and $\vstwop$, that is, \\ $\SCond(\econd, \vsonep, \vstwop)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsescond$, $\vsesone$, and $\vsestwo$}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\tcond, \econd, \vsescond) \OrTypeError\\\\
  \checktypesat(\tenv, \tcond, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock{\tenv, \vsone} \typearrow (\vsonep, \vsesone) \OrTypeError\\\\
  \annotateblock{\tenv, \vstwo} \typearrow (\vstwop, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsescond \cup \vsesone \cup \vsestwo
}{
  \annotatestmt(\tenv, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \typearrow
  (\overname{\SCond(\econd, \vsonep, \vstwop)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\CodeSubsection{\SCondBegin}{\SCondEnd}{../Typing.ml}
\lrmcomment{This is related to \identr{NBDJ}.}

\subsection{Semantics}
\SemanticsRuleDef{SCond}
\subsubsection{Examples}
The specification in \listingref{semantics-scond} does not result in any Assertion Error.
\ASLListing{Evaluating a conditional statement}{semantics-scond}{\semanticstests/SemanticsRule.SCond.asl}

The specification in \listingref{semantics-scond2}
does not result in any error.
\ASLListing{Evaluating a condition statement with \texttt{elsif}}{semantics-scond2}{\semanticstests/SemanticsRule.SCond2.asl}

The specification in \listingref{semantics-scond3}
results in an Assertion Error.
\ASLListing{Evaluating a condition statement that results in an Assertion Error}{semantics-scond3}{\semanticstests/SemanticsRule.SCond3.asl}

The specification in \listingref{semantics-scond4} does not result in any error.
\ASLListing{Evaluating a condition statement with only a \texttt{then} branch}{semantics-scond4}{\semanticstests/SemanticsRule.SCond4.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vs$ is a condition statement, $\SCond(\ve, \vsone, \vstwo)$;
\item evaluating $\ve$ in $\env$ is $\Normal(\vv, \vgone)$\ProseOrAbnormal;
\item $\vv$ is a native Boolean for $\vb$;
\item the statement $\vsp$ is $\vsone$ is $\vb$ is $\True$ and $\vstwo$ otherwise
(so that $\vsone$ will be evaluated if the condition evaluates to $\True$ and otherwise
$\vstwo$ will be evaluated);
\item evaluating $\vsp$ in $\envone$ as per \chapref{BlockStatements} is a non-abnormal configuration
      (either $\Normal$ or $\Continuing$) $C$\ProseOrAbnormal;
\item $\vg$ is the ordered composition of $\vgone$ and the execution graph of the configuration $C$;
\item $D$ is the configuration $C$ with the execution graph component updated to be $\vg$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \envone) \OrAbnormal\\
  \vv \eqname \nvbool(\vb)\\
  \vsp \eqdef \choice{\vb}{\vsone}{\vstwo}\\
  \evalblock{\envone, \vsp} \evalarrow C \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\aslctrl}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\vg}
}{
  \evalstmt{\env, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}} \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSCondBegin}{\EvalSCondEnd}{../Interpreter.ml}

\hypertarget{def-casestatementterm}{}
\section{Case Statements\label{sec:CaseStatements}}
Case statements allow executing different statements, based on which
condition an expression satisfies.

\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tcase \parsesep \Nexpr \parsesep \Tof \parsesep \Ncasealtlist \parsesep \Tend \parsesep \Tsemicolon &\\
|\ & \Tcase \parsesep \Nexpr \parsesep \Tof \parsesep \Ncasealtlist \parsesep \Totherwise \parsesep \Tarrow &\\
   & \wrappedline\ \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Ncasealtlist \derives \ & \ClistOne{\Ncasealt} \parsesep &\\
\Ncasealt \derives \ & \Twhen \parsesep \Npatternlist \parsesep \option{\Twhere \parsesep \Nexpr} \parsesep \Tarrow \parsesep \Nstmtlist &\\
\end{flalign*}

\hypertarget{def-casediscriminantterm}{}
\hypertarget{def-casealternativeterm}{}
\hypertarget{def-otherwisecaseterm}{}
The expression following the \Tcase\ keyword is called the \emph{\casediscriminantterm}.
The list following the \Tof\ keyword consists of \emph{\casealternativesterm},
optionally ending with an \emph{\otherwisecaseterm}, which follows the \Totherwise\ keyword.

\subsection{Abstract Syntax}
Case statements are considered syntactic sugar and are \emph{desugared}.
That is, they are transformed into an untyped AST node that does not have
an explicit representation for \texttt{case} statements.
This is achieved via \ASTRuleRef{DesugarCaseStmt},
which obeys the following requirements:
\RequirementDef{CaseDiscriminant} The \casediscriminantterm\ of a \texttt{case}
statement should be evaluated only once each time the case statement is evaluated.

\RequirementDef{CaseAlternatives} The \casealternativesterm\ are examined
one after another, in the order they are listed.
If any of the patterns match the \casediscriminantterm (and the guard
expression is true, if present) then this \casealternativeterm\ is considered selected,
its statement list is executed, and the \texttt{case} statement ends without examining any further
\casealternativesterm.

\RequirementDef{CaseOtherwise} If no \casealternativeterm\ is selected, and there is an
\otherwisecaseterm\, the \otherwisecaseterm\ is executed.

\RequirementDef{CaseDiscriminantTesting} Testing the \casediscriminantterm\ against a \\
pattern list
follows the semantics of pattern matching defined in \chapref{PatternMatching}.
It is not a static error if it can be statically determined that none of the patterns in a
\casealternativeterm\ can match the discriminant.

\RequirementDef{CaseNoOtherwiseError} If no \casealternativeterm\ is selected,
and there is no \otherwisecaseterm, it is a dynamic error.

\subsubsection{Example}
\listingref{ast-case1} shows an example of how a \texttt{case} statement can be transformed into a corresponding
compound condition statement.
\ASLListing{Transforming a case statement with a variable as the case discriminant}{ast-case1}{\syntaxtests/ASTRule.Desugar_SCase1.asl}

\listingref{ast-case2} shows an example of how a \texttt{case} statement can be transformed into
a statement that does not contain any \text{case} statement.
By storing the \casediscriminantterm\ in a variable and by adding
a call to \texttt{Unreachable()}, the transformation ensures that a dynamic error occurs when no
\casealternativeterm\ is selected.
\ASLListing{Transforming a case statement with a non-variable as the case discriminant
and no otherwise case}{ast-case2}{\syntaxtests/ASTRule.Desugar_SCase2.asl}

The untyped AST contains non-terminals for \casealternativesterm, which exist
only as a data type used by $\desugarcasestmt$ and do not later appear in the untyped
AST:

\begin{flalign*}
\casealt \derives\ & \{ \CasePattern : \pattern, \CaseWhere : \expr?, \CaseStmt : \stmt \} &
\end{flalign*}

\ASTRuleDef{SCase}
To satisfy \RequirementRef{CaseNoOtherwiseError}, when no \otherwisecaseterm\ exists,
$\SUnreachable$ is used instead:
\begin{mathpar}
\inferrule[no\_otherwise]{
  \buildlist[\buildcasealt](\vcasealtlist) \astarrow \vcasealtlistast\\
  \buildexpr(\vediscriminant) \astarrow \astversion{\vediscriminant}\\
  {
  \begin{array}{r}
  \desugarcasestmt(\astversion{\vediscriminant}, \vcasealtlistast, \SUnreachable) \astarrow \\
  \vastnode
  \end{array}
  }
}{
  {
  \buildstmt\left(\overname{
    \Nstmt\left(
      \begin{array}{l}
        \Tcase, \namednode{\vediscriminant}{\Nexpr}, \Tof, \\
        \wrappedline\ \namednode{\vcasealtlist}{\Ncasealtlist}, \\
        \wrappedline\ \Tend, \Tsemicolon
      \end{array}
    \right)
    }{\vparsednode}\right)
  \astarrow
  \vastnode
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise]{
  \buildlist[\buildcasealt](\vcasealtlist) \astarrow \vcasealtlistast\\
  \buildexpr(\vediscriminant) \astarrow \astversion{\vediscriminant}\\
  \buildstmtlist(\votherwise) \astarrow \astversion{\votherwise}\\
  {
  \begin{array}{r}
  \desugarcasestmt(\astversion{\vediscriminant}, \vcasealtlistast, \astversion{\votherwise}) \astarrow \\
  \vastnode
  \end{array}
  }
}{
  {
  \buildstmt\left(\overname{
    \Nstmt\left(
      \begin{array}{l}
        \Tcase, \namednode{\vediscriminant}{\Nexpr}, \Tof, \\
        \wrappedline\ \namednode{\vcasealtlist}{\Ncasealtlist}, \\
        \wrappedline\ \Totherwise, \Tarrow, \namednode{\votherwise}{\Nstmtlist}, \\
        \wrappedline\ \Tend, \Tsemicolon
      \end{array}
    \right)
    }{\vparsednode}\right)
  \astarrow
  \vastnode
  }
}
\end{mathpar}

\ASTRuleDef{CaseAltList}
\hypertarget{build-casealtlist}{}
The function
\[
\buildcasealtlist(\overname{\parsenode{\Ncasealtlist}}{\vparsednode}) \;\aslto\; \overname{\casealt^+}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildclist[\buildcasealt](\vcases) \typearrow \vastnode
}{
  \buildcasealtlist(\overname{\Ncasealtlist(\vcases : \ClistOne{\Ncasealt})}{\vparsednode}) \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{CaseAlt}
\hypertarget{build-casealt}{}
The function
\[
\buildcasealt(\overname{\parsenode{\Ncasealt}}{\vparsednode}) \;\aslto\; \overname{\casealt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildoption[\buildexpr](\vwhereopt) \astarrow \vwhereast
}{
  {
    \begin{array}{r}
  \buildcasealt\left(\overname{\Ncasealt\left(
    \begin{array}{l}
    \Twhen, \punnode{\Npatternlist}, \\
    \wrappedline\ \namednode{\vwhereopt}{\option{\Twhere, \Nexpr}}, \Tarrow, \\
    \wrappedline\ \namednode{\vstmts}{\Nstmtlist}
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{\casealt(\CasePattern: \astof{\vpatternlist}, \CaseWhere: \vwhereast, \CaseStmt: \astof{\vstmtlist})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarCaseStmt}
\hypertarget{def-desugarcasestmt}{}
The relation
\[
\desugarcasestmt(
  \overname{\expr}{\vezero},
  \overname{\casealt^*}{\vcases},
  \overname{\stmt}{\votherwise}) \;\aslrel\; \overname{\stmt}{\news}
\]
transforms a \casediscriminantterm\ $\vezero$, a list of \casealternativesterm\ $\vcases$,
and a statement $\votherwise$ into a statement $\news$.

\begin{mathpar}
\inferrule[var]{
  \astlabel(\vezero) = \EVar\\
  \casestocond(\vezero, \vcases, \votherwise) \typearrow \news
}{
  \desugarcasestmt(\vezero, \vcases, \votherwise) \astarrow \news
}
\end{mathpar}

To satisfy \RequirementRef{CaseDiscriminant}, the transformation assigns the
\casediscriminantterm\ to a temporary variable, which is then used in a
compound conditional statement (see \listingref{ast-case2} for an example):
\begin{mathpar}
\inferrule[non\_var]{
  \astlabel(\vezero) \neq \EVar\\
  \vx \in \Identifiers \text{ is fresh}\\
  \vdeclx \eqname \SDecl(\LDKLet, \LDIVar(\vx), \None, \langle\vezero\rangle)\\
  \casestocond(\EVar(\vx), \vcases, \votherwise) \typearrow \vscond
}{
  \desugarcasestmt(\vezero, \vcases, \votherwise) \astarrow \overname{\SSeq(\vdeclx, \vscond)}{\news}
}
\end{mathpar}
\CodeSubsection{\DesugarCaseStmtBegin}{\DesugarCaseStmtEnd}{../desugar.ml}

\ASTRuleDef{CasesToCond}
\hypertarget{def-casestocond}{}
The function
\[
\casestocond(
  \overname{\expr}{\ve} \aslsep
  \overname{\casealt^*}{\vcases} \aslsep
  \overname{\stmt}{\votherwise})
\;\aslrel\; \overname{\stmt}{\news}
\]
transforms an expression $\ve$, a list of \texttt{case} alternatives $\vcases$,
and a statement $\votherwise$
into a statement $\news$.

\begin{mathpar}
\inferrule[last]{
  \casetocond(\ve, \vcase, \votherwise) \astarrow \news
}{
  \casestocond(\ve, \overname{[\vcase]}{\vcases}, \votherwise) \astarrow \news
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_last]{
  \vcasesone \neq \emptylist\\
  \casestocond(\ve, \vcasesone) \typearrow \vsone\\
  \casetocond(\ve, \vcase, \vsone) \typearrow \news
}{
  \casestocond(\ve, \overname{[\vcase] \concat \vcasesone}{\vcases}, \votherwise) \astarrow \news
}
\end{mathpar}
\CodeSubsection{\CasesToCondBegin}{\CasesToCondEnd}{../desugar.ml}

\ASTRuleDef{CaseToCond}
\hypertarget{def-casetocond}{}
The function
\[
\casetocond(\overname{\expr}{\vezero} \aslsep \overname{\casealt}{\vcase} \aslsep \overname{\stmt}{\vtail})
\;\aslrel\; \overname{\stmt}{\news}
\]
transforms an expression $\vezero$ (the condition used for a \texttt{case} statement),
a single \texttt{case} alternative $\vcase$, and a statement $\vtail$, which represents
a list of \texttt{case} alternatives already converted to conditionals, into a condition statement $\news$.

\begin{mathpar}
\inferrule{
  \vcase \eqname \{ \CasePattern : \vpattern, \CaseWhere : \vwhere, \CaseStmt : \vstmt \}\\
  \vepattern \eqdef \EPattern(\vezero, \vpattern)\\
  \vcond \eqdef \choice{\vwhere = \langle\vewhere\rangle}{\EBinop(\BAND, \vepattern, \vewhere)}{\vepattern}
}{
  \casetocond(\vezero, \vcase, \vtail) \astarrow \overname{\SCond(\vcond, \vstmt, \vtail)}{\news}
}
\end{mathpar}
\CodeSubsection{\CaseToCondBegin}{\CaseToCondEnd}{../desugar.ml}

\subsection{Typing}
Since case statements are transformed into other statements,
they do not require type system rules.
\lrmcomment{This is related to \identr{WGSY}.}

\subsection{Semantics}
Since case statements are transformed into other statements,
they do not appear in the typed AST and thus are not associated with a semantics.

\hypertarget{def-assertionstatementterm}{}
\section{Assertion Statements\label{sec:AssertionStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tassert \parsesep \Nexpr \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SAssert(\expr) &
\end{flalign*}

\ASTRuleDef{SAssert}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tassert, \Nexpr, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SAssert(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SAssert}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is an assert statement with expression $\ve$, that is, $\SAssert(\ve)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tep,\vep, \vsese)$\ProseOrTypeError;
  \item checking that $\vsese$ is pure via $\sesispure$ yields $\True$\ProseOrTypeError;
  \item checking that $\vtep$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is an assert statement with expression $\vep$, that is, $\SAssert(\vep)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsese$ and the singleton set for \PerformsAssertionsTerm}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vtep, \vep, \vsese) \OrTypeError\\\\
  \checktrans{\sesispure(\vsese) \typearrow \True}{\SideEffectViolation}\\\\
  \checktypesat(\tenv, \vtep, \TBool) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsese \cup \{\PerformsAssertions\}
}{
  \annotatestmt(\tenv, \overname{\SAssert(\ve)}{\vs}) \typearrow (\overname{\SAssert(\vep)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SAssertBegin}{\SAssertEnd}{../Typing.ml}
\lrmcomment{This is related to \identr{JQYF}.}

\subsection{Semantics}
\SemanticsRuleDef{SAssert}
\subsubsection{Example}
In \listingref{semantics-sasertok},
\texttt{assert (42 != 3);} ensures that \texttt{3} is not equal to \texttt{42}.
\ASLListing{Evaluating an assertion that succeeds}{semantics-sasertok}{\semanticstests/SemanticsRule.SAssertOk.asl}

\subsubsection{Example}
In \listingref{semantics-sassertno},
evaluating \texttt{assert (42 == 3);} results in an \texttt{AssertionFailed} error.
\ASLListing{Evaluating an assertion that fails}{semantics-sassertno}{\semanticstests/SemanticsRule.SAssertNo.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is an assertion statement, $\SAssert(\ve)$;
  \item one of the following holds:
  \begin{itemize}
    \item all of the following hold (\textsc{okay}):
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ is $\Normal((\vv, \newg), \newenv)$\ProseOrAbnormal;
      \item $\vv$ is a native Boolean value for $\True$;
      \item the resulting configuration is $\Continuing(\newg, \newenv)$.
    \end{itemize}

    \item all of the following hold (\textsc{error}):
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ is $\Normal((\vv, \newg), \newenv)$;
      \item $\vv$ is a native Boolean value for $\False$;
      \item the result is a dynamic error indicating the assertion failure returned (\DynamicAssertionFailure).
    \end{itemize}
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \newg), \newenv) \OrAbnormal\\\\
  \vv \eqname \nvbool(\True)
}{
  \evalstmt{\env, \SAssert(\ve)} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
  \inferrule[error]{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \Ignore), \Ignore)\\
  \vv \eqname \nvbool(\False)
}{
  \evalstmt{\env, \SAssert(\ve)} \evalarrow \DynamicErrorVal{\DynamicAssertionFailure}
}
\end{mathpar}
\CodeSubsection{\EvalSAssertBegin}{\EvalSAssertEnd}{../Interpreter.ml}
\lrmcomment{This is related to \identd{QJYV}, \identr{WZSL}, \identr{WQRN}.}

\hypertarget{def-whilestatementterm}{}
\section{While Statements\label{sec:WhileStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Twhile \parsesep \Nexpr \parsesep \Nlooplimit \parsesep \Tdo \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SWhile(\overtext{\expr}{condition}, \overtext{\expr?}{loop limit}, \overtext{\stmt}{loop body}) &
\end{flalign*}

\ASTRuleDef{SWhile}
\begin{mathpar}
\inferrule{
  \buildexpr(\vlimitexpr) \astarrow \astversion{\vlimitexpr}\\
  \buildlooplimit(\voptlimit) \astarrow \astversion{\voptlimit}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Twhile, \econd: \Nexpr, \voptlimit : \Nlooplimit, \Tdo, \\
    \wrappedline\ \punnode{\Nstmtlist}, \Tend, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow\\
  \overname{\SWhile(\astof{\vexpr}, \astversion{\voptlimit}, \astof{\vstmtlist})}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{LoopLimit}
\hypertarget{build-looplimit}{}
The function
\[
\buildlooplimit(\overname{\parsenode{\Nlooplimit}}{\vparsednode}) \aslto \overname{\langle\expr\rangle}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[limit]{}{
  \buildlooplimit\left(\overname{\Nlooplimit(\Tlooplimit, \punnode{\Nexpr})}{\vparsednode}\right)
  \astarrow
  \overname{\langle\astof{\vexpr}\rangle}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_limit]{}{
  \buildlooplimit\left(\overname{\Nlooplimit(\emptysentence)}{\vparsednode}\right)
  \astarrow
  \overname{\None}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SWhile}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vs$ is a \texttt{while} statement with expression $\veone$, optional limit expression $\vlimitone$,
      and statement block $\vsone$, that is, $\SWhile(\veone, \vsone)$;
\item annotating the right-hand-side expression $\veone$ in $\tenv$ yields $(\vt, \vetwo, \vsese)$\ProseOrTypeError;
\item annotating the optional limit expression $\vlimitone$ via $\annotatelimitexpr$ in $\tenv$ yields $(\vlimittwo, \vseslimit)$\ProseOrTypeError;
\item checking that $\vt$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item annotating $\vsone$ as a block statement as per \TypingRuleRef{Block} in $\tenv$ yields \\
      $(\vstwo, \vsesblock)$\ProseOrTypeError;
\item $\news$ is a \texttt{while} statement with expression $\vetwo$, optional limit expression $\vlimittwo$,
      and statement block $\vstwo$, that is, $\SWhile(\vetwo, \vstwo)$;
\item $\newtenv$ is $\tenv$;
\item \Proseeqdef{$\vses$}{the union of $\vsesblock$, $\vsese$, and $\vseslimit$}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo, \vsese) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimitone) \typearrow (\vlimittwo, \vseslimit) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock{\tenv, \vsone} \typearrow (\vstwo, \vsesblock) \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsese \cup \vseslimit
}{
  \annotatestmt(\tenv, \overname{\SWhile(\veone, \vlimitone, \vsone)}{\vs}) \typearrow
  (\overname{\SWhile(\vetwo, \vlimittwo, \vstwo)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SWhileBegin}{\SWhileEnd}{../Typing.ml}
\lrmcomment{This is related to \identr{FTVN}.}

\TypingRuleDef{AnnotateLimitExpr}
\hypertarget{def-annotatelimitexpr}{}
The function
\[
  \annotatelimitexpr(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\langle\expr\rangle}{\ve} \aslsep
  ) \aslto
  (\langle\overname{\expr}{\vep}\rangle \times \overname{\TSideEffectSet}{\vses}) \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates an optional expression $\ve$ serving as the limit of a loop or a recursive subprogram in $\tenv$,
yielding a pair consisting of an expression $\vep$ and a \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\ve$ is $\None$;
    \item $\vep$ is $\None$;
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\ve$ is $\langle\vlimit\rangle$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\vlimit$ in $\tenv$ yields \\
          $(\vlimitp, \vses)$\ProseOrTypeError;
    \item $\vep$ is $\langle\vlimitp\rangle$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \annotatelimitexpr(\tenv, \overname{\None}{\ve}) \typearrow (\overname{\None}{\vep}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\begin{mathpar}
\inferrule[some]{
  \annotatesymbolicconstrainedinteger(\tenv, \vlimit) \typearrow (\vlimitp, \vses) \OrTypeError
}{
  \annotatelimitexpr(\tenv, \overname{\langle\vlimit\rangle}{\ve}) \typearrow (\overname{\langle\vlimitp\rangle}{\vep}, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateLimitExprBegin}{\AnnotateLimitExprEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{SWhile}
\subsubsection{Example}
The specification in \listingref{semantics-swhile} prints \texttt{0123}.
\ASLListing{Evaluating a \texttt{while} loop}{semantics-swhile}{\semanticstests/SemanticsRule.SWhile.asl}

\subsubsection{Prose}
Evaluation of the statement $\vs$ in an environment $\env$ is
the output configuration $C$ and all of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{while} statement, $\SWhile(\ve, \velimitopt, \vbody)$;
  \item evaluating the optional limit expression $\velimitopt$ via $\evallimit$ in $\env$
        yields $(\vlimitopt, \vgone)$\ProseOrError;
  \item evaluating the loop as per \SemanticsRuleRef{Loop} in an environment $\env$,
  with the arguments $\True$ (which conveys that this is a \texttt{while} statement), $\vlimitopt$, $\ve$, and $\vbody$
  yields the (non-error configuration) $C$\ProseOrError;
  \item $\vgtwo$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge;
  \item the output configuration $D$ is the output configuration $C$ with its execution graph
        substituted with $\vgtwo$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitopt, \vgone) \OrDynError\\\\
  \evalloop{\env, \True, \vlimitopt, \ve, \vbody} \evalarrow C \OrDynError\\\\
  \vgtwo \eqdef \ordered{\vgone}{\asldata}{\graphof{C}}\\
  D \eqdef \withgraph{C}{\vgtwo}
}{
  \evalstmt{\env, \overname{\SWhile(\ve, \velimitopt, \vbody)}{\vs}} \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSWhileBegin}{\EvalSWhileEnd}{../Interpreter.ml}

\SemanticsRuleDef{Loop}
The relation
\hypertarget{def-evalloop}{}
\[
  \evalloop{
    \overname{\envs}{\env} \aslsep
    \overname{\Bool}{\iswhile} \aslsep
    \overname{\N?}{\vlimitopt} \aslsep
    \overname{\expr}{\econd} \aslsep
    \overname{\stmt}{\vbody}}
  \;\aslrel\;
  \left(
    \begin{array}{cl}
      \Continuing(\overname{\XGraphs}{\newg} \aslsep \overname{\envs}{\newenv}) & \cup \\
      \overname{\TReturning}{\ReturningConfig} & \cup \\
      \overname{\TThrowing}{\ThrowingConfig} & \cup \\
      \overname{\TDynError}{\DynErrorConfig} &
    \end{array}
  \right)
\]
to evaluate both \texttt{while} statements and \texttt{repeat} statements.

More specifically, $\evalloop{\env, \iswhile, \velimitopt, \econd, \vbody}$
evaluates $\vbody$ in $\env$ as long as $\econd$ holds when $\iswhile$ is $\True$
or until $\econd$ holds when $\iswhile$ is $\False$.
If the number of iterations exceeds the optional value specified by $\vlimitopt$,
the result is a dynamic error.
The result is either the continuing configuration \\ $\Continuing(\newg,\newenv)$,
an early return configuration, or an abnormal configuration.

\subsubsection{Example}
The specification in \listingref{semantics-loop} does not result in any Assertion Error
and the specification terminates with exit code $0$.
\ASLListing{Evaluating a loop}{semantics-loop}{\semanticstests/SemanticsRule.Loop.asl}

\CodeSubsection{\EvalLoopBegin}{\EvalLoopEnd}{../Interpreter.ml}
\subsubsection{Prose}
One of the following applies:
\begin{itemize}
\item all of the following apply (\textsc{exit}):
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is $\Normal(\condm, \newenv)$\ProseOrAbnormal;
    \item $\condm$ consists of a native Boolean for $\vb$ and an execution graph $\newg$;
    \item $\vb$ is not equal to $\iswhile$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$
    and the loop is exited.
  \end{itemize}
\item all of the following apply (\textsc{continue}):
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is $\Normal(\condm, \envone)$;
    \item $\mcond$ consists of a native Boolean for $\vb$ and an execution graph $\vgone$;
    \item $\vb$ is equal to $\iswhile$;
    \item \Proseticklooplimit{$\vlimitopt$}{$\vlimitoptp$}\ProseOrError;
    \item evaluating $\vbody$ in $\envone$ as per \SemanticsRuleRef{Block} is either \\
    $\Continuing(\vgtwo, \envtwo)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
    \item evaluating $(\iswhile, \vlimitoptp, \econd, \vbody)$ in $\envtwo$ as a loop is \\
    $\Continuing(\vgthree, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label
    and then the ordered composition of the result and $\vgthree$ with the $\aslpo$ edge;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
The premise $\vb \neq \iswhile$ is $\True$ in the case of a \texttt{while} loop
and the loop condition $\ve$ not holding, which is exactly when we want the
loop to exit. The opposite holds for a \texttt{repeat} loop.
The negation of the condition is used to decide whether to continue the loop iteration.

\begin{mathpar}
\inferrule[exit]{
  \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \newenv) \OrAbnormal\\
  \condm \eqname (\nvbool(\vb), \newg)\\
  \vb \neq \iswhile
}{
  \evalloop{\env, \iswhile, \vlimitopt, \econd, \vbody} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[continue]{
  \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \envone)\\
  \condm \eqname (\nvbool(\vb), \vgone)\\
  \vb = \iswhile\\
  \ticklooplimit(\vlimitopt) \evalarrow \vlimitoptp \OrDynError\\\\
  \evalblock{\envone, \vbody} \evalarrow \Continuing(\vgtwo, \envtwo) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig\\
  {
    \begin{array}{r}
      \evalloop{\envtwo, \iswhile, \vlimitoptp, \econd, \vbody} \evalarrow \\
      \Continuing(\vgthree, \newenv) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig\\
    \end{array}
  }\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslctrl}{\vgtwo}}{\aslpo}{\vgthree}
}{
  \evalloop{\env, \iswhile, \vlimitopt, \econd, \vbody} \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\SemanticsRuleDef{EvalLimit}
The relation
\hypertarget{def-evallimit}{}
\[
\evallimit(\overname{\env}{\envs} \aslsep \overname{\velimitopt}{\expr?})
\aslto (\overname{\langle\N\rangle}{\vvopt}, \overname{\vg}{\XGraphs})
\cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the optional expression $\velimitopt$ in the environment $\env$, yielding
the optional integer value $\vvopt$ and execution graph $\vg$.
\ProseOrError

The evaluation uses the function $\evalexprsef$ because limit expressions are
guaranteed side-effect-free by the type-checker,
see \TypingRuleRef{AnnotateLimitExpr}.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\velimitopt$ is $\None$;
    \item $\vvopt$ is $\None$;
    \item $\vg$ is the empty execution graph.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\velimitopt$ is the expression $\velimit$;
    \item evaluating the side-effect-free expression $\velimitopt$ in $denv$ yields the native integer for $\vv$ and
          the execution graph $\vg$;
    \item $\vvopt$ is $\langle\vv\rangle$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \evallimit(\env, \overname{\None}{\velimitopt}) \evalarrow (\overname{\None}{\vvopt}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \evalexprsef{\env, \velimit} \evalarrow (\nvint(\vv), \vg) \OrDynError
}{
  \evallimit(\env, \overname{\langle\velimit\rangle}{\velimitopt}) \evalarrow (\overname{\langle\vv\rangle}{\vvopt}, \vg)
}
\end{mathpar}

\SemanticsRuleDef{TickLoopLimit}
The relation
\hypertarget{def-ticklooplimit}{}
\[
\ticklooplimit(\overname{\vvopt}{\N?}) \aslto \overname{\langle\vvoptp\rangle}{\N?}
\cup \overname{\TDynError}{\DynErrorConfig}
\]
decrements the optional integer $\vvopt$, yielding
the optional integer value $\vvopt$.
If the value is $0$, the result is a dynamic error.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vvopt$ is $\None$;
    \item $\vvoptp$ is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{some\_ok}):
  \begin{itemize}
    \item $\vvopt$ is the positive integer $\vv$;
    \item $\vvoptp$ is $\langle\vv-1\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{some\_error}):
  \begin{itemize}
    \item $\vvopt$ is the integer $0$;
    \item the result is a dynamic error indicating that a limit has been reached
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \ticklooplimit(\overname{\None}{\vvopt}) \evalarrow \overname{\None}{\vvoptp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_ok]{
  \vv > 0
}{
  \ticklooplimit(\overname{\langle\vv\rangle}{\vvopt}) \evalarrow \overname{\langle\vv-1\rangle}{\vvoptp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_error]{}{
  \ticklooplimit(\overname{\langle 0 \rangle}{\vvopt}) \evalarrow \DynamicErrorVal{\LimitExceeded}
}
\end{mathpar}

\hypertarget{def-repeatstatementterm}{}
\section{Repeat Statements\label{sec:RepeatStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Trepeat \parsesep \Nstmtlist \parsesep \Tuntil \parsesep \Nexpr \parsesep \Nlooplimit \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SRepeat(\overtext{\stmt}{loop body}, \overtext{\expr}{condition}, \overtext{\expr?}{loop limit}) &
\end{flalign*}

\ASTRuleDef{SRepeat}
\begin{mathpar}
\inferrule{
  \buildexpr(\vlimitexpr) \astarrow \astversion{\vlimitexpr}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Tlooplimit, \Tlpar, \namednode{\vlimitexpr}{\Nexpr}, \Trpar, \Trepeat, \\
    \wrappedline\ \Nstmtlist, \Tuntil, \punnode{\Nexpr}, \punnode{\Nlooplimit}, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow\\
  \overname{\SRepeat(\astof{\vstmtlist}, \astof{\vexpr}, \astof{\vlooplimit})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SRepeat}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement with statement block $\vsone$,
        optional limit expression $\vlimitone$, and expression $\veone$, that is, $\SRepeat(\vsone, \veone, \vlimitone)$;
  \item annotating $\vsone$ as a block statement per \TypingRuleRef{Block} in $\tenv$ yields $(\vstwo, \vsesblock)$\ProseOrTypeError;
  \item annotating the optional limit expression $\vlimitone$ via $\annotatelimitexpr$ in $\tenv$ yields $(\vlimittwo, \vseslimit)$\ProseOrTypeError;
  \item annotating the right-hand-side expression $\veone$ in $\tenv$ yields $(\vt, \vetwo, \vsese)$\ProseOrTypeError;
  \item checking that $\vt$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is a \texttt{repeat} statement with statement block $\vstwo$, optional limit expression $\vlimittwo$,
        and condition expression $\vetwo$ and , that is, $\SRepeat(\vstwo, \vetwo, \vlimittwo)$;
  \item $\newtenv$ is $\tenv$;
  \item \Proseeqdef{$\vses$}{the union of $\vsesblock$, $\vsese$, and $\vseslimit$}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateblock{\tenv, \vsone} \typearrow (\vstwo, \vsesblock) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimitone) \typearrow (\vlimittwo, \vseslimit) \OrTypeError\\\\
  \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo, \vsese) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesblock \cup \vsese \cup \vseslimit
}{
  \annotatestmt(\tenv, \overname{\SRepeat(\vsone, \veone, \vlimitone)}{\vs}) \typearrow
  (\overname{\SRepeat(\vstwo, \vetwo, \vlimittwo)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SRepeatBegin}{\SRepeatEnd}{../Typing.ml}
\lrmcomment{This is related to \identr{FTVN}.}

\subsection{Semantics}
\SemanticsRuleDef{SRepeat}
\subsubsection{Example}
The specification in \listingref{semantics-srepeat} prints
\begin{Verbatim}
  0
  1
  2
  3
\end{Verbatim}
\ASLListing{Evaluating a \texttt{repeat} loop}{semantics-srepeat}{\semanticstests/SemanticsRule.SRepeat.asl}

\subsubsection{Prose}
Evaluation of the statement $\vs$ in an environment $\env$ is
either \\ $\Returning((\vvs, \newg), \newenv)$ or an output configuration $D$ and all of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement, $\SRepeat(\ve, \vbody, \velimitopt)$;
  \item evaluating the optional limit expression $\velimitopt$ via $\evallimit$ in $\env$
        yields $(\vlimitopt, \vgone)$\ProseOrError;
  \item \Proseticklooplimit{$\vlimitoptone$}{$\vlimitopttwo$}\ProseOrError;
  \item evaluating $\vbody$ in $\env$ as per \chapref{BlockStatements}
        yields $\Continuing(\vgtwo, \envone)$\ProseTerminateAs{\ReturningConfig,\ThrowingConfig,\DynErrorConfig};
  \item evaluating the loop as per \secref{SemanticsRule.Loop} in an environment $\envone$,
        with the arguments $\False$ (which conveys that this is a \texttt{repeat} statement),
        $\vlimitopttwo$,
        $\ve$,
        and $\vbody$
        results in $C$;
  \item $\vgthree$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ and the graph of $C$
        with the $\aslpo$ edge;
  \item the output configuration $D$ is the output configuration $C$ with its execution graph
        substituted with $\vgthree$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evallimit(\env, \velimitopt) \evalarrow (\vlimitoptone, \vgone) \OrDynError\\\\
  \ticklooplimit(\vlimitoptone) \evalarrow \vlimitopttwo \OrDynError\\\\
  \evalblock{\env, \vbody} \evalarrow \Continuing(\vgtwo, \envone) \terminateas \ReturningConfig,\ThrowingConfig,\DynErrorConfig\\\\
  \evalloop{\envone, \False, \vlimitopttwo, \ve, \vbody} \evalarrow C\\
  \vgthree \eqdef \ordered{\vgone}{\asldata}{\ordered{\vgtwo}{\aslpo}{\graphof{C}}}\\
  D \eqdef \withgraph{C}{\vgthree}
}{
  \evalstmt{\env, \overname{\SRepeat(\ve, \vbody, \velimitopt)}{\vs}} \evalarrow D
}
\end{mathpar}
\CodeSubsection{\EvalSRepeatBegin}{\EvalSRepeatEnd}{../Interpreter.ml}

\hypertarget{def-forstatementterm}{}
\section{For Statements\label{sec:ForStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tfor \parsesep \Tidentifier \parsesep \Teq \parsesep \Nexpr \parsesep \Ndirection \parsesep
                    \Nexpr \parsesep \Nlooplimit \parsesep \Tdo &\\
                        & \wrappedline\ \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Ndirection \derives \ & \Tto \;|\; \Tdownto &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\fordirection \derives\ & \UP \;|\; \DOWN &\\
\stmt \derives\ & \SFor\left\{
      \begin{array}{rcl}
      \Forindexname  &:& \identifier,\\
      \Forstarte     &:& \expr,\\
      \Fordir        &:& \fordirection,\\
      \Forende       &:& \expr,\\
      \Forbody       &:& \stmt,\\
      \Forlimit      &:& \expr?
      \end{array}
    \right\} &
\end{flalign*}

\ASTRuleDef{SFor}
\begin{mathpar}
\inferrule{
  \buildexpr(\vstarte) \astarrow \astversion{\vstarte}\\
  \buildexpr(\vende) \astarrow \astversion{\vende}\\
}{
  {
    \begin{array}{r}
      \buildstmt\left(\overname{\Nstmt\left(
        \begin{array}{l}
        \Tfor, \Tidentifier(\vindexname), \Teq, \namednode{\vstarte}{\Nexpr},  \\
        \wrappedline\ \Ndirection, \namednode{\vende}{\Nexpr}, \punnode{\Nlooplimit}, \Tdo, \\
        \wrappedline\ \punnode{\Nstmtlist}, \Tend, \Tsemicolon
        \end{array}
        \right)}{\vparsednode}\right)
      \astarrow \\
        \overname{
        \SFor\left(\left\{
          \begin{array}{rcl}
            \Forindexname &:& \vindexname\\
            \Forstarte &:& \astversion{\vstarte}\\
            \Forende &:& \astversion{\vende}\\
            \Forbody &:& \astof{\vstmtlist}\\
            \Forlimit &:& \astof{\vlooplimit}\\
          \end{array}
            \right\}\right)
    }{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{Direction}
\hypertarget{build-direction}{}
The function
\[
\builddirection(\overname{\parsenode{\Ndirection}}{\vparsednode}) \;\aslto\; \overname{\fordirection}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[to]{}{
  \builddirection(\overname{\Ndirection(\Tto)}{\vparsednode}) \astarrow \overname{\UP}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[downto]{}{
  \builddirection(\overname{\Ndirection(\Tdownto)}{\vparsednode}) \astarrow \overname{\DOWN}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SFor}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement with index $\vindexname$,
        start expression $\vstarte$,
        direction $\dir$,
        end expression $\vende$,
        body statement (block) $\vbody$,
        and optional limit expression $\vlimit$,
        that is, $\SFor\left\{\begin{array}{rcl}
          \Forindexname &:& \vindexname\\
          \Forstarte &:& \vstarte\\
          \fordirection &:& \vdir\\
          \Forende &:& \vende\\
          \Forbody &:& \vbody\\
          \Forlimit &:& \vlimit
        \end{array}\right\}$;
  \item annotating the right-hand-side expression $\vstarte$ in $\tenv$ yields \\
        $(\vstartt, \vstartep, \vsesstart)$\ProseOrTypeError;
  \item annotating the right-hand-side expression $\vende$ in $\tenv$ yields \\ $(\vendt, \vendep, \vsesend)$\ProseOrTypeError;
  \item annotating the optional loop limit expression $\vlimit$ via $\annotatelimitexpr$ in $\tenv$
        yields $(\vlimitp, \vseslimit)$\ProseOrTypeError;
  \item checking that $\vsesstart$ is pure via $\sesispure$ yields $\True$\ProseOrTypeError;
  \item checking that $\vsesstart$ is deterministic via $\sesisdeterministic$ yields $\True$\ProseOrTypeError;
  \item checking that $\vsesend$ is pure via $\sesispure$ yields $\True$\ProseOrTypeError;
  \item checking that $\vsesend$ is deterministic via $\sesisdeterministic$ yields $\True$\ProseOrTypeError;
  \item \Proseeqdef{$\vsescond$}{the union of $\vsesstart$, $\vsesend$, and $\vseslimit$};
  \item obtaining the \underlyingtype\ of $\vstartt$ in $\tenv$ yields $\vstartstruct$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vendt$ in $\tenv$ yields $\vendstruct$\ProseOrTypeError;
  \item applying $\getforconstraints$ to $\vstartstruct$, $\vendstruct$,
        $\vstartep$, $\vendep$, and $\dir$ in $\tenv$,
        to obtain the constraints on the loop index $\vindexname$,
        yields $\cs$\ProseOrTypeError;
  \item $\tty$ is the integer type with constraints $\cs$;
  \item checking that $\vindexname$ is not already declared in $\tenv$ yields $\True$\ProseOrTypeError;
  \item adding $\vindexname$ as a local immutable variable with type $\tty$ to $\tenv$ yields $\tenvp$;
  \item annotating $\vbody$ as a block statement in $\tenvp$ yields $(\vbodyp, \vsesblock)$\ProseOrTypeError;
  \item $\news$ is the \texttt{for} statement with index $\vindexname$,
        start expression $\vstartep$, direction $\dir$,
        end expression $\vendep$,
        body statement (block) $\vbodyp$, and
        optional limit expression $\vlimit$;
  \item $\newtenv$ is $\tenv$ (notice that this means $\vindexname$ is only declared for annotating $\vbodyp$ but then goes
        out of scope);
  \item \Prosenonconflictingunion{$\vsesblock$ and $\vsescond$}{$\vses$}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vstarte} \typearrow (\vstartt, \vstartep, \vsesstart) \OrTypeError\\\\
  \annotateexpr{\tenv, \vende} \typearrow (\vendt, \vendep, \vsesend) \OrTypeError\\\\
  \annotatelimitexpr(\tenv, \vlimit) \typearrow (\vlimitp, \vseslimit) \OrTypeError\\\\
  \checktrans{\sesispure(\vsesstart)}{\SideEffectViolation} \typearrow \OrTypeError\\\\
  \checktrans{\sesisdeterministic(\vsesstart)}{\SideEffectViolation} \typearrow \OrTypeError\\\\
  \checktrans{\sesispure(\vsesend)}{\SideEffectViolation} \typearrow \OrTypeError\\\\
  \checktrans{\sesisdeterministic(\vsesend)}{\SideEffectViolation} \typearrow \OrTypeError\\\\
  \vsescond \eqdef \vsesstart \cup \vsesend \cup \vseslimit\\
  \makeanonymous(\tenv, \vstartt) \typearrow \vstartstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vendt) \typearrow \vendstruct \OrTypeError\\\\
  {
    \begin{array}{r}
  \getforconstraints(\tenv, \vstartstruct, \vendstruct, \vstartep, \vendep, \dir) \typearrow \\
    \cs \OrTypeError
    \end{array}
  }\\\\
  \tty \eqdef \TInt(\cs)\\
  \checkvarnotinenv{\tenv, \vindexname} \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \tty, \vindexname, \LDKLet) \typearrow \tenvp\\
  \annotateblock{\tenvp, \vbody} \typearrow (\vbodyp, \vsesblock) \OrTypeError\\\\
  \nonconflictingunion([\vsesblock, \vsescond]) \typearrow \vses \OrTypeError
}{
  {
    \begin{array}{r}
  \annotatestmt\left(\tenv, \overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \vlimit
  \end{array}\right\}}{\vs}\right) \typearrow \\
  \left(\overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstartep\\
    \fordirection &:& \vdir\\
    \Forende &:& \vendep\\
    \Forbody &:& \vbodyp\\
    \Forlimit &:& \vlimitp
  \end{array}\right\}}{\news}, \overname{\tenv}{\newtenv}, \vses\right)
\end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SForBegin}{\SForEnd}{../Typing.ml}
\lrmcomment{This is related to \identr{SSBD}, \identr{ZSND}, \identr{VTJW}.}

\TypingRuleDef{SForConstraints}
\hypertarget{def-getforconstraints}{}
The function
\[
  \getforconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\structone} \aslsep
    \overname{\ty}{\structtwo} \aslsep
    \overname{\expr}{\veonep} \aslsep
    \overname{\expr}{\vetwop} \aslsep
    \overname{\dir}{\dir}
  ) \aslto
  \overname{\constraintkind}{\vis} \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
infers the integer constraints for a \texttt{for} loop index variable from the following:
\begin{itemize}
  \item the \wellconstrainedversion\ of the type of the start expression --- $\structone$
  \item the \wellconstrainedversion\ of the type of the end expression --- $\structtwo$
  \item the annotated start expression --- $\veonep$
  \item the annotated end expression --- $\vetwop$
  \item the loop direction --- $\dir$
\end{itemize}
The result is $\vis$.
\ProseOtherwiseTypeError

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{not\_integers}):
  \begin{itemize}
    \item at least one of $\structone$ and $\structtwo$ is not an integer type;
    \item the result is a type error indicating that the start expression and end expression of \texttt{for} loops
          must have the \structure\ of integer types.
  \end{itemize}

  \item All of the following apply (\textsc{unconstrained}):
  \begin{itemize}
    \item both of $\structone$ and $\structtwo$ are integer types;
    \item at least one of $\structone$ and $\structtwo$ is the unconstrained integer type;
    \item define $\vis$ as $\unconstrained$.
  \end{itemize}

  \item All of the following apply (\textsc{well\_constrained}):
  \begin{itemize}
    \item both of $\structone$ and $\structtwo$ are integer types;
    \item neither $\structone$ nor $\structtwo$ is the unconstrained integer type;
    \item symbolically simplifying $\veonep$ in $\tenv$ yields $\eonen$\ProseOrTypeError;
    \item symbolically simplifying $\vetwop$ in $\tenv$ yields $\etwon$\ProseOrTypeError;
    \item define $\icsup$ as the single range constraint with expressions $\eonen$ and $\etwon$;
    \item define $\icsdown$ as the single range constraint with expressions $\etwon$ and $\eonen$;
    \item define $\vis$ as $\icsup$ if $\dir$ is $\UP$ and $\icsdown$ otherwise.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[not\_integers]{
  \astlabel(\structone) \neq \TInt \lor \astlabel(\structtwo) \neq \TInt
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  \astlabel(\structone) = \TInt \land \astlabel(\structtwo) = \TInt\\
  \structone = \unconstrainedinteger \lor \structtwo = \unconstrainedinteger\\
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \overname{\unconstrained}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \astlabel(\structone) = \TInt \land \astlabel(\structtwo) = \TInt\\
  \structone \neq \unconstrainedinteger \land \structtwo \neq \unconstrainedinteger\\
  \normalize(\tenv, \veonep) \typearrow \eonen \OrTypeError\\\\
  \normalize(\tenv, \vetwop) \typearrow \etwon \OrTypeError\\\\
  \icsup \eqdef \wellconstrained([\ConstraintRange(\eonen, \etwon)])\\
  \icsdown \eqdef \wellconstrained([\ConstraintRange(\etwon, \eonen)])\\
  \vis \eqdef \choice{\dir=\UP}{\icsup}{\icsdown}
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \vis
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{SFor}
Evaluating a \texttt{for} statement involves introducing an index variable to the
environment. The type system ensures, via \TypingRuleRef{SFor}, that the index variable
is not already declared in the scope of the subprogram containing the \texttt{for}
statement.

\subsubsection{Example}
The specification in \listingref{semantics-sfor} prints
\begin{Verbatim}
  0
  1
  2
  3
\end{Verbatim}
\ASLListing{Evaluating a \texttt{for} loop}{semantics-sfor}{\semanticstests/SemanticsRule.SFor.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement, $\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \Ignore
  \end{array}\right\}$;
  \item evaluating the side-effect-free expression $\vstarte$ in $\env$ yields
        $\Normal(\vstartv, \vgone)$\ProseOrError;
  \item evaluating the side-effect-free expression $\vende$ in $\env$ yields
        $\Normal(\vendv, \vgtwo)$\ProseOrError;
  \item \Proseevallimit{$\env$}{$\velimitopt$}{$\Normal(\vlimitopt, \vgthree)$}\ProseOrError;
  \item declaring the local identifier $\vindexname$ in $\env$ with value $\vstartv$ is $(\vgfour, \envone)$;
  \item evaluating the \texttt{for} loop with arguments $(\vindexname, \vlimitopt, \vstartv, \dir, \vendv, \vbody)$ in $\envone$,
        as per \SemanticsRuleRef{EvalFor} yields $\Normal(\vgfive, \envtwo)$\ProseOrAbnormal;
  \item removing the local $\vindexname$ from $\envtwo$ is $\envthree$;
  \item $\newg$ is formed as follows:
        the parallel composition of $\vgone$, $\vgtwo$, and $\vgthree$;
        followed by the ordered composition of the result with $\vgfour$ using the $\asldata$ edge;
        followed by the ordered composition of the result with $\vgfive$ using the $\aslpo$ edge.
  \item $\newenv$ is $\envthree$.
  \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
\end{itemize}
\subsubsection{Formally}
Recall that the expressions for the \texttt{for} loop range are
side-effect-free, as guaranteed by \TypingRuleRef{SFor}, which is why
they are evaluated via the rule for evaluating side-effect-free expressions.
\begin{mathpar}
\inferrule{
  \evalexprsef{\env, \vstarte} \evalarrow \Normal(\vstartv, \vgone) \OrDynError\\\\
  \evalexprsef{\env, \vende} \evalarrow \Normal(\vendv, \vgtwo) \OrDynError\\\\
  \evallimit(\env, \velimitopt) \evalarrow \Normal(\vlimitopt, \vgthree) \OrDynError\\\\
  \declarelocalidentifier(\env, \vindexname, \vstartv) \evalarrow (\vgfour,\envone)\\
  {
    \begin{array}{r}
      \evalfor(\envone, \vindexname, \vlimitopt, \vstartv, \dir, \vendv, \vbody) \evalarrow \\
      \Normal(\vgfive, \envtwo) \OrAbnormal
    \end{array}
  }\\
  \removelocal(\envtwo, \vindexname) \evalarrow \envthree\\
  \newg \eqdef \ordered{(\vgone \parallelcomp \vgtwo \parallelcomp \vgthree)}{\asldata}{ \ordered{\vgfour}{\aslpo}{\vgfive}   }\\
  \newenv \eqdef \envthree
}{
  {
  \begin{array}{r}
  \evalstmt{\env,
  \overname{
  \SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdir\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \velimitopt\\
  \end{array}\right\}}{\vs}} \evalarrow \\ \Continuing(\newg, \newenv)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EvalSForBegin}{\EvalSForEnd}{../Interpreter.ml}

\SemanticsRuleDef{EvalFor}
The relation
\hypertarget{def-evalfor}{}
\[
  \evalfor(
    \overname{\envs}{\env} \aslsep
    \overname{\Identifiers}{\vindexname} \aslsep
    \overname{\langle\tint\rangle}{\vlimitopt} \aslsep
    \overname{\tint}{\vstart} \aslsep
    \overname{\{\UP, \DOWN\}}{\dir} \aslsep
    \overname{\tint}{\vend} \aslsep
    \overname{\stmt}{\vbody})
  \;\aslrel\;
  \left(
    \begin{array}{cl}
    \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TContinuing}{\ContinuingConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup\\
    \overname{\TDynError}{\DynErrorConfig} &
    \end{array}
    \right)
\]
evaluates the \texttt{for} loop with the index variable $\vindexname$,
optional limit value $\vlimitopt$,
starting from the value
$\vstart$ going in the direction given by $\dir$ until the value given by $\vend$,
executing $\vbody$ on each iteration.
%
The evaluation utilizes two helper relations: $\evalforstep$ and $\evalforloop$.

\hypertarget{def-evalforstep}{}
The helper relation
\[
  \evalforstep(
    \overname{\envs}{\env},
    \overname{\Identifiers}{\vindexname},
    \overname{\langle\tint\rangle}{\vlimitopt} \aslsep
    \overname{\tint}{\vstart},
    \overname{\{\UP,\DOWN\}}{\dir})
    \;\aslrel\;
    ((\overname{\tint}{\vstep} \times \overname{\envs}{\newenv}) \times \overname{\XGraphs}{\newg})
\]
either increments or decrements the index variable,
returning the new value of the index variable, the modified environment,
and the resulting execution graph.

\hypertarget{def-evalforloop}{}
The helper relation
\[
  \evalforloop(\overname{
    \envs}{\env},
    \overname{\Identifiers}{\vindexname},
    \overname{\langle\tint\rangle}{\vlimitopt},
    \overname{\tint}{\vstart},
    \overname{\{\UP,\DOWN\}}{\dir},
    \overname{\tint}{\vend},
    \overname{\stmt}{\vbody}) \;\aslrel\;
    \left(
    \begin{array}{cl}
      \overname{\TContinuing}{\Continuing(\newg, \newenv)} & \cup\\
      \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup \\
    \overname{\TDynError}{\DynErrorConfig} &
    \end{array}
    \right)
\]
executes one iteration of the loop body and then uses $\texttt{eval\_for}$ to execute the remaining
iterations.

\subsubsection{Prose}
\subsubsection{Stepping the Index Variable}
All of the following apply:
\begin{itemize}
  \item $\opfordir$ is either $\PLUS$ when $\dir$ is $\UP$ or $\MINUS$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item applying the binary operator $\opfordir$ to $\vstart$ and the native integer for $1$ is $\vstep$;
  \item the execution graph for writing $\vstep$ into the identifier $\vindexname$ gives $\vgtwo$;
  \item updating the local component of the dynamic environment of $\env$ by binding \\ $\vindexname$ to $\vstep$
  gives $\newenv$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}

\subsubsection{Running the Loop Body}
All of the following apply:
\begin{itemize}
  \item evaluating $\vbody$ as a block statement (see \SemanticsRuleRef{Block}) in $\env$
        yields \\ $\Continuing(\vgone, \envone)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
  \item stepping the index $\vindexname$ with $\vstart$ and the direction $\dir$ in $\envone$,
        that is, $\evalforstep(\envone, \vindexname, \vlimitopt, \vstart, \dir)$ yields \\
        $((\vstep, \envtwo), \vgtwo)$;
  \item evaluating the \texttt{for} loop with $(\vindexname, \vlimitopt, \vstep, \dir, \vend, \vbody)$
        in $\envtwo$ results in a continuing configuration $\Continuing(\vgthree, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
  \item $\newg$ is the ordered composition of $\vgone$, $\vgtwo$, and $\vgthree$ with the $\aslpo$
        edge.
\end{itemize}

\subsubsection{Overall Evaluation}
\subsubsection{Example}
The specification in \listingref{semantics-sfor}
does not result in any assertion error, and terminates with exit-code $0$.

Evaluating $(\vindexname, \vstart, \dir, \vend, \vbody)$ in $\env$ is either
a continuing configuration $\Continuing(\newg, \newenv)$ or a returning configuration
(in case the body of the loop results in an early return)
or an abnormal configuration,
and All of the following apply:
\begin{itemize}
  \item \Proseticklooplimit{$\vlimitopt$}{$\vnextlimitopt$}\ProseOrError;
  \item $\compfordir$ is either $\LT$ when $\dir$ is $\UP$ or $\GT$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item One of the following applies:
    \begin{itemize}
    \item All of the following apply (\textsc{return}):
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native Boolean for $\True$;
      \item $\newg$ is $\vgone$;
      \item $\newenv$ is $\env$;
      \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}
    \item All of the following apply (\textsc{continue}):
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native Boolean for $\False$;
      \item evaluating the loop body via $\evalforloop$ with \\ $(\vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody)$
      in $\env$ is \\ $\Continuing(\vgtwo, \newenv)$\ProseTerminateAs{\ReturningConfig, \ThrowingConfig, \DynErrorConfig};
      \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
Advancing the loop counter one step towards the end of its range is achieved via the following rule:
\begin{mathpar}
\inferrule{
  \opfordir \eqdef \choice{\dir = \UP}{\PLUS}{\MINUS}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\
  \binoprel(\opfordir, \vstart, \nvint(1)) \evalarrow \vstep\\
  \writeidentifier(\vindex, \vstep) \evalarrow \vgtwo\\
  \env \eqname (\tenv, \denv)\\
  \newenv \eqdef (\tenv, (G^\denv, L^\denv[\vindexname\mapsto\vstep]))\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  {
    \begin{array}{r}
      \evalforstep(\env, \vindexname, \vlimitopt, \vstart, \dir) \evalarrow \\
      ((\vstep, \newenv), \newg)
    \end{array}
  }
}
\end{mathpar}

Running the loop body is achieved via the following rule:
\begin{mathpar}
\inferrule{
  \evalblock{\env, \vbody} \evalarrow \Continuing(\vgone, \envone) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig\\
  \evalforstep(\envone, \vindexname, \vlimitopt, \vstart, \dir) \evalarrow ((\vstep, \envtwo), \vgtwo)\\
  {
    \begin{array}{r}
      \evalfor(\envtwo, \vindexname, \vlimitopt, \vstep, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\vgthree, \newenv) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig
    \end{array}
  }\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\vgthree}
}{
  {
    \begin{array}{r}
      \evalforloop(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\newg, \newenv)
    \end{array}
  }
}
\end{mathpar}

Finally, the rules for evaluating a \texttt{for} loop utilize both $\evalforstep$
and \\
$\evalforloop$ (the latter in a mutually recursive manner):
\begin{mathpar}
\inferrule[return]{
  \ticklooplimit(\vlimitopt) \evalarrow \vnextlimitopt \OrDynError\\\\
  \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\\\
  \commonprefixline\\\\
  \binoprel(\compfordir, \vend, \vstart) \evalarrow \nvbool(\True)
}{
  {
    \begin{array}{r}
      \evalfor(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\overname{\vgone}{\newg}, \overname{\env}{\newenv})
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[continue]{
  \ticklooplimit(\vlimitopt) \evalarrow \vnextlimitopt \OrDynError\\\\
  \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
  \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\\\
  \commonprefixline\\\\
  \binoprel(\compfordir, \vend, \vstart) \evalarrow \nvint(\False)\\
  \evalforloop(\env, \vindexname, \vnextlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
  \Continuing(\vgtwo, \newenv) \terminateas \ReturningConfig, \ThrowingConfig, \DynErrorConfig\\\\
  \newg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
}{
  {
    \begin{array}{r}
      \evalfor(\env, \vindexname, \vlimitopt, \vstart, \dir, \vend, \vbody) \evalarrow \\
      \Continuing(\newg, \newenv)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EvalForBegin}{\EvalForEnd}{../Interpreter.ml}

\hypertarget{def-throwstatementterm}{}
\section{Throw Statements\label{sec:ThrowStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tthrow \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Tthrow \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SThrow(\expr?) &
\end{flalign*}

\ASTRuleDef{SThrow}
\begin{mathpar}
\inferrule[throw\_some]{}{
  \buildstmt(\overname{\Nstmt(\Tthrow, \Nexpr, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SThrow(\langle\astof{\vexpr}\rangle)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[throw\_none]{}{
  \buildstmt(\overname{\Nstmt(\Tthrow, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SThrow(\None)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SThrow}
\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vs$ is a throw statement with no expression, that is, $\SThrow(\None)$;
    \item $\news$ is $\vs$;
    \item $\newtenv$ is $\tenv$;
    \item \Proseeqdef{$\vses$}{the singleton set for $\ThrowException(\texttt{\_})$}
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\vs$ is a throw statement with expression $\ve$, that is, $\SThrow(\langle\ve\rangle)$;
    \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte, \vep, \vsesone)$\ProseOrTypeError;
    \item checking that $\vte$ has the structure of an exception type yields $\True$\ProseOrTypeError;
    \item view $\vte$ as the named type for $\exnname$;
    \item $\news$ is a throw statement with expression $\vep$ and type $\vte$, that is, \\
          $\SThrow(\langle (\vep, \vte) \rangle)$;
    \item $\newtenv$ is $\tenv$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesone$ and the singleton set for \\
          $\ThrowException(\exnname)$}.
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \annotatestmt(\tenv, \overname{\SThrow(\None)}{\vs}) \typearrow
  (\overname{\SThrow(\None)}{\news}, \overname{\tenv}{\newtenv}, \overname{\{\ThrowException(\texttt{\_})\}}{\vses})
}
\end{mathpar}
\lrmcomment{Note that \identr{BRCJ} is done in~\cite[SemanticsRule.TopLevel]{ASLSemanticsReference}.}

\begin{mathpar}
\inferrule[some]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep, \vsesone) \OrTypeError\\\\
  \checkstructurelabel(\tenv, \vte, \TException) \typearrow \True \OrTypeError\\\\
  \vte \eqname \TNamed(\exnname)\\
  \vses \eqdef \vsesone \cup \{\ThrowException(\exnname)\}
}{
  \annotatestmt(\tenv, \overname{\SThrow(\langle\ve\rangle)}{\vs}) \typearrow
  (\overname{\SThrow(\langle (\vep, \vte) \rangle)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\lrmcomment{This is related to \identr{NXRC}.}
\CodeSubsection{\SThrowBegin}{\SThrowEnd}{../Typing.ml}

\subsection{Semantics}
subsubsection{SemanticsRule.SThrow\label{sec:SemanticsRule.SThrow}}
\subsubsection{Example (Rethrowing an Exception)}
The specification in \listingref{semantics-sthrownone}
first catches the exception raised by \\
\verb|throw MyExceptionType{a=42}|
and then raises it in the catch clause via \verb|throw;|,
catching it again in the outer \texttt{try-catch} statement.
\ASLListing{Rethrowing an exception}{semantics-sthrownone}{\semanticstests/SemanticsRule.SThrowNone.asl}

\subsubsection{Example (Throwing a Typed Exception)}
The specification in \listingref{semantics-sthrowsometyped}
terminates successfully. That is, no dynamic error occurs.
\ASLListing{Throwing an exception}{semantics-sthrowsometyped}{\semanticstests/SemanticsRule.SThrowSomeTyped.asl}

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
  \item $\vs$ is a \texttt{throw} statement that does not provide an expression, $\SThrow(\None)$;
  \item $\newenv$ is $\env$;
  \item $\vex$ is $\None$;
  \item $\newg$ is the empty graph;
  \item an exception is thrown with $\newenv$.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\vs$ is a \texttt{throw} statement that provides an expression and a type, \\
          $\SThrow(\langle(\ve, \vt)\rangle)$;
    \item evaluating $\ve$ in $\env$ is $\Normal((\vv, \vgone), \newenv)$\ProseOrAbnormal;
    \item $\name$ is a fresh identifier (which conceptually holds the exception value);
    \item $\vgtwo$ is a Write Effect to $\name$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge;
    \item $\vex$ consists of the exception value $\vv$, the name of the variable holding it ---
          $\name$, and the type annotation for the exception --- $\vt$;
    \item the result of the entire evaluation is $\Throwing((\vex, \newg), \env)$.
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[none]{}
{
  \evalstmt{\env, \SThrow(\None)} \evalarrow \Throwing((\None, \emptygraph), \env)
}
\end{mathpar}
\begin{mathpar}
\inferrule[some]{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\
  \name\in\Identifiers \text{ is fresh}\\
  \vgtwo \eqdef \WriteEffect(\name)\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}\\
  \vex \eqdef \langle(\valuereadfrom(\vv, \name),\vt)\rangle
}{
  \evalstmt{\env, \SThrow(\langle(\ve, \vt)\rangle)} \evalarrow
  \Throwing((\vex, \newg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalSThrowBegin}{\EvalSThrowEnd}{../Interpreter.ml}

\hypertarget{def-trystatementterm}{}
\section{Try Statements\label{sec:TryStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Ttry \parsesep \Nstmtlist \parsesep \Tcatch \parsesep \ListOne{\Ncatcher} \parsesep \Notherwiseopt &\\
                  & \wrappedline\ \parsesep \Tend \parsesep \Tsemicolon &\\
\Notherwiseopt \derives\ & \Totherwise \parsesep \Tarrow \parsesep \Nstmtlist &\\
               |\ & \emptysentence &\\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \STry(\stmt, \catcher^*, \overtext{\stmt?}{otherwise}) &
\end{flalign*}

\ASTRuleDef{STry}
\begin{mathpar}
\inferrule{
  \buildlist[\Ncatcher] \astarrow \astversion{\vcatcherlist}
}{
  {
    \begin{array}{r}
  \buildstmt\left(\overname{\Nstmt\left(
    \begin{array}{r}
    \Ttry, \Nstmtlist, \Tcatch,  \\
    \wrappedline\ \namednode{\vcatcherlist}{\ListOne{\Ncatcher}}, \\
    \wrappedline\ \Notherwiseopt, \Tend, \Tsemicolon
    \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{\STry(\astof{\vstmtlist}, \astversion{\vcatcherlist}, \astof{\votherwiseopt})}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{OtherwiseOpt}
\hypertarget{build-otherwiseopt}{}
The function
\[
   \buildotherwiseopt(\overname{\parsenode{\Notherwiseopt}}{\vparsednode}) \aslto
    \overname{\langle\stmt\rangle}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[non\_empty]{
  \buildstmtlist(\vstmts) \astarrow \astversion{\vstmts}
}{
  {
  \begin{array}{r}
    \buildotherwiseopt(\overname{\Notherwiseopt(\Totherwise, \Tarrow, \namednode{\vstmts}{\Nstmtlist})}{\vparsednode}) \astarrow\\
    \astversion{\vstmts}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty]{}{
  \buildotherwiseopt(\overname{\Notherwiseopt(\emptysentence)}{\vparsednode}) \astarrow \None
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{STry}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a try statement with statement $\vsp$, list of catchers $\catchers$ and an \optional\ \texttt{otherwise} block;
  \item annotating the statement $\vsp$ as a block statement yields $(\vspp, \vsesone)$\ProseOrTypeError;
  \item annotating each catcher $\catchers[\vi]$, for each $\vi$ in $\listrange(\catchers)$ in $\tenv$ yields $\vc\_\vi$
        and $\vxs_i$\ProseOrTypeError;
  \item $\catchersp$ is the list of annotated catchers $\vc\_\vi$ for each $\vi\in\listrange(\catchers)$;
  \item \Proseeqdef{$\vsescatchers$}{the union of all $\vxs_\vi$, for \Proselistrange{$\vi$}{$\catchers$}};
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{no\_otherwise}):
    \begin{itemize}
      \item there is no \texttt{otherwise} statement;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and no \texttt{otherwise} statement,
            that is \\
            $\STry(\vspp, \catchersp, \None)$;
      \item \Proseeqdef{$\vsesotherwise$}{the empty set};
      \item \Proseeqdef{$\vsesthree$}{$\vsestwo$}.
    \end{itemize}

    \item All of the following apply (\textsc{otherwise}):
    \begin{itemize}
      \item there is an \texttt{otherwise} statement $\otherwise$;
      \item annotating the statement $\otherwise$ as a block statement in $\tenv$ yields $\otherwisep$\ProseOrTypeError;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and \texttt{otherwise} statement
            $\otherwisep$, that is \\
            $\STry(\vspp, \catchersp, \langle\otherwisep\rangle)$;
      \item \Proseeqdef{$\vsesotherwise$}{$\vsesblock$};
      \item \Proseeqdef{$\vsesthree$}{$\vsestwo$, excluding any \ThrowExceptionTerm}.
    \end{itemize}

    \item \Proseeqdef{$\vses$}{the union of $\vsesthree$, $\vsescatchers$, and $\vsesotherwise$}.
  \end{itemize}
  \item $\newtenv$ is $\tenv$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[no\_otherwise]{
  \annotateblock{\tenv, \vsp} \typearrow (\vspp, \vsesone) \OrTypeError\\\\
  \vi\in\listrange(\catchers): \annotatecatcher{\tenv, \catchers[\vi]} \typearrow (\vc_\vi, \vxs_vi) \OrTypeError\\\\
  \catchersp \eqdef [\vi\in\listrange(\catchers) : \vc_\vi]\\\\
  \vsescatchers \eqdef \bigcup_{\vi\in\listrange(\catchers)} \vxs_vi\\\\
  \commonprefixline\\\\
  \news \eqdef \STry(\vspp, \catchersp, \None)\\
  \vsesotherwise \eqdef \emptyset\\
  \vsesthree \eqdef \vsestwo\\\\
  \commonsuffixline\\\\
  \vses \eqdef \vsesthree \cup \vsescatchers \cup \vsesotherwise
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \None)}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv}, \vses)
}
\and
\inferrule[otherwise]{
  \annotateblock{\tenv, \vsp} \typearrow (\vspp, \vsesone) \OrTypeError\\\\
  \vi\in\listrange(\catchers): \annotatecatcher{\tenv, \catchers[\vi]} \typearrow (\vc_\vi, \vxs_vi) \OrTypeError\\\\
  \catchersp \eqdef [\vi\in\listrange(\catchers) : \vc_\vi]\\\\
  \vsescatchers \eqdef \bigcup_{\vi\in\listrange(\catchers)} \vxs_i\\\\
  \commonprefixline\\\\
  \annotateblock{\tenv, \otherwise} \typearrow (\otherwisep, \vsesblock) \OrTypeError\\\\
  \news \eqdef \STry(\vspp, \catchersp, \otherwise')\\
  \vsesotherwise \eqdef \vsesblock\\
  \vsesthree \eqdef \vsestwo \setminus \{ \vs \in \TSideEffectSet \;|\; \configdomain{\vs} = \ThrowException\} \\\\
  \commonsuffixline\\\\
  \vses \eqdef \vsescatchers \cup \vsesotherwise
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \langle\otherwise\rangle)}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\STryBegin}{\STryEnd}{../Typing.ml}
\lrmcomment{This is related to \identr{WVXS}.}

\subsection{Semantics}
\SemanticsRuleDef{STry}
\subsubsection{Example}
Evaluating the specification in \listingref{semantics-stry}
does not result in any Assertion error, and the specification terminates with the exit code $0$.
\ASLListing{Evaluating a \texttt{try} statement}{semantics-stry}{\semanticstests/SemanticsRule.STry.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{try} statement, $\STry(\vs, \catchers, \otherwiseopt)$;
  \item evaluating $\vsone$ in $\env$ as per \chapref{BlockStatements}
  is a non-abnormal (that is, either $\Normal$ or $\Continuing$) configuration $\sm$\ProseOrAbnormal;
  \item evaluating $(\catchers, \otherwiseopt, \sm)$ as per \chapref{CatchingExceptions}
  is $C$, which is the result of the entire evaluation.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalblock{\env, \vsone} \evalarrow \sm \OrAbnormal\\
  \evalcatchers{\env, \catchers, \otherwiseopt, \sm} \evalarrow C
}{
  \evalstmt{\env, \STry(\vsone, \catchers, \otherwiseopt)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalSTryBegin}{\EvalSTryEnd}{../Interpreter.ml}

\hypertarget{def-returnstatementterm}{}
\section{Return Statements\label{sec:ReturnStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Treturn \parsesep \option{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
  \stmt \derives\ & \SReturn(\expr?) &
\end{flalign*}

\ASTRuleDef{SReturn}
\begin{mathpar}
\inferrule{
  \buildoption[\Nexpr](\vexpr) \astarrow \astversion{\vexpr}
}{
  \buildstmt(\overname{\Nstmt(\Treturn, \namednode{\vexpr}{\option{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SReturn(\astversion{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{SReturn}
\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with an optional expression $\veopt$, that is, \\
          $\SReturn(\veopt)$;
    \item the condition that $\veopt$ is $\None$ if and only if the enclosing subprogram does not have a return type
          (that is, $\returntype$ in the local static environment is $\None$) does not hold;
    \item the result is an error indicating the mismatch between the declared (existence of the) return type
          and the (existence of the) return expression.
  \end{itemize}

  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
    \item the enclosing subprogram does not have a \texttt{return} type (it is either a setter
          or a procedure);
    \item $\news$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
    \item $\newtenv$ is $\tenv$;
    \item \Proseeqdef{$\vses$}{the empty set}.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement with an expression $\ve$, that is, $\SReturn(\langle \vep \rangle)$;
    \item the enclosing subprogram has a return type $\vt$;
    \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tep,\vep,\vses)$\ProseOrTypeError;
    \item checking whether $\vtep$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\news$ is a \texttt{return} statement with value $\vep$, that is, $\SReturn(\langle \vep \rangle)$;
    \item $\newtenv$ is $\tenv$.
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[error]{
  \vb \eqdef (L^\tenv.\returntype = \None \leftrightarrow \veopt = \None) \\
  \vb = \False
}{
  \annotatestmt(\tenv, \overname{\SReturn(\veopt)}{\vs}) \typearrow \TypeErrorVal{\BadSubprogramDeclaration}
}
\end{mathpar}

\begin{mathpar}
\inferrule[none]{
  L^\tenv.\returntype = \None
}{
  \annotatestmt(\tenv, \overname{\SReturn(\None)}{\vs}) \typearrow
  (\overname{\SReturn(\None)}{\news}, \overname{\tenv}{\newtenv}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  L^\tenv.\returntype = \langle \vt \rangle\\
  \annotateexpr{\tenv, \ve} \typearrow (\vtep, \vep, \vses) \OrTypeError\\\\
  \checktypesat(\tenv, \vtep, \vt) \typearrow \True \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SReturn(\langle \ve \rangle)}{\vs}) \typearrow
  (\overname{\SReturn(\langle \vep \rangle)}{\news}, \overname{\tenv}{\newtenv}, \vses)
}
\end{mathpar}
\CodeSubsection{\SReturn}{\SReturnEnd}{../Typing.ml}
\lrmcomment{This is related to \identr{FTPK}.}

\subsection{Semantics}
\SemanticsRuleDef{SReturn}
\subsubsection{Example (No Return Value)}
The specification in \listingref{semantics-sreturn} exits the procedure \texttt{println\_me}
by evaluating the \texttt{return;} statement.
\ASLListing{Evaluating a \texttt{return} statement with no value}{semantics-sreturn}{\semanticstests/SemanticsRule.SReturnNone.asl}

\subsubsection{Example (Returning a Single Value)}
In \listingref{semantic-ssreturnone},
\texttt{return 3;} exits the function \texttt{f} with value \texttt{3}.
\ASLListing{Evaluating a \texttt{return} statement with a single value}{semantic-ssreturnone}{\semanticstests/SemanticsRule.SReturnOne.asl}

\subsubsection{Example (Returning a Tuple of Values)}
In \listingref{semantics-sreturntuple},
\texttt{return (3, 42);} exits the function \texttt{f} with the value \texttt{(3, 42)}.
\ASLListing{Evaluating a \texttt{return} statement with a tuple of values}{semantics-sreturntuple}{\semanticstests/SemanticsRule.SReturnSome.asl}

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement, $\SReturn(\None)$;
    \item $\vvs$ is the empty list, $\emptylist$;
    \item $\newg$ is the empty graph;
    \item $\newenv$ is $\env$.
  \end{itemize}

  \item All of the following apply (\textsc{one}):
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement;
    \item $\vs$ is a \texttt{return} statement for a single expression, $\SReturn(\langle\ve\rangle)$;
    \item evaluating $\ve$ in $\env$ is $\Normal((\vv, \vgone), \newenv)$\ProseOrAbnormal;
    \item $\vvs$ is $[\vv]$;
    \item $\vgtwo$ is the result of adding a Write Effect for a fresh identifier and the value $\vv$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\vs$ is a \texttt{return} statement for a list of expressions, $\SReturn(\langle\ETuple(\es)\rangle)$;
    \item evaluating each expression in $\es$ separately as per \secref{SemanticsRule.EExprListM}
    is \\ $\Normal(\ms, \newenv)$\ProseOrAbnormal;
    \item writing the list of values in $\vms$ results in $(\vvs, \newg)$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[none]{}
{
  \evalstmt{\env, \SReturn(\None)} \evalarrow \Returning((\emptylist, \emptygraph), \env)
}
\end{mathpar}

\begin{mathpar}
\inferrule[one]{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \wid \in \Identifiers\text{ is fresh}\\
  \writeidentifier(\wid, \vv) \evalarrow \vgtwo\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalstmt{\env, \SReturn(\langle\ve\rangle)} \evalarrow \Returning(([\vv], \newg), \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \evalexprlistm(\env, \es) \evalarrow \Normal(\ms, \newenv) \OrAbnormal\\
  \writefolder(\ms) \evalarrow (\vvs, \newg)
}{
  \evalstmt{\env, \SReturn(\langle\ETuple(\es)\rangle)} \evalarrow \Returning((\vvs, \newg), \newenv)
}
\end{mathpar}
\CodeSubsubsection{\SReturnBegin}{\EvalSReturnEnd}{../Interpreter.ml}

\SemanticsRuleDef{EExprListM}
\hypertarget{def-evalexprlistm}{}
The helper relation
\[
  \evalexprlistm(\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vEs}) \;\aslrel\;
          \Normal(\overname{(\vals\times\XGraphs)^* }{\vms} \aslsep \overname{\envs}{\newenv}) \cup
          \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates a list of expressions $\vEs$ in left-to-right in the initial environment $\env$
and returns the list of values associated with graphs $\vms$ and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\vEs$ is an empty list;
    \item $\vms$ is then empty list.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\vEs$ is a list with \head\ $\ve$ and \tail\ $\vesone$;
    \item evaluating $\ve$ in $\env$ yields $\Normal(\vmone, \envone)$\ProseOrAbnormal;
    \item evaluating $\vesone$ in $\envone$ via $\evalexprlistm$ yields \\
          $\Normal(\vmsone, \newenv)$\ProseOrAbnormal;
    \item the result is the normal configuration with the list consisting of $\vmone$ as its \head\ and $\vmsone$
          as its \tail\ and $\newenv$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \evalexprlistm(\env, \overname{\emptylist}{\vEs}) \evalarrow \Normal(\overname{\emptylist}{\vms}, \overname{\env}{\newenv})
}
\end{mathpar}

\subsubsection{Semantics}
\begin{mathpar}
\inferrule[non\_empty]{
  \vEs \eqname [\ve] \concat \vesone\\
  \evalexpr{\env, \ve} \evalarrow \Normal(\vmone, \envone) \OrAbnormal\\
  \evalexprlistm(\envone, \vesone) \evalarrow \Normal(\vmsone, \newenv) \OrAbnormal
}{
  \evalexprlistm(\env, \vEs) \evalarrow \Normal([\vmone]\concat\vmsone, \newenv)
}
\end{mathpar}

\SemanticsRuleDef{WriteFolder}
\hypertarget{def-writefolder}{}
The helper relation
\[
  \writefolder(\overname{(\vals\times\XGraphs)^*}{\vms}) \aslrel (\overname{\vals^*}{\vvs}, \overname{\XGraphs}{\newg}) \enspace,
\]
concatenates the input values in $\vms$ and generates an execution graph
by composing the graphs in $\vms$ with Write Effects for the respective values.

\begin{mathpar}
\inferrule[empty]{}{
  \writefolder(\emptylist) \evalarrow (\emptylist, \emptygraph)
}
\and
\inferrule[nonempty]{
  \vms \eqname [\vm] \concat \vmsone\\
  \vm \eqdef (\vv, \vg)\\
  \wid \in \Identifiers\text{ is fresh}\\
  \writeidentifier(\wid, \vv) \evalarrow \vgone\\
  \writefolder(\vmsone, \vgone) \evalarrow (\vvsone, \vgtwo)\\
  \vvs \eqdef [\vv] \concat \vvsone\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \writefolder(\vms) \evalarrow (\vvs, \ordered{\vg}{\aslpo}{\newg})
}
\end{mathpar}

\hypertarget{def-printstatementterm}{}
\section{Print Statements\label{sec:PrintStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tprint \parsesep \PlistZero{\Nexpr} \parsesep \Tsemicolon & \\
\Nstmt \derives \ & \Tprintln \parsesep \PlistZero{\Nexpr} \parsesep \Tsemicolon & \\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
  \stmt \derives\ & \SPrint(\overtext{\expr^*}{args}, \overtext{\Bool}{newline}) &
\end{flalign*}

\ASTRuleDef{SPrint}
\begin{mathpar}
\inferrule{%
  \buildplist[\Nexpr](\vargs) \astarrow \astversion{\vargs} \\
  \vnewline \eqdef \False \\
}{%
  \buildstmt(\overname{\Nstmt(\Tprint, \namednode{\vargs}{\PlistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPrint(\astversion{\vargs}, \vnewline)}{\vastnode}
}
\\
\inferrule{%
  \buildplist[\Nexpr](\vargs) \astarrow \astversion{\vargs} \\
  \vnewline \eqdef \True \\
  \vdebug \eqdef \False \\
}{%
  \buildstmt(\overname{\Nstmt(\Tprintln, \namednode{\vargs}{\PlistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SPrint(\astversion{\vargs}, \vnewline)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}

\TypingRuleDef{SPrint}
\paragraph{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ denotes the print statement with arguments $\vargs$ and newline indicator $\vnewline$;
  \item annotating for each \Proselistrange{$i$}{$\vargs$}, the expression $\vargs_i$ in $\tenv$ yields $(\vt_i, \vargsp_i, \vxs_i)$\ProseOrTypeError;
  \item checking for each \Proselistrange{$i$}{$\vargs$}, that $\vt_i$ is a singular type yields $\True$\ProseOrTypeError;
  \item $\news$ denotes the print statement with arguments $\vargsp$ and newline indicator $\vnewline$;
  \item $\newtenv$ is $\tenv$;
  \item \Prosenonconflictingunion{$\vxs_i$, \Proselistrange{$i$}{$\vargs$}, }{$\vses$}\ProseOrTypeError.
\end{itemize}

\paragraph{Formally}
\begin{mathpar}
  \inferrule{%
    \vi\in\listrange(\vargs): \annotateexpr{\vargs[i], \tenv} \typearrow (\vt_i, \vargsp[i], \vxs_i)\OrTypeError \\\\
    \vi\in\listrange(\vargs): \checktrans{\issingular(\vt_i)}{\UnexpectedType} \typearrow \True \OrTypeError \\\\
    \nonconflictingunion([\vi\in\listrange(\vargs): \vxs_i]) \typearrow \vses \OrTypeError
  }{%
    \annotatestmt (\tenv, \overname{\SPrint(\vargs, \vnewline)}{\vs}) \typearrow (\SPrint(\vargsp, \vnewline), \tenv, \vses)
  }
\end{mathpar}
\CodeSubsection{\SPrintBegin}{\SPrintEnd}{../Typing.ml}

\subsection{Semantics}

Not all ASL backends support printing to a console.
%
Therefore, the semantics is parameterized by the function $\outputtoconsole$,
which takes a string and communicates it to a console, where one exists.%
\footnote{%
  Formally, the console can be modelled by adding a string-typed component to
  the global dybamic environment, which concatenates all strings that were sent
  to it. For brevity, and since it is only used for print statements, we omit
  this component from our definition of a dynamic environment.%
}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ denotes a Print statement with arguments $\elist$ and newline indicator $\vnewline$;
  \item the evaluation of $\elist$ in $\env$ is $\Normal((\vlist, \vg), \newenv)$\ProseOrAbnormal;
  \item \hyperlink{def-outputtoconsole}{prints} all the elements in $\elist$, without separator;
  \item if $\vnewline$ is $\True$, prints a newline character;
  \item $\newenv$ is $\env$.
\end{itemize}

\subsubsection{Formally}

\begin{mathpar}
  \inferrule[Print]{%
    \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \newenv) \OrAbnormal\\
    \vi\in\listrange(\vlist): \outputtoconsole(\vlist[i]) \\
  }{%
    \evalstmt{\env, \SPrint(\elist, \False)} \evalarrow \Continuing(\vg, \newenv)
  }
  \\
  \inferrule[Println]{%
    \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \newenv) \OrAbnormal\\
    \vi\in\listrange(\vlist): \outputtoconsole(\vlist[i]) \\
    \outputtoconsole(\lstring(\texttt{"\char`\\n"})) \\
  }{%
    \evalstmt{\env, \SPrint(\elist, \True)} \evalarrow \Continuing(\vg, \newenv)
  }
\end{mathpar}
\CodeSubsection{\EvalSPrintBegin}{\EvalSPrintEnd}{../Interpreter.ml}

\hypertarget{def-unreachablestatementterm}{}
\section{The Unreachable Statement\label{sec:UnreachableStatement}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tunreachable \parsesep \Tlpar \parsesep \Trpar \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SUnreachable &
\end{flalign*}

\ASTRuleDef{SUnreachable}
\begin{mathpar}
\inferrule{}{
  \buildstmt(\overname{\Nstmt(\Tunreachable, \Tlpar, \Trpar, \Tsemicolon)}{\vparsednode})
  \astarrow
  \overname{\SUnreachable}{\vastnode}
}
\end{mathpar}

\TypingRuleDef{SUnreachable}
\subsubsection{Prose}
Annotating $\SUnreachable$ in the static environment $\tenv$ yields $(\SUnreachable, \tenv, \emptyset)$.

\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \annotatestmt(\tenv, \SUnreachable) \typearrow (\SUnreachable, \tenv, \overname{\emptyset}{\vses})
}
\end{mathpar}

\SemanticsRuleDef{SUnreachable}
\subsubsection{Prose}
Evaluating $\SUnreachable$ in an environment $\env$ results in a dynamic error indicating this ($\UnreachableError$).
\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \evalstmt{\env, \SUnreachable} \evalarrow \DynamicErrorVal{\UnreachableError}
}
\end{mathpar}

\hypertarget{def-pragmastatementterm}{}
\section{Pragma Statements\label{sec:PragmaStatements}}
\subsection{Syntax}
\begin{flalign*}
\Nstmt \derives \ & \Tpragma \parsesep \Tidentifier \parsesep \ClistZero{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\stmt \derives\ & \SPragma(\Tidentifier, \overtext{\expr^*}{args}) &
\end{flalign*}

\ASTRuleDef{SPragma}
\begin{mathpar}
\inferrule{
  \buildclist[\Nexpr](\vargs) \astarrow \astversion{\vargs}
}{
    \buildstmt(\overname{\Nstmt(\Tpragma, \Tidentifier(\id), \namednode{\vargs}{\ClistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow
    \overname{\SPragma(\id, \astversion{\vargs})}{\vastnode}
}
\end{mathpar}

\TypingRuleDef{SPragma}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a pragma statement with identifier $\id$ and expression list $\vargs$. that is, $\SPragma(\id, \vargs)$;
  \item for each \Proselistrange{$i$}{$\vargs$}, \Proseannotateexpr{$\tenv$}{$\vargs[i]$}{$(\Ignore, \Ignore, \vxs_i)$}\ProseOrTypeError;
  \item define $\vsess$ as the list of $\vxs_i$m \Proselistrange{$i$}{$\vargs$};
  \item define $\news$ as the \passstatementterm, that is, $\SPass$
  \item $\newtenv$ is $\tenv$;
  \item \Prosenonconflictingunion{$\vsess$}{$\vses$}\ProseOrTypeError.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  i\in\listrange(\vargs): \annotateexpr{\tenv, \vargs[i]} \typearrow (\Ignore, \Ignore, \vxs_i) \OrTypeError\\\\
  \vsess \eqdef [i\in\listrange(\vargs): \vxs_i]\\
  \nonconflictingunion(\vsess) \typearrow \vses \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SPragma(\id, \vargs)}{\vs}) \typearrow (\overname{\SPass}{\news}, \tenv)
}
\end{mathpar}
\CodeSubsection{\SPragmaBegin}{\SPragmaEnd}{../Typing.ml}

\subsection{Semantics\label{sec:PragmaSemantics}}

\subsubsection{Prose}
Pragmas are structures present in the \untypedast \ which are designed to be used
by third-party tools.

To avoid conflicts between different ASL parsers, it is recommended that the pragma's identifier $\Tidentifier(\id)$ be prefixed by the name of the ASL tool that supports that pragma
(e.g. ARM for Arm's internal ASL tools). An ASL language processor that does not recognise a pragma directive should generate a warning for that pragma.

Pragmas are not associated with semantics and are discarded from the \typedast.
