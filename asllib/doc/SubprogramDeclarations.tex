\chapter{Subprogram Declarations\label{chap:SubprogramDeclarations}}

The \Tfunc{} keyword declares a subprogram. If a return type is included it is a \emph{function declaration},
otherwise it is a \emph{procedure declaration}. \identr{RXHX}

\ExampleDef{Subprogram Declarations}
In \listingref{SubprogramDeclarations}, \verb|Add| is a function whereas \verb|IncrementCounter| is a procedure.
\ASLListing{Subprogram declarations}{SubprogramDeclarations}{\definitiontests/SubprogramDeclarations.asl}

\listingref{ParametricFunction} shows an example of a parametric function \verb|f| and its invocations.
\ASLListing{Invoking a parametric function}{ParametricFunction}{\definitiontests/ParametricFunction.asl}

\listingref{ParametricFunction2} shows an example of a parametric function \verb|append| and its invocations.
\ASLListing{Invoking a parametric function}{ParametricFunction2}{\definitiontests/ParametricFunction2.asl}

\ChapterOutline
\begin{itemize}
  \item \secref{Accessors} discusses \emph{accessors};
  \item \FormalRelationsRef{Subprogram Declarations} defines the formal relations for subprogram declarations;
  \item \SyntaxRef{Subprogram Declarations} defines the syntax of subprogram declarations;
  \item \AbstractSyntaxRef{Subprogram Declarations} defines the abstract syntax of subprogram declarations; and
  \item \TypeRulesRef{Subprogram Declarations} defines the type rules for subprogram declarations.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Accessors\label{sec:Accessors}}
Special kinds of subprograms are \emph{getters} and \emph{setters}, which are paired to form an \emph{accessor}
declaration. Intuitively, an accessor is used to abstract reading and writing to a global storage datatype.

\listingref{AccessorDeclaration} shows an accessor declaration.
The accessor \texttt{X} is used to read and write underlying storage element \texttt{R}.
For example, this could model a register file consisting of 32 registers, each of 64-bits, the last of which is always zero.

\ASLListing{An accessor declaration}{AccessorDeclaration}{\definitiontests/Accessor.asl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Subprogram Declarations}
\paragraph{Syntax:} Subprogram declarations are grammatically derived from $\Ndecl$ via the subset of productions shown in
  \SyntaxRef{Subprogram Declarations}.

\paragraph{Abstract Syntax:} Subprogram declarations are derived in the abstract syntax from $\decl$
  and generated by $\builddecl$ (see \AbstractSyntaxRef{Subprogram Declarations}).

\paragraph{Typing:} Subprogram declarations are annotated via $\annotateanddeclarefunc$ (see \TypingRuleRef{AnnotateAndDeclareFunc});

\paragraph{Semantics:} The dynamic semantics of subprogram calls is given in \chapref{SubprogramCalls}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SyntaxDef{Subprogram Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\RequirementDef{NoEmptyBody}
Subprograms may not have empty bodies.
To define a subprogram whose body has no effect, a \passstatementterm{} can be used.
For example, \listingref{NoEmptyBody} shows a subprogram declaration whose body has no effect.
\ASLListing{A pass statement can be used to define a subprogram body with no effect}{NoEmptyBody}{\definitiontests/GuideRule.NoEmptyBody.asl}

\begin{flalign*}
\Ndecl  \derives \ & \Npuritykeyword \parsesep \Noverride \parsesep \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs &\\
    &\wrappedline \Nreturntype \parsesep \Nrecurselimit \parsesep \Nfuncbody\\
|\ & \Nqualifier \parsesep \Noverride \parsesep \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs &\\
    &\wrappedline \Nrecurselimit \parsesep \Nfuncbody &\\
|\ & \Noverride \parsesep \Taccessor \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Tbeq \parsesep \Tidentifier \parsesep \Nasty &\\
   & \wrappedline\ \Naccessorbody &\\
\Naccessorbody \derives \ & \Tbegin \parsesep \Naccessors \parsesep \Tend \parsesep \Tsemicolon&
\end{flalign*}

\begin{flalign*}
\Nrecurselimit   \derives \ & \Trecurselimit \parsesep \Nexpr &\\
|\              & \emptysentence &\\
\Nparamsopt \derives \ & \emptysentence &\\
                   |\ & \Tlbrace \parsesep \ClistZero{\Nopttypedidentifier} \parsesep \Trbrace &\\
\Nopttypedidentifier \derives \ & \Tidentifier \parsesep \option{\Nasty} &\\
\Nfuncargs          \derives \ & \Tlpar \parsesep \ClistZero{\Ntypedidentifier} \parsesep \Trpar &\\
\Nreturntype        \derives \ & \Tarrow \parsesep \Nty &\\
\Nfuncbody          \derives \ & \Tbegin \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Nstmtlist \derives \ & \emptysentence \;|\; \Nstmtlist &\\
  \Naccessors \derives \ &
    \Nisreadonly \parsesep \Tgetter \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon \parsesep \\ & \wrappedline
    \Tsetter \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
  |\ & \Tsetter \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon \parsesep \\ & \wrappedline
      \Nisreadonly \parsesep \Tgetter \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Nqualifier \derivesinline\ & \emptysentence \;|\; \Tpure \;|\;\Treadonly \;|\;\Tnoreturn &\\
\Npuritykeyword \derivesinline\ & \emptysentence \;|\; \Tpure \;|\;\Treadonly &\\
\Nisreadonly \derivesinline\ & \emptysentence \;|\; \Treadonly &\\
\Noverride \derivesinline\ & \emptysentence \;|\; \Timpdef \;|\;\Timplementation &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\AbstractSyntaxDef{Subprogram Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RenderTypes[remove_hypertargets]{decl_func}
\BackupOriginalAST{
\begin{flalign*}
\decl \derives\ & \DFunc(\func) &
\end{flalign*}

\begin{flalign*}
\func \derives\ &
{
\left\{
  \begin{array}{rcl}
 \funcname &:& \Strings, \\
 \funcparameters &:& \KleeneStar{(\identifier, \ty?)},\\
 \funcargs &:& \KleeneStar{\typedidentifier},\\
 \funcbody &:& \stmt,\\
 \funcreturntype &:& \ty?,\\
 \funcsubprogramtype &:& \subprogramtype,\\
 \funcrecurselimit    &:& \expr?\\
 \funcbuiltin &:& \Bool\\
 \funcqualifier &:& \Some{\qualifier}\\
 \funcoverride &:& \Some{\overrideinfo}\\
\end{array}
\right\}
} &\\
\typedidentifier \derives\ & (\identifier, \ty) &\\
\subprogramtype \derives\ & \STProcedure \;|\; \STFunction &\\
                |\  & \STGetter \;|\; \STSetter &\\
\qualifier \derives\ & \Pure \;|\; \Readonly \;|\; \Noreturn &\\
\overrideinfo \derives\ & \Impdef \;|\; \Implementation &
\end{flalign*}
}

\ASTRuleDef{SubprogramDecl}
This rule defines the cases for $\builddecl$ for subprogram declarations.

We first define $\accessorpair$, which we use in this section as an intermediate representation between the syntax forms of accessors and their corresponding abstract syntax.
In particular, rather than directly building the abstract syntax for accessors, we first build an $\accessorpair$ structure, which we then desugar into abstract syntax.

\hypertarget{ast-accessorpair}{}
\begin{flalign*}
\accessorpair \derives\ &
{
\left\{
  \begin{array}{rcl}
    \accessorpairisreadonly &:& \Bool, \\
    \accessorpairgetter &:& \stmt, \\
    \accessorpairsetter &:& \stmt
\end{array}
\right\}
} &
\end{flalign*}

\begin{mathpar}
\inferrule[func\_decl]{
  \buildqualifier(\vp) \astarrow \astversion{\vp}
}{
  \builddecl\left(
    \overname{\Ndecl\left(
      \begin{array}{l}
    \namednode{\vp}{\Npuritykeyword}, \punnode{\Noverride}, \Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \\
    \wrappedline\ \punnode{\Nfuncargs}, \punnode{\Nreturntype}, \punnode{\Nrecurselimit}, \punnode{\Nfuncbody}
      \end{array}
  \right)}{\vparsednode}\right)
\astarrow \\
{
    \overname{
  \left[\DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \astof{\vfuncbody},\\
            \funcreturntype &:& \some{ \astof{\vreturntype} },\\
            \funcsubprogramtype &:& \STFunction,\\
            \funcrecurselimit   &:& \astof{\vrecurselimit}\\
            \funcbuiltin &:& \False\\
            \funcqualifier &:& \astversion{\vp}\\
            \funcoverride &:& \astof{\voverride}
    \end{array}
  \right\}\right)\right]}{\vastnode}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[procedure\_decl]{}{
  \builddecl\left(
    \overname{\Ndecl\left(
      \begin{array}{l}
      \punnode{\Nqualifier}, \punnode{\Noverride}, \Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \\
      \wrappedline\ \punnode{\Nfuncargs}, \punnode{\Nrecurselimit}, \punnode{\Nfuncbody}
      \end{array}
      \right)}{\vparsednode}
    \right)
  \astarrow \\
  {
    \overname{
  \left[\DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \astof{\vfuncbody},\\
            \funcreturntype &:& \None,\\
            \funcsubprogramtype &:& \STProcedure,\\
            \funcrecurselimit   &:& \astof{\vrecurselimit}\\
            \funcbuiltin &:& \False\\
            \funcqualifier &:& \astof{\vqualifier}\\
            \funcoverride &:& \astof{\voverride}
    \end{array}
  \right\}\right)\right]
    }{\vastnode}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[accessor]{
  \buildaccessorbody(\vbody) \astarrow \vaccessorpair \\
  {
  \desugaraccessorpair\left(
    \begin{array}{l}
    \voverride,\\
    \name,\\
    \astof{\vparamsopt},\\
    \astof{\vfuncargs},\\
    \vsetterarg,\\
    \astof{\tty},\\
    \vaccessorpair
    \end{array}
    \right) \astarrow \vastnode
  }
}{
  {
  \begin{array}{r}
    \builddecl\left(\overname{\Ndecl\left(
      \begin{array}{l}
        \punnode{\Noverride}, \Taccessor, \Tidentifier(\name), \punnode{\Nparamsopt},  \\
        \wrappedline\ \punnode{\Nfuncargs},
        \Tbeq, \Tidentifier(\vsetterarg), \punnode{\Nasty}, \namednode{\vbody}{\Naccessorbody}
      \end{array}
    \right)}{\vparsednode}\right)
  \\ \astarrow \vastnode
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{AccessorBody}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-accessorbody}{}
The relation
\[
  \buildaccessorbody : \overname{\parsenode{\Naccessorbody}}{\vparsednode} \;\aslrel\; \overname{\accessorpair}{\vaccessorpair}
\]
transforms a parse node $\vparsednode$ into an $\accessorpair$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildaccessors(\vaccessors) \astarrow \vaccessorpair
}{
    \buildaccessorbody\left(\overname{\Ndecl\left(
      \begin{array}{l}
        \Tbegin, \namednode{\vaccessors}{\Naccessors}, \Tend, \Tsemicolon
      \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \vaccessorpair
}
\end{mathpar}

\ASTRuleDef{RecurseLimit}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-recurselimit}{}
The function
\[
\buildrecurselimit(\overname{\parsenode{\Nrecurselimit}}{\vparsednode}) \aslto \overname{\Option{\expr}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\Trecurselimit, \punnode{\Nexpr})}{\vparsednode}\right)
  \astarrow
  \overname{\some{\astof{\vexpr}}}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\emptysentence)}{\vparsednode}\right)
  \astarrow
  \overname{\None}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{TypedIdentifier}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-typedidentifier}{}
The function
\[
\buildtypedidentifier(\overname{\parsenode{\Ntypedidentifier}}{\vparsednode}) \aslto \overname{(\Identifier \times \ty)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{}{
  \buildtypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \punnode{\Nasty})}{\vparsednode}) \astarrow \overname{(\id,\astof{\vasty})}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{OptTypedIdentifier}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-opttypedidentifier}{}
The function
\[
\buildopttypedidentifier(\overname{\parsenode{\Nopttypedidentifier}}{\vparsednode}) \aslto \overname{(\Identifier \times \Option{\ty})}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildoption[\Nasty](\vastyopt) \astarrow \astversion{\vastyopt}
}{
  {
  \begin{array}{r}
  \buildopttypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \namednode{\vastyopt}{\option{\Nasty}})}{\vparsednode}) \astarrow \\
  \overname{(\id, \astversion{\vastyopt})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{ReturnType}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-returntype}{}
The function
\[
\buildreturntype(\overname{\parsenode{\Nreturntype}}{\vparsednode}) \aslto \overname{\ty}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{}{
  \buildreturntype(\overname{\Nreturntype(\Tarrow, \punnode{\Nty})}{\vparsednode}) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{ParamsOpt}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-paramsopt}{}
The function
\[
\buildparamsopt(\overname{\parsenode{\Nparamsopt}}{\vparsednode}) \aslto
  \overname{\KleeneStar{(\Identifier\times\Option{\ty})}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[empty]{}{
  \buildparamsopt(\overname{\Nparamsopt(\epsilonnode)}{\vparsednode}) \astarrow
  \overname{\emptylist}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \buildclist[\Nopttypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildparamsopt(\overname{\Nparamsopt(\Tlbrace, \namednode{\ids}{\ClistZero{\Nopttypedidentifier}}, \Trbrace)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{FuncArgs}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-funcargs}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncargs}}{\vparsednode}) \aslto
  \overname{\KleeneStar{(\Identifier\times\ty)}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildclist[\Ntypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildfuncargs(\overname{\Nfuncargs(\Tlpar, \namednode{\ids}{\ClistZero{\Ntypedidentifier}}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{FuncBody}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-funcbody}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncbody}}{\vparsednode}) \aslto
  \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{}{
  {
  \begin{array}{r}
  \buildfuncbody(\overname{\Nfuncbody(\Tbegin, \namednode{\vstmts}{\Nstmtlist}, \Tend, \Tsemicolon)}{\vparsednode}) \astarrow \\
  \overname{\astof{\vstmtlist}}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{Accessors}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-accessors}{}
The function
\[
\buildaccessors(\overname{\parsenode{\Naccessors}}{\vparsednode}) \aslto
  \overname{\accessorpair}{\vaccessorpair}
\]
transforms a parse node $\vparsednode$ into an $\accessorpair$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildstmt(\vgetter) \astarrow \astversion{\vgetter} \\\\
  \buildstmt(\vsetter) \astarrow \astversion{\vsetter} \\\\
  {
  \vaccessorpair \eqdef
  \left\{
  \begin{array}{rcl}
    \accessorpairisreadonly &:& \astof{\visreadonly},\\
    \accessorpairgetter    &:& \astversion{\vgetter},\\
    \accessorpairsetter    &:& \astversion{\vsetter}
  \end{array}
  \right\}
  }
}{
  {
  \begin{array}{r}
    \buildaccessors(
      \punnode{\Nisreadonly}, \Tgetter, \namednode{\vgetter}{\Nstmtlist}, \Tend, \Tsemicolon, \\
      \Tsetter, \namednode{\vsetter}{\Nstmtlist}, \Tend, \Tsemicolon
    ) \\
    \astarrow \vaccessorpair
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildstmt(\vgetter) \astarrow \astversion{\vgetter} \\\\
  \buildstmt(\vsetter) \astarrow \astversion{\vsetter} \\\\
  {
  \vaccessorpair \eqdef
  \left\{
  \begin{array}{rcl}
    \accessorpairisreadonly &:& \astof{\visreadonly},\\
    \accessorpairgetter    &:& \astversion{\vgetter},\\
    \accessorpairsetter    &:& \astversion{\vsetter}
  \end{array}
  \right\}
  }
}{
  {
  \begin{array}{r}
    \buildaccessors(
      \Tsetter, \namednode{\vsetter}{\Nstmtlist}, \Tend, \Tsemicolon, \\
      \punnode{\Nisreadonly}, \Tgetter, \namednode{\vgetter}{\Nstmtlist}, \Tend, \Tsemicolon
    ) \\
    \astarrow \vaccessorpair
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarAccessorPair}
\MarkedIgnoredRelationDefinition{
\hypertarget{def-desugaraccessorpair}{}
The function
\[
  \desugaraccessorpair\left(
    \begin{array}{l}
    \overname{\overrideinfo}{\voverride} \aslsep \\
    \overname{\Identifier}{\name} \aslsep \\
    \overname{\KleeneStar{(\Identifier \times \Option{\ty})}}{\vparameters} \aslsep \\
    \overname{\KleeneStar{\typedidentifier}}{\vargs} \aslsep \\
    \overname{\Identifier}{\vsetterarg} \aslsep \\
    \overname{\ty}{\tty} \aslsep \\
    \overname{\accessorpair}{\vaccessorpair}
  \end{array}\right) \aslto
  \overname{\KleeneStar{\decl}}{\vastnode}
\]
transforms an $\accessorpair$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \vqualifier \eqdef \choice{\vaccessorpair.\accessorpairisreadonly}{\some{\Readonly}}{\None} \\\\
  {
  \vgetter \eqdef
      \DFunc\left\{
      \begin{array}{rcl}
        \funcname &:& \name,\\
        \funcparameters &:& \vparameters,\\
        \funcargs &:& \vargs,\\
        \funcbody &:& \vaccessorpair.\accessorpairgetter,\\
        \funcreturntype &:& \some{\tty},\\
        \funcsubprogramtype &:& \STGetter,\\
        \funcrecurselimit   &:& \None\\
        \funcbuiltin &:& \False\\
        \funcqualifier &:& \vqualifier\\
        \funcoverride &:& \voverride
      \end{array}
      \right\}
  } \\\\
  \vsetterargs \eqdef [(\vsetterarg, \tty)] \concat \vargs \\\\
  {
  \vsetter \eqdef
      \DFunc\left\{
      \begin{array}{rcl}
        \funcname &:& \name,\\
        \funcparameters &:& \vparameters,\\
        \funcargs &:& \vsetterargs,\\
        \funcbody &:& \vaccessorpair.\accessorpairsetter,\\
        \funcreturntype &:& \None,\\
        \funcsubprogramtype &:& \STSetter,\\
        \funcrecurselimit   &:& \None\\
        \funcbuiltin &:& \False\\
        \funcqualifier &:& \None\\
        \funcoverride &:& \voverride
      \end{array}
      \right\}
  }
}{
  {
    \desugaraccessorpair\left(
      \begin{array}{l}
        \voverride, \\
        \name, \\
        \vparameters, \\
        \vargs, \\
        \vsetterarg, \\
        \tty, \\
        \vaccessorpair
      \end{array}
    \right)
    \astarrow [\vgetter, \vsetter]
  }
}
\end{mathpar}

\ASTRuleDef{Qualifier}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-qualifier}{}
The function
\[
\buildqualifier(\overname{\parsenode{\Nqualifier}}{\vparsednode}) \aslto
  \overname{\Option{\qualifier}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[none]{}{
  \buildqualifier(\overname{\Nqualifier(\emptysentence)}{\vparsednode}) \astarrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[pure]{}{
  \buildqualifier(\overname{\Nqualifier(\Tpure)}{\vparsednode}) \astarrow \some{\Pure}
}
\end{mathpar}

\begin{mathpar}
\inferrule[readonly]{}{
  \buildqualifier(\overname{\Nqualifier(\Treadonly)}{\vparsednode}) \astarrow \some{\Readonly}
}
\end{mathpar}

\begin{mathpar}
\inferrule[noreturn]{}{
  \buildqualifier(\overname{\Nqualifier(\Tnoreturn)}{\vparsednode}) \astarrow \some{\Noreturn}
}
\end{mathpar}

\ASTRuleDef{IsReadonly}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-isreadonly}{}
The function
\[
\buildisreadonly(\overname{\parsenode{\Nisreadonly}}{\vparsednode}) \aslto
  \overname{\Bool}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[none]{}{
  \buildisreadonly(\overname{\Nisreadonly(\emptysentence)}{\vparsednode}) \astarrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[readonly]{}{
  \buildqualifier(\overname{\Nisreadonly(\Treadonly)}{\vparsednode}) \astarrow \True
}
\end{mathpar}

\ASTRuleDef{Override}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-override}{}
The function
\[
\buildoverride(\overname{\parsenode{\Noverride}}{\vparsednode}) \aslto
  \overname{\Option{\overrideinfo}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[none]{}{
  \buildoverride(\overname{\Noverride(\emptysentence)}{\vparsednode}) \astarrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[impdef]{}{
  \buildoverride(\overname{\Noverride(\Timpdef)}{\vparsednode}) \astarrow \some{\Impdef}
}
\end{mathpar}

\begin{mathpar}
\inferrule[implementation]{}{
  \buildoverride(\overname{\Noverride(\Timplementation)}{\vparsednode}) \astarrow \some{\Implementation}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\TypeRulesDef{Subprogram Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The main rule for annotating subprogram declarations is \\
\TypingRuleRef{AnnotateSubprogram}.

We also define the following helper rules:
\begin{itemize}
  \item \TypingRuleRef{AnnotateAndDeclareFunc}
  \item \TypingRuleRef{AnnotateFuncSig}
  \item \TypingRuleRef{AnnotateParams}
  \item \TypingRuleRef{AnnotateOneParam}
  \item \TypingRuleRef{CheckParamDecls}
  \item \TypingRuleRef{FuncSigTypes}
  \item \TypingRuleRef{ParametersOfTy}
  \item \TypingRuleRef{ParametersOfExpr}
  \item \TypingRuleRef{ParametersOfConstraint}
  \item \TypingRuleRef{AnnotateArgs}
  \item \TypingRuleRef{AnnotateOneArg}
  \item \TypingRuleRef{AnnotateReturnType}
  \item \TypingRuleRef{CheckSubprogramPurity}
  \item \TypingRuleRef{DeclareOneFunc}
  \item \TypingRuleRef{SubprogramClash}
  \item \TypingRuleRef{AddNewFunc}
  \item \TypingRuleRef{AddSubprogram}
  \item \TypingRuleRef{Subprogram}
  \item \TypingRuleRef{CheckControlFlow}
  \item \TypingRuleRef{ApproxStmt}
  \item \TypingRuleRef{AllowedAbsConfigs}
\end{itemize}

\TypingRuleDef{AnnotateSubprogram}
See \ExampleRef{Annotating Subprogram Signatures} and
\ExampleRef{Updating the Static Environment for a Subprogram}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vd$ is a subprogram AST node with a subprogram definition $\vf$, that is, $\DFunc(\vf)$;
  \item annotating and declaring the subprogram for $\vf$ in $\genv$ as per \\
        \TypingRuleRef{AnnotateAndDeclareFunc}
        yields the environment $\tenvone$, a subprogram definition $\vfone$,
        and a \sideeffectdescriptorsetsterm{} $\vsesfuncsig$\ProseOrTypeError;
  \item \Proseannotatesubprogram{$\tenv$}{$\vfone$}{\vsesfuncsig}{$\newf$}{$\vsesf$}\ProseOrTypeError;
  \item applying $\addsubprogram$ to $\tenvone$, $\newf.\funcname$, $\newf$, and $\vsesf$ yields \\
        $\newtenv$;
  \item define $\newd$ as the subprogram AST node with $\newf$, that is, $\DFunc(\newf)$;
  \item define $\newgenv$ as the global component of $\newtenv$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateanddeclarefunc(\genv, \vf) \typearrow (\tenvone, \vfone, \vsesfuncsig) \OrTypeError\\\\
  \annotatesubprogram(\tenvone, \vfone, \vsesfuncsig) \typearrow (\newf,\vsesf) \OrTypeError\\\\
  \addsubprogram(\tenvone, \newf.\funcname, \newf, \vsesf) \typearrow \newtenv
}{
  \typecheckdecl(\genv, \overname{\DFunc(\vf)}{\vd})
  \typearrow (\overname{\DFunc(\newf)}{\newd}, \overname{G^\newtenv}{\newgenv})
}
\end{mathpar}

\TypingRuleDef{AnnotateAndDeclareFunc}
\RenderRelation{annotate_and_declare_func}
\BackupOriginalRelation{
The function
\[
  \annotateanddeclarefunc(\overname{\globalstaticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto
  \begin{array}{l}
  (\overname{\staticenvs}{\tenv} \times \overname{\func}{\newfuncsig} \times \overname{\TSideEffectSet}{\vses})\ \cup\\
  \overname{\typeerror}{\TypeErrorConfig}
  \end{array}
\]
annotates a subprogram definition $\funcsig$ in the \globalstaticenvironmentterm{} $\genv$,
yielding a new subprogram definition $\newfuncsig$, a modified \staticenvironmentterm{}
$\newtenv$, and an inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

See \ExampleRef{Annotating Subprogram Signatures} and
\ExampleRef{Updating the Static Environment for a Subprogram}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the signature of $\funcsig$ in $\genv$ as per
        \TypingRuleRef{AnnotateFuncSig} yields
        $(\tenvone, \funcsigfone, \vsesone)$\ProseOrTypeError;
  \item declaring the subprogram defined by $\funcsigfone$ in $\tenvone$ with $\vsesfone$
        as per \TypingRuleRef{DeclareOneFunc} yields the environment $\newtenv$
        and new $\func$ node $\newfuncsig$\ProseOrTypeError;
  \item \Proseeqdef{$\vses$}{$\vsesfone$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\tenvone, \funcsigfone, \vsesfone) \OrTypeError\\\\
  \declareonefunc(\tenvone, \funcsigfone, \vsesfone) \typearrow (\newtenv, \newfuncsig) \OrTypeError
}{
  \annotateanddeclarefunc(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig, \overname{\vsesfone}{\vses})
}
\end{mathpar}
\CodeSubsection{\AnnotateAndDeclareFuncBegin}{\AnnotateAndDeclareFuncEnd}{../Typing.ml}

\TypingRuleDef{AnnotateFuncSig}
\RenderRelation{annotate_func_sig}
\BackupOriginalRelation{
The function
\[
  \annotatefuncsig(\overname{\globalstaticenvs}{\genv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig} \times \overname{\TSideEffect}{\vses})
  \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
annotates the signature of a function definition $\funcsig$ in the \globalstaticenvironmentterm{} $\genv$,
yielding a new function definition $\newfuncsig$,
a modified \staticenvironmentterm{} $\newtenv$, and
an inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Subprogram Signatures}
\ExampleRef{Annotating Parameters},
\ExampleRef{Checking Parameter Declarations},
\ExampleRef{Annotating Subprogram Arguments},
and
\ExampleRef{Annotating Subprogram Return Types}
show well-typed subprogram signatures and ill-typed subprogram signatures.

The specification in \listingref{AnnotateFuncSig} shows a subprogram
with an associated recursion limit.
\ASLListing{Annotating a subprogram signature with a recursion limit}{AnnotateFuncSig}{\typingtests/TypingRule.AnnotateFuncSig.asl}

The specification in \listingref{AnnotateFuncSig-bad} is ill-typed, since the recursion limit expression \verb|W|
is not a constrained expression.
\ASLListing{An ill-typed subprogram signature}{AnnotateFuncSig-bad}{\typingtests/TypingRule.AnnotateFuncSig.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tenv$ is the \staticenvironmentterm{} which comprises of the \globalstaticenvironmentterm{} $\genv$ and an empty local environment;
  \item applying $\annotatelimitexpr$ to $\funcsig.\funcrecurselimit$ in $\tenvone$ yields \\
        $(\vrecurselimit, \vsesrecurselimit)$\ProseOrTypeError;
  \item annotating and declaring the parameters $\funcsig.\funcparameters$ in $\tenv$ using \\
        $\annotateparams$ yields $(\tenvwithparams, \vseswithparams, \params)$\ProseOrTypeError;
  \item checking that the parameters $\funcsig.\funcparameters$ are declared correctly using $\checkparamdecls$, yields $\True$\ProseOrTypeError;
  \item annotating and declaring the arguments $\funcsig.\funcargs$ in $\tenvwithparams$ using $\annotateargs$
        and $\vseswithparams$ yields\\
        $(\tenvwithargs, \vseswithargs, \vargs)$\ProseOrTypeError;
  \item annotating the return type of $\funcsig$ in $\tenvwithparams$ using \\ $\annotatereturntype$ and $\vseswithargs$, yields\\
        $(\newtenv, \vreturntype, \vseswithreturn)$\ProseOrTypeError;
  \item \Proseeqdef{$\vsesp$}{$\vseswithreturn$ with every \LocalEffectTerm\ removed};
  \item checking that the \sideeffectsetterm{} $\vsesp$ adheres to the subprogram's \purity{} qualifier $\funcsig.\funcqualifier$ yields $\True$\ProseOrTypeError;
  \item the \sideeffectsetterm{} corresponding to $\funcsig.\funcqualifier$ (via $\sesforsubprogram$) is $\vses$;
  \item $\newfuncsig$ is $\funcsig$ with the annotated parameters $\vparams$, annotated arguments $\vargs$, annotated return type $\vreturntype$,
        and $\vrecurselimit$ as its recursion limit.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \withemptylocal(\genv) \typearrow \tenv\\
  {
    \begin{array}{r}
    \annotatelimitexpr(\tenvone, \funcsig.\funcrecurselimit) \typearrow \\
    (\vrecurselimit, \vsesrecurselimit) \OrTypeError
    \end{array}
  }\\\\
  {
    \begin{array}{r}
    \annotateparams(\tenv, \funcsig.\funcparameters, (\tenv, \emptylist)) \typearrow \\
    (\tenvwithparams, \vseswithparams, \params) \OrTypeError
    \end{array}
  }\\
  \checkparamdecls(\tenv, \funcsig) \typearrow \True \OrTypeError \\
  {
    \begin{array}{r}
    \annotateargs\left(
      \begin{array}{l}
        \tenvwithparams, \funcsig.\funcargs,\\
        (\tenvwithparams, \emptylist), \vseswithparams
      \end{array}
      \right) \typearrow \\
    (\tenvwithargs, \vseswithargs, \vargs) \OrTypeError
      \end{array}
  }\\\\
  {
    \begin{array}{r}
    \annotatereturntype\left(
      \begin{array}{l}
        \tenvwithargs, \tenvwithparams, \\
        \funcsig.\funcreturntype, \vseswithargs
      \end{array}
      \right) \typearrow \\
    (\newtenv, \vreturntype, \vseswithreturn) \OrTypeError
    \end{array}
  }\\\\
  \vsesp \eqdef \vseswithreturn \setminus \{ \vs \;|\; \configdomain{\vs} = \LocalEffect \}\\
  \checksubprogrampurity(\funcsig.\funcqualifier, \vsesp) \typearrow \True \OrTypeError \\
  \sesforsubprogram(\funcsig.\funcqualifier) \typearrow \vses\\
  {
    \newfuncsig \eqdef
    \left\{
    \begin{array}{rcl}
      \funcname            &:& \funcsig.\funcname,\\
      \funcparameters      &:& \vparameters,\\
      \funcargs            &:& \vargs,\\
      \funcbody            &:& \funcsig.\funcbody,\\
      \funcreturntype      &:& \vreturntype,\\
      \funcsubprogramtype  &:& \funcsig.\funcsubprogramtype,\\
      \funcrecurselimit    &:& \vrecurselimit\\
      \funcbuiltin         &:& \funcsig.\funcbuiltin
    \end{array}
    \right\}
  }
}{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateFuncSigBegin}{\AnnotateFuncSigEnd}{../Typing.ml}

\TypingRuleDef{AnnotateParams}
\RenderRelation{annotate_params}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\annotateparams(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\KleeneStar{(\Identifier \times \Option{\ty})}}{\params} \aslsep
  (\overname{\staticenvs}{\newtenv} \times \overname{\KleeneStar{(\Identifier\times\ty)}}{\acc})
) \aslto \\
(\overname{\staticenvs}{\tenvwithparams} \times \overname{\Identifier\times\ty}{\paramsone})
\cup\ \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates each parameter in $\params$ with respect to $\tenv$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithparams$ and the annotated parameters $\paramsone$, together with any annotated parameters already in the accumulator $\acc$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Parameters}
In \listingref{typing-parameterofconstraint}, the list of explicitly defined parameters
of the function \\
\verb|signature_example| is $\{\texttt{A},\texttt{B}\}$.
Therefore, $\tenvwithparams$ effectively reflects the added declarations \\
\verb|let A: integer{A}| and \verb|let B: integer{B}|.

\ASLListing{A function with parameters}{typing-parameterofconstraint}{\typingtests/TypingRule.AnnotateFuncSig.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\params$ is the empty list;
    \item $\tenvwithparams$ is $\newtenv$;
    \item $\paramsone$ is $\acc$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\params$ is a list with $(\vx, \tyopt)$ as its \head\ and $\paramsp$ as its \tail;
    \item applying $\annotateoneparam$ to the parameter $(\vx, \tyopt)$ with $\tenv$ and $\newtenv$ yields the pair $\newtenvp$ and $\tty$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \tty)$;
    \item applying $\annotateparams$ to $\paramsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields $\tenvwithparams$ and $\paramsone$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotateparams(\tenv, \overname{\emptylist}{\params}, (\newtenv, \acc)) \typearrow
  (\overname{\newtenv}{\tenvwithparams}, \overname{\acc}{\paramsone})
}
\and
\inferrule[non\_empty]{
  \params = [(\vx,\tyopt)] \concat \paramsp\\\\
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \tty)] \\\\
  \annotateparams(\tenv, \paramsp, (\newtenvp, \accp)) \typearrow (\tenvwithparams, \paramsone) \OrTypeError
}{
  \annotateparams(\tenv, \params, (\newtenv, \acc)) \typearrow (\tenvwithparams, \paramsone)
}
\end{mathpar}

\TypingRuleDef{AnnotateOneParam}
\RenderRelation{annotate_one_param}
\BackupOriginalRelation{
The function
\[
\annotateoneparam(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\Identifier}{\vx} \times \overname{\Option{\ty}}{\tyopt})
) \aslto
\begin{array}{l}
  (\overname{\staticenvs}{\newtenvp} \times \overname{\ty}{\tty})\ \cup\\
  \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates the parameter given by $\vx$ and the \optionalterm\ type $\tyopt$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The updated environment $\newtenvp$ and annotated parameter type $\tty$ are returned.
\ProseOtherwiseTypeError
} % END_OF_PENDING_RELATION


\ExampleDef{Annotating Subprogram Parameters}
In \listingref{AnnotateOneParam},
the parameters \verb|A| and \verb|B| are annotated as \parameterizedintegertypesterm,
and \verb|C| is annotated as a \wellconstrainedintegertypeterm.
The specification demonstrates how \verb|A|, \verb|B|, and \verb|C| exist as local storage elements
of \verb|parameterized|.
\ASLListing{Annotating subprogram parameters}{AnnotateOneParam}{\typingtests/TypingRule.AnnotateOneParam.asl}

In \listingref{AnnotateOneParam-bad1}, the declaration of the parameter \verb|A| is illegal,
since \verb|A| is also declared as a global storage element.
\ASLListing{An ill-typed subprogram parameter}{AnnotateOneParam-bad1}{\typingtests/TypingRule.AnnotateOneParam.bad1.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{type\_parameterized}
    \begin{itemize}
      \item $\tyopt$ is either $\None$ or an \unconstrainedintegertypeterm{};
      \item $\tty$ is defined as the \parameterizedintegertypeterm\ for the identifier $\vx$.
    \end{itemize}

    \item \AllApplyCase{type\_annotated}
    \begin{itemize}
      \item $\tyopt$ is the type $\some{\ttyp}$, which is not the unconstrained integer type;
      \item annotating $\ttyp$ in $\tenv$ yields $\tty$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item checking that $\tty$ is a constrained integer in $\newtenv$ via $\checkconstrainedinteger$
        yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\tty$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[type\_parameterized]{
  (\tyopt = \None \lor \tyopt = \some{ \unconstrainedinteger}) \\
  \tty \eqdef \TInt(\Parameterized(\vx))\\\\
  \commonsuffixline\\\\
  \checkvarnotinenv(\newtenv, \vx) \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty)
}
\and
\inferrule[type\_annotated]{
  \ttyp \neq \unconstrainedinteger\\
  \annotatetype(\False, \tenv, \ttyp) \typearrow \tty \OrTypeError\\\\
  \commonsuffixline\\\\
  \checkvarnotinenv(\newtenv, \vx) \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \some{\ttyp})) \typearrow (\newtenvp, \tty)
}
\end{mathpar}

\TypingRuleDef{CheckParamDecls}
\RenderRelation{check_param_decls}
\BackupOriginalRelation{
The function
\[
\checkparamdecls(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig}) \aslto \overname{\Bool}{\vb} \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
checks the validity of the parameters declared in $\funcsig$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Checking Parameter Declarations}
The specification in \listingref{CheckParamDecls} is well-typed.
Specifically, the parameter \verb|N|, which must be used in the function signature is used by the
return type.
\ASLListing{A parameter used by the return type}{CheckParamDecls}{\typingtests/TypingRule.CheckParamDecls.asl}

In \listingref{ParametersOfExpr}, the list of extracted parameters \verb|B, C, D, E, F, G|
is equal to the list of declared parameters.

The specification in \listingref{CheckParamDecls-bad} is ill-typed, since the list of extracted parameters is
\verb|D, A, B, C|, while the list of declared parameters is \verb|A, B, C, D|.
\ASLListing{Incorrectly declaring subprogram parameters}{CheckParamDecls-bad}{\typingtests/TypingRule.CheckParamDecls.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\extractparameters$ to $\tenv$ and $\funcsig$ yields\\
        $\inferredparameters$\ProseOrTypeError;
  \item \Proseeqdef{$\declaredparameters$}{the list of parameter names in the order they are listed in $\funcsig.\funcparameters$};
  \item checking that $\inferredparameters$ is equal to $\declaredparameters$ yields \\
        $\True$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \extractparameters(\tenv, \funcsig) \typearrow \inferredparameters \OrTypeError\\\\
  \declaredparameters \eqdef [(\vp, \Ignore) \in \funcsig.\funcparameters: \vp]\\
  \checktrans{\inferredparameters = \declaredparameters}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError
}{
  \checkparamdecls(\tenv, \funcsig) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{ExtractParameters}
\RenderRelation{extract_parameters}
\BackupOriginalRelation{
The function
\[
\extractparameters(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig}) \aslto \overname{\KleeneStar{\Identifier}}{\uniqueparameters}
  \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
returns the parameter names declared in $\funcsig$ into $\allparameters$, while checking their validity in the \staticenvironmentterm{} $\tenv$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{The Parameters of a Function}
In \listingref{typing-parameterofconstraint}, the set of identifiers that may correspond
to parameters of the function \texttt{signature\_example} is $\{\texttt{A}, \texttt{B}\}$,
since they appear in the type \texttt{bits(A)}
of the argument \texttt{bv} and the type \texttt{bits(A+B)} of the argument \texttt{bv3}.

Finding parameters for each type in the signature of the function \texttt{signature\_example}
yields the following results:
\begin{center}
\begin{tabular}{lll}
\textbf{Expression} & \textbf{Result} & \textbf{Reason}\\
\hline
\texttt{bits(A)} & $\{\texttt{A}\}$ & \texttt{A} is a variable expression \\
& & and \texttt{A} is not defined in the environment.\\
\texttt{bits(W)} & $\emptyset$ & \texttt{W} is defined in the environment.\\
\texttt{bits(A+B)} & $\{\texttt{A}, \texttt{B}\}$ & \texttt{A} and \texttt{B} are variables \\
& & and neither is defined in the environment.\\
\end{tabular}
\end{center}

\ExampleDef{Extracting Parameters from Subprogram Signatures}
The list of parameters extracted from the signature of \verb|parameters_of_expressions|
in \listingref{ParametersOfExpr} is
\verb|B, C, D, E, F, G|.

\ExampleDef{Unsupported Expressions in Subprogram Signatures}
The specification in \listingref{ExtractParameters-bad1} is ill-typed, since the
expressions \\
\verb|N as integer{8,16,32}| and \verb|(N + 1) as integer{9,17}|
are unsupported inside \bitvectortypesterm{} of arguments.
\ASLListing{An ill-typed subprogram signature}{ExtractParameters-bad1}{\typingtests/TypingRule.ExtractParameters-bad1.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item applying $\funcsigtypes$ to $\funcsig$ yields the empty list;
    \item \Proseeqdef{$\uniqueparameters$}{the empty list}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item applying $\funcsigtypes$ to $\funcsig$ yields the list of types $\vt_{1..k}$;
    \item applying $\paramsofty$ to $\tenv$ and $\vtypes[\vi]$, for every $\vi=1..k$, yields the list of parameter names $\vparams_\vi$\ProseOrTypeError;
    \item \Proseeqdef{$\allparameters$}{the concatenation of lists $\vparams_\vi$, for every $\vi=1..k$};
    \item \Proseeqdef{$\uniqueparameters$}{the list of parameters in $\allparameters$, with repeating parameters removed}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{
  \funcsigtypes(\funcsig) \typearrow \emptylist
}{
  \extractparameters(\tenv, \funcsig) \typearrow \overname{\emptylist}{\uniqueparameters}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \funcsigtypes(\funcsig) \typearrow \vt_{1..k}\\
  \vi=1..k: \paramsofty(\tenv, \vtypes[\vi]) \typearrow \vparams_\vi \OrTypeError\\\\
  \allparameters \eqdef \vparams_1 \concat \ldots \concat \vparams_k\\
  \uniqueparameters \eqdef \uniquelist(\allparameters)
}{
  \extractparameters(\tenv, \funcsig) \typearrow \uniqueparameters
}
\end{mathpar}

\TypingRuleDef{FuncSigTypes}
\RenderRelation{func_sig_types}
\BackupOriginalRelation{
The function
\[
\funcsigtypes(\overname{\func}{\funcsig}) \aslto \overname{\KleeneStar{\ty}}{\tys}
\]
returns the list of types $\tys$ in the subprogram signature $\funcsig$.
Their ordering is return type first (if any), followed by argument types left-to-right.
} % END_OF_BACKUP_RELATION

\ExampleDef{Listing Signature Types}
\listingref{FuncSigTypes} shows the list of signature types for a procedure and a function
in comments above their declarations.
\ASLListing{Listing signature types}{FuncSigTypes}{\typingtests/TypingRule.FuncSigTypes.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\vreturntype$}{the singleton list for $\ttyp$ if
        $\funcsig.\funcreturntype$ if the singleton set for $\ttyp$,
        and the empty list, otherwise.}
  \item \Proseeqdef{$\argtypes$}{the types of arguments in $\funcsig.\funcargs$};
  \item \Proseeqdef{$tys$}{the \Proselist{$\vreturntype$}{$\argtypes$}}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \vreturntype \eqdef
    \begin{cases}
      [\ttyp] & \text{if }\funcsig.\funcreturntype = \some{\ttyp}\\
      \emptylist & \text{if }\funcsig.\funcreturntype = \None
    \end{cases}
  } \\\\
  \argtypes \eqdef [(\Ignore, \ttyp)\in\funcsig.\funcargs: \ttyp]
}{
  \funcsigtypes(\funcsig) \typearrow \overname{\vreturntype \concat \argtypes}{\tys}
}
\end{mathpar}

\TypingRuleDef{ParametersOfTy}
\RenderRelation{paramsofty}
\BackupOriginalRelation{
The function
\[
\paramsofty(\overname{\staticenvs}{\tenv}, \overname{\ty}{\tty}) \typearrow \overname{\KleeneStar{\Identifier}}{\ids}
\cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
extracts the list of parameters appearing in the type $\tty$,
assuming that $\tty$ appears in a function signature.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{The Parameters Extracted from Argument Types}
The parameters extracted from the types of arguments appearing in the signature of \verb|parameters_of_types|
(starting with the return type)
in \listingref{ParametersOfTy} are as follows:
\begin{center}
\begin{tabular}{ll}
\textbf{Type} & \textbf{Parameters}\\
\hline
\verb|bits(A)|            & $[\texttt{A}]$\\
\verb|(bits(B), bits(C))| & $[\texttt{B}, \texttt{C}]$\\
\verb|integer{D..E}|      & $[\texttt{D}, \texttt{E}]$\\
\verb|real|               & $\emptylist$\\
\verb|integer|            & $\emptylist$\\
\end{tabular}
\end{center}

\ASLListing{The parameters extracted from argument types}{ParametersOfTy}{\typingtests/TypingRule.ParametersOfTy.asl}

\ExampleRef{Ill-typed Type Declarations} shows an ill-typed argument type.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{tbits}
    \begin{itemize}
      \item $\tty$ is a bitvector type, that is, $\TBits(\ve, \Ignore)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $\ids$\ProseOrTypeError.
    \end{itemize}

  \item \AllApplyCase{ttuple}
    \begin{itemize}
      \item $\tty$ is a tuple over a list of types $\tys$, that is, $\TTuple(\tys)$;
      \item applying $\paramsofty$ to each type $\tty_i$ in $\tys$ yields $\ids_i$\ProseOrTypeError;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item \AllApplyCase{tint\_constrained\_precise}
    \begin{itemize}
      \item $\tty$ is a \wellconstrainedintegertypeterm, that is, $\TInt(\WellConstrained(\cs))$;
      \item applying $\paramsofconstraint$ to each constraint $\vc_i$ in $\cs$ yields $\ids_i$\ProseOrTypeError;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item \AllApplyCase{other}
    \begin{itemize}
      \item $\tty$ meets one of the following conditions:
      \begin{itemize}
        \item $\tty$ is one of the following types: \realtypeterm, \stringtypeterm, \booleantypeterm, \arraytypeterm, \namedtypeterm;
        \item $\tty$ is an \unconstrainedintegertypeterm;
        \item $\tty$ is a \wellconstrainedintegertypeterm{} with a $\False$ precision flag, that is, $\TInt(\WellConstrained(\Ignore, \False))$;
        \item $\tty$ is a \parameterizedintegertypeterm;
      \end{itemize}
      \item $\ids$ is the empty list.
    \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item $\tty$ either a \structuredtypeterm{} or an \enumerationtypeterm;
    \item the result is a \typingerrorterm{} ($\BadSubprogramDeclaration$).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[tbits]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofty(\tenv, \TBits(\ve, \Ignore)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ttuple]{
  \tty_i \in \tys: \paramsofty(\tenv, \tty_i) \typearrow \ids_i \OrTypeError\\\\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TTuple(\tys)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[tint\_constrained\_precise]{
  \vc_i \in \cs: \paramsofconstraint(\tenv, \vc_i) \typearrow \ids_i \OrTypeError\\\\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TInt(\WellConstrained(\cs, \True))) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  {
  \begin{array}{ll}
  \astlabel(\tty) \in \{ \TReal, \TString, \TBool, \TArray, \TNamed \}  & \lor\\
  \tty = \unconstrainedinteger                                          &\lor\\
  \tty = \TInt(\WellConstrained(\Ignore, \False))                       & \lor\\
  \tty = \TInt(\Parameterized(\Ignore))                                 &
  \end{array}
  }
}{
  \paramsofty(\tenv, \tty) \typearrow \overname{\emptylist}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \isstructured(\tty) \lor \astlabel(\tty) = \TEnum
}{
  \paramsofty(\tenv, \tty) \typearrow \TypeErrorVal{\BadSubprogramDeclaration}
}
\end{mathpar}

\TypingRuleDef{ParametersOfExpr}
\RenderRelation{params_of_expr}
\BackupOriginalRelation{
The function
\[
\paramsofexpr(\overname{\staticenvs}{\tenv}, \overname{\expr}{\ve}) \typearrow \overname{\KleeneStar{\Identifier}}{\ids}
\cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
extracts the list of parameters appearing in the expression $\ve$.
It assumes that $\ve$ appears as $\TBits(\ve, \Ignore)$ or as part of a \wellconstrainedintegertypeterm{} in a function signature.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Extracting the Parameters from Expressions}
In \listingref{ParametersOfExpr}, extracting parameters from expressions appearing
in the types of signature arguments (starting with the return type) yield the following lists of parameters:
\begin{center}
\begin{tabular}{ll}
\textbf{Expression} & \textbf{Parameters}\\
\hline
\verb|A|      & $\emptylist$\\
\verb|B|      & $[\texttt{B}]$\\
\verb|C|      & $[\texttt{C}]$\\
\verb|-D|      & $[\texttt{D}]$\\
\verb|E+F|      & $[\texttt{E}, \texttt{F}]$\\
\verb|(G)|      & $[\texttt{G}]$\\
\verb|if H == 0 then I else J|      & $[\texttt{H}, \texttt{I}, \texttt{J}]$\\
\end{tabular}
\end{center}
Notice that, since \verb|A| is declared as a global storage element, it is not extracted as a parameter
for the expression \verb|A| appearing in the return type.

\ASLListing{Extracting the parameters from expressions}{ParametersOfExpr}{\typingtests/TypingRule.ParametersOfExpr.asl}

\listingref{ParametersOfExpr-bad} shows examples of expressions that are illegal in types of arguments.
\ASLListing{Ill-typed expressions in signature types}{ParametersOfExpr-bad}{\typingtests/TypingRule.ParametersOfExpr.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{eval}
    \begin{itemize}
      \item $\ve$ is a variable, that is, $\EVar(\vx)$;
      \item if $\vx$ is undefined in $\tenv$ then $\ids$ is $[\vx]$, otherwise $\ids$ is $\emptylist$.
    \end{itemize}

  \item \AllApplyCase{eunop}
    \begin{itemize}
      \item $\ve$ is a unary operation, that is, $\EUnop(\Ignore, \ve)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\ids$\ProseOrTypeError.
    \end{itemize}

  \item \AllApplyCase{ebinop}
    \begin{itemize}
      \item $\ve$ is a binary operation, that is, $\EBinop(\Ignore, \veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$\ProseOrTypeError;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$\ProseOrTypeError;
      \item define $\ids$ as the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}

  \item \AllApplyCase{etuple}
    \begin{itemize}
      \item $\ve$ is a tuple over the list of expression $\es$, that is, $\ETuple(\es)$;
      \item checking that $\es$ is a singleton list yields $\True$\ProseTerminateAs{\BadSubprogramDeclaration};
      \item view $\es$ as the singleton list for the expression $\ve$;
      \item applying $\paramsofexpr$ to $\ve$ $\ids$\ProseOrTypeError.
    \end{itemize}

  \item \AllApplyCase{econd}
    \begin{itemize}
      \item $\ve$ is a conditional expression, that is, $\ECond(\ve, \veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $\idsp$\ProseOrTypeError;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$\ProseOrTypeError;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$\ProseOrTypeError;
      \item define $\ids$ as the concatenation of $\idsp$, $\idsone$, and $\idstwo$.
    \end{itemize}

  \item \AllApplyCase{other}
    \begin{itemize}
      \item $\ve$ is not a variable, unary operation, binary operation, or tuple;
      \item the result is a \typingerrorterm{} ($\BadSubprogramDeclaration$).
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[eval]{
  \isundefined(\tenv, \vx) \typearrow \vb\\
  \ids \eqdef \choice{\vb}{[\vx]}{\emptylist}
}{
  \paramsofexpr(\tenv, \EVar(\vx)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[eunop]{
  \paramsofexpr(\tenv, \veone) \typearrow \ids \OrTypeError
}{
  \paramsofexpr(\tenv, \EUnop(\Ignore, \veone)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \OrTypeError\\\\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo \OrTypeError
}{
  \paramsofexpr(\tenv, \EBinop(\Ignore, \veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[etuple]{
  \checktrans{|\es| = 1}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError\\\\
  \es \eqname [\ve]\\
  \paramsofexpr(\tenv, \ve) \typearrow \ids \OrTypeError\
}{
  \paramsofexpr(\tenv, \ETuple(\es)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[econd]{
  \paramsofexpr(\tenv, \ve) \typearrow \idsp \OrTypeError\\\\
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \OrTypeError\\\\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo \OrTypeError
}{
  \paramsofexpr(\tenv, \ECond(\ve, \veone, \vetwo)) \typearrow \overname{\idsp \concat \idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \notin \{ \EVar, \EUnop, \EBinop, \ETuple \}
}{
  \paramsofexpr(\tenv, \ve) \typearrow \TypeErrorVal{\BadSubprogramDeclaration}
}
\end{mathpar}

\TypingRuleDef{ParametersOfConstraint}
\RenderRelation{params_of_constraint}
\BackupOriginalRelation{
The function
\[
\paramsofconstraint(\overname{\staticenvs}{\tenv}, \overname{\intconstraint}{\vc}) \typearrow \overname{\KleeneStar{\Identifier}}{\ids}
\]
finds the list of parameters in the constraint $\vc$.
It assumes that $\vc$ appears within a \wellconstrainedintegertypeterm{} in a function signature.
} % END_OF_BACKUP_RELATION

\ExampleDef{The Parameters Extracted from a Constraint}
In \listingref{ParametersOfTy}, the list of parameters extracted from the constraint
\verb|{D..E}| is $[\texttt{D}, \texttt{E}]$.

See also \ExampleRef{Extracting the Parameters from Expressions}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
    \begin{itemize}
      \item $\vc$ is an exact constraint, that is, $\ConstraintExact(\ve)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $ids$.
    \end{itemize}

  \item \AllApplyCase{range}
    \begin{itemize}
      \item $\vc$ is an range constraint, that is, $\ConstraintRange(\veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$;
      \item $\ids$ is the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofconstraint(\tenv, \ConstraintExact(\ve)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo \\
}{
  \paramsofconstraint(\tenv, \ConstraintRange(\veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\TypingRuleDef{AnnotateArgs}
\RenderRelation{annotate_args}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\annotateargs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\KleeneStar{(\Identifier \times \ty)}}{\args} \aslsep\
  (\overname{\staticenvs}{\newtenv} \times \overname{\KleeneStar{(\Identifier\times\ty)}}{\acc} \aslsep
  \overname{\TSideEffectSet}{\vsesin})
) \aslto \\
(\overname{\staticenvs}{\tenvwithargs} \times \overname{\KleeneStar{(\Identifier\times\ty)}}{\vnewargs} \times \overname{\TSideEffectSet}{\vses})
\cup\ \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates each argument in $\args$ with respect to $\tenv$ and a \sideeffectsetterm\ $\vsesin$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithargs$, the annotated arguments $\vnewargs$,
together with any annotated arguments already in the accumulator $\acc$,
and a \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Subprogram Arguments}
In \listingref{typing-parameterofconstraint}, the annotated arguments are
\texttt{bv}, \texttt{bv2}, \texttt{bv3}, and \texttt{C}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\args$ is the empty list;
    \item $\tenvwithargs$ is $\newtenv$;
    \item $\newargs$ is $\acc$;
    \item \Proseeqdef{$\vses$}{$\vsesin$}
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\args$ is a list with $(\vx, \tty)$ as its \head\ and $\vargsp$ as its \tail;
    \item applying $\annotateonearg$ to the argument $(\vx, \tty)$ with $\tenv$ and $\newtenv$ yields
          $(\newtenvp, \ttyp, \vsesty)$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \ttyp)$;
    \item applying $\annotateargs$ to $\vargsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields\\
          $(\tenvwithargs, \newargs, \newses)$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesty$ and $\newses$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotateargs(\tenv, \overname{\emptylist}{\args}, (\newtenv, \acc), \vsesin) \typearrow
  (\overname{\newtenv}{\tenvwithargs}, \overname{\acc}{\newargs}, \overname{\vsesin}{\vses})
}
\and
\inferrule[non\_empty]{
  \vargs = [(\vx,\tty)] \concat \vargsp\\\\
  \annotateonearg(\tenv, \newtenv, (\vx, \tty)) \typearrow (\newtenvp, \ttyp, \vsesty) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \ttyp)] \\\\
  \annotateargs(\tenv, \vargsp, (\newtenvp, \accp), \vsesin) \typearrow (\tenvwithargs, \newargs, \newses) \OrTypeError\\\\
  \vses \eqdef \vsesty \cup\ \newses
}{
  \annotateargs(\tenv, \args, (\newtenv, \acc), \vsesin) \typearrow (\tenvwithargs, \newargs, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateOneArg}
\RenderRelation{annotate_one_arg}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
  \annotateonearg(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\Identifier}{\vx} \times \overname{\ty}{\tty})
) \aslto\\
(\overname{\staticenvs}{\newtenvp} \times\ \overname{\ty}{\ttyp} \times \overname{\TSideEffectSet}{\vses})\ \cup
\overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates the argument given by the identifier $\vx$ and the type $\tty$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The result is the updated environment $\newtenvp$, annotated argument type $\ttyp$,
and inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating a Subprogram Argument}
The specification in \listingref{AnnotateOneArg} shows well-typed argument declarations
and demonstrates how they exist as local storage elements in the subprogram body.
\ASLListing{Well-typed subprogram arguments}{AnnotateOneArg}{\typingtests/TypingRule.AnnotateOneArg.asl}

The specification in \listingref{AnnotateOneArg-bad1} is illegal, since arguments cannot share a name
with global storage elements, \verb|b| in this example.
\ASLListing{An ill-typed subprogram argument}{AnnotateOneArg-bad1}{\typingtests/TypingRule.AnnotateOneArg.bad1.asl}

The specification in \listingref{AnnotateOneArg-bad2} is illegal, since arguments cannot be typed
as \collectiontypesterm.
\ASLListing{An ill-typed subprogram argument}{AnnotateOneArg-bad2}{\typingtests/TypingRule.AnnotateOneArg.bad2.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyp, \vses)$\ProseOrTypeError;
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\ttyp$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatetype(\tenv, \tty) \typearrow (\ttyp, \vses) \OrTypeError \\\\
  \checkvarnotinenv(\newtenv, \vx) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \ttyp, \LDKLet) \typearrow \newtenvp
}{
  \annotateonearg(\tenv, \newtenv, (\vx, \tty))
  \typearrow (\newtenvp, \ttyp, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateReturnType}
\RenderRelation{annotate_return_type}
\BackupOriginalRelation{
The function
\[
\begin{array}{rl}
\annotatereturntype(
  \overname{\staticenvs}{\tenvwithparams} \aslsep
  \overname{\staticenvs}{\tenvwithargs} \aslsep
  \overname{\Option{\ty}}{\vreturntype} \aslsep
  \overname{\TSideEffectSet}{\vsesin}
) & \aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newreturntype} \times \overname{\TSideEffectSet}{\vses})
\cup\ \overname{\typeerror}{\TypeErrorConfig} &
\end{array}
\]
annotates the \optionalterm\ return type $\vreturntype$ in the context of the \staticenvironmentterm{}
$\tenvwithparams$, where all parameters have been declared,
and the \sideeffectsetterm\ $\vsesin$.
The result is $\newtenv$, which is the input $\tenvwithargs$ (where all parameters and arguments have been declared)
with the \optionalterm{} annotated return type $\newreturntype$ added
and the inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Subprogram Return Types}
In \listingref{MatchFuncRes}, the subprogram \verb|proc| has no return type.
Annotating its return type does not modify the \staticenvironmentterm{}, and the optional annotated return type is $\None$.
In contrast, the subprogram \verb|returns_value| updates the \staticenvironmentterm{} by
binding $\funcreturntype$ to $\unconstrainedinteger$ and returning $\unconstrainedinteger$
as the optional return type.

The specification in \listingref{AnnotateReturnType-bad} is ill-typed, since \collectiontypesterm{} are not allowed
as return types.
\ASLListing{An ill-typed return type}{AnnotateReturnType-bad}{\typingtests/TypingRule.AnnotateReturnType.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{no\_return\_type}
  \begin{itemize}
    \item $\vreturntype$ is $\None$;
    \item $\newtenv$ is $\tenvwithargs$;
    \item $\newreturntype$ is $\None$;
    \item \Proseeqdef{$\vses$}{$\vsesin$}.
  \end{itemize}

  \item \AllApplyCase{has\_return\_type}
  \begin{itemize}
    \item $\vreturntype$ is $\some{\tty}$;
    \item annotating $\tty$ in $\tenvwithparams$ yields $(\ttyp, \vsesty)$\ProseOrTypeError;
    \item $\newreturntype$ is $\some{\ttyp}$;
    \item $\newtenv$ is $\tenvwithargs$ with its local environment updated by binding its \\ $\funcreturntype$ field
          to $\newreturntype$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesin$ and $\vsesty$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_return\_type]{}
{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\None}{\vreturntype}, \vsesin) \typearrow \\
  (\overname{\tenvwithargs}{\newtenv}, \overname{\None}{\newreturntype}, \overname{\vsesin}{\vses})
  \end{array}
  }
}
\and
\inferrule[has\_return\_type]{
  \annotatetype(\tenvwithparams, \tty) \typearrow (\ttyp, \vsesty) \OrTypeError\\\\
  \newreturntype \eqdef \some{\ttyp}\\
  \newtenv \eqdef (G^\tenvwithargs, L^\tenvwithargs[\funcreturntype\mapsto\newreturntype])\\
  \vses \eqdef \vsesin \cup\ \vsesty
}{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\some{\tty}}{\returntype}, \vsesin) \typearrow \\
  (\newtenv, \newreturntype, \vses)
  \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{CheckSubprogramPurity}
\RenderRelation{check_subprogram_purity}
\BackupOriginalRelation{
The function
\[
\checksubprogrampurity(
  \overname{\Option{\qualifier}}{\vqualifier} \aslsep
  \overname{\TSideEffectSet}{\vses}
)
\aslto \overname{\Bool}{\vb} \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
checks that the \sideeffectsetterm{} $\vses$ is consistent with the subprogram qualifier $\vqualifier$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Checking subprogram purity}
In \listingref{SESForSubprogram}, the bodies of each subprogram are checked as follows:
\begin{itemize}
  \item the side effects of the body of \verb|foo| are all \pureterm{};
  \item the side effects of the body of \verb|bar| are all \readonlyterm{};
  \item the side effects of the body of \verb|goo| are not checked; and
  \item the side effects of the body of \verb|baz| are not checked.
\end{itemize}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none\_or\_noreturn}
  \begin{itemize}
    \item $\vqualifier$ is either $\None$ or $\some{\Noreturn}$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{some\_readonly}
  \begin{itemize}
    \item $\vqualifier$ is $\some{\Readonly}$;
    \item checking that all \sideeffectdescriptorsterm{} in $\vses$ are \readonlyterm{} yields $\True$\ProseOrTypeError;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{some\_pure}
  \begin{itemize}
    \item $\vqualifier$ is $\some{\Pure}$;
    \item checking that all \sideeffectdescriptorsterm{} in $\vses$ are \pureterm{} yields $\True$\ProseOrTypeError;
    \item $\vb$ is $\True$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none\_or\_noreturn]{
  \vqualifier = \None \lor \vqualifier = \some{\Noreturn}
}{
  \checksubprogrampurity(\vqualifier) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_readonly]{
  \sesisreadonly(\vses) \typearrow \True \OrTypeError
}{
  \checksubprogrampurity(\overname{\some{\Readonly}}{\vqualifier}) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_pure]{
  \sesispure(\vses) \typearrow \True \OrTypeError
}{
  \checksubprogrampurity(\overname{\some{\Pure}}{\vqualifier}) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\TypingRuleDef{DeclareOneFunc}
\RenderRelation{declare_one_func}
\BackupOriginalRelation{
The function
\[
  \declareonefunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\func}{\funcsig} \aslsep
    \overname{\TSideEffectSet}{\vsesfuncsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup\ \overname{\typeerror}{\TypeErrorConfig}
\]
checks that a subprogram defined by $\funcsig$
and associated with the \sideeffectsetterm\ $\vsesfuncsig$
can be added to the \staticenvironmentterm{} $\tenv$,
resulting in an annotated function definition $\newfuncdef$ and new \staticenvironmentterm{} $\newtenv$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

See \ExampleRef{Updating the Static Environment for a Subprogram}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\funcsig$ has name $\name$, arguments $\vargs$, and type $\subprogramtype$, that is,
  \[
    \begin{array}{rrcl}
      \funcsig \eqdef \{
                      & \funcname            &:& \name,\\
                      & \funcparameters      &:& \vp,\\
                      & \funcargs            &:& \vargs,\\
                      & \funcbody            &:& \bd,\\
                      & \funcreturntype      &:& \vt,\\
                      & \funcsubprogramtype  &:& \subprogramtype, \\
                      & \funcbuiltin         &:& \vb \\
                      & \funcqualifier       &:& \vqualifier \\
                  \}  & ; &&
        \end{array}
  \]
  \item adding a new subprogram with $\name$, $\vqualifier$, $\vargs$, and $\subprogramtype$ to $\tenv$ yields the new
        environment $\tenvone$ and new name $\namep$\ProseOrTypeError;
  \item checking that $\namep$ is not already declared in the global environment of $\tenvone$
        yields $\True$\ProseOrTypeError;
  \item $\funcsigone$ is $\funcsig$ with $\name$ substituted by $\namep$;
  \item adding a subprogram with name $\namep$, definition $\funcsigone$,
        and \sideeffectsetterm\ $\vsesfuncsig$ to $\tenvone$ yields $\newtenv$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rrcl}
    \funcsig \eqdef \{
                    & \funcname            &:& \name,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \bd,\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype, \\
                    & \funcbuiltin         &:& \vb \\
                    & \funcqualifier       &:& \vqualifier \\
                    & \funcoverride        &:& \voverride \\
                \} &&&
      \end{array}
    }\\
  \addnewfunc(\tenv, \vqualifier, \name, \vargs, \subprogramtype) \typearrow
  (\tenvone, \namep) \OrTypeError\\\\
  \checktrans{G^\tenvone.\subprograms(\namep) = \bot}{\IdentifierAlreadyDeclared} \checktransarrow \True \terminateas \IdentifierAlreadyDeclared \\\\
  \newfuncsig \eqdef \funcsig[\funcname \mapsto \namep] \\\\
  \addsubprogram(\tenvone, \namep, \funcsigone, \vsesfuncsig) \typearrow \newtenv \OrTypeError
}{
  \declareonefunc(\tenv, \funcsig, \vsesfuncsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}
\CodeSubsection{\DeclareOneFuncBegin}{\DeclareOneFuncEnd}{../Typing.ml}
\identi{HJRD} \identd{BTBR} \identi{FSFQ} \identi{PFGQ} \identr{PGFC}

\TypingRuleDef{SubprogramClash}
\RenderRelation{subprogram_clash}
\BackupOriginalRelation{
The function
\[
  \begin{array}{rl}
  \subprogramclash
    (
      \overname{\staticenvs}{\tenv} \aslsep
      \overname{\Strings}{\name} \aslsep
      \overname{\subprogramtype}{\subpgmtype} \aslsep
      \overname{\qualifier}{\vqualifier} \aslsep
      \overname{\KleeneStar{\ty}}{\formaltypes}
    )
  & \aslto \\
    \overname{\Bool}{\vb} \cup\ \overname{\typeerror}{\TypeErrorConfig} &
  \end{array}
\]
checks whether the unique subprogram associated with $\name$
clashes with another subprogram
that has subprogram type $\subpgmtype$, qualifier $\vqualifier$, and list of formal types $\formaltypes$,
yielding a Boolean value in $\vb$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

The function assumes there exists a binding for $\name$ in the
$\subprograms$ map of $\tenv$.

\ExampleDef{Subprogram Clashing}
In \listingref{SubprogramTypesClash}, the getter for \verb|X| and the setter for \verb|X| do not clash,
since they have non-clashing subprogram types (see \TypingRuleRef{SubprogramTypesClash}).

In \listingref{SubprogramTypesClash-bad1}, the getter for \verb|X| and the function \verb|X| clash,
since their subprogram types clash and their signatures clash (see \TypingRuleRef{HasArgClash}).

In \listingref{SubprogramTypesClash-bad2}, the function \verb|X| and the procedure \verb|X| clash
since their subprogram types clash and their signatures clash.

In \listingref{SubprogramClash-bad1}, the function \verb|X| and the procedure \verb|X| clash since subprogram types clash and their qualifiers differ.
\ASLListing{Clashing subprogram qualifiers}{SubprogramClash-bad1}{\typingtests/TypingRule.SubprogramClash.bad1.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item the identifier $\name$ is bound to the $\func$ AST node $\otherfuncsig$ in the \\
        $\subprograms$ map
        of the static global environment of $\tenv$ (ignoring the associated \sideeffectdescriptorsterm);
  \item applying $\subprogramtypesclash$ to the subprogram type of $\otherfuncsig$ \\
        ($\otherfuncsig.\subprogramtype$) and $\subpgmtype$ yields \\
        $\vbone$;
  \item determining whether the qualifier of $\otherfuncsig$ is not equal to $\vqualifier$ yields $\vbtwo$;
  \item determining whether there is an argument clash between $\formaltypes$ and \\
        the formal arguments of $\otherfuncsig$ ($\otherfuncsig.\funcargs$) in $\tenv$ yields $\vbthree$\ProseOrTypeError.
  \item \Proseeqdef{$\vb$}{$\vbone \land (\vbtwo \lor \vbthree)$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  G^\tenv.\subprograms(\name) = (\otherfuncsig, \Ignore)\\
  \subprogramtypesclash(\otherfuncsig.\subprogramtype, \subpgmtype) \typearrow \vbone\\
  \vbtwo \eqdef \otherfuncsig.\funcqualifier \neq \vqualifier \\
  \hasargclash(\formaltypes, \otherfuncsig.\funcargs) \typearrow \vbthree
}{
  \subprogramclash(\tenv, \name, \subpgmtype, \vqualifier, \formaltypes) \typearrow \overname{\vbone \land (\vbtwo \lor \vbthree)}{\vb}
}
\end{mathpar}
\identd{BTBR} \identi{FSFQ} \identi{PFGQ}

\TypingRuleDef{SubprogramTypesClash}
\RenderRelation{subprogram_types_clash}
\BackupOriginalRelation{
The function
\[
  \subprogramtypesclash(
    \overname{\subprogramtype}{\vsone} \aslsep
    \overname{\subprogramtype}{\vstwo}
  ) \aslto \overname{\Bool}{\vb}
\]
defines whether the subprogram types $\vsone$ and
$\vstwo$ clash, yielding the result in $\vb$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Clashing Subprogram Types}

The specification in \listingref{SubprogramTypesClash} contains an accessor for \verb|X|.
The subprogram type of its getter does not clash with the subprogram type of its setter.
\ASLListing{Non-clashing subprogram types}{SubprogramTypesClash}{\typingtests/TypingRule.SubprogramTypesClash.asl}

The specification in \listingref{SubprogramTypesClash-bad1} contains an accessor for \verb|X|.
The subprogram types of its getter and setter both clash with the subprogram type of the procedure \verb|X| ($\STProcedure$).
\ASLListing{Clashing subprogram types}{SubprogramTypesClash-bad1}{\typingtests/TypingRule.SubprogramTypesClash.bad1.asl}

The specification in \listingref{SubprogramTypesClash-bad2} contains a function \verb|X| and a procedure \verb|X|
whose subprogram types ($\STFunction$ and $\STProcedure$, respectively) clash.
\ASLListing{Clashing subprogram types}{SubprogramTypesClash-bad2}{\typingtests/TypingRule.SubprogramTypesClash.bad2.asl}

\ProseParagraph
\ProseEqdef{$\vb$}{$\True$ unless
$\vsone$ is $\STGetter$ and $\vstwo$ is $\STSetter$ or
$\vsone$ is $\STSetter$ and $\vstwo$ is $\STGetter$}.

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
  \vb \eqdef (\vsone, \vstwo) \not\in
  \left\{
  \begin{array}{l}
    (\STGetter,       \STSetter),\\
    (\STSetter,       \STGetter)
  \end{array}
  \right\}
  }
}{
  \subprogramtypesclash(\subpgmtypeone, \subpgmtypetwo) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{AddNewFunc}
\RenderRelation{add_new_func}
\BackupOriginalRelation{
The function
\[
  \begin{array}{rl}
  \addnewfunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Identifier}{\name} \aslsep
    \overname{\Option{\qualifier}}{\vqualifier} \aslsep
    \overname{\KleeneStar{\typedidentifier}}{\formals} \aslsep
    \overname{\subprogramtype}{\subpgmtype})
  & \aslto\\
  (\overname{\staticenvs}{\newtenv} \times \overname{\Strings}{\newname})
  \cup\ \overname{\typeerror}{\TypeErrorConfig} &
  \end{array}
\]
ensures that the subprogram given by the identifier $\name$, qualifier $\vqualifier$, list of formals $\formals$,
and subprogram type $\subpgmtype$ has a unique name among all the potential subprograms
that overload $\name$.
The result is the unique subprogram identifier $\newname$, which is used to distinguish it in the set
of overloaded subprograms (that is, other subprograms that share the same name)
and the environment $\newtenv$, which is updated with $\newname$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

The function $\addnewfunc$ updates the $\overloadedsubprograms$ map in the \staticenvironmentterm{},
and must be followed by $\addsubprogram$, which updates the $\subprograms$ map (see \TypingRuleRef{AddSubprogram}).

\ExampleDef{Updating the Static Environment for a Subprogram}
The specification in \listingref{DeclareSubprograms}
contains two subprograms named \verb|add_10| with the signatures
\verb|func add_10(x: integer) => integer| and
\verb|func add_10(x: real) => real|, which for brevity we will refer to by
$I$ and $R$, respectively.
These subprograms are added to the \staticenvironmentterm{}
based on the dependency ordering \\
(see \TypingRuleRef{DeclDependencies}).
In this case, there is no ordering between these two subprograms.
Assuming $I$ is processed before $R$, adding $I$ to the
\staticenvironmentterm{}, the \staticenvironmentterm{} has
$\overloadedsubprograms(\addten) = \bot$
and is then updated by binding $\addten$ to $\{\addten\}$ in $\overloadedsubprograms$.
Then, processing $R$, results in
binding $\addten$ to
$\{\addten, \addtenone\}$ where \addtenone{} will be used for $R$.

\ExampleDef{Illegal Subprogram Declarations due to Clashes}
The specifications in \listingref{AddNewFunc-bad1},
\listingref{AddNewFunc-bad2}, and
\listingref{AddNewFunc-bad3}
are ill-typed due to subprogram declaration clashes.
\ASLListing{Subprogram clashes}{AddNewFunc-bad1}{\typingtests/TypingRule.AddNewFunc.bad1.asl}
\ASLListing{Subprogram clashes}{AddNewFunc-bad2}{\typingtests/TypingRule.AddNewFunc.bad2.asl}
\ASLListing{Subprogram clashes}{AddNewFunc-bad3}{\typingtests/TypingRule.AddNewFunc.bad3.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{first\_name}
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ does not have a binding for $\name$;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the singleton set containing
          $\name$.
  \end{itemize}

  \item \AllApplyCase{name\_exists}
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ binds $\name$ to the set of strings $\othernames$;
    \item $\newname$ is the unique name that will be associated with the subprogram given by the identifier $\name$, list of formals $\formals$,
          and subprogram type $\subpgmtype$. It is constructed by concatenating a hyphen (\texttt{-}) to $\name$, followed
          by a string corresponding to the number of strings in $\othernames$.
          Notice that this is not an ASL identifier, as ASL identifiers do not contain hyphens, which ensures that this string
          does not occur in any specification;
    \item $\formaltypes$ is the list of types that appear in $\formals$ in the same order;
    \item checking for each $\namep$ in $\othernames$ whether the subprogram associated with $\namep$ clashes
          with the subprogram type $\subpgmtype$ and list of types $\formaltypes$ yields $\False$
          or a \typingerrorterm{} that indicates there are multiply defined subprograms, which short-circuits the entire rule;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the union of $\othernames$ and
          $\{\newname\}$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[first\_name]{
  G^\tenv.\overloadedsubprograms(\name) = \bot\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto\{\name\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \vqualifier, \formals, \subpgmtype) \typearrow
  (\newtenv, \overname{\name}{\newname})
}
\end{mathpar}

\begin{mathpar}
\inferrule[name\_exists]{
  G^\tenv.\overloadedsubprograms(\name) = \othernames\\
  k \eqdef \cardinality{\othernames}\\
  \newname \eqdef \name\ \stringconcat\ \discardvarstr\ \stringconcat\ \stringofnat(k)\\
  \formaltypes \eqdef [(\id,\vt) \in \formals : \vt]\\
  {
    \left(\begin{array}{l}
  \namep \in \othernames: \\ \subprogramclash(\tenv, \namep, \subpgmtype, \vqualifier, \formaltypes) \typearrow
  \vb_{\namep} \OrTypeError
    \end{array}\right)
  }\\\\
  \namep \in \othernames: \checktrans{\neg\vb_{\namep}}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError\\\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto \othernames \cup\ \{\newname\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \vqualifier, \formals, \subpgmtype) \typearrow
  (\newtenv, \newname)
}
\end{mathpar}
\identr{PGFC}
\CodeSubsection{\AddNewFuncBegin}{\AddNewFuncEnd}{../Typing.ml}

\TypingRuleDef{Subprogram}
\RenderRelation{annotate_subprogram}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
  \annotatesubprogram(\overname{\staticenvs}{\tenv} \aslsep \overname{\func}{\vf} \aslsep \overname{\TSideEffectSet}{\vsesfuncsig})
  \aslto \\
  (\overname{\func}{\vfp} \times \overname{\TSideEffectSet}{\vses})\ \cup \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates a subprogram $\vf$ in an environment $\tenv$ and \sideeffectsetterm\ $\vsesfuncsig$, resulting in an annotated subprogram $\vfp$
and inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

Note that the return type in $\vf$ has already been annotated by $\annotatefuncsig$.

\ExampleDef{Annotating Subprograms}
\listingref{typing-subprogram} shows an example of a well-typed procedure --- \verb|my_procedure|
and an example of a well-typed function --- \verb|flip_bits|.
\ASLListing{Typing subprograms}{typing-subprogram}{\typingtests/TypingRule.Subprogram.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating $\vf.\funcbody$ in $\tenv$ as per \TypingRuleRef{Block} yields \\
        $(\newbody, \vsesbody)$\ProseOrTypeError;
  \item applying $\checkcontrolflow$ to $\tenv$, $\vf$, and $\newbody$ yields $\True$\ProseOrTypeError;
  \item $\vfp$ is $\vf$ with the subprogram body substituted with $\newbody$;
  \item \Proseeqdef{$\vsesp$}{the union of $\vsesfuncsig$ and $\vsesbody$ with every \LocalEffectTerm{} removed};
  \item checking that the \sideeffectsetterm{} $\vsesp$ adheres to the subprogram's \purity{} qualifier $\vf.\funcqualifier$ yields $\True$\ProseOrTypeError;
  \item the \sideeffectsetterm{} corresponding to $\vf.\funcqualifier$ (via \\
        $\sesforsubprogram$) is $\vses$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateblock(\tenv, \vf.\funcbody) \typearrow (\newbody, \vsesbody) \OrTypeError\\\\
  \checkcontrolflow(\tenv, \vf, \newbody) \typearrow \True \OrTypeError\\\\
  \vfp \eqdef \substrecordfield(\vf, \funcbody, \newbody)\\
  \vsesp \eqdef \vsesfuncsig \cup (\vsesbody \setminus \{ \vs \;|\; \configdomain{\vs} = \LocalEffect \}) \\
  \checksubprogrampurity(\vf.\funcqualifier, \vsesp) \typearrow \True \OrTypeError \\
  \sesforsubprogram(\vf.\funcqualifier) \typearrow \vses
}{
  \annotatesubprogram(\tenv, \vf, \vsesfuncsig) \typearrow (\vfp, \vses)
}
\end{mathpar}

\identi{GHGK} \identr{HWTV} \identr{SCHV} \identr{VDPC}
\identr{TJKQ} \identi{LFJZ} \identi{BZVB} \identi{RQQB}
\CodeSubsection{\SubprogramBegin}{\SubprogramEnd}{../Typing.ml}

\TypingRuleDef{CheckControlFlow}
\RenderRelation{check_control_flow}
\BackupOriginalRelation{
The function
\[
  \checkcontrolflow(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\func}{\vf} \aslsep
    \overname{\stmt}{\vbody})
  \typearrow \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether the annotated body statement $\vs$ of the function definition $\vf$
obeys the control-flow requirements in the \staticenvironmentterm{} $\tenv$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Ensuring All Terminating Paths Terminate Correctly}
In \listingref{CheckControlFlow}, every evaluation of the function body for\\
\verb|all_terminating_paths_correct| terminates by either returning
a value, throwing an exception, or evaluating an \unreachablestatementterm.
\ASLListing{All terminating paths terminate correctly}{CheckControlFlow}{\typingtests/TypingRule.CheckControlFlow.asl}

In \listingref{CheckControlFlow-bad2}, the path through the function body
for \verb|incorrect_terminating_path|
where \verb|v != Zeros{N}| evaluates to
$\True$ and \verb|flag| evaluates to $\False$ terminates without
returning a value, throwing an exception, or evaluating an \unreachablestatementterm,
which is a \typingerrorterm.
\ASLListing{An incorrectly terminating path}{CheckControlFlow-bad2}{\typingtests/TypingRule.CheckControlFlow.bad2.asl}

\ExampleDef{Illegally returning from a \texttt{noreturn} Subprogram}
The specification in \listingref{CheckControlFlow-bad3}
is ill-typed as \verb|returning| is declared with the \verb|noreturn|
qualifier, yet it returns via a \passstatementterm.
\ASLListing{Illegally returning from a \texttt{noreturn} subprogram}{CheckControlFlow-bad3}{\typingtests/TypingRule.CheckControlFlow.bad3.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\approxstmt$ to $\tenv$ and $\vbody$ yields $\absconfigs$;
  \item checking that $\absconfigs$ is a subset of the set of \Proseabstractconfigurations{}
        allowed for $\vf$, as determined by $\allowedabsconfigs$ yields $\True$\ProseTerminateAs{\BadSubprogramDeclaration}.
  \item the result is $\True$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \approxstmt(\tenv, \vbody) \typearrow \absconfigs\\
  \checktrans{\absconfigs \subseteq \allowedabsconfigs(\vf)}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError
}{
  \checkcontrolflow(\tenv, \vf, \vbody) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{AllowedAbsConfigs}
\RenderRelation{allowed_abs_configs}
\BackupOriginalRelation{
The function
\[
  \allowedabsconfigs(\overname{\func}{\vf})
  \typearrow \overname{\pow{\{\AbsContinuing, \AbsReturning, \AbsAbnormal\}}}{\absconfigs}
\]
determines the set of \Proseabstractconfigurations{} allowed for the function definition $\vf$,
yielding the result in $\absconfigs$.
} % END_OF_BACKUP_RELATION

\ExampleDef{The Allowed Abstract Configurations for a Subprogram}
The set of \Proseabstractconfigurations{} allowed for the subprogram \\
\verb|all_terminating_paths_correct|
in \listingref{CheckControlFlow} is $\{\AbsAbnormal, \AbsReturning\}$, since it is
a function.

The set of \Proseabstractconfigurations{} allowed for the subprogram \verb|returning|
in \listingref{CheckControlFlow-bad3} is $\{\AbsAbnormal\}$, since it is qualified
by \verb|noreturn|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{noreturn}
  \begin{itemize}
    \item $\vf$ is qualified by \verb|noreturn|;
    \item \Proseeqdef{$\absconfigs$}{the set consisting of $\AbsAbnormal$}.
  \end{itemize}

  \item \AllApply
  \begin{itemize}
    \item $\vf$ is not qualified by \verb|noreturn|;
    \OneApplies
    \begin{itemize}
      \item \AllApplyCase{returning\_proc}
      \begin{itemize}
        \item $\vf$ is a procedure;
        \item \Proseeqdef{$\absconfigs$}{the set consisting of $\AbsContinuing$, \\
              $\AbsReturning$, and $\AbsAbnormal$}.
      \end{itemize}

      \item \AllApplyCase{func}
      \begin{itemize}
        \item $\vf$ is as function;
        \item \Proseeqdef{$\absconfigs$}{the set consisting of $\AbsReturning$, \\
              $\AbsAbnormal$}.
      \end{itemize}
    \end{itemize}
  \end{itemize}

\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[noreturn]{
  \vf.\funcqualifier = \some{\Noreturn}
}{
  \allowedabsconfigs(\vf) \typearrow \overname{\{\AbsAbnormal\}}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[returning\_proc]{
  \vf.\funcqualifier \neq \some{\Noreturn} \land \vf.\funcreturntype = \None
}{
  \allowedabsconfigs(\vf) \typearrow \overname{\{\AbsContinuing, \AbsReturning, \AbsAbnormal\}}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[func]{
  \vf.\funcqualifier \neq \some{\Noreturn} \land \vf.\funcreturntype \neq \None
}{
  \allowedabsconfigs(\vf) \typearrow \overname{\{\AbsReturning, \AbsAbnormal\}}{\absconfigs}
}
\end{mathpar}

\TypingRuleDef{ApproxStmt}
\RenderRelation{approx_stmt}
\BackupOriginalRelation{
The function
\[
  \approxstmt(\overname{\staticenvs}{\tenv} \aslsep \overname{\stmt}{\vs})
  \typearrow\overname{\{\AbsContinuing, \AbsReturning, \AbsAbnormal\}}{\absconfigs}
\]
returns in $\absconfigs$ a superset of the set of \Proseabstractconfigurations{} (defined next),
that an evaluation of $\vs$ in any environment consisting of the \staticenvironmentterm{} $\tenv$ yields.
} % END_OF_BACKUP_RELATION

The type \RenderType{abstract_configuration}
of \emph{\Proseabstractconfigurations{}} consists of symbols that represent
subsets of the set of dynamic configurations that may be returned by
$\evalstmt((\tenv, \cdot), \vs)$:
\begin{itemize}
  \item $\AbsContinuing$ represents $\TContinuing$;
  \item $\AbsReturning$ represents $\TReturning$; and
  \item $\AbsAbnormal$ represents $\TThrowing \cup \TDynError$.
\end{itemize}

\ExampleDef{Determining the Abstract Configurations of Statements}
In \listingref{ApproxStmt}, the function bodies of all functions
terminate by either returning a value, throwing an exception, or executing
the \unreachablestatementterm.
\ASLListing{Determining the abstract configurations of statements}{ApproxStmt}{\typingtests/TypingRule.ApproxStmt.asl}

In \listingref{ApproxStmt-bad1}, the function body of \verb|loop_forever|
is ill-typed, since the conservative analysis of \TypingRuleRef{ApproxStmt}
cannot determine that the \whilestatementterm{} never terminates.
To make the function body well-typed, another statement following the loop
can be added, for example, an \unreachablestatementterm.
\ASLListing{An ill-typed function body}{ApproxStmt-bad1}{\typingtests/TypingRule.ApproxStmt.bad1.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{s\_pass}
  \begin{itemize}
    \item $\vs$ is a \passstatementterm;
    \item \Proseeqdef{$\absconfigs$}{the singleton set for $\AbsContinuing$}.
  \end{itemize}

  \item \AllApplyCase{simple}
  \begin{itemize}
    \item $\vs$ is either a \declarationstatementterm, an \assignmentstatementterm,
          an \assertionstatementterm, or a \printstatementsterm;
    \item \Proseeqdef{$\absconfigs$}{the set consisting of $\AbsContinuing$ and \\
          $\AbsAbnormal$}.
  \end{itemize}

  \item \AllApplyCase{s\_unreachable}
  \begin{itemize}
    \item $\vs$ is the \unreachablestatementterm;
    \item \Proseeqdef{$\absconfigs$}{the singleton set for $\AbsAbnormal$}.
  \end{itemize}

  \item \AllApplyCase{s\_call}
  \begin{itemize}
    \item $\vs$ is a \callstatementterm{} consisting of the call record $\call$, that is, $\SCall(\call)$;
    \item \Proseeqdef{$\vf$}{the $\func$ AST node bound to $\call.\callname$ in the \globalstaticenvironmentterm
          map $\subprograms$};
    \item \Proseeqdef{$\absconfigs$}{the singleton set for $\AbsAbnormal$, if $\vf$ has the\\
          \texttt{noreturn} qualifier, and the set consisting of $\AbsContinuing$ and \\
          $\AbsAbnormal$ otherwise}.
  \end{itemize}

  \item \AllApplyCase{s\_return}
  \begin{itemize}
    \item $\vs$ is a \returnstatementsterm;
    \item \Proseeqdef{$\absconfigs$}{the set consisting of $\AbsReturning$ and $\AbsAbnormal$}.
  \end{itemize}

  \item \AllApplyCase{s\_throw}
  \begin{itemize}
    \item $\vs$ is a \throwstatementsterm;
    \item  \Proseeqdef{$\absconfigs$}{the singleton set for $\AbsAbnormal$}.
  \end{itemize}

  \item \AllApplyCase{s\_seq}
  \begin{itemize}
    \item $\vs$ is the \sequencingstatement{$\vsone$}{$\vstwo$};
    \item applying $\approxstmt$ to $\tenv$ and $\vsone$ yields $\configsone$;
    \item applying $\approxstmt$ to $\tenv$ and $\vstwo$ yields $\configstwo$;
    \item for each \Proseabstractconfiguration{} $\vc$ in $\configsone$ \Proseeqdef{$\vs_\vc$}{
      $\configstwo$ if $\vc$ is $\AbsContinuing$ and the singleton set for $\vc$ otherwise};
    \item \Proseeqdef{$\absconfigs$}{the union of the sets $\vs_\vc$ for each \Proseabstractconfiguration{} $\vc$ in $\configsone$}.
  \end{itemize}

  \item \AllApplyCase{s\_repeat}
  \begin{itemize}
    \item $\vs$ is a \repeatstatementsterm{} with body statement $\vbody$;
    \item applying $\approxstmt$ to $\tenv$ and $\vbody$ yields $\bodyconfigs$;
    \item \Proseeqdef{$\absconfigs$}{the union of $\bodyconfigs$ and $\AbsAbnormal$}.
  \end{itemize}

  \item \AllApplyCase{s\_while\_for}
  \begin{itemize}
    \item $\vs$ matches one of the following statements:
          a \forstatementterm{} with body statement $\vbody$, or a \whilestatementterm{} with body statement $\vbody$;
    \item applying $\approxstmt$ to $\tenv$ and $\vbody$ yields $\bodyconfigs$;
    \item \Proseeqdef{$\absconfigs$}{the union of $\bodyconfigs$, $\AbsAbnormal$, and \\ $\AbsContinuing$}.
  \end{itemize}

  \item \AllApplyCase{s\_cond}
  \begin{itemize}
    \item $\vs$ is a \conditionalstatement{$\Ignore$}{$\vsone$}{$\vstwo$};
    \item applying $\approxstmt$ to $\tenv$ and $\vsone$ yields $\configsone$;
    \item applying $\approxstmt$ to $\tenv$ and $\vstwo$ yields $\configstwo$;
    \item \Proseeqdef{$\absconfigs$}{the union of $\configsone$, $\configstwo$, and $\AbsAbnormal$}.
  \end{itemize}

  \item \AllApplyCase{s\_try}
  \begin{itemize}
    \item $\vs$ is the \trystatement{$\vbody$}{\\
          $\catchers$}{$\otherwise$};
    \item applying $\approxstmt$ to $\tenv$ and $\vbody$ yields $\bodyconfigs$;
    \item \Proseeqdef{$\otherwiseconfigs$}{the application of $\approxstmt$ to $\tenv$ and $\votherwise$,
          if $\votherwise$ is the optional containing $\otherwises$ and the empty set otherwise};
    \item for every statement $\vc$ appearing in a catcher in the list $\catchers$, applying $\approxstmt$ to $\tenv$ and $\vc$
          yields $\catchconfigs_\vc$;
    \item \Proseeqdef{$\absconfigs$}{the union of $\bodyconfigs$, $\otherwiseconfigs$,
          and  $\catchconfigs_\vc$, for every statement $\vc$ appearing in a catcher in the list $\catchers$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[s\_pass]{}{
  \approxstmt(\tenv, \overname{\SPass}{\vs}) \typearrow \overname{\{\AbsContinuing\}}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[simple]{
  \configdomain{\vs} \in \{\SDecl, \SAssign, \SAssert, \SPrint\}
}{
  \approxstmt(\tenv, \vs) \typearrow \overname{\{\AbsContinuing, \AbsAbnormal\}}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_unreachable]{}{
  \approxstmt(\tenv, \overname{\SUnreachable}{\vs}) \typearrow \overname{\{\AbsAbnormal \}}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_call]{
  G^\tenv.\subprograms(\call.\callname) = (\vf, \Ignore)\\
  {
  \absconfigs \eqdef
  \begin{cases}
    \{\AbsAbnormal\} & \text{if }\vf.\funcqualifier = \some{\Noreturn}\\
    \{\AbsContinuing, \AbsAbnormal\} & \text{else}
  \end{cases}
  }
}{
  \approxstmt(\tenv, \overname{\SCall(\call)}{\vs}) \typearrow \absconfigs
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_return]{}{
  \approxstmt(\tenv, \overname{\SReturn(\Ignore)}{\vs}) \typearrow \overname{\{\AbsReturning, \AbsAbnormal \}}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_throw]{}{
  \approxstmt(\tenv, \overname{\SThrow(\Ignore)}{\vs}) \typearrow \overname{\{\AbsAbnormal \}}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_seq]{
  \approxstmt(\tenv, \vsone) \typearrow \configsone\\
  \approxstmt(\tenv, \vstwo) \typearrow \configstwo\\
  \vc\in\configsone: \vs_\vc \eqdef \choice{\vc = \AbsContinuing}{\configstwo}{\{\vc\}}\\
  \absconfigs \eqdef \bigcup_{\vc\in\configsone} \vs_\vc
}{
  \approxstmt(\tenv, \overname{\SSeq(\vsone, \vstwo)}{\vs}) \typearrow \absconfigs
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_repeat]{
  \approxstmt(\tenv, \vbody) \typearrow \bodyconfigs
}{
  \approxstmt(\tenv, \overname{\SRepeat(\vbody, \Ignore, \Ignore)}{\vs}) \typearrow \overname{\bodyconfigs \cup \{\AbsAbnormal\}}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_while\_for]{
  {
  \left(
  \begin{array}{rcll}
    \vs &=& \SFor \{ \Forbody : \vbody, \ldots \} &\lor\\
    \vs &=& \SWhile(\Ignore, \Ignore, \vbody) &
  \end{array}
  \right)
  }\\
  \approxstmt(\tenv, \vbody) \typearrow \bodyconfigs\\
}{
  \approxstmt(\tenv, \vs) \typearrow \overname{\bodyconfigs \cup \{\AbsAbnormal, \AbsContinuing\}}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_cond]{
  \approxstmt(\tenv, \vsone) \typearrow \configsone\\
  \approxstmt(\tenv, \vstwo) \typearrow \configstwo
}{
  \approxstmt(\tenv, \overname{\SCond(\Ignore, \vsone, \vstwo)}{\vs}) \typearrow \overname{\{\AbsAbnormal\} \cup \vsone \cup \vstwo}{\absconfigs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_try]{
  \approxstmt(\vbody, \vsone) \typearrow \bodyconfigs\\
  {
    \otherwiseconfigs \eqdef \left\{
    \begin{array}{ll}
    \textbf{if}   & \votherwise=\some{\otherwises}\textbf{ then}\\
                  & \approxstmt(\tenv, \otherwises)\\
    \textbf{else} & \emptyset
    \end{array}\right.
  }\\
  (\Ignore,\Ignore,\vc)\in\catchers: \approxstmt(\tenv, \vc) \typearrow \catchconfigs_\vc\\
  {
  \absconfigs \eqdef \left\{
  \begin{array}{ll}
  \bodyconfigs & \cup\\
  \otherwiseconfigs & \cup\\
  \bigcup_{(\Ignore,\Ignore,\vc)\in\catchers} \catchconfigs_\vc &
  \end{array}\right.
  }
}{
  \approxstmt(\tenv, \overname{\STry(\vbody, \catchers, \votherwise)}{\vs}) \typearrow \absconfigs
}
\end{mathpar}
