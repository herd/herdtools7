\chapter{Subprogram Declarations\label{chap:SubprogramDeclarations}}

Subprogram declarations are grammatically derived from $\Ndecl$ via the subset of productions shown in
\secref{SubprogramDeclarationsSyntax} and represented as ASTs via the production of $\decl$
shown in \secref{SubprogramDeclarationsAbstractSyntax}.
%
Subprogram declarations are typed via $\annotateanddeclarefunc$, which is defined in \TypingRuleRef{AnnotateAndDeclareFunc}.
%
Subprogram declarations have no associated semantics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax\label{sec:SubprogramDeclarationsSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Ndecl  \derives \ & \Noverride \parsesep \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nreturntype \\
& \wrappedline\ \Nrecurselimit \parsesep \Nfuncbody &\\
|\ & \Noverride \parsesep \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nfuncbody &\\
|\ & \Noverride \parsesep \Taccessor \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Tbiarrow \parsesep \Tidentifier \parsesep \Nasty &\\
   & \wrappedline\ \Naccessorbody &\\
\Naccessorbody \derives \ & \Tbegin \parsesep \Naccessors \parsesep \Tend \parsesep \Tsemicolon&
\end{flalign*}

\begin{flalign*}
\Nrecurselimit   \derives \ & \Trecurselimit \parsesep \Nexpr &\\
|\              & \emptysentence &\\
\Nparamsopt \derives \ & \emptysentence &\\
                   |\ & \Tlbrace \parsesep \ClistZero{\Nopttypedidentifier} \parsesep \Trbrace &\\
\Nopttypedidentifier \derives \ & \Tidentifier \parsesep \option{\Nasty} &\\
\Nfuncargs          \derives \ & \Tlpar \parsesep \ClistZero{\Ntypedidentifier} \parsesep \Trpar &\\
\Nreturntype        \derives \ & \Tarrow \parsesep \Nty &\\
\Nfuncbody          \derives \ & \Tbegin \parsesep \Nmaybeemptystmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Nmaybeemptystmtlist \derives \ & \emptysentence \;|\; \Nstmtlist &\\
\Naccessors \derives \ &
  \Tgetter \parsesep \Nmaybeemptystmtlist \parsesep \Tend \parsesep \Tsemicolon \parsesep \\ & \wrappedline
  \Tsetter \parsesep \Nmaybeemptystmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
|\ & \Tsetter \parsesep \Nmaybeemptystmtlist \parsesep \Tend \parsesep \Tsemicolon \parsesep \\ & \wrappedline
    \Tgetter \parsesep \Nmaybeemptystmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Noverride \derivesinline\ & \emptysentence \;|\; \Timpdef \;|\;\Timplementation &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Syntax\label{sec:SubprogramDeclarationsAbstractSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\decl \derives\ & \DFunc(\func) &
\end{flalign*}

\begin{flalign*}
\func \derives\ &
{
\left\{
  \begin{array}{rcl}
 \funcname &:& \Strings, \\
 \funcparameters &:& (\identifier, \ty?)^*,\\
 \funcargs &:& \typedidentifier^*,\\
 \funcbody &:& \stmt,\\
 \funcreturntype &:& \ty?,\\
 \funcsubprogramtype &:& \subprogramtype,\\
 \funcrecurselimit    &:& \expr?\\
 \funcbuiltin &:& \Bool\\
 \funcoverride &:& \Some{\overrideinfo}\\
\end{array}
\right\}
} &\\
\typedidentifier \derives\ & (\identifier, \ty) &\\
\subprogramtype \derives\ & \STProcedure \;|\; \STFunction &\\
                |\  & \STGetter \;|\; \STSetter &\\
\overrideinfo \derives\ & \Impdef \;|\; \Implementation &
\end{flalign*}

\ASTRuleDef{GlobalDecl}
The relation
\[
  \builddecl : \overname{\parsenode{\Ndecl}}{\vparsednode} \;\aslrel\; \overname{\decl^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

We first define $\accessorpair$, which we use in this section as an intermediate representation between the syntax forms of accessors and their corresponding abstract syntax.
In particular, rather than directly building the abstract syntax for accessors, we first build an $\accessorpair$ structure, which we then desugar into abstract syntax.

\hypertarget{ast-accessorpair}{}
\begin{flalign*}
\accessorpair \derives\ &
{
\left\{
  \begin{array}{rcl}
    \accessorpairgetter &:& \stmt, \\
    \accessorpairsetter &:& \stmt
\end{array}
\right\}
} &
\end{flalign*}

\begin{mathpar}
\inferrule[func\_decl]{}{
  \builddecl\left(
    \overname{\Ndecl\left(
      \begin{array}{l}
    \punnode{\Noverride}, \Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \punnode{\Nreturntype}, \\
    \wrappedline\ \punnode{\Nrecurselimit}, \punnode{\Nfuncbody}
      \end{array}
  \right)}{\vparsednode}\right)
\astarrow \\
{
    \overname{
  \left[\DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \astof{\vfuncbody},\\
            \funcreturntype &:& \langle \astof{\vreturntype} \rangle,\\
            \funcsubprogramtype &:& \STFunction,\\
            \funcrecurselimit   &:& \langle\astof{\vrecurselimit}\rangle\\
            \funcbuiltin &:& \False\\
            \funcoverride &:& \astof{\voverride}
    \end{array}
  \right\}\right)\right]}{\vastnode}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[procedure\_decl]{}{
  \builddecl(
    \overname{\Ndecl(\punnode{\Noverride}, \Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \punnode{\Nfuncbody})}{\vparsednode}
    )
  \astarrow \\
  {
    \overname{
  \left[\DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \astof{\vfuncbody},\\
            \funcreturntype &:& \None,\\
            \funcsubprogramtype &:& \STProcedure,\\
            \funcrecurselimit   &:& \None\\
            \funcbuiltin &:& \False\\
            \funcoverride &:& \astof{\voverride}
    \end{array}
  \right\}\right)\right]
    }{\vastnode}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[accessor]{
  \buildaccessorbody(\vbody) \astarrow \vaccessorpair \\
  {
  \desugaraccessorpair\left(
    \begin{array}{l}
    \voverride,\\
    \name,\\
    \astof{\vparamsopt},\\
    \astof{\vfuncargs},\\
    \vsetterarg,\\
    \astof{\tty},\\
    \vaccessorpair
    \end{array}
    \right) \astarrow \vastnode
  }
}{
  {
  \begin{array}{r}
    \builddecl\left(\overname{\Ndecl\left(
      \begin{array}{l}
        \punnode{\Noverride}, \Taccessor, \Tidentifier(\name), \punnode{\Nparamsopt},  \\
        \wrappedline\ \punnode{\Nfuncargs},
        \Tbiarrow, \Tidentifier(\vsetterarg), \punnode{\Nasty}, \namednode{\vbody}{\Naccessorbody}
      \end{array}
    \right)}{\vparsednode}\right)
  \\ \astarrow \vastnode
  \end{array}
  }
}
\end{mathpar}

\subsection{Example}
\listingref{AccessorDeclaration} shows an accessor declaration.
The accessor \texttt{X} is used to read and write underlying storage element \texttt{R}.
For example, this could model a register file consisting of 32 registers, each of 64-bits, the last of which is always zero.

\ASLListing{An accessor declaration}{AccessorDeclaration}{\definitiontests/Accessor.asl}

\ASTRuleDef{AccessorBody}
\hypertarget{build-accessorbody}{}
The relation
\[
  \buildaccessorbody : \overname{\parsenode{\Naccessorbody}}{\vparsednode} \;\aslrel\; \overname{\accessorpair}{\vaccessorpair}
\]
transforms a parse node $\vparsednode$ into an $\accessorpair$.

\begin{mathpar}
\inferrule{
  \buildaccessors(\vaccessors) \astarrow \vaccessorpair
}{
    \builddecl\left(\overname{\Ndecl\left(
      \begin{array}{l}
        \Tbegin, \namednode{\vaccessors}{\Naccessors}, \Tend, \Tsemicolon
      \end{array}
    \right)}{\vparsednode}\right)
  \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{RecurseLimit}
\hypertarget{build-recurselimit}{}
The function
\[
\buildrecurselimit(\overname{\parsenode{\Nrecurselimit}}{\vparsednode}) \aslto \overname{\accessorpair}{\vaccessorpair}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\Trecurselimit, \punnode{\Nexpr})}{\vparsednode}\right)
  \astarrow
  \overname{\langle\astof{\vexpr}\rangle}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\emptysentence)}{\vparsednode}\right)
  \astarrow
  \overname{\None}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{TypedIdentifier}
\hypertarget{build-typedidentifier}{}
The function
\[
\buildtypedidentifier(\overname{\parsenode{\Ntypedidentifier}}{\vparsednode}) \aslto \overname{(\identifier \times \ty)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildtypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \punnode{\Nasty})}{\vparsednode}) \astarrow \overname{(\id,\astof{\vasty})}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{OptTypedIdentifier}
\hypertarget{build-opttypedidentifier}{}
The function
\[
\buildopttypedidentifier(\overname{\parsenode{\Nopttypedidentifier}}{\vparsednode}) \aslto \overname{(\identifier \times \langle\ty\rangle)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildoption[\Nasty](\vastyopt) \astarrow \astversion{\vastyopt}
}{
  {
  \begin{array}{r}
  \buildopttypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \namednode{\vastyopt}{\option{\Nasty}})}{\vparsednode}) \astarrow \\
  \overname{(\id, \astversion{\vastyopt})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{ReturnType}
\hypertarget{build-returntype}{}
The function
\[
\buildreturntype(\overname{\parsenode{\Nreturntype}}{\vparsednode}) \aslto \overname{\ty}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildreturntype(\overname{\Nreturntype(\Tarrow, \punnode{\Nty})}{\vparsednode}) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{ParamsOpt}
\hypertarget{build-paramsopt}{}
The function
\[
\buildparamsopt(\overname{\parsenode{\Nparamsopt}}{\vparsednode}) \aslto
  \overname{(\identifier\times\langle\ty\rangle)^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildparamsopt(\overname{\Nparamsopt(\epsilonnode)}{\vparsednode}) \astarrow
  \overname{\emptylist}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \buildclist[\Nopttypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildparamsopt(\overname{\Nparamsopt(\Tlbrace, \namednode{\ids}{\ClistZero{\Nopttypedidentifier}}, \Trbrace)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{FuncArgs}
\hypertarget{build-funcargs}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncargs}}{\vparsednode}) \aslto
  \overname{(\identifier\times\ty)^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildclist[\Ntypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildfuncargs(\overname{\Nfuncargs(\Tlpar, \namednode{\ids}{\ClistZero{\Ntypedidentifier}}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{MaybeEmptyStmtList}
\hypertarget{build-maybeemptystmtlist}{}
The function
\[
\buildmaybeemptystmtlist(\overname{\parsenode{\Nmaybeemptystmtlist}}{\vparsednode}) \aslto
  \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildmaybeemptystmtlist(\overname{\Nmaybeemptystmtlist(\epsilonnode)}{\vparsednode}) \astarrow
  \overname{\SPass}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{}{
  \buildmaybeemptystmtlist(\overname{\Nmaybeemptystmtlist(\Nstmtlist)}{\vparsednode}) \astarrow
  \overname{\astof{\vstmtlist}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{FuncBody}
\hypertarget{build-funcbody}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncbody}}{\vparsednode}) \aslto
  \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  {
  \begin{array}{r}
  \buildfuncbody(\overname{\Nfuncbody(\Tbegin, \namednode{\vstmts}{\Nmaybeemptystmtlist}, \Tend, \Tsemicolon)}{\vparsednode}) \astarrow \\
  \overname{\astof{\vmaybeemptystmtlist}}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{Accessors}
\hypertarget{build-accessors}{}
The function
\[
\buildaccessors(\overname{\parsenode{\Naccessors}}{\vparsednode}) \aslto
  \overname{\accessorpair}{\vaccessorpair}
\]
transforms a parse node $\vparsednode$ into an $\accessorpair$.

\begin{mathpar}
\inferrule{
  \buildstmt(\vgetter) \astarrow \astversion{\vgetter} \\\\
  \buildstmt(\vsetter) \astarrow \astversion{\vsetter} \\\\
  {
  \vaccessorpair \eqdef
  \left\{
  \begin{array}{rcl}
    \accessorpairgetter    &:& \astversion{\vgetter},\\
    \accessorpairsetter    &:& \astversion{\vsetter}
  \end{array}
  \right\}
  }
}{
  {
  \begin{array}{r}
    \buildaccessors(
      \Tgetter, \namednode{\vgetter}{\Nmaybeemptystmtlist}, \Tend, \Tsemicolon, \\
      \Tsetter, \namednode{\vsetter}{\Nmaybeemptystmtlist}, \Tend, \Tsemicolon
    ) \\
    \astarrow \vaccessorpair
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildstmt(\vgetter) \astarrow \astversion{\vgetter} \\\\
  \buildstmt(\vsetter) \astarrow \astversion{\vsetter} \\\\
  {
  \vaccessorpair \eqdef
  \left\{
  \begin{array}{rcl}
    \accessorpairgetter    &:& \astversion{\vgetter},\\
    \accessorpairsetter    &:& \astversion{\vsetter}
  \end{array}
  \right\}
  }
}{
  {
  \begin{array}{r}
    \buildaccessors(
      \Tsetter, \namednode{\vsetter}{\Nmaybeemptystmtlist}, \Tend, \Tsemicolon, \\
      \Tgetter, \namednode{\vgetter}{\Nmaybeemptystmtlist}, \Tend, \Tsemicolon
    ) \\
    \astarrow \vaccessorpair
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarAccessorPair}
\hypertarget{def-desugaraccessorpair}{}
The function
\[
  \desugaraccessorpair\left(
    \begin{array}{l}
    \overname{\overrideinfo}{\voverride} \aslsep \\
    \overname{\identifier}{\name} \aslsep \\
    \overname{(\identifier \times \Some{\ty})^*}{\vparameters} \aslsep \\
    \overname{\typedidentifier^*}{\vargs} \aslsep \\
    \overname{\identifier}{\vsetterarg} \aslsep \\
    \overname{\ty}{\tty} \aslsep \\
    \overname{\accessorpair}{\vaccessorpair}
  \end{array}\right) \aslto
  \overname{\decl^*}{\vastnode}
\]
transforms an $\accessorpair$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  {
  \vgetter \eqdef
      \DFunc\left\{
      \begin{array}{rcl}
        \funcname &:& \name,\\
        \funcparameters &:& \vparameters,\\
        \funcargs &:& \vargs,\\
        \funcbody &:& \vaccessorpair.\accessorpairgetter,\\
        \funcreturntype &:& \Some{\tty},\\
        \funcsubprogramtype &:& \STGetter,\\
        \funcrecurselimit   &:& \None\\
        \funcbuiltin &:& \False\\
        \funcoverride &:& \voverride
      \end{array}
      \right\}
  } \\\\
  \vsetterargs \eqdef [(\vsetterarg, \tty)] \concat \vargs \\\\
  {
  \vsetter \eqdef
      \DFunc\left\{
      \begin{array}{rcl}
        \funcname &:& \name,\\
        \funcparameters &:& \vparameters,\\
        \funcargs &:& \vsetterargs,\\
        \funcbody &:& \vaccessorpair.\accessorpairsetter,\\
        \funcreturntype &:& \None,\\
        \funcsubprogramtype &:& \STSetter,\\
        \funcrecurselimit   &:& \None\\
        \funcbuiltin &:& \False\\
        \funcoverride &:& \voverride
      \end{array}
      \right\}
  }
}{
  {
    \desugaraccessorpair\left(
      \begin{array}{l}
        \voverride, \\
        \name, \\
        \vparameters, \\
        \vargs, \\
        \vsetterarg, \\
        \tty, \\
        \vaccessorpair
      \end{array}
    \right)
    \astarrow [\vgetter, \vsetter]
  }
}
\end{mathpar}

\ASTRuleDef{Override}
\hypertarget{build-override}{}
The function
\[
\buildoverride(\overname{\parsenode{\Noverride}}{\vparsednode}) \aslto
  \overname{\Some{\overrideinfo}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildoverride(\overname{\Noverride(\emptysentence)}{\vparsednode}) \astarrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule{}{
  \buildoverride(\overname{\Noverride(\Timpdef)}{\vparsednode}) \astarrow \Some{\Impdef}
}
\end{mathpar}

\begin{mathpar}
\inferrule{}{
  \buildoverride(\overname{\Noverride(\Timplementation)}{\vparsednode}) \astarrow \Some{\Implementation}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We also define the following helper rules:
\begin{itemize}
  \item \TypingRuleRef{AnnotateAndDeclareFunc}
  \item \TypingRuleRef{AnnotateFuncSig}
  \item \TypingRuleRef{AnnotateParams}
  \item \TypingRuleRef{AnnotateOneParam}
  \item \TypingRuleRef{CheckParamDecls}
  \item \TypingRuleRef{FuncSigTypes}
  \item \TypingRuleRef{ParametersOfTy}
  \item \TypingRuleRef{ParametersOfExpr}
  \item \TypingRuleRef{ParametersOfConstraint}
  \item \TypingRuleRef{AnnotateArgs}
  \item \TypingRuleRef{AnnotateOneArg}
  \item \TypingRuleRef{AnnotateReturnType}
  \item \TypingRuleRef{DeclareOneFunc}
  \item \TypingRuleRef{SubprogramClash}
  \item \TypingRuleRef{AddNewFunc}
  \item \TypingRuleRef{AddSubprogram}
\end{itemize}

\TypingRuleDef{AnnotateAndDeclareFunc}
\hypertarget{def-annotateanddeclarefunc}{}
The function
\[
  \annotateanddeclarefunc(\overname{\globalstaticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto
  \begin{array}{l}
  (\overname{\staticenvs}{\tenv} \times \overname{\func}{\newfuncsig} \times \overname{\TSideEffectSet}{\vses})\ \cup\\
  \overname{\TTypeError}{\TypeErrorConfig}
  \end{array}
\]
annotates a subprogram definition $\funcsig$ in the global static environment $\genv$,
yielding a new subprogram definition $\newfuncsig$, a modified static environment
$\newtenv$, and an inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

See \ExampleRef{Annotating Subprogram Signatures} and
\ExampleRef{Updating the Static Environment for a Subprogram}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the signature of $\funcsig$ in $\genv$ as per
        \TypingRuleRef{AnnotateFuncSig} yields
        $(\tenvone, \funcsigfone, \vsesone)$\ProseOrTypeError;
  \item declaring the subprogram defined by $\funcsigfone$ in $\tenvone$ with $\vsesfone$
        as per \TypingRuleRef{DeclareOneFunc} yields the environment $\newtenv$
        and new $\func$ node $\newfuncsig$\ProseOrTypeError;
  \item \Proseeqdef{$\vses$}{$\vsesfone$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\tenvone, \funcsigfone, \vsesfone) \OrTypeError\\\\
  \declareonefunc(\tenvone, \funcsigfone, \vsesfone) \typearrow (\newtenv, \newfuncsig) \OrTypeError
}{
  \annotateanddeclarefunc(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig, \overname{\vsesfone}{\vses})
}
\end{mathpar}
\CodeSubsection{\AnnotateAndDeclareFuncBegin}{\AnnotateAndDeclareFuncEnd}{../Typing.ml}

\TypingRuleDef{AnnotateFuncSig}
\hypertarget{def-annotatefuncsig}{}
The function
\[
  \annotatefuncsig(\overname{\globalstaticenvs}{\genv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig} \times \overname{\TSideEffect}{\vses})
  \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the signature of a function definition $\funcsig$ in the global static environment $\genv$,
yielding a new function definition $\newfuncsig$,
a modified static environment $\newtenv$, and
an inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Subprogram Signatures}
\ExampleRef{Annotating Parameters},
\ExampleRef{Checking Parameter Declarations},
\ExampleRef{Annotating Subprogram Arguments},
and
\ExampleRef{Annotating Subprogram Return Types}
show well-typed subprogram signatures and ill-typed subprogram signatures.

The specification in \listingref{AnnotateFuncSig} shows a subprogram
with an associated recursion limit.
\ASLListing{Annotating a subprogram signature with a recursion limit}{AnnotateFuncSig}{\typingtests/TypingRule.AnnotateFuncSig.asl}

The specification in \listingref{AnnotateFuncSig-bad} is ill-typed, since the recursion limit expression \verb|W|
is not a constrained expression.
\ASLListing{An ill-typed subprogram signature}{AnnotateFuncSig-bad}{\typingtests/TypingRule.AnnotateFuncSig.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tenv$ is the static environment which comprises of the global static environment $\genv$ and an empty local environment;
  \item applying $\annotatelimitexpr$ to $\funcsig.\funcrecurselimit$ in $\tenvone$ yields \\
        $(\vrecurselimit, \vsesrecurselimit)$\ProseOrTypeError;
  \item annotating and declaring the parameters $\funcsig.\funcparameters$ in $\tenv$ using \\
        $\annotateparams$ yields $(\tenvwithparams, \vseswithparams, \params)$\ProseOrTypeError;
  \item checking that the parameters $\funcsig.\funcparameters$ are declared correctly using $\checkparamdecls$, yields $\True$\ProseOrTypeError;
  \item annotating and declaring the arguments $\funcsig.\funcargs$ in $\tenvwithparams$ using $\annotateargs$
        and $\vseswithparams$ yields\\
        $(\tenvwithargs, \vseswithargs, \vargs)$\ProseOrTypeError;
  \item annotating the return type of $\funcsig$ in $\tenvwithparams$ using \\ $\annotatereturntype$ and $\vseswithargs$, yields\\
        $(\newtenv, \vreturntype, \vseswithreturn)$\ProseOrTypeError;
  \item \Proseeqdef{$\vses$}{$\vseswithreturn$ with all instances of \ReadLocal\ and \WriteLocalTerm\ removed};
  \item $\newfuncsig$ is $\funcsig$ with the annotated parameters $\vparams$, annotated arguments $\vargs$, annotated return type $\vreturntype$,
        and $\vrecurselimit$ as its recursion limit.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \withemptylocal(\genv) \typearrow \tenv\\
  \annotatelimitexpr(\tenvone, \funcsig.\funcrecurselimit) \typearrow (\vrecurselimit, \vsesrecurselimit) \OrTypeError\\\\
  {
    \begin{array}{r}
    \annotateparams(\tenv, \funcsig.\funcparameters, (\tenv, \emptylist)) \typearrow \\
    (\tenvwithparams, \vseswithparams, \params) \OrTypeError
    \end{array}
  }\\
  \checkparamdecls(\tenv, \funcsig) \typearrow \True \OrTypeError \\
  {
    \begin{array}{r}
    \annotateargs(\tenvwithparams, \funcsig.\funcargs, (\tenvwithparams, \emptylist), \vseswithparams) \typearrow \\
    (\tenvwithargs, \vseswithargs, \vargs) \OrTypeError
      \end{array}
  }\\\\
  {
    \begin{array}{r}
  \annotatereturntype(\tenvwithargs, \tenvwithparams, \funcsig.\funcreturntype, \vseswithargs) \typearrow \\
    (\newtenv, \vreturntype, \vseswithreturn) \OrTypeError
    \end{array}
  }\\\\
  \vses \eqdef \vseswithreturn \setminus \{ \vs \;|\; \configdomain{\vs} \in \{\ReadLocal, \WriteLocal\} \}\\
  {
    \newfuncsig \eqdef
    \left\{
    \begin{array}{rcl}
      \funcname            &:& \funcsig.\funcname,\\
      \funcparameters      &:& \vparameters,\\
      \funcargs            &:& \vargs,\\
      \funcbody            &:& \funcsig.\funcbody,\\
      \funcreturntype      &:& \vreturntype,\\
      \funcsubprogramtype  &:& \funcsig.\funcsubprogramtype,\\
      \funcrecurselimit    &:& \vrecurselimit\\
      \funcbuiltin         &:& \funcsig.\funcbuiltin
    \end{array}
    \right\}
  }
}{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateFuncSigBegin}{\AnnotateFuncSigEnd}{../Typing.ml}

\TypingRuleDef{AnnotateParams}
\hypertarget{def-annotateparams}{}
The function
\[
\begin{array}{r}
\annotateparams(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier \times \langle\ty\rangle)^*}{\params} \aslsep\
  (\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\acc})
) \aslto \\
(\overname{\staticenvs}{\tenvwithparams} \times \overname{\identifier\times\ty}{\paramsone})
\cup\ \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates each parameter in $\params$ with respect to $\tenv$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithparams$ and the annotated parameters $\paramsone$, together with any annotated parameters already in the accumulator $\acc$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Parameters}
In \listingref{typing-parameterofconstraint}, the list of explicitly defined parameters
of the function \\
\verb|signature_example| is $\{\texttt{A},\texttt{B}\}$.
Therefore, $\tenvwithparams$ effectively reflects the added declarations \\
\verb|let A: integer{A}| and \verb|let B: integer{B}|.

\ASLListing{A function with parameters}{typing-parameterofconstraint}{\typingtests/TypingRule.AnnotateFuncSig.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\params$ is the empty list;
    \item $\tenvwithparams$ is $\newtenv$;
    \item $\paramsone$ is $\acc$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\params$ is a list with $(\vx, \tyopt)$ as its \head\ and $\paramsp$ as its \tail;
    \item applying $\annotateoneparam$ to the parameter $(\vx, \tyopt)$ with $\tenv$ and $\newtenv$ yields the pair $\newtenvp$ and $\tty$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \tty)$;
    \item applying $\annotateparams$ to $\paramsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields $\tenvwithparams$ and $\paramsone$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotateparams(\tenv, \overname{\emptylist}{\params}, (\newtenv, \acc)) \typearrow
  (\overname{\newtenv}{\tenvwithparams}, \overname{\acc}{\paramsone})
}
\and
\inferrule[non\_empty]{
  \params \eqname [(\vx,\tyopt)] \concat \paramsp\\\\
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \tty)] \\\\
  \annotateparams(\tenv, \paramsp, (\newtenvp, \accp)) \typearrow (\tenvwithparams, \paramsone) \OrTypeError
}{
  \annotateparams(\tenv, \params, (\newtenv, \acc)) \typearrow (\tenvwithparams, \paramsone)
}
\end{mathpar}

\TypingRuleDef{AnnotateOneParam}
The function
\hypertarget{def-annotateoneparam}{}
\[
\annotateoneparam(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\langle\ty\rangle}{\tyopt})
) \aslto
\begin{array}{l}
  (\overname{\staticenvs}{\newtenvp} \times \overname{\ty}{\tty})\ \cup\\
  \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the parameter given by $\vx$ and the \optional\ type $\tyopt$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The updated environment $\newtenvp$ and annotated parameter type $\tty$ are returned.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Subprogram Parameters}
In \listingref{AnnotateOneParam},
the parameters \verb|A| and \verb|B| are annotated as \parameterizedintegertypes,
and \verb|C| is annotated as a \wellconstrainedintegertype.
The specification demonstrates how \verb|A|, \verb|B|, and \verb|C| exist as local storage elements
of \verb|parameterized|.
\ASLListing{Annotating subprogram parameters}{AnnotateOneParam}{\typingtests/TypingRule.AnnotateOneParam.asl}

In \listingref{AnnotateOneParam-bad1}, the declaration of the parameter \verb|A| is illegal,
since \verb|A| is also declared as a global storage element.
\ASLListing{An ill-typed subprogram parameter}{AnnotateOneParam-bad1}{\typingtests/TypingRule.AnnotateOneParam.bad1.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{type\_parameterized}
    \begin{itemize}
      \item $\tyopt$ is either $\None$ or an \unconstrainedintegertype{};
      \item $\tty$ is defined as the \parameterizedintegertype\ for the identifier $\vx$.
    \end{itemize}

    \item \AllApplyCase{type\_annotated}
    \begin{itemize}
      \item $\tyopt$ is the type $\langle\ttyp\rangle$, which is not the unconstrained integer type;
      \item annotating $\ttyp$ in $\tenv$ yields $\tty$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item checking that $\tty$ is a constrained integer in $\newtenv$ via $\checkconstrainedinteger$
        yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\tty$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[type\_parameterized]{
  (\tyopt = \None \lor \tyopt = \langle \unconstrainedinteger\rangle) \\
  \tty \eqdef \TInt(\parameterized(\vx))\\\\
  \commonsuffixline\\\\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty)
}
\and
\inferrule[type\_annotated]{
  \ttyp \neq \unconstrainedinteger\\
  \annotatetype{\False, \tenv, \ttyp} \typearrow \tty \OrTypeError\\\\
  \commonsuffixline\\\\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \langle\ttyp\rangle)) \typearrow (\newtenvp, \tty)
}
\end{mathpar}

\TypingRuleDef{CheckParamDecls}
\hypertarget{def-checkparamdecls}{}
The function
\[
\checkparamdecls(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig}) \aslto \overname{\Bool}{\vb} \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
checks the validity of the parameters declared in $\funcsig$.

\ExampleDef{Checking Parameter Declarations}
In \listingref{ParametersOfExpr}, the list of extracted parameters \verb|B, C, D, E, F, G|
is equal to the list of declared parameters.

The specification in \listingref{CheckParamDecls-bad} is ill-typed, since the list of extracted
\verb|D, A, B, C| while the list of declared parameters is \verb|A, B, C, D|.
\ASLListing{Incorrectly declaring subprogram parameters}{CheckParamDecls-bad}{\typingtests/TypingRule.CheckParamDecls.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\extractparameters$ to $\tenv$ and $\funcsig$ yields $\inferredparameters$\ProseOrTypeError;
  \item \Proseeqdef{$\declaredparameters$}{the list of parameter names in the order they are listed in $\funcsig.\funcparameters$};
  \item checking that $\inferredparameters$ is equal to $\declaredparameters$ yields \\
        $\True$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \extractparameters(\tenv, \funcsig) \typearrow \inferredparameters \OrTypeError\\\\
  \declaredparameters \eqdef [(\vp, \Ignore) \in \funcsig.\funcparameters: \vp]\\
  \checktrans{\inferredparameters = \declaredparameters}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError
}{
  \checkparamdecls(\tenv, \funcsig) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{ExtractParameters}
\hypertarget{def-extractparameters}{}
The function
\[
\extractparameters(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig}) \aslto \overname{\identifier^*}{\uniqueparameters}
  \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the parameter names declared in $\funcsig$ into $\allparameters$, while checking their validity in the static environment $\tenv$.
\ProseOtherwiseTypeError

\ExampleDef{Extracting Parameters from Subprogram Signatures}

The list of parameters extracted from the signature of \verb|parameters_of_expressions|
in \listingref{ParametersOfExpr} is
\verb|B, C, D, E, F, G|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item applying $\funcsigtypes$ to $\funcsig$ yields the empty list;
    \item \Proseeqdef{$\uniqueparameters$}{the empty list}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item applying $\funcsigtypes$ to $\funcsig$ yields the list of types $\vt_{1..k}$;
    \item applying $\paramsofty$ to $\tenv$ and $\vtypes[\vi]$, for every $\vi=1..k$, yields the list of parameter names $\vparams_\vi$\ProseOrTypeError;
    \item \Proseeqdef{$\allparameters$}{the concatenation of lists $\vparams_\vi$, for every $\vi=1..k$};
    \item \Proseeqdef{$\uniqueparameters$}{the list of parameters in $\allparameters$, with repeating parameters removed}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{
  \funcsigtypes(\funcsig) \typearrow \emptylist
}{
  \extractparameters(\tenv, \funcsig) \typearrow \overname{\emptylist}{\uniqueparameters}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \funcsigtypes(\funcsig) \typearrow \vt_{1..k}\\
  \vi=1..k: \paramsofty(\tenv, \vtypes[\vi]) \typearrow \vparams_\vi \OrTypeError\\\\
  \allparameters \eqdef \vparams_1 \concat \ldots \concat \vparams_k\\
  \uniqueparameters \eqdef \uniquelist(\allparameters)
}{
  \extractparameters(\tenv, \funcsig) \typearrow \uniqueparameters
}
\end{mathpar}

\TypingRuleDef{FuncSigTypes}
\hypertarget{def-funcsigtypes}{}
The function
\[
\funcsigtypes(\overname{\func}{\funcsig}) \aslto \overname{\ty^*}{\tys}
\]
returns the list of types $\tys$ in the subprogram signature $\funcsig$.
Their ordering is return type first (if any), followed by argument types left-to-right.

\ExampleDef{Listing Signature Types}
\listingref{FuncSigTypes} shows the list of signature types for a procedure and a function
in comments above their declarations.
\ASLListing{Listing signature types}{FuncSigTypes}{\typingtests/TypingRule.FuncSigTypes.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\vreturntype$}{the singleton list for $\ttyp$ if
        $\funcsig.\funcreturntype$ if the singleton set for $\ttyp$,
        and the empty list, otherwise.}
  \item \Proseeqdef{$\argtypes$}{the types of arguments in $\funcsig.\funcargs$};
  \item \Proseeqdef{$tys$}{the \Proselist{$\vreturntype$}{$\argtypes$}}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \vreturntype \eqdef
    \begin{cases}
      [\ttyp] & \text{if }\funcsig.\funcreturntype = \langle\ttyp\rangle\\
      \emptylist & \text{if }\funcsig.\funcreturntype = \None
    \end{cases}
  } \\\\
  \argtypes \eqdef [(\Ignore, \ttyp)\in\funcsig.\funcargs: \ttyp]
}{
  \funcsigtypes(\funcsig) \typearrow \overname{\vreturntype \concat \argtypes}{\tys}
}
\end{mathpar}

\TypingRuleDef{ParametersOfTy}
\hypertarget{def-paramsofty}{}
The function
\[
\paramsofty(\overname{\staticenvs}{\tenv}, \overname{\ty}{\tty}) \typearrow \overname{\identifier^*}{\ids}
\cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
extracts the list of parameters appearing in the type $\tty$,
assuming that $\tty$ appears in a function signature.
\ProseOtherwiseTypeError

\ExampleDef{The Parameters Extracted from Argument Types}
The parameters extracted from the types of arguments appearing in the signature of \verb|parameters_of_types|
(starting with the return type)
in \listingref{ParametersOfTy} are as follows:
\begin{center}
\begin{tabular}{ll}
\textbf{Type} & \textbf{Parameters}\\
\hline
\verb|bits(A)|            & $[\texttt{A}]$\\
\verb|(bits(B), bits(C))| & $[\texttt{B}, \texttt{C}]$\\
\verb|integer{D..E}|      & $[\texttt{D}, \texttt{E}]$\\
\verb|real|               & $\emptylist$\\
\verb|integer|            & $\emptylist$\\
\end{tabular}
\end{center}

\ASLListing{The parameters extracted from argument types}{ParametersOfTy}{\typingtests/TypingRule.ParametersOfTy.asl}

\ExampleRef{Ill-typed Type Declarations} shows an ill-typed argument type.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{tbits}
    \begin{itemize}
      \item $\tty$ is a bitvector type, that is, $\TBits(\ve, \Ignore)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $\ids$\ProseOrTypeError.
    \end{itemize}

  \item \AllApplyCase{ttuple}
    \begin{itemize}
      \item $\tty$ is a tuple over a list of types $\tys$, that is, $\TTuple(\tys)$;
      \item applying $\paramsofty$ to each type $\tty_i$ in $\tys$ yields $\ids_i$\ProseOrTypeError;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item \AllApplyCase{tint\_constrained\_precise}
    \begin{itemize}
      \item $\tty$ is a \wellconstrainedintegertype, that is, $\TInt(\wellconstrained(\cs))$;
      \item applying $\paramsofconstraint$ to each constraint $\vc_i$ in $\cs$ yields $\ids_i$\ProseOrTypeError;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item \AllApplyCase{other}
    \begin{itemize}
      \item $\tty$ meets one of the following conditions:
      \begin{itemize}
        \item $\tty$ is one of the following types: \realtypeterm, \stringtypeterm, \booleantypeterm, \arraytypeterm, \namedtypeterm;
        \item $\tty$ is an \unconstrainedintegertype;
        \item $\tty$ is a \wellconstrainedintegertype{} with a $\False$ precision flag, that is, $\TInt(\wellconstrained(\Ignore, \False))$;
        \item $\tty$ is a \parameterizedintegertype;
      \end{itemize}
      \item $\ids$ is the empty list.
    \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item $\tty$ either a \structuredtype{} or an \enumerationtypeterm;
    \item the result is a \typingerrorterm{} ($\BadSubprogramDeclaration$).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[tbits]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofty(\tenv, \TBits(\ve, \Ignore)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ttuple]{
  \tty_i \in \tys: \paramsofty(\tenv, \tty_i) \typearrow \ids_i \OrTypeError\\\\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TTuple(\tys)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[tint\_constrained\_precise]{
  \vc_i \in \cs: \paramsofconstraint(\tenv, \vc_i) \typearrow \ids_i \OrTypeError\\\\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TInt(\wellconstrained(\cs, \True))) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  {
  \begin{array}{ll}
  \astlabel(\tty) \in \{ \TReal, \TString, \TBool, \TArray, \TNamed \}  & \lor\\
  \tty = \unconstrainedinteger                                          &\lor\\
  \tty = \TInt(\wellconstrained(\Ignore, \False))                       & \lor\\
  \tty = \TInt(\parameterized(\Ignore))                                 &
  \end{array}
  }
}{
  \paramsofty(\tenv, \tty) \typearrow \overname{\emptylist}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \isstructured(\tty) \lor \astlabel(\tty) = \TEnum
}{
  \paramsofty(\tenv, \tty) \typearrow \TypeErrorVal{\BadSubprogramDeclaration}
}
\end{mathpar}

\TypingRuleDef{ParametersOfExpr}
\hypertarget{def-paramsofexpr}{}
The function
\[
\paramsofexpr(\overname{\staticenvs}{\tenv}, \overname{\expr}{\ve}) \typearrow \overname{\identifier^*}{\ids}
\cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
extracts the list of parameters appearing in the expression $\ve$.
It assumes that $\ve$ appears as $\TBits(\ve, \Ignore)$ or as part of a \wellconstrainedintegertype{} in a function signature.
\ProseOtherwiseTypeError

\ExampleDef{Extracting the Parameters from Expressions}
In \listingref{ParametersOfExpr}, extracting parameters from expressions appearing
in the types of signature arguments (starting with the return type) yield the following lists of parameters:
\begin{center}
\begin{tabular}{ll}
\textbf{Expression} & \textbf{Parameters}\\
\hline
\verb|A|      & $\emptylist$\\
\verb|B|      & $[\texttt{B}]$\\
\verb|C|      & $[\texttt{C}]$\\
\verb|-D|      & $[\texttt{D}]$\\
\verb|E+F|      & $[\texttt{E}, \texttt{F}]$\\
\verb|(G)|      & $[\texttt{G}]$\\
\verb|if H == 0 then I else J|      & $[\texttt{H}, \texttt{I}, \texttt{J}]$\\
\end{tabular}
\end{center}
Notice that, since \verb|A| is declared as a global storage element, it is not extracted as a parameter
for the expression \verb|A| appearing in the return type.

\ASLListing{Extracting the parameters from expressions}{ParametersOfExpr}{\typingtests/TypingRule.ParametersOfExpr.asl}

\listingref{ParametersOfExpr-bad} shows examples of expressions that are illegal in types of arguments.
\ASLListing{Ill-typed expressions in signature types}{ParametersOfExpr-bad}{\typingtests/TypingRule.ParametersOfExpr.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{eval}
    \begin{itemize}
      \item $\ve$ is a variable, that is, $\EVar(\vx)$;
      \item if $\vx$ is undefined in $\tenv$ then $\ids$ is $[\vx]$, otherwise $\ids$ is $\emptylist$.
    \end{itemize}

  \item \AllApplyCase{eunop}
    \begin{itemize}
      \item $\ve$ is a unary operation, that is, $\EUnop(\Ignore, \ve)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\ids$\ProseOrTypeError.
    \end{itemize}

  \item \AllApplyCase{ebinop}
    \begin{itemize}
      \item $\ve$ is a binary operation, that is, $\EBinop(\Ignore, \veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$\ProseOrTypeError;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$\ProseOrTypeError;
      \item define $\ids$ as the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}

  \item \AllApplyCase{etuple}
    \begin{itemize}
      \item $\ve$ is a tuple over the list of expression $\es$, that is, $\ETuple(\es)$;
      \item checking that $\es$ is a singleton list yields $\True$\ProseTerminateAs{\BadSubprogramDeclaration};
      \item view $\es$ as the singleton list for the expression $\ve$;
      \item applying $\paramsofexpr$ to $\ve$ $\ids$\ProseOrTypeError.
    \end{itemize}

  \item \AllApplyCase{econd}
    \begin{itemize}
      \item $\ve$ is a conditional expression, that is, $\ECond(\ve, \veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $\idsp$\ProseOrTypeError;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$\ProseOrTypeError;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$\ProseOrTypeError;
      \item define $\ids$ as the concatenation of $\idsp$, $\idsone$, and $\idstwo$.
    \end{itemize}

  \item \AllApplyCase{other}
    \begin{itemize}
      \item $\ve$ is not a variable, unary operation, binary operation, or tuple;
      \item the result is a \typingerrorterm{} ($\BadSubprogramDeclaration$).
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[eval]{
  \isundefined(\tenv, \vx) \typearrow \vb\\
  \ids \eqdef \choice{\vb}{[\vx]}{\emptylist}
}{
  \paramsofexpr(\tenv, \EVar(\vx)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[eunop]{
  \paramsofexpr(\tenv, \veone) \typearrow \ids \OrTypeError
}{
  \paramsofexpr(\tenv, \EUnop(\Ignore, \veone)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \OrTypeError\\\\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo \OrTypeError
}{
  \paramsofexpr(\tenv, \EBinop(\Ignore, \veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[etuple]{
  \checktrans{|\es| = 1}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError\\\\
  \es \eqname [\ve]\\
  \paramsofexpr(\tenv, \ve) \typearrow \ids \OrTypeError\
}{
  \paramsofexpr(\tenv, \ETuple(\es)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[econd]{
  \paramsofexpr(\tenv, \ve) \typearrow \idsp \OrTypeError\\\\
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \OrTypeError\\\\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo \OrTypeError
}{
  \paramsofexpr(\tenv, \ECond(\ve, \veone, \vetwo)) \typearrow \overname{\idsp \concat \idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \notin \{ \EVar, \EUnop, \EBinop, \ETuple \}
}{
  \paramsofexpr(\tenv, \ve) \typearrow \TypeErrorVal{\BadSubprogramDeclaration}
}
\end{mathpar}

\TypingRuleDef{ParametersOfConstraint}
\hypertarget{def-paramsofconstraint}{}
The function
\[
\paramsofconstraint(\overname{\staticenvs}{\tenv}, \overname{\intconstraint}{\vc}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the constraint $\vc$.
It assumes that $\vc$ appears within a \wellconstrainedintegertype{} in a function signature.

\ExampleDef{The Parameters Extracted from a Constraint}
In \listingref{ParametersOfTy}, the list of parameters extracted from the constraint
\verb|{D..E}| is $[\texttt{D}, \texttt{E}]$.

See also \ExampleRef{Extracting the Parameters from Expressions}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
    \begin{itemize}
      \item $\vc$ is an exact constraint, that is, $\ConstraintExact(\ve)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $ids$.
    \end{itemize}

  \item \AllApplyCase{range}
    \begin{itemize}
      \item $\vc$ is an range constraint, that is, $\ConstraintRange(\veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$;
      \item $\ids$ is the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofconstraint(\tenv, \ConstraintExact(\ve)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo \\
}{
  \paramsofconstraint(\tenv, \ConstraintRange(\veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\subsection{Example}
In \listingref{typing-parameterofconstraint}, the set of identifiers that may correspond
to parameters of the function \texttt{signature\_example} is $\{\texttt{A}, \texttt{B}\}$,
since they appear in the type \texttt{bits(A)}
of the argument \texttt{bv} and the type \texttt{bits(A+B)} of the argument \texttt{bv3}.

Finding parameters for each type in the signature of the function \texttt{signature\_example}
yields the following results:
\begin{center}
\begin{tabular}{lll}
\textbf{Expression} & \textbf{Result} & \textbf{Reason}\\
\hline
\texttt{bits(A)} & $\{\texttt{A}\}$ & \texttt{A} is a variable expression \\
& & and \texttt{A} is not defined in the environment.\\
\texttt{bits(W)} & $\emptyset$ & \texttt{W} is defined in the environment.\\
\texttt{bits(A+B)} & $\{\texttt{A}, \texttt{B}\}$ & \texttt{A} and \texttt{B} are variables \\
& & and neither is defined in the environment.\\
\end{tabular}
\end{center}

\TypingRuleDef{AnnotateArgs}
\hypertarget{def-annotateargs}{}
The function
\[
\begin{array}{r}
\annotateargs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier \times \ty)^*}{\args} \aslsep\
  (\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\acc} \aslsep
  \overname{\TSideEffectSet}{\vsesin})
) \aslto \\
(\overname{\staticenvs}{\tenvwithargs} \times \overname{(\identifier\times\ty)^*}{\vnewargs} \times \overname{\TSideEffectSet}{\vses})
\cup\ \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates each argument in $\args$ with respect to $\tenv$ and a \sideeffectsetterm\ $\vsesin$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithargs$, the annotated arguments $\vnewargs$,
together with any annotated arguments already in the accumulator $\acc$,
and a \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Subprogram Arguments}
In \listingref{typing-parameterofconstraint}, the annotated arguments are
\texttt{bv}, \texttt{bv2}, \texttt{bv3}, and \texttt{C}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\args$ is the empty list;
    \item $\tenvwithargs$ is $\newtenv$;
    \item $\newargs$ is $\acc$;
    \item \Proseeqdef{$\vses$}{$\vsesin$}
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\args$ is a list with $(\vx, \tty)$ as its \head\ and $\vargsp$ as its \tail;
    \item applying $\annotateonearg$ to the argument $(\vx, \tty)$ with $\tenv$ and $\newtenv$ yields
          $(\newtenvp, \ttyp, \vsesty)$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \ttyp)$;
    \item applying $\annotateargs$ to $\vargsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields $(\tenvwithargs, \newargs, \newses)$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesty$ and $\newses$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotateargs(\tenv, \overname{\emptylist}{\args}, (\newtenv, \acc), \vsesin) \typearrow
  (\overname{\newtenv}{\tenvwithargs}, \overname{\acc}{\newargs}, \overname{\vsesin}{\vses})
}
\and
\inferrule[non\_empty]{
  \vargs \eqname [(\vx,\tty)] \concat \vargsp\\\\
  \annotateonearg(\tenv, \newtenv, (\vx, \tty)) \typearrow (\newtenvp, \ttyp, \vsesty) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \ttyp)] \\\\
  \annotateargs(\tenv, \vargsp, (\newtenvp, \accp), \vsesin) \typearrow (\tenvwithargs, \newargs, \newses) \OrTypeError\\\\
  \vses \eqdef \vsesty \cup\ \newses
}{
  \annotateargs(\tenv, \args, (\newtenv, \acc), \vsesin) \typearrow (\tenvwithargs, \newargs, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateOneArg}
\hypertarget{def-annotateonearg}{}
The function
\[
\begin{array}{r}
  \annotateonearg(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\ty}{\tty})
) \aslto\\
(\overname{\staticenvs}{\newtenvp} \times\ \overname{\ty}{\ttyp} \times \overname{\TSideEffectSet}{\vses})\ \cup
\overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the argument given by the identifier $\vx$ and the type $\tty$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The result is the updated environment $\newtenvp$, annotated argument type $\ttyp$,
and inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating a Subprogram Argument}
The specification in \listingref{AnnotateOneArg} shows well-typed argument declarations
and demonstrates how they exist as local storage elements in the subprogram body.
\ASLListing{Well-typed subprogram arguments}{AnnotateOneArg}{\typingtests/TypingRule.AnnotateOneArg.asl}

The specification in \listingref{AnnotateOneArg-bad1} is illegal, since arguments cannot share a name
with global storage elements, \verb|b| in this example.
\ASLListing{An ill-typed subprogram argument}{AnnotateOneArg-bad1}{\typingtests/TypingRule.AnnotateOneArg.bad1.asl}

The specification in \listingref{AnnotateOneArg-bad2} is illegal, since arguments cannot be typed
as \collectiontypesterm.
\ASLListing{An ill-typed subprogram argument}{AnnotateOneArg-bad2}{\typingtests/TypingRule.AnnotateOneArg.bad2.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyp, \vses)$\ProseOrTypeError;
  \item \Prosecheckisnotcollection{$\tenv$}{$\tty$};
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\ttyp$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \tty} \typearrow (\ttyp, \vses) \OrTypeError \\\\
  \checkisnotcollection(\tenv, \tty) \typearrow \True \OrTypeError\\\\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \ttyp, \LDKLet) \typearrow \newtenvp
}{
  \annotateonearg(\tenv, \newtenv, (\vx, \tty))
  \typearrow (\newtenvp, \ttyp, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateReturnType}
\hypertarget{def-annotatereturntype}{}
The function
\[
\begin{array}{rl}
\annotatereturntype(
  \overname{\staticenvs}{\tenvwithparams} \aslsep
  \overname{\staticenvs}{\tenvwithargs} \aslsep
  \overname{\langle\ty\rangle}{\vreturntype} \aslsep
  \overname{\TSideEffectSet}{\vsesin}
) & \aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newreturntype} \times \overname{\TSideEffectSet}{\vses})
\cup\ \overname{\TTypeError}{\TypeErrorConfig} &
\end{array}
\]
annotates the \optional\ return type $\vreturntype$ in the context of the static environment
$\tenvwithparams$, where all parameters have been declared,
and the \sideeffectsetterm\ $\vsesin$.
The result is $\newtenv$, which is the input $\tenvwithargs$ (where all parameters and arguments have been declared)
with the \optional{} annotated return type $\newreturntype$ added
and the inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Subprogram Return Types}
In \listingref{MatchFuncRes}, the subprogram \verb|proc| has no return type.
Annotating its return type does not modify the static environment, and the optional annotated return type is $\None$.
In contrast, the subprogram \verb|returns_value| updates the static environment by
binding $\funcreturntype$ to $\unconstrainedinteger$ and returning $\unconstrainedinteger$
as the optional return type.

The specification in \listingref{AnnotateReturnType-bad} is ill-typed, since \collectiontypesterm{} are not allowed
as return types.
\ASLListing{An ill-typed return type}{AnnotateReturnType-bad}{\typingtests/TypingRule.AnnotateReturnType.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{no\_return\_type}
  \begin{itemize}
    \item $\vreturntype$ is $\None$;
    \item $\newtenv$ is $\tenvwithargs$;
    \item $\newreturntype$ is $\None$;
    \item \Proseeqdef{$\vses$}{$\vsesin$}.
  \end{itemize}

  \item \AllApplyCase{has\_return\_type}
  \begin{itemize}
    \item $\vreturntype$ is $\langle\tty\rangle$;
    \item annotating $\tty$ in $\tenvwithparams$ yields $(\ttyp, \vsesty)$\ProseOrTypeError;
    \item \Prosecheckisnotcollection{$\tenv$}{$\ttyp$};
    \item $\newreturntype$ is $\langle\ttyp\rangle$;
    \item $\newtenv$ is $\tenvwithargs$ with its local environment updated by binding its \\ $\funcreturntype$ field
          to $\newreturntype$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesin$ and $\vsesty$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_return\_type]{}
{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\None}{\vreturntype}, \vsesin) \typearrow \\
  (\overname{\tenvwithargs}{\newtenv}, \overname{\None}{\newreturntype}, \overname{\vsesin}{\vses})
  \end{array}
  }
}
\and
\inferrule[has\_return\_type]{
  \annotatetype{\tenvwithparams, \tty} \typearrow (\ttyp, \vsesty) \OrTypeError\\\\
  \checkisnotcollection(\tenv, \ttyp) \typearrow \True \OrTypeError\\\\
  \newreturntype \eqdef \langle\ttyp\rangle\\
  \newtenv \eqdef (G^\tenvwithargs, L^\tenvwithargs[\funcreturntype\mapsto\newreturntype])\\
  \vses \eqdef \vsesin \cup\ \vsesty
}{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\langle\tty\rangle}{\returntype}, \vsesin) \typearrow \\
  (\newtenv, \newreturntype, \vses)
  \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{DeclareOneFunc}
\hypertarget{def-declareonefunc}{}
The function
\[
  \declareonefunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\func}{\funcsig} \aslsep
    \overname{\TSideEffectSet}{\vsesfuncsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
checks that a subprogram defined by $\funcsig$
and associated with the \sideeffectsetterm\ $\vsesfuncsig$
can be added to the static environment $\tenv$,
resulting in an annotated function definition $\newfuncdef$ and new static environment $\newtenv$.
\ProseOtherwiseTypeError

See \ExampleRef{Updating the Static Environment for a Subprogram}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\funcsig$ has name $\name$, arguments $\vargs$, and type $\subprogramtype$, that is,
  \[
    \begin{array}{rrcl}
      \funcsig \eqdef \{
                      & \funcname            &:& \name,\\
                      & \funcparameters      &:& \vp,\\
                      & \funcargs            &:& \vargs,\\
                      & \funcbody            &:& \bd,\\
                      & \funcreturntype      &:& \vt,\\
                      & \funcsubprogramtype  &:& \subprogramtype, \\
                      & \funcbuiltin         &:& \vb \\
                  \}  & ; &&
        \end{array}
  \]
  \item adding a new subprogram with $\name$, $\vargs$, and $\subprogramtype$ to $\tenv$ yields the new
        environment $\tenvone$ and new name $\namep$\ProseOrTypeError;
  \item checking that $\namep$ is not already declared in the global environment of $\tenvone$
        yields $\True$\ProseOrTypeError;
  \item $\funcsigone$ is $\funcsig$ with $\name$ substituted by $\nameone$;
  \item \Proseeqdef{$\initses$}{the union of $\vsesfuncsig$ and the singleton set for
        a \RecursiveCallTerm\ for $\namep$};
  \item adding a subprogram with name $\namep$, definition $\funcsigone$,
        and \sideeffectsetterm\ $\initses$ to $\tenvone$ yields $\newtenv$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rrcl}
    \funcsig \eqdef \{
                    & \funcname            &:& \name,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \bd,\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype, \\
                    & \funcbuiltin         &:& \vb \\
                \} &&&
      \end{array}
    }\\
  \addnewfunc(\tenv, \name, \vargs, \subprogramtype) \typearrow
  (\tenvone, \namep) \OrTypeError\\\\
  \checktrans{G^\tenvone.\subprograms(\namep) = \bot}{\IdentifierAlreadyDeclared} \checktransarrow \True \terminateas \IdentifierAlreadyDeclared \\\\
  {
  \begin{array}{rrcl}
    \newfuncsig \eqdef \{
                    & \funcname            &:& \namep,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \bd,\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype, \\
                    & \funcbuiltin         &:& \vb \\
                \} &&&
      \end{array}
    }\\
    \initses \eqdef \vsesfuncsig \cup\ \{ \RecursiveCall(\namep) \}\\
    \addsubprogram(\tenvone, \namep, \funcsigone, \initses) \typearrow \newtenv \OrTypeError
}{
  \declareonefunc(\tenv, \funcsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}
\CodeSubsection{\DeclareOneFuncBegin}{\DeclareOneFuncEnd}{../Typing.ml}
\identi{HJRD} \identd{BTBR} \identi{FSFQ} \identi{PFGQ} \identr{PGFC}

\TypingRuleDef{SubprogramClash}
\hypertarget{def-subprogramclash}{}
The function
\[
\subprogramclash
  (
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\subprogramtype}{\subpgmtype} \aslsep
    \overname{\ty^*}{\formaltypes}
  )
  \aslto
  \overname{\Bool}{\vb} \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the unique subprogram associated with $\name$
clashes with another subprogram
that has subprogram type $\subpgmtype$ and list of formal types $\formaltypes$,
yielding a Boolean value in $\vb$.
\ProseOtherwiseTypeError

The function assumes there exists a binding for $\name$ in the
$\subprograms$ map of $\tenv$.

\ExampleDef{Subprogram Clashing}
In \listingref{SubprogramTypesClash}, the getter for \verb|X| and the setter for \verb|X| do not clash,
since they have non-clashing subprogram types (see \TypingRuleRef{SubprogramTypesClash}).

In \listingref{SubprogramTypesClash-bad1}, the getter for \verb|X| and the function \verb|X| clash,
since their subprogram types clash and their signatures clash (see \TypingRuleRef{HasArgClash}).

In \listingref{SubprogramTypesClash-bad2}, the function \verb|X| and the procedure \verb|X| clash
since their subprogram types clash and their signatures clash.

\ProseParagraph
\AllApply
\begin{itemize}
  \item the identifier $\name$ is bound to the $\func$ AST node $\otherfuncsig$ in the \\
        $\subprograms$ map
        of the static global environment of $\tenv$ (ignoring the associated \sideeffectdescriptorsterm);
  \item applying $\subprogramtypesclash$ to the subprogram type of $\otherfuncsig$ \\
        ($\otherfuncsig.\subprogramtype$) and $\subpgmtype$ yields \\
        $\True$\ProseTerminateAs{\False}
        (that is, if both subprogram types are $\STGetter$ or both are $\STSetter$ then the
        subprogram types are considered to be non-clashing and the entire rule short-circuits to $\False$);
  \item determining whether there is an argument clash between $\formaltypes$ and \\
        the formal arguments of $\otherfuncsig$ ($\otherfuncsig.\funcargs$) in $\tenv$ yields $\vb$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  G^\tenv.\subprograms(\name) = (\otherfuncsig, \Ignore)\\
  \subprogramtypesclash(\otherfuncsig.\subprogramtype, \subpgmtype) \typearrow \vbone\\
  \hasargclash(\formaltypes, \otherfuncsig.\funcargs) \typearrow \vbtwo
}{
  \subprogramclash(\tenv, \name, \subpgmtype, \formaltypes) \typearrow \overname{\vbone \land \vbtwo}{\vb}
}
\end{mathpar}
\identd{BTBR} \identi{FSFQ} \identi{PFGQ}

\TypingRuleDef{SubprogramTypesClash}
\hypertarget{def-subprogramtypeclash}{}
The function
\[
  \subprogramtypesclash(
    \overname{\subprogramtype}{\vsone} \aslsep
    \overname{\subprogramtype}{\vstwo}
  ) \aslto \overname{\Bool}{\vb}
\]
defines whether the subprogram types $\vsone$ and
$\vstwo$ clash, yielding the result in $\vb$.

\ExampleDef{Clashing Subprogram Types}

The specification in \listingref{SubprogramTypesClash} contains an accessor for \verb|X|.
The subprogram type of its getter does not clash with the subprogram type of its setter.
\ASLListing{Non-clashing subprogram types}{SubprogramTypesClash}{\typingtests/TypingRule.SubprogramTypesClash.asl}

The specification in \listingref{SubprogramTypesClash-bad1} contains an accessor for \verb|X|.
The subprogram types of its getter and setter both clash with the subprogram type of the procedure \verb|X| ($\STProcedure$).
\ASLListing{Clashing subprogram types}{SubprogramTypesClash-bad1}{\typingtests/TypingRule.SubprogramTypesClash.bad1.asl}

The specification in \listingref{SubprogramTypesClash-bad2} contains a function \verb|X| and a procedure \verb|X|
whose subprogram types ($\STFunction$ and $\STProcedure$, respectively) clash.
\ASLListing{Clashing subprogram types}{SubprogramTypesClash-bad2}{\typingtests/TypingRule.SubprogramTypesClash.bad2.asl}

\ProseParagraph
\ProseEqdef{$\vb$}{$\True$ unless
$\vsone$ is $\STGetter$ and $\vstwo$ is $\STSetter$ or
$\vsone$ is $\STSetter$ and $\vstwo$ is $\STGetter$}.

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
  \vb \eqdef (\vsone, \vstwo) \not\in
  \left\{
  \begin{array}{l}
    (\STGetter,       \STSetter),\\
    (\STSetter,       \STGetter)
  \end{array}
  \right\}
  }
}{
  \subprogramtypesclash(\subpgmtypeone, \subpgmtypetwo) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{AddNewFunc}
\hypertarget{def-addnewfunc}{}
The function
\[
  \begin{array}{rl}
  \addnewfunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\typedidentifier^*}{\formals} \aslsep
    \overname{\subprogramtype}{\subpgmtype})
  & \aslto\\
  (\overname{\staticenvs}{\newtenv} \times \overname{\Strings}{\newname})
  \cup\ \overname{\TTypeError}{\TypeErrorConfig} &
  \end{array}
\]
ensures that the subprogram given by the identifier $\name$, list of formals $\formals$,
and subprogram type $\subpgmtype$ has a unique name among all the potential subprograms
that overload $\name$.
The result is the unique subprogram identifier $\newname$, which is used to distinguish it in the set
of overloaded subprograms (that is, other subprograms that share the same name)
and the environment $\newtenv$, which is updated with $\newname$.
\ProseOtherwiseTypeError

The function $\addnewfunc$ updates the $\overloadedsubprograms$ map in the static environment,
and must be followed by $\addsubprogram$, which updates the $\subprograms$ map (see \TypingRuleRef{AddSubprogram}).

\ExampleDef{Updating the Static Environment for a Subprogram}
The specification in \listingref{DeclareSubprograms}
contains two subprograms named \verb|add_10| with the signatures
\verb|func add_10(x: integer) => integer| and
\verb|func add_10(x: real) => real|, which for brevity we will refer to by
$I$ and $R$, respectively.
These subprograms are added to the static environment
based on the dependency ordering \\
(see \TypingRuleRef{DeclDependencies}).
In this case, there is no ordering between these two subprograms.
Assuming $I$ is processed before $R$, adding $I$ to the
static environment, the static environment has
$\overloadedsubprograms(\addten) = \bot$
and is then updated by binding $\addten$ to $\{\addten\}$ in $\overloadedsubprograms$.
Then, processing $R$, results in
binding $\addten$ to
$\{\addten, \addtenone\}$ where \addtenone{} will be used for $R$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{first\_name}
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ does not have a binding for $\name$;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the singleton set containing
          $\name$.
  \end{itemize}

  \item \AllApplyCase{name\_exists}
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ binds $\name$ to the set of strings $\othernames$;
    \item $\newname$ is the unique name that will be associated with the subprogram given by the identifier $\name$, list of formals $\formals$,
          and subprogram type $\subpgmtype$. It is constructed by concatenating a hyphen (\texttt{-}) to $\name$, followed
          by a string corresponding to the number of strings in $\othernames$.
          Notice that this is not an ASL identifier, as ASL identifiers do not contain hyphens, which ensures that this string
          does not occur in any specification;
    \item $\formaltypes$ is the list of types that appear in $\formals$ in the same order;
    \item checking for each $\namep$ in $\othernames$ whether the subprogram associated with $\namep$ clashes
          with the subprogram type $\subpgmtype$ and list of types $\formaltypes$ yields $\False$
          or a \typingerrorterm{} that indicates there are multiply defined subprograms, which short-circuits the entire rule;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the union of $\othernames$ and
          $\{\newname\}$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[first\_name]{
  G^\tenv.\overloadedsubprograms(\name) = \bot\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto\{\name\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \overname{\name}{\newname})
}
\end{mathpar}

\begin{mathpar}
\inferrule[name\_exists]{
  G^\tenv.\overloadedsubprograms(\name) = \othernames\\
  k \eqdef \cardinality{\othernames}\\
  \newname \eqdef \name\ \stringconcat\ \discardvarstr\ \stringconcat\ \stringofnat(k)\\
  \formaltypes \eqdef [(\id,\vt) \in \formals : \vt]\\
  {
    \left(\begin{array}{l}
  \namep \in \othernames: \\ \subprogramclash(\tenv, \namep, \subpgmtype, \formaltypes) \typearrow
  \vb_{\namep} \OrTypeError
    \end{array}\right)
  }\\\\
  \namep \in \othernames: \checktrans{\neg\vb_{\namep}}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError\\\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto \othernames \cup\ \{\newname\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \newname)
}
\end{mathpar}
\identr{PGFC}
\CodeSubsection{\AddNewFuncBegin}{\AddNewFuncEnd}{../Typing.ml}
