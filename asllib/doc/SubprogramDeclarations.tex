\chapter{Subprogram Declarations\label{chap:SubprogramDeclarations}}

Subprogram declarations are grammatically derived from $\Ndecl$ via the subset of productions shown in
\secref{SubprogramDeclarationsSyntax} and represented as ASTs via the production of $\decl$
shown in \secref{SubprogramDeclarationsAbstractSyntax}.
%
Subprogram declarations are typed via $\annotateanddeclarefunc$, which is defined in \TypingRuleRef{AnnotateAndDeclareFunc}.
%
Subprogram declarations have no associated semantics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax\label{sec:SubprogramDeclarationsSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Ndecl  \derives \ & \Noverride \parsesep \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nreturntype \parsesep \Nrecurselimit \\
& \wrappedline\ \parsesep \Nfuncbody &\\
|\ & \Noverride \parsesep \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nfuncbody &\\
|\ & \Noverride \parsesep \Taccessor \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Tbiarrow \parsesep \Nty &\\
   & \wrappedline\ \Tbegin \parsesep \Naccessors \parsesep \Tend \parsesep \Tsemicolon &\\
\end{flalign*}

\begin{flalign*}
\Nrecurselimit   \derives \ & \Trecurselimit \parsesep \Nexpr &\\
|\              & \emptysentence &\\
\Nparamsopt \derives \ & \emptysentence &\\
                   |\ & \Tlbrace \parsesep \ClistZero{\Nopttypedidentifier} \parsesep \Trbrace &\\
\Nopttypedidentifier \derives \ & \Tidentifier \parsesep \option{\Nasty} &\\
\Nfuncargs          \derives \ & \Tlpar \parsesep \ClistZero{\Ntypedidentifier} \parsesep \Trpar &\\
\Nreturntype        \derives \ & \Tarrow \parsesep \Nty &\\
\Nfuncbody          \derives \ & \Tbegin \parsesep \Nmaybeemptystmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Nmaybeemptystmtlist \derives \ & \emptysentence \;|\; \Nstmtlist &\\
\Naccessors \derives \ &
  \Tgetter \parsesep \Nfuncbody \parsesep
  \Tsetter \parsesep \Teq \parsesep \Tidentifier \parsesep \Nfuncbody &\\
|\ & \Tsetter \parsesep \Teq \parsesep \Tidentifier \parsesep \Nfuncbody \parsesep
    \Tgetter \parsesep \Nfuncbody &\\
\Noverride \derivesinline\ & \emptysentence \;|\; \Timpdef \;|\;\Timplementation &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Syntax\label{sec:SubprogramDeclarationsAbstractSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\decl \derives\ & \DFunc(\func) &
\end{flalign*}

\begin{flalign*}
\func \derives\ &
{
\left\{
  \begin{array}{rcl}
 \funcname &:& \Strings, \\
 \funcparameters &:& (\identifier, \ty?)^*,\\
 \funcargs &:& \typedidentifier^*,\\
 \funcbody &:& \subprogrambody,\\
 \funcreturntype &:& \ty?,\\
 \funcsubprogramtype &:& \subprogramtype,\\
 \funcrecurselimit    &:& \expr?\\
 \funcbuiltin &:& \Bool\\
 \funcoverride &:& \Some{\overrideinfo}\\
\end{array}
\right\}
} &\\
\typedidentifier \derives\ & (\identifier, \ty) &\\
\subprogrambody \derives\ & \SBASL(\stmt) \;|\; \SBPrimitive &\\
\subprogramtype \derives\ & \STProcedure \;|\; \STFunction &\\
                |\  & \STGetter \;|\; \STSetter &\\
\overrideinfo \derives\ & \Impdef \;|\; \Implementation &
\end{flalign*}

\ASTRuleDef{GlobalDecl}
The relation
\[
  \builddecl : \overname{\parsenode{\Ndecl}}{\vparsednode} \;\aslrel\; \overname{\decl^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

We first define $\accessorpair$, which we use in this section as an intermediate representation between the syntax forms of accessors and their corresponding abstract syntax.
In particular, rather than directly building the abstract syntax for accessors, we first build an $\accessorpair$ structure, which we then desugar into abstract syntax.

\hypertarget{ast-accessorpair}{}
\begin{flalign*}
\accessorpair \derives\ &
{
\left\{
  \begin{array}{rcl}
    \accessorpairgetter &:& \stmt, \\
    \accessorpairsetter &:& \stmt,\\
    \accessorpairsetterarg &:& \identifier
\end{array}
\right\}
} &
\end{flalign*}

\begin{mathpar}
\inferrule[func\_decl]{}{
  \builddecl\left(
    \overname{\Ndecl\left(
      \begin{array}{l}
    \punnode{\Noverride}, \Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \punnode{\Nreturntype}, \\
    \wrappedline\ \punnode{\Nrecurselimit}, \punnode{\Nfuncbody}
      \end{array}
  \right)}{\vparsednode}\right)
\astarrow \\
{
    \overname{
  \left[\DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \langle \astof{\vreturntype} \rangle,\\
            \funcsubprogramtype &:& \STFunction,\\
            \funcrecurselimit   &:& \langle\astof{\vrecurselimit}\rangle\\
            \funcbuiltin &:& \False\\
            \funcoverride &:& \astof{\voverride}
    \end{array}
  \right\}\right)\right]}{\vastnode}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[procedure\_decl]{}{
  \builddecl(
    \overname{\Ndecl(\punnode{\Noverride}, \Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \punnode{\Nfuncbody})}{\vparsednode}
    )
  \astarrow \\
  {
    \overname{
  \left[\DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \None,\\
            \funcsubprogramtype &:& \STProcedure,\\
            \funcrecurselimit   &:& \None\\
            \funcbuiltin &:& \False\\
            \funcoverride &:& \astof{\voverride}
    \end{array}
  \right\}\right)\right]
    }{\vastnode}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[accessor]{
  \buildaccessors(\vaccessors) \astarrow \vaccessorpair \\
  \desugaraccessorpair(\voverride, \name, \astof{\vparamsopt}, \astof{\vfuncargs}, \astof{\tty}, \vaccessorpair) \astarrow \vastnode
}{
  {
  \begin{array}{r}
    \builddecl\left(\overname{\Ndecl\left(
      \begin{array}{l}
        \punnode{\Noverride}, \Taccessor, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs},
        \Tbiarrow, \punnode{\Nty}, \\
        \wrappedline\ \Tbegin, \namednode{\vaccessors}{\Naccessors}, \Tend, \Tsemicolon
      \end{array}
    \right)}{\vparsednode}\right)
  \\ \astarrow \vastnode
  \end{array}
  }
}
\end{mathpar}

\subsection{Example}
\listingref{AccessorDeclaration} shows an accessor declaration.
The accessor \texttt{X} is used to read and write underlying storage element \texttt{R}.
For example, this could model a register file consisting of 32 registers, each of 64-bits, the last of which is always zero.

\ASLListing{An accessor declaration}{AccessorDeclaration}{\definitiontests/Accessor.asl}

\ASTRuleDef{RecurseLimit}
\hypertarget{build-recurselimit}{}
The function
\[
\buildrecurselimit(\overname{\parsenode{\Nrecurselimit}}{\vparsednode}) \aslto \overname{\langle\expr\rangle}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\Trecurselimit, \punnode{\Nexpr})}{\vparsednode}\right)
  \astarrow
  \overname{\langle\astof{\vexpr}\rangle}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\emptysentence)}{\vparsednode}\right)
  \astarrow
  \overname{\None}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{TypedIdentifier}
\hypertarget{build-typedidentifier}{}
The function
\[
\buildtypedidentifier(\overname{\parsenode{\Ntypedidentifier}}{\vparsednode}) \aslto \overname{(\identifier \times \ty)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildtypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \punnode{\Nasty})}{\vparsednode}) \astarrow \overname{(\id,\astof{\vasty})}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{OptTypedIdentifier}
\hypertarget{build-opttypedidentifier}{}
The function
\[
\buildopttypedidentifier(\overname{\parsenode{\Nopttypedidentifier}}{\vparsednode}) \aslto \overname{(\identifier \times \langle\ty\rangle)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildoption[\Nasty](\vastyopt) \astarrow \astversion{\vastyopt}
}{
  {
  \begin{array}{r}
  \buildopttypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \namednode{\vastyopt}{\option{\Nasty}})}{\vparsednode}) \astarrow \\
  \overname{(\id, \astversion{\vastyopt})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{ReturnType}
\hypertarget{build-returntype}{}
The function
\[
\buildreturntype(\overname{\parsenode{\Nreturntype}}{\vparsednode}) \aslto \overname{\ty}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildreturntype(\overname{\Nreturntype(\Tarrow, \punnode{\Nty})}{\vparsednode}) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{ParamsOpt}
\hypertarget{build-paramsopt}{}
The function
\[
\buildparamsopt(\overname{\parsenode{\Nparamsopt}}{\vparsednode}) \aslto
  \overname{(\identifier\times\langle\ty\rangle)^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildparamsopt(\overname{\Nparamsopt(\epsilonnode)}{\vparsednode}) \astarrow
  \overname{\emptylist}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \buildclist[\Nopttypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildparamsopt(\overname{\Nparamsopt(\Tlbrace, \namednode{\ids}{\ClistZero{\Nopttypedidentifier}}, \Trbrace)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{FuncArgs}
\hypertarget{build-funcargs}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncargs}}{\vparsednode}) \aslto
  \overname{(\identifier\times\ty)^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildclist[\Ntypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildfuncargs(\overname{\Nfuncargs(\Tlpar, \namednode{\ids}{\ClistZero{\Ntypedidentifier}}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{MaybeEmptyStmtList}
\hypertarget{build-maybeemptystmtlist}{}
The function
\[
\buildmaybeemptystmtlist(\overname{\parsenode{\Nmaybeemptystmtlist}}{\vparsednode}) \aslto
  \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildmaybeemptystmtlist(\overname{\Nmaybeemptystmtlist(\epsilonnode)}{\vparsednode}) \astarrow
  \overname{\SPass}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{}{
  \buildmaybeemptystmtlist(\overname{\Nmaybeemptystmtlist(\Nstmtlist)}{\vparsednode}) \astarrow
  \overname{\astof{\vstmtlist}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{FuncBody}
\hypertarget{build-funcbody}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncbody}}{\vparsednode}) \aslto
  \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  {
  \begin{array}{r}
  \buildfuncbody(\overname{\Nfuncbody(\Tbegin, \namednode{\vstmts}{\Nmaybeemptystmtlist}, \Tend, \Tsemicolon)}{\vparsednode}) \astarrow \\
  \overname{\astof{\vmaybeemptystmtlist}}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{Accessors}
\hypertarget{build-accessors}{}
The function
\[
\buildaccessors(\overname{\parsenode{\Naccessors}}{\vparsednode}) \aslto
  \overname{\accessorpair}{\vaccessorpair}
\]
transforms a parse node $\vparsednode$ into an $\accessorpair$.

\begin{mathpar}
\inferrule{
  \buildstmt(\vgetter) \astarrow \astversion{\vgetter} \\\\
  \buildstmt(\vsetter) \astarrow \astversion{\vsetter} \\\\
  {
  \vaccessorpair \eqdef
  \left\{
  \begin{array}{rcl}
    \accessorpairgetter    &:& \astversion{\vgetter},\\
    \accessorpairsetter    &:& \astversion{\vsetter},\\
    \accessorpairsetterarg &:& \name
  \end{array}
  \right\}
  }
}{
  {
  \begin{array}{r}
    \buildaccessors(
      \Tgetter, \namednode{\vgetter}{\Nfuncbody},
      \Tsetter, \Tidentifier(\name), \namednode{\vsetter}{\Nfuncbody}
    ) \\
    \astarrow \vaccessorpair
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \buildstmt(\vgetter) \astarrow \astversion{\vgetter} \\\\
  \buildstmt(\vsetter) \astarrow \astversion{\vsetter} \\\\
  {
  \vaccessorpair \eqdef
  \left\{
  \begin{array}{rcl}
    \accessorpairgetter    &:& \astversion{\vgetter},\\
    \accessorpairsetter    &:& \astversion{\vsetter},\\
    \accessorpairsetterarg &:& \name
  \end{array}
  \right\}
  }
}{
  {
  \begin{array}{r}
    \buildaccessors(
      \Tsetter, \Tidentifier(\name), \namednode{\vsetter}{\Nfuncbody},
      \Tgetter, \namednode{\vgetter}{\Nfuncbody}
    ) \\
    \astarrow \vaccessorpair
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DesugarAccessorPair}
\hypertarget{def-desugaraccessorpair}{}
The function
\[
\begin{array}{r}
  \desugaraccessorpair(
    \overname{\overrideinfo}{\voverride} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{(\identifier \times \Some{\ty})^*}{\vparameters} \aslsep
    \overname{\typedidentifier^*}{\vargs} \aslsep
    \overname{\ty}{\tty} \aslsep
    \overname{\accessorpair}{\vaccessorpair}
  ) \\ \aslto
  \overname{\decl^*}{\vastnode}
\end{array}
\]
transforms an $\accessorpair$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  {
  \vgetter \eqdef
      \DFunc\left\{
      \begin{array}{rcl}
        \funcname &:& \name,\\
        \funcparameters &:& \vparameters,\\
        \funcargs &:& \vargs,\\
        \funcbody &:& \SBASL(\vaccessorpair.\accessorpairgetter),\\
        \funcreturntype &:& \Some{\tty},\\
        \funcsubprogramtype &:& \STGetter,\\
        \funcrecurselimit   &:& \None\\
        \funcbuiltin &:& \False\\
        \funcoverride &:& \voverride
      \end{array}
      \right\}
  } \\\\
  \vsetterargs \eqdef [(\vaccessorpair.\accessorpairsetterarg, \tty)] \concat \vargs \\\\
  {
  \vsetter \eqdef
      \DFunc\left\{
      \begin{array}{rcl}
        \funcname &:& \name,\\
        \funcparameters &:& \vparameters,\\
        \funcargs &:& \vsetterargs,\\
        \funcbody &:& \SBASL(\vaccessorpair.\accessorpairsetter),\\
        \funcreturntype &:& \None,\\
        \funcsubprogramtype &:& \STSetter,\\
        \funcrecurselimit   &:& \None\\
        \funcbuiltin &:& \False\\
        \funcoverride &:& \voverride
      \end{array}
      \right\}
  }
}{
  {
  \begin{array}{r}
    \desugaraccessorpair(\voverride, \name, \vparameters, \vargs, \tty, \vaccessorpair)
    \astarrow [\vgetter, \vsetter]
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{Override}
\hypertarget{build-override}{}
The function
\[
\buildoverride(\overname{\parsenode{\Noverride}}{\vparsednode}) \aslto
  \overname{\Some{\overrideinfo}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildoverride(\overname{\Noverride(\emptysentence)}{\vparsednode}) \astarrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule{}{
  \buildoverride(\overname{\Noverride(\Timpdef)}{\vparsednode}) \astarrow \Some{\Impdef}
}
\end{mathpar}

\begin{mathpar}
\inferrule{}{
  \buildoverride(\overname{\Noverride(\Timplementation)}{\vparsednode}) \astarrow \Some{\Implementation}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We also define the following helper rules:
\begin{itemize}
  \item \TypingRuleRef{AnnotateAndDeclareFunc}
  \item \TypingRuleRef{AnnotateFuncSig}
  \item \TypingRuleRef{AnnotateParams}
  \item \TypingRuleRef{AnnotateOneParam}
  \item \TypingRuleRef{CheckParamDecls}
  \item \TypingRuleRef{TypesInFuncSig}
  \item \TypingRuleRef{ParametersOfTy}
  \item \TypingRuleRef{ParametersOfExpr}
  \item \TypingRuleRef{ParametersOfConstraint}
  \item \TypingRuleRef{AnnotateArgs}
  \item \TypingRuleRef{AnnotateOneArg}
  \item \TypingRuleRef{AnnotateReturnType}
  \item \TypingRuleRef{DeclareOneFunc}
  \item \TypingRuleRef{SubprogramClash}
  \item \TypingRuleRef{AddNewFunc}
  \item \TypingRuleRef{AddSubprogram}
\end{itemize}

\TypingRuleDef{AnnotateAndDeclareFunc}
\hypertarget{def-annotateanddeclarefunc}{}
The function
\[
  \annotateanddeclarefunc(\overname{\globalstaticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\tenv} \times \overname{\func}{\newfuncsig} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a subprogram definition $\funcsig$ in the global static environment $\genv$,
yielding a new subprogram definition $\newfuncsig$, a modified static environment
$\newtenv$, and an inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the signature of $\funcsig$ in $\genv$ as per
        \TypingRuleRef{AnnotateFuncSig} yields
        $(\tenvone, \funcsigfone, \vsesone)$\ProseOrTypeError;
  \item declaring the subprogram defined by $\funcsigfone$ in $\tenvone$ with $\vsesfone$
        as per \TypingRuleRef{DeclareOneFunc} yields the environment $\newtenv$
        and new $\func$ node $\newfuncsig$\ProseOrTypeError;
  \item \Proseeqdef{$\vses$}{$\vsesfone$}.
\end{itemize}
\CodeSubsection{\AnnotateAndDeclareFuncBegin}{\AnnotateAndDeclareFuncEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\tenvone, \funcsigfone, \vsesfone) \OrTypeError\\\\
  \declareonefunc(\tenvone, \funcsigfone, \vsesfone) \typearrow (\newtenv, \newfuncsig) \OrTypeError
}{
  \annotateanddeclarefunc(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig, \overname{\vsesfone}{\vses})
}
\end{mathpar}

\TypingRuleDef{AnnotateFuncSig}
\hypertarget{def-annotatefuncsig}{}
The function
\[
  \annotatefuncsig(\overname{\globalstaticenvs}{\genv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig} \times \overname{\TSideEffect}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the signature of a function definition $\funcsig$ in the global static environment $\genv$,
yielding a new function definition $\newfuncsig$,
a modified static environment $\newtenv$, and
an inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tenv$ is the static environment which comprises of the global static environment $\genv$ and an empty local environment;
  \item applying $\annotatelimitexpr$ to $\funcsig.\funcrecurselimit$ in $\tenvone$ yields \\
        $(\vrecurselimit, \vsesrecurselimit)$\ProseOrTypeError;
  \item annotating and declaring the parameters $\funcsig.\funcparameters$ in $\tenv$ using \\
        $\annotateparams$ yields $(\tenvwithparams, \vseswithparams, \params)$\ProseOrTypeError;
  \item checking that the parameters $\funcsig.\funcparameters$ are declared correctly using $\checkparamdecls$, yields $\True$\ProseOrTypeError;
  \item annotating and declaring the arguments $\funcsig.\funcargs$ in $\tenvwithparams$ using $\annotateargs$
        and $\vseswithparams$ yields
        $(\tenvwithargs, \vseswithargs, \vargs)$\ProseOrTypeError;
  \item annotating the return type of $\funcsig$ in $\tenvwithparams$ using \\ $\annotatereturntype$ and $\vseswithargs$, yields
        $(\newtenv, \vreturntype, \vseswithreturn)$\ProseOrTypeError;
  \item \Proseeqdef{$\vses$}{$\vseswithreturn$ with all instances of \ReadLocal\ and \WriteLocalTerm\ removed};
  \item $\newfuncsig$ is $\funcsig$ with the annotated parameters $\vparams$, annotated arguments $\vargs$, annotated return type $\vreturntype$,
        and $\vrecurselimit$ as its recursion limit.
\end{itemize}
\CodeSubsection{\AnnotateFuncSigBegin}{\AnnotateFuncSigEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \withemptylocal(\genv) \typearrow \tenv\\
  \annotatelimitexpr(\tenvone, \funcsig.\funcrecurselimit) \typearrow (\vrecurselimit, \vsesrecurselimit) \OrTypeError\\\\
  {
    \begin{array}{r}
    \annotateparams(\tenv, \funcsig.\funcparameters, (\tenv, \emptylist)) \typearrow \\
    (\tenvwithparams, \vseswithparams, \params) \OrTypeError
    \end{array}
  }\\
  \checkparamdecls(\tenv, \funcsig) \typearrow \True \OrTypeError \\
  {
    \begin{array}{r}
    \annotateargs(\tenvwithparams, \funcsig.\funcargs, (\tenvwithparams, \emptylist), \vseswithparams) \typearrow \\
    (\tenvwithargs, \vseswithargs, \vargs) \OrTypeError
      \end{array}
  }\\\\
  {
    \begin{array}{r}
  \annotatereturntype(\tenvwithargs, \tenvwithparams, \funcsig.\funcreturntype, \vseswithargs) \typearrow \\
    (\newtenv, \vreturntype, \vseswithreturn) \OrTypeError
    \end{array}
  }\\\\
  \vses \eqdef \vseswithreturn \setminus \{ \vs \;|\; \configdomain{\vs} \in \{\ReadLocal, \WriteLocal\} \}\\
  {
    \newfuncsig \eqdef
    \left\{
    \begin{array}{rcl}
      \funcname            &:& \funcsig.\funcname,\\
      \funcparameters      &:& \vparameters,\\
      \funcargs            &:& \vargs,\\
      \funcbody            &:& \funcsig.\funcbody,\\
      \funcreturntype      &:& \vreturntype,\\
      \funcsubprogramtype  &:& \funcsig.\funcsubprogramtype,\\
      \funcrecurselimit    &:& \vrecurselimit\\
      \funcbuiltin         &:& \funcsig.\funcbuiltin
    \end{array}
    \right\}
  }
}{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateParams}
\hypertarget{def-annotateparams}{}
The function
\[
\begin{array}{r}
\annotateparams(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier \times \langle\ty\rangle)^*}{\params} \aslsep\
  (\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\acc})
) \aslto \\
(\overname{\staticenvs}{\tenvwithparams} \times \overname{\identifier\times\ty}{\paramsone})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates each parameter in $\params$ with respect to $\tenv$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithparams$ and the annotated parameters $\paramsone$, together with any annotated parameters already in the accumulator $\acc$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Parameters}
In \listingref{typing-parameterofconstraint}, the list of explicitly defined parameters
of the function \\
\verb|signature_example| is $\{\texttt{A},\texttt{B}\}$.
Therefore, $\tenvwithparams$ effectively reflects the added declarations \\
\verb|let A: integer{A}| and \verb|let B: integer{B}|.

\ASLListing{A function with parameters}{typing-parameterofconstraint}{\typingtests/TypingRule.AnnotateFuncSig.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\params$ is the empty list;
    \item $\tenvwithparams$ is $\newtenv$;
    \item $\paramsone$ is $\acc$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\params$ is a list with $(\vx, \tyopt)$ as its \head\ and $\paramsp$ as its \tail;
    \item applying $\annotateoneparam$ to the parameter $(\vx, \tyopt)$ with $\tenv$ and $\newtenv$ yields the pair $\newtenvp$ and $\tty$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \tty)$;
    \item applying $\annotateparams$ to $\paramsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields $\tenvwithparams$ and $\paramsone$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotateparams(\tenv, \overname{\emptylist}{\params}, (\newtenv, \acc)) \typearrow
  (\overname{\newtenv}{\tenvwithparams}, \overname{\acc}{\paramsone})
}
\and
\inferrule[non\_empty]{
  \params \eqname [(\vx,\tyopt)] \concat \paramsp\\\\
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \tty)] \\\\
  \annotateparams(\tenv, \paramsp, (\newtenvp, \accp)) \typearrow (\tenvwithparams, \paramsone) \OrTypeError
}{
  \annotateparams(\tenv, \params, (\newtenv, \acc)) \typearrow (\tenvwithparams, \paramsone)
}
\end{mathpar}

\TypingRuleDef{AnnotateOneParam}
The function
\hypertarget{def-annotateoneparam}{}
\[
\begin{array}{r}
\annotateoneparam(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\langle\ty\rangle}{\tyopt})
) \aslto
(\overname{\staticenvs}{\newtenvp} \times \overname{\ty}{\tty})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the parameter given by $\vx$ and the \optional\ type $\tyopt$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The updated environment $\newtenvp$ and annotated parameter type $\tty$ are returned.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{type\_parameterized}
    \begin{itemize}
      \item $\tyopt$ is either $\None$ or an \unconstrainedintegertype{};
      \item $\tty$ is defined as the \parameterizedintegertype\ for the identifier $\vx$.
    \end{itemize}

    \item \AllApplyCase{type\_annotated}
    \begin{itemize}
      \item $\tyopt$ is the type $\langle\ttyp\rangle$, which is not the unconstrained integer type;
      \item annotating $\ttyp$ in $\tenv$ yields $\tty$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item checking that $\tty$ is a constrained integer in $\newtenv$ via $\checkconstrainedinteger$
        yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\tty$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[type\_parameterized]{
  (\tyopt = \None \lor \tyopt = \langle \unconstrainedinteger\rangle) \\
  \tty \eqdef \TInt(\parameterized(\vx))\\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty)
}
\and
\inferrule[type\_annotated]{
  \ttyp \neq \unconstrainedinteger\\
  \annotatetype{\False, \tenv, \ttyp} \typearrow \tty \OrTypeError\\\\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \langle\ttyp\rangle)) \typearrow (\newtenvp, \tty)
}
\end{mathpar}

\TypingRuleDef{CheckParamDecls}
\hypertarget{def-checkparamdecls}{}
The function
\[
\checkparamdecls(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig}) \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks the parameters declared in $\funcsig$ for validity.

\ProseParagraph
\AllApply
\begin{itemize}
  \item Finding the list of types in $\funcsig$ using $\typesinfuncsig$ yields $\tys$;
  \item Applying $\paramsofty$ to each type in $\tys$ and concatenating the results yields the list of parameter identifiers $\params$;
  \item Finding unique elements in $\params$ yields $\paramsone$;
  \item Checking that the expected parameters $\paramsone$ and the declared parameters $\funcsig.\funcparameters$ are equal yields $\vb$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \typesinfuncsig(\funcsig) \typearrow \tys \\
  \vi \in \listrange(\tys): \paramsofty(\tenv, \tty_i) \typearrow \params_i \\
  \params \eqdef \params_1 \concat \ldots \concat \params_{\listlen{\tys}} \\
  \paramsone \eqdef \uniquelist(\params) \\\\
  \checktrans{\paramsone = \funcsig.\funcparameters}{\BadSubprogramDeclaration} \checktransarrow \vb \OrTypeError
}{
  \checkparamdecls(\tenv, \funcsig) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{TypesInFuncSig}
\hypertarget{def-typesinfuncsig}{}
The function
\[
\typesinfuncsig(\overname{\func}{\funcsig}) \aslto \overname{\ty^*}{\tys}
\]
returns the list of types $\tys$ in the function signature $\funcsig$.
Their ordering is return type first (if any), followed by argument types left-to-right.

\ProseParagraph
Define $\tys$ as the return type (if any) concatenated with the argument types.

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \left(
    \begin{array}{l}
    \funcsig.\funcreturntype \eqname \None \;\land\; \vreturntype \eqdef \emptylist \;\lor\\
    \funcsig.\funcreturntype \eqname \langle\ttyp\rangle \;\land\; \vreturntype \eqdef [\ttyp]
    \end{array}
    \right)
  } \\\\
  \argtypes \eqdef [(\Ignore, \ttyp)\in\funcsig.\funcargs: \ttyp]
}{
  \typesinfuncsig(\funcsig) \typearrow \overname{\vreturntype \concat \argtypes}{\tys}
}
\end{mathpar}


\TypingRuleDef{ParametersOfTy}
\hypertarget{def-paramsofty}{}
The function
\[
\paramsofty(\overname{\staticenvs}{\tenv}, \overname{\ty}{\tty}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the type $\tty$.
It assumes that $\tty$ appears in a function signature.

\ProseParagraph
\OneApplies

\begin{itemize}
  \item \AllApplyCase{tbits}
    \begin{itemize}
      \item $\tty$ is a bitvector type, that is, $\TBits(\ve, \Ignore)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $\ids$.
    \end{itemize}

  \item \AllApplyCase{ttuple}
    \begin{itemize}
      \item $\tty$ is a tuple over a list of types $\tys$, that is, $\TTuple(\tys)$;
      \item applying $\paramsofty$ to each type $\tty_i$ in $\tys$ yields $\ids_i$;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item \AllApplyCase{tint\_constrained}
    \begin{itemize}
      \item $\tty$ is a \wellconstrainedintegertype, that is, $\TInt(\wellconstrained(\cs))$;
      \item applying $\paramsofconstraint$ to each constraint $\vc_i$ in $\cs$ yields $\ids_i$;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item \AllApplyCase{other}
    \begin{itemize}
      \item $\tty$ is not a \tupletypeterm{}, bitvector type, or \wellconstrainedintegertype;
      \item $\ids$ is the empty list.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[tbits]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofty(\tenv, \TBits(\ve, \Ignore)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ttuple]{
  \tty_i \in \tys: \paramsofty(\tenv, \tty_i) \typearrow \ids_i \\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TTuple(\tys)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[tint\_constrained]{
  \vc_i \in \cs: \paramsofconstraint(\tenv, \vc_i) \typearrow \ids_i \\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TInt(\wellconstrained(\cs)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\tty) \notin \{ \TBits, \TTuple \} \\
  \neg \iswellconstrainedinteger(\tty)
}{
  \paramsofty(\tenv, \tty) \typearrow \overname{\emptylist}{\ids}
}
\end{mathpar}


\TypingRuleDef{ParametersOfExpr}
\hypertarget{def-paramsofexpr}{}
The function
\[
\paramsofexpr(\overname{\staticenvs}{\tenv}, \overname{\expr}{\ve}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the expression $\ve$.
It assumes that $\ve$ appears as $\TBits(\ve, \Ignore)$ or as part of a \wellconstrainedintegertype{} in a function signature.

\ProseParagraph
\OneApplies

\begin{itemize}
  \item \AllApplyCase{eval}
    \begin{itemize}
      \item $\ve$ is a variable, that is, $\EVar(\vx)$;
      \item if $\vx$ is undefined in $\tenv$ then $\ids$ is $[\vx]$, otherwise $\ids$ is $\emptylist$.
    \end{itemize}

  \item \AllApplyCase{eunop}
    \begin{itemize}
      \item $\ve$ is a unary operation, that is, $\EUnop(\Ignore, \ve)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\ids$.
    \end{itemize}

  \item \AllApplyCase{ebinop}
    \begin{itemize}
      \item $\ve$ is a binary operation, that is, $\EBinop(\Ignore, \veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$;
      \item define $\ids$ as the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}

  \item \AllApplyCase{etuple}
    \begin{itemize}
      \item $\ve$ is a tuple over a list of expressions, that is, $\ETuple(\es)$;
      \item applying $\paramsofexpr$ to each expression $\ve_i$ in $\es$ yields $\ids_i$;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item \AllApplyCase{other}
    \begin{itemize}
      \item $\ve$ is not a variable, unary operation, binary operation, or tuple;
      \item $\ids$ is the empty list.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[eval]{
  \isundefined(\tenv, \vx) \typearrow \vb\\
  \ids \eqdef \choice{\vb}{[\vx]}{\emptylist}
}{
  \paramsofexpr(\tenv, \EVar(\vx)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[eunop]{
  \paramsofexpr(\tenv, \veone) \typearrow \ids
}{
  \paramsofexpr(\tenv, \EUnop(\Ignore, \veone)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo
}{
  \paramsofexpr(\tenv, \EBinop(\Ignore, \veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[etuple]{
  \ve_i \in \es: \paramsofexpr(\tenv, \ve_i) \typearrow \ids_i \\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\es}}
}{
  \paramsofexpr(\tenv, \ETuple(\es)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \notin \{ \EVar, \EUnop, \EBinop, \ETuple \}
}{
  \paramsofexpr(\tenv, \ve) \typearrow \overname{\emptylist}{\ids}
}
\end{mathpar}

\TypingRuleDef{ParametersOfConstraint}
\hypertarget{def-paramsofconstraint}{}
The function
\[
\paramsofconstraint(\overname{\staticenvs}{\tenv}, \overname{\intconstraint}{\vc}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the constraint $\vc$.
It assumes that $\vc$ appears within a \wellconstrainedintegertype{} in a function signature.

\ProseParagraph
\OneApplies

\begin{itemize}
  \item \AllApplyCase{exact}
    \begin{itemize}
      \item $\vc$ is an exact constraint, that is, $\ConstraintExact(\ve)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $ids$.
    \end{itemize}

  \item \AllApplyCase{range}
    \begin{itemize}
      \item $\vc$ is an range constraint, that is, $\ConstraintRange(\veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$;
      \item $\ids$ is the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofconstraint(\tenv, \ConstraintExact(\ve)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo \\
}{
  \paramsofconstraint(\tenv, \ConstraintRange(\veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\subsection{Example}
In \listingref{typing-parameterofconstraint}, the set of identifiers that may correspond
to parameters of the function \texttt{signature\_example} is $\{\texttt{A}, \texttt{B}\}$,
since they appear in the type \texttt{bits(A)}
of the argument \texttt{bv} and the type \texttt{bits(A+B)} of the argument \texttt{bv3}.

Finding parameters for each type in the signature of the function \texttt{signature\_example}
yields the following results:
\begin{center}
\begin{tabular}{lll}
\textbf{Expression} & \textbf{Result} & \textbf{Reason}\\
\hline
\texttt{bits(A)} & $\{\texttt{A}\}$ & \texttt{A} is a variable expression \\
& & and \texttt{A} is not defined in the environment.\\
\texttt{bits(W)} & $\emptyset$ & \texttt{W} is defined in the environment.\\
\texttt{bits(A+B)} & $\{\texttt{A}, \texttt{B}\}$ & \texttt{A} and \texttt{B} are variables \\
& & and neither is defined in the environment.\\
\end{tabular}
\end{center}

\TypingRuleDef{AnnotateArgs}
\hypertarget{def-annotateargs}{}
The function
\[
\begin{array}{r}
\annotateargs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier \times \ty)^*}{\args} \aslsep\
  (\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\acc} \aslsep
  \overname{\TSideEffectSet}{\vsesin})
) \aslto \\
(\overname{\staticenvs}{\tenvwithargs} \times \overname{(\identifier\times\ty)^*}{\vnewargs} \times \overname{\TSideEffectSet}{\vses})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates each argument in $\args$ with respect to $\tenv$ and a \sideeffectsetterm\ $\vsesin$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithargs$, the annotated arguments $\vnewargs$,
together with any annotated arguments already in the accumulator $\acc$,
and a \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Subprogram Arguments}
In \listingref{typing-parameterofconstraint}, the annotated arguments are
\texttt{bv}, \texttt{bv2}, \texttt{bv3}, and \texttt{C}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\args$ is the empty list;
    \item $\tenvwithargs$ is $\newtenv$;
    \item $\newargs$ is $\acc$;
    \item \Proseeqdef{$\vses$}{$\vsesin$}
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\args$ is a list with $(\vx, \tty)$ as its \head\ and $\vargsp$ as its \tail;
    \item applying $\annotateonearg$ to the argument $(\vx, \tty)$ with $\tenv$ and $\newtenv$ yields
          $(\newtenvp, \ttyp, \vsesty)$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \ttyp)$;
    \item applying $\annotateargs$ to $\vargsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields $(\tenvwithargs, \newargs, \newses)$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesty$ and $\newses$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotateargs(\tenv, \overname{\emptylist}{\args}, (\newtenv, \acc), \vsesin) \typearrow
  (\overname{\newtenv}{\tenvwithargs}, \overname{\acc}{\newargs}, \overname{\vsesin}{\vses})
}
\and
\inferrule[non\_empty]{
  \vargs \eqname [(\vx,\tty)] \concat \vargsp\\\\
  \annotateonearg(\tenv, \newtenv, (\vx, \tty)) \typearrow (\newtenvp, \ttyp, \vsesty) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \ttyp)] \\\\
  \annotateargs(\tenv, \vargsp, (\newtenvp, \accp), \vsesin) \typearrow (\tenvwithargs, \newargs, \newses) \OrTypeError\\\\
  \vses \eqdef \vsesty \cup \newses
}{
  \annotateargs(\tenv, \args, (\newtenv, \acc), \vsesin) \typearrow (\tenvwithargs, \newargs, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateOneArg}
\hypertarget{def-annotateonearg}{}
The function
\[
\annotateonearg(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\ty}{\tty})
) \aslto
(\overname{\staticenvs}{\newtenvp} \times\ \overname{\ty}{\ttyp} \times \overname{\TSideEffectSet}{\vses})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the argument given by the identifier $\vx$ and the type $\tty$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The result is the updated environment $\newtenvp$, annotated argument type $\ttyp$,
and inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyp, \vses)$\ProseOrTypeError;
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\ttyp$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \tty} \typearrow (\ttyp, \vses) \OrTypeError \\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\
  \addlocal(\newtenv, \vx, \ttyp, \LDKLet) \typearrow \newtenvp
}{
  \annotateonearg(\tenv, \newtenv, (\vx, \tty))
  \typearrow (\newtenvp, \ttyp, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateReturnType}
\hypertarget{def-annotatereturntype}{}
The function
\[
\begin{array}{rl}
\annotatereturntype(
  \overname{\staticenvs}{\tenvwithparams} \aslsep
  \overname{\staticenvs}{\tenvwithargs} \aslsep
  \overname{\langle\ty\rangle}{\vreturntype \aslsep
  \overname{\TSideEffectSet}{\vsesin}}
) & \aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newreturntype} \times \overname{\TSideEffectSet}{\vses})
\cup \overname{\TTypeError}{\TypeErrorConfig} &
\end{array}
\]
annotates the \optional\ return type $\vreturntype$ in the context of the static environment
$\tenvwithparams$, where all parameters have been declared,
and the \sideeffectsetterm\ $\vsesin$.
The result is $\newtenv$, which is the input $\tenvwithargs$ (where all parameters and arguments have been declared)
with the \optional{} annotated return type $\newreturntype$ added
and the inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{no\_return\_type}
  \begin{itemize}
    \item $\vreturntype$ is $\None$;
    \item $\newtenv$ is $\tenvwithargs$;
    \item $\newreturntype$ is $\None$;
    \item \Proseeqdef{$\vses$}{$\vsesin$}.
  \end{itemize}

  \item \AllApplyCase{has\_return\_type}
  \begin{itemize}
    \item $\returntype$ is $\langle\tty\rangle$;
    \item annotating $\tty$ in $\tenvwithparams$ yields $(\ttyp, \vsesty)$\ProseOrTypeError;
    \item $\newreturntype$ is $\langle\ttyp\rangle$;
    \item $\newtenv$ is $\tenvwithargs$ with its local environment updated by binding its \\ $\funcreturntype$ field
          to $\newreturntype$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesin$ and $\vsesty$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_return\_type]{}
{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\None}{\vreturntype}, \vsesin) \typearrow \\
  (\overname{\tenvwithargs}{\newtenv}, \overname{\None}{\newreturntype}, \overname{\vsesin}{\vses})
  \end{array}
  }
}
\and
\inferrule[has\_return\_type]{
  \annotatetype{\tenvwithparams, \tty} \typearrow (\ttyp, \vsesty) \OrTypeError\\\\
  \newreturntype \eqdef \langle\ttyp\rangle\\
  \newtenv \eqdef (G^\tenvwithargs, L^\tenvwithargs[\funcreturntype\mapsto\newreturntype])\\
  \vses \eqdef \vsesin \cup \vsesty
}{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\langle\tty\rangle}{\returntype}, \vsesin) \typearrow \\
  (\newtenv, \newreturntype, \vses)
  \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{DeclareOneFunc}
\hypertarget{def-declareonefunc}{}
The function
\[
  \declareonefunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\func}{\funcsig} \aslsep
    \overname{\TSideEffectSet}{\vsesfuncsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks that a subprogram defined by $\funcsig$
and associated with the \sideeffectsetterm\ $\vsesfuncsig$
can be added to the static environment $\tenv$,
resulting in an annotated function definition $\newfuncdef$ and new static environment $\newtenv$.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\funcsig$ has name $\name$, arguments $\vargs$, and type $\subprogramtype$, that is,
  \[
    \begin{array}{rrcl}
      \funcsig \eqdef \{
                      & \funcname            &:& \name,\\
                      & \funcparameters      &:& \vp,\\
                      & \funcargs            &:& \vargs,\\
                      & \funcbody            &:& \SBASL(\bd),\\
                      & \funcreturntype      &:& \vt,\\
                      & \funcsubprogramtype  &:& \subprogramtype, \\
                      & \funcbuiltin         &:& \vb \\
                  \}  & ; &&
        \end{array}
  \]
  \item adding a new subprogram with $\name$, $\vargs$, and $\subprogramtype$ to $\tenv$ yields the new
        environment $\tenvone$ and new name $\namep$\ProseOrTypeError;
  \item checking that $\namep$ is not already declared in the global environment of $\tenvone$
        yields $\True$\ProseOrTypeError;
  \item $\funcsigone$ is $\funcsig$ with $\name$ substituted by $\nameone$;
  \item \Proseeqdef{$\initses$}{the union of $\vsesfuncsig$ and the singleton set for
        a \RecursiveCallTerm\ for $\namep$};
  \item adding a subprogram with name $\namep$, definition $\funcsigone$,
        and \sideeffectsetterm\ $\initses$ to $\tenvone$ yields $\newtenv$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rrcl}
    \funcsig \eqdef \{
                    & \funcname            &:& \name,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype, \\
                    & \funcbuiltin         &:& \vb \\
                \} &&&
      \end{array}
    }\\
  \addnewfunc(\tenv, \name, \vargs, \subprogramtype) \typearrow
  (\tenvone, \namep) \OrTypeError\\\\
  \checktrans{G^\tenvone.\subprograms(\namep) = \bot}{\IdentifierAlreadyDeclared} \checktransarrow \True \terminateas \IdentifierAlreadyDeclared \\\\
  {
  \begin{array}{rrcl}
    \newfuncsig \eqdef \{
                    & \funcname            &:& \namep,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype, \\
                    & \funcbuiltin         &:& \vb \\
                \} &&&
      \end{array}
    }\\
    \initses \eqdef \vsesfuncsig \cup \{ \RecursiveCall(\namep) \}\\
    \addsubprogram(\tenvone, \namep, \funcsigone, \initses) \typearrow \newtenv \OrTypeError
}{
  \declareonefunc(\tenv, \funcsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}
\CodeSubsection{\DeclareOneFuncBegin}{\DeclareOneFuncEnd}{../Typing.ml}
\identi{HJRD} \identd{BTBR} \identi{FSFQ} \identi{PFGQ} \identr{PGFC}

\TypingRuleDef{SubprogramClash}
\hypertarget{def-subprogramclash}{}
The function
\[
  \subprogramclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\subprogramtype}{\subpgmtype} \aslsep
    \overname{\ty^*}{\formaltypes}
  )
  \aslto
  \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the unique subprogram associated with $\name$
clashes with another subprogram
that has subprogram type $\subpgmtype$ and list of formal types $\formaltypes$,
yielding a Boolean value in $\vb$.
\ProseOtherwiseTypeError

The function is only defined when there exists a binding for $\name$ in the
$\subprograms$ map of $\tenv$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item the identifier $\name$ is bound to the $\func$ AST node $\otherfuncsig$ in the \\
        $\subprograms$ map
        of the static global environment of $\tenv$ (ignoring the associated \sideeffectdescriptorsterm);
  \item applying $\subprogramtypesclash$ to the subprogram type of $\otherfuncsig$ \\
        ($\otherfuncsig.\subprogramtype$) and $\subpgmtype$ yields \\
        $\True$\ProseTerminateAs{\False}
        (that is, if both subprogram types are $\STGetter$ or both are $\STSetter$ then the
        subprogram types are considered to be non-clashing and the entire rule short-circuits to $\False$);
  \item determining whether there is an argument clash between $\formaltypes$ and \\
        the formal arguments of $\otherfuncsig$ ($\otherfuncsig.\funcargs$) in $\tenv$ yields $\vb$\ProseOrTypeError.
\end{itemize}
\FormallyParagraph
\hypertarget{def-subprogramtypeclash}{}
We first introduce the helper predicate
\[
  \subprogramtypesclash(
    \overname{\subprogramtype}{\subpgmtypeone} \aslsep
    \overname{\subprogramtype}{\subpgmtypetwo}
  ) \aslto \overname{\Bool}{\vb}
\]
which defines whether two subprogram types are considered to be clashing:
\begin{mathpar}
\inferrule{
  \vbone \eqdef
  {
    \begin{array}{l}
  (\subpgmtypeone=\STGetter \land \subpgmtypetwo=\STSetter)\ \lor\\
  (\subpgmtypeone=\STSetter \land \subpgmtypetwo=\STGetter)
    \end{array}
  }\\\\
  \vb \eqdef \neg\vbone
}{
  \subprogramtypesclash(\subpgmtypeone, \subpgmtypetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  G^\tenv.\subprograms(\name) = (\otherfuncsig, \Ignore)\\
  \subprogramtypesclash(\otherfuncsig.\subprogramtype, \subpgmtype) \typearrow \True \terminateas \False\\
  \hasargclash(\formaltypes, \otherfuncsig.\funcargs) \typearrow \vb
}{
  \subprogramclash(\tenv, \name, \subpgmtype, \formaltypes) \typearrow \vb
}
\end{mathpar}
\identd{BTBR} \identi{FSFQ} \identi{PFGQ}

\TypingRuleDef{AddNewFunc}
\hypertarget{def-addnewfunc}{}
The function
\[
  \begin{array}{rl}
  \addnewfunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\typedidentifier^*}{\formals} \aslsep
    \overname{\subprogramtype}{\subpgmtype})
  & \aslto\\
  (\overname{\staticenvs}{\newtenv} \times \overname{\Strings}{\newname})
  \cup \overname{\TTypeError}{\TypeErrorConfig} &
  \end{array}
\]
ensures that the subprogram given by the identifier $\name$, list of formals $\formals$,
and subprogram type $\subpgmtype$ has a unique name among all the potential subprograms
that overload $\name$.
The result is the unique subprogram identifier $\newname$, which is used to distinguish it in the set
of overloaded subprograms (that is, other subprograms that share the same name)
and the environment $\newtenv$, which is updated with $\newname$.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{first\_name}
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ does not have a binding for $\name$;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the singleton set containing
          $\name$.
  \end{itemize}

  \item \AllApplyCase{name\_exists}
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ binds $\name$ to the set of strings $\othernames$;
    \item $\newname$ is the unique name that will be associated with the subprogram given by the identifier $\name$, list of formals $\formals$,
          and subprogram type $\subpgmtype$. It is constructed by concatenating a hyphen (\texttt{-}) to $\name$, followed
          by a string corresponding to the number of strings in $\othernames$.
          Notice that this is not an ASL identifier, as ASL identifiers do not contain hyphens, which ensures that this string
          does not occur in any specification;
    \item $\formaltypes$ is the list of types that appear in $\formals$ in the same order;
    \item checking for each $\namep$ in $\othernames$ whether the subprogram associated with $\namep$ clashes
          with the subprogram type $\subpgmtype$ and list of types $\formaltypes$ yields $\False$
          or a type error that indicates there are multiply defined subprograms, which short-circuits the entire rule;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the union of $\othernames$ and
          $\{\newname\}$.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[first\_name]{
  G^\tenv.\overloadedsubprograms(\name) = \bot\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto\{\name\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \overname{\name}{\newname})
}
\end{mathpar}

\begin{mathpar}
\inferrule[name\_exists]{
  G^\tenv.\overloadedsubprograms(\name) = \othernames\\
  k \eqdef \cardinality{\othernames}\\
  \newname \eqdef \name\ \stringconcat\ \discardvarstr\ \stringconcat\ \stringofnat(k)\\
  \formaltypes \eqdef [(\id,\vt) \in \formals : \vt]\\
  {
    \left(\begin{array}{l}
  \namep \in \othernames: \\ \subprogramclash(\tenv, \namep, \subpgmtype, \formaltypes) \typearrow
  \vb_{\namep} \OrTypeError
    \end{array}\right)
  }\\\\
  \namep \in \othernames: \checktrans{\neg\vb_{\namep}}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError\\\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto \othernames \cup \{\newname\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \newname)
}
\end{mathpar}
\identr{PGFC}
\CodeSubsection{\AddNewFuncBegin}{\AddNewFuncEnd}{../Typing.ml}
