%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basic Type Attributes\label{sec:BasicTypeAttributes}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section defines some basic predicates for classifying types as well as
functions that inspect the structure of types:
\begin{itemize}
  \item Builtin singular types (\TypingRuleRef{BuiltinSingularType})
  \item Named types (\TypingRuleRef{NamedType})
  \item Anonymous types (\TypingRuleRef{AnonymousType})
  \item Singular types (\TypingRuleRef{SingularType})
  \item Structured types (\TypingRuleRef{StructuredType})
  \item The structure of a type (\TypingRuleRef{Structure})
  \item The underlying type of a type (\TypingRuleRef{MakeAnonymous})
  \item Checked constrained integers (\TypingRuleRef{CheckConstrainedInteger})
\end{itemize}

\TypingRuleDef{BuiltinSingularType}
\RenderRelation{is_builtin_singular}


\ProseParagraph
The \emph{builtin singular types} are:
\begin{itemize}
\item the \integertypesterm{};
\item the \realtypeterm{};
\item the \stringtypeterm{};
\item the \booleantypeterm{};
\item the \bitvectortypeterm{} (which includes \texttt{bit}, as a special case);
\item the \enumerationtypeterm{}.
\end{itemize}

\ExampleDef{Builtin singular types}
\listingref{typing-builtinsingulartype} defines variables of builtin singular types
\texttt{integer}, \texttt{real},
\texttt{boolean}, \texttt{bits(4)}, and~\texttt{bits(2)}
\ASLListing{Examples of builtin singular types}{typing-builtinsingulartype}{\typingtests/TypingRule.BuiltinSingularTypes.asl}

\ExampleDef{Builtin enumeration types}
In \listingref{typing-builtinenumerationtype},
the builtin singular type \texttt{Color} consists of two constants:
\texttt{RED} and~\texttt{BLACK}.
\ASLListing{An enumeration type}{typing-builtinenumerationtype}{\typingtests/TypingRule.EnumerationType.asl}

\FormallyParagraph
\BackupOriginalRule{
\begin{mathpar}
\inferrule{
  \vb \eqdef \astlabel(\tty) \in \{\TReal, \TString, \TBool, \TBits, \TEnum, \TInt\}
}{
  \isbuiltinsingular(\tty) \typearrow \vb
}
\end{mathpar}
} % END_OF_BACKUP_RULE
\RenderRule{is_builtin_singular}
\CodeSubsection{\BuiltinSingularBegin}{\BuiltinSingularEnd}{../types.ml}
\identd{PQCK} \identd{NZWT}

\TypingRuleDef{NamedType}
\RenderRelation{is_named}

\Enumerationtypesterm{}, record types, collection types, and exception types
must be declared and associated with a named type.

\ExampleDef{Named Types}
In the specification
\begin{lstlisting}
type ticks of integer;
\end{lstlisting}
\texttt{ticks} is a named type.

\ProseParagraph
A named type is a type that is declared by using the \texttt{type ... of ...} syntax.

\FormallyParagraph
\BackupOriginalRule{
\begin{mathpar}
\inferrule{
  \vb \eqdef \astlabel(\tty) = \TNamed
}{
  \isnamed(\tty) \typearrow \vb
}
\end{mathpar}
} % END_OF_BACKUP_RULE
\RenderRule{is_named}
\CodeSubsection{\NamedBegin}{\NamedEnd}{../types.ml}
\identd{vmzx}

\TypingRuleDef{AnonymousType}
\identd{VMZX} \identi{SBCK}%
\RenderRelation{is_anonymous}

\ExampleDef{Anonymous Types}
The well-typed specification in \listingref{AnonymousType} illustrates the use
of anonymous types as permitted by \TypingRuleRef{TypeSatisfaction}.
\ASLListing{Well-typed anonymous types}{AnonymousType}{\typingtests/TypingRule.AnonymousType.asl}

\ProseParagraph
\Anonymoustypes\ are types that are not declared using the \texttt{type ... of ...} syntax:
\integertypesterm{}, the \realtypeterm{}, the \stringtypeterm{}, the \booleantypeterm{},
\bitvectortypesterm{}, \tupletypesterm{}, and \arraytypesterm{}.

\FormallyParagraph
\BackupOriginalRule{
\begin{mathpar}
\inferrule{
  \vb \eqdef \astlabel(\tty) \neq \TNamed
}{
  \isanonymous(\tty) \typearrow \vb
}
\end{mathpar}
} % END_OF_BACKUP_RULE
\RenderRule{is_anonymous}
\CodeSubsection{\AnonymousBegin}{\AnonymousEnd}{../types.ml}

\TypingRuleDef{SingularType}
\identr{GVZK}%
\RenderRelation{is_singular}

\ExampleDef{Singular types}
In the following example, the types \texttt{A}, \texttt{B}, and \texttt{C} are all singular types:
\begin{lstlisting}
type A of integer;
type B of A;
type C of B;
\end{lstlisting}

\ProseParagraph
\AllApply
\begin{itemize}
  \item obtaining the \underlyingtypeterm\ of $\tty$ in the \staticenvironmentterm{} $\tenv$ yields $\vtone$\ProseOrTypeError;
  \item applying $\isbuiltinsingular$ to $\vtone$ yields $\vb$.
\end{itemize}

\FormallyParagraph
\BackupOriginalRule{
\begin{mathpar}
\inferrule{
  \makeanonymous(\tenv, \tty) \typearrow \vtone \OrTypeError\hva\\\\
  \isbuiltinsingular(\vtone) \typearrow \vb
}{
  \issingular(\tenv, \tty) \typearrow \vb
}
\end{mathpar}
} % END_OF_BACKUP_RULE
\RenderRule{is_singular}
\CodeSubsection{\SingularBegin}{\SingularEnd}{../types.ml}

\TypingRuleDef{StructuredType}
\hypertarget{def-structuredtype}{}
A \emph{\structuredtypeterm} is any type that consists of a list of field
identifiers that denote individual storage elements.
In ASL there are three such types --- record types, collection types, and
exception types.

\RenderRelation{is_structured}

\ExampleDef{Structured Types}
In the following example, the types \texttt{SyntaxException} and \texttt{PointRecord}
are each an example of a \structuredtypeterm:
\begin{lstlisting}
type SyntaxException of exception {message: string };
type PointRecord of Record {x : real, y: real, z: real};
\end{lstlisting}

\ProseParagraph
The result $\vb$ is $\True$ if and only if $\tty$ is either a record type, a
collection type or an exception type, which is determined via the AST label of
$\tty$.

\FormallyParagraph
\BackupOriginalRule{
\begin{mathpar}
\inferrule{}{
  \isstructured(\tty) \typearrow \overname{\astlabel(\tty) \in \{\TRecord, \TException, \TCollection\}}{\vb}
}
\end{mathpar}
} % END_OF_BACKUP_RULE
\RenderRule{is_structured}
\identd{WGQS} \identd{QXYC}

\TypingRuleDef{Structure}
\RenderRelation{get_structure}

\TypingRuleRef{TypeCheckAST} ensures the absence of circular type definitions,
which ensures that \TypingRuleRef{Structure} terminates\footnote{In mathematical terms,
this ensures that \TypingRuleRef{Structure} is a proper \emph{structural induction.}}.

\ExampleDef{The Structure of a Type}
\listingref{Structure} shows examples of types and their structures.
\ASLListing{Types and their structure}{Structure}{\typingtests/TypingRule.Structure.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
\item \AllApplyCase{named}
  \begin{itemize}
  \item $\tty$ is a named type $\vx$;
  \item obtaining the declared type associated with $\vx$ in the \staticenvironmentterm{} $\tenv$ yields $\vtone$\ProseOrTypeError;
  \item obtaining the structure of $\vtone$ \staticenvironmentterm{} $\tenv$ yields $\vt$\ProseOrTypeError;
  \end{itemize}
\item \AllApplyCase{builtin\_singular}
  \begin{itemize}
  \item $\tty$ is a builtin singular type;
  \item $\vt$ is $\tty$.
  \end{itemize}
\item \AllApplyCase{tuple}
  \begin{itemize}
  \item $\tty$ is a \tupletypeterm{} with list of types $\tys$;
  \item the types in $\tys$ are indexed as $\vt_i$, for $i=1..k$;
  \item obtaining the structure of each type $\vt_i$, for $i=1..k$, in $\tys$ in the \staticenvironmentterm{} $\tenv$,
  yields $\vtp_i$\ProseOrTypeError;
  \item $\vt$ is a \tupletypeterm{} with the list of types $\vtp_i$, for $i=1..k$.
  \end{itemize}
\item \AllApplyCase{array}
  \begin{itemize}
    \item $\tty$ is an array type of length $\ve$ with element type $\vt$;
    \item obtaining the structure of $\vt$ yields $\vtone$\ProseOrTypeError;
    \item $\vt$ is an array type of length $\ve$ with element type $\vtone$.
  \end{itemize}
\item \AllApplyCase{structured}
  \begin{itemize}
  \item $\tty$ is a \structuredtypeterm\ with fields $\fields$;
  \item obtaining the structure for each type $\vt$ associated with field $\id$ yields a type $\vt_\id$\ProseOrTypeError;
  \item $\vt$ is a record, a collection or an exception, in correspondence to $\tty$, with the list of pairs $(\id, \vt\_\id)$;
  \end{itemize}
\end{itemize}

\FormallyParagraph
\BackupOriginalRule{
\begin{mathpar}
\inferrule[named]{
  \declaredtype(\tenv, \vx) \typearrow \vtone \OrTypeError\hva\\\\
  \tstruct(\tenv, \vtone)\typearrow\vt \OrTypeError
}{
  \tstruct(\tenv, \overname{\TNamed(\vx)}{\tty}) \typearrow \vt
}
\end{mathpar}

\begin{mathpar}
\inferrule[builtin\_singular]{
  \isbuiltinsingular(\tty) \typearrow \True
}{
  \tstruct(\tenv, \tty) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \tys \eqname \vt_{1..k}\\
  i=1..k: \tstruct(\tenv, \vt_i) \typearrow \vtp_i \OrTypeError
}{
  \tstruct(\tenv, \overname{\TTuple(\tys)}{\tty}) \typearrow  \TTuple(i=1..k: \vtp_i)
}
\end{mathpar}

\begin{mathpar}
\inferrule[array]{
  \tstruct(\tenv, \vt) \typearrow \vtone \OrTypeError
}{
  \tstruct(\tenv, \overname{\TArray(\ve, \vt)}{\tty}) \typearrow \TArray(\ve, \vtone)
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException, \TCollection\}\hva\\\\
  (\id,\vt) \in \fields : \tstruct(\tenv, \vt) \typearrow \vt_\id \OrTypeError
}{
  \tstruct(\tenv, \overname{L(\fields)}{\tty}) \typearrow
 L([ (\id,\vt) \in \fields : (\id,\vt_\id) ])
}
\end{mathpar}
} % END_OF_BACKUP_RULE
\RenderRule{get_structure}
\CodeSubsection{\StructureBegin}{\StructureEnd}{../types.ml}
\identd{FXQV}

\TypingRuleDef{MakeAnonymous}
\RenderRelation{make_anonymous}

\ExampleDef{The Underlying Type of a Type}
Consider the following example:
\begin{lstlisting}
type T1 of integer;
type T2 of T1;
type T3 of (integer, T2);
\end{lstlisting}

The \underlyingtypesterm\ of \texttt{integer}, \texttt{T1}, and \texttt{T2} is \texttt{integer}.

The \underlyingtypeterm{} of \texttt{(integer, T2)} and \texttt{T3} is
\texttt{(integer, T2)}.  Notice how the \underlyingtypeterm{} does not replace
\texttt{T2} with its own \underlyingtypeterm, in contrast to the \structureterm{} of
\texttt{T2}, which is \texttt{(integer, integer)}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{named}
  \begin{itemize}
    \item $\tty$ is a named type $\vx$;
    \item obtaining the type declared for $\vx$ yields $\vtone$\ProseOrTypeError;
    \item the \underlyingtypeterm\ of $\vtone$ is $\vt$.
  \end{itemize}

  \item \AllApplyCase{non-named}
  \begin{itemize}
    \item $\tty$ is not a named type $\vx$;
    \item $\vt$ is $\tty$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\BackupOriginalRule{
\begin{mathpar}
\inferrule[named]{
  \tty \eqname \TNamed(\vx) \\
  \declaredtype(\tenv, \vx) \typearrow \vtone \OrTypeError \hva\\\\
  \makeanonymous(\tenv, \vtone) \typearrow \vt
}{
  \makeanonymous(\tenv, \tty) \typearrow \vt
}
\hva\and
\inferrule[non-named]{
  \astlabel(\tty) \neq \TNamed
}{
  \makeanonymous(\tenv, \tty) \typearrow \tty
}
\end{mathpar}
} % END_OF_BACKUP_RULE
\RenderRule{make_anonymous}
\CodeSubsection{\MakeAnonymousBegin}{\MakeAnonymousEnd}{../types.ml}

\TypingRuleDef{CheckConstrainedInteger}
A type is a \emph{\constrainedintegerterm} if it is either a \wellconstrainedintegertypeterm{}
or a \parameterizedintegertypeterm.

\RenderRelation{check_constrained_integer}

\ExampleDef{Checking for Constrained Integers}
\listingref{check-constrained-integer}
shows examples of checking whether a type (used for the width of a bitvector type)
is a \constrainedintegerterm{} type.
\ASLListing{Checking for constrained integers}{check-constrained-integer}{\typingtests/TypingRule.CheckConstrainedInteger.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{well-constrained}
  \begin{itemize}
    \item $\vt$ is a well-constrained integer;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{parameterized}
  \begin{itemize}
    \item $\vt$ is a \parameterizedintegertypeterm;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{unconstrained}
  \begin{itemize}
    \item $\vt$ is an unconstrained integer or pending constrained integer;
    \item the result is a \typingerrorterm{} indicating that a constrained integer type is expected.
  \end{itemize}

  \item \AllApplyCase{conflicting\_type}
  \begin{itemize}
    \item $\vt$ is not an integer type;
    \item the result is a \typingerrorterm{} indicating the type conflict.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\BackupOriginalRule{
\begin{mathpar}
\inferrule[well-constrained]{}
{
  \checkconstrainedinteger(\tenv, \overname{\TInt(\WellConstrained(\Ignore))}{\tty}) \typearrow \True
}
\hva\and
\inferrule[parameterized]{}
{
  \checkconstrainedinteger(\tenv, \overname{\TInt(\Parameterized(\Ignore))}{\tty}) \typearrow \True
}
\hva\and
\inferrule[unconstrained]{
  \astlabel(\vc) = \Unconstrained \;\lor\; \astlabel(\vc) = \PendingConstrained
}{
  \checkconstrainedinteger(\tenv, \overname{\TInt(\vc)}{\tty}) \typearrow \TypeErrorVal{\UnexpectedType}
}
\hva\and
\inferrule[conflicting\_type]{
  \astlabel(\vt) \neq \TInt
}{
  \checkconstrainedinteger(\tenv, \vt) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
} % END_OF_BACKUP_RULE
\RenderRule{check_constrained_integer}
\CodeSubsection{\CheckConstrainedIntegerBegin}{\CheckConstrainedIntegerEnd}{../Typing.ml}
