\chapter{Dynamic Semantics Definitions\label{chap:Semantics}}

The dynamic semantics of ASL define all valid behaviors of a given ASL specification.
More precisely, an ASL specification is first parsed into an \emph{abstract syntax tree},
or AST, for short. Second, a typechecker analyzes the \emph{\untypedast} to determine whether it
is well-typed and, if successful, returns a \emph{\staticenvironmentterm{}} and a \emph{\typedast}.
Otherwise, it returns a \typingerrorterm{}.

Tools such as interpreters, Verilog simulators, and verifiers can operate over the \typedast,
based on the definition of the semantics in this reference, to test and analyze a given specification.

We note that the dynamic semantics is only used to define the set of valid behaviors
of a given specification without assigning any other quantification, such as the time
required to evaluate it.

\paragraph{Understanding the Dynamic Semantics Formalization:}
We assume basic familiarity with the ASL language constructs.
The ASL dynamic semantics is defined in terms of its AST,
and as a consequence familiarity with the AST is required to understand the semantics.
The few components of the type system needed to understand the ASL dynamic semantics are explained in context.
The mathematical background needed to understand the mathematical formalization
of the ASL dynamic semantics appears in \chapref{FormalSystem}.

\ChapterOutline
\begin{itemize}
  \item \secref{MeaningfulASLSpecifications} explains which ASL specifications that have a dynamic semantics
        assigned to them;
  \item \secref{Sequential Semantics and Dynamic Semantics} explains how this reference defines both the
        sequential semantics and concurrent semantics for ASL;
  \item \secref{Dynamic Semantics Configurations} defines the configurations used by the dynamic semantics;
  \item \secref{nativevalues} defines the concept of \nativevalues{};
  \item \secref{Semantic Evaluation} explains how the dynamic semantics rules are used to evaluate specifications; and
  \item \secref{Semantics of Diverging Specifications} defines the semantics of diverging specifications.
\end{itemize}

\section{When Do ASL Specifications Have Meaning\label{sec:MeaningfulASLSpecifications}}
The ASL dynamic semantics defined here assign meaning only to \emph{well-typed specifications}.
More specifically, the semantics is only defined for a \typedast{} produced by the typechecker
from some \untypedast{} (rather than a \typingerrorterm{}).
Specifications that are not well-typed have no defined semantics.
In the rest of this reference, we assume well-typed specifications.

ASL admits non-determinism, for example via the \ARBITRARY{} expression.
This means that a given specification might have (potentially infinitely) many
(potentially infinite) \derivationtreesterm.

An ASL specification is \emph{terminating} when \underline{all} of its \derivationtreesterm{} are finite.
An ASL specification is \emph{diverging} when \underline{some} of its \derivationtreesterm{} are
infinite.

\secref{Semantics of Diverging Specifications} explains how to interpret
the ASL dynamic semantics rules to assign meaning to both terminating specifications
and diverging specifications.

\section{Sequential Semantics and Dynamic Semantics\label{sec:Sequential Semantics and Dynamic Semantics}}
The ASL dynamic semantics are given by relations between
\hyperlink{def-configuration}{\emph{semantic configurations}}~\cite{SemanticsWithApplicationsBook}.
We refer to relations between semantic configurations as \emph{semantic relations}.
Semantic configurations encapsulate information needed to transition into other semantic configurations, such as:
\begin{itemize}
  \item a \emph{dynamic environment}, which binds variables to values;
  \item the \typedast{} node that needs to be evaluated;
  \item a \emph{concurrent execution graph}, as per a given memory model; and
  \item values resulting from evaluating expressions.
\end{itemize}
The semantic relations are constructively defined via \emph{semantic rules}.
These semantic rules are defined by induction over the typed AST.

\paragraph{Execution:}
A valid execution of an ASL specification transitions from an \emph{initial semantic configuration},
which consists of the given specification and the standard library specification, to an output semantic configuration
consisting of an output value and a concurrent execution graph.

We define two types of semantics --- \emph{sequential semantics} and \emph{concurrent semantics}.

\paragraph{Concurrent Semantics:}
The concurrent semantics operate over concurrent execution graphs.
Intuitively, these graphs define Read Effects and Write Effects to variables and constraints over those effects.
Together with the constraints that define a given memory model (such as the ARM memory model~\cite{AlglaveDGHM21}),
these graphs axiomatically define
the valid interactions of shared variables of a given specification.

\paragraph{Sequential Semantics:}
The sequential semantics correspond to executing an ASL specification in the context of a single thread
of execution; notice that ASL does not contain any concurrency constructs.
%
Technically, the sequential semantics are defined by omitting the concurrent execution graph components
from all semantic configurations.

\section{Dynamic Semantics Configurations\label{sec:Dynamic Semantics Configurations}}
This section defines the mathematical types over which our dynamic semantics are defined.
An \hyperlink{eval-example}{example} of semantic evaluation appears at the end.

Semantic configurations express intermediate states related by \emph{semantic relations}.
%
More precisely, semantic relations relate two distinct sets of semantic configurations ---
\emph{input semantic configurations} and \emph{output semantic configurations}.
Input semantic configurations consist of an environment and an AST node.
Output semantic configurations consist of an output environment, values,
and concurrent execution graphs.
%
Semantic configurations wrap together elements such as environments and AST nodes
and associate them with a \emph{configuration domain}. Input semantic configuration domains
determine the semantic relation they pertain to, while output semantic configuration
domains distinguish between conceptually different kinds of outputs, for example
ones where an exception was raised, ones when a \dynamicerrorterm{} occurred, etc.

The rest of this section defines the components comprising semantic configurations:
\begin{itemize}
    \item Native values.
    \item Static Environments, which consist of the information inferred
            by the typechecker for the specification.
    \item Dynamic Environments (\defref{dynamicenvironments}) associate \nativevalues\ to variables.
    \item Concurrent Execution Graphs (\secref{concurrentexecutiongraphs}) track Read and Write Effects over variables.
\end{itemize}

\hypertarget{def-vals}{}
\hypertarget{def-nativevalue}{}
\hypertarget{def-nativevalues}{}
\section{Native Values\label{sec:nativevalues}}
Semantic evaluation binds values to storage elements when a specification is semantically evaluated.
To formalize this, we define the set of \emph{\nativevalues}, denoted $\vals$
(\texttt{NV} stands for Native Value).

\ProseParagraph
The set of \nativevalues\ $\vals$ is the minimal set satisfying all of the following rules:
\begin{itemize}
  \item \textsc{basis set}: if $\vv$ is a literal then $\nvliteral(\vv)$ is a \nativevalue;
  \item \textsc{tuple values and array values}: if $\vl$ is a list of \nativevalues\ then $\nvvector(\vl)$ is a \nativevalue;
  \item \textsc{record values}: if $\vr$ is a finite function from identifiers to \nativevalues\ then $\nvrecord(\vr)$ is a \nativevalue.
\end{itemize}

\FormallyParagraph
\hypertarget{def-nvliteral}{}
\hypertarget{def-nvvector}{}
\hypertarget{def-nvrecord}{}
\begin{mathpar}
  \inferrule[(Basis Set: Integers, Reals, Booleans, Strings, and Bitvectors)]
  {\vv \in \literal}
  { \nvliteral(\vv) \in \vals }
  \and
  \inferrule[(Tuple Values and Array Values)]{\vvl \in \vals^*}
  { \nvvector(\vvl) \in \vals }
  \and
  \inferrule[(Record Values)]
  {\vr : \Identifiers \rightarrowfin \vals}
  { \nvrecord(\vr) \in \vals }
\end{mathpar}

We define the following shorthand notations for \nativevalue\ literals:
\hypertarget{def-nvint}{}
\[
\begin{array}{rcl}
\nvint(z)       &\triangleq& \nvliteral(\LInt(z))           \hypertarget{def-nvbool}{}\\
\nvbool(b)      &\triangleq& \nvliteral(\LBool(b))          \hypertarget{def-nvreal}{}\\
\nvreal(r)      &\triangleq& \nvliteral(\LReal(r))          \hypertarget{def-nvlabel}{}\\
\nvlabel(l)     &\triangleq& \nvliteral(\LLabel(l))         \hypertarget{def-nvstring}{}\\
\nvstring(s)    &\triangleq& \nvliteral(\LString(s))        \hypertarget{def-nvbitvector}{}\\
\nvbitvector(v) &\triangleq& \nvliteral(\LBitvector(v))\\
\end{array}
\]

We define the following types of \nativevalues:
\hypertarget{def-tint}{}
\[
\begin{array}{rcl}
  \tint       &\triangleq& \{ \nvint(z) \;|\; z \in \Z\}                                        \hypertarget{def-tbool}{}\\
  \tbool      &\triangleq& \{ \nvbool(\True), \nvbool(\False) \}                                \hypertarget{def-treal}{}\\
  \treal      &\triangleq& \{ \nvreal(r) \;|\; r \in \Q\}                                       \hypertarget{def-tstring}{}\\
  \tlabel     &\triangleq& \{ \nvlabel(l) \;|\; l \in \Identifiers\}                             \hypertarget{def-tlabel}{}\\
  \tstring    &\triangleq& \{ \nvstring(s) \;|\; s \in \Strings\}  \hypertarget{def-tbitvector}{}\\
  \tbitvector &\triangleq& \{ \nvbitvector(\textit{bits}) \;|\; \textit{bits} \in \Bit^*\}   \hypertarget{def-tvector}{}\\
  \tvector    &\triangleq& \{ \nvvector(\textit{vals}) \;|\; \textit{vals} \in \vals^*\}        \hypertarget{def-trecord}{}\\
  \trecord  &\triangleq& \{ \nvrecord(\fieldmap) \;|\; \fieldmap \in \Identifiers\rightarrowfin\vals\}\\
\end{array}
\]

\hypertarget{def-dynamicenvs}{}
\begin{definition}[Dynamic Environments\label{def:dynamicenvironments}]
A \emph{sequential dynamic environment}, or \\ \emph{dynamic environment}
$\denv \in \dynamicenvs$
consists of a \emph{dynamic global environment} and a \emph{dynamic local environment}.
\hypertarget{def-pending-calls}{}
\hypertarget{def-storage}{}
In turn, a dynamic global environment maps identifiers corresponding to global storage elements to \nativevalues\
via the $\storage$ map and identifiers corresponding to subprograms to natural numbers corresponding
to the number of calls being evaluated for those subprograms via the $\pendingcalls$ map.
The dynamic local environment maps identifiers corresponding to local storage elements to \nativevalues:
\[
\begin{array}{rcl}
\dynamicenvs        &\triangleq&  \globaldynamicenvs \times \localdynamicenvs
  \hypertarget{def-globaldynamicenvs}{}\\
\globaldynamicenvs  &\triangleq&  [\storage \mapsto (\Identifiers \partialto \vals),\; \pendingcalls \mapsto (\Identifiers \partialto \N)]
  \hypertarget{def-localdynamicenvs}{}\\
\localdynamicenvs   &\triangleq&  (\Identifiers \partialto \vals) \\
\end{array}
\]
\end{definition}

\begin{definition}[Well-formed Dynamic Environments]
A dynamic environment \\
$\denv\in\dynamicenvs$ is \emph{well-formed} if it satisfies the following invariant:
\[
\dom(G^\denv.\storage) \cap \dom(L^\denv) = \emptyset \enspace.
\]
That is, the storage elements assigned values in the local dynamic environment
and the storage elements assigned values in the global dynamic environment
are mutually exclusive.
\end{definition}
In the rest of this reference, we assume all dynamic environments
are well-formed.

\hypertarget{def-emptydenv}{}
An empty dynamic environment $\emptydenv$ is defined as follows:
\[
\emptydenv \triangleq ([\storage \mapsto \emptyfunc, \pendingcalls \mapsto \emptyfunc], \emptyfunc) \enspace.
\]

\hypertarget{def-envs}{}
\begin{definition}[Environments]
Environments pair \hyperlink{def-staticenvs}{static environments} with dynamic environments:
$\envs \triangleq \staticenvs \times \dynamicenvs$.
\end{definition}
We write $\env \in \envs$ to range over environments.
%
From the perspective of the semantics, the \staticenvironmentterm{} is immutable.
That is, all environments share the same \staticenvironmentterm{}.

\subsection{Concurrent Execution Graphs\label{sec:concurrentexecutiongraphs}}
\hypertarget{def-executiongraph}{}
The concurrent semantics of an ASL specification utilize \emph{concurrent execution graphs}
(\emph{execution graphs}, for short),
which track the Read and Write Effects over variables, yielded by the sequential semantics,
and the \emph{ordering constraints} between those effects.
The graphs resulting from executing an ASL specification are converted into
\emph{candidate execution graphs}, which are introduced, defined,
and used in~\cite{AlglaveMT14,alglave2016syntax,AlglaveDGHM21}.

\hypertarget{def-xgraphs}{}
Formally, an execution graph $\xgraph = (N^\xgraph, E^\xgraph, O^\xgraph) \in \XGraphs$
is defined via a set of \emph{nodes} ($N^\xgraph$), a set of \emph{edges} ($E^\xgraph$), and a set of \emph{output nodes} ($O^\xgraph$):
\hypertarget{def-nodes}{}
\[
\begin{array}{rcl}
\XGraphs &\triangleq& \pow{\Nodes} \times \pow{\Nodes \times \Labels \times \Nodes} \times \pow{\Nodes}  \hypertarget{def-read}{}\hypertarget{def-write}{}\\
\Nodes   &\triangleq& \N \times \{ \Read, \Write \} \times \Identifiers \hypertarget{def-labels}{}\\
\Labels  &\triangleq& \{ \asldata, \aslctrl, \aslpo \}
\end{array}
\]

Nodes represent unique Read and Write Effects. Formally, a node $(u,l,\id) \in \Nodes$ associates a unique instance counter $u$
to an \emph{ordering label} $l$, which specifies whether it represents a Read Effect of a Write Effect to a variable named $\id$.
%
We say that en Effect \texttt{E1} is \emph{$l$-before} another Effect \texttt{E2}, for $l\in \Labels$ and a given execution graph
$g$, when $(\texttt{E1}, l, \texttt{E2}) \in E^g$.

An edge represents an ordering constraint between two effects, which can be one of the following:
\hypertarget{def-asldata}{}
\begin{description}
\item[$\asldata$] Represents a \emph{data dependency}.
That is, when one effect hands over its data to another effect.
\hypertarget{def-aslctrl}{}
\item[$\aslctrl$] Represents a \emph{control dependency}.
That is, when a Read Effect to a variable determines the flow of control (e.g., which condition of a branch is taken),
which then leads to another Read/Write Effect.
\hypertarget{def-aslpo}{}
\item[$\aslpo$] Represents a \emph{program order}.
That is, when two Effects are generated by ASL constructs, which are separated by a semicolon in the text of the specification,
or appear in successive iterations of a loop unrolling.
% That is, when two effects are defined to be ordered according to the sequential semantics.
\end{description}

An execution graph is \emph{well-formed} if all nodes have unique instance counters, edges connect graph nodes,
and the output nodes are contained in the set of nodes:
\[
  \begin{array}{rcl}
  \forall n, n' \in N^\xgraph &.& n=(u,l,\id) \land n=(u',l',\id') \;\Rightarrow\; u \neq u' \\
  \forall e \in E^\xgraph &.& e=(n, n', l) \;\Rightarrow\; n, n' \in N^\xgraph \\
  & & O^\xgraph \subseteq N^\xgraph \enspace.
  \end{array}
\]
\hypertarget{def-emptygraph}{}

We denote the empty execution graph $\emptygraph \triangleq (\emptyset, \emptyset, \emptyset)$.
%
We define the following functions, which return an execution graph that represents a single Read/Write Effect to a variable \texttt{x}.
\hypertarget{def-writeeffect}{}
\hypertarget{def-readeffect}{}
\begin{definition}[Read/Write Effects]
\[
  \begin{array}{rclll}
    \WriteEffect(\vx) &\triangleq& (\{n\}, \emptyset, \{n\}) & \text{where } n=(u, \Write, \vx), & u\in\N \text{ is fresh}\\
    \ReadEffect(\vx)  &\triangleq& (\{n\}, \emptyset, \{n\}) & \text{where } n=(u, \Read, \vx),   & u\in\N \text{ is fresh}\\
  \end{array}
\]
\end{definition}

We also define two ways to compose execution graphs --- \emph{unordered composition} and
\emph{ordered composition with a given label}.

\hypertarget{def-parallel}{}
\begin{definition}[Unordered Graph Composition]
Given two execution graphs $S_1 = (N_1, E_1, O_1)$ and $S_1 = (N_2, E_2, O_2)$ their unordered composition,
denoted $S_1 \parallelcomp S_2$ is defined as follows:
\[
  S_1 \parallelcomp S_2\triangleq (N_1 \cup N_2, E_1 \cup E_2, O_1 \cup O_2) \enspace.
\]
Intuitively, this composition conveys the fact that there are no ordering constraints between the effects
in the arguments graphs.
\end{definition}

\hypertarget{def-ordered}{}
\begin{definition}[Ordered Graph Composition]
Given two execution graphs, \\ $S_1 = (N_1, E_1, O_1)$ and $S_1 = (N_2, E_2, O_2)$ and an ordering label $l$,
the ordered composition $\ordered{S_1}{l}{S_2}$ is defined as follows:
\[
  \ordered{S_1}{l}{S_2} \triangleq (N_1 \cup N_2,\ E_1 \cup E_2 \cup (O_1 \times \{l\} \times N_2),\ O_2) \enspace.
\]
Intuitively, this composition constrains the output effects of $S_1$ to appear before any effect of $S_2$ with respect
to the given ordering label.
\end{definition}

\subsection{Concurrent Values\label{sec:ConcurrentValues}}
\hypertarget{def-concurrentnativevalue}{}
The ASL dynamic semantics operate over pairs consisting of \nativevalues\ and \executiongraphs,
which we refer to as \concurrentnativevalues.

\subsection{Kinds of Semantic Configurations\label{sec:KindsOfSemanticConfigurations}}

Recall that the ASL dynamic semantics define a relation between input semantic configurations and output semantic configurations.
Input semantic configuration domains are unique to the semantic relation that employs them.
For that reason, we name semantic relations by the name of the corresponding configuration domain of the input semantic configuration.
For example, the semantic relation that employs input semantic configurations with the domain $\evalexpr$
is named $\evalexpr$.
%
We will often use the prefix \texttt{eval} for semantic relations with the intuition being that their input semantic configurations
should be semantically evaluated, yielding an output semantic configuration.

ASL dynamic semantics mainly utilize the following types of output semantic configurations:
\begin{description}
  \item[Normal Values.]\hypertarget{def-normal}{}
  Semantic configurations consisting of different combinations of values,
  execution graphs, and environments. These represent intermediate results
  generated while evaluating various constructs such as
  expressions, side-effect-free expressions, \assignableexpressions,
  local declaration items, slices, and expression lists
  (which are evaluated in two different ways for the purpose of concurrency):
  \begin{itemize}
  \item $\ResultExpr((\vals \times \XGraphs), \envs)$,
  \item $\ResultExprSEF(\vals, \XGraphs)$,
  \item $\ResultLexpr(\XGraphs, \envs)$,
  \item $\ResultLDI(\XGraphs, \envs)$,
  \item $\ResultSlices(((\vals \times \vals)^* \times \XGraphs))$,
  \item $\ResultExprList((\vals^* \times \XGraphs), \envs)$,
  \item $\ResultExprListM((\vals\times\XGraphs)^*, \envs)$,
  \end{itemize}

  \hypertarget{def-throwing}{}
  \item[Exceptions.] Semantic configurations in
  \[
    \Throwing(\valuereadfrom(\vals,\Identifiers) \times \ty \times \XGraphs \times \envs)
  \]
  represent thrown exceptions.
  \hypertarget{def-valuereadfrom}{}

  There are two flavors of exceptions:
  exceptions without an exception value (as in \texttt{throw;}), and ones with an exception value,
  an identifier to which the Read Effect is attributed, and an associated type.
  The type $\valuereadfrom(\vals,\Identifiers)$ is a semantic configuration nested inside an exception semantic configuration.
  The ASL dynamic semantics propagate these \emph{exceptional semantic configurations} to the nearest catch clause that matches
  them, and otherwise they are caught at the top-level and reported as errors (see \dynamicerrorsterm{} below).

  \hypertarget{def-returning}{}
  \item[Returned Values.] Semantic configurations in $\Returning((\vals^* \times \XGraphs), \envs)$
  represent (tuples of) values being returned by the currently executing subprogram.
  The ASL dynamic semantics propagate these \emph{early return semantic configurations} to the respective call expression/statement.

  \hypertarget{def-continuing}{}
  \item[In-flight Subprogram.] Semantic configurations in $\Continuing(\XGraphs, \envs)$
  represent the fact that a subprogram has more statements to execute.
  The ASL dynamic semantics treat these semantic configurations as a signal to keep evaluating the remainder
  of the subprogram currently being evaluated.

  \hypertarget{def-error}{}
  \item[Dynamic Errors.] Semantic configurations in $\DynamicError(\Strings)$
  represent \dynamicerrorsterm{} (for example, division by zero).
  The ASL dynamic semantics are set up such that when these \emph{error semantic configurations} appear,
  the evaluation of the entire specification terminates by outputting them.

  \hypertarget{def-diverging}{}
  \item[Diverging Configurations.] The semantic configuration $\Diverging$
  represents a diverging evaluation.
\end{description}
Helper relations often have output semantic configurations that are just tuples, without an associated configuration domain.

We define the following shorthand notations for types of output semantic configurations:
\hypertarget{def-tnormal}{}
\hypertarget{def-resultexpr}{}
\hypertarget{def-resultexprlist}{}
\hypertarget{def-resultexprlistm}{}
\hypertarget{def-resultexprsef}{}
\hypertarget{def-resultlexpr}{}
\hypertarget{def-resultslices}{}
\hypertarget{def-resultpattern}{}
\hypertarget{def-resultldi}{}
\hypertarget{def-resultsubprogram}{}
\hypertarget{def-resultcall}{}
\hypertarget{def-tcontinuing}{}
\hypertarget{def-tthrowing}{}
\hypertarget{def-treturning}{}
\hypertarget{def-tdynerror}{}
\hypertarget{def-tdiverging}{}
\[
  \begin{array}{rcll}
    \TNormal          & \triangleq & \ResultExpr((\vals \times \XGraphs), \envs)\  & \cup \\
                      &            & \ResultExprSEF(\vals, \XGraphs)  & \cup \\
                      &            & \ResultLexpr(\XGraphs, \envs) & \cup\\
                      &            & \ResultLDI(\XGraphs, \envs)  & \cup \\
                      &            & \ResultSlices(((\vals \times \vals)^* \times \XGraphs), \envs) &  \cup\\
                      &            & \ResultExprList((\vals^* \times \XGraphs), \envs)  & \cup \\
                      &            & \ResultExprListM((\vals\times\XGraphs)^*, \envs) & \\
    \TThrowing        & \triangleq & \Throwing(\vals \times \ty \times \XGraphs \times \envs) &\\
    \TContinuing      & \triangleq & \Continuing(\XGraphs, \envs) &\\
    \TReturning       & \triangleq & \Returning((\vals^* \times \XGraphs), \envs) &\\
    \TDynError        & \triangleq & \DynamicError(\Strings) &\\
    \TDiverging       & \triangleq & \{ \Diverging \}&\\
  \end{array}
\]

We will say that a semantic transition
\begin{itemize}
\item \emph{terminates normally} when the output semantic configuration is a member of \\
      $\TNormal$,
\item \emph{terminates exceptionally} when the output semantic configuration is a member of $\TThrowing$,
\item \emph{terminates erroneously} when the output semantic configuration is a member of $\TDynError$,
\item \emph{diverges} when the output semantic configuration is a member of $\TDiverging$,
\item is \emph{abnormal} when it either terminates exceptionally, terminates erroneously, or diverges.
\end{itemize}

We introduce the following shorthand notations for semantic configurations where all variables
appearing are \hyperlink{def-freshvariables}{fresh}:
\begin{itemize}
\hypertarget{def-throwingconfig}{}
\item $\ThrowingConfig \triangleq \Throwing(\vv, \vt, \vg, \newenv)$.
      \hypertarget{def-errorconfig}{}
\item $\DynErrorConfig \triangleq \DynamicError(\vs)$.
      \hypertarget{def-returningconfig}{}
\item $\ReturningConfig \triangleq \Returning((\vvs,\newg), \newenv)$
      is an early return semantic configuration.
\hypertarget{def-continuingconfig}{}
\item $\ContinuingConfig \triangleq \Continuing(\newg, \newenv)$.
      \hypertarget{def-divergingconfig}{}
\item $\DivergingConfig \triangleq \Diverging$ is a diverging configuration.
\end{itemize}

\subsection{Extracting and Substituting Elements of Semantic configurations}

\hypertarget{def-graphof}{}
\hypertarget{def-environof}{}
Given a semantic configuration $C$, we define the graph component of the semantic configuration, \\
$\graphof{C}$, and the environment of the semantic configuration, $\environof{C}$, as follows:
\[
\begin{array}{lcc}
  C & \graphof{C} & \environof{C}\\
  \hline
  \ResultExpr((\vv, \vg), \env) & \vg & \env\\
  \ResultExprSEF(\vv, \vg) & \vg & \text{undefined}\\
  \ResultLexpr(\vg, \env) & \vg & \env \\
  \ResultLDI(\vg, \env) & \vg & \env \\
  \ResultSlices(([i=1..k: (\va_i,\vb)], \vg), \env) & \vg & \env \\
  \ResultExprList(([i=1..k: \vv_i], \vg), \env) & \vg & \env \\
  \ResultExprListM([i=1..k: (\vv_i,\vg_i)], \env) & \text{undefined} & \env\\
  \Throwing(\valuereadfrom(\vx,\vv),\vt,\vg, \env) & \vg & \env\\
  \Returning(([\vv_{1..k}],\vg), \env) & \vg & \env\\
  \Continuing(\vg, \env) & \vg & \env\\
  \DynamicError(\vs) & \text{undefined} & \text{undefined}\\
  \Diverging & \text{undefined} & \text{undefined}\\
\end{array}
\]

\hypertarget{def-withgraph}{}
Given a semantic configuration $C$, we define $\withgraph{C}{\vgp}$ to be a semantic configuration
like $C$ where the graph component is substituted with $\vgp$:
\[
\begin{array}{ll}
  C & \withgraph{C}{\vgp}\\
  \hline
  \ResultExpr((\vv, \vg), \env) & \ResultExpr((\vv, \vgp), \env)\\
  \ResultExprSEF(\vv, \vg) & \ResultExprSEF(\vv, \vgp)\\
  \ResultLexpr(\vg, \env) & \ResultLexpr(\vgp, \env)\\
  \ResultLDI(\vg, \env) & \ResultLDI(\vgp, \env)\\
  \ResultSlices(([i=1..k: (\va_i,\vb)], \vg), \env) & \ResultSlices(([i=1..k: (\va_i,\vb)], \vgp), \env)\\
  \ResultExprList(([i=1..k: \vv_i], \vg), \env) & \ResultExprList(([i=1..k: \vv_i], \vgp), \env)\\
  \ResultExprListM([i=1..k: (\vv_i,\vg_i)], \env) & \text{undefined}\\
  \Throwing(\valuereadfrom(\vx,\vv),\vt,\vg, \env) & \Throwing(\valuereadfrom(\vx,\vv),\vt,\vgp, \env)\\
  \Returning((i=1..k: \vv_i,\vg), \env) & \Returning((i=1..k: \vv_i,\vgp), \env)\\
  \Continuing(\vg, \env) & \Continuing(\vgp, \env)\\
  \DynamicError(\vs) & \text{undefined}\\
  \Diverging & \text{undefined} \\
\end{array}
\]

\hypertarget{def-withenviron}{}
Similarly, we define the $\withenviron{C}{\envp}$ to be a semantic configuration
like $C$ where the environment component, if one exists, is substituted with $\envp$:
\[
\begin{array}{ll}
  \textbf{Semantic configuration} & \withenviron{C}{\envp}\\
  \hline
  \ResultExpr((\vv, \vg), \env) & \ResultExpr((\vv, \vg), \envp)\\
  \ResultExprSEF(\vv, \vg) & \text{undefined}\\
  \ResultLexpr(\vg, \env) & \ResultLexpr(\vg, \envp)\\
  \ResultLDI(\vg, \env) & \ResultLDI(\vg, \envp)\\
  \ResultSlices(([i=1..k: (\va_i,\vb)], \vg), \env) & \ResultSlices(([i=1..k: (\va_i,\vb)], \vg), \envp)\\
  \ResultExprList(([i=1..k: \vv_i], \vg), \env) & \ResultExprList(([i=1..k: \vv_i], \vg), \envp)\\
  \ResultExprListM([i=1..k: (\vv_i,\vg_i)], \env) & \ResultExprListM([i=1..k: (\vv_i,\vg_i)], \envp)\\
  \Throwing(\valuereadfrom(\vx,\vv),\vt,\vg, \env) & \Throwing(\valuereadfrom(\vx,\vv),\vt,\vg, \envp)\\
  \Returning((i=1..k: \vv_i,\vg), \env) & \Returning((i=1..k: \vv_i,\vg), \envp)\\
  \Continuing(\vg, \env) & \Continuing(\vg, \envp)\\
  \DynamicError(\vs) & \text{undefined}\\
  \Diverging & \text{undefined} \\
\end{array}
\]

\section{Semantic Evaluation\label{sec:Semantic Evaluation}}
\hypertarget{def-evalrel}{}
The semantics of ASL is given by the relation\footnote{The reason that a relation, rather than a function, is used is due to
the non-determinism inherent in the \ARBITRARY{} expression.}
\evalrel.
The relation \evalrel\ is defined as the disjoint union of the relations defined in this reference:
$\evalexpr$, $\evalstmt$, etc.

\subsection{Natural Operational Semantics}
We define the ASL dynamic semantics in the style of \emph{natural operational semantics}~\cite{SemanticsWithApplicationsBook}
(also known as \emph{big step semantics}).
Natural operational semantics evaluates the AST inductively.
That is, it concludes transitions for semantic configurations starting from
non-leaf AST nodes by concluding transitions from semantic configurations starting from their children nodes.

\subsubsection{No Undefined Behaviors}
When an input semantic configuration does not satisfy any semantic rule,
there is no output semantic configuration for it to transition to. We say that
the semantic configuration is \emph{stuck} and the ASL dynamic semantics are undefined for that
input semantic configuration.

The ASL dynamic semantics are defined for well-typed ASL specifications
and gets stuck only in cases of diverging specifications
(due to diverging loops, or infinite recursion).
Otherwise, for every input semantic configuration there is at least one rule that can be used to take a semantic transition.

\hypertarget{eval-example}{}
\subsubsection{Evaluation Example}
The following example shows how to utilize the rules for expression literals and binary operator expressions
to derive a transition from an input semantic configuration with the expression $(1+2)*(4+5)$,
given by the AST
\[
  \begin{array}{rl}
  \EBinop(\MUL, &\overname{\EBinop(\PLUS, \overname{\elint{1}}{\veone}, \overname{\elint{2}}{\vetwo})}{\veonetwo}, \\
                &\overname{\EBinop(\PLUS, \overname{\elint{4}}{\vefour}, \overname{\elint{5}}{\vefive})}{\vefourfive})
  \end{array}
\]
to an output semantic configuration with the value resulting from the calculation of the expression.

We annotate subexpressions to allow referring to them.

\hypertarget{def-emptyenv}{}
We define the empty environment $\emptyenv$ as $(\emptydenv, \emptytenv)$.

Notice that, we have dropped the execution graph component and simplified pairs of the form $(\vv,\vg)$,
where $\vv$ is a \nativevalue\  and $\vg$ is an execution graph, to just $\vv$.
This is because we are interested in demonstrating the sequential semantics (also, the execution graphs
in this case are all empty).

The example shows (using references to the relevant rules on the right), how the expression for $1+2$ is evaluated
using the rule for literal expressions, the rule for binary operator (for addition), and the rules for \binopexpressionsterm{}.
Similarly, the expression for $4+5$ is evaluated.
Finally, the transitions for both of the subexpressions are used as premises for the \binopexpressionterm{}
rule, along with the rule for binary operator (for multiplication), to evaluate the entire expression.

\begin{mathpar}
\inferrule*[right=\ref{sec:SemanticsRule.Binop}]{
  \inferrule*[right=\ref{sec:SemanticsRule.ELit}]{}{ \evalexpr(\emptyenv, \veone) \evalarrow \ResultExpr(\nvint(1), \emptyenv) } \\\\
  \inferrule*[right=\ref{sec:SemanticsRule.ELit}]{}{ \evalexpr(\emptyenv, \vetwo) \evalarrow \ResultExpr(\nvint(2), \emptyenv) } \\\\
  \inferrule*[right=\ref{sec:SemanticsRule.BinopValues}]{}{\binoprel(\PLUS, \nvint(1), \nvint(2)) \evalarrow \nvint(3)}
}{
  \evalexpr( \emptyenv, \veonetwo ) \evalarrow
  \ResultExpr(\nvint(3), \emptyenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule*[right=\ref{sec:SemanticsRule.Binop}]{
  \inferrule*[right=\ref{sec:SemanticsRule.ELit}]{}{ \evalexpr(\emptyenv, \vefour) \evalarrow \ResultExpr(\nvint(4), \emptyenv) } \\\\
  \inferrule*[right=\ref{sec:SemanticsRule.ELit}]{}{ \evalexpr(\emptyenv, \vefive) \evalarrow \ResultExpr(\nvint(5), \emptyenv) } \\\\
  \inferrule*[right=\ref{sec:SemanticsRule.BinopValues}]{}{\binoprel(\PLUS, \nvint(4), \nvint(5)) \evalarrow \nvint(9)}
}{
  \evalexpr( \emptyenv, \vefourfive ) \evalarrow
  \ResultExpr(\nvint(9), \emptyenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule*[right=\ref{sec:SemanticsRule.Binop}]{
  \evalexpr( \emptyenv, \veonetwo ) \evalarrow \ResultExpr(\nvint(3), \emptyenv)\\
  \evalexpr( \emptyenv, \vefourfive ) \evalarrow \ResultExpr(\nvint(9), \emptyenv)\\
  \inferrule*[right=\ref{sec:SemanticsRule.BinopValues}]{}{\binoprel(\MUL, \nvint(3), \nvint(9)) \evalarrow \nvint(27)}
}{
  \evalexpr( \emptyenv, \EBinop(\MUL, \veonetwo, \vefourfive) ) \evalarrow
  \ResultExpr(\nvint(27), \emptyenv)
}
\end{mathpar}

\subsection{Evaluation Order\label{sec:EvaluationOrder}}
ASL specifies an evaluation order to ensure predictability of side-effects and exceptions.
In particular, semantic rules use \shortcircuitrulemacros{} to
impose an ordering on premises and their associated side-effects, errors, and exceptions.
Further, the threading through of environments similarly impose an ordering.

For example, \SemanticsRuleRef{ECond} is duplicated below:
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\mcond, \envone) \OrAbnormal\\\\
  \mcond \eqname (\nvbool(\vb), \vgone)\\
  \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\\\
  \evalexpr(\envone, \vep) \evalarrow \ResultExpr((\vv, \vgtwo), \newenv)  \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
}{
  \evalexpr(\env, \overname{\ECond(\econd, \veone, \vetwo)}{\ve}) \evalarrow
  \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
The use of $\OrAbnormal$ rule macros here define an evaluation order:
$\econd$ must be evaluated first, then exactly one of $\veone$ or $\vetwo$.
This order is also reflected by the fact that evaluation of the conditional
expression produces the environment $\envone$, which is then used to evaluate
the chosen expression $\vep$.

For most ASL constructs, there is only one evaluation order that makes sense for the intended purpose of the construct.
In the example above, it is not feasible to evaluate $\veone$ before evaluating $\econd$.
However, some ASL constructs could feasibly be evaluated in different ways.
These are:
\begin{itemize}
  \item arguments and parameters to a function call (\SemanticsRuleRef{ECall} and \SemanticsRuleRef{SCall});
  \item tuple expressions (\SemanticsRuleRef{ETuple} and \SemanticsRuleRef{LEDestructuring});
  \item non-short-circuiting binary operations (\SemanticsRuleRef{Binop});
  \item array-indexing (\SemanticsRuleRef{EGetArray}, \SemanticsRuleRef{EGetEnumArray}) --- in particular, for \verb|arr[[idx]]| whether \verb|arr| or \verb|idx| is evaluated first;
  \item slicing expressions (\SemanticsRuleRef{ESlice} and \SemanticsRuleRef{LESlice});
  \item record construction expressions (\SemanticsRuleRef{ERecord});
  \item arguments to \verb|print| and \verb|println| (\SemanticsRuleRef{SPrint});
  \item for-loop start/end expressions (\SemanticsRuleRef{SFor}).
\end{itemize}

For these constructs, ASL defines an evaluation order.
When there are multiple feasible choices for the next evaluation transition, ASL is defined to take the syntactically leftmost transition.
This applies \underline{only} when there are multiple feasible choices.
For example, assignment statements (\secref{AssignmentStatements}) must still evaluate their right-hand side before considering their left-hand side, as the evaluation transition for left-hand sides requires the right-hand side value (\chapref{AssignableExpressions}).

\ConventionDef{EvaluationOrderIndependence}
To assist reliable translation of ASL to other representations that may not specify an evaluation order, implementations may choose to enforce independence from evaluation order using a conservative static analysis that warns users of possibly conflicting side-effects which may affect behaviour if reordered.
An initial prototype of such an analysis can be found in \href{https://github.com/herd/herdtools7/blob/\VERSION/asllib/SideEffect.ml}{ASLRef}.

\ExampleDef{Evaluation order}
\listingref{evaluation-order} shows examples of the constructs above, followed by output to the console from running the specification.
\textbf{Note:} the ordering for slicing expressions may, at first glance, seem not to follow the evaluation order specification; this is because some forms of slice are elaborated during typechecking (see \TypingRuleRef{Slice}).
\ASLListing{Evaluation order}{evaluation-order}{\definitiontests/EvaluationOrder.asl}
% CONSOLE_BEGIN aslref \definitiontests/EvaluationOrder.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
Function calls:
1234
Tuples:
12
Non-short-circuiting binary operations:
123
Array-indexing:
1
2
Record construction:
12
Print statements:
12341234
\end{Verbatim}
% CONSOLE_END

\section{Semantics of Diverging Specifications\label{sec:Semantics of Diverging Specifications}}
While typical specifications are intended to always terminate,
diverging specifications can be potentially useful.
For example, simulating the fetch-decode-execute cycle of a given processor,
which may look like the following partial specification:
\begin{lstlisting}
func main() => integer
begin
  while !stop_condition() do
    let instr = fetch_next_instruction();
    decode_and_execute(instr);
  end;
  return error_code;
end;
\end{lstlisting}

\subsection{The Big-step Semantics of ASL}

\begin{definition}[ASL Big-step Rules]
The \emph{big-step semantics}\cite{SemanticsWithApplicationsBook} of terminating evaluations and diverging evaluations
is given by two disjoint sets of rules:
\begin{description}
  \item[Inductive Rules] The set of \emph{inductive rules} are all dynamic semantics
        rules that do not include configurations in $\TDiverging$; and
  \item[Co-inductive Rules] The set of \emph{co-inductive rules}~\cite{LeroyG:IC09}
       are all dynamic semantics rules whose output configurations are in $\TDiverging$.
       Co-inductive rules have the property that, considering the list of premises that
       are transition judgments, the last, and only the last one has an output configuration in $\TDiverging$.
       This is ensured by the placement of $\DivergingConfig$ as short-circuiting alternatives
       in macro rules.
\end{description}
\end{definition}

As an example of an inductive rule, consider the following rule,
obtained by expanding the macro rule for \SemanticsRuleRef{Loop}.CONTINUE:
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\condm, \envone)\\
  \condm \eqname (\nvbool(\vb), \vgone)\\
  \vb = \iswhile\\
  \ticklooplimit(\vlimitopt) \evalarrow \vlimitoptp\\
  \evalblock(\envone, \vbody) \evalarrow \Continuing(\vgtwo, \envtwo)\\
  \evalloop(\envtwo, \iswhile, \vlimitoptp, \econd, \vbody) \evalarrow \Continuing(\vgthree, \newenv)\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslctrl}{\vgtwo}}{\aslpo}{\vgthree}
}{
  \evalloop(\env, \iswhile, \vlimitopt, \econd, \vbody) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

As an example of a co-inductive rule, consider the following expansion
for the same macro rule:
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\condm, \envone)\\
  \condm \eqname (\nvbool(\vb), \vgone)\\
  \vb = \iswhile\\
  \ticklooplimit(\vlimitopt) \evalarrow \vlimitoptp\\
  \evalblock(\envone, \vbody) \evalarrow \Continuing(\vgtwo, \envtwo)\\
  \evalloop(\envtwo, \iswhile, \vlimitoptp, \econd, \vbody) \evalarrow \DivergingConfig\\
  \newg \eqdef \ordered{\ordered{\vgone}{\aslctrl}{\vgtwo}}{\aslpo}{\vgthree}
}{
  \evalloop(\env, \iswhile, \vlimitopt, \econd, \vbody) \evalarrow \DivergingConfig
}
\end{mathpar}

\begin{definition}[Meaning of ASL Big-step Rules]
We say that a judgment\\
$g = C \evalarrow D$ holds if and only if one of the following applies:
\begin{itemize}
  \item $D\not\in\TDiverging$ and there exists a \underline{finite} \derivationtreeterm{}
        with root $g$, consisting of only inductive rules; or
  \item $D\in\TDiverging$ and there exists an \underline{infinite} \derivationtreeterm{}
        with root $g$, consisting of both inductive rules and co-inductive rules.
\end{itemize}
\end{definition}

\ExampleDef{Diverging Evaluation of a Loop}

To exemplify a diverging evaluation, consider the sequential semantics
of the statement \verb|while TRUE do pass; end;| evaluated with
an environment $\env$.
The infinite \derivationtreeterm{} consists of vertices
\[
\{S_1, L_1, V_1\} \cup \{n \geq 2 \;|\; E_n, B_n, T_n, P_n, Q_n\} \enspace,
\]
which we use to annotate the vertices of the \derivationtreeterm{} defined below
(we inline aliasing equalities and deconstructing equalities,
leaving only asserting equalities and transitions, to simplify the presentation).

The root of the infinite \derivationtreeterm{} is the following one:
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rc}
  L_1:& \evallimit(\env, \None) \evalarrow \None\\
  V_1:& \evalloop(\env, \True, \None, \ETrue, \SPass) \evalarrow \Diverging
  \end{array}
  }
}{
  S_1: \evalstmt(\env, \SWhile(\ETrue, \None, \SPass)) \evalarrow \Diverging
}
\end{mathpar}

and the rest of the \derivationtreeterm{} is given as:
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rc}
  E_{n+1}:& \evalexpr(\env, \ETrue) \evalarrow \ResultExpr(\nvbool(\vb), \env)\\
  B_{n+1}:& \vb = \True\\
  T_{n+1}:& \ticklooplimit(\None) \evalarrow \None\\
          & \left(\inferrule{Q_{n+1}:\evalstmt(\env, \SPass)\evalarrow \Continuing(\env)}{P_{n+1}: \evalblock(\env, \SPass) \evalarrow \Continuing(\env)}\right)\\
  V_{n+1}:& \evalloop(\env, \True, \None, \ETrue, \SPass) \evalarrow \Diverging
  \end{array}
  }
}{
  V_n: \evalloop(\env, \True, \None, \ETrue, \SPass) \evalarrow \Diverging
}
\end{mathpar}

That is, the premise $V_{n+1}$ is given by copying the same sub-tree as above for each $n\geq 2$,
which visually looks like the following:
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rc}
  E_{n+1}:& \evalexpr(\env, \ETrue) \evalarrow \ResultExpr(\nvbool(\vb), \env)\\
  B_{n+1}:& \vb = \True\\
  T_{n+1}:& \ticklooplimit(\None) \evalarrow \None\\
  & \left(\inferrule{Q_{n+1}:\evalstmt(\env, \SPass)\evalarrow \Continuing(\env)}{P_{n+1}: \evalblock(\env, \SPass) \evalarrow \Continuing(\env)}\right)\\
  &
  \left(
  \inferrule{
    E_{n+2}\\ B_{n+2}\\ T_{n+2}\\ P_{n+2}\\ V_{n+2}\\ \inferrule{\vdots}{V_{n+2}}
  }{
    V_{n+1}: \evalloop(\env, \True, \None, \ETrue, \SPass) \evalarrow \Diverging
  }
  \right)
  \end{array}
  }
}{
  V_n: \evalloop(\env, \True, \None, \ETrue, \SPass) \evalarrow \Diverging
}
\end{mathpar}
