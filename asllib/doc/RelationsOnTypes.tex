\section{Relations Over Types\label{sec:RelationsOnTypes}}

This section defines the following relations over types and operators:
\begin{itemize}
  \item Subtype (\TypingRuleRef{Subtype})
  \item Subtype Satisfaction (\TypingRuleRef{SubtypeSatisfaction})
  \item Type Satisfaction (\TypingRuleRef{TypeSatisfaction})
  \item The Lowest Common Ancestor of two types (\TypingRuleRef{LowestCommonAncestor})
  \item Applying a unary operator to a type (\TypingRuleRef{ApplyUnopType})
  \item Applying a binary operator to a pair of types (\TypingRuleRef{ApplyBinopTypes})
\end{itemize}

\TypingRuleDef{Subtype}
\hypertarget{def-supertypeterm}{}
The \emph{\subtypeterm} relation is a partial order over \underline{named types}.
The \emph{\supertypeterm} is the inverse relation.
That is, \tty\ is a \supertypeterm{} of \tsy\ if and only if \tsy\ is a \subtypeterm{} of \tty.

\ExampleDef{Subtypes and Supertypes}
The following table determines whether the type \vAbf{}
subtypes the type \vBbf{} with respect to the types
declared in \listingref{subtype}:\\
\begin{tabular}{llll}
  \textbf{type A} & \textbf{type B}   & \textbf{subtypes?}  & \textbf{reason}\\
\hline
  \texttt{subInt}     & \texttt{subInt}   & yes             & subtyping is reflexive for \namedtypesterm{}\\
  \texttt{subInt}     & \texttt{superInt} & yes             & declared as a \subtypeterm{}\\
  \texttt{superInt}   & \texttt{subInt}   & no              & subtyping is anti-symmetric\\
  \texttt{subsubInt}  & \texttt{superInt} & yes             & subtyping is transitive\\
  \texttt{otherInt}   & \texttt{superInt} & no              & no chain of subtyping between the types\\
  \texttt{superInt}   & \texttt{integer}  & no              & \texttt{integer} is not a \namedtypeterm{}\\
  \texttt{integer}    & \texttt{integer}  & no              & \texttt{integer} is not a \namedtypeterm{}\\
\end{tabular}

\ASLListing{Subtypes and Supertypes}{subtype}{\typingtests/TypingRule.Subtype.asl}

\RenderRelation{is_subtype}
\BackupOriginalRelation{
The predicate
\[
  \issubtype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\Bool}{\vb}
\]
defines whether the type $\vtone$ subtypes the type $\vttwo$ in the \staticenvironmentterm{} $\tenv$,
yielding the result in $\vb$.
} % END_OF_BACKUP_RELATION

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{reflexive}
  \begin{itemize}
    \item $\vtone$ and $\vttwo$ are both the same named type;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{transitive}
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the \globalstaticenvironmentterm{} maintains that $\idone$ is a subtype of $\idthree$;
    \item testing whether the type named $\idthree$ is a subtype of $\vttwo$ in the \staticenvironmentterm{} $\tenv$
    gives $\vb$.
  \end{itemize}

  \item \AllApplyCase{no\_supertype}
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the \globalstaticenvironmentterm{} maintains that $\idone$ does subtype any named type;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item \AllApplyCase{not\_named}
  \begin{itemize}
    \item at least one of $\vtone$ and $\vttwo$ is not a named type;
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[reflexive]{}{
  \issubtype(\tenv, \overname{\TNamed(\id)}{\vtone}, \overname{\TNamed(\id)}{\vttwo}) \typearrow \True
}
\and
\inferrule[transitive]{
  \idone \neq \idtwo\\
  G^\tenv.\subtypes(\idone) = \idthree\\
  \issubtype(\tenv, \TNamed(\idthree), \vttwo) \typearrow \vb
}{
  \issubtype(\tenv, \overname{\TNamed(\idone)}{\vtone}, \overname{\TNamed(\idtwo)}{\vttwo}) \typearrow \vb
}
\and
\inferrule[no\_supertype]{
  \idone \neq \idtwo\\
  G^\tenv.\subtypes(\idone) = \bot
}{
  \issubtype(\tenv, \overname{\TNamed(\idone)}{\vtone}, \overname{\TNamed(\idtwo)}{\vttwo}) \typearrow \False
}
\and
\inferrule[not\_named]{
  (\astlabel(\vtone) \neq \TNamed \lor \astlabel(\vttwo) \neq \TNamed)
}{
  \issubtype(\tenv, \vtone, \vttwo) \typearrow \False
}
\end{mathpar}
\CodeSubsection{\SubtypeBegin}{\SubtypeEnd}{../types.ml}

\identr{NXRX} \identi{KGKS} \identi{MTML} \identi{JVRM} \identi{CHMP}

\TypingRuleDef{SubtypeSatisfaction}
\RenderRelation{subtype_satisfies}
\BackupOriginalRelation{
The predicate
\[
  \subtypesatisfies(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
determines whether a type $\vt$ \emph{subtype-satisfies} a type $\vs$ in environment $\tenv$,
returning the result in $\vb$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

This function assumes that both $\vt$ and $\vs$ are well-typed according to \chapref{Types}.

\ExampleDef{Subtype Satisfaction}
\listingref{subtypesat1} shows examples
where the types of the \rhsexpressions{} \subtypesatisfyterm{}
the types of the left-hand-side expressions.
\pagebreak
\ASLListing{Subtype Satisfaction}{subtypesat1}{\typingtests/TypingRule.SubtypeSatisfaction1.asl}

\listingref{subtypesat-bad1} and \listingref{subtypesat-bad2}
shows examples of nuanced \typingerrorsterm.
Specifically where a type consisting of a range of values does not \subtypesatisfyterm{}
a type consisting of one variable expression.
\ASLListing{Subtype satisfaction error 1}{subtypesat-bad1}{\typingtests/TypingRule.SubtypeSatisfaction.bad1.asl}
\ASLListing{Subtype satisfaction error 2}{subtypesat-bad2}{\typingtests/TypingRule.SubtypeSatisfaction.bad2.asl}

\listingref{subtypesat2} shows examples of legal and illegal assignments involving
subtyping.
\ASLListing{More Examples of subtype satisfaction}{subtypesat2}{\typingtests/TypingRule.SubtypeSatisfaction2.asl}

\listingref{subtypesat3} shows more examples of legal and illegal assignments involving
subtyping.
\ASLListing{Even more examples of subtype satisfaction}{subtypesat3}{\typingtests/TypingRule.SubtypeSatisfaction3.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
\item \AllApplyCase{error1}
  \begin{itemize}
  \item obtaining the \underlyingtypeterm\ of $\vt$ gives a \typingerrorterm{};
  \item the rule results in a \typingerrorterm{}.
  \end{itemize}

\item \AllApplyCase{error2}
  \begin{itemize}
    \item obtaining the \underlyingtypeterm\ of $\vt$ gives a type $\vttwo$;
    \item obtaining the \underlyingtypeterm\ of $\vs$ gives a \typingerrorterm{};
    \item the rule results in a \typingerrorterm{}.
    \end{itemize}

\item \AllApplyCase{different\_labels}
  \begin{itemize}
  \item the underlying types of $\vt$ and $\vs$ have different AST labels
  (for example, $\TInt$ and $\TReal$);
  \item $\vb$ is $\False$.
  \end{itemize}

\item \AllApplyCase{simple}
  \begin{itemize}
  \item the \underlyingtypeterm\ of $\vt$, $\vttwo$, is either \realtypeterm{}, \stringtypeterm{}, or \booleantypeterm{};
  \item the \underlyingtypeterm\ of $\vs$, $\vstwo$, is either \realtypeterm{}, \stringtypeterm{}, or \booleantypeterm{};
  \item $\vb$ is $\True$ if and only if both $\vttwo$ and $\vstwo$ have the same ASL label.
  \end{itemize}

\item \AllApplyCase{t\_int}
  \begin{itemize}
  \item the \underlyingtypeterm\ of $\vt$, $\vttwo$, is an \integertypeterm{} (any kind);
  \item the \underlyingtypeterm\ of $\vs$, $\vstwo$, is an \integertypeterm{} (any kind);
  \item applying $\symdomoftype$ to $\tenv$ and $\vs$ yields the \symbolicdomainterm{} $\ds$;
  \item applying $\symdomoftype$ to $\tenv$ and $\vt$ yields the \symbolicdomainterm{} $\dt$;
  \item applying $\symdomsubsetunions$ to $\tenv$, $\ds$, and $\dt$ yields $\vb$.
  \end{itemize}

\item \AllApplyCase{t\_enum}
  \begin{itemize}
  \item the \underlyingtypeterm\ of $\vt$ is an \enumerationtypeterm{} with list of labels $\vlit$, that is, $\TEnum(\vlit)$;
  \item the \underlyingtypeterm\ of $\vs$ is an \enumerationtypeterm{} with list of labels $\vlis$, that is, $\TEnum(\vlis)$;
  \item $\vb$ is $\True$ if and only if $\vlit$ is equal to $\vlis$.
  \end{itemize}

\item \AllApplyCase{t\_bits}
  \begin{itemize}
  \item the \underlyingtypeterm\ of $\vs$ is a bitvector type with width $\ws$ and bit fields $\bfss$, that is $\TBits(\ws, \bfss)$;
  \item the \underlyingtypeterm\ of $\vt$ is a bitvector type with width $\wt$ and bit fields $\bfst$, that is $\TBits(\wt, \bfst)$;
  \item determining whether the bitfields $\bfss$ are included in the bitfields $\bfst$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item determining whether the \symbolicdomainterm{} of $\ws$ subsumes the \symbolicdomainterm{} of $\wt$ in $\tenv$ yields $\vb$.
  \end{itemize}

\item \AllApplyCase{t\_array\_expr}
  \begin{itemize}
  \item $\vs$ has the \underlyingtypeterm\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtypeterm\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are \equivalenttypesterm{} in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array length expression with $\vlengthexprs$, that is \\ $\ArrayLengthExpr(\vlengthexprs)$;
  \item $\vlengtht$ is an array length expression with $\vlengthexprt$, that is \\ $\ArrayLengthExpr(\vlengthexprt)$;
  \item determining whether $\vlengthexprs$ and $\vlengthexprt$ are \equivalentexprsterm{} gives $\vb$.
  \end{itemize}

  \item \AllApplyCase{t\_array\_enum}
  \begin{itemize}
  \item $\vs$ has the \underlyingtypeterm\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtypeterm\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are \equivalenttypesterm{} in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array with indices taken from the enumeration $\vnames$, that is $\ArrayLengthEnum(\vnames, \Ignore)$;
  \item $\vlengtht$ is an array with indices taken from the enumeration $\vnamet$, that is $\ArrayLengthEnum(\vnamet, \Ignore)$;
  \item $\vb$ is $\True$ if and only if $\vnames$ and $\vnamet$ are the same.
  \end{itemize}

\item \AllApplyCase{t\_tuple}
  \begin{itemize}
  \item $\vs$ has the \underlyingtypeterm\ of a tuple with type list $\vlis$, that is $\TTuple(\vlis)$;
  \item $\vt$ has the \underlyingtypeterm\ of a tuple with type list $\vlit$, that is $\TTuple(\vlit)$;
  \item equating the lengths of $\vlis$ and $\vlit$ is either $\True$ or $\False$, which short-circuits
  the entire rule with $\vb=\False$;
  \item checking at each index $\vi$ of the list $\vlis$ whether the type $\vlit[\vi]$ \typesatisfiesterm\ the type $\vlis[\vi]$
  yields $\vb_\vi$\ProseOrTypeError;
  \item $\vb$ is $\True$ if and only if all $\vb_\vi$ are $\True$;
  \end{itemize}

\item \AllApplyCase{structured}
  \begin{itemize}
  \item $\vs$ has the \underlyingtypeterm\ $L(\vfieldss)$, which is a \structuredtypeterm;
  \item $\vt$ has the \underlyingtypeterm\ $L(\vfieldst)$, which is a \structuredtypeterm;
  \item since both underlying types have the same AST label they are either both record types or both exception types or both collection types;
  \item $\vb$ is $\True$ if and only if for each field in $\vfieldss$ with type $\vtys$
  there exists a field in $\vfieldst$ with type $\vtyt$ such that both $\vtys$ and $\vtyt$
  are determined to be \typeequivalentterm\ in $\tenv$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[error1]{
  \makeanonymous(\tenv, \vt) \typearrow \TypeErrorConfig
}{
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\end{mathpar}

\begin{mathpar}
\inferrule[error2]{
  \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
  \makeanonymous(\tenv, \vs) \typearrow \TypeErrorConfig
}{
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\end{mathpar}

\begin{mathpar}
\inferrule[different\_labels]{
  \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
  \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
  \astlabel(\vttwo) \neq \astlabel(\vstwo)
}{
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
  \inferrule[simple]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \astlabel(\vttwo) \in \{\TReal, \TString, \TBool\}\\
    \vb \eqdef \astlabel(\vstwo) = \astlabel(\vttwo)
  }{
    \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
\inferrule[t\_int]{
  \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
  \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
  \astlabel(\vttwo) = \astlabel(\vstwo) = \TInt\\
  \symdomoftype(\tenv, \vs) \typearrow \ds \\
  \symdomoftype(\tenv, \vt) \typearrow \dt \\
  \symdomsubsetunions(\tenv, \ds, \dt) \typearrow \vb
}{
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \makeanonymous(\tenv, \vt) \typearrow \TEnum(\vlit)\\
  \makeanonymous(\tenv, \vs) \typearrow \TEnum(\vlis)\\
  \vb \eqdef \vlit = \vlis
}{
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \makeanonymous(\tenv, \vs) \typearrow \TBits(\ws, \bfss)\\
  \makeanonymous(\tenv, \vt) \typearrow \TBits(\wt, \bfst)\\
  \bitfieldsincluded(\tenv, \bfss, \bfst) \typearrow \True \OrTypeError \\
  \symdomofwidthexpr(\tenv, \ws) \typearrow \ds \\
  \symdomofwidthexpr(\tenv, \wt) \typearrow \dt \\
  \symdomsubsetunions(\tenv, \ds, \dt) \typearrow \vb
}{
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_expr]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True \terminateas \False\\
  \booltrans(\astlabel(\vlengths) = \astlabel(\vlengtht)) \booltransarrow \True \terminateas \False\\
  \vlengths \eqname \ArrayLengthExpr(\vlengthexprs)\\
  \vlengtht \eqname \ArrayLengthExpr(\vlengthexprt)\\
  \exprequal(\tenv, \vlengthexprs, \vlengthexprt) \typearrow \vb
}{
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_enum]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True\\
  \booltrans(\astlabel(\vlengths) = \astlabel(\vlengtht)) \typearrow \True \terminateas \False \\
  \vlengths \eqname \ArrayLengthEnum(\vnames, \Ignore)\\
  \vlengtht \eqname \ArrayLengthEnum(\vnamet, \Ignore)\\
  \vb \eqdef \vnames = \vnamet
}{
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]
{ \makeanonymous(\tenv, \vs) \typearrow\TTuple(\vlis)\\
  \makeanonymous(\tenv, \vt) \typearrow\TTuple(\vlit)\\
  \equallength(\vlis, \vlit) \typearrow\True \terminateas \False\\
  \vi\in\listrange(\vlis): \typesatisfies(\tenv, \vlit[\vi], \vlis[\vi]) \typearrow \vb_i \terminateas \typeerror\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_\vi
}{
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\RenderRelation{field_names}
For a list of typed fields $\fields$, we define the set of its field identifiers as:
\[
  \fieldnames(\fields) \triangleq \{ \id \;|\; (\id, \vt) \in \fields\}
\]

\RenderRelation{field_type}
It is defined as follows:
\[
  \fieldtype(\fields, \id) \triangleq
  \begin{cases}
  \some{\vt}  & \text{ if }\{ \vtp \;|\; (\id,\vtp) \in \fields\} = \{\vt\}\\
  \None & \text{ otherwise}
  \end{cases}
\]

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException, \TCollection\}\\
  \makeanonymous(\tenv, \vs)\typearrow L(\vfieldss) \\
  \makeanonymous(\tenv, \vt)\typearrow L(\vfieldst) \\
  \vnamess \eqdef \fieldnames(\vfieldss)\\
  \vnamest \eqdef \fieldnames(\vfieldst)\\
  \booltrans(\vnamess \subseteq \vnamest) \booltransarrow \True \terminateas \False\\
  (\id,\vtys)\in\vfieldss: \typeequal(\tenv, \vtys, \fieldtype(\vfieldst, \id)) \typearrow \vb_\id\\
  \vb \eqdef \bigwedge_{\id \in \vnamess} \vb_\id
}{
  \subtypesatisfies(\tenv, \vs, \vt) \typearrow \vb
}
\end{mathpar}
\identd{TRVR} \identi{SJDC} \identi{MHYB} \identi{TWTZ} \identi{GYSK} \identi{KXSD} \identi{KNXJ}
\CodeSubsection{\SubtypeSatisfactionBegin}{\SubtypeSatisfactionEnd}{../types.ml}

\TypingRuleDef{TypeSatisfaction}
\identr{FMXK}
\RenderRelation{type_satisfies}
\BackupOriginalRelation{
The predicate
\[
  \typesatisfies(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
determines whether a type $\vt$ \emph{\typesatisfiesterm} a type $\vs$ in environment $\tenv$,
returning the result $\vb$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

The function assumes that both $\vt$ and $\vs$ are well-typed according to \secref{Types}.

\ExampleDef{Type-satisfaction Examples}
In \listingref{typing-typesat1},
\texttt{var pair: pairT = (1, dataT1)} is legal since the right-hand-side has
anonymous, non-primitive type \texttt{(integer, T1)}.
\ASLListing{Type satisfaction example}{typing-typesat1}{\typingtests/TypingRule.TypeSatisfaction1.asl}

\ExampleDef{More Type-satisfaction Examples}
In \listingref{typing-typesat2},
\texttt{pair = (1, dataAsInt);} is legal since the right-hand-side has anonymous,
primitive type \texttt{(integer, integer)}.
\ASLListing{Type satisfaction example}{typing-typesat2}{\typingtests/TypingRule.TypeSatisfaction2.asl}

\ExampleDef{Failing Type-satisfaction}
In \listingref{typing-typesat3},
\texttt{pair = (1, dataT2);} is illegal since the right-hand-side has anonymous,
non-primitive type \texttt{(integer, T2)} which does not subtype-satisfy named
type \texttt{pairT}.
\ASLListing{Type satisfaction example}{typing-typesat3}{\typingtests/TypingRule.TypeSatisfaction3.asl}

The specification in \listingref{typing-typesat-bad1} is ill-typed,
since \verb|integer{0..N}| does not \typesatisfyterm{} \verb|integer{0..M}|.
\ASLListing{Failing type satisfaction example}{typing-typesat-bad1}{\typingtests/TypingRule.TypeSatisfaction.bad1.asl}

\ProseParagraph
\OneApplies
 \begin{itemize}
  \item \AllApplyCase{subtypes}
    \begin{itemize}
    \item $\vt$ subtypes $\vs$ in $\tenv$ ;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{anonymous}
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item at least one of $\vt$ and $\vs$ is an anonymous type in $\tenv$;
    \item determining whether $\vt$ \subtypesatisfiesterm\ $\vs$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{t\_bits}
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfiesterm\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item $\vt$ is a bitvector type with width $\widtht$ and no bitfields;
    \item obtaining the \structureterm\ of $\vs$ in $\tenv$ yields a bitvector type with width \\
          $\widths$\ProseOrTypeError;
    \item determining whether $\widtht$ and $\widths$ are \bitwidthequivalentterm\ yields $\vb$.
  \end{itemize}

  \item \AllApplyCase{otherwise1}
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfiesterm\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item obtaining the \structureterm\ of $\vs$ in $\tenv$ yields a $\vsstruct$\ProseOrTypeError;
    \item at least one of $\vt$ and $\vsstruct$ is not a bitvector type;
  \end{itemize}

  \item \AllApplyCase{otherwise2}
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfiesterm\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item obtaining the \structureterm\ of $\vs$ in $\tenv$ yields a $\vsstruct$\ProseOrTypeError;
    \item both $\vt$ and $\vsstruct$ are bitvector types;
    \item the bitvector type $\vt$ has a non-empty list of bitfields;
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[subtypes]{
  \issubtype(\tenv, \vt, \vs) \typearrow \True
}{
  \typesatisfies(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[anonymous]{
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \vbone \lor \vbtwo\\
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \True
}{
  \typesatisfies(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \vt = \TBits(\widtht, \emptylist)\\
  \tstruct(\tenv, \vs) \typearrow \TBits(\widths, \Ignore) \OrTypeError\\\\
  \bitwidthequal(\tenv, \widtht, \widths) \typearrow \vb
}{
  \typesatisfies(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise1]{
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \astlabel(\vt) \neq \TBits \lor \astlabel(\vsstruct) \neq \TBits
}{
  \typesatisfies(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise2]{
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesatisfies(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \astlabel(\vt) = \TBits \land \astlabel(\vsstruct) = \TBits\\
  \vt = \TBits(\widtht, \bitfields)\\
  \bitfields \neq \emptylist
}{
  \typesatisfies(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}
\CodeSubsection{\TypeSatisfactionBegin}{\TypeSatisfactionEnd}{../types.ml}

\TypingRuleDef{CheckTypeSatisfaction}
\RenderRelation{checked_typesat}
\BackupOriginalRelation{
We also define
\[
  \checktypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
which is the same as $\typesatisfies$, but yields a \typingerrorterm{} when \\ $\typesatisfies(\tenv, \vt, \vs)$ is $\False$.
} % END_OF_BACKUP_RELATION

The function assumes that both $\vt$ and $\vs$ are well-typed according to \secref{Types}.

\ExampleDef{Checking Type Satisfaction}
In \listingref{typing-typesat1},
checking whether \verb|(integer, T1)| \typesatisfiesterm{} \verb|pairT|
for the assignment \verb|var pair: pairT = (1, dataT1)| yields $\True$.

In \listingref{typing-typesat3}, checking whether \verb|(intege, T2)|
\typesatisfiesterm{} \verb|pairT| for the assignment \verb|pair = (1, dataT2);|
yields a \typingerrorterm.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item \ProsetypesatTrue{$\tenv$}{$\vt$}{$\vs$};
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item \ProsetypesatFalse{$\tenv$}{$\vt$}{$\vs$}..
    \item the result is a \typingerrorterm{} (\TypeSatisfactionFailure).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \typesatisfies(\tenv, \vt, \vs) \typearrow \True
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \typesatisfies(\tenv, \vt, \vs) \typearrow \False
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\TypeSatisfactionFailure}
}
\end{mathpar}

\TypingRuleDef{LowestCommonAncestor}
Annotating a conditional expression (see \TypingRuleRef{ECond}),
requires finding a single type that can be used to annotate the results of both subexpressions.
We refer to such a type as a \emph{\Proselca}, or LCA, for short, and define it next.

\RenderRelation{lowest_common_ancestor}
\BackupOriginalRelation{
The function
\[
  \lca(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\ty}{\tty} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
returns the \Proselca{} of types $\vt$ and $\vs$ in $\tenv$ --- $\tty$.
The result is a \typingerrorterm{} if a \Proselca{} does not exist or a \typingerrorterm{} is detected.
} % END_OF_BACKUP_RELATION

\ExampleDef{Lowest Common Ancestor Examples}
\listingref{example-lca} shows examples of conditional expressions and the resulting
\emph{\Proselca}.
\pagebreak
\ASLListing{Lowest common ancestor}{example-lca}{\typingtests/TypingRule.LowestCommonAncestor.asl}

\listingref{example-lca2} shows an example of a lowest common ancestor of two \bitvectortypesterm{}
of different widths.
\ASLListing{Lowest common ancestor of two bitvectors}{example-lca2}{\typingtests/TypingRule.LowestCommonAncestor2.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{type\_equal}
  \begin{itemize}
    \item $\vt$ is \typeequal\ to $\vs$ in $\tenv$;
    \item $\tty$ is $\vs$ (can as well be $\vt$).
  \end{itemize}

  \item \AllApply
  \begin{itemize}
    \item $\vt$ is not \typeequal\ to $\vs$ in $\tenv$;
    \item \OneApplies
    \begin{itemize}
      \item \AllApplyCase{named\_subtype1}
      \begin{itemize}
        \item $\vt$ is a named type with identifier $\namesubt$, that is, $\TNamed(\namesubt)$;
        \item $\vs$ is a named type with identifier $\namesubs$, that is, $\TNamed(\namesubs)$;
        \item there is no \namedlowestcommonancestorterm\ of $\namesubs$ and $\namesubt$ in $\tenv$;
        \item obtaining the \underlyingtypeterm\ of $\vs$ yields $\vanons$\ProseOrTypeError;
        \item obtaining the \underlyingtypeterm\ of $\vt$ yields $\vanont$\ProseOrTypeError;
        \item obtaining the lowest common ancestor of $\vanons$ and $\vanont$ in $\tenv$ yields $\tty$\ProseOrTypeError.
      \end{itemize}

      \item \AllApplyCase{named\_subtype2}
      \begin{itemize}
        \item $\vt$ is a named type with identifier $\namesubt$, that is, $\TNamed(\namesubt)$;
        \item $\vs$ is a named type with identifier $\namesubs$, that is, $\TNamed(\namesubs)$;
        \item the \namedlowestcommonancestorterm\ of $\namesubs$ and $\namesubt$ in $\tenv$ is \\
              $\name$\ProseOrTypeError;
        \item $\tty$ is the named type with identifier $\name$, that is, $\TNamed(\name)$.
      \end{itemize}

      \item \AllApplyCase{one\_named1}
      \begin{itemize}
        \item only one of $\vt$ or $\vs$ is a named type;
        \item obtaining the \underlyingtypeterm\ of $\vs$ yields $\vanons$\ProseOrTypeError;
        \item obtaining the \underlyingtypeterm\ of $\vt$ yields $\vanont$\ProseOrTypeError;
        \item $\vanont$ is \typeequal\ to $\vanons$;
        \item $\tty$ is $\vt$ if it is a named type (that is, $\astlabel(\vt)=\TNamed$), and $\vs$ otherwise.
      \end{itemize}

      \item \AllApplyCase{one\_named2}
      \begin{itemize}
        \item only one of $\vt$ or $\vs$ is a named type;
        \item obtaining the \underlyingtypeterm\ of $\vs$ yields $\vanons$\ProseOrTypeError;
        \item obtaining the \underlyingtypeterm\ of $\vt$ yields $\vanont$\ProseOrTypeError;
        \item $\vanont$ is not \typeequal\ to $\vanons$;
        \item the lowest common ancestor of $\vanont$ and $\vanons$ in $\tenv$ is $\tty$\ProseOrTypeError.
      \end{itemize}

      \item \AllApplyCase{t\_int\_unconstrained}
      \begin{itemize}
        \item both $\vt$ and $\vs$ are integer types;
        \item at least one of $\vt$ or $\vs$ is an unconstrained integer type;
        \item $\tty$ is the unconstrained integer type.
      \end{itemize}

      \item \AllApplyCase{t\_int\_parameterized}
      \begin{itemize}
        \item neither $\vt$ nor $\vs$ are the unconstrained integer type;
        \item one of $\vt$ and $\vs$ is a \parameterizedintegertypeterm;
        \item the \wellconstrainedversionterm\ of $\vt$ is $\vtone$;
        \item the \wellconstrainedversionterm\ of $\vs$ is $\vsone$;
        \item $\tty$ the lowest common ancestor of $\vtone$ and $\vsone$ in $\tenv$ is $\tty$\ProseOrTypeError.
      \end{itemize}

      \item \AllApplyCase{t\_int\_wellconstrained}
      \begin{itemize}
        \item $\vt$ is a well-constrained integer type with constraints $\cst$ and \precisionlossindicatorterm{} $\vpone$;
        \item $\vs$ is a well-constrained integer type with constraints $\css$ and \precisionlossindicatorterm{} $\vpone$;
        \item applying $\precisionjoin$ on $\vpone$ and $\vptwo$ yields $\vp$;
        \item $\tty$ is the well-constrained integer type with constraints $\cst \concat \css$ and \precisionlossindicatorterm{} $\vp$.
      \end{itemize}

      \item \AllApplyCase{t\_bits}
      \begin{itemize}
        \item $\vt$ is a bitvector type with length expression $\vet$, that is, $\TBits(\vet, \Ignore)$;
        \item $\vs$ is a bitvector type with length expression $\ves$, that is, $\TBits(\ves, \Ignore)$;
        \item applying $\typeequal$ to $\vt$ and $\vs$ in $\tenv$ yields $\False$;
        \item applying $\exprequal$ to $\vet$ and $\ves$ in $\tenv$ yields $\vbequal$;
        \item checking whether $\vbequal$ is $\True$ yields $\True$\ProseTerminateAs{\NoLCA};
        \item $\tty$ is a bitvector type with length expression $\vet$ and an empty bitfield list, that is, $\TBits(\vet, \emptylist)$.
      \end{itemize}

      \item \AllApplyCase{t\_array}
      \begin{itemize}
        \item $\vt$ is an array type with width expression $\widtht$ and element type $\vtyt$;
        \item $\vs$ is an array type with width expression $\widths$ and element type $\vtys$;
        \item applying $\arraylengthequal$ to $\widtht$ and $\widths$ in $\tenv$ to equate the array lengths,
              yields $\vbequallength$\ProseOrTypeError;
        \item checking that $\vbequallength$ is $\True$ yields $\True$\ProseTerminateAs{\NoLCA};
        \item the lowest common ancestor of $\vtyt$ and $\vtys$ is $\vtone$\ProseOrTypeError;
        \item $\tty$ is an array type with width expression $\widths$ and element type $\vtone$.
      \end{itemize}

      \item \AllApplyCase{t\_tuple}
      \begin{itemize}
        \item $\vt$ is a \tupletypeterm{} with type list $\vlit$;
        \item $\vs$ is a \tupletypeterm{} with type list $\vlis$;
        \item checking whether $\vlit$ and $\vlis$ have the same number of elements yields $\True$
              or a \typingerrorterm{}, which short-circuits the entire rule (indicating that the number of elements in both tuples is expected
              to be the same and thus there is no lowest common ancestor);
        \item applying $\lca$ to $\vlit[\vi]$ and $\vlis[\vi]$ in $\tenv$, for every position of $\vlit$,
              yields $\vt_\vi$\ProseOrTypeError;
        \item define $\vli$ to be the list of types $\vt_\vi$, for every position of $\vlit$;
        \item define $\tty$ as the \tupletypeterm{} with list of types $\vli$, that is, $\TTuple(\vli)$.
      \end{itemize}

      \item \AllApplyCase{error}
      \begin{itemize}
        \item either the AST labels of $\vt$ and $\vs$ are different, or one of them is $\TEnum$, $\TRecord$, $\TCollection$, or $\TException$;
        \item the result is a \typingerrorterm{} indicating the lack of a lowest common ancestor.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}
\CodeSubsection{\LowestCommonAncestorBegin}{\LowestCommonAncestorEnd}{../types.ml}

\FormallyParagraph
Since we do not impose a canonical representation on types (e.g., \verb|integer {1, 2}| is \typeequivalentterm{} to \verb|integer {1..2}|),
the lowest common ancestor is not unique.
We define $\lca(\tenv, \vt, \vs)$ to be any type $\vtp$ that is \typeequivalentterm\ to the lowest common ancestor of $\vt$ and $\vs$.

\begin{mathpar}
\inferrule[type\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \True
}{
  \lca(\tenv, \vt, \vs) \typearrow \overname{\vs}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[named\_subtype1]{
  \vt = \TNamed(\namesubs)\\
  \vs = \TNamed(\namesubt)\\
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \namedlca(\tenv, \namesubs, \namesubt) \typearrow \None \OrTypeError\\\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\\\
  \lca(\tenv, \vanont, \vanons) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[named\_subtype2]{
  \vt = \TNamed(\namesubs)\\
  \vs = \TNamed(\namesubt)\\
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \namedlca(\tenv, \namesubs, \namesubt) \typearrow \some{\name} \OrTypeError\\
}{
  \lca(\tenv, \vt, \vs) \typearrow \overname{\TNamed(\name)}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_named1]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) = \TNamed \lor \astlabel(\vs) = \TNamed)\\
  \astlabel(\vt) \neq \astlabel(\vs)\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\\\
  \typeequal(\tenv, \vanont, \vanons) \typearrow \True\\
  \tty \eqdef \choice{\astlabel(\vt) = \TNamed}{\vt}{\vs}
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_named2]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) = \TNamed \lor \astlabel(\vs) = \TNamed)\\
  \astlabel(\vt) \neq \astlabel(\vs)\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\\\
  \typeequal(\tenv, \vanont, \vanons) \typearrow \False\\
  \lca(\tenv, \vanont, \vanons) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_int\_unconstrained]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \isunconstrainedinteger(\vt) \lor \isunconstrainedinteger(\vs)
}{
  \lca(\tenv, \vt, \vs) \typearrow \overname{\unconstrainedinteger}{\tty}
}
\and
\inferrule[t\_int\_parameterized]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \neg\isunconstrainedinteger(\vt)\\
  \neg\isunconstrainedinteger(\vs)\\
  \isparameterizedinteger(\vt) \lor \isparameterizedinteger(\vs)\\
  \towellconstrained(\tenv, \vt) \typearrow \vtone\\
  \towellconstrained(\tenv, \vs) \typearrow \vsone\\
  \lca(\tenv, \vtone, \vsone) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\and
\inferrule[t\_int\_wellconstrained]
{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt = \TInt(\WellConstrained(\cst, \vpone))\\
  \vs = \TInt(\WellConstrained(\css, \vptwo))\\
  \vp \eqdef \precisionjoin(\vpone, \vptwo)
}{
  \lca(\tenv, \vt, \vs) \typearrow \overname{\TInt(\WellConstrained(\cst \concat \css, \vp))}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \exprequal(\tenv, \vet, \ves) \typearrow \vbequal\\
  \techeck(\vbequal, \NoLCA) \typearrow \True \OrTypeError
}{
  \lca(\tenv, \overname{\TBits(\vet, \Ignore)}{\vt}, \overname{\TBits(\ves, \Ignore)}{\vs}) \typearrow \overname{\TBits(\vet, \emptylist)}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \arraylengthequal(\tenv, \widtht, \widths) \typearrow \vbequallength \OrTypeError\\\\
  \techeck(\vbequallength, \NoLCA) \typearrow \True \OrTypeError\\\\
  \lca(\tenv, \vtyt, \vtys) \typearrow \vtone \OrTypeError
}{
  {
  \begin{array}{r}
  \lca(\tenv, \overname{\TArray(\widtht, \vtyt)}{\vt}, \overname{\TArray(\widths, \vtys)}{\vs}) \typearrow \\
  \overname{\TArray(\widtht, \vtone)}{\tty}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \equallength(\vlit, \vlis) \typearrow \vb\\
  \techeck(\vb, \NoLCA) \typearrow \True \OrTypeError\\\\
  {
    \begin{array}{r}
  \vi\in\listrange(\vlit): \lca(\tenv, \vlit[\vi], \vlis[\vi]) \typearrow \\
   \vt_\vi \OrTypeError
    \end{array}
  }\\
  \vli \eqdef [\vi\in\listrange(\vlit): \vt_\vi]
}{
  \lca(\tenv, \overname{\TTuple(\vlit)}{\vt}, \overname{\TTuple(\vlis)}{\vs}) \typearrow \overname{\TTuple(\vli)}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) \neq \astlabel(\vs)) \lor
  \astlabel(\vt) \in \{\TEnum, \TRecord, \TException, \TCollection\}
}{
  \lca(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\NoLCA}
}
\end{mathpar}

\identr{YZHM}

\TypingRuleDef{ApplyUnopType}
\RenderRelation{apply_unop_type}
\BackupOriginalRelation{
The function
\[
  \applyunoptype(\overname{\staticenvs}{\tenv} \aslsep \overname{\unop}{\op} \aslsep \overname{\ty}{\vt})
  \aslto \overname{\ty}{\vs} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
determines the result type of applying a unary operator when the type of its operand is known.
Similarly, we determine the negation of integer constraints.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Applying Unary Operations to Types}
\listingref{apply-unop-type} shows examples of typing applications of unary operations.
\ASLListing{Applying unary operations to types}{apply-unop-type}{\typingtests/TypingRule.ApplyUnopType.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
\item \AllApplyCase{bnot\_t\_bool}
  \begin{itemize}
    \item $\op$ is $\BNOT$;
    \item determining whether $\vt$ \typesatisfiesterm\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vs$ is $\TBool$;
  \end{itemize}

\item \AllApplyCase{neg\_error}
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfiesterm\ $\TReal$ yields $\False$\ProseOrTypeError;
  \item determining whether $\vt$ \typesatisfiesterm\ $\unconstrainedinteger$ yields $\False$\ProseOrTypeError;
  \item the result is a \typingerrorterm{} indicating the $\NEG$ is appropriate only for the \realtypeterm{} and the \integertypeterm{};
\end{itemize}

\item \AllApplyCase{neg\_t\_real}
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfiesterm\ $\TReal$ yields $\True$;
  \item $\vs$ is $\TReal$;
\end{itemize}

\item \AllApplyCase{neg\_t\_int\_unconstrained}
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item obtaining the \wellconstrainedstructureterm\ of $\vt$ yields $\unconstrainedinteger$\ProseOrTypeError;
  \item $\vs$ is $\unconstrainedinteger$;
\end{itemize}

\item \AllApplyCase{neg\_t\_int\_well\_constrained}
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item obtaining the \wellconstrainedstructureterm\ of $\vt$ yields the well-constrained integer type with constraints $\vcs$ and \precisionlossindicatorterm{} $\vp$\ProseOrTypeError;
  \item negating the constraints in $\vcs$ (see $\negateconstraint$) yields $\vcsnew$;
  \item $\vs$ is the well-constrained integer type with constraints $\vcsnew$ and \precisionlossindicatorterm{} $\vp$, that is, \\
  $\TInt(\WellConstrained(\vcsnew, \vp))$;
\end{itemize}

\item \AllApplyCase{not\_t\_bits}
  \begin{itemize}
  \item $\op$ is $\NOT$;
  \item $\vt$ has the structure of a bitvector;
  \item $\vs$ is $\vt$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[bnot\_t\_bool]{
  \checktypesat(\tenv, \vtone, \TBool) \typearrow \True \OrTypeError\\
}{
  \applyunoptype(\tenv, \BNOT, \vtone) \typearrow \TBool
}
\end{mathpar}
\CodeSubsection{\ApplyUnopTypeBegin}{\ApplyUnopTypeEnd}{../Typing.ml}

\begin{mathpar}
\inferrule[neg\_error]{
  \typesatisfies(\tenv, \vt, \unconstrainedinteger) \typearrow \False \OrTypeError\\\\
  \typesatisfies(\tenv, \vt, \TReal) \typearrow \False \OrTypeError\\
}{
  \applyunoptype(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \TypeErrorVal{\BadOperands}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_real]{
  \typesatisfies(\tenv, \vt, \TReal) \typearrow \True
}{
  \applyunoptype(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \overname{\TReal}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_int\_unconstrained]{
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \unconstrainedinteger \OrTypeError
}{
  \applyunoptype(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \overname{\unconstrainedinteger}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_int\_well\_constrained]{
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \TInt(\WellConstrained(\vcs))\\
  \vc \in \vcs: \negateconstraint(\vc) \typearrow \vneg_\vc\\
  \vcsnew \eqdef [\vc \in \vcs: \vneg_\vc]
}{
  \applyunoptype(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \overname{\TInt(\WellConstrained(\vcsnew))}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_t\_bits]{
  \checkstructurelabel(\tenv, \vt, \TBits) \typearrow \True \OrTypeError
}{
  \applyunoptype(\tenv, \overname{\NOT}{\op}, \vt) \typearrow \vt
}
\end{mathpar}

\TypingRuleDef{NegateConstraint}
\RenderRelation{negate_constraint}
\BackupOriginalRelation{
The function
\[
  \negateconstraint(\overname{\intconstraint}{\vc}) \aslto \overname{\intconstraint}{\newc}
\]
takes an integer constraint $\vc$ and returns the constraint $\newc$,
which corresponds to the negation of all the values that $\vc$ represents.
} % END_OF_BACKUP_RELATION

\ExampleRef{Applying Unary Operations to Types} shows examples of negating single expression
constraints and range constraints.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is the \Proseexactconstraint{$\ve$};
    \item \Proseeqdef{$\newc$}{the \Proseexactconstraint{the unary expression negating $\ve$}}.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is the \Proserangeconstraint{$\vstart$}{$\vend$}
    \item \Proseeqdef{$\newc$}{the \Proserangeconstraint{that is the unary expression negating $\vend$}
    {that is the unary expression negating $\vstart$}}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{}
{
  \negateconstraint(\overname{\ConstraintExact(\ve)}{\vc}) \typearrow
  \overname{\ConstraintExact(\EUnop(\SUB, \ve))}{\newc}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{}
{
  \negateconstraint(\overname{\ConstraintRange(\vstart, \vend)}{\vc}) \typearrow \\
  \overname{\ConstraintRange(\EUnop(\SUB, \vend), \EUnop(\SUB, \vstart))}{\newc}
}
\end{mathpar}

\TypingRuleDef{ApplyBinopTypes}
\RenderRelation{apply_binop_types}
\BackupOriginalRelation{
The function
\[
  \applybinoptypes(\overname{\staticenvs}{\tenv} \aslsep \overname{\binop}{\op} \aslsep \overname{\ty}{\vtone}
  \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\ty}{\vt} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
determines the result type $\vt$ of applying the binary operator $\op$
to operands of type $\vtone$ and $\vttwo$ in the \staticenvironmentterm{} $\tenv$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Filtering Constraints for Binary Operations}
Since binary operations may dynamically fail, the typechecker may remove values
that will definitely lead to \dynamicerrorsterm.
For example, in \listingref{apply-binop-constraints2},
the constraint \verb|integer{-1..1}| serves for the denominator in \verb|x DIV y|,
and since \verb|-1| and \verb|0| will always lead to a \dynamicerrorterm,
the typechecker removes them for the purpose of typing \verb|x DIV y|,
which leaves only \verb|1| and the final type for \verb|z| is therefore
\verb|integer{2, 4}|.

\ASLListing{Removing values from constraints}{apply-binop-constraints2}
{\typingtests/TypingRule.ApplyBinopTypes.constraints2.asl}

\ExampleDef{Applying Binary Operations to Types}
\listingref{apply-binop-type} shows examples of typing binary operations.
\ASLListing{Applying binary operations to types}{apply-binop-type}
          {\typingtests/TypingRule.ApplyBinopTypes.asl}

\ExampleDef{Applying Binary Operations to Constrained Integers}
\listingref{apply-binop-constraints} shows examples of typing binary operations
applied to \constrainedintegerterm{} types.

Importantly, note that there is no AST for applying binary operations on
constraints.
For example, given a range constraint \verb|A..B| and an exact constraint |2|,
there is no AST to express \verb|(A..B) * 2|. Therefore, the constraints for typing
\verb|ab_times_2| approximate the set of values for \verb|(A..B) * 2| via four
range constraints. More precisely, they are a superset of the values for \verb|(A..B) * 2|.

\pagebreak
\ASLListing{Applying binary operations to constrained integers}{apply-binop-constraints}
          {\typingtests/TypingRule.ApplyBinopTypes.constraints.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{named}
  \begin{itemize}
    \item at least one of $\vtone$ and $\vttwo$ is a \namedtype;
    \item determining the \underlyingtypeterm\ if $\vtone$ yields $\vtoneanon$\ProseOrTypeError;
    \item determining the \underlyingtypeterm\ if $\vttwo$ yields $\vttwoanon$\ProseOrTypeError;
    \item \Proseapplybinoptypes{$\tenv$}{$\op$}{$\vtoneanon$}{$\vttwoanon$}{$\vt$\ProseOrTypeError}.
  \end{itemize}

  \item \AllApplyCase{boolean}
  \begin{itemize}
    \item $\op$ is $\AND$, $\OR$, $\EQ$ or $\IMPL$;
    \item both $\vtone$ and $\vttwo$ are $\TBool$;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item \AllApplyCase{bits\_arith}
  \begin{itemize}
    \item $\op$ is one of $\AND$, $\OR$, $\XOR$, $\ADD$, and $\SUB$;
    \item $\vtone$ is a bitvector type with width expression $\vwone$;
    \item $\vttwo$ is a bitvector type with width expression $\vwtwo$;
    \item checking whether $\vtone$ and $\vttwo$ have the \structureterm\ of bitvector types
          of the same width in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is the bitvector type of width $\vwone$ and empty list of bitfields, that is, \\ $\TBits(\vwone, \emptylist)$.
  \end{itemize}

  \item \AllApplyCase{bits\_int}
  \begin{itemize}
    \item $\op$ is either $\ADD$ or $\SUB$;
    \item $\vtone$ is a bitvector type with width expression $\vw$;
    \item $\vttwo$ is an integer type;
    \item $\vt$ is the bitvector type of width $\vw$ and empty list of bitfields, that is, \\ $\TBits(\vw, \emptylist)$.
  \end{itemize}

  \item \AllApplyCase{bits\_concat}
  \begin{itemize}
    \item $\op$ is $\BVCONCAT$;
    \item $\vtone$ is a bitvector type with width expression $\vwone$;
    \item $\vttwo$ is a bitvector type with width expression $\vwtwo$;
    \item define $\vw$ as the addition of $\vwone$ and $\vwtwo$;
    \item applying \normalize{} to $\vw$ in $\tenv$ yields $\vwp$;
    \item $\vt$ is the bitvector type of width $\vwp$ and empty list of bitfields, that is, \\ $\TBits(\vw, \emptylist)$.
  \end{itemize}

  \item \AllApplyCase{string\_concat}
  \begin{itemize}
    \item $\op$ is $\STRCONCAT$;
    \item $\vtone$ and $\vttwo$ are not both bitvector types;
    \item checking that $\vtone$ is a \singulartypeterm{} yields $\True$\ProseOrTypeError;
    \item checking that $\vttwo$ is a \singulartypeterm{} yields $\True$\ProseOrTypeError;
    \item $\vt$ is the string type.
  \end{itemize}

  \item \AllApplyCase{rel}
  \begin{itemize}
    \item the operator $\op$ and types of $\vtone$ and $\vttwo$ match one of the rows in the following table:
    \[
    \begin{array}{lll}
      \mathbf{\op} & \mathbf{\vtone} & \mathbf{\vttwo} \\
      \hline
      \LE  & \TInt    & \TInt\\
      \GE  & \TInt    & \TInt\\
      \GT   & \TInt    & \TInt\\
      \LT   & \TInt    & \TInt\\
      \LE  & \TReal   & \TReal\\
      \GE  & \TReal   & \TReal\\
      \GT   & \TReal   & \TReal\\
      \LT   & \TReal   & \TReal\\
      \EQ & \TInt    & \TInt\\
      \NE  & \TInt    & \TInt\\
      \EQ & \TBool   & \TBool\\
      \NE  & \TBool   & \TBool\\
      \EQ & \TReal   & \TReal\\
      \NE  & \TReal   & \TReal\\
      \EQ & \TString & \TString\\
      \NE  & \TString & \TString
    \end{array}
    \]
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item \AllApplyCase{eq\_neq\_bits}
  \begin{itemize}
    \item $\op$ is either $\EQ$ or $\NE$;
    \item $\vtone$ is a bitvector type with width expression $\vwone$;
    \item $\vttwo$ is a bitvector type with width expression $\vwtwo$;
    \item checking whether the bitwidth of $\vtoneanon$ and $\vttwoanon$ is the same yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item \AllApplyCase{eq\_neq\_enum}
  \begin{itemize}
    \item $\op$ is either $\EQ$ or $\NE$;
    \item $\vtone$ is $\TEnum(\vlione)$;
    \item $\vttwo$ is $\TEnum(\vlitwo)$;
    \item checking whether $\vlione$ is equal to $\vlitwo$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item \AllApplyCase{arith\_t\_int\_unconstrained}
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \ADD, \SUB\}$;
    \item both $\vtone$ and $\vttwo$ are integer types and at least one them is the unconstrained integer type;
    \item $\vt$ is the unconstrained integer type;
  \end{itemize}

  \item \AllApplyCase{arith\_t\_int\_parameterized}
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \ADD, \SUB\}$;
    \item both $\vtone$ and $\vttwo$ are integer types, neither is an unconstrained integer type, and at least one them is a \parameterizedintegertypeterm;
    \item applying $\towellconstrained$ to $\vtone$ yields $\vtonewellconstrained$;
    \item applying $\towellconstrained$ to $\vttwo$ yields $\vttwowellconstrained$;
    \item \Proseapplybinoptypes{$\tenv$}{$\op$}{$\vtonewellconstrained$}{$\vttwowellconstrained$}{$\vt$}.
  \end{itemize}

  \item \AllApplyCase{arith\_t\_int\_wellconstrained}
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \POW, \ADD, \SUB, \DIVRM, \DIV, \MOD, \SHL, \SHR\}$;
    \item $\vtone$ is the well-constrained integer type with constraints $\csone$ and \precisionlossindicatorterm{} $\vpone$;
    \item $\vttwo$ is the well-constrained integer type with constraints $\cstwo$ and \precisionlossindicatorterm{} $\vptwo$;
    \item applying $\annotateconstraintbinop$ to $\op$, $\csone$, and $\cstwo$ in $\tenv$ yields $\vc$ and $\vpthree$;
    \item defining $\vpthree$ as the $\precisionjoin$ of $\vpone$, $\vptwo$, and $\vpthree$;
    \item $\vt$ is the well-constrained integer type with constraints $\vc$ and \precisionlossindicatorterm{} $\vp$\
  \end{itemize}

  \item \AllApplyCase{arith\_real}
  \begin{itemize}
    \item the operator $\op$ and types of $\vtone$ and $\vttwo$ match one of the rows in the following table:
    \[
    \begin{array}{lll}
      \mathbf{\op} & \mathbf{\vtone} & \mathbf{\vttwo} \\
      \hline
      \ADD  & \TReal    & \TReal\\
      \SUB & \TReal    & \TReal\\
      \MUL   & \TReal    & \TReal\\
      \POW   & \TReal    & \TInt\\
      \RDIV  & \TReal    & \TReal
    \end{array}
    \]
    \item $\vt$ is $\TReal$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item obtaining the \underlyingtypeterm\ of $\vtone$ in $\tenv$ yields $\vtoneanon$\ProseOrTypeError;
    \item obtaining the \underlyingtypeterm\ of $\vttwo$ in $\tenv$ yields $\vttwoanon$\ProseOrTypeError;
    \item the operator and the AST labels of $\vtoneanon$ and $\vttwoanon$ do not match any of the rows in the following table,
    where $\vlone$ and $\vltwo$ are the AST labels of any \singulartypesterm{}:
    \[
    \begin{array}{lll}
      \hline
      \mathbf{\op} & \mathbf{\astlabel(\vtoneanon)} & \mathbf{\astlabel(\vttwoanon)} \\
      \hline
      \AND     & \TBool  & \TBool\\
      \OR      & \TBool  & \TBool\\
      \EQ    & \TBool  & \TBool\\
      \IMPL    & \TBool  & \TBool\\
      %
      \AND     & \TBits  & \TBits\\
      \OR      & \TBits  & \TBits\\
      \XOR     & \TBits  & \TBits\\
      \ADD    & \TBits  & \TBits\\
      \SUB   & \TBits  & \TBits\\
      \BVCONCAT& \TBits  & \TBits\\
      %
      \STRCONCAT& \vlone  & \vltwo\\
      %
      \ADD    & \TBits  & \TInt\\
      \SUB   & \TBits  & \TInt\\
      %
      \LE     & \TInt     & \TInt\\
      \GE     & \TInt     & \TInt\\
      \GT      & \TInt     & \TInt\\
      \LT      & \TInt     & \TInt\\
      \LE     & \TReal    & \TReal\\
      \GE     & \TReal    & \TReal\\
      \GT      & \TReal    & \TReal\\
      \LT      & \TReal    & \TReal\\
      \EQ    & \TInt     & \TInt\\
      \NE     & \TInt     & \TInt\\
      \EQ    & \TBool    & \TBool\\
      \NE     & \TBool    & \TBool\\
      \EQ    & \TReal    & \TReal\\
      \NE     & \TReal    & \TReal\\
      \EQ    & \TString  & \TString\\
      \NE     & \TString  & \TString\\
      %
      \MUL     & \TInt  & \TInt\\
      \DIV     & \TInt  & \TInt\\
      \DIVRM   & \TInt  & \TInt\\
      \MOD     & \TInt  & \TInt\\
      \SHL     & \TInt  & \TInt\\
      \SHR     & \TInt  & \TInt\\
      \POW     & \TInt  & \TInt\\
      \ADD    & \TInt  & \TInt\\
      \SUB   & \TInt  & \TInt\\
      \ADD    & \TReal & \TReal\\
      \SUB   & \TReal & \TReal\\
      \MUL     & \TReal & \TReal\\
      \RDIV    & \TReal & \TReal\\
      \POW     & \TReal & \TInt\\
      %
      \ADD    & \TReal & \TReal\\
      \SUB   & \TReal & \TReal\\
      \MUL     & \TReal & \TReal\\
      \POW     & \TReal & \TInt\\
      \RDIV    & \TReal & \TReal\\
      \hline
    \end{array}
    \]
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[named]{
  \astlabel(\vtone) = \TNamed \lor \astlabel(\vttwo) = \TNamed\\
  \makeanonymous(\tenv, \vtone) \typearrow \vtoneanon \OrTypeError\\\\
  \makeanonymous(\tenv, \vttwo) \typearrow \vttwoanon \OrTypeError\\\\
  \applybinoptypes(\tenv, \op, \vtoneanon, \vttwoanon) \typearrow \vt \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt
}
\end{mathpar}

\begin{mathpar}
\inferrule[boolean]{
  \op \in  \{\BAND, \BOR, \IMPL, \EQ\}
}{
  \applybinoptypes(\tenv, \op, \overname{\TBool}{\vtone}, \overname{\TBool}{\vttwo}) \typearrow \overname{\TBool}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_arith]{
  \op \in  \{\AND, \OR, \XOR, \ADD, \SUB\}\\
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \overname{\TBits(\vwone, \Ignore)}{\vtone}, \overname{\TBits(\vwtwo, \Ignore)}{\vttwo})
  \typearrow \overname{\TBits(\vwone, \emptylist)}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_int]{
  \op \in  \{\ADD, \SUB\}}{
  \applybinoptypes(\tenv, \op, \overname{\TBits(\vw, \Ignore)}{\vtone}, \overname{\TInt(\Ignore)}{\vttwo}) \typearrow
  \overname{\TBits(\vw, \emptylist)}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_concat]{
  \vw \eqdef \EBinop(\ADD, \vwone, \vwtwo) \\
  \normalize(\tenv, \vw) \typearrow \vwp
}{
  \applybinoptypes(\tenv, \BVCONCAT, \overname{\TBits(\vwone, \Ignore)}{\vtone}, \overname{\TBits(\vwtwo, \Ignore)}{\vttwo}) \typearrow
  \overname{\TBits(\vwp, \emptylist)}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[string\_concat]{
  \vtone \neq \TBits(\Ignore, \Ignore) \lor \vttwo \neq \TBits(\Ignore, \Ignore) \\
  \techeck(\issingular(\vtone), \UnexpectedType) \typearrow \True \OrTypeError \\
  \techeck(\issingular(\vttwo), \UnexpectedType) \typearrow \True \OrTypeError
}{
  \applybinoptypes(\tenv, \STRCONCAT, \vtone, \vttwo) \typearrow
  \overname{\TString}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[rel]{
  {
    (\op, \vtone, \vttwo) \in \left\{
      \begin{array}{lclcl}
        (\LE     &,& \TInt     &,& \TInt)\\
        (\GE     &,& \TInt     &,& \TInt)\\
        (\GT      &,& \TInt     &,& \TInt)\\
        (\LT      &,& \TInt     &,& \TInt)\\
        (\LE     &,& \TReal    &,& \TReal)\\
        (\GE     &,& \TReal    &,& \TReal)\\
        (\GT      &,& \TReal    &,& \TReal)\\
        (\LT      &,& \TReal    &,& \TReal)\\
        (\EQ    &,& \TInt     &,& \TInt)\\
        (\NE     &,& \TInt     &,& \TInt)\\
        (\EQ    &,& \TBool    &,& \TBool)\\
        (\NE     &,& \TBool    &,& \TBool)\\
        (\EQ    &,& \TReal    &,& \TReal)\\
        (\NE     &,& \TReal    &,& \TReal)\\
        (\EQ    &,& \TString  &,& \TString)\\
        (\NE     &,& \TString  &,& \TString)\\
      \end{array}
      \right\}
  }
}{
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \overname{\TBool}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_neq\_bits]{
  \op \in  \{\EQ, \NE\}\\
  \checkbitsequalwidth(\tenv, \vtoneanon, \vttwoanon) \typearrow \True \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \overname{\TBits(\vwone, \Ignore)}{\vtone}, \overname{\TBits(\vwtwo, \Ignore)}{\vttwo}) \typearrow \overname{\TBool}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_neq\_enum]{
  \op \in  \{\EQ, \NE\}\\
  \techeck(\vlione = \vlitwo, \BadOperands) \typearrow \True \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \overname{\TEnum(\vlione)}{\vtone}, \overname{\TEnum(\vlitwo)}{\vttwo}) \typearrow \overname{\TBool}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_t\_int\_unconstrained]{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \ADD, \SUB\}\\
  \vcone = \Unconstrained \lor \vctwo = \Unconstrained
}{
  \applybinoptypes(\tenv, \op, \overname{\TInt(\vcone)}{\vtone}, \overname{\TInt(\vctwo)}{\vttwo}) \typearrow \unconstrainedinteger
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_t\_int\_parameterized]{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \ADD, \SUB\}\\
  \astlabel(\vcone) = \Parameterized \lor \astlabel(\vctwo) = \Parameterized\\
  \astlabel(\vcone) \neq \Unconstrained \land \astlabel(\vctwo) \neq \Unconstrained\\
  \towellconstrained(\vtone) \typearrow \vtonewellconstrained\\
  \towellconstrained(\vttwo) \typearrow \vttwowellconstrained\\
  \applybinoptypes(\tenv, \vtonewellconstrained, \vttwowellconstrained) \typearrow \vt \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \overname{\TInt(\vcone)}{\vtone}, \overname{\TInt(\vctwo)}{\vttwo}) \typearrow \vt
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_t\_int\_wellconstrained]{
  \op \in  \{\MUL, \POW, \ADD, \SUB, \DIVRM, \DIV, \MOD, \SHL, \SHR\}\\
  \vcone = \WellConstrained(\cstwo, \vpone)\\
  \vctwo = \WellConstrained(\csone, \vptwo)\\
  \annotateconstraintbinop(\tenv, \op, \vcsone, \vcstwo) \typearrow (\cs, \vpthree) \OrTypeError\\\\
  \vp = \precisionjoin(\vpone, \precisionjoin(\vptwo, \vpthree))
}{
      \applybinoptypes(\tenv, \op, \overname{\TInt(\vcone)}{\vtone},
        \overname{\TInt(\vctwo)}{\vttwo}) \typearrow
        \overname{\TInt(\WellConstrained(\cs, \vp))}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_real]{
  (\op, \vtone, \vttwo) \in
  {
    \left\{
    \begin{array}{lclcl}
      (\ADD  &,& \TReal &,& \TReal)\\
      (\SUB &,& \TReal &,& \TReal)\\
      (\MUL   &,& \TReal &,& \TReal)\\
      (\POW   &,& \TReal &,& \TInt)\\
      (\RDIV  &,& \TReal &,& \TReal)
    \end{array}
    \right\}
  }
}{
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \overname{\TReal}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \makeanonymous(\tenv, \vtone) \typearrow \vtoneanon \OrTypeError\\\\
  \makeanonymous(\tenv, \vttwo) \typearrow \vttwoanon \OrTypeError\\\\
  {
  \begin{array}{l}
  (\op, \astlabel(\vtoneanon), \astlabel(\vttwoanon)) \not\in\\
    \left\{
    \begin{array}{lclcl}
      (\AND     &,& \TBool  &,& \TBool)\\
      (\OR      &,& \TBool  &,& \TBool)\\
      (\EQ    &,& \TBool  &,& \TBool)\\
      (\IMPL    &,& \TBool  &,& \TBool)\\
      %
      (\AND     &,& \TBits  &,& \TBits)\\
      (\OR      &,& \TBits  &,& \TBits)\\
      (\XOR     &,& \TBits  &,& \TBits)\\
      (\ADD    &,& \TBits  &,& \TBits)\\
      (\SUB   &,& \TBits  &,& \TBits)\\
      (\BVCONCAT&,& \TBits  &,& \TBits)\\
      %
      (\ADD    &,& \TBits  &,& \TInt)\\
      (\SUB   &,& \TBits  &,& \TInt)\\
      %
      (\LE     &,& \TInt     &,& \TInt)\\
      (\GE     &,& \TInt     &,& \TInt)\\
      (\GT      &,& \TInt     &,& \TInt)\\
      (\LT      &,& \TInt     &,& \TInt)\\
      (\LE     &,& \TReal    &,& \TReal)\\
      (\GE     &,& \TReal    &,& \TReal)\\
      (\GT      &,& \TReal    &,& \TReal)\\
      (\LT      &,& \TReal    &,& \TReal)\\
      (\EQ    &,& \TInt     &,& \TInt)\\
      (\NE     &,& \TInt     &,& \TInt)\\
      (\EQ    &,& \TBool    &,& \TBool)\\
      (\NE     &,& \TBool    &,& \TBool)\\
      (\EQ    &,& \TReal    &,& \TReal)\\
      (\NE     &,& \TReal    &,& \TReal)\\
      (\EQ    &,& \TString  &,& \TString)\\
      (\NE     &,& \TString  &,& \TString)\\
      %
      (\MUL   &,& \TInt  &,& \TInt)\\
      (\DIV   &,& \TInt  &,& \TInt)\\
      (\DIVRM &,& \TInt  &,& \TInt)\\
      (\MOD   &,& \TInt  &,& \TInt)\\
      (\SHL   &,& \TInt  &,& \TInt)\\
      (\SHR   &,& \TInt  &,& \TInt)\\
      (\POW   &,& \TInt  &,& \TInt)\\
      (\ADD  &,& \TInt  &,& \TInt)\\
      (\SUB &,& \TInt  &,& \TInt)\\
      (\ADD  &,& \TReal &,& \TReal)\\
      (\SUB &,& \TReal &,& \TReal)\\
      (\MUL   &,& \TReal &,& \TReal)\\
      (\RDIV  &,& \TReal &,& \TReal)\\
      (\POW   &,& \TReal &,& \TInt)\\
      %
      (\ADD  &,& \TReal &,& \TReal)\\
      (\SUB &,& \TReal &,& \TReal)\\
      (\MUL   &,& \TReal &,& \TReal)\\
      (\POW   &,& \TReal &,& \TInt)\\
      (\RDIV  &,& \TReal &,& \TReal)
    \end{array}
    \right\}\\
    \cup \{ (\STRCONCAT, \astlabel(\vtone), \astlabel(\vttwo)) \;|\; \issingular(\vtone) \land \issingular(\vttwo)\}\\
  \end{array}
  }
}{
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \TypeErrorVal{\BadOperands}
}
\end{mathpar}
\CodeSubsection{\applybinoptypesBegin}{\applybinoptypesEnd}{../Typing.ml}

\identr{BKNT} \identr{ZYWY} \identr{BZKW}
\identr{KFYS} \identr{KXMR} \identr{SQXN} \identr{MRHT} \identr{JGWF}
\identr{TTGQ} \identi{YHML} \identi{YHRP} \identi{VMZF} \identi{YXSY}
\identi{LGHJ} \identi{RXLG}

\TypingRuleDef{FindNamedLCA}
\RenderRelation{named_lowest_common_ancestor}
\BackupOriginalRelation{
The function
\[
  \namedlca(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\ty}{\tty} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
returns the lowest common named super type --- $\tty$ --- of the types $\vt$ and $\vs$ in $\tenv$.
} % END_OF_BACKUP_RELATION
\RenderRelation{supers}
\BackupOriginalRelation{
The function
\[
  \supers(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt})
  \aslto \pow{\ty}
\]
returns the set of \emph{named supertypes} of a type $\vt$
in the $\subtypes$ function of a \globalstaticenvironmentterm{} $\tenv$.
} % END_OF_BACKUP_RELATION
\[
  \supers(\tenv, \vt) \triangleq
  \begin{cases}
    \{\vt\} \cup \supers(\vs) & \text{ if }G^\tenv.\subtypes(\vt) = \vs\\
    \{\vt\}  & \text{ otherwise } (\text{that is, }G^\tenv.\subtypes(\vt) = \bot)\\
  \end{cases}
\]

\ExampleDef{Finding Named Lowest Common Ancestors}
In \listingref{find-named-lca},
the set of named supertypes for \verb|B2| is \verb|{A1, A2, B1, B2}|,
set of named supertypes for \verb|C2| is \verb|{A1, A2, C1, C2}|,
therefore the named lowest common ancestor of \verb|B2| and \verb|C2|
is \verb|A2|, while \verb|B2| and \verb|D1| have no
named lowest common ancestor.

\ASLListing{Finding named lowest common ancestors}{find-named-lca}{\typingtests/TypingRule.FindNamedLCA.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item $\vtsupers$ is in the set of named supertypes of $\vt$;
  \item \AllApplyCase{found}
  \begin{itemize}
    \item $\vs$ is in $\vtsupers$;
    \item $\tty$ is $\vs$;
  \end{itemize}

  \item \AllApplyCase{super}
  \begin{itemize}
    \item $\vs$ is not in $\vtsupers$;
    \item $\vs$ has a named super type in $\tenv$ --- $\vsp$;
    \item $\tty$ is the lowest common named \supertypeterm{} of $\vt$ and $\vsp$ in $\tenv$.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is not in $\vtsupers$;
    \item $\vs$ has no named super type in $\tenv$;
    \item $\tty$ is $\None$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[found]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \in \vtsupers
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \vs
}
\and
\inferrule[super]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \not\in \vtsupers\\
  G^\tenv.\subtypes(\vs) = \vsp\\
  \namedlca(\tenv, \vt, \vsp) \typearrow \tty
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \tty
}
\and
\inferrule[none]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \not\in \vtsupers\\
  G^\tenv.\subtypes(\vs) = \bot
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \None
}
\end{mathpar}

\TypingRuleDef{AnnotateConstraintBinop}
\RenderRelation{annotate_constraint_binop}
\BackupOriginalRelation{
The function
\[
\annotateconstraintbinop\left(
  \begin{array}{c}
  \overname{\{\Over,\Under\}}{\vapprox} \aslsep\\
  \overname{\staticenvs}{\tenv} \aslsep\\
  \overname{\binop}{\op} \aslsep\\
  \overname{\KleeneStar{\intconstraint}}{\csone} \aslsep\\
  \overname{\KleeneStar{\intconstraint}}{\cstwo}
  \end{array}
\right) \aslto
\begin{array}{r}
\left(
  \begin{array}{c}
  \overname{\KleeneStar{\intconstraint}}{\annotatedcs} \aslsep\\
  \overname{\precisionlossindicator}{\vp}
  \end{array}
\right)
\\ \cup\ \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates the application of the binary operation $\op$ to the lists of integer constraints
$\csone$ and $\cstwo$, yielding a list of constraints --- $\annotatedcs$.
%
If the list is empty, the result is either $\CannotUnderapproximate$ or $\CannotOverapproximate$,
based on $\vapprox$ (this function is invoked in the context of approximating lists of constraints).
%
\ProseOtherwiseTypeError\
} % END_OF_BACKUP_RELATION

The operator $\op$ is assumed to be only one of the operators in the following set:
$\{\SHL, \SHR, \POW, \MOD, \DIVRM, \SUB, \MUL, \ADD, \DIV\}$.
The rule employs $\binopisexploding$ to decide whether range constraints can be maintained
as range constraints or have to be converted to a list of exact constraints.

\ExampleDef{Annotating Constraints for Binary Operations}
Applying $\ADD$ to
$\{\AbbrevConstraintRange{\ELInt{2}}{\ELInt{4}}\}$ and
$\{\AbbrevConstraintExact{\ELInt{2}}\}$ results in\\
$\{\AbbrevConstraintRange{\ELInt{4}}{\ELInt{6}}\}$,
since $\binopisexploding(\ADD) \typearrow \False$
while applying $\MUL$ to the same lists of constraints results in\\
$\{\AbbrevConstraintExact{\ELInt{4}}, \AbbrevConstraintExact{\ELInt{6}}, \AbbrevConstraintExact{\ELInt{8}}\}$,
since $\binopisexploding(\MUL) \typearrow \True$.

Annotating the constraints involves applying symbolic reasoning and in particular filtering out values that
will definitely result in a \dynamicerrorterm{}.

Also see \ExampleRef{Applying Binary Operations to Constrained Integers}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\binopfilterrhs$ to $\vapprox$, $\op$ $\cstwo$ in $\tenv$, to filter out constraints that will definitely fail dynamically,
        yields $\cstwof$\ProseTerminateAs{\CannotUnderapproximate, \CannotOverapproximate};
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{exploding}
    \begin{itemize}
      \item applying $\binopisexploding$ to $\op$ yields $\True$;
      \item applying $\explodeintervals$ to $\csone$ in $\tenv$ yields $(\csonee \aslsep \vpone)$;
      \item applying $\explodeintervals$ to $\cstwof$ in $\tenv$ yields $(\cstwoe \aslsep \vptwo)$;
      \item applying $\precisionjoin$ to $\vpone$ and $\vptwo$ yields $\vpzero$;
      \item \Proseeqdef{$\vexpectedconstraintlength$}{the number of constraints in \\
            $\cstwoe$ if $\op$ is $\MOD$
            and the multiplication of numbers of constraints in $\csonee$ and $\cstwoe$, respectively};
      \item \Proseeqdef{$(\csonearg, \cstwoarg, \vp)$}{$(\csonee, \cstwoe, \vpzero)$ if \\
            $\vexpectedconstraintlength$ is
            less than $\maxconstraintsize$ and \\
            $(\csone, \cstwof, \PrecisionLost)$, otherwise};
    \end{itemize}

    \item \AllApplyCase{non\_exploding}
    \begin{itemize}
      \item applying $\binopisexploding$ to $\op$ yields $\False$;
      \item \Proseeqdef{$\vp$}{$\PrecisionFull$};
      \item \Proseeqdef{$(\csonearg, \cstwoarg)$}{$(\csone, \cstwof)$};
    \end{itemize}
  \end{itemize}
  \item applying $\constraintbinop$ to $\op$, $\csonearg$, and $\cstwoarg$ yields $\csvanilla$;
  \item applying $\refineconstraintfordiv$ to $\vapprox$, $\op$ and $\csvanilla$ yields\\
        $\refinedcs$\ProseTerminateAs{\CannotUnderapproximate, \CannotOverapproximate};
  \item applying $\reduceconstraints$ to $\refinedcs$ in $\tenv$ yields $\annotatedcs$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exploding]{
  \binopfilterrhs(\vapprox, \tenv, \op, \cstwo) \typearrow \cstwof \terminateas \CannotUnderapproximate, \CannotOverapproximate\\\\
  \commonprefixline\\\\
  \binopisexploding(\op) \typearrow \True\\
  \explodeintervals(\tenv, \csone) \typearrow (\csonee, \vpone)\\
  \explodeintervals(\tenv, \cstwof) \typearrow (\cstwoe, \vptwo)\\
  \vpzero \eqdef \precisionjoin(\vpone, \vptwo)\\
  \vexpectedconstraintlength \eqdef \choice{\op = \MOD}{\listlen{\cstwoe}}{\listlen{\csonee} \times \listlen{\cstwoe}}\\
  {
  (\csonearg, \cstwoarg, \vp) \eqdef \left\{
  \begin{array}{ll}
    \textbf{if }&\vexpectedconstraintlength < \maxconstraintsize\text{ then}\\
    & (\csonee, \cstwoe, \vpzero)\\
    \textbf{else}&\\
    & (\csone, \cstwof, \PrecisionLost )
  \end{array}\right.
  }\\\\
  \commonsuffixline\\\\
  \constraintbinop(\op, \csonearg, \cstwoarg) \typearrow \csvanilla\\
  \refineconstraintfordiv(\vapprox, \op, \csvanilla) \typearrow \refinedcs \terminateas \CannotUnderapproximate,\CannotOverapproximate\\\\
  \reduceconstraints(\tenv, \refinedcs) \typearrow \annotatedcs
}{
  \annotateconstraintbinop(\vapprox, \tenv, \op, \csone, \cstwo) \typearrow \annotatedcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_exploding]{
  \binopfilterrhs(\vapprox, \tenv, \op, \cstwo) \typearrow \cstwof \terminateas \CannotUnderapproximate, \CannotOverapproximate\\\\
  \commonprefixline\\\\
  \binopisexploding(\op) \typearrow \False\\
  \vp \eqdef \PrecisionFull \\
  (\csonearg, \cstwoarg) \eqdef (\csone, \cstwof)\\\\
  \commonsuffixline\\\\
  \constraintbinop(\op, \csonearg, \cstwoarg) \typearrow \csvanilla\\
  \refineconstraintfordiv(\vapprox, \op, \csvanilla) \typearrow \refinedcs \terminateas \CannotUnderapproximate, \CannotOverapproximate\\\\
  \reduceconstraints(\tenv, \refinedcs) \typearrow \annotatedcs
}{
  \annotateconstraintbinop(\vapprox, \tenv, \op, \csone, \cstwo) \typearrow \annotatedcs
}
\end{mathpar}
\CodeSubsection{\AnnotateConstraintBinopBegin}{\AnnotateConstraintBinopEnd}{../StaticOperations.ml}

\TypingRuleDef{BinopFilterRhs}
\RenderRelation{binop_filter_rhs}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\binopfilterrhs(
    \overname{\{\Over,\Under\}}{\vapprox} \aslsep
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\binop}{\op} \aslsep
    \overname{\KleeneStar{\intconstraint}}{\cs})
\aslto \\
\overname{\KleenePlus{\intconstraint}}{\newcs}
\cup \{\CannotUnderapproximate, \CannotOverapproximate\}
\end{array}
\]
filters the list of constraints $\cs$ by removing values that will definitely result in a dynamic
error if found on the right-hand-side of a binary operation expression with the operator $\op$
in any environment consisting of the \staticenvironmentterm{} $\tenv$.
The result is the filtered list of constraints $\newcs$.
%
If the list is empty, the result is either $\CannotUnderapproximate$ or $\CannotOverapproximate$,
based on $\vapprox$ (this function is invoked in the context of approximating lists of constraints).
} % END_OF_BACKUP_RELATION

\ExampleDef{Filtering Right-hand-side Constraints}
An example of filtering constraints appears in \listingref{apply-binop-constraints},
where the constraints inferred for \verb|a_div| filter out \verb|-5..0|
from the constraint \verb|-5..3|, thus avoiding including constraints
\verb|A DIV -5| and \verb|A DIV 0|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{greater\_or\_equal}
  \begin{itemize}
    \item $\op$ is one of $\SHL$, $\SHR$, and $\POW$;
    \item define $\vf$ as the specialization of $\refineconstraintbysign$ for the predicate
          $\lambda x.\ x \geq 0$, which is $\True$ if and only if the tested number is greater or equal to $0$;
    \item refining the list of constraints $\cs$ with $\vf$ and $\vapprox$ via $\refineconstraints$ yields \\
          $\newcs$\ProseTerminateAs{\CannotUnderapproximate, \CannotOverapproximate};
    \item checking whether $\newcs$ is empty yields $\True$\ProseTerminateAs{\BadOperands}.
  \end{itemize}

  \item \AllApplyCase{greater\_than}
  \begin{itemize}
    \item $\op$ is one of $\MOD$, $\DIV$, and $\DIVRM$;
    \item define $\vf$ as the specialization of $\refineconstraintbysign$ for the predicate
          $\lambda x.\ x > 0$, which is $\True$ if and only if the tested number is greater than $0$;
    \item refining the list of constraints $\cs$ with $\vf$ and $\vapprox$ via $\refineconstraints$ yields \\
          $\newcs$\ProseTerminateAs{\CannotUnderapproximate, \CannotOverapproximate};
    \item checking whether $\newcs$ is empty yields $\True$\ProseTerminateAs{\BadOperands}.
  \end{itemize}

  \item \AllApplyCase{no\_filtering}
  \begin{itemize}
    \item $\op$ is one of $\SUB$, $\MUL$, and $\ADD$;
    \item $\newcs$ is $\cs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[greater\_or\_equal]{
  \op \in \{\SHL, \SHR, \POW\}\\\\
  \refineconstraintbysign(\tenv, \lambda x.\ x \geq 0) \typearrow \vf\\
  \refineconstraints(\vapprox, \cs, \vf) \typearrow \newcs \terminateas \CannotUnderapproximate, \CannotOverapproximate\\\\
  \techeck(\newcs \neq \emptylist, \BadOperands) \typearrow \True\OrTypeError
}{
  \binopfilterrhs(\vapprox, \tenv, \op, \cs) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[greater\_than]{
  \op \in \{\MOD, \DIV, \DIVRM\}\\\\
  \vf \eqdef \refineconstraintbysign(\tenv, \lambda x.\ x > 0)\\
  \refineconstraints(\vapprox, \cs, \vf) \typearrow \newcs \terminateas \CannotUnderapproximate, \CannotOverapproximate\\\\
  \techeck(\newcs \neq \emptylist, \BadOperands) \typearrow \True\OrTypeError
}{
  \binopfilterrhs(\vapprox, \tenv, \op, \cs) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_filtering]{
  \op \in \{\SUB, \MUL, \ADD\}
}{
  \binopfilterrhs(\vapprox, \op, \cs) \typearrow \overname{\cs}{\newcs}
}
\end{mathpar}

\TypingRuleDef{RefineConstraintBySign}
\RenderRelation{refine_constraint_by_sign}
\BackupOriginalRelation{
The function
\[
\refineconstraintbysign(\overname{\staticenvs}{\tenv} \aslsep \overname{\Z\rightarrow \Bool}{\vp} \aslsep \overname{\intconstraint}{\vc})
\aslto \overname{\Option{\intconstraint}}{\vcopt}
\]
takes a predicate $\vp$ that returns $\True$ based on the sign of its input.
The function conservatively refines the constraint $\vc$ in $\tenv$ by applying symbolic reasoning to yield a new constraint
(inside an optional)
that represents the values that satisfy the $\vc$ and for which $\vp$ holds.
In this context, conservatively means that the new constraint may represent a superset of the values that a more precise
reasoning may yield.
If the set of those values is empty the result is $\None$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Refining Constraints with a Sign Predicate}
The specification in \listingref{RefineConstraintBySign}
shows examples of how the constraints for \verb|y|
are refined for the \DIV{} operator via the sign predicate
that tests whether an integer is positive: $\lambda x.\ x > 0$.

\ASLListing{Refining Constraints with a Sign Predicate}{RefineConstraintBySign}{\typingtests/TypingRule.RefineConstraintBySign.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact\_reduces\_to\_z}
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\reducetozopt$ to $\ve$ in $\tenv$, in order to symbolically simplify $\ve$ to an integer,
          yields $\some{\vz}$;
    \item $\vcopt$ is $\some{\vc}$ if $\vp$ holds for $\vz$ and $\None$ otherwise.
  \end{itemize}

  \item \AllApplyCase{exact\_does\_not\_reduce\_to\_z}
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\reducetozopt$ to $\ve$ in $\tenv$, in order to symbolically simplify $\ve$ to an integer,
          yields $\None$;
    \item $\vcopt$ is $\some{\vc}$.
  \end{itemize}

  \item \AllApplyCase{range\_both\_reduce\_to\_z}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$, in order to symbolically simplify $\veone$ to an integer,
          yields $\some{\vzone}$;
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$, in order to symbolically simplify $\vetwo$ to an integer,
          yields $\some{\vztwo}$;
    \item \OneApplies{} (defining $\vcopt$)
    \begin{itemize}
      \item if $\vp$ is $\True$ for both $\vzone$ and $\vztwo$, define $\vcopt$ as $\some{\vc}$;
      \item if $\vp$ is $\False$ for $\vzone$ and $\True$ for $\vztwo$, define $\vcopt$ as the optional range constraint
            where the bottom expression is the literal expression for $0$ if $\vp$ holds for $0$ and the literal expression for $1$ otherwise,
            and the top expression is $\vetwo$;
      \item if $\vp$ is $\True$ for $\vzone$ and $\False$ for $\vztwo$, define $\vcopt$ as the optional range constraint
            where the bottom expression is $\veone$ and the top expression is the literal expression for $0$ if $\vp$ holds for $0$
            and the literal expression for $-1$ otherwise;
      \item if $\vp$ is $\False$ for both $\vzone$ and $\vztwo$, define $\vcopt$ as $\None$.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{only\_e1\_reduces\_to\_z}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$, in order to symbolically simplify $\veone$ to an integer,
          yields $\some{\vzone}$;
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$, in order to symbolically simplify $\vetwo$ to an integer,
          yields $\None$;
    \item \OneApplies{} (defining $\vcopt$):
    \begin{itemize}
      \item if $\vp$ is $\True$ for $\vzone$, define $\vcopt$ as $\some{\vc}$;
      \item if $\vp$ is $\False$ for $\vzone$, define $\vcopt$ as the optional range constraint with the bottom expression
            as the literal expression for $0$ if $\vp$ holds for $0$ and the literal expression for $1$ otherwise,
            and the top expression $\vetwo$.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{only\_e2\_reduces\_to\_z}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$, in order to symbolically simplify $\veone$ to an integer,
          yields $\None$;
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$, in order to symbolically simplify $\vetwo$ to an integer,
          yields $\some{\vztwo}$;
    \item One of the following applies (defining $\vcopt$):
    \begin{itemize}
      \item if $\vp$ is $\True$ for $\vztwo$, define $\vcopt$ as $\some{\vc}$;
      \item if $\vp$ is $\False$ for $\vztwo$, define $\vcopt$ as the optional range constraint with the bottom expression
            $\veone$ and the top expression the literal expression for $0$ if $\vp$ holds for $0$ and the literal expression for $-1$ otherwise.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{none\_reduce\_to\_z}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$, in order to symbolically simplify $\veone$ to an integer,
          yields $\None$;
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$, in order to symbolically simplify $\vetwo$ to an integer,
          yields $\None$;
    \item \Proseeqdef{$\vcopt$}{$\vc$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact\_reduces\_to\_z]{
  \reducetozopt(\tenv, \ve) \typearrow \some{\vz}\\
  \vcopt \eqdef \choice{\vp(\vz)}{\some{\vc}}{\None}
}{
  \refineconstraintbysign(\tenv, \vp, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_does\_not\_reduce\_to\_z]{
  \reducetozopt(\tenv, \ve) \typearrow \None
}{
  \refineconstraintbysign(\tenv, \vp, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\some{\vc}}{\vcopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_both\_reduce\_to\_z]{
  \reducetozopt(\tenv, \veone) \typearrow \some{\vzone}\\
  \reducetozopt(\tenv, \vetwo) \typearrow \some{\vztwo}\\
  {
    \begin{array}{c}
  \vcopt \eqdef \\ \wrappedline\ \begin{cases}
    \some{\vc}& \text{if }\vp(\vzone) \land \vp(\vztwo)\\
    \some{\ConstraintRange(\choice{\vp(0)}{\ELInt{0}}{\ELInt{1}}, \vetwo)}& \text{if }\neg\vp(\vzone) \land \vp(\vztwo)\\
    \some{\ConstraintRange(\veone, \choice{\vp(0)}{\ELInt{0}}{\ELInt{-1}})}& \text{if }\vp(\vzone) \land \neg\vp(\vztwo)\\
    \None& \text{if }\neg\vp(\vzone) \land \neg\vp(\vztwo)\\
  \end{cases}
\end{array}
  }
}{
  \refineconstraintbysign(\tenv, \vp, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[only\_e1\_reduces\_to\_z]{
  \vc = \ConstraintRange(\veone, \vetwo)\\
  \reducetozopt(\tenv, \veone) \typearrow \some{\vzone}\\
  \reducetozopt(\tenv, \vetwo) \typearrow \None\\
  {
    \begin{array}{c}
  \vcopt \eqdef \\ \wrappedline\ \begin{cases}
    \some{\vc}& \text{if }\vp(\vzone)\\
    \some{\ConstraintRange(\choice{\vp(0)}{\ELInt{0}}{\ELInt{1}}, \vetwo)}& \text{else}\\
  \end{cases}
\end{array}
  }
}{
  \refineconstraintbysign(\tenv, \vp, \vc) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[only\_e2\_reduces\_to\_z]{
  \vc = \ConstraintRange(\veone, \vetwo)\\
  \reducetozopt(\tenv, \veone) \typearrow \None\\
  \reducetozopt(\tenv, \vetwo) \typearrow \some{\vztwo}\\
  {
    \begin{array}{c}
  \vcopt \eqdef \\ \wrappedline\ \begin{cases}
    \some{\vc}& \text{if }\vp(\vztwo)\\
    \some{\ConstraintRange(\veone, \choice{\vp(0)}{\ELInt{0}}{\ELInt{-1}})}& \text{else}\\
  \end{cases}
\end{array}
  }
}{
  \refineconstraintbysign(\tenv, \vp, \vc) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[none\_reduce\_to\_z]{
  \vc = \ConstraintRange(\veone, \vetwo)\\
  \reducetozopt(\tenv, \veone) \typearrow \None\\
  \reducetozopt(\tenv, \vetwo) \typearrow \None
}{
  \refineconstraintbysign(\tenv, \vp, \vc) \typearrow \overname{\vc}{\vcopt}
}
\end{mathpar}

\TypingRuleDef{ReduceToZOpt}
\RenderRelation{reduce_to_z_opt}
\BackupOriginalRelation{
The function
\[
\reducetozopt(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve})
\aslto \overname{\Option{\Z}}{\vzopt}
\]
returns an integer inside an optional if $\ve$ can be symbolically simplified into an integer in $\tenv$
and $\None$ otherwise.
The expression $\ve$ is assumed not to yield a \typingerrorterm{}
when applying $\normalize$ to it.
} % END_OF_BACKUP_RELATION

\ExampleDef{Reducing Expressions to Optional Integers}
The specification in \listingref{ReduceToZOpt} shows two examples of expressions
where one can be reduced into an integer constant, which is then returned in an optional,
and one that cannot be reduced into an integer constant, which yields $\None$.
\ASLListing{Reducing expressions to optional integers}{ReduceToZOpt}{\typingtests/TypingRule.ReduceToZOpt.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{normalizes\_to\_z}
  \begin{itemize}
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields a literal expression for the integer $\vz$;
    \item define $\vzopt$ as $\some{\vz}$.
  \end{itemize}

  \item \AllApplyCase{does\_not\_normalize\_to\_z}
  \begin{itemize}
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields an expression that is not an integer literal;
    \item define $\vzopt$ as $\None$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[normalizes\_to\_z]{
  \normalize(\tenv, \ve) \typearrow \ELInt{\vz}
}{
  \reducetozopt(\tenv, \ve) \typearrow \overname{\some{\vz}}{\vzopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[does\_not\_normalize\_to\_z]{
  \normalize(\tenv, \ve) \typearrow \vep\\
  \forall \vz\in\Z.\ \vep \neq \ELInt{\vz}
}{
  \reducetozopt(\tenv, \ve) \typearrow \overname{\None}{\vzopt}
}
\end{mathpar}

\TypingRuleDef{RefineConstraints}
\RenderRelation{refine_constraints}
\BackupOriginalRelation{
The function
\[
\refineconstraints\left(
  \begin{array}{c}
  \overname{\{\Over,\Under\}}{\vapprox} \aslsep\\
  \overname{\staticenvs}{\tenv} \aslsep\\
  \overname{\intconstraint\rightarrow\Option{\intconstraint}}{\vf} \aslsep\\
  \overname{\KleeneStar{\intconstraint}}{\cs}
  \end{array}
  \right)
\aslto
\begin{array}{ll}
\overname{\KleeneStar{\intconstraint}}{\newcs} & \cup\\
\{\CannotUnderapproximate, \CannotOverapproximate\}
\end{array}
\]
refines a list of constraints $\cs$ by applying the refinement function $\vf$ to each constraint and retaining the constraints
that do not refine to $\None$. The resulting list of constraints is given in $\newcs$.
%
If the list is empty, the result is either $\CannotUnderapproximate$ or $\CannotOverapproximate$,
based on $\vapprox$ (this function is invoked in the context of approximating lists of constraints).
} % END_OF_BACKUP_RELATION

\ExampleDef{Filtering Optional Constraints}
The specification in \listingref{RefineConstraintBySign}
shows how certain constraints are filtered out.
For example, $\AbbrevConstraintExact{\AbbrevEBinop{\DIV}{\AbbrevEVar{\vA}}{\ELInt{0}}}$.
Similarly, since both expressions in the constraint \verb|-4..-3| fail the sign predicate
used by $\refineconstraintbysign$, the resulting $\None$ is also filtered out.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\cs$ is the empty list;
    \item $\newcs$ is the empty list.
  \end{itemize}

  \item \AllApply
  \begin{itemize}
    \item $\cs$ is the list with $\vc$ as its \head\ and $\csone$ as its \tail;
    \item applying $\vf$ to $\vc$ yields $\None$;
    \item applying $\refineconstraints$ to $\vapprox$, $\vf$ and $\csone$ yields $\csonep$;
    \item \OneApplies
    \begin{itemize}
      \item \AllApplyCase{non\_empty\_none\_precise}
      \begin{itemize}
        \item $\csonep$ is not the empty list;
        \item $\newcs$ is $\csonep$.
      \end{itemize}

      \item \AllApplyCase{non\_empty\_none\_approx}
      \begin{itemize}
        \item $\csonep$ is not the empty list;
        \item the result is $\CannotOverapproximate$ if $\vapprox$ is $\Over$ and $\CannotUnderapproximate$, otherwise.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{non\_empty\_some}
  \begin{itemize}
    \item $\cs$ is the list with $\vc$ as its \head\ and $\csone$ as its \tail;
    \item applying $\vf$ to $\vc$ yields $\some{\vcp}$;
    \item applying $\refineconstraints$ to $\vapprox$, $\vf$ and $\csone$ yields $\csonep$;
    \item $\newcs$ is the list with $\vcp$ as its \head\ and $\csonep$ as its \tail.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \refineconstraints(\vapprox, \tenv, \vf, \overname{\emptylist}{\cs}) \typearrow \overname{\emptylist}{\newcs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty\_none\_precise]{
  \vf(\vc) \typearrow \None\\
  \refineconstraints(\vapprox, \vf, \csone) \typearrow \csonep\\
  \csonep \neq \emptylist
}{
  \refineconstraints(\vapprox, \vf, \overname{[\vc]\concat \csone}{\cs}) \typearrow \overname{\csonep}{\newcs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty\_none\_approx]{
  \vf(\vc) \typearrow \None\\
  \refineconstraints(\vapprox, \vf, \csone) \typearrow \csonep\\
  \csonep = \emptylist
}{
  \refineconstraints(\vapprox, \vf, \overname{[\vc]\concat \csone}{\cs}) \typearrow \choice{\vapprox=\Over}{\CannotOverapproximate}{\CannotUnderapproximate}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty\_some]{
  \vf(\vc) \typearrow \some{\vcp}\\
  \refineconstraints(\vapprox, \vf, \csone) \typearrow \csonep\\
}{
  \refineconstraints(\vapprox, \vf, \overname{[\vc]\concat \csone}{\cs}) \typearrow \overname{[\vcp] \concat \csonep}{\newcs}
}
\end{mathpar}

\TypingRuleDef{RefineConstraintForDiv}
\RenderRelation{refine_constraint_for_div}
\BackupOriginalRelation{
The function
\[
\refineconstraintfordiv\left(
  \begin{array}{c}
  \overname{\{\Over,\Under\}}{\vapprox} \aslsep\\
  \overname{\binop}{\op} \aslsep\\
  \overname{\KleeneStar{\intconstraint}}{\cs}
  \end{array}
  \right) \aslto
  \begin{array}{ll}
  \overname{\KleeneStar{\intconstraint}}{\vres} & \cup\\
  \{\CannotUnderapproximate, \CannotOverapproximate\} &
  \end{array}
\]
filters the list of constraints $\cs$ for $\op$,
removing constraints that represents a division operation that will definitely fail
when $\op$ is the division operation.
%
If the list is empty, the result is either $\CannotUnderapproximate$ or $\CannotOverapproximate$,
based on $\vapprox$ (this function is invoked in the context of approximating lists of constraints).
} % END_OF_BACKUP_RELATION

See \ExampleRef{Filtering and Reducing Division-based Constraints}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApply
  \begin{itemize}
    \item $\op$ is $\DIV$;
    \item applying $\filterreduceconstraintdiv$ to each constraint $\cs[\vi]$, for each $\vi$ in $\listrange(\cs)$,
          yields the optional constraint $\vcopt_\vi$\ProseOrTypeError;
    \item define $\vres$ as the list made of constraints $\vcp_\vi$, for each $\vi$ in $\listrange(\cs)$
          such that $\vcopt_\vi = \some{\vcp_\vi}$;
    \item \OneApplies
    \begin{itemize}
      \item \AllApplyCase{div\_non\_empty}
      \begin{itemize}
        \item $\vres$ is not the empty list;
      \end{itemize}

      \item \AllApplyCase{div\_empty}
      \begin{itemize}
        \item $\vres$ is the empty list;
        \item the result is $\CannotOverapproximate$ if $\vapprox$ is $\Over$ and $\CannotUnderapproximate$, otherwise.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{non\_div}
  \begin{itemize}
    \item $\op$ is not $\DIV$;
    \item define $\vres$ as $\cs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[div\_non\_empty]{
  \op = \DIV\\
  \vi\in\listrange(\cs): \filterreduceconstraintdiv(\cs[\vi]) \typearrow \vcopt_\vi \OrTypeError\\\\
  \vres \eqdef [\vi\in\listrange(\cs): \choice{\vcopt_\vi = \some{\vcp_\vi}}{\vcp}{\epsilon}]\\
  \vres \neq \emptylist
}{
  \refineconstraintfordiv(\vapprox, \op, \cs) \typearrow \vres
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_empty]{
  \op = \DIV\\
  \vi\in\listrange(\cs): \filterreduceconstraintdiv(\cs[\vi]) \typearrow \vcopt_\vi \OrTypeError\\\\
  \vres \eqdef [\vi\in\listrange(\cs): \choice{\vcopt_\vi = \some{\vcp_\vi}}{\vcp}{\epsilon}]\\
  \vres = \emptylist\\
}{
  \refineconstraintfordiv(\vapprox, \op, \cs) \typearrow \choice{\vapprox=\Over}{\CannotOverapproximate}{\CannotUnderapproximate}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_div]{
  \op \neq \DIV
}{
  \refineconstraintfordiv(\vapprox, \op, \cs) \typearrow \overname{\cs}{\vres}
}
\end{mathpar}
\CodeSubsection{\RefineConstraintForDIVBegin}{\RefineConstraintForDIVEnd}{../types.ml}

\TypingRuleDef{FilterReduceConstraintDiv}
\RenderRelation{filter_reduce_constraint_div}
\BackupOriginalRelation{
The function
\[
\filterreduceconstraintdiv(
  \overname{\intconstraint}{\vc}) \aslto
  \overname{\Option{\intconstraint}}{\vcopt}
\]
returns $\None$ if $\vc$ is an exact constraint for a \binopexpressionterm{} for dividing two integer literals
where the denominator does not divide the numerator, and an optional containing $\vc$ otherwise.
The result is returned in $\vcopt$.
This is used to conservatively test whether $\vc$ would always fail dynamically.
} % END_OF_BACKUP_RELATION

\ExampleDef{Filtering and Reducing Division-based Constraints}
The specification in \listingref{FilterReduceConstraintDiv}
shows how different constraints formed by dividing the constraints of \verb|x| by \verb|2|
in order to annotate \verb|z|.
The resulting constraints are listed in the type annotation for \verb|z_typed|.
Specifically, notice the following:
\begin{itemize}
  \item the constraint for \verb|3| divided by \verb|2| is filtered away,
        since the result is not an integer,
  \item the constraint for \verb|7..10| divided by \verb|2|
        effectively rounds up $7/2$ into \verb|3|,
  \item the constraint for \verb|14..17| divided by \verb|2| effectively rounds down
        $17/2$ into \verb|16|, and
  \item the constraint for \verb|16..15| divided by \verb|2| is filtered away,
        since it is not a legal \rangeconstraintterm.
\end{itemize}
\ASLListing{Filtering and Reducing Division-based Constraints}{FilterReduceConstraintDiv}{\typingtests/TypingRule.FilterReduceConstraintDiv.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\getliteraldivopt$ to $\ve$ yields $\some{(\vzone, \vztwo)}$\ProseTerminateAs{\None};
    \item define $\vcopt$ as follows:
    \begin{itemize}
      \item $\None$, if $\vztwo$ is positive and $\vztwo$ does not divide $\vzone$;
      \item $\some{\vc}$, otherwise.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is a range constraint for $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\getliteraldivopt$ to $\veone$ yields $\veoneopt$;
    \item define $\vzoneopt$ as follows:
    \begin{itemize}
      \item $\vzone$ divided by $\vztwo$ and rounded up, if $\veoneopt$ is $(\vzone, \vztwo)$ and $\vztwo$ is positive;
      \item $\None$, otherwise.
    \end{itemize}
    \item applying $\getliteraldivopt$ to $\vetwo$ yields $\vetwoopt$;
    \item define $\vztwoopt$ as follows:
    \begin{itemize}
      \item $\vzthree$ divided by $\vzfour$ and rounded down, if $\vetwoopt$ is $(\vzthree, \vzfour)$ and $\vzfour$ is positive;
      \item $\None$, otherwise.
    \end{itemize}
    \item define $\vcopt$ as follows:
    \begin{itemize}
      \item the exact constraint for the literal integer $\vzfive$, if $\vzoneopt$ is $\some{\vzfive}$ and $\vztwoopt$ is $\some{\vzsix}$ and $\vzfive$ is equal to $\vzsix$;
      \item the range constraint for the literal integer $\vzfive$ and $\vzsix$, if $\vzoneopt$ is $\some{\vzfive}$ and $\vztwoopt$ is $\some{\vzsix}$ and $\vzfive$ is less than $\vzsix$;
      \item $\None$, if $\vzoneopt$ is $\some{\vzfive}$ and $\vztwoopt$ is $\some{\vzsix}$ and $\vzfive$ is greater than $\vzsix$;
      \item the range constraint for the literal integer $\vzfive$ and $\vetwo$, if $\vzoneopt$ is $\some{\vzfive}$ and $\vztwoopt$ is $\None$;
      \item the range constraint for $\veone$ and the literal integer $\vzsix$, if $\vzoneopt$ is $\None$ and $\vztwoopt$ is $\some{\vzsix}$;
      \item $\vc$ if $\vzoneopt$ is $\None$ and $\vztwoopt$ is $\None$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \getliteraldivopt(\ve) \typearrow \some{(\vzone, \vztwo)} \terminateas \None\\\\
  {
    \vcopt \eqdef
    \begin{cases}
      \None & \text{if }\vztwo > 0 \land \frac{\vzone}{\vztwo} \not\in \Z\\
      \some{\vc} & \text{else}
    \end{cases}
  }
}{
  \filterreduceconstraintdiv(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \getliteraldivopt(\veone) \typearrow \veoneopt\\
  {
    \vzoneopt \eqdef
    \begin{cases}
      \left\lceil\frac{\vzone}{\vztwo}\right\rceil & \text{if }\veoneopt = \some{(\vzone, \vztwo)} \land \vztwo > 0\\
      \None & \text{else}
    \end{cases}
  }\\
  \getliteraldivopt(\vetwo) \typearrow \vetwoopt\\
  {
    \vztwoopt \eqdef
    \begin{cases}
      \left\lfloor\frac{\vzthree}{\vzfour}\right\rfloor & \text{if }\vetwoopt = \some{(\vzthree, \vzfour)} \land \vzfour > 0\\
      \None & \text{else}
    \end{cases}
  }\\
  {
    \vcopt \eqdef
    \begin{cases}
     \some{\AbbrevConstraintExact{\ELInt{\vzfive}}} & \text{if }\vzoneopt = \some{\vzfive} \land \vztwoopt = \some{\vzsix} \land \vzfive=\vzsix\\
     \some{\AbbrevConstraintRange{\ELInt{\vzfive}}{\ELInt{\vzsix}}} & \text{if }\vzoneopt = \some{\vzfive} \land \vztwoopt = \some{\vzsix} \land \vzfive<\vzsix\\
     \None & \text{if }\vzoneopt = \some{\vzfive} \land \vztwoopt = \some{\vzsix} \land \vzfive>\vzsix\\
     \some{\AbbrevConstraintRange{\ELInt{\vzfive}}{\vetwo}} & \text{if }\vzoneopt = \some{\vzfive} \land \vztwoopt = \None\\
     \some{\AbbrevConstraintRange{\veone}{\ELInt{\vzsix}}} & \text{if }\vzoneopt = \None \land \vztwoopt = \some{\vzsix}\\
     \some{\AbbrevConstraintRange{\veone}{\vetwo}} & \text{if }\vzoneopt = \None \land \vztwoopt = \None\\
    \end{cases}
  }
}{
  \filterreduceconstraintdiv(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\some{\vc}}{\vcopt}
}
\end{mathpar}

\TypingRuleDef{GetLiteralDivOpt}
\RenderRelation{get_literal_div_opt}
\BackupOriginalRelation{
The function
\[
\getliteraldivopt(\overname{\expr}{\ve}) \aslto \overname{\Option{(\Z\cartimes\Z)}}{\rangeopt}
\]
matches the expression $\ve$ to a binary operation expression over the division operation and two literal integer expressions.
If $\ve$ matches this pattern, the result $\rangeopt$ is an optional containing the pair of integers appearing in the operand
expressions. Otherwise, the result is $\None$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Obtaining Division Expressions Optionally Resulting in Literals}
In \listingref{FilterReduceConstraintDiv},
the following are examples of $\getliteraldivopt$ applications that are used
for generating the constraints for \verb|z|:
\[
\begin{array}{rcl}
\getliteraldivopt(\AbbrevEBinop{\DIV}{\ELInt{14}}{\ELInt{2}}) &\typearrow& \some{(14, 2)}\\
\getliteraldivopt(\AbbrevEBinop{\DIV}{\ELInt{7}}{\ELInt{2}}) &\typearrow& \some{(7, 2)}\\
\getliteraldivopt(\AbbrevEBinop{\DIV}{\AbbrevEVar{\vA}}{\ELInt{2}}) &\typearrow& \None\\
\end{array}
\]

\ProseParagraph
The value $\rangeopt$ is $\some{(\vzone, \vztwo)}$ if $\ve$ is a binary operation expression over the division operation
and two literal integer expressions for the integers $\vzone$ and $\vztwo$ and $\None$ otherwise.

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \rangeopt \eqdef \choice{\ve = \AbbrevEBinop{\DIV}{\ELInt{\vzone}}{\ELInt{\vztwo}}}{\some{(\vzone, \vztwo)}}{\None}
}{
  \getliteraldivopt(\ve) \typearrow \rangeopt
}
\end{mathpar}

\TypingRuleDef{ExplodeIntervals}
\RenderRelation{explode_intervals}
\BackupOriginalRelation{
The function
\[
\explodeintervals(\overname{\staticenvs}{\tenv} \aslsep \overname{\KleeneStar{\intconstraint}}{\cs})
\aslto \left( \overname{\KleeneStar{\intconstraint}}{\newcs} \aslsep \overname{\precisionlossindicator}{\vp} \right)
\]
applies $\explodedinterval$ to each constraint of $\cs$ in $\tenv$, and returns
a pair consisting of the list of exploded constraints in $\newcs$ and a
\precisionlossindicatorterm{} $\vp$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Exploding Intervals}
In \listingref{ExplodeIntervals}, annotating the constraints for \verb|y|
involves exploding each of the constraints for \verb|{C..0, 0..A}|,
which does not incur a precision loss.
On the other hand, annotating the constraints for \verb|z|
involves exploding each of the constraints for \verb|C..0, 0..B|
where exploding the first constraint \verb|C..0| does not incur precision loss,
but exploding the second constraint \verb|0..B| does incur precision loss,
and so overall the result is that there is precision loss.
\ASLListing{Exploding intervals}{ExplodeIntervals}{\typingtests/TypingRule.ExplodeIntervals.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\cs$ is the empty list;
    \item $\newcs$ is the empty list;
    \item $\vp$ is $\PrecisionFull$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\cs$ is the list with $\vc$ as its \head\ and $\csone$ as its \tail;
    \item applying $\explodeconstraint$ to $\vc$ in $\tenv$ yields $\vcp$ (a list of constraints);
    \item applying $\explodeintervals$ to $\csone$ in $\tenv$ yields $\csonep$;
    \item $\newcs$ is the concatenation of $\vcp$ and $\csonep$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \explodeintervals(\tenv, \overname{\emptylist}{\cs}) \typearrow \left( \overname{\emptylist}{\newcs} \aslsep \overname{\PrecisionFull}{\vp} \right)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \explodeconstraint(\tenv, \vc) \typearrow (\vcp, \vpone)\\
  \explodeintervals(\tenv, \csone) \typearrow (\csonep, \vptwo)\\
  \vp \eqdef \precisionjoin(\vpone, \vptwo)\\
  \newcs \eqdef \vcp \concat \csonep\\
}{
  \explodeintervals(\tenv, \overname{[\vc] \concat \csone}{\cs}) \typearrow (\newcs, \vp)
}
\end{mathpar}

\TypingRuleDef{ExplodeConstraint}
\RenderRelation{explode_constraint}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\explodeconstraint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\intconstraint}{\vc})
\aslto \\
(\overname{\KleeneStar{\intconstraint}}{\vcs}, \overname{\precisionlossindicator}{\newprec})
\end{array}
\]
given the \staticenvironmentterm{} $\tenv$ and the constraint $\vc$,
expands $\vc$ into the equivalent list of exact constraints if
$\vc$ matches an ascending range constraint that is not too large,
and the singleton list for $\vc$ otherwise.
The resulting list of constraints and the \precisionlossindicatorterm{}
are in $\vcs$ and $\newprec$, respectively.
} % END_OF_BACKUP_RELATION

See \ExampleRef{Intervals too Large to Enumerate}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an exact constraint;
    \item $\vcs$ is the singleton list for $\vc$;
    \item \Proseeqdef{$\newprec$}{$\PrecisionFull$}.
  \end{itemize}

  \item \AllApplyCase{range\_reduced}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\va$ and $\vb$;
    \item applying $\reducetozopt$ to $\va$ in $\tenv$ yields $\some{\vza}$;
    \item applying $\reducetozopt$ to $\vb$ in $\tenv$ yields $\some{\vzb}$;
    \item define $\explodedinterval$ as the list of exact constraints for each integer literal in the range starting
          at $\vza$ and ending at $\vzb$, inclusively, which is empty if $\vzb < \vza$;
    \item applying $\intervaltoolarge$ to $\vza$ and $\vzb$ yields $\vbtoolarge$;
    \item define $(\vcs, \newprec)$ as
          the singleton list for $\vc$ and $\PrecisionLost$ if \\
          $\vbtoolarge$ is $\True$
          and $\explodedinterval$ and $\PrecisionFull$ otherwise.
  \end{itemize}

  \item \AllApplyCase{range\_not\_reduced}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\va$ and $\vb$;
    \item applying $\reducetozopt$ to $\va$ in $\tenv$ yields $\vzaopt$;
    \item applying $\reducetozopt$ to $\vb$ in $\tenv$ yields $\vzbopt$;
    \item at least one of $\vzaopt$ and $\vzbopt$ is $\None$;
    \item $\vcs$ is the singleton list for $\vc$;
    \item \Proseeqdef{$\newprec$}{$\PrecisionFull$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \astlabel(\vc) = \ConstraintExact
}{
  \explodeconstraint(\tenv, \vc) \typearrow
  (\overname{[\vc]}{\vcs}, \overname{\PrecisionFull}{\newprec})
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_reduced]{
  \vc = \ConstraintRange(\va, \vb)\\
  \reducetozopt(\tenv, \va) \typearrow \some{\vza}\\
  \reducetozopt(\tenv, \vb) \typearrow \some{\vzb}\\
  \explodedinterval \eqdef [\vz \in \vza..\vzb: \ConstraintExact(\ELInt{\vz})]\\
  \intervaltoolarge(\vza, \vzb) \typearrow \vbtoolarge\\
  {
  (\vcs, \newprec) \eqdef
  \begin{cases}
    ([\vc], \PrecisionLost) & \text{ if } \vbtoolarge\\
    ([\explodedinterval], \PrecisionFull) & \text{ else}
  \end{cases}
  }
}{
  \explodeconstraint(\tenv, \vc) \typearrow (\vcs, \newprec)
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_not\_reduced]{
  \vc = \ConstraintRange(\va, \vb)\\
  \reducetozopt(\tenv, \va) \typearrow \vzaopt\\
  \reducetozopt(\tenv, \vb) \typearrow \vzbopt\\
  \vzaopt = \None \lor \vzbopt = \None
}{
  \explodeconstraint(\tenv, \vc) \typearrow
  (\overname{[\vc]}{\vcs}, \overname{\PrecisionFull}{\newprec})
}
\end{mathpar}

\TypingRuleDef{IntervalTooLarge}
\RenderRelation{interval_too_large}
\BackupOriginalRelation{
The function
\[
\intervaltoolarge(\overname{\Z}{\vzone} \aslsep \overname{\Z}{\vztwo}) \aslto \overname{\Bool}{\vb}
\]
determines whether the set of numbers between $\vzone$ and $\vztwo$, inclusive, contains more than $\maxexplodedintervalsize$
integers, yielding the result in $\vb$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Intervals too Large to Enumerate}
In \listingref{IntervalTooLarge}, the size of the interval used to annotate
\verb|z| is less than $\maxexplodedintervalsize$.
\ASLListing{An enumerated interval}{IntervalTooLarge}{\typingtests/TypingRule.IntervalTooLarge.asl}

In \listingref{IntervalTooLarge-bad}, the size of the interval used to annotate
\verb|y| is just below $\maxexplodedintervalsize$, but the size of the interval
used to annotate \verb|z| is equal to $\maxexplodedintervalsize$, which is too
large to be enumerated.
\ASLListing{An interval too large to enumerate}{IntervalTooLarge-bad}{\typingtests/TypingRule.IntervalTooLarge.bad.asl}

\ProseParagraph
The value $\vb$ is $\True$ if and only if the absolute value of $\vzone-\vztwo$ is greater than $\maxexplodedintervalsize$.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \intervaltoolarge(\vzone, \vztwo) \typearrow \overname{\vztwo-\vzone > \maxexplodedintervalsize}{\vb}
}
\end{mathpar}

\TypingRuleDef{BinopIsExploding}
\RenderRelation{binop_is_exploding}
\BackupOriginalRelation{
The function
\[
\binopisexploding(\overname{\binop}{\op}) \aslto \overname{\Bool}{\vb}
\]
determines whether the binary operation $\op$ should lead to applying $\explodeintervals$
when the $\op$ is applied to a pair of constraint lists.
It is assumed that $\op$ is one of $\MUL$, $\SHL$, $\POW$, $\ADD$, $\DIV$, $\SUB$, $\MOD$, $\SHR$,
and $\DIVRM$.
} % END_OF_BACKUP_RELATION

See \ExampleRef{Annotating Constraints for Binary Operations}.

\ProseParagraph
The value $\vb$ is $\True$ if and only if $\op$ is one of $\MUL$, $\SHL$, and $\POW$.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \binopisexploding(\op) \typearrow \overname{\op \in \{\MUL, \SHL, \POW, \DIV, \DIVRM, \MOD, \SHR\}}{\vb}
}
\end{mathpar}

\TypingRuleDef{BitFieldsIncluded}
\RenderRelation{bitfields_included}
\BackupOriginalRelation{
The predicate
\[
  \bitfieldsincluded(\overname{\staticenvs}{\tenv}, \overname{\KleeneStar{\bitfield}}{\bfsone} \aslsep \overname{\KleeneStar{\bitfield}}{\bfstwo})
  \aslto \overname{\Bool}{\vb} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
tests whether the set of bit fields $\bfsone$ is included in the set of bit fields $\bfstwo$ in environment $\tenv$,
returning a \typingerrorterm{}, if one is detected.
}

\ExampleDef{Checking Whether all Bitfields are Included}
In \listingref{MemBfs},
all bitfields of the type \\
\verb|bits(8) {[0] flag, [7:1] data { [2:0] low }}|
are included in the type \\
\verb|FlaggedPacket|.

In \listingref{MemBfs-bad}, not all bitfields of the type \verb|bits(8) {[0] flag, [1] lsb}|
are included in the type \verb|FlaggedPacket|. Specifically, the bitfield \verb|lsb| is
not included in \verb|FlaggedPacket|.

\ProseParagraph
\AllApply
\begin{itemize}
  \item checking whether each field $\vbf$ in $\bfsone$ exists in $\bfstwo$ via $\membfs$ yields $\vb_\vbf$\ProseOrTypeError;
  \item the result --- $\vb$ --- is the conjunction of $\vb_\vbf$ for all bitfields $\vbf$ in $\bfsone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vbf \in \bfsone: \membfs(\bfstwo, \vbf) \typearrow \vb_\vbf \OrTypeError\\\\
  \vbf \eqdef \bigwedge_{\bf \in \bfsone} \vb_\vbf
}{
  \bitfieldsincluded(\tenv, \bfsone, \bfstwo) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{MemBfs}
\RenderRelation{mem_bfs}
\BackupOriginalRelation{
The function
\[
  \membfs(\overname{\staticenvs}{\tenv} \aslsep \overname{\KleenePlus{\bitfield}}{\bfstwo} \aslsep \overname{\bitfield}{\vbfone})
  \aslto \overname{\Bool}{\vb}
\]
checks whether the bitfield $\vbf$ exists in $\bfstwo$ in the context of $\tenv$, returning the result in $\vb$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Checking Bitfield Membership}
The specification in \listingref{MemBfs} is well-typed.
Specifically, the bitfield \verb|flag| in the type
\verb|bits(8) {[0] flag, [7:1] data { [2:0] low }}|
is a member of the set of bitfields in the type \verb|FlaggedPacket|.
\ASLListing{No missing bitfields}{MemBfs}{\typingtests/TypingRule.MemBfs.asl}

In \listingref{MemBfs-bad}, the bitfield \verb|lsb| is missing from
the set of bitfields in the type \verb|FlaggedPacket|, which is why the specification
is ill-typed.
\ASLListing{A missing bitfield}{MemBfs-bad}{\typingtests/TypingRule.MemBfs.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\None$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item \AllApplyCase{simple\_any}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item \AllApplyCase{nested\_simple}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item \AllApplyCase{nested\_nested}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a nested bitfield with name $\nameone$, slices $\sliceone$, and $\bfsone$;
    \item $\vbone$ is true if and only if $\nameone$ is equal to $\nametwo$;
    \item symbolically equating the slices $\slicesone$ and $\slicestwo$ in $\tenv$ yields $\vbtwo$;
    \item checking $\bfsone$ is included in $\bfstwop$ in the context of $\tenv$ yields $\vbthree$;
    \item $\vb$ is defined as the conjunction of $\vbone$, $\vbtwo$, and $\vbthree$.
  \end{itemize}

  \item \AllApplyCase{nested\_typed}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a typed bitfield;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item \AllApplyCase{typed\_simple}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item \AllApplyCase{typed\_nested}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a nested bitfield;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item \AllApplyCase{typed\_typed}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a typed bitfield with name $\nameone$, slices $\slicesone$, and type $\ttyone$;
    \item $\vbone$ is true if and only if $\nameone$ is equal to $\nametwo$;
    \item symbolically equating the slices $\slicesone$ and $\slicestwo$ in $\tenv$ yields $\vbtwo$;
    \item checking whether $\ttyone$ subtypes $\ttytwo$ in $\tenv$ yields $\vbthree$;
    \item $\vb$ is defined as the conjunction of $\vbone$, $\vbtwo$, and $\vbthree$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{
  \bitfieldgetname(\vbfone) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \None
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \False
}
\and
\inferrule[simple\_any]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \some{ \vbftwo }\\
  \astlabel(\vbftwo) = \BitFieldSimple\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested\_simple]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \some{ \vbftwo }\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \vbfone = \BitFieldSimple(\Ignore)\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[nested\_nested]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \some{ \vbftwo }\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \vbfone = \BitFieldNested(\nameone, \slicesone, \bfsone)\\
  \vbone \eqdef \nameone = \nametwo\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \bitfieldsincluded(\tenv, \bfsone, \bfstwop) \typearrow \vbthree\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\and
\inferrule[nested\_typed]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \some{ \vbftwo }\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \astlabel(\vbfone) = \BitFieldType
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[typed\_simple]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \some{ \vbftwo }\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \vbfone = \BitFieldSimple(\Ignore)\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\and
\inferrule[typed\_nested]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \some{ \vbftwo }\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \astlabel(\vbfone) = \BitFieldNested
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[typed\_typed]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \some{ \vbftwo }\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \vbfone = \BitFieldType(\nameone, \slicesone, \ttyone)\\
  \vbone \eqdef \nameone = \nametwo\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \subtypesatisfies(\tenv, \ttyone, \ttytwo) \typearrow \vbthree \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{CheckStructure}
\RenderRelation{check_structure_label}
\BackupOriginalRelation{
The function
\[
  \checkstructurelabel(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ASTLabels}{\vl}) \aslto
  \{\True\} \cup \typeerror
\]
returns $\True$ is $\vt$ is has the \structureterm\ a of type corresponding to the AST label $\vl$ and a \typingerrorterm{} otherwise.
} % END_OF_BACKUP_RELATION

See \ExampleRef{The Structure of a Type}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item determining the \structureterm\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ has the label $\vl$;
    \item the result is $\True$;
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item determining the \structureterm\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ does not have the label $\vl$;
    \item the result is a \typingerrorterm{} indicating that $\vt$ was expected to have the \structureterm\ of a type with the AST label $\vl$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\vt) \typearrow \vtp \OrTypeError\\\\
  \astlabel(\vtp) = \vl
}
{
  \checkstructurelabel(\tenv, \vt, \vl) \typearrow \True
}
\and
\inferrule[error]{
  \tstruct(\vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \vl
}
{
  \checkstructurelabel(\tenv, \vt, \vl) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}

\TypingRuleDef{ToWellConstrained}
\RenderRelation{to_well_constrained}
\BackupOriginalRelation{
The function
\[
  \towellconstrained(\overname{\ty}{\vt}) \aslto \overname{\ty}{\vtp}
\]
returns the \wellconstrainedversionterm\ of a type $\vt$ --- $\vtp$,
which converts \parameterizedintegertypesterm{} to \wellconstrainedintegertypesterm{},
and leaves all other types as are.
} % END_OF_BACKUP_RELATION

\ExampleDef{Converting Parameterized Integer Types to Well-constrainted Integer Types}
The following table shows examples of applying $\towellconstrained$ to various types:
\[
\begin{array}{rl}
\textbf{input type}           & \textbf{output type}\\
\hline
\TInt(\Parameterized(\vx))    & \TInt(\WellConstrained(\ConstraintExact(\EVar(\vx))))\\
\TInt(\unconstrainedinteger)  & \TInt(\unconstrainedinteger)\\
\TReal                        & \TReal\\
\end{array}
\]

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{t\_int\_parameterized}
  \begin{itemize}
    \item $\vt$ is a \parameterizedintegertypeterm\ for the variable $\vv$;
    \item $\vtp$ is the well-constrained integer constrained by the variable expression for $\vv$,
    that is, $\TInt(\WellConstrained(\ConstraintExact(\EVar(\vv))))$.
  \end{itemize}

  \item \AllApplyCase{t\_int\_other, other}
  \begin{itemize}
    \item $\vt$ is not a \parameterizedintegertypeterm\ for the variable $\vv$;
    \item $\vtp$ is $\vt$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[t\_int\_parameterized]{}
{
  \towellconstrained(\overname{\TInt(\Parameterized(\vv))}{\vt}) \typearrow\\ \TInt(\WellConstrained(\ConstraintExact(\EVar(\vv))))
}
\and
\inferrule[t\_int\_other]{
  \astlabel(\vi) \neq \Parameterized
}{
  \towellconstrained(\overname{\TInt(\vi)}{\vt}) \typearrow \vt
}
\and
\inferrule[other]{
  \astlabel(\vt) \neq \TInt
}{
  \towellconstrained(\vt) \typearrow \vt
}
\end{mathpar}

\TypingRuleDef{GetWellConstrainedStructure}
\RenderRelation{get_well_constrained_structure}
\BackupOriginalRelation{
The function
\[
  \getwellconstrainedstructure(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt})
  \aslto \overname{\ty}{\vtp} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
returns the \wellconstrainedstructureterm\ of a type $\vt$ in the \staticenvironmentterm{} $\tenv$ --- $\vtp$, which is defined as follows.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Obtaining the Well-constrained Structure of a Type}
In \listingref{GetWellConstrainedStructure},
annotating the expression \verb|-N| involves obtaining the well-constrained structure of the
type of \verb|N|, which yields \\
$\TInt(\WellConstrained([\ConstraintExact(\EVar(\vN))]))$.
Similarly, the for expression \verb|-x|,
obtaining the well-constrained structure of the type for $\vx$ yields \\
$\unconstrainedinteger$.
\ASLListing{Obtaining the well constrained structure of a type}{GetWellConstrainedStructure}{\typingtests/TypingRule.GetWellConstrainedStructure.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item the \structureterm\ of $\vt$ in $\tenv$ is $\vtone$\ProseOrTypeError;
  \item the well-constrained version of $\vtone$ is $\vtp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) \typearrow \vtone \OrTypeError\\\\
  \towellconstrained(\vtone) \typearrow \vtp
}{
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \vtp
}
\end{mathpar}

\TypingRuleDef{GetBitvectorWidth}
\RenderRelation{get_bitvector_width}
\BackupOriginalRelation{
The function
\[
  \getbitvectorwidth(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \overname{\expr}{\ve} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
returns the expression $\ve$, which represents the width of the bitvector type $\vt$
in the \staticenvironmentterm{} $\tenv$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

See \ExampleRef{Obtaining the Integer Corresponding to a Bitvector Width}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item obtaining the \structureterm\ of $\vt$ in $\tenv$ yields a bitvector type with width expression $\ve$,
          that is, $\TBits(\ve, \Ignore)$\ProseOrTypeError;
    \item the result is $\ve$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item obtaining the \structureterm\ of $\vt$ in $\tenv$ yields a type that is not a bitvector type;
    \item the result is a \typingerrorterm{} indicating that a bitvector type was expected.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\tenv, \vt) \typearrow \TBits(\ve, \Ignore) \OrTypeError
}{
  \getbitvectorwidth(\tenv, \vt) \typearrow \ve
}
\and
\inferrule[error]{
  \tstruct(\tenv, \vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \TBits
}{
  \getbitvectorwidth(\tenv, \vt) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\GetBitvectorWidthBegin}{\GetBitvectorWidthEnd}{../Typing.ml}

\TypingRuleDef{GetBitvectorConstWidth}
\RenderRelation{get_bitvector_const_width}
\BackupOriginalRelation{
The function
\[
  \getbitvectorconstwidth(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \overname{\N}{\vw} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
returns the natural number $\vw$, which represents the width of the bitvector type $\vt$
in the \staticenvironmentterm{} $\tenv$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Obtaining the Integer Corresponding to a Bitvector Width}
In \listingref{lesetfields}, annotating the \assignableexpression{} \verb|x.[status, time, data]|
requires obtaining the widths of the fields \verb|status|, \verb|time|, and \verb|data|
whose corresponding types are \verb|bit|, \verb|bits(16)|, and \verb|bits(8)|,
which yield $1$, $16$, and $8$, respectively.

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\getbitvectorwidth$ to $\vt$ in $\tenv$ yields $\ewidth$\ProseOrTypeError;
  \item \Prosestaticeval{$\tenv$}{$\ewidth$}{integer for $\vw$}\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \getbitvectorwidth(\tenv, \vt) \typearrow \ewidth \OrTypeError\\\\
  \staticeval(\tenv, \ewidth) \typearrow \LInt(\vw) \OrTypeError
}{
  \getbitvectorconstwidth(\tenv, \vt) \typearrow \vw
}
\end{mathpar}
\CodeSubsection{\GetBitvectorConstWidthBegin}{\GetBitvectorConstWidthEnd}{../Typing.ml}

\TypingRuleDef{CheckBitsEqualWidth}
\RenderRelation{check_bits_equal_width}
\BackupOriginalRelation{
The function
\[
  \checkbitsequalwidth(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\vtone} \aslsep
    \overname{\ty}{\vttwo}) \aslto
  \{\True\} \cup \typeerror
\]
tests whether the types $\vtone$ and $\vttwo$ are bitvector types of the same width.
If the answer is positive, the result is $\True$. \ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Ensuring That Two Bitvectors Have Equal Width}
In \listingref{CheckBitsEqualWidth}, annotating the bitfield \verb|info|
requires checking that its declared width given by \verb|bits(4)| is equal to
the width defined by the corresponding slice \verb|[6:3]|.

In addition, annotating the expression \verb|x AND y| requires checking that
the widths of \verb|x| and \verb|y| are equal.
\ASLListing{Ensuring that two bitvectors Have equal width}{CheckBitsEqualWidth}{\typingtests/TypingRule.CheckBitsEqualWidth.asl}

The specification in \listingref{CheckBitsEqualWidth-bad}
is ill-typed, since \verb|M| and \verb|N| are not necessarily equal, even though they have the same type.
\ASLListing{Two bitvectors of possibly different widths}{CheckBitsEqualWidth-bad}{\typingtests/TypingRule.CheckBitsEqualWidth.bad.asl}

The specification in \listingref{CheckBitsEqualWidth-bad2} is ill-typed for a similar reason.
\ASLListing{Two bitvectors of possibly different widths}{CheckBitsEqualWidth-bad2}{\typingtests/TypingRule.CheckBitsEqualWidth.bad2.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item obtaining the width of $\vtone$ in $\tenv$ (via $\getbitvectorwidth$) yields the expression $\vn$\ProseOrTypeError;
  \item obtaining the width of $\vttwo$ in $\tenv$ (via $\getbitvectorwidth$) yields the expression $\vm$\ProseOrTypeError;
  \item symbolically checking whether the bitwidth expressions $\vn$ and $\vm$ are equal (via $\bitwidthequal$) yields $\vb$;
  \item checking whether $\vb$ is $\True$ yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item the result is $\True$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vn \OrTypeError\\\\
  \getbitvectorwidth(\tenv, \vttwo) \typearrow \vm \OrTypeError\\\\
  \bitwidthequal(\tenv, \vn, \vm) \typearrow \vb\\
  \techeck(\vb, \UnexpectedType) \typearrow \True \OrTypeError
}{
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{PrecisionJoin}
\RenderRelation{precision_join}
\BackupOriginalRelation{
The function
\[
    \precisionjoin(
      \overname{\precisionlossindicator}{\vpone} \aslsep
      \overname{\precisionlossindicator}{\vptwo}
    )
    \aslto
    \overname{\precisionlossindicator}{\vp}
\]
returns the \precisionlossindicatorterm{} $\vp$, denoting whether $\vpone$ or
$\vptwo$ denote a precision loss.
} % END_OF_BACKUP_RELATION

\ExampleDef{Precision join}
In \listingref{precisionjoin}, the statement \verb|var b = (a * a) + 2;| is
forbidden because it tries to declare a type with a precision loss (see
\TypingRuleRef{LDVar}).
The expression \verb|a * a| has a type that results in a precision loss (see
\TypingRuleRef{AnnotateConstraintBinop}).
The typing rule \TypingRuleRef{PrecisionJoin} is called by
\TypingRuleRef{ApplyBinopTypes} to compute the precision of the type of the
expression \verb|(a * a) + 2|. Because the type of \verb|(a * a)| denotes a
precision lost, the type of \verb|(a * a) + 2| also denotes a precision lost.
\ASLListing{Precision join}{precisionjoin}{\typingtests/TypingRule.PrecisionJoin.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{Loss}
    \begin{itemize}
      \item $\vpone$ is $\PrecisionLost$ or $\vptwo$ is $\PrecisionLost$;
      \item $\vp$ is $\PrecisionLost$;
    \end{itemize}
  \item \AllApplyCase{Full}
    \begin{itemize}
      \item $\vpone$ is $\PrecisionFull$ and $\vptwo$ is $\PrecisionFull$;
      \item $\vp$ is $\PrecisionFull$;
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[Loss]{
    \vpone = \PrecisionLost \lor
    \vptwo = \PrecisionLost
  }{
    \precisionjoin(\vpone, \vptwo) \typearrow \PrecisionLost
  }
  \and
  \inferrule[Full]{
    \vpone = \PrecisionFull \\
    \vptwo = \PrecisionFull
  }{
    \precisionjoin(\vpone, \vptwo) \typearrow \PrecisionFull
  }
\end{mathpar}
