\section{Relations Over Types\label{sec:RelationsOnTypes}}

This section defines the following relations over types and operators:
\begin{itemize}
  \item Subtype (\TypingRuleRef{Subtype})
  \item Subtype Satisfaction (\TypingRuleRef{SubtypeSatisfaction})
  \item Type Satisfaction (\TypingRuleRef{TypeSatisfaction})
  \item The Lowest Common Ancestor of two types (\TypingRuleRef{LowestCommonAncestor})
  \item Applying a unary operator to a type (\TypingRuleRef{ApplyUnopType})
  \item Applying a binary operator to a pair of types (\TypingRuleRef{ApplyBinopTypes})
\end{itemize}

\TypingRuleDef{Subtype}
\hypertarget{def-supertypeterm}{}
The \emph{\subtypeterm} relation is a partial order over \underline{named types}.
The \emph{\supertypeterm} is the inverse relation.
That is, \tty\ is a \supertypeterm{} of \tsy\ if and only if \tsy\ is a \subtypeterm{} of \tty.

\ExampleDef{Subtypes and Supertypes}
The following table determines whether the type \vAbf{}
subtypes the type \vBbf{} with respect to the types
declared in \listingref{subtype}:\\
\begin{tabular}{llll}
  \textbf{type A} & \textbf{type B}   & \textbf{subtypes?}  & \textbf{reason}\\
\hline
  \texttt{subInt}     & \texttt{subInt}   & yes             & subtyping is reflexive for \namedtypesterm{}\\
  \texttt{subInt}     & \texttt{superInt} & yes             & declared as a \subtypeterm{}\\
  \texttt{superInt}   & \texttt{subInt}   & no              & subtyping is anti-symmetric\\
  \texttt{subsubInt}  & \texttt{superInt} & yes             & subtyping is transitive\\
  \texttt{otherInt}   & \texttt{superInt} & no              & no chain of subtyping between the types\\
  \texttt{superInt}   & \texttt{integer}  & no              & \texttt{integer} is not a \namedtypeterm{}\\
  \texttt{integer}    & \texttt{integer}  & no              & \texttt{integer} is not a \namedtypeterm{}\\
\end{tabular}

\ASLListing{Subtypes and Supertypes}{subtype}{\typingtests/TypingRule.Subtype.asl}

\hypertarget{def-subtypesrel}{}
The predicate
\[
  \subtypesrel(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\Bool}{\vb}
\]
defines whether the type $\vtone$ subtypes the type $\vttwo$ in the static environment $\tenv$,
yielding the result in $\vb$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{reflexive}
  \begin{itemize}
    \item $\vtone$ and $\vttwo$ are both the same named type;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{transitive}
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the global static environment maintains that $\idone$ is a subtype of $\idthree$;
    \item testing whether the type named $\idthree$ is a subtype of $\vttwo$ in the static environment $\tenv$
    gives $\vb$.
  \end{itemize}

  \item \AllApplyCase{no\_supertype}
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the global static environment maintains that $\idone$ does subtype any named type;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item \AllApplyCase{not\_named}
  \begin{itemize}
    \item at least one of $\vtone$ and $\vttwo$ is not a named type;
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[reflexive]{}{
  \subtypesrel(\tenv, \TNamed(\id), \TNamed(\id)) \typearrow \True
}
\and
\inferrule[transitive]{
  \idone \neq \idtwo\\
  G^\tenv.\subtypes(\idone) = \idthree\\
  \subtypesrel(\tenv, \TNamed(\idthree), \vttwo) \typearrow \vb
}{
  \subtypesrel(\tenv, \TNamed(\idone), \TNamed(\idtwo)) \typearrow \vb
}
\and
\inferrule[no\_supertype]{
  \idone \neq \idtwo\\
  G^\tenv.\subtypes(\idone) = \bot
}{
  \subtypesrel(\tenv, \TNamed(\idone), \TNamed(\idtwo)) \typearrow \False
}
\and
\inferrule[not\_named]{
  (\astlabel(\vtone) \neq \TNamed \lor \astlabel(\vttwo) \neq \TNamed)
}{
  \subtypesrel(\tenv, \vtone, \vttwo) \typearrow \False
}
\end{mathpar}
\CodeSubsection{\SubtypeBegin}{\SubtypeEnd}{../types.ml}

\identr{NXRX} \identi{KGKS} \identi{MTML} \identi{JVRM} \identi{CHMP}

\TypingRuleDef{SubtypeSatisfaction}
\hypertarget{def-subtypesat}{}
The predicate
\[
  \subtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
determines whether a type $\vt$ \emph{subtype-satisfies} a type $\vs$ in environment $\tenv$,
returning the result in $\vb$.
\ProseOtherwiseTypeError

The function assumes that both $\vt$ and $\vs$ are well-typed according to \chapref{Types}.

\ExampleDef{Subtype Satisfaction}
\listingref{subtypesat1} shows examples
where the types of the right-hand-side expressions \subtypesatisfy{}
the types of the left-hand-side expressions.
\pagebreak
\ASLListing{Subtype Satisfaction}{subtypesat1}{\typingtests/TypingRule.SubtypeSatisfaction1.asl}

\listingref{subtypesat-bad1} and \listingref{subtypesat-bad2}
shows examples of nuanced \typingerrorsterm.
Specifically where a type consisting of a range of values does not \subtypesatisfy{}
a type consisting of one variable expression.
\ASLListing{Subtype satisfaction error 1}{subtypesat-bad1}{\typingtests/TypingRule.SubtypeSatisfaction.bad1.asl}
\ASLListing{Subtype satisfaction error 2}{subtypesat-bad2}{\typingtests/TypingRule.SubtypeSatisfaction.bad2.asl}

\listingref{subtypesat2} shows examples of legal and illegal assignments involving
subtyping.
\ASLListing{More Examples of subtype satisfaction}{subtypesat2}{\typingtests/TypingRule.SubtypeSatisfaction2.asl}

\listingref{subtypesat3} shows more examples of legal and illegal assignments involving
subtyping.
\ASLListing{Even more examples of subtype satisfaction}{subtypesat3}{\typingtests/TypingRule.SubtypeSatisfaction3.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
\item \AllApplyCase{error1}
  \begin{itemize}
  \item obtaining the \underlyingtype\ of $\vt$ gives a \typingerrorterm{};
  \item the rule results in a \typingerrorterm{}.
  \end{itemize}

\item \AllApplyCase{error2}
  \begin{itemize}
    \item obtaining the \underlyingtype\ of $\vt$ gives a type $\vttwo$;
    \item obtaining the \underlyingtype\ of $\vs$ gives a \typingerrorterm{};
    \item the rule results in a \typingerrorterm{}.
    \end{itemize}

\item \AllApplyCase{different\_labels}
  \begin{itemize}
  \item the underlying types of $\vt$ and $\vs$ have different AST labels
  (for example, $\TInt$ and $\TReal$);
  \item $\vb$ is $\False$.
  \end{itemize}

\item \AllApplyCase{simple}
  \begin{itemize}
  \item the \underlyingtype\ of $\vt$, $\vttwo$, is either \realtypeterm{}, \stringtypeterm{}, or \booleantypeterm{};
  \item the \underlyingtype\ of $\vs$, $\vstwo$, is either \realtypeterm{}, \stringtypeterm{}, or \booleantypeterm{};
  \item $\vb$ is $\True$ if and only if both $\vttwo$ and $\vstwo$ have the same ASL label.
  \end{itemize}

\item \AllApplyCase{t\_int}
  \begin{itemize}
  \item the \underlyingtype\ of $\vt$, $\vttwo$, is an \integertypeterm{} (any kind);
  \item the \underlyingtype\ of $\vs$, $\vstwo$, is an \integertypeterm{} (any kind);
  \item applying $\symdomoftype$ to $\tenv$ and $\vs$ yields the \symbolicdomain{} $\ds$;
  \item applying $\symdomoftype$ to $\tenv$ and $\vt$ yields the \symbolicdomain{} $\dt$;
  \item applying $\symdomsubsetunions$ to $\tenv$, $\ds$, and $\dt$ yields $\vb$.
  \end{itemize}

\item \AllApplyCase{t\_enum}
  \begin{itemize}
  \item the \underlyingtype\ of $\vt$ is an \enumerationtypeterm{} with list of labels $\vlit$, that is, $\TEnum(\vlit)$;
  \item the \underlyingtype\ of $\vs$ is an \enumerationtypeterm{} with list of labels $\vlis$, that is, $\TEnum(\vlis)$;
  \item $\vb$ is $\True$ if and only if $\vlit$ is equal to $\vlis$.
  \end{itemize}

\item \AllApplyCase{t\_bits}
  \begin{itemize}
  \item the \underlyingtype\ of $\vs$ is a bitvector type with width $\ws$ and bit fields $\bfss$, that is $\TBits(\ws, \bfss)$;
  \item the \underlyingtype\ of $\vt$ is a bitvector type with width $\wt$ and bit fields $\bfst$, that is $\TBits(\wt, \bfst)$;
  \item determining whether the bitfields $\bfss$ are included in the bitfields $\bfst$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item determining whether the \symbolicdomain{} of $\ws$ subsumes the \symbolicdomain{} of $\wt$ in $\tenv$ yields $\vb$.
  \end{itemize}

\item \AllApplyCase{t\_array\_expr}
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtype\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are equivalent in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array length expression with $\vlengthexprs$, that is \\ $\ArrayLengthExpr(\vlengthexprs)$;
  \item $\vlengtht$ is an array length expression with $\vlengthexprt$, that is \\ $\ArrayLengthExpr(\vlengthexprt)$;
  \item determining whether expressions $\vlengthexprs$ and $\vlengthexprt$ are equivalent gives $\vb$.
  \end{itemize}

  \item \AllApplyCase{t\_array\_enum}
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtype\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are equivalent in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array with indices taken from the enumeration $\vnames$, that is $\ArrayLengthEnum(\vnames, \Ignore)$;
  \item $\vlengtht$ is an array with indices taken from the enumeration $\vnamet$, that is $\ArrayLengthEnum(\vnamet, \Ignore)$;
  \item $\vb$ is $\True$ if and only if $\vnames$ and $\vnamet$ are the same.
  \end{itemize}

\item \AllApplyCase{t\_tuple}
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of a tuple with type list $\vlis$, that is $\TTuple(\vlis)$;
  \item $\vt$ has the \underlyingtype\ of a tuple with type list $\vlit$, that is $\TTuple(\vlit)$;
  \item equating the lengths of $\vlis$ and $\vlit$ is either $\True$ or $\False$, which short-circuits
  the entire rule with $\vb=\False$;
  \item checking at each index $\vi$ of the list $\vlis$ whether the type $\vlit[\vi]$ \typesatisfies\ the type $\vlis[\vi]$
  yields $\vb_\vi$\ProseOrTypeError;
  \item $\vb$ is $\True$ if and only if all $\vb_\vi$ are $\True$;
  \end{itemize}

\item \AllApplyCase{structured}
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ $L(\vfieldss)$, which is a \structuredtype;
  \item $\vt$ has the \underlyingtype\ $L(\vfieldst)$, which is a \structuredtype;
  \item since both underlying types have the same AST label they are either both record types or both exception types or both collection types;
  \item $\vb$ is $\True$ if and only if for each field in $\vfieldss$ with type $\vtys$
  there exists a field in $\vfieldst$ with type $\vtyt$ such that both $\vtys$ and $\vtyt$
  are determined to be \typeequivalent\ in $\tenv$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[error1]{
  \makeanonymous(\tenv, \vt) \typearrow \TypeErrorConfig
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\end{mathpar}

\begin{mathpar}
\inferrule[error2]{
  \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
  \makeanonymous(\tenv, \vs) \typearrow \TypeErrorConfig
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\end{mathpar}

\begin{mathpar}
\inferrule[different\_labels]{
  \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
  \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
  \astlabel(\vttwo) \neq \astlabel(\vstwo)
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
  \inferrule[simple]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \astlabel(\vttwo) \in \{\TReal, \TString, \TBool\}\\
    \vb \eqdef \astlabel(\vstwo) = \astlabel(\vttwo)
  }{
    \subtypesat(\tenv, \vt, \vs) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
\inferrule[t\_int]{
  \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
  \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
  \astlabel(\vttwo) = \astlabel(\vstwo) = \TInt\\
  \symdomoftype(\tenv, \vs) \typearrow \ds \\
  \symdomoftype(\tenv, \vt) \typearrow \dt \\
  \symdomsubsetunions(\tenv, \ds, \dt) \typearrow \vb
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \makeanonymous(\tenv, \vt) \typearrow \TEnum(\vlit)\\
  \makeanonymous(\tenv, \vs) \typearrow \TEnum(\vlis)\\
  \vb \eqdef \vlit = \vlis
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \makeanonymous(\tenv, \vs) \typearrow \TBits(\ws, \bfss)\\
  \makeanonymous(\tenv, \vt) \typearrow \TBits(\wt, \bfst)\\
  \bitfieldsincluded(\tenv, \bfss, \bfst) \typearrow \True \OrTypeError \\
  \symdomofwidthexpr(\tenv, \ws) \typearrow \ds \\
  \symdomofwidthexpr(\tenv, \wt) \typearrow \dt \\
  \symdomsubsetunions(\tenv, \ds, \dt) \typearrow \vb
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_expr]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True \terminateas \False\\
  \booltrans{\astlabel(\vlengths) = \astlabel(\vlengtht)} \booltransarrow \True \terminateas \False\\
  \vlengths \eqname \ArrayLengthExpr(\vlengthexprs)\\
  \vlengtht \eqname \ArrayLengthExpr(\vlengthexprt)\\
  \exprequal(\tenv, \vlengthexprs, \vlengthexprt) \typearrow \vb
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_enum]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True\\
  \booltrans{\astlabel(\vlengths) = \astlabel(\vlengtht)} \typearrow \True \terminateas \False \\
  \vlengths \eqname \ArrayLengthEnum(\vnames, \Ignore)\\
  \vlengtht \eqname \ArrayLengthEnum(\vnamet, \Ignore)\\
  \vb \eqdef \vnames = \vnamet
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]
{ \makeanonymous(\tenv, \vs) \typearrow\TTuple(\vlis)\\
  \makeanonymous(\tenv, \vt) \typearrow\TTuple(\vlit)\\
  \equallength(\vlis, \vlit) \typearrow\True \terminateas \False\\
  \vi\in\listrange(\vlis): \typesat(\tenv, \vlit[\vi], \vlis[\vi]) \typearrow \vb_i \terminateas \TTypeError\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_\vi
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\hypertarget{def-fieldnames}{}
For a list of typed fields $\fields$, we define the set of its field identifiers as:
\[
  \fieldnames(\fields) \triangleq \{ \id \;|\; (\id, \vt) \in \fields\}
\]
\hypertarget{def-fieldtype}{}
We define the type associated with the field name $\id$ in a list of typed fields $\fields$,
if there is a unique one, as follows:
\[
  \fieldtype(\fields, \id) \triangleq
  \begin{cases}
  \vt  & \text{ if }\{ \vtp \;|\; (\id,\vtp) \in \fields\} = \{\vt\}\\
  \bot & \text{ otherwise}
  \end{cases}
\]

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException, \TCollection\}\\
  \makeanonymous(\tenv, \vs)\typearrow L(\vfieldss) \\
  \makeanonymous(\tenv, \vt)\typearrow L(\vfieldst) \\
  \vnamess \eqdef \fieldnames(\vfieldss)\\
  \vnamest \eqdef \fieldnames(\vfieldst)\\
  \booltrans{\vnamess \subseteq \vnamest} \booltransarrow \True \terminateas \False\\
  (\id,\vtys)\in\vfieldss: \typeequal(\tenv, \vtys, \fieldtype(\vfieldst, \id)) \typearrow \vb_\id\\
  \vb \eqdef \bigwedge_{\id \in \vnamess} \vb_\id
}{
  \subtypesat(\tenv, \vs, \vt) \typearrow \vb
}
\end{mathpar}
\identd{TRVR} \identi{SJDC} \identi{MHYB} \identi{TWTZ} \identi{GYSK} \identi{KXSD} \identi{KNXJ}
\CodeSubsection{\SubtypeSatisfactionBegin}{\SubtypeSatisfactionEnd}{../types.ml}

\TypingRuleDef{TypeSatisfaction}
\identr{FMXK}
\hypertarget{def-typesatisfies}{}
The predicate
\[
  \typesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
determines whether a type $\vt$ \emph{\typesatisfies} a type $\vs$ in environment $\tenv$,
returning the result $\vb$.
\ProseOtherwiseTypeError

The function assumes that both $\vt$ and $\vs$ are well-typed according to \secref{Types}.

\ExampleDef{Type-satisfaction Examples}
In \listingref{typing-typesat1},
\texttt{var pair: pairT = (1, dataT1)} is legal since the right-hand-side has
anonymous, non-primitive type \texttt{(integer, T1)}.
\ASLListing{Type satisfaction example}{typing-typesat1}{\typingtests/TypingRule.TypeSatisfaction1.asl}

\ExampleDef{More Type-satisfaction Examples}
In \listingref{typing-typesat2},
\texttt{pair = (1, dataAsInt);} is legal since the right-hand-side has anonymous,
primitive type \texttt{(integer, integer)}.
\ASLListing{Type satisfaction example}{typing-typesat2}{\typingtests/TypingRule.TypeSatisfaction2.asl}

\ExampleDef{Failing Type-satisfaction}
In \listingref{typing-typesat3},
\texttt{pair = (1, dataT2);} is illegal since the right-hand-side has anonymous,
non-primitive type \texttt{(integer, T2)} which does not subtype-satisfy named
type \texttt{pairT}.
\ASLListing{Type satisfaction example}{typing-typesat3}{\typingtests/TypingRule.TypeSatisfaction3.asl}

\ProseParagraph
\OneApplies
 \begin{itemize}
  \item \AllApplyCase{subtypes}
    \begin{itemize}
    \item $\vt$ subtypes $\vs$ in $\tenv$ ;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{anonymous}
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item at least one of $\vt$ and $\vs$ is an anonymous type in $\tenv$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{t\_bits}
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item $\vt$ is a bitvector type with width $\widtht$ and no bitfields;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a bitvector type with width \\
          $\widths$\ProseOrTypeError;
    \item determining whether $\widtht$ and $\widths$ are \bitwidthequivalent\ yields $\vb$.
  \end{itemize}

  \item \AllApplyCase{otherwise1}
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a $\vsstruct$\ProseOrTypeError;
    \item at least one of $\vt$ and $\vsstruct$ is not a bitvector type;
  \end{itemize}

  \item \AllApplyCase{otherwise2}
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a $\vsstruct$\ProseOrTypeError;
    \item both $\vt$ and $\vsstruct$ are bitvector types;
    \item the bitvector type $\vt$ has a non-empty list of bitfields;
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[subtypes]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \True
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[anonymous]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \vbone \lor \vbtwo\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \True
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \vt = \TBits(\widtht, \emptylist)\\
  \tstruct(\tenv, \vs) \typearrow \TBits(\widths, \Ignore) \OrTypeError\\\\
  \bitwidthequal(\tenv, \widtht, \widths) \typearrow \vb
}{
  \typesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise1]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \astlabel(\vt) \neq \TBits \lor \astlabel(\vsstruct) \neq \TBits
}{
  \typesat(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise2]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \astlabel(\vt) = \TBits \land \astlabel(\vsstruct) = \TBits\\
  \vt = \TBits(\widtht, \bitfields)\\
  \bitfields \neq \emptylist
}{
  \typesat(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}
\CodeSubsection{\TypeSatisfactionBegin}{\TypeSatisfactionEnd}{../types.ml}

\TypingRuleDef{CheckTypeSatisfaction}
\hypertarget{def-checktypesat}{}
We also define
\[
  \checktypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
which is the same as $\typesat$, but yields a \typingerrorterm{} when \\ $\typesat(\tenv, \vt, \vs)$ is $\False$.

The function assumes that both $\vt$ and $\vs$ are well-typed according to \secref{Types}.

\ExampleDef{Checking Type Satisfaction}
In \listingref{typing-typesat1},
checking whether \verb|(integer, T1)| \typesatisfies{} \verb|pairT|
for the assignment \verb|var pair: pairT = (1, dataT1)| yields $\True$.

In \listingref{typing-typesat3}, checking whether \verb|(intege, T2)|
\typesatisfies{} \verb|pairT| for the assignment \verb|pair = (1, dataT2);|
yields a \typingerrorterm.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item \ProsetypesatTrue{$\tenv$}{$\vt$}{$\vs$};
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item \ProsetypesatFalse{$\tenv$}{$\vt$}{$\vs$}..
    \item the result is a \typingerrorterm{} (\TypeSatisfactionFailure).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \typesat(\tenv, \vt, \vs) \typearrow \False
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\TypeSatisfactionFailure}
}
\end{mathpar}

\TypingRuleDef{LowestCommonAncestor}
\hypertarget{def-lowestcommonancestor}{}
Annotating a conditional expression (see \TypingRuleRef{ECond}),
requires finding a single type that can be used to annotate the results of both subexpressions.
We refer to such a type as a \emph{\Proselca}, or LCA, for short, and define it next.

The function
\[
  \lca(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\ty}{\tty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the \Proselca{} of types $\vt$ and $\vs$ in $\tenv$ --- $\tty$.
The result is a \typingerrorterm{} if a \Proselca{} does not exist or a \typingerrorterm{} is detected.

\ExampleDef{Lowest Common Ancestor}
\listingref{example-lca} shows examples of conditional expressions and the resulting
\emph{\Proselca}.
\pagebreak
\ASLListing{Lowest Common Ancestor}{example-lca}{\typingtests/TypingRule.LowestCommonAncestor.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{type\_equal}
  \begin{itemize}
    \item $\vt$ is \typeequal\ to $\vs$ in $\tenv$;
    \item $\tty$ is $\vs$ (can as well be $\vt$).
  \end{itemize}

  \item \AllApply
  \begin{itemize}
    \item $\vt$ is not \typeequal\ to $\vs$ in $\tenv$;
    \item \OneApplies
    \begin{itemize}
      \item \AllApplyCase{named\_subtype1}
      \begin{itemize}
        \item $\vt$ is a named type with identifier $\namesubt$, that is, $\TNamed(\namesubt)$;
        \item $\vs$ is a named type with identifier $\namesubs$, that is, $\TNamed(\namesubs)$;
        \item there is no \namedlowestcommonancestor\ of $\namesubs$ and $\namesubt$ in $\tenv$;
        \item obtaining the \underlyingtype\ of $\vs$ yields $\vanons$\ProseOrTypeError;
        \item obtaining the \underlyingtype\ of $\vt$ yields $\vanont$\ProseOrTypeError;
        \item obtaining the lowest common ancestor of $\vanons$ and $\vanont$ in $\tenv$ yields $\tty$\ProseOrTypeError.
      \end{itemize}

      \item \AllApplyCase{named\_subtype2}
      \begin{itemize}
        \item $\vt$ is a named type with identifier $\namesubt$, that is, $\TNamed(\namesubt)$;
        \item $\vs$ is a named type with identifier $\namesubs$, that is, $\TNamed(\namesubs)$;
        \item the \namedlowestcommonancestor\ of $\namesubs$ and $\namesubt$ in $\tenv$ is \\
              $\name$\ProseOrTypeError;
        \item $\tty$ is the named type with identifier $\name$, that is, $\TNamed(\name)$.
      \end{itemize}

      \item \AllApplyCase{one\_named1}
      \begin{itemize}
        \item only one of $\vt$ or $\vs$ is a named type;
        \item obtaining the \underlyingtype\ of $\vs$ yields $\vanons$\ProseOrTypeError;
        \item obtaining the \underlyingtype\ of $\vt$ yields $\vanont$\ProseOrTypeError;
        \item $\vanont$ is \typeequal\ to $\vanons$;
        \item $\tty$ is $\vt$ if it is a named type (that is, $\astlabel(\vt)=\TNamed$), and $\vs$ otherwise.
      \end{itemize}

      \item \AllApplyCase{one\_named2}
      \begin{itemize}
        \item only one of $\vt$ or $\vs$ is a named type;
        \item obtaining the \underlyingtype\ of $\vs$ yields $\vanons$\ProseOrTypeError;
        \item obtaining the \underlyingtype\ of $\vt$ yields $\vanont$\ProseOrTypeError;
        \item $\vanont$ is not \typeequal\ to $\vanons$;
        \item the lowest common ancestor of $\vanont$ and $\vanons$ in $\tenv$ is $\tty$\ProseOrTypeError.
      \end{itemize}

      \item \AllApplyCase{t\_int\_unconstrained}
      \begin{itemize}
        \item both $\vt$ and $\vs$ are integer types;
        \item at least one of $\vt$ or $\vs$ is an unconstrained integer type;
        \item $\tty$ is the unconstrained integer type.
      \end{itemize}

      \item \AllApplyCase{t\_int\_parameterized}
      \begin{itemize}
        \item neither $\vt$ nor $\vs$ are the unconstrained integer type;
        \item one of $\vt$ and $\vs$ is a \parameterizedintegertype;
        \item the \wellconstrainedversion\ of $\vt$ is $\vtone$;
        \item the \wellconstrainedversion\ of $\vs$ is $\vsone$;
        \item $\tty$ the lowest common ancestor of $\vtone$ and $\vsone$ in $\tenv$ is $\tty$\ProseOrTypeError.
      \end{itemize}

      \item \AllApplyCase{t\_int\_wellconstrained}
      \begin{itemize}
        \item $\vt$ is a well-constrained integer type with constraints $\cst$ and \Proseprecisionlossindicator{} $\vpone$;
        \item $\vs$ is a well-constrained integer type with constraints $\css$ and \Proseprecisionlossindicator{} $\vpone$;
        \item applying $\precisionjoin$ on $\vpone$ and $\vptwo$ yields $\vp$;
        \item $\tty$ is the well-constrained integer type with constraints $\cst \concat \css$ and \Proseprecisionlossindicator{} $\vp$.
      \end{itemize}

      \item \AllApplyCase{t\_bits}
      \begin{itemize}
        \item $\vt$ is a bitvector type with length expression $\vet$, that is, $\TBits(\vet, \Ignore)$;
        \item $\vs$ is a bitvector type with length expression $\ves$, that is, $\TBits(\ves, \Ignore)$;
        \item applying $\typeequal$ to $\vt$ and $\vs$ in $\tenv$ yields $\False$;
        \item applying $\exprequal$ to $\vet$ and $\ves$ in $\tenv$ yields $\vbequal$;
        \item checking whether $\vbequal$ is $\True$ yields $\True$\ProseTerminateAs{\NoLCA};
        \item $\tty$ is a bitvector type with length expression $\vet$ and an empty bitfield list, that is, $\TBits(\vet, \emptylist)$.
      \end{itemize}

      \item \AllApplyCase{t\_array}
      \begin{itemize}
        \item $\vt$ is an array type with width expression $\widtht$ and element type $\vtyt$;
        \item $\vs$ is an array type with width expression $\widths$ and element type $\vtys$;
        \item applying $\arraylengthequal$ to $\widtht$ and $\widths$ in $\tenv$ to equate the array lengths,
              yields $\vbequallength$\ProseOrTypeError;
        \item checking that $\vbequallength$ is $\True$ yields $\True$\ProseTerminateAs{\NoLCA};
        \item the lowest common ancestor of $\vtyt$ and $\vtys$ is $\vtone$\ProseOrTypeError;
        \item $\tty$ is an array type with width expression $\widths$ and element type $\vtone$.
      \end{itemize}

      \item \AllApplyCase{t\_tuple}
      \begin{itemize}
        \item $\vt$ is a \tupletypeterm{} with type list $\vlit$;
        \item $\vs$ is a \tupletypeterm{} with type list $\vlis$;
        \item checking whether $\vlit$ and $\vlis$ have the same number of elements yields $\True$
              or a \typingerrorterm{}, which short-circuits the entire rule (indicating that the number of elements in both tuples is expected
              to be the same and thus there is no lowest common ancestor);
        \item applying $\lca$ to $\vlit[\vi]$ and $\vlis[\vi]$ in $\tenv$, for every position of $\vlit$,
              yields $\vt_\vi$\ProseOrTypeError;
        \item define $\vli$ to be the list of types $\vt_\vi$, for every position of $\vlit$;
        \item define $\tty$ as the \tupletypeterm{} with list of types $\vli$, that is, $\TTuple(\vli)$.
      \end{itemize}

      \item \AllApplyCase{error}
      \begin{itemize}
        \item either the AST labels of $\vt$ and $\vs$ are different, or one of them is $\TEnum$, $\TRecord$, $\TCollection$, or $\TException$;
        \item the result is a \typingerrorterm{} indicating the lack of a lowest common ancestor.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}
\CodeSubsection{\LowestCommonAncestorBegin}{\LowestCommonAncestorEnd}{../types.ml}

\FormallyParagraph
Since we do not impose a canonical representation on types (e.g., \verb|integer {1, 2}| is equivalent to \verb|integer {1..2}|),
the lowest common ancestor is not unique.
We define $\lca(\tenv, \vt, \vs)$ to be any type $\vtp$ that is \typeequivalent\ to the lowest common ancestor of $\vt$ and $\vs$.

\begin{mathpar}
\inferrule[type\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \True
}{
  \lca(\tenv, \vt, \vs) \typearrow \overname{\vs}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[named\_subtype1]{
  \vt = \TNamed(\namesubs)\\
  \vs = \TNamed(\namesubt)\\
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \namedlca(\tenv, \namesubs, \namesubt) \typearrow \None \OrTypeError\\\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\\\
  \lca(\tenv, \vanont, \vanons) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[named\_subtype2]{
  \vt = \TNamed(\namesubs)\\
  \vs = \TNamed(\namesubt)\\
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \namedlca(\tenv, \namesubs, \namesubt) \typearrow \langle\name\rangle \OrTypeError\\
}{
  \lca(\tenv, \vt, \vs) \typearrow \overname{\TNamed(\name)}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_named1]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) = \TNamed \lor \astlabel(\vs) = \TNamed)\\
  \astlabel(\vt) \neq \astlabel(\vs)\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\\\
  \typeequal(\tenv, \vanont, \vanons) \typearrow \True\\
  \tty \eqdef \choice{\astlabel(\vt) = \TNamed}{\vt}{\vs}
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_named2]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) = \TNamed \lor \astlabel(\vs) = \TNamed)\\
  \astlabel(\vt) \neq \astlabel(\vs)\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\\\
  \typeequal(\tenv, \vanont, \vanons) \typearrow \False\\
  \lca(\tenv, \vanont, \vanons) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_int\_unconstrained]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \isunconstrainedinteger(\vt) \lor \isunconstrainedinteger(\vs)
}{
  \lca(\tenv, \vt, \vs) \typearrow \overname{\unconstrainedinteger}{\tty}
}
\and
\inferrule[t\_int\_parameterized]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \neg\isunconstrainedinteger(\vt)\\
  \neg\isunconstrainedinteger(\vs)\\
  \isparameterizedinteger(\vt) \lor \isparameterizedinteger(\vs)\\
  \towellconstrained(\tenv, \vt) \typearrow \vtone\\
  \towellconstrained(\tenv, \vs) \typearrow \vsone\\
  \lca(\tenv, \vtone, \vsone) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\and
\inferrule[t\_int\_wellconstrained]
{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt = \TInt(\wellconstrained(\cst, \vpone))\\
  \vs = \TInt(\wellconstrained(\css, \vptwo))\\
  \vp \eqdef \precisionjoin(\vpone, \vptwo)
}{
  \lca(\tenv, \vt, \vs) \typearrow \overname{\TInt(\wellconstrained(\cst \concat \css, \vp))}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \exprequal(\tenv, \vet, \ves) \typearrow \vbequal\\
  \checktrans{\vbequal}{\NoLCA} \checktransarrow \True \OrTypeError
}{
  \lca(\tenv, \overname{\TBits(\vet, \Ignore)}{\vt}, \overname{\TBits(\ves, \Ignore)}{\vs}) \typearrow \overname{\TBits(\vet, \emptylist)}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \arraylengthequal(\tenv, \widtht, \widths) \typearrow \vbequallength \OrTypeError\\\\
  \checktrans{\vbequallength}{\NoLCA} \checktransarrow \True \OrTypeError\\\\
  \lca(\tenv, \vtyt, \vtys) \typearrow \vtone \OrTypeError
}{
  {
  \begin{array}{r}
  \lca(\tenv, \overname{\TArray(\widtht, \vtyt)}{\vt}, \overname{\TArray(\widths, \vtys)}{\vs}) \typearrow \\
  \overname{\TArray(\widtht, \vtone)}{\tty}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \equallength(\vlit, \vlis) \typearrow \vb\\
  \checktrans{\vb}{\NoLCA} \typearrow \True \OrTypeError\\\\
  {
    \begin{array}{r}
  \vi\in\listrange(\vlit): \lca(\tenv, \vlit[\vi], \vlis[\vi]) \typearrow \\
   \vt_\vi \OrTypeError
    \end{array}
  }\\
  \vli \eqdef [\vi\in\listrange(\vlit): \vt_\vi]
}{
  \lca(\tenv, \overname{\TTuple(\vlit)}{\vt}, \overname{\TTuple(\vlis)}{\vs}) \typearrow \overname{\TTuple(\vli)}{\tty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) \neq \astlabel(\vs)) \lor
  \astlabel(\vt) \in \{\TEnum, \TRecord, \TException, \TCollection\}
}{
  \lca(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\NoLCA}
}
\end{mathpar}

\identr{YZHM}

\TypingRuleDef{ApplyUnopType}
\hypertarget{def-applyunoptype}{}
The function
\[
  \applyunoptype(\overname{\staticenvs}{\tenv} \aslsep \overname{\unop}{\op} \aslsep \overname{\ty}{\vt})
  \aslto \overname{\ty}{\vs} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
determines the result type of applying a unary operator when the type of its operand is known.
Similarly, we determine the negation of integer constraints.
\ProseOtherwiseTypeError

\ExampleDef{Applying Unary Operations to Types}
\listingref{apply-unop-type} shows examples of typing applications of unary operations.
\ASLListing{Applying unary operations to types}{apply-unop-type}{\typingtests/TypingRule.ApplyUnopType.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
\item \AllApplyCase{bnot\_t\_bool}
  \begin{itemize}
    \item $\op$ is $\BNOT$;
    \item determining whether $\vt$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vs$ is $\TBool$;
  \end{itemize}

\item \AllApplyCase{neg\_error}
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\TReal$ yields $\False$\ProseOrTypeError;
  \item determining whether $\vt$ \typesatisfies\ $\unconstrainedinteger$ yields $\False$\ProseOrTypeError;
  \item the result is a \typingerrorterm{} indicating the $\NEG$ is appropriate only for the \realtypeterm{} and the \integertypeterm{};
\end{itemize}

\item \AllApplyCase{neg\_t\_real}
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\TReal$ yields $\True$;
  \item $\vs$ is $\TReal$;
\end{itemize}

\item \AllApplyCase{neg\_t\_int\_unconstrained}
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item obtaining the \wellconstrainedstructure\ of $\vt$ yields $\unconstrainedinteger$\ProseOrTypeError;
  \item $\vs$ is $\unconstrainedinteger$;
\end{itemize}

\item \AllApplyCase{neg\_t\_int\_well\_constrained}
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item obtaining the \wellconstrainedstructure\ of $\vt$ yields the well-constrained integer type with constraints $\vcs$ and \Proseprecisionlossindicator{} $\vp$\ProseOrTypeError;
  \item negating the constraints in $\vcs$ (see $\negateconstraint$) yields $\vcsnew$;
  \item $\vs$ is the well-constrained integer type with constraints $\vcsnew$ and \Proseprecisionlossindicator{} $\vp$, that is, \\
  $\TInt(\wellconstrained(\vcsnew, \vp))$;
\end{itemize}

\item \AllApplyCase{not\_t\_bits}
  \begin{itemize}
  \item $\op$ is $\NOT$;
  \item $\vt$ has the structure of a bitvector;
  \item $\vs$ is $\vt$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[bnot\_t\_bool]{
  \checktypesat(\tenv, \vtone, \TBool) \typearrow \True \OrTypeError\\
}{
  \applyunoptype(\tenv, \BNOT, \vtone) \typearrow \TBool
}
\end{mathpar}
\CodeSubsection{\ApplyUnopTypeBegin}{\ApplyUnopTypeEnd}{../Typing.ml}

\begin{mathpar}
\inferrule[neg\_error]{
  \typesat(\tenv, \vt, \unconstrainedinteger) \typearrow \False \OrTypeError\\\\
  \typesat(\tenv, \vt, \TReal) \typearrow \False \OrTypeError\\
}{
  \applyunoptype(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \TypeErrorVal{\BadOperands}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_real]{
  \typesat(\tenv, \vt, \TReal) \typearrow \True
}{
  \applyunoptype(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \overname{\TReal}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_int\_unconstrained]{
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \unconstrainedinteger \OrTypeError
}{
  \applyunoptype(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \overname{\unconstrainedinteger}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_int\_well\_constrained]{
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \TInt(\wellconstrained(\vcs))\\
  \vc \in \vcs: \negateconstraint(\vc) \typearrow \vneg_\vc\\
  \vcsnew \eqdef [\vc \in \vcs: \vneg_\vc]
}{
  \applyunoptype(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \overname{\TInt(\wellconstrained(\vcsnew))}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_t\_bits]{
  \checkstructurelabel(\tenv, \vt, \TBits) \typearrow \True \OrTypeError
}{
  \applyunoptype(\tenv, \overname{\NOT}{\op}, \vt) \typearrow \vt
}
\end{mathpar}

\TypingRuleDef{NegateConstraint}
\hypertarget{def-negateconstraint}{}
The helper function
\[
  \negateconstraint(\overname{\intconstraint}{\vc}) \aslto \overname{\intconstraint}{\newc}
\]
takes an integer constraint $\vc$ and returns the constraint $\newc$,
which corresponds to the negation of all the values that $\vc$ represents.

\ExampleRef{Applying Unary Operations to Types} shows examples of negating single expression
constraints and range constraints.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is the \Proseexactconstraint{$\ve$};
    \item \Proseeqdef{$\newc$}{the \Proseexactconstraint{the unary expression negating $\ve$}}.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is the \Proserangeconstraint{$\vstart$}{$\vend$}
    \item \Proseeqdef{$\newc$}{the \Proserangeconstraint{that is the unary expression negating $\vend$}
    {that is the unary expression negating $\vstart$}}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{}
{
  \negateconstraint(\overname{\ConstraintExact(\ve)}{\vc}) \typearrow
  \overname{\ConstraintExact(\EUnop(\MINUS, \ve))}{\newc}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{}
{
  \negateconstraint(\overname{\ConstraintRange(\vstart, \vend)}{\vc}) \typearrow \\
  \overname{\ConstraintRange(\EUnop(\MINUS, \vend), \EUnop(\MINUS, \vstart))}{\newc}
}
\end{mathpar}

\TypingRuleDef{ApplyBinopTypes}
\hypertarget{def-applybinoptypes}{}
The function
\[
  \applybinoptypes(\overname{\staticenvs}{\tenv} \aslsep \overname{\binop}{\op} \aslsep \overname{\ty}{\vtone}
  \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\ty}{\vt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
determines the result type $\vt$ of applying the binary operator $\op$
to operands of type $\vtone$ and $\vttwo$ in the static environment $\tenv$.
\ProseOtherwiseTypeError

\ExampleDef{Applying Binary Operations to Types}
\listingref{apply-binop-type} shows examples of typing binary operations.
\ASLListing{Applying binary operations to types}{apply-binop-type}
          {\typingtests/TypingRule.ApplyBinopTypes.asl}

\ExampleDef{Applying Binary Operations to Constrained Integers}
\listingref{apply-binop-constraints} shows examples of typing binary operations
applied to \constrainedinteger{} types.

Importantly, note that the AST for constraints is not closed under binary operations.
For example, given a range constraint \verb|A..B| and an exact constraint |2|,
there is no AST to express \verb|(A..B) * 2|. Therefore, they constraints for typing
\verb|ab_times_2| approximate the set of values for \verb|(A..B) * 2| via four
range constraints. More precisely, they are a superset of the values for \verb|(A..B) * 2|.

\pagebreak
\ASLListing{Applying binary operations to constrained integers}{apply-binop-constraints}
          {\typingtests/TypingRule.ApplyBinopTypes.constraints.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{named}
  \begin{itemize}
    \item at least one of $\vtone$ and $\vttwo$ is a \namedtype;
    \item determining the \underlyingtype\ if $\vtone$ yields $\vtoneanon$\ProseOrTypeError;
    \item determining the \underlyingtype\ if $\vttwo$ yields $\vttwoanon$\ProseOrTypeError;
    \item \Proseapplybinoptypes{$\tenv$}{$\op$}{$\vtoneanon$}{$\vttwoanon$}{$\vt$\ProseOrTypeError}.
  \end{itemize}

  \item \AllApplyCase{boolean}
  \begin{itemize}
    \item $\op$ is $\AND$, $\OR$, $\EQOP$ or $\IMPL$;
    \item both $\vtone$ and $\vttwo$ are $\TBool$;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item \AllApplyCase{bits\_arith}
  \begin{itemize}
    \item $\op$ is one of $\AND$, $\OR$, $\XOR$, $\PLUS$, and $\MINUS$;
    \item $\vtone$ is a bitvector type with width expression $\vwone$;
    \item $\vttwo$ is a bitvector type with width expression $\vwtwo$;
    \item checking whether $\vtone$ and $\vttwo$ have the \structure\ of bitvector types
          of the same width in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is the bitvector type of width $\vwone$ and empty list of bitfields, that is, \\ $\TBits(\vwone, \emptylist)$.
  \end{itemize}

  \item \AllApplyCase{bits\_int}
  \begin{itemize}
    \item $\op$ is either $\PLUS$ or $\MINUS$;
    \item $\vtone$ is a bitvector type with width expression $\vw$;
    \item $\vttwo$ is an integer type;
    \item $\vt$ is the bitvector type of width $\vw$ and empty list of bitfields, that is, \\ $\TBits(\vw, \emptylist)$.
  \end{itemize}

  \item \AllApplyCase{bits\_concat}
  \begin{itemize}
    \item $\op$ is $\CONCAT$;
    \item $\vtone$ is a bitvector type with width expression $\vwone$;
    \item $\vttwo$ is a bitvector type with width expression $\vwtwo$;
    \item define $\vw$ as the addition of $\vwone$ and $\vwtwo$;
    \item applying \normalize{} to $\vw$ in $\tenv$ yields $\vwp$;
    \item $\vt$ is the bitvector type of width $\vwp$ and empty list of bitfields, that is, \\ $\TBits(\vw, \emptylist)$.
  \end{itemize}

  \item \AllApplyCase{string\_concat}
  \begin{itemize}
    \item $\op$ is $\CONCAT$;
    \item $\vtone$ and $\vttwo$ are not both bitvector types;
    \item checking that $\vtone$ is a \Prosesingulartype{} yields $\True$\ProseOrTypeError;
    \item checking that $\vttwo$ is a \Prosesingulartype{} yields $\True$\ProseOrTypeError;
    \item $\vt$ is the string type.
  \end{itemize}

  \item \AllApplyCase{rel}
  \begin{itemize}
    \item the operator $\op$ and types of $\vtone$ and $\vttwo$ match one of the rows in the following table:
    \[
    \begin{array}{lll}
      \mathbf{\op} & \mathbf{\vtone} & \mathbf{\vttwo} \\
      \hline
      \LEQ  & \TInt    & \TInt\\
      \GEQ  & \TInt    & \TInt\\
      \GT   & \TInt    & \TInt\\
      \LT   & \TInt    & \TInt\\
      \LEQ  & \TReal   & \TReal\\
      \GEQ  & \TReal   & \TReal\\
      \GT   & \TReal   & \TReal\\
      \LT   & \TReal   & \TReal\\
      \EQOP & \TInt    & \TInt\\
      \NEQ  & \TInt    & \TInt\\
      \EQOP & \TBool   & \TBool\\
      \NEQ  & \TBool   & \TBool\\
      \EQOP & \TReal   & \TReal\\
      \NEQ  & \TReal   & \TReal\\
      \EQOP & \TString & \TString\\
      \NEQ  & \TString & \TString
    \end{array}
    \]
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item \AllApplyCase{eq\_neq\_bits}
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item $\vtone$ is a bitvector type with width expression $\vwone$;
    \item $\vttwo$ is a bitvector type with width expression $\vwtwo$;
    \item checking whether the bitwidth of $\vtoneanon$ and $\vttwoanon$ is the same yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item \AllApplyCase{eq\_neq\_enum}
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item $\vtone$ is $\TEnum(\vlione)$;
    \item $\vttwo$ is $\TEnum(\vlitwo)$;
    \item checking whether $\vlione$ is equal to $\vlitwo$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item \AllApplyCase{arith\_t\_int\_unconstrained}
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}$;
    \item both $\vtone$ and $\vttwo$ are integer types and at least one them is the unconstrained integer type;
    \item $\vt$ is the unconstrained integer type;
  \end{itemize}

  \item \AllApplyCase{arith\_t\_int\_parameterized}
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}$;
    \item both $\vtone$ and $\vttwo$ are integer types, neither is an unconstrained integer type, and at least one them is a \parameterizedintegertype;
    \item applying $\towellconstrained$ to $\vtone$ yields $\vtonewellconstrained$;
    \item applying $\towellconstrained$ to $\vttwo$ yields $\vttwowellconstrained$;
    \item \Proseapplybinoptypes{$\tenv$}{$\op$}{$\vtonewellconstrained$}{$\vttwowellconstrained$}{$\vt$}.
  \end{itemize}

  \item \AllApplyCase{arith\_t\_int\_wellconstrained}
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \POW, \PLUS, \MINUS, \DIVRM, \DIV, \MOD, \SHL, \SHR\}$;
    \item $\vtone$ is the well-constrained integer type with constraints $\csone$ and \Proseprecisionlossindicator{} $\vpone$;
    \item $\vttwo$ is the well-constrained integer type with constraints $\cstwo$ and \Proseprecisionlossindicator{} $\vptwo$;
    \item applying $\annotateconstraintbinop$ to $\op$, $\csone$, and $\cstwo$ in $\tenv$ yields $\vc$ and $\vpthree$;
    \item defining $\vpthree$ as the $\precisionjoin$ of $\vpone$, $\vptwo$, and $\vpthree$;
    \item $\vt$ is the well-constrained integer type with constraints $\vc$ and \Proseprecisionlossindicator{} $\vp$\
  \end{itemize}

  \item \AllApplyCase{arith\_real}
  \begin{itemize}
    \item the operator $\op$ and types of $\vtone$ and $\vttwo$ match one of the rows in the following table:
    \[
    \begin{array}{lll}
      \mathbf{\op} & \mathbf{\vtone} & \mathbf{\vttwo} \\
      \hline
      \PLUS  & \TReal    & \TReal\\
      \MINUS & \TReal    & \TReal\\
      \MUL   & \TReal    & \TReal\\
      \POW   & \TReal    & \TInt\\
      \RDIV  & \TReal    & \TReal
    \end{array}
    \]
    \item $\vt$ is $\TReal$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item obtaining the \underlyingtype\ of $\vtone$ in $\tenv$ yields $\vtoneanon$\ProseOrTypeError;
    \item obtaining the \underlyingtype\ of $\vttwo$ in $\tenv$ yields $\vttwoanon$\ProseOrTypeError;
    \item the operator and the AST labels of $\vtoneanon$ and $\vttwoanon$ do not match any of the rows in the following table,
    where $\vlone$ and $\vltwo$ are the AST labels of any \Prosesingulartypes{}:
    \[
    \begin{array}{lll}
      \hline
      \mathbf{\op} & \mathbf{\astlabel(\vtoneanon)} & \mathbf{\astlabel(\vttwoanon)} \\
      \hline
      \AND     & \TBool  & \TBool\\
      \OR      & \TBool  & \TBool\\
      \EQOP    & \TBool  & \TBool\\
      \IMPL    & \TBool  & \TBool\\
      %
      \AND     & \TBits  & \TBits\\
      \OR      & \TBits  & \TBits\\
      \XOR     & \TBits  & \TBits\\
      \PLUS    & \TBits  & \TBits\\
      \MINUS   & \TBits  & \TBits\\
      \CONCAT  & \vlone  & \vltwo\\
      %
      \PLUS    & \TBits  & \TInt\\
      \MINUS   & \TBits  & \TInt\\
      %
      \LEQ     & \TInt     & \TInt\\
      \GEQ     & \TInt     & \TInt\\
      \GT      & \TInt     & \TInt\\
      \LT      & \TInt     & \TInt\\
      \LEQ     & \TReal    & \TReal\\
      \GEQ     & \TReal    & \TReal\\
      \GT      & \TReal    & \TReal\\
      \LT      & \TReal    & \TReal\\
      \EQOP    & \TInt     & \TInt\\
      \NEQ     & \TInt     & \TInt\\
      \EQOP    & \TBool    & \TBool\\
      \NEQ     & \TBool    & \TBool\\
      \EQOP    & \TReal    & \TReal\\
      \NEQ     & \TReal    & \TReal\\
      \EQOP    & \TString  & \TString\\
      \NEQ     & \TString  & \TString\\
      %
      \MUL     & \TInt  & \TInt\\
      \DIV     & \TInt  & \TInt\\
      \DIVRM   & \TInt  & \TInt\\
      \MOD     & \TInt  & \TInt\\
      \SHL     & \TInt  & \TInt\\
      \SHR     & \TInt  & \TInt\\
      \POW     & \TInt  & \TInt\\
      \PLUS    & \TInt  & \TInt\\
      \MINUS   & \TInt  & \TInt\\
      \PLUS    & \TReal & \TReal\\
      \MINUS   & \TReal & \TReal\\
      \MUL     & \TReal & \TReal\\
      \RDIV    & \TReal & \TReal\\
      \POW     & \TReal & \TInt\\
      %
      \PLUS    & \TReal & \TReal\\
      \MINUS   & \TReal & \TReal\\
      \MUL     & \TReal & \TReal\\
      \POW     & \TReal & \TInt\\
      \RDIV    & \TReal & \TReal\\
      \hline
    \end{array}
    \]
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[named]{
  \astlabel(\vtone) = \TNamed \lor \astlabel(\vttwo) = \TNamed\\
  \makeanonymous(\tenv, \vtone) \typearrow \vtoneanon \OrTypeError\\\\
  \makeanonymous(\tenv, \vttwo) \typearrow \vttwoanon \OrTypeError\\\\
  \applybinoptypes(\tenv, \op, \vtoneanon, \vttwoanon) \typearrow \vt \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt
}
\end{mathpar}

\begin{mathpar}
\inferrule[boolean]{
  \op \in  \{\BAND, \BOR, \IMPL, \EQOP\}
}{
  \applybinoptypes(\tenv, \op, \overname{\TBool}{\vtone}, \overname{\TBool}{\vttwo}) \typearrow \overname{\TBool}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_arith]{
  \op \in  \{\AND, \OR, \XOR, \PLUS, \MINUS\}\\
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \overname{\TBits(\vwone, \Ignore)}{\vtone}, \overname{\TBits(\vwtwo, \Ignore)}{\vttwo})
  \typearrow \overname{\TBits(\vwone, \emptylist)}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_int]{
  \op \in  \{\PLUS, \MINUS\}}{
  \applybinoptypes(\tenv, \op, \overname{\TBits(\vw, \Ignore)}{\vtone}, \overname{\TInt(\Ignore)}{\vttwo}) \typearrow
  \overname{\TBits(\vw, \emptylist)}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_concat]{
  \vw \eqdef \EBinop(\PLUS, \vwone, \vwtwo) \\
  \normalize(\tenv, \vw) \typearrow \vwp
}{
  \applybinoptypes(\tenv, \CONCAT, \overname{\TBits(\vwone, \Ignore)}{\vtone}, \overname{\TBits(\vwtwo, \Ignore)}{\vttwo}) \typearrow
  \overname{\TBits(\vwp, \emptylist)}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[string\_concat]{
  \vtone \neq \TBits(\Ignore, \Ignore) \lor \vttwo \neq \TBits(\Ignore, \Ignore) \\
  \checktrans{\issingular(\vtone)}{\UnexpectedType} \typearrow \True \OrTypeError \\
  \checktrans{\issingular(\vttwo)}{\UnexpectedType} \typearrow \True \OrTypeError
}{
  \applybinoptypes(\tenv, \CONCAT, \vtone, \vttwo) \typearrow
  \overname{\TString}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[rel]{
  {
    (\op, \vtone, \vttwo) \in \left\{
      \begin{array}{lclcl}
        (\LEQ     &,& \TInt     &,& \TInt)\\
        (\GEQ     &,& \TInt     &,& \TInt)\\
        (\GT      &,& \TInt     &,& \TInt)\\
        (\LT      &,& \TInt     &,& \TInt)\\
        (\LEQ     &,& \TReal    &,& \TReal)\\
        (\GEQ     &,& \TReal    &,& \TReal)\\
        (\GT      &,& \TReal    &,& \TReal)\\
        (\LT      &,& \TReal    &,& \TReal)\\
        (\EQOP    &,& \TInt     &,& \TInt)\\
        (\NEQ     &,& \TInt     &,& \TInt)\\
        (\EQOP    &,& \TBool    &,& \TBool)\\
        (\NEQ     &,& \TBool    &,& \TBool)\\
        (\EQOP    &,& \TReal    &,& \TReal)\\
        (\NEQ     &,& \TReal    &,& \TReal)\\
        (\EQOP    &,& \TString  &,& \TString)\\
        (\NEQ     &,& \TString  &,& \TString)\\
      \end{array}
      \right\}
  }
}{
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \overname{\TBool}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_neq\_bits]{
  \op \in  \{\EQOP, \NEQ\}\\
  \checkbitsequalwidth(\tenv, \vtoneanon, \vttwoanon) \typearrow \True \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \overname{\TBits(\vwone, \Ignore)}{\vtone}, \overname{\TBits(\vwtwo, \Ignore)}{\vttwo}) \typearrow \overname{\TBool}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_neq\_enum]{
  \op \in  \{\EQOP, \NEQ\}\\
  \checktrans{\vlione = \vlitwo}{DifferentEnumLabels} \checktransarrow \True \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \overname{\TEnum(\vlione)}{\vtone}, \overname{\TEnum(\vlitwo)}{\vttwo}) \typearrow \overname{\TBool}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_t\_int\_unconstrained]{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}\\
  \vcone = \unconstrained \lor \vctwo = \unconstrained
}{
  \applybinoptypes(\tenv, \op, \overname{\TInt(\vcone)}{\vtone}, \overname{\TInt(\vctwo)}{\vttwo}) \typearrow \unconstrainedinteger
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_t\_int\_parameterized]{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}\\
  \astlabel(\vcone) = \parameterized \lor \astlabel(\vctwo) = \parameterized\\
  \astlabel(\vcone) \neq \unconstrained \land \astlabel(\vctwo) \neq \unconstrained\\
  \towellconstrained(\vtone) \typearrow \vtonewellconstrained\\
  \towellconstrained(\vttwo) \typearrow \vttwowellconstrained\\
  \applybinoptypes(\tenv, \vtonewellconstrained, \vttwowellconstrained) \typearrow \vt \OrTypeError
}{
  \applybinoptypes(\tenv, \op, \overname{\TInt(\vcone)}{\vtone}, \overname{\TInt(\vctwo)}{\vttwo}) \typearrow \vt
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_t\_int\_wellconstrained]{
  \op \in  \{\MUL, \POW, \PLUS, \MINUS, \DIVRM, \DIV, \MOD, \SHL, \SHR\}\\
  \vcone = \wellconstrained(\cstwo, \vpone)\\
  \vctwo = \wellconstrained(\csone, \vptwo)\\
  \annotateconstraintbinop(\tenv, \op, \vcsone, \vcstwo) \typearrow (\cs, \vpthree) \OrTypeError\\\\
  \vp = \precisionjoin(\vpone, \precisionjoin(\vptwo, \vpthree))
}{
      \applybinoptypes(\tenv, \op, \overname{\TInt(\vcone)}{\vtone},
        \overname{\TInt(\vctwo)}{\vttwo}) \typearrow
        \overname{\TInt(\wellconstrained(\cs, \vp))}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_real]{
  (\op, \vtone, \vttwo) \in
  {
    \left\{
    \begin{array}{lclcl}
      (\PLUS  &,& \TReal &,& \TReal)\\
      (\MINUS &,& \TReal &,& \TReal)\\
      (\MUL   &,& \TReal &,& \TReal)\\
      (\POW   &,& \TReal &,& \TInt)\\
      (\RDIV  &,& \TReal &,& \TReal)
    \end{array}
    \right\}
  }
}{
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \overname{\TReal}{\vt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \makeanonymous(\tenv, \vtone) \typearrow \vtoneanon \OrTypeError\\\\
  \makeanonymous(\tenv, \vttwo) \typearrow \vttwoanon \OrTypeError\\\\
  {
  \begin{array}{l}
  (\op, \astlabel(\vtoneanon), \astlabel(\vttwoanon)) \not\in\\
    \left\{
    \begin{array}{lclcl}
      (\AND     &,& \TBool  &,& \TBool)\\
      (\OR      &,& \TBool  &,& \TBool)\\
      (\EQOP    &,& \TBool  &,& \TBool)\\
      (\IMPL    &,& \TBool  &,& \TBool)\\
      %
      (\AND     &,& \TBits  &,& \TBits)\\
      (\OR      &,& \TBits  &,& \TBits)\\
      (\XOR     &,& \TBits  &,& \TBits)\\
      (\PLUS    &,& \TBits  &,& \TBits)\\
      (\MINUS   &,& \TBits  &,& \TBits)\\
      (\CONCAT  &,& \TBits  &,& \TBits)\\
      %
      (\PLUS    &,& \TBits  &,& \TInt)\\
      (\MINUS   &,& \TBits  &,& \TInt)\\
      %
      (\LEQ     &,& \TInt     &,& \TInt)\\
      (\GEQ     &,& \TInt     &,& \TInt)\\
      (\GT      &,& \TInt     &,& \TInt)\\
      (\LT      &,& \TInt     &,& \TInt)\\
      (\LEQ     &,& \TReal    &,& \TReal)\\
      (\GEQ     &,& \TReal    &,& \TReal)\\
      (\GT      &,& \TReal    &,& \TReal)\\
      (\LT      &,& \TReal    &,& \TReal)\\
      (\EQOP    &,& \TInt     &,& \TInt)\\
      (\NEQ     &,& \TInt     &,& \TInt)\\
      (\EQOP    &,& \TBool    &,& \TBool)\\
      (\NEQ     &,& \TBool    &,& \TBool)\\
      (\EQOP    &,& \TReal    &,& \TReal)\\
      (\NEQ     &,& \TReal    &,& \TReal)\\
      (\EQOP    &,& \TString  &,& \TString)\\
      (\NEQ     &,& \TString  &,& \TString)\\
      %
      (\MUL   &,& \TInt  &,& \TInt)\\
      (\DIV   &,& \TInt  &,& \TInt)\\
      (\DIVRM &,& \TInt  &,& \TInt)\\
      (\MOD   &,& \TInt  &,& \TInt)\\
      (\SHL   &,& \TInt  &,& \TInt)\\
      (\SHR   &,& \TInt  &,& \TInt)\\
      (\POW   &,& \TInt  &,& \TInt)\\
      (\PLUS  &,& \TInt  &,& \TInt)\\
      (\MINUS &,& \TInt  &,& \TInt)\\
      (\PLUS  &,& \TReal &,& \TReal)\\
      (\MINUS &,& \TReal &,& \TReal)\\
      (\MUL   &,& \TReal &,& \TReal)\\
      (\RDIV  &,& \TReal &,& \TReal)\\
      (\POW   &,& \TReal &,& \TInt)\\
      %
      (\PLUS  &,& \TReal &,& \TReal)\\
      (\MINUS &,& \TReal &,& \TReal)\\
      (\MUL   &,& \TReal &,& \TReal)\\
      (\POW   &,& \TReal &,& \TInt)\\
      (\RDIV  &,& \TReal &,& \TReal)
    \end{array}
    \right\}\\
    \cup \{ (\CONCAT, \astlabel(\vtone), \astlabel(\vttwo)) \;|\; \issingular(\vtone) \land \issingular(\vttwo)\}\\
  \end{array}
  }
}{
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \TypeErrorVal{\BadOperands}
}
\end{mathpar}
\CodeSubsection{\applybinoptypesBegin}{\applybinoptypesEnd}{../Typing.ml}

\identr{BKNT} \identr{ZYWY} \identr{BZKW}
\identr{KFYS} \identr{KXMR} \identr{SQXN} \identr{MRHT} \identr{JGWF}
\identr{TTGQ} \identi{YHML} \identi{YHRP} \identi{VMZF} \identi{YXSY}
\identi{LGHJ} \identi{RXLG}

\TypingRuleDef{FindNamedLCA}
\hypertarget{def-namedlowestcommonancestor}{}
The function
\[
  \namedlca(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\ty}{\tty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the lowest common named super type --- $\tty$ --- of the types $\vt$ and $\vs$ in $\tenv$.

\hypertarget{def-supers}{}
The helper function
\[
  \supers(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt})
  \aslto \pow{\ty}
\]
returns the set of \emph{named supertypes} of a type $\vt$
in the $\subtypes$ function of a global static environment $\tenv$:
\[
  \supers(\tenv, \vt) \triangleq
  \begin{cases}
    \{\vt\} \cup \supers(\vs) & \text{ if }G^\tenv.\subtypes(\vt) = \vs\\
    \{\vt\}  & \text{ otherwise } (\text{that is, }G^\tenv.\subtypes(\vt) = \bot)\\
  \end{cases}
\]

\ExampleDef{Finding Named Lowest Common Ancestors}
In \listingref{find-named-lca},
the set of named supertypes for \verb|B2| is \verb|{A1, A2, B1, B2}|,
set of named supertypes for \verb|C2| is \verb|{A1, A2, C1, C2}|,
therefore the named lowest common ancestor of \verb|B2| and \verb|C2|
is \verb|A2|, while \verb|B2| and \verb|D1| have no
named lowest common ancestor.

\ASLListing{Finding named lowest common ancestors}{find-named-lca}{\typingtests/TypingRule.FindNamedLCA.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item $\vtsupers$ is in the set of named supertypes of $\vt$;
  \item \AllApplyCase{found}
  \begin{itemize}
    \item $\vs$ is in $\vtsupers$;
    \item $\tty$ is $\vs$;
  \end{itemize}

  \item \AllApplyCase{super}
  \begin{itemize}
    \item $\vs$ is not in $\vtsupers$;
    \item $\vs$ has a named super type in $\tenv$ --- $\vsp$;
    \item $\tty$ is the lowest common named \supertypeterm{} of $\vt$ and $\vsp$ in $\tenv$.
  \end{itemize}

  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is not in $\vtsupers$;
    \item $\vs$ has no named super type in $\tenv$;
    \item $\tty$ is $\None$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[found]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \in \vtsupers
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \vs
}
\and
\inferrule[super]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \not\in \vtsupers\\
  G^\tenv.\subtypes(\vs) = \vsp\\
  \namedlca(\tenv, \vt, \vsp) \typearrow \tty
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \tty
}
\and
\inferrule[none]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \not\in \vtsupers\\
  G^\tenv.\subtypes(\vs) = \bot
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \None
}
\end{mathpar}

\TypingRuleDef{AnnotateConstraintBinop}
\hypertarget{def-annotateconstraintbinop}{}
The function
\[
\begin{array}{r}
\annotateconstraintbinop(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint^*}{\csone} \aslsep
  \overname{\intconstraint^*}{\cstwo}
) \aslto \\
\left(
  \overname{\intconstraint^*}{\annotatedcs} \aslsep
  \overname{\precisionlossindicator}{\vp}
\right)
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the application of the binary operation $\op$ to the lists of integer constraints
$\csone$ and $\cstwo$, yielding a list of constraints --- $\annotatedcs$.
\ProseOtherwiseTypeError\

The operator $\op$ is assumed to be only one of the operators in the following set:
$\{\SHL, \SHR, \POW, \MOD, \DIVRM, \MINUS, \MUL, \PLUS, \DIV\}$.
The rule employs $\binopisexploding$ to decide whether range constraints can be maintained
as range constraints or have to be converted to a list of exact constraints.

\ExampleDef{Annotating Constraints for Binary Operations}
Applying $\PLUS$ to
$\{ \AbbrevConstraintRange{\ELInt{2}}{\ELInt{4}}\}$ and
$\{\AbbrevConstraintExact{\ELInt{2}}\}$ results in\\
$\{\AbbrevConstraintRange{\ELInt{4}}{\ELInt{6}}\}$,
since $\binopisexploding(\PLUS) \typearrow \False$
while applying $\MUL$ to the same lists of constraints results in
$\{\AbbrevConstraintExact{\ELInt{4}}, \AbbrevConstraintExact{\ELInt{6}}, \AbbrevConstraintExact{\ELInt{8}}\}$,
since $\binopisexploding(\MUL) \typearrow \True$.

Annotating the constraints involves applying symbolic reasoning and in particular filtering out values that
will definitely result in a dynamic error.

Also see \ExampleRef{Applying Binary Operations to Constrained Integers}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\binopfilterrhs$ to $\op$ $\cstwo$ in $\tenv$, to filter out constraints that will definitely fail dynamically, yields $\cstwof$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{exploding}
    \begin{itemize}
      \item applying $\binopisexploding$ to $\op$ yields $\True$;
      \item applying $\explodeintervals$ to $\csone$ in $\tenv$ yields $(\csonee \aslsep \vpone)$;
      \item applying $\explodeintervals$ to $\cstwof$ in $\tenv$ yields $(\cstwoe \aslsep \vptwo)$;
      \item applying $\precisionjoin$ to $\vpone$ and $\vptwo$ yields $\vpzero$;
      \item \Proseeqdef{$\vexpectedconstraintlength$}{the number of constraints in \\
            $\cstwoe$ if $\op$ is $\MOD$
            and the multiplication of numbers of constraints in $\csonee$ and $\cstwoe$, respectively};
      \item \Proseeqdef{$(\csonearg, \cstwoarg, \vp)$}{$(\csonee, \cstwoe, \vpzero)$ if \\
            $\vexpectedconstraintlength$ is
            less than $\maxconstraintsize$ and \\
            $(\csone, \cstwof, \PrecisionLost)$, otherwise};
    \end{itemize}

    \item \AllApplyCase{non\_exploding}
    \begin{itemize}
      \item applying $\binopisexploding$ to $\op$ yields $\False$;
      \item \Proseeqdef{$\vp$}{$\PrecisionFull$};
      \item \Proseeqdef{$(\csonearg, \cstwoarg)$}{$(\csone, \cstwof)$};
    \end{itemize}
  \end{itemize}
  \item applying $\constraintbinop$ to $\op$, $\csonearg$, and $\cstwoarg$ yields $\csvanilla$;
  \item applying $\refineconstraintfordiv$ to $\op$ and $\csvanilla$ yields $\refinedcs$\ProseOrTypeError;
  \item applying $\reduceconstraints$ to $\refinedcs$ in $\tenv$ yields $\annotatedcs$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exploding]{
  \binopfilterrhs(\tenv, \op, \cstwo) \typearrow \cstwof\\\\
  \commonprefixline\\\\
  \binopisexploding(\op) \typearrow \True\\
  \explodeintervals(\tenv, \csone) \typearrow (\csonee, \vpone)\\
  \explodeintervals(\tenv, \cstwof) \typearrow (\cstwoe, \vptwo)\\
  \vpzero \eqdef \precisionjoin(\vpone, \vptwo)\\
  \vexpectedconstraintlength \eqdef \choice{\op = \MOD}{\listlen{\cstwoe}}{\listlen{\csonee} \times \listlen{\cstwoe}}\\
  {
  (\csonearg, \cstwoarg, \vp) \eqdef
  \begin{array}{ll}
    \textbf{if }&\vexpectedconstraintlength < \maxconstraintsize\text{ then}\\
    & (\csonee, \cstwoe, \vpzero)\\
    \textbf{else}&\\
    & (\csone, \cstwof, \PrecisionLost )
  \end{array}
  }\\\\
  \commonsuffixline\\\\
  \constraintbinop(\op, \csonearg, \cstwoarg) \typearrow \csvanilla\\
  \refineconstraintfordiv(\op, \csvanilla) \typearrow \refinedcs \OrTypeError\\\\
  \reduceconstraints(\tenv, \refinedcs) \typearrow \annotatedcs
}{
  \annotateconstraintbinop(\tenv, \op, \csone, \cstwo) \typearrow \annotatedcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_exploding]{
  \binopfilterrhs(\tenv, \op, \cstwo) \typearrow \cstwof\\\\
  \commonprefixline\\\\
  \binopisexploding(\op) \typearrow \False\\
  \vp \eqdef \PrecisionFull \\
  (\csonearg, \cstwoarg) \eqdef (\csone, \cstwof)\\\\
  \commonsuffixline\\\\
  \constraintbinop(\op, \csonearg, \cstwoarg) \typearrow \csvanilla\\
  \refineconstraintfordiv(\op, \csvanilla) \typearrow \refinedcs \OrTypeError\\\\
  \reduceconstraints(\tenv, \refinedcs) \typearrow \annotatedcs
}{
  \annotateconstraintbinop(\tenv, \op, \csone, \cstwo) \typearrow \annotatedcs
}
\end{mathpar}
\CodeSubsection{\AnnotateConstraintBinopBegin}{\AnnotateConstraintBinopEnd}{../StaticOperations.ml}

\TypingRuleDef{BinopFilterRhs}
\hypertarget{def-binopfilterrhs}{}
The function
\[
\binopfilterrhs(\overname{\staticenvs}{\tenv} \aslsep \overname{\binop}{\op} \aslsep \overname{\intconstraint^*}{\cs})
\aslto \overname{\intconstraint^*}{\newcs}
\]
filters the list of constraints $\cs$ by removing values that will definitely result in a dynamic
error if found on the right-hand-side of a binary operation expression with the operator $\op$
in any environment consisting of the static environment $\tenv$.
The result is the filtered list of constraints $\newcs$.

\ExampleDef{Filtering Right-hand-side Constraints}
An example of filtering constraints appears in \listingref{apply-binop-constraints},
where the constraints inferred for \verb|a_div| filter out \verb|-5..0|
from the constraint \verb|-5..3|, thus avoiding including constraints
\verb|A DIV -5| and \verb|A DIV 0|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{greater\_or\_equal}
  \begin{itemize}
    \item $\op$ is one of $\SHL$, $\SHR$, and $\POW$;
    \item define $\vf$ as the specialization of $\refineconstraintbysign$ for the predicate
          $\lambda x.\ x \geq 0$, which is $\True$ if and only if the tested number is greater or equal to $0$;
    \item refining the list of constraints $\cs$ with $\vf$ via $\refineconstraints$ yields $\newcs$;
    \item checking whether $\newcs$ is empty yields $\True$\ProseTerminateAs{\BadOperands}.
  \end{itemize}

  \item \AllApplyCase{greater\_than}
  \begin{itemize}
    \item $\op$ is one of $\MOD$, $\DIV$, and $\DIVRM$;
    \item define $\vf$ as the specialization of $\refineconstraintbysign$ for the predicate
          $\lambda x.\ x > 0$, which is $\True$ if and only if the tested number is greater than $0$;
    \item refining the list of constraints $\cs$ with $\vf$ via $\refineconstraints$ yields $\newcs$;
    \item checking whether $\newcs$ is empty yields $\True$\ProseTerminateAs{\BadOperands}.
  \end{itemize}

  \item \AllApplyCase{no\_filtering}
  \begin{itemize}
    \item $\op$ is one of $\MINUS$, $\MUL$, and $\PLUS$;
    \item $\newcs$ is $\cs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[greater\_or\_equal]{
  \op \in \{\SHL, \SHR, \POW\}\\\\
  \vf \eqdef \refineconstraintbysign(\tenv, \lambda x.\ x \geq 0)\\
  \refineconstraints(\cs, \vf) \typearrow \newcs\\
  \checktrans{\newcs \neq \emptylist}{\BadOperands} \typearrow \True\OrTypeError
}{
  \binopfilterrhs(\tenv, \op, \cs) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[greater\_than]{
  \op \in \{\MOD, \DIV, \DIVRM\}\\\\
  \vf \eqdef \refineconstraintbysign(\tenv, \lambda x.\ x > 0)\\
  \refineconstraints(\cs, \vf) \typearrow \newcs\\
  \checktrans{\newcs \neq \emptylist}{\BadOperands} \typearrow \True\OrTypeError
}{
  \binopfilterrhs(\tenv, \op, \cs) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_filtering]{
  \op \in \{\MINUS, \MUL, \PLUS\}
}{
  \binopfilterrhs(\op, \cs) \typearrow \overname{\cs}{\newcs}
}
\end{mathpar}

\TypingRuleDef{RefineConstraintBySign}
\hypertarget{def-refineconstraintbysign}{}
The function
\[
\refineconstraintbysign(\overname{\staticenvs}{\tenv} \aslsep \overname{\Z\rightarrow \Bool}{\vp} \aslsep \overname{\intconstraint}{\vc})
\aslto \overname{\langle\intconstraint\rangle}{\vcopt}
\]
takes a predicate $\vp$ that returns $\True$ based on the sign of its input.
The function conservatively refines the constraint $\vc$ in $\tenv$ by applying symbolic reasoning to yield a new constraint
(inside an optional)
that represents the values that satisfy the $\vc$ and for which $\vp$ holds.
In this context, conservatively means that the new constraint may represent a superset of the values that a more precise
reasoning may yield.
If the set of those values is empty the result is $\None$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact\_reduces\_to\_z}
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\reducetozopt$ to $\ve$ in $\tenv$, in order to symbolically simplify $\ve$ to an integer,
          yields $\langle\vz\rangle$;
    \item $\vcopt$ is $\langle\vc\rangle$ if $\vp$ holds for $\vz$ and $\None$ otherwise.
  \end{itemize}

  \item \AllApplyCase{exact\_does\_not\_reduce\_to\_z}
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\reducetozopt$ to $\ve$ in $\tenv$, in order to symbolically simplify $\ve$ to an integer,
          yields $\None$;
    \item $\vcopt$ is $\langle\vc\rangle$.
  \end{itemize}

  \item \AllApplyCase{range\_both\_reduce\_to\_z}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$, in order to symbolically simplify $\veone$ to an integer,
          yields $\langle\vzone\rangle$;
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$, in order to symbolically simplify $\vetwo$ to an integer,
          yields $\langle\vztwo\rangle$;
    \item \OneApplies{} (defining $\vcopt$)
    \begin{itemize}
      \item if $\vp$ is $\True$ for both $\vzone$ and $\vztwo$, define $\vcopt$ as $\langle\vc\rangle$;
      \item if $\vp$ is $\False$ for $\vzone$ and $\True$ for $\vztwo$, define $\vcopt$ as the optional range constraint
            where the bottom expression is the literal expression for $0$ if $\vp$ holds for $0$ and the literal expression for $1$ otherwise,
            and the top expression is $\vetwo$;
      \item if $\vp$ is $\True$ for $\vzone$ and $\False$ for $\vztwo$, define $\vcopt$ as the optional range constraint
            where the bottom expression is $\veone$ and the top expression is the literal expression for $0$ if $\vp$ holds for $0$
            and the literal expression for $-1$ otherwise;
      \item if $\vp$ is $\False$ for both $\vzone$ and $\vztwo$, define $\vcopt$ as $\None$.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{only\_e1\_reduces\_to\_z}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$, in order to symbolically simplify $\veone$ to an integer,
          yields $\langle\vzone\rangle$;
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$, in order to symbolically simplify $\vetwo$ to an integer,
          yields $\None$;
    \item \OneApplies{} (defining $\vcopt$):
    \begin{itemize}
      \item if $\vp$ is $\True$ for $\vzone$, define $\vcopt$ as $\langle\vc\rangle$;
      \item if $\vp$ is $\False$ for $\vzone$, define $\vcopt$ as the optional range constraint with the bottom expression
            as the literal expression for $0$ if $\vp$ holds for $0$ and the literal expression for $1$ otherwise,
            and the top expression $\vetwo$.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{only\_e2\_reduces\_to\_z}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$, in order to symbolically simplify $\veone$ to an integer,
          yields $\None$;
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$, in order to symbolically simplify $\vetwo$ to an integer,
          yields $\langle\vztwo\rangle$;
    \item One of the following applies (defining $\vcopt$):
    \begin{itemize}
      \item if $\vp$ is $\True$ for $\vztwo$, define $\vcopt$ as $\langle\vc\rangle$;
      \item if $\vp$ is $\False$ for $\vztwo$, define $\vcopt$ as the optional range constraint with the bottom expression
            $\veone$ and the top expression the literal expression for $0$ if $\vp$ holds for $0$ and the literal expression for $-1$ otherwise.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{none\_reduce\_to\_z}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$, in order to symbolically simplify $\veone$ to an integer,
          yields $\None$;
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$, in order to symbolically simplify $\vetwo$ to an integer,
          yields $\None$;
    \item \Proseeqdef{$\vcopt$}{$\vc$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact\_reduces\_to\_z]{
  \reducetozopt(\tenv, \ve) \typearrow \langle\vz\rangle\\
  \vcopt \eqdef \choice{\vp(\vz)}{\langle\vc\rangle}{\None}
}{
  \refineconstraintbysign(\tenv, \vp, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_does\_not\_reduce\_to\_z]{
  \reducetozopt(\tenv, \ve) \typearrow \None
}{
  \refineconstraintbysign(\tenv, \vp, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\langle\vc\rangle}{\vcopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_both\_reduce\_to\_z]{
  \reducetozopt(\tenv, \veone) \typearrow \langle\vzone\rangle\\
  \reducetozopt(\tenv, \vetwo) \typearrow \langle\vztwo\rangle\\
  {
    \begin{array}{c}
  \vcopt \eqdef \\ \wrappedline\ \begin{cases}
    \langle\vc\rangle& \text{if }\vp(\vzone) \land \vp(\vztwo)\\
    \langle\ConstraintRange(\choice{\vp(0)}{\ELInt{0}}{\ELInt{1}}, \vetwo)\rangle& \text{if }\neg\vp(\vzone) \land \vp(\vztwo)\\
    \langle\ConstraintRange(\veone, \choice{\vp(0)}{\ELInt{0}}{\ELInt{-1}})\rangle& \text{if }\vp(\vzone) \land \neg\vp(\vztwo)\\
    \None& \text{if }\neg\vp(\vzone) \land \neg\vp(\vztwo)\\
  \end{cases}
\end{array}
  }
}{
  \refineconstraintbysign(\tenv, \vp, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[only\_e1\_reduces\_to\_z]{
  \vc = \ConstraintRange(\veone, \vetwo)\\
  \reducetozopt(\tenv, \veone) \typearrow \langle\vzone\rangle\\
  \reducetozopt(\tenv, \vetwo) \typearrow \None\\
  {
    \begin{array}{c}
  \vcopt \eqdef \\ \wrappedline\ \begin{cases}
    \langle\vc\rangle& \text{if }\vp(\vzone)\\
    \langle\ConstraintRange(\choice{\vp(0)}{\ELInt{0}}{\ELInt{1}}, \vetwo)\rangle& \text{else}\\
  \end{cases}
\end{array}
  }
}{
  \refineconstraintbysign(\tenv, \vp, \vc) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[only\_e2\_reduces\_to\_z]{
  \vc = \ConstraintRange(\veone, \vetwo)\\
  \reducetozopt(\tenv, \veone) \typearrow \None\\
  \reducetozopt(\tenv, \vetwo) \typearrow \langle\vztwo\rangle\\
  {
    \begin{array}{c}
  \vcopt \eqdef \\ \wrappedline\ \begin{cases}
    \langle\vc\rangle& \text{if }\vp(\vztwo)\\
    \langle\ConstraintRange(\veone, \choice{\vp(0)}{\ELInt{0}}{\ELInt{-1}})\rangle& \text{else}\\
  \end{cases}
\end{array}
  }
}{
  \refineconstraintbysign(\tenv, \vp, \vc) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[none\_reduce\_to\_z]{
  \vc = \ConstraintRange(\veone, \vetwo)\\
  \reducetozopt(\tenv, \veone) \typearrow \None\\
  \reducetozopt(\tenv, \vetwo) \typearrow \None
}{
  \refineconstraintbysign(\tenv, \vp, \vc) \typearrow \overname{\vc}{\vcopt}
}
\end{mathpar}

\TypingRuleDef{ReduceToZOpt}
\hypertarget{def-reducetozopt}{}
The function
\[
\reducetozopt(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve})
\aslto \overname{\langle\Z\rangle}{\vzopt}
\]
returns an integer inside an optional if $\ve$ can be symbolically simplified into an integer in $\tenv$
and $\None$ otherwise.
The expression $\ve$ is assumed to appear in a constraint for a type that has been successfully annotated,
which means that applying $\normalize$ to it should not yield a \typingerrorterm{}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{normalizes\_to\_z}
  \begin{itemize}
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields a literal expression for the integer $\vz$;
    \item define $\vzopt$ as $\langle\vz\rangle$.
  \end{itemize}

  \item \AllApplyCase{does\_not\_normalize\_to\_z}
  \begin{itemize}
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields an expression that is not an integer literal;
    \item define $\vzopt$ as $\None$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[normalizes\_to\_z]{
  \normalize(\tenv, \ve) \typearrow \ELInt{\vz}
}{
  \reducetozopt(\tenv, \ve) \typearrow \overname{\langle\vz\rangle}{\vzopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[does\_not\_normalize\_to\_z]{
  \normalize(\tenv, \ve) \typearrow \vep\\
  \forall \vz\in\Z.\ \vep \neq \ELInt{\vz}
}{
  \reducetozopt(\tenv, \ve) \typearrow \overname{\None}{\vzopt}
}
\end{mathpar}

\TypingRuleDef{RefineConstraints}
\hypertarget{def-refineconstraints}{}
The function
\[
\begin{array}{r}
\refineconstraints(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint\rightarrow\langle\intconstraint\rangle}{\vf} \aslsep \overname{\intconstraint^*}{\cs})
\aslto \\
\overname{\intconstraint^*}{\newcs}
\end{array}
\]
refines a list of constraints $\cs$ by applying the refinement function $\vf$ to each constraint and retaining the constraints
that do not refine to $\None$. The resulting list of constraints is given in $\newcs$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\cs$ is the empty list;
    \item $\newcs$ is the empty list.
  \end{itemize}

  \item \AllApplyCase{non\_empty\_none}
  \begin{itemize}
    \item $\cs$ is the list with $\vc$ as its \head\ and $\csone$ as its \tail;
    \item applying $\vf$ to $\vc$ yields $\None$;
    \item applying $\refineconstraints$ to $\vf$ and $\csone$ yields $\csonep$;
    \item $\newcs$ is $\csonep$.
  \end{itemize}

  \item \AllApplyCase{non\_empty\_some}
  \begin{itemize}
    \item $\cs$ is the list with $\vc$ as its \head\ and $\csone$ as its \tail;
    \item applying $\vf$ to $\vc$ yields $\langle\vcp\rangle$;
    \item applying $\refineconstraints$ to $\vf$ and $\csone$ yields $\csonep$;
    \item $\newcs$ is the list with $\vcp$ as its \head\ and $\csonep$ as its \tail.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \refineconstraints(\tenv, \vf, \overname{\emptylist}{\cs}) \typearrow \overname{\emptylist}{\newcs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty\_none]{
  \vf(\vc) \typearrow \None\\
  \refineconstraints(\vf, \csone) \typearrow \csonep\\
}{
  \refineconstraints(\vf, \overname{[\vc]\concat \csone}{\cs}) \typearrow \overname{\csonep}{\newcs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty\_some]{
  \vf(\vc) \typearrow \langle\vcp\rangle\\
  \refineconstraints(\vf, \csone) \typearrow \csonep\\
}{
  \refineconstraints(\vf, \overname{[\vc]\concat \csone}{\cs}) \typearrow \overname{[\vcp] \concat \csonep}{\newcs}
}
\end{mathpar}

\TypingRuleDef{RefineConstraintForDiv}
\hypertarget{def-refineconstraintfordiv}{}
The function
\[
\refineconstraintfordiv(\overname{\binop}{\op} \aslsep \overname{\intconstraint^*}{\cs}) \aslto \overname{\intconstraint^*}{\vres}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
filters the list of constraints $\cs$ for $\op$,
removing constraints that represents a division operation that will definitely fail
when $\op$ is the division operation.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{div}
  \begin{itemize}
    \item $\op$ is $\DIV$;
    \item applying $\filterreduceconstraintdiv$ to each constraint $\cs[\vi]$, for each $\vi$ in $\listrange(\cs)$,
          yields the optional constraint $\vcopt_\vi$\ProseOrTypeError;
    \item define $\vres$ as the list made of constraints $\vcp_\vi$, for each $\vi$ in $\listrange(\cs)$
          such that $\vcopt_\vi = \langle\vcp_\vi\rangle$;
    \item checking that $\vres$ is not the empty list yields $\True$\ProseTerminateAs{\BadOperands}.
  \end{itemize}

  \item \AllApplyCase{non\_div}
  \begin{itemize}
    \item $\op$ is not $\DIV$;
    \item define $\vres$ as $\cs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[div]{
  \op = \DIV\\
  \vi\in\listrange(\cs): \filterreduceconstraintdiv(\cs[\vi]) \typearrow \vcopt_\vi \OrTypeError\\\\
  \vres \eqdef [\vi\in\listrange(\cs): \choice{\vcopt_\vi = \langle\vcp_\vi\rangle}{\vcp}{\epsilon}]\\
  \checktrans{\vres \neq \emptylist}{\BadOperands} \checktransarrow \True \OrTypeError
}{
  \refineconstraintfordiv(\op, \cs) \typearrow \vres
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_div]{
  \op \neq \DIV
}{
  \refineconstraintfordiv(\op, \cs) \typearrow \overname{\cs}{\vres}
}
\end{mathpar}
\CodeSubsection{\RefineConstraintForDIVBegin}{\RefineConstraintForDIVEnd}{../types.ml}

\TypingRuleDef{FilterReduceConstraintDiv}
\hypertarget{def-filterreduceconstraintdiv}{}
The function
\[
\filterreduceconstraintdiv(\overname{\intconstraint}{\vc}) \aslto \overname{\langle\intconstraint\rangle}{\vcopt}
\]
returns $\None$ if $\vc$ is an exact constraint for a binary expression for dividing two integer literals
where the denominator does not divide the numerator and an optional containing $\vc$.
The result is returned in $\vcopt$.
This is used to conservatively test whether $\vc$ would always fail dynamically.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\getliteraldivopt$ to $\ve$ yields $\langle(\vzone, \vztwo)\rangle$\ProseTerminateAs{\None};
    \item define $\vcopt$ as follows:
    \begin{itemize}
      \item $\None$, if $\vztwo$ is positive and $\vztwo$ does not divide $\vzone$;
      \item $\langle\vc\rangle$, otherwise.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is a range constraint for $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\getliteraldivopt$ to $\veone$ yields $\veoneopt$;
    \item define $\vzoneopt$ as follows:
    \begin{itemize}
      \item $\vzone$ divided by $\vztwo$ and rounded up, if $\veoneopt$ is $(\vzone, \vztwo)$ and $\vztwo$ is positive;
      \item $\None$, otherwise.
    \end{itemize}
    \item applying $\getliteraldivopt$ to $\vetwo$ yields $\vetwoopt$;
    \item define $\vztwoopt$ as follows:
    \begin{itemize}
      \item $\vzthree$ divided by $\vzfour$ and rounded down, if $\vetwoopt$ is $(\vzthree, \vzfour)$ and $\vzfour$ is positive;
      \item $\None$, otherwise.
    \end{itemize}
    \item define $\vcopt$ as follows:
    \begin{itemize}
      \item the exact constraint for the literal integer $\vzfive$, if $\vzoneopt$ is $\langle\vzfive\rangle$ and $\vztwoopt$ is $\langle\vzsix\rangle$ and $\vzfive$ is equal to $\vzsix$;
      \item the range constraint for the literal integer $\vzfive$ and $\vzsix$, if $\vzoneopt$ is $\langle\vzfive\rangle$ and $\vztwoopt$ is $\langle\vzsix\rangle$ and $\vzfive$ is less than $\vzsix$;
      \item $\None$, if $\vzoneopt$ is $\langle\vzfive\rangle$ and $\vztwoopt$ is $\langle\vzsix\rangle$ and $\vzfive$ is greater than $\vzsix$;
      \item the range constraint for the literal integer $\vzfive$ and $\vetwo$, if $\vzoneopt$ is $\langle\vzfive\rangle$ and $\vztwoopt$ is $\None$;
      \item the range constraint for $\veone$ and the literal integer $\vzsix$, if $\vzoneopt$ is $\None$ and $\vztwoopt$ is $\langle\vzsix\rangle$;
      \item $\vc$ if $\vzoneopt$ is $\None$ and $\vztwoopt$ is $\None$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \getliteraldivopt(\ve) \typearrow \langle(\vzone, \vztwo)\rangle \terminateas \None\\\\
  {
    \vcopt \eqdef
    \begin{cases}
      \None & \text{if }\vztwo > 0 \land \frac{\vzone}{\vztwo} \not\in \Z\\
      \langle\vc\rangle & \text{else}
    \end{cases}
  }
}{
  \filterreduceconstraintdiv(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vcopt
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \getliteraldivopt(\veone) \typearrow \veoneopt\\
  {
    \vzoneopt \eqdef
    \begin{cases}
      \left\lceil\frac{\vzone}{\vztwo}\right\rceil & \text{if }\veoneopt = \langle(\vzone, \vztwo)\rangle \land \vztwo > 0\\
      \None & \text{else}
    \end{cases}
  }\\
  \getliteraldivopt(\vetwo) \typearrow \vetwoopt\\
  {
    \vztwoopt \eqdef
    \begin{cases}
      \left\lfloor\frac{\vzthree}{\vzfour}\right\rfloor & \text{if }\vetwoopt = \langle(\vzthree, \vzfour)\rangle \land \vzfour > 0\\
      \None & \text{else}
    \end{cases}
  }\\
  {
    \vcopt \eqdef
    \begin{cases}
     \langle\AbbrevConstraintExact{\ELInt{\vzfive}}\rangle & \text{if }\vzoneopt = \langle\vzfive\rangle \land \vztwoopt = \langle\vzsix\rangle \land \vzfive=\vzsix\\
     \langle\AbbrevConstraintRange{\ELInt{\vzfive}}{\ELInt{\vzsix}}\rangle & \text{if }\vzoneopt = \langle\vzfive\rangle \land \vztwoopt = \langle\vzsix\rangle \land \vzfive<\vzsix\\
     \None & \text{if }\vzoneopt = \langle\vzfive\rangle \land \vztwoopt = \langle\vzsix\rangle \land \vzfive>\vzsix\\
     \langle\AbbrevConstraintRange{\ELInt{\vzfive}}{\vetwo}\rangle & \text{if }\vzoneopt = \langle\vzfive\rangle \land \vztwoopt = \None\\
     \langle\AbbrevConstraintRange{\veone}{\ELInt{\vzsix}}\rangle & \text{if }\vzoneopt = \None \land \vztwoopt = \langle\vzsix\rangle\\
     \langle\ConstraintRange(\veone, \vetwo)\rangle & \text{if }\vzoneopt = \None \land \vztwoopt = \None\\
    \end{cases}
  }
}{
  \filterreduceconstraintdiv(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\langle\vc\rangle}{\vcopt}
}
\end{mathpar}

\TypingRuleDef{GetLiteralDivOpt}
\hypertarget{def-getliteraldivopt}{}
The function
\[
\getliteraldivopt(\overname{\expr}{\ve}) \aslto \overname{\langle\Z\cartimes\Z\rangle}{\rangeopt}
\]
matches the expression $\ve$ to a binary operation expression over the division operation and two literal integer expressions.
If $\ve$ matches this pattern the result $\rangeopt$ is an optional containing the pair of integers appearing in the operand
expressions. Otherwise, the result is $\None$.

\ProseParagraph
The value $\rangeopt$ is $\langle(\vzone, \vztwo)\rangle$ if $\ve$ is a binary operation expression over the division operation
and two literal integer expressions for the integers $\vzone$ and $\vztwo$ and $\None$ otherwise.

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \rangeopt \eqdef \choice{\ve = \EBinop(\DIV, \ELInt{\vzone}, \ELInt{\vztwo})}{\langle(\vzone, \vztwo)\rangle}{\None}
}{
  \getliteraldivopt(\ve) \typearrow \rangeopt
}
\end{mathpar}

\TypingRuleDef{ExplodeIntervals}
\hypertarget{def-explodeintervals}{}
The function
\[
\explodeintervals(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint^*}{\cs})
\aslto \left( \overname{\intconstraint^*}{\newcs} \aslsep \overname{\precisionlossindicator}{\vp} \right)
\]
applies $\explodedinterval$ to each constraint of $\cs$ in $\tenv$, and returns
a pair consisting of the list of exploded constraints in $\newcs$ and a
\Proseprecisionlossindicator{} $\vp$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\cs$ is the empty list;
    \item $\newcs$ is the empty list;
    \item $\vp$ is $\PrecisionFull$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\cs$ is the list with $\vc$ as its \head\ and $\csone$ as its \tail;
    \item applying $\explodeconstraint$ to $\vc$ in $\tenv$ yields $\vcp$ (a list of constraints);
    \item applying $\explodeintervals$ to $\csone$ in $\tenv$ yields $\csonep$;
    \item $\newcs$ is the concatenation of $\vcp$ and $\csonep$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \explodeintervals(\tenv, \overname{\emptylist}{\cs}) \typearrow \left( \overname{\emptylist}{\newcs} \aslsep \overname{\PrecisionFull}{\vp} \right)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \explodeconstraint(\tenv, \vc) \typearrow (\vcp, \vpone)\\
  \explodeintervals(\tenv, \csone) \typearrow (\csonep, \vptwo)\\
  \vp \eqdef \precisionjoin(\vpone, \vptwo)\\
  \newcs \eqdef \vcp \concat \csonep\\
}{
  \explodeintervals(\tenv, \overname{[\vc] \concat \csone}{\cs}) \typearrow (\newcs, \vp)
}
\end{mathpar}

\TypingRuleDef{ExplodeConstraint}
\hypertarget{def-explodeconstraint}{}
The function
\[
\explodeconstraint(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vc})
\aslto \overname{\intconstraint^*}{\vcs}
\]
expands the constraint $\vc$ into the equivalent list of exact constraints if
$\vc$ matches a n ascending range constraint that is not too large in $\tenv$
and the singleton list for $\vc$ otherwise.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an exact constraint;
    \item $\vcs$ is the singleton list for $\vc$.
  \end{itemize}

  \item \AllApplyCase{range\_reduced}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\va$ and $\vb$;
    \item applying $\reducetozopt$ to $\va$ in $\tenv$ yields $\langle\vza\rangle$;
    \item applying $\reducetozopt$ to $\vb$ in $\tenv$ yields $\langle\vzb\rangle$;
    \item define $\explodedinterval$ as the list of exact constraints for each integer literal in the range starting
          at $\vza$ and ending at $\vzb$, inclusively, which is empty if $\vzb < \vza$;
    \item applying $\intervaltoolarge$ to $\vza$ and $\vzb$ yields $\vbtoolarge$;
    \item define $\vcs$ as the singleton list for $\vc$ if $\vbtoolarge$ is $\True$ and \\
          $\explodedinterval$ otherwise.
  \end{itemize}

  \item \AllApplyCase{range\_not\_reduced}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\va$ and $\vb$;
    \item applying $\reducetozopt$ to $\va$ in $\tenv$ yields $\vzaopt$;
    \item applying $\reducetozopt$ to $\vb$ in $\tenv$ yields $\vzbopt$;
    \item at least one of $\vzaopt$ and $\vzbopt$ is $\None$;
    \item $\vcs$ is the singleton list for $\vc$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \astlabel(\vc) = \ConstraintExact
}{
  \explodeconstraint(\tenv, \vc) \typearrow \overname{[\vc]}{\vcs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_reduced]{
  \vc = \ConstraintRange(\va, \vb)\\
  \reducetozopt(\tenv, \va) \typearrow \langle\vza\rangle\\
  \reducetozopt(\tenv, \vb) \typearrow \langle\vzb\rangle\\
  \explodedinterval \eqdef [\vz \in \vza..\vzb: \ConstraintExact(\ELInt{\vz})]\\
  \intervaltoolarge(\vza, \vzb) \typearrow \vbtoolarge\\
  \vcs \eqdef \choice{\vbtoolarge}{[\vc]}{\explodedinterval}
}{
  \explodeconstraint(\tenv, \vc) \typearrow \vcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_not\_reduced]{
  \vc = \ConstraintRange(\va, \vb)\\
  \reducetozopt(\tenv, \va) \typearrow \vzaopt\\
  \reducetozopt(\tenv, \vb) \typearrow \vzbopt\\
  \vzaopt = \None \lor \vzbopt = \None
}{
  \explodeconstraint(\tenv, \vc) \typearrow \overname{[\vc]}{\vcs}
}
\end{mathpar}

\TypingRuleDef{IntervalTooLarge}
\hypertarget{def-intervaltoolarge}{}
The function
\[
\intervaltoolarge(\overname{\Z}{\vzone} \aslsep \overname{\Z}{\vztwo}) \aslto \overname{\Bool}{\vb}
\]
determines whether the set of numbers between $\vzone$ and $\vztwo$, inclusive, contains more than $\maxexplodedintervalsize$
integers, yielding the result in $\vb$.

\ProseParagraph
The value $\vb$ is $\True$ if and only if the absolute value of $\vzone-\vztwo$ is greater than $\maxexplodedintervalsize$.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \intervaltoolarge(\vzone, \vztwo) \typearrow \overname{\vztwo-\vzone > \maxexplodedintervalsize}{\vb}
}
\end{mathpar}

\TypingRuleDef{BinopIsExploding}
\hypertarget{def-binopisexploding}{}
The function
\[
\binopisexploding(\overname{\binop}{\op}) \aslto \overname{\Bool}{\vb}
\]
determines whether the binary operation $\op$ should lead to applying $\explodeintervals$
when the $\op$ is applied to a pair of constraint lists.
It is assumed that $\op$ is one of $\MUL$, $\SHL$, $\POW$, $\PLUS$, $\DIV$, $\MINUS$, $\MOD$, $\SHR$,
and $\DIVRM$.

See \ExampleRef{Annotating Constraints for Binary Operations}.

\ProseParagraph
The value $\vb$ is $\True$ if and only if $\op$ is one of $\MUL$, $\SHL$, and $\POW$.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \binopisexploding(\op) \typearrow \overname{\op \in \{\MUL, \SHL, \POW, \DIV, \DIVRM, \MOD, \SHR\}}{\vb}
}
\end{mathpar}

\TypingRuleDef{BitFieldsIncluded}
\hypertarget{def-bitfieldsincluded}{}
The predicate
\[
  \bitfieldsincluded(\overname{\staticenvs}{\tenv}, \overname{\bitfield^*}{\bfsone} \aslsep \overname{\bitfield^*}{\bfstwo})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the set of bit fields $\bfsone$ is included in the set of bit fields $\bfstwo$ in environment $\tenv$,
returning a \typingerrorterm{}, if one is detected.

\ProseParagraph
\AllApply
\begin{itemize}
  \item checking whether each field $\vbf$ in $\bfsone$ exists in $\bfstwo$ via $\membfs$ yields $\vb_\vbf$\ProseOrTypeError;
  \item the result --- $\vb$ --- is the conjunction of $\vb_\vbf$ for all bitfields $\vbf$ in $\bfsone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vbf \in \bfsone: \membfs(\bfstwo, \vbf) \typearrow \vb_\vbf \OrTypeError\\\\
  \vbf \eqdef \bigwedge_{\bf \in \bfsone} \vb_\vbf
}{
  \bitfieldsincluded(\tenv, \bfsone, \bfstwo) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{MemBfs}
\hypertarget{def-membfs}{}
The function
\[
  \membfs(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield^+}{\bfstwo} \aslsep \overname{\bitfield}{\vbfone})
  \aslto \overname{\Bool}{\vb}
\]
checks whether the bitfield $\vbf$ exists in $\bfstwo$ in the context of $\tenv$, returning the result in $\vb$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\None$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item \AllApplyCase{simple\_any}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item \AllApplyCase{nested\_simple}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item \AllApplyCase{nested\_nested}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a nested bitfield with name $\nameone$, slices $\sliceone$, and $\bfsone$;
    \item $\vbone$ is true if and only if $\nameone$ is equal to $\nametwo$;
    \item symbolically equating the slices $\slicesone$ and $\slicestwo$ in $\tenv$ yields $\vbtwo$;
    \item checking $\bfsone$ is included in $\bfstwop$ in the context of $\tenv$ yields $\vbthree$;
    \item $\vb$ is defined as the conjunction of $\vbone$, $\vbtwo$, and $\vbthree$.
  \end{itemize}

  \item \AllApplyCase{nested\_typed}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a typed bitfield;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item \AllApplyCase{typed\_simple}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item \AllApplyCase{typed\_nested}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a nested bitfield;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item \AllApplyCase{typed\_typed}
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a typed bitfield with name $\nameone$, slices $\slicesone$, and type $\ttyone$;
    \item $\vbone$ is true if and only if $\nameone$ is equal to $\nametwo$;
    \item symbolically equating the slices $\slicesone$ and $\slicestwo$ in $\tenv$ yields $\vbtwo$;
    \item checking whether $\ttyone$ subtypes $\ttytwo$ in $\tenv$ yields $\vbthree$;
    \item $\vb$ is defined as the conjunction of $\vbone$, $\vbtwo$, and $\vbthree$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{
  \bitfieldgetname(\vbfone) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \None
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \False
}
\and
\inferrule[simple\_any]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \astlabel(\vbftwo) = \BitFieldSimple\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested\_simple]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \vbfone = \BitFieldSimple(\Ignore)\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[nested\_nested]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \vbfone = \BitFieldNested(\nameone, \slicesone, \bfsone)\\
  \vbone \eqdef \nameone = \nametwo\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \bitfieldsincluded(\tenv, \bfsone, \bfstwop) \typearrow \vbthree\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\and
\inferrule[nested\_typed]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \astlabel(\vbfone) = \BitFieldType
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[typed\_simple]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \vbfone = \BitFieldSimple(\Ignore)\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\and
\inferrule[typed\_nested]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \astlabel(\vbfone) = \BitFieldNested
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[typed\_typed]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \vbfone = \BitFieldType(\nameone, \slicesone, \ttyone)\\
  \vbone \eqdef \nameone = \nametwo\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \subtypesat(\tenv, \ttyone, \ttytwo) \typearrow \vbthree \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\end{mathpar}

\hypertarget{def-checkstructurelabel}{}
\TypingRuleDef{CheckStructure}
The function
\[
  \checkstructurelabel(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\astlabels}{\vl}) \aslto
  \{\True\} \cup \TTypeError
\]
returns $\True$ is $\vt$ is has the \structure\ a of type corresponding to the AST label $\vl$ and a \typingerrorterm{} otherwise.

See \ExampleRef{The Structure of a Type}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ has the label $\vl$;
    \item the result is $\True$;
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ does not have the label $\vl$;
    \item the result is a \typingerrorterm{} indicating that $\vt$ was expected to have the \structure\ of a type with the AST label $\vl$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\vt) \typearrow \vtp \OrTypeError\\\\
  \astlabel(\vtp) = \vl
}
{
  \checkstructurelabel(\tenv, \vt, \vl) \typearrow \True
}
\and
\inferrule[error]{
  \tstruct(\vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \vl
}
{
  \checkstructurelabel(\tenv, \vt, \vl) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}

\TypingRuleDef{ToWellConstrained}
\hypertarget{def-towellconstrained}{}
The function
\[
  \towellconstrained(\overname{\ty}{\vt}) \aslto \overname{\ty}{\vtp}
\]
returns the \wellconstrainedversion\ of a type $\vt$ --- $\vtp$,
which converts \parameterizedintegertypes{} to \wellconstrainedintegertypes{},
and leaves all other types as are.

\ExampleDef{Converting Parameterized Integer Types to Well-constrainted Integer Types}
The following table shows examples of applying $\towellconstrained$ to various types:
\[
\begin{array}{rl}
\textbf{input type}           & \textbf{output type}\\
\hline
\TInt(\parameterized(\vx))    & \TInt(\wellconstrained(\ConstraintExact(\EVar(\vx))))\\
\TInt(\unconstrainedinteger)  & \TInt(\unconstrainedinteger)\\
\TReal                        & \TReal\\
\end{array}
\]

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{t\_int\_parameterized}
  \begin{itemize}
    \item $\vt$ is a \parameterizedintegertype\ for the variable $\vv$;
    \item $\vtp$ is the well-constrained integer constrained by the variable expression for $\vv$,
    that is, $\TInt(\wellconstrained(\constraintexact(\EVar(\vv))))$.
  \end{itemize}

  \item \AllApplyCase{t\_int\_other, other}
  \begin{itemize}
    \item $\vt$ is not a \parameterizedintegertype\ for the variable $\vv$;
    \item $\vtp$ is $\vt$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[t\_int\_parameterized]{}
{
  \towellconstrained(\TInt(\parameterized(\vv))) \typearrow\\ \TInt(\wellconstrained(\constraintexact(\EVar(\vv))))
}
\and
\inferrule[t\_int\_other]{
  \astlabel(\vi) \neq \parameterized
}{
  \towellconstrained(\TInt(\vi)) \typearrow \vt
}
\and
\inferrule[other]{
  \astlabel(\vt) \neq \TInt
}{
  \towellconstrained(\vt) \typearrow \vt
}
\end{mathpar}

\TypingRuleDef{GetWellConstrainedStructure}
\hypertarget{def-getwellconstrainedstructure}{}
The function
\[
  \getwellconstrainedstructure(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt})
  \aslto \overname{\ty}{\vtp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the \wellconstrainedstructure\ of a type $\vt$ in the static environment $\tenv$ --- $\vtp$, which is defined as follows.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item the \structure\ of $\vt$ in $\tenv$ is $\vtone$\ProseOrTypeError;
  \item the well-constrained version of $\vtone$ is $\vtp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) \typearrow \vtone \OrTypeError\\\\
  \towellconstrained(\vtone) \typearrow \vtp
}{
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \vtp
}
\end{mathpar}

\TypingRuleDef{GetBitvectorWidth}
\hypertarget{def-getbitvectorwidth}{}
The function
\[
  \getbitvectorwidth(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \overname{\expr}{\ve} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the expression $\ve$, which represents the width of the bitvector type $\vt$
in the static environment $\tenv$.
\ProseOrTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a bitvector type with width expression $\ve$,
          that is, $\TBits(\ve, \Ignore)$\ProseOrTypeError;
    \item the result is $\ve$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a type that is not a bitvector type;
    \item the result is a \typingerrorterm{} indicating that a bitvector type was expected.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\tenv, \vt) \typearrow \TBits(\ve, \Ignore) \OrTypeError
}{
  \getbitvectorwidth(\tenv, \vt) \typearrow \ve
}
\and
\inferrule[error]{
  \tstruct(\tenv, \vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \TBits
}{
  \getbitvectorwidth(\tenv, \vt) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\GetBitvectorWidthBegin}{\GetBitvectorWidthEnd}{../Typing.ml}

\TypingRuleDef{GetBitvectorConstWidth}
\hypertarget{def-getbitvectorconstwidth}{}
The function
\[
  \getbitvectorconstwidth(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \overname{\N}{\vw} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the natural number $\vw$, which represents the width of the bitvector type $\vt$
in the static environment $\tenv$.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\getbitvectorwidth$ to $\vt$ in $\tenv$ yields $\ewidth$\ProseOrTypeError;
  \item \Prosestaticeval{$\tenv$}{$\ewidth$}{integer for $\vw$}\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \getbitvectorwidth(\tenv, \vt) \typearrow \ewidth \OrTypeError\\\\
  \staticeval(\tenv, \ewidth) \typearrow \lint(\vw) \OrTypeError
}{
  \getbitvectorconstwidth(\tenv, \vt) \typearrow \vw
}
\end{mathpar}
\CodeSubsection{\GetBitvectorConstWidthBegin}{\GetBitvectorConstWidthEnd}{../Typing.ml}

\TypingRuleDef{CheckBitsEqualWidth}
\hypertarget{def-checkbitsequalwidth}{}
The function
\[
  \checkbitsequalwidth(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\vtone} \aslsep
    \overname{\ty}{\vttwo}) \aslto
  \{\True\} \cup \TTypeError
\]
tests whether the types $\vtone$ and $\vttwo$ are bitvector types of the same width.
If the answer is positive, the result is $\True$. \ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item obtaining the width of $\vtone$ in $\tenv$ (via $\getbitvectorwidth$) yields the expression $\vn$\ProseOrTypeError;
  \item obtaining the width of $\vttwo$ in $\tenv$ (via $\getbitvectorwidth$) yields the expression $\vm$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{true}
    \begin{itemize}
      \item symbolically checking whether the bitwidth expressions $\vn$ and $\vm$ are equal (via $\bitwidthequal$) yields $\True$;
      \item the result is $\True$.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item symbolically checking whether the bitwidth expressions $\vn$ and $\vm$ are equal (via $\bitwidthequal$) yields $\False$;
      \item the result is a \typingerrorterm{} indicating that the bitwidths are different.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[true]{
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vn \OrTypeError\\\\
  \getbitvectorwidth(\tenv, \vttwo) \typearrow \vm \OrTypeError\\\\
  \bitwidthequal(\tenv, \vn, \vm) \typearrow \True
}{
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \True
}
\and
\inferrule[error]{
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vn \OrTypeError\\\\
  \getbitvectorwidth(\tenv, \vttwo) \typearrow \vm \OrTypeError\\\\
  \bitwidthequal(\tenv, \vn, \vm) \typearrow \False
}{
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}

\TypingRuleDef{PrecisionJoin}
\hypertarget{def-precisionjoin}{}
The function
\[
    \precisionjoin(
      \overname{\vpone}{\precisionlossindicator} \aslsep
      \overname{\vpone}{\precisionlossindicator}
    )
    \aslto
    \overname{\vp}{\precisionlossindicator}
\]
returns the \Proseprecisionlossindicator{} $\vp$, denoting whether $\vpone$ or
$\vptwo$ denote a precision loss.

\ExampleDef{Precision join}
In \listingref{precisionjoin}, the statement \verb|var b = (a * a) + 2;| is
forbidden because it tries to declare a type with a precision loss (see
\TypingRuleRef{LDVar}).
The expression \verb|a * a| has a type that results in a precision loss (see
\TypingRuleRef{AnnotateConstraintBinop}).
The typing rule \TypingRuleRef{PrecisionJoin} is called by
\TypingRuleRef{ApplyBinopTypes} to compute the precision of the type of the
expression \verb|(a * a) + 2|. Because the type of \verb|(a * a)| denotes a
precision lost, the type of \verb|(a * a) + 2| also denotes a precision lost.
\ASLListing{Precision join}{precisionjoin}{\typingtests/TypingRule.PrecisionJoin.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{Loss}
    \begin{itemize}
      \item $\vpone$ is $\PrecisionLost$ or $\vptwo$ is $\PrecisionLost$;
      \item $\vp$ is $\PrecisionLost$;
    \end{itemize}
  \item \AllApplyCase{Full}
    \begin{itemize}
      \item $\vpone$ is $\PrecisionFull$ and $\vptwo$ is $\PrecisionFull$;
      \item $\vp$ is $\PrecisionFull$;
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[Loss]{
    \vpone = \PrecisionLost \lor
    \vptwo = \PrecisionLost
  }{
    \vp = \PrecisionLost
  }
  \and
  \inferrule[Full]{
    \vpone = \PrecisionFull \\
    \vptwo = \PrecisionFull
  }{
    \vp = \PrecisionFull
  }
\end{mathpar}
