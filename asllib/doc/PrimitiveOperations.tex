\chapter{Primitive Operations\label{chap:PrimitiveOperations}}

Primitive operations allow transforming single \nativevaluesterm{} (unary operations)
and pairs of \nativevaluesterm{} (binary operations) into other \nativevaluesterm{}.

\identd{KXWT}
\identi{HSQL}
The term \emph{Primitive Operations} denotes the set of operations available
in the expression syntax that use an \emph{Operator} derived from either
$\unop$ or $\binop$.
This chapter defines the Primitive Operations as functions over literals.

Primitive operations are evaluated both statically and dynamically.
We define the static evaluation of primitive operations on literals
via the functions $\unopliterals$ and $\binopliterals$ and then reuse
those to define the dynamic evaluation of primitive operations
on \nativevaluesterm{} via $\evalunop$ and $\evalbinop$.

\ExampleDef{Primitive Operations}
\listingref{PrimitiveOperations} shows examples of primitive operations.
\ASLListing{Examples of primitive operations}{PrimitiveOperations}{\definitiontests/PrimitiveOperations.asl}

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Primitive Operations} defines the formal relations
        primitive operations;
  \item \SyntaxRef{Primitive Operations} defines the syntax for unary operations and binary operations;
  \item \AbstractSyntaxRef{Primitive Operations} defines the AST for unary operations and binary operations;
  \item \secref{PrimitiveOperationSignatures} defines the signatures for all primitive operations;
  \item \TypeRulesRef{Primitive Operations} defines the static evaluation of primitive operations for literal values;
  \item \SemanticsRulesRef{Primitive Operations} defines how to adapt $\unopliterals$
        and $\binopliterals$ to be used by the dynamic semantics. Essentially this is done by unwrapping
        \nativevaluesterm{} into literal values, applying $\unopliterals$ and $\binopliterals$,
        and finally wrapping the results by \nativevaluesterm{}.
\end{itemize}

\FormalRelationsDef{Primitive Operations}
\paragraph{Syntax:} primitive operations are grammatically derived from $\Nunop$ and $\Nbinop$.

\paragraph{Abstract Syntax:} primitive operations are derived in the abstract syntax from $\unop$
  and $\binop$, and generated by $\buildunop$ (see \ASTRuleRef{Unop})
  and $\buildbinop$ (see \ASTRuleRef{Binop}).

\paragraph{Typing:} primitive operations are not directly annotated; rather \unopexpressionsterm{}
  and \binopexpressionsterm{} are annotated (see \TypingRuleRef{EUnop} and \TypingRuleRef{EBinop}).\\
  Unary operations are statically evaluated by $\unopliterals$
  (see \TypingRuleRef{UnopLiterals}) and binary operations are statically evaluated
  by $\binopliterals$ \\
  (see \TypingRuleRef{BinopLiterals}).

\paragraph{Semantics:} unary operations are dynamically evaluated via
  $\evalunop$ \\
  (see \SemanticsRuleRef{UnopValues})
  and binary operations are dynamically evaluated via
  $\evalbinop$ (see \SemanticsRuleRef{BinopValues}).

\SyntaxDef{Primitive Operations}
\begin{flalign*}
\Nunop \derivesinline\ & \Tbnot \;|\; \Tminus \;|\; \Tnot &\\
\Nbinop \derivesinline\ & \Tand \;|\; \Tband \;|\; \Tbor \;|\; \Tbeq \;|\; \Tdiv \;|\; \Tdivrm \;|\; \Txor \;|\; \Teqop \;|\; \Tneq &\\
                      |\ & \Tgt \;|\; \Tgeq \;|\; \Timpl \;|\; \Tlt \;|\; \Tleq \;|\; \Tplus \;|\; \Tminus \;|\; \Tmod \;|\; \Tmul &\\
                      |\ & \Tor \;|\; \Trdiv \;|\; \Tshl \;|\; \Tshr \;|\; \Tpow \;|\; \Tcoloncolon \;|\; \Tplusplus
\end{flalign*}

\AbstractSyntaxDef{Primitive Operations}
\RenderTypes[remove_hypertargets]{unop_and_binop}
\BackupOriginalAST{
\begin{flalign*}
\unop \derives\ & \overname{\BNOT}{\texttt{"!"}} \;|\; \overname{\NEG}{\texttt{"-"}} \;|\; \overname{\NOT}{\texttt{"NOT"}} & \\
\binop  \derives\ & \overname{\BAND}{\texttt{"\&\&"}} \;|\; \overname{\BOR}{\texttt{"||"}} \;|\; \overname{\IMPL}{\texttt{"==>"}}
              \;|\; \overname{\BEQ}{\texttt{"<=>"}}
        & \\
        |\ & \overname{\EQOP}{\texttt{"=="}} \;|\; \overname{\NEQ}{\texttt{"!="}} \;|\; \overname{\GT}{\texttt{"<"}}
        \;|\; \overname{\GEQ}{\texttt{">="}} \;|\; \overname{\LT}{\texttt{"<"}} \;|\; \overname{\LEQ}{\texttt{"<="}}
        & \\
        |\ & \overname{\PLUS}{\texttt{"+"}} \;|\; \overname{\MINUS}{\texttt{"-"}} \;|\; \overname{\OR}{\texttt{"OR"}}
        \;|\; \overname{\XOR}{\texttt{"XOR"}} \;|\; \overname{\AND}{\texttt{"AND"}}
        & \\
        |\ & \overname{\MUL}{\texttt{"*"}} \;|\; \overname{\DIV}{\texttt{"DIV"}} \;|\; \overname{\DIVRM}{\texttt{"DIVRM"}}
        \;|\; \overname{\MOD}{\texttt{"MOD"}} \;|\; \overname{\SHL}{\shiftleftlexeme}  \;|\; \overname{\SHR}{\shiftrightlexeme}
        & \\
        |\ & \overname{\RDIV}{\texttt{"/"}} \;|\; \overname{\POW}{\texttt{"\^{}"}} \;|\; \overname{\BVCONCAT}{\texttt{"::"}} \;|\; \overname{\STRCONCAT}{\texttt{"++"}}
        &
\end{flalign*}
}

\ASTRuleDef{Unop}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-unop}{}
The function
\[
  \buildunop(\overname{\parsenode{\Nunop}}{\vparsednode}) \;\aslto\; \overname{\unop}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[bnot]{}{
  \buildunop(\Nunop(\Tbnot)) \astarrow \overname{\BNOT}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg]{}{
  \buildunop(\Nunop(\Tminus)) \astarrow \overname{\NEG}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[not]{}{
  \buildunop(\Nunop(\Tnot)) \astarrow \overname{\NOT}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{Binop}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-binop}{}
The function
\[
  \buildbinop(\overname{\parsenode{\Nbinop}}{\vparsednode}) \;\aslto\; \overname{\binop}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[and]{}{
  \buildbinop(\Nbinop(\Tand)) \astarrow \overname{\AND}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[band]{}{
  \buildbinop(\Nbinop(\Tband)) \astarrow \overname{\BAND}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bor]{}{
  \buildbinop(\Nbinop(\Tbor)) \astarrow \overname{\BOR}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[beq]{}{
  \buildbinop(\Nbinop(\Tbeq)) \astarrow \overname{\BEQ}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div]{}{
  \buildbinop(\Nbinop(\Tdiv)) \astarrow \overname{\DIV}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[divrm]{}{
  \buildbinop(\Nbinop(\Tdivrm)) \astarrow \overname{\DIVRM}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[xor]{}{
  \buildbinop(\Nbinop(\Txor)) \astarrow \overname{\XOR}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eqop]{}{
  \buildbinop(\Nbinop(\Teqop)) \astarrow \overname{\EQ}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neq]{}{
  \buildbinop(\Nbinop(\Tneq)) \astarrow \overname{\NE}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[gt]{}{
  \buildbinop(\Nbinop(\Tgt)) \astarrow \overname{\GT}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[geq]{}{
  \buildbinop(\Nbinop(\Tgeq)) \astarrow \overname{\GE}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[impl]{}{
  \buildbinop(\Nbinop(\Timpl)) \astarrow \overname{\IMPL}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[lt]{}{
  \buildbinop(\Nbinop(\Tlt)) \astarrow \overname{\LT}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[leq]{}{
  \buildbinop(\Nbinop(\Tleq)) \astarrow \overname{\LE}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[plus]{}{
  \buildbinop(\Nbinop(\Tplus)) \astarrow \overname{\ADD}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[minus]{}{
  \buildbinop(\Nbinop(\Tminus)) \astarrow \overname{\SUB}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mod]{}{
  \buildbinop(\Nbinop(\Tmod)) \astarrow \overname{\MOD}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul]{}{
  \buildbinop(\Nbinop(\Tmul)) \astarrow \overname{\MUL}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[or]{}{
  \buildbinop(\Nbinop(\Tor)) \astarrow \overname{\OR}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[rdiv]{}{
  \buildbinop(\Nbinop(\Trdiv)) \astarrow \overname{\RDIV}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[shl]{}{
  \buildbinop(\Nbinop(\Tshl)) \astarrow \overname{\SHL}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[shr]{}{
  \buildbinop(\Nbinop(\Tshr)) \astarrow \overname{\SHR}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[pow]{}{
  \buildbinop(\Nbinop(\Tpow)) \astarrow \overname{\POW}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bvconcat]{}{
  \buildbinop(\Nbinop(\Tcoloncolon)) \astarrow \overname{\BVCONCAT}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[strconcat]{}{
  \buildbinop(\Nbinop(\Tplusplus)) \astarrow \overname{\STRCONCAT}{\vastnode}
}
\end{mathpar}

\section{Primitive Operation Signatures\label{sec:PrimitiveOperationSignatures}}
ASL follows mathematical and programming language tradition of allowing operators such as \texttt{+} to be overloaded
to refer to one of several different operations.
%
\taref{BooleanOperators}, \taref{IntegerOperators}, \taref{BitvectorOperators}, \taref{RealOperators},
\taref{StringOperators}, and \taref{EnumerationOperators} define,
for each primitive operation, the kinds of input literals and the kind of output literals,
as well as assigning each primitive operation a unique name.

\identr{BKNT}
\RequirementDef{PrimitiveOperatorImplements}
An operation implements an operator if it appears in the same row as the operator in one
of the tables in this section.
% INLINED_EXAMPLE
For example, the operation $\aslnotbool$ implements the operator $\Tbnot$
as it appears on the first row of \taref{BooleanOperators}.

\identr{JGWF}
\RequirementDef{PrimitiveOperatorMatches}
An expression which invokes a primitive operator \emph{matches} an operation
if the operation implements the operator and the operands of the expression
\typesatisfyterm\ the corresponding operands of the operation as shown in the
tables in this section.
% INLINED_EXAMPLE
For example, the expression \verb|!TRUE|, which invokes the primitive operator
$\Tbnot$, matches the primitive operation $\aslnotbool$, since the operand $\True$
\typesatisfiesterm{} the \booleantypeterm{}.

\identr{TTGQ}
\RequirementDef{PrimitiveOperationError}
It is a \typingerrorterm{} if an expression which invokes a
primitive operator does not match exactly one primitive operation
(see \BadOperands).
% INLINED_EXAMPLE
For example, including the expression \verb|!1| in any specification
would lead to a \typingerrorterm{}, since it does not match any primitive
operation.

\begin{table}[!htbp]
\caption{Boolean Operation Signatures\label{ta:BooleanOperators}}
\centering
\hypertarget{def-notbool}{}
\hypertarget{def-andbool}{}
\hypertarget{def-orbool}{}
\hypertarget{def-eqbool}{}
\hypertarget{def-nebool}{}
\hypertarget{def-impliesbool}{}
\hypertarget{def-equivbool}{}
\begin{tabular}{lllll}
\hline
\textbf{Operator} & \textbf{Operand 1} & \textbf{Operand 2} & \textbf{Result} & \textbf{Name}\\
\hline
$\Tbnot$  & $\LBool$ & -        & $\LBool$ & $\aslnotbool$\\
$\Tband$  & $\LBool$ & $\LBool$ & $\LBool$ & $\andbool$\\
$\Tbor$   & $\LBool$ & $\LBool$ & $\LBool$ & $\orbool$\\
$\Teqop$  & $\LBool$ & $\LBool$ & $\LBool$ & $\eqbool$\\
$\Tneq$   & $\LBool$ & $\LBool$ & $\LBool$ & $\nebool$\\
$\Timpl$  & $\LBool$ & $\LBool$ & $\LBool$ & $\impliesbool$\\
$\Tbeq$   & $\LBool$ & $\LBool$ & $\LBool$ & $\equivbool$\\
\hline
\end{tabular}
\end{table}

\begin{table}[!htbp]
\caption{Integer Operation Signatures\label{ta:IntegerOperators}}
\centering
\hypertarget{def-negateint}{}
\hypertarget{def-addint}{}
\hypertarget{def-subint}{}
\hypertarget{def-mulint}{}
\hypertarget{def-expint}{}
\hypertarget{def-shiftleftint}{}
\hypertarget{def-shiftrightint}{}
\hypertarget{def-divint}{}
\hypertarget{def-fdivint}{}
\hypertarget{def-fremint}{}
\hypertarget{def-eqint}{}
\hypertarget{def-neint}{}
\hypertarget{def-leint}{}
\hypertarget{def-ltint}{}
\hypertarget{def-gtint}{}
\hypertarget{def-geint}{}
\begin{tabular}{lllll}
\hline
\textbf{Operator} & \textbf{Operand 1} & \textbf{Operand 2} & \textbf{Result} & \textbf{Name}\\
\hline
$\Tminus$ & $\LInt$ & - & $\LInt$ & $\negateint$\\
$\Tplus$  & $\LInt$ & $\LInt$ & $\LInt$   & $\addint$\\
$\Tminus$ & $\LInt$ & $\LInt$ & $\LInt$   & $\subint$\\
$\Tmul$   & $\LInt$ & $\LInt$ & $\LInt$   & $\mulint$\\
$\Tpow$   & $\LInt$ & $\LInt$ & $\LInt$   & $\expint$\\
$\Tshl$   & $\LInt$ & $\LInt$ & $\LInt$   & $\shiftleftint$\\
$\Tshr$   & $\LInt$ & $\LInt$ & $\LInt$   & $\shiftrightint$\\
$\Tdiv$   & $\LInt$ & $\LInt$ & $\LInt$   & $\divint$\\
$\Tdivrm$ & $\LInt$ & $\LInt$ & $\LInt$   & $\fdivint$\\
$\Tmod$   & $\LInt$ & $\LInt$ & $\LInt$   & $\fremint$\\
$\Teqop$  & $\LInt$ & $\LInt$ & $\LBool$  & $\eqint$\\
$\Tneq$   & $\LInt$ & $\LInt$ & $\LBool$  & $\neint$\\
$\Tleq$   & $\LInt$ & $\LInt$ & $\LBool$  & $\leint$\\
$\Tlt$    & $\LInt$ & $\LInt$ & $\LBool$  & $\ltint$\\
$\Tgt$    & $\LInt$ & $\LInt$ & $\LBool$  & $\gtint$\\
$\Tgeq$   & $\LInt$ & $\LInt$ & $\LBool$  & $\geint$\\
\hline
\end{tabular}
\end{table}

\begin{table}[!htbp]
\caption{Real Operation Signatures\label{ta:RealOperators}}
\centering
\hypertarget{def-mulintreal}{}
\hypertarget{def-mulrealint}{}
\hypertarget{def-negatereal}{}
\hypertarget{def-addreal}{}
\hypertarget{def-subreal}{}
\hypertarget{def-mulreal}{}
\hypertarget{def-expreal}{}
\hypertarget{def-divreal}{}
\hypertarget{def-eqreal}{}
\hypertarget{def-nereal}{}
\hypertarget{def-lereal}{}
\hypertarget{def-ltreal}{}
\hypertarget{def-gtreal}{}
\hypertarget{def-gereal}{}
\begin{tabular}{lllll}
\hline
\textbf{Operator} & \textbf{Operand 1} & \textbf{Operand 2} & \textbf{Result} & \textbf{Name}\\
\hline
$\Tminus$ & $\LReal$ & - & $\LReal$ & $\negatereal$\\
$\Tmul$   & $\LInt$  & $\LReal$ & $\LReal$ & $\mulintreal$\\
$\Tmul$   & $\LReal$ & $\LInt$  & $\LReal$ & $\mulrealint$\\
$\Tplus$  & $\LReal$ & $\LReal$ & $\LReal$ & $\addreal$\\
$\Tminus$ & $\LReal$ & $\LReal$ & $\LReal$ & $\subreal$\\
$\Tmul$   & $\LReal$ & $\LReal$ & $\LReal$ & $\mulreal$\\
$\Tpow$   & $\LReal$ & $\LInt$  & $\LReal$ & $\expreal$\\
$\Trdiv$  & $\LReal$ & $\LReal$ & $\LReal$ & $\divreal$\\
$\Teqop$  & $\LReal$ & $\LReal$ & $\LBool$ & $\eqreal$\\
$\Tneq$   & $\LReal$ & $\LReal$ & $\LBool$ & $\nereal$\\
$\Tleq$   & $\LReal$ & $\LReal$ & $\LBool$ & $\lereal$\\
$\Tlt$    & $\LReal$ & $\LReal$ & $\LBool$ & $\ltreal$\\
$\Tgt$    & $\LReal$ & $\LReal$ & $\LBool$ & $\gtreal$\\
$\Tgeq$   & $\LReal$ & $\LReal$ & $\LBool$ & $\gereal$\\
\hline
\end{tabular}
\end{table}

\begin{table}[!htbp]
\caption{Bitvector Operation Signatures\label{ta:BitvectorOperators}}
\centering
\hypertarget{def-addbits}{}
\hypertarget{def-addbitsint}{}
\hypertarget{def-subbits}{}
\hypertarget{def-subbitsint}{}
\hypertarget{def-notbits}{}
\hypertarget{def-andbits}{}
\hypertarget{def-orbits}{}
\hypertarget{def-xorbits}{}
\hypertarget{def-eqbits}{}
\hypertarget{def-nebits}{}
\hypertarget{def-concatbits}{}
\begin{tabular}{lllll}
\hline
\textbf{Operator} & \textbf{Operand 1} & \textbf{Operand 2} & \textbf{Result} & \textbf{Name}\\
\hline
$\Tplus$        & $\LBitvector$ & $\LBitvector$ & $\LBitvector$ & $\addbits$\\
$\Tplus$        & $\LBitvector$ & $\LInt$       & $\LBitvector$ & $\addbitsint$\\
$\Tminus$       & $\LBitvector$ & $\LBitvector$ & $\LBitvector$ & $\subbits$\\
$\Tminus$       & $\LBitvector$ & $\LInt$       & $\LBitvector$ & $\subbitsint$\\
$\Tnot$         & $\LBitvector$ & -             & $\LBitvector$ & $\notbits$\\
$\Tand$         & $\LBitvector$ & $\LBitvector$ & $\LBitvector$ & $\andbits$\\
$\Tor$          & $\LBitvector$ & $\LBitvector$ & $\LBitvector$ & $\orbits$\\
$\Txor$         & $\LBitvector$ & $\LBitvector$ & $\LBitvector$ & $\xorbits$\\
$\Teqop$        & $\LBitvector$ & $\LBitvector$ & $\LBool$      & $\eqbits$\\
$\Tneq$         & $\LBitvector$ & $\LBitvector$ & $\LBool$      & $\nebits$\\
$\Tcoloncolon$  & $\LBitvector$ & $\LBitvector$ & $\LBitvector$ & $\concatbits$\\
\hline
\end{tabular}
\end{table}

\begin{table}[!htbp]
\caption{String Operation Signatures\label{ta:StringOperators}}
\centering
\hypertarget{def-eqstring}{}
\hypertarget{def-nestring}{}
\begin{tabular}{lllll}
\hline
\textbf{Operator} & \textbf{Operand 1} & \textbf{Operand 2} & \textbf{Result} & \textbf{Name}\\
\hline
$\Teqop$  & $\LString$ & $\LString$ & $\LBool$ & $\eqstring$\\
$\Tneq$   & $\LString$ & $\LString$ & $\LBool$ & $\nestring$\\
\hline
\end{tabular}
\end{table}

\begin{table}[!htbp]
\caption{Enumeration Operation Signatures\label{ta:EnumerationOperators}}
\centering
\hypertarget{def-eqenum}{}
\hypertarget{def-neenum}{}
\begin{tabular}{lllll}
\hline
\textbf{Operator} & \textbf{Operand 1} & \textbf{Operand 2} & \textbf{Result} & \textbf{Name}\\
\hline
$\Teqop$  & $\LLabel$ & $\LLabel$ & $\LBool$ & $\eqenum$\\
$\Tneq$   & $\LLabel$ & $\LLabel$ & $\LBool$ & $\neenum$\\
\hline
\end{tabular}
\end{table}

\pagebreak
\TypeRulesDef{Primitive Operations}
\TypingRuleDef{UnopLiterals}
\RenderRelation{unop_literals}
\BackupOriginalRelation{
The function
\[
  \unopliterals(\overname{\unop}{\op} \aslsep \overname{\literal}{\vl}) \aslto
  \overname{\literal}{\vr} \cup \typeerror
\]
statically evaluates a unary operator $\op$ (a terminal derived from the AST non-terminal for unary operators)
over a literal $\vl$ and returns the resulting literal $\vr$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\hypertarget{def-unopsignatures}{}
The following set of unary operator types and argument types defines the correct argument type
for a given unary operator:
\[
\unopsignatures \triangleq
\left\{
\begin{array}{lcll}
  (\NEG   &,& \LInt)        &,\\
  (\NEG   &,& \LReal)       &,\\
  (\BNOT  &,& \LBool)       &,\\
  (\NOT   &,& \LBitvector)  &\\
\end{array}
\right\}
\]

\ExampleDef{Unary Operations}
\listingref{unary-operations} shows applications of unary operations
(invalid applications appear in comments),
followed by the resulting console output.
\ASLListing{Applications of unary operations}{unary-operations}{\typingtests/TypingRule.UnopLiterals.asl}

% CONSOLE_BEGIN aslref \typingtests/TypingRule.UnopLiterals.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
negate_int: -10 = -10
negate_int: -0x0 = 0
negate_int: -0xf = -15
negate_rel: -2.3 = -23/10
not_bool: !TRUE = FALSE
not_bits: NOT '' = 0x
not_bits: NOT '11 01' = 0x2
\end{Verbatim}
% CONSOLE_END

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{error}
  \begin{itemize}
    \item $(\op, \astlabel(\vl))$ is not in $\unopsignatures$;
    \item the result is a \typingerrorterm{} indicating that the combination of $\op$ and $\astlabel(\vl)$
          is not legal.
  \end{itemize}

  \item \AllApplyCase{negate\_int}
  \begin{itemize}
    \item $\op$ is $\NEG$ and $\vl$ is an integer literal for $\vn$;
    \item define $\vr$ as the integer literal for $- \vn$.
  \end{itemize}

  \item \AllApplyCase{negate\_real}
  \begin{itemize}
    \item $\op$ is $\NEG$ and $\vl$ is a real literal for $\vq$;
    \item define $\vr$ as the real literal for $- \vq$.
  \end{itemize}

  \item \AllApplyCase{not\_bool}
  \begin{itemize}
    \item $\op$ is $\BNOT$ and $\vl$ is a Boolean literal for $\vb$;
    \item define $\vr$ as the Boolean literal for $\neg\vb$.
  \end{itemize}

  \item \AllApplyCase{not\_bits\_empty, not\_bits\_not\_empty}
  \begin{itemize}
    \item $\op$ is $\NOT$ and $\vl$ is a bitvector literal for the sequence of bits $\bits$;
    \item $\vc$ is the sequence of bits of the same length as $\bits$ where in each position
          the bit in $\vr$ is defined as the negation of the bit of $\bits$ in the same position;
    \item define $\vr$ as the bitvector literal for $\vc$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[error]{
  (\op, \astlabel(\vl)) \not\in \unopsignatures
}{
  \unopliterals(\op, \vl) \typearrow \TypeErrorVal{\BadOperands}
}
\and
\inferrule[negate\_int]{}{
  \unopliterals(\overname{\NEG}{\op}, \overname{\LInt(n)}{\vl}) \typearrow \overname{\LInt(- n)}{\vr}
}
\and
\inferrule[negate\_real]{}{
  \unopliterals(\overname{\NEG}{\op}, \overname{\LReal(q)}{\vl}) \typearrow \overname{\LReal(- q)}{\vr}
}
\and
\inferrule[not\_bool]{}{
  \unopliterals(\overname{\BNOT}{\op}, \overname{\LBool(b)}{\vl}) \typearrow \overname{\LBool(\neg b)}{\vr}
}
\and
\inferrule[not\_bits\_empty]{
  \bits \eqname \emptylist\\
  c \eqdef \emptylist
}{
  \unopliterals(\overname{\NOT}{\op}, \overname{\LBitvector(\bits)}{\vl}) \typearrow\overname{\LBitvector(c)}{\vr}
}
\and
\inferrule[not\_bits\_not\_empty]{
  \bits \eqname \vb_{1..k}\\
  c \eqdef [i=1..k: (1-\vb_\vi)]
}{
  \unopliterals(\overname{\NOT}{\op}, \overname{\LBitvector(\bits)}{\vl}) \typearrow\overname{\LBitvector(c)}{\vr}
}
\end{mathpar}

\TypingRuleDef{BinopLiterals}
\RenderRelation{binop_literals}
\BackupOriginalRelation{
The function
\[
  \binopliterals(\overname{\binop}{\op} \aslsep \overname{\literal}{\vvone} \aslsep \overname{\literal}{\vvtwo}) \aslto
  \overname{\literal}{\vr} \cup \typeerror
\]
statically evaluates a binary operator $\op$ (a terminal derived from the AST non-terminal for binary operators)
over a pair of literals $\vlone$ and $\vltwo$
and returns the resulting literal $\vr$.
The result is a \typingerrorterm{}, if it is illegal to apply the operator
to the given values, or a different kind of \typingerrorterm{} is detected.
} % END_OF_BACKUP_RELATION

\ExampleDef{Boolean Operations}
\listingref{binary-operations-boolean} shows applications
of operations to Boolean-typed literals (invalid applications in comments),
followed by the resulting console output.
\ASLListing{Applications of Boolean operations}
  {binary-operations-boolean}
  {\typingtests/TypingRule.BinopLiterals.boolean.asl}

% CONSOLE_BEGIN aslref \typingtests/TypingRule.BinopLiterals.boolean.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
and_bool: TRUE && TRUE = TRUE
and_bool: TRUE && FALSE = FALSE
or_bool: TRUE || FALSE = TRUE
or_bool: FALSE || FALSE = FALSE
eq_bool: FALSE == FALSE = TRUE
eq_bool: TRUE == TRUE = TRUE
eq_bool: FALSE == TRUE = FALSE
ne_bool: FALSE != FALSE = FALSE
ne_bool: TRUE != TRUE = FALSE
ne_bool: FALSE != TRUE = TRUE
implies_bool: FALSE ==> FALSE = TRUE
implies_bool: FALSE ==> TRUE = TRUE
implies_bool: TRUE ==> TRUE = TRUE
implies_bool: TRUE ==> FALSE = FALSE
equiv_bool: FALSE <=> FALSE = TRUE
equiv_bool: TRUE <=> TRUE = TRUE
equiv_bool: FALSE <=> TRUE = FALSE
\end{Verbatim}
% CONSOLE_END

\ExampleDef{Integer Arithmetic}
\listingref{binary-operations-integer-arithmetic} shows applications
of integer arithmetic operations to literals (invalid applications in comments),
followed by the resulting console output.
\ASLListing{Applications of integer arithmetic operations}
  {binary-operations-integer-arithmetic}
  {\typingtests/TypingRule.BinopLiterals.integer-arithmetic.asl}

% CONSOLE_BEGIN aslref \typingtests/TypingRule.BinopLiterals.integer-arithmetic.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
add_int: 10 + 20 = 30
sub_int: 10 - 20 = -10
mul_int: 10 * 20 = 200
div_int: 20 DIV 10 = 2
fdiv_int: 20 DIVRM 3 = 6
fdiv_int: -20 DIVRM 3 = -7
frem_int: 20 MOD 3 = 2
frem_int: -20 MOD 3 = 1
exp_int: 2 ^ 10 = 1024
exp_int: -2 ^ 10 = 1024
exp_int: -2 ^ 11 = -2048
exp_int: 0 ^ 0 = 1
exp_int: -2 ^ 0 = 1
shiftleft_int: 1 << 10 = 1024
shiftleft_int: 1 << 0 = 1
shiftleft_int: -1 << 10 = -1024
shiftright_int: 1 >> 10 = 0
shiftright_int: 16 >> 2 = 4
shiftright_int: -16 >> 2 = -4
shiftright_int: 1 >> 0 = 1
shiftright_int: -1 >> 10 = -1
\end{Verbatim}
% CONSOLE_END

\ExampleDef{Integer Comparison}
\listingref{binary-operations-integer-relational} shows applications
of integer comparison operations to literals (invalid applications in comments),
followed by the resulting console output.
\ASLListing{Applications of integer comparison operations}
  {binary-operations-integer-relational}
  {\typingtests/TypingRule.BinopLiterals.integer-relational.asl}

% CONSOLE_BEGIN aslref \typingtests/TypingRule.BinopLiterals.integer-relational.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
eq_int: 5 == 10 = FALSE
ne_int: 5 != 10 = TRUE
le_int: 10 <= 10 = TRUE
lt_int: 10 < 10 = TRUE
lt_int: 5 < 10 = TRUE
gt_int: 10 > 10 = FALSE
gt_int: 11 > 10 = TRUE
ge_int: 11 >= 10 = TRUE
ge_int: 6 >= 10 = FALSE
\end{Verbatim}
% CONSOLE_END

\ExampleDef{Real Operations}
\listingref{binary-operations-real} shows applications
of operations on real-typed literals (invalid applications in comments),
followed by the resulting console output.
\ASLListing{Applications of operations on reals}
  {binary-operations-real}
  {\typingtests/TypingRule.BinopLiterals.real.asl}

% CONSOLE_BEGIN aslref \typingtests/TypingRule.BinopLiterals.real.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
mul_int_real: 10 * 0.5 = 5
mul_real_int: 0.5 * 10 = 5
add_real: 10.0 + 0.5 = 21/2
sub_real: 10.0 - 0.5 = 19/2
mul_real: 10.0 * 0.5 = 5
exp_real: 10.0 ^ 2 = 100
div_real: 10.0 / 0.5 = 20
eq_real: 10.0 == 0.5 = FALSE
ne_real: 10.0 != 0.5 = TRUE
le_real: 10.0 <= 0.5 = FALSE
lt_real: 10.0 < 0.5 = FALSE
gt_real: 10.0 > 0.5 = TRUE
ge_real: 10.0 >= 0.5 = TRUE
\end{Verbatim}
% CONSOLE_END

\ExampleDef{Bitvector Operations}
\listingref{binary-operations-bitvector} shows applications
of operations on bitvector-typed literals (invalid applications in comments),
followed by the resulting console output.
\ASLListing{Applications of operations on bitvectors}
  {binary-operations-bitvector}
  {\typingtests/TypingRule.BinopLiterals.bits.asl}

% CONSOLE_BEGIN aslref \typingtests/TypingRule.BinopLiterals.bits.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
add_bits: '010' + '011' = 0x5
add_bits: '10' + '11' = 0x1
add_bits: '010' + 3 = 0x5
add_bits: '10' + 3 = 0x1
sub_bits: '100' - '010' = 0x2
sub_bits: '100' - '111' = 0x5
sub_bits: '100' - 7 = 0x5
sub_bits: '100' - 8 = 0x4
and_bits: '100' AND '111' = 0x4
or_bits: '100' OR '110' = 0x6
xor_bits: '100' XOR '110' = 0x2
eq_bits: '100' == '110' = FALSE
ne_bits: '100' != '110' = TRUE
concat_bits: '100' :: '110' = 0x26
concat_bits: '100' :: '' = 0x4
\end{Verbatim}
% CONSOLE_END

\ExampleDef{String and Enumeration Label Operations}
\listingref{binary-operations-stringslabels} shows applications
of operations on string-typed literals and enumeration-typed literals (invalid applications in comments),
followed by the resulting console output.
\ASLListing{Applications of operations on strings and enumeration labels}
  {binary-operations-stringslabels}
  {\typingtests/TypingRule.BinopLiterals.strings_labels.asl}

% CONSOLE_BEGIN aslref \typingtests/TypingRule.BinopLiterals.strings_labels.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
eq_string: "hello" == "world" = FALSE
eq_string: "hello" == "hello" = TRUE
ne_string: "hello" != "world" = TRUE
eq_enum: RED == RED = TRUE
eq_enum: RED == GREEN = FALSE
eq_enum: RED != RED = FALSE
eq_enum: RED != GREEN = TRUE
concat_string: 0 ++ '1' ++ 2.0 ++ TRUE ++ "foo" ++ RED = 00x12TRUEfooRED
\end{Verbatim}
% CONSOLE_END

\ExampleDef{String Concatenation}
String concatenation operates over singular types, first converting them to strings using $\literaltostring$.
\listingref{binary-operations-stringslabels} shows an example of string concatenation applied to literals of \integertypeterm{}, \bitvectortypeterm{}, \realtypeterm{}, \booleantypeterm{}, and \enumerationtypeterm{}.
The literals are converted to strings, and these strings are concatenated.

\hypertarget{def-binopsignatures}{}
The following set defines the valid signatures of
binary operations in terms of the type of the binary operator
and argument types of its operand literals:
\[
\binopsignatures \triangleq
\left\{
\begin{array}{lclcll}
  (\ADD      &,& \LInt &,& \LInt)&,\\
  (\SUB     &,& \LInt &,& \LInt)&,\\
  (\MUL       &,& \LInt &,& \LInt)&,\\
  (\DIV       &,& \LInt &,& \LInt)&,\\
  (\DIVRM     &,& \LInt &,& \LInt)&,\\
  (\MOD       &,& \LInt &,& \LInt)&,\\
  (\POW       &,& \LInt &,& \LInt)&,\\
  (\SHL       &,& \LInt &,& \LInt)&,\\
  (\SHR       &,& \LInt &,& \LInt)&,\\
  (\EQ      &,& \LInt &,& \LInt)&,\\
  (\NE       &,& \LInt &,& \LInt)&,\\
  (\LE       &,& \LInt &,& \LInt)&,\\
  (\LT        &,& \LInt &,& \LInt)&,\\
  (\GE       &,& \LInt &,& \LInt)&,\\
  (\GT        &,& \LInt &,& \LInt)&,\\
  (\BAND      &,& \LBool &,& \LBool)&,\\
  (\BOR       &,& \LBool &,& \LBool)&,\\
  (\IMPL      &,& \LBool &,& \LBool)&,\\
  (\BEQ       &,& \LBool &,& \LBool)&,\\
  (\EQ       &,& \LBool &,& \LBool)&,\\
  (\NE       &,& \LBool &,& \LBool)&,\\
  (\MUL       &,& \LInt  &,& \LReal)&,\\
  (\MUL       &,& \LReal &,& \LInt)&,\\
  (\ADD      &,& \LReal &,& \LReal)&,\\
  (\SUB     &,& \LReal &,& \LReal)&,\\
  (\MUL       &,& \LReal &,& \LReal)&,\\
  (\RDIV      &,& \LReal &,& \LReal)&,\\
  (\POW       &,& \LReal &,& \LInt)&,\\
  (\EQ      &,& \LReal &,& \LReal)&,\\
  (\NE       &,& \LReal &,& \LReal)&,\\
  (\LE       &,& \LReal &,& \LReal)&,\\
  (\LT        &,& \LReal &,& \LReal)&,\\
  (\GE       &,& \LReal &,& \LReal)&,\\
  (\GT        &,& \LReal &,& \LReal)&,\\
  (\EQ      &,& \LBitvector &,& \LBitvector)&,\\
  (\NE       &,& \LBitvector &,& \LBitvector)&,\\
  (\OR        &,& \LBitvector &,& \LBitvector)&,\\
  (\AND       &,& \LBitvector &,& \LBitvector)&,\\
  (\XOR       &,& \LBitvector &,& \LBitvector)&,\\
  (\SUB     &,& \LBitvector &,& \LBitvector)&,\\
  (\ADD      &,& \LBitvector &,& \LBitvector)&,\\
  (\BVCONCAT  &,& \LBitvector &,& \LBitvector)&,\\
  (\STRCONCAT &,& \Ignore &,& \Ignore)&,\\
  (\SUB     &,& \LBitvector &,& \LInt)&,\\
  (\ADD      &,& \LBitvector &,& \LInt)&\\
  (\EQ      &,& \LString &,& \LString)&,\\
  (\NE       &,& \LString &,& \LString)&,\\
  (\EQ      &,& \LLabel &,& \LLabel)&,\\
  (\NE       &,& \LLabel &,& \LLabel)&\\
\end{array}
\right\}
\]

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{error}
  \begin{itemize}
    \item $(\op, \astlabel(\vlone), \astlabel(\vltwo))$ is not included in $\binopsignatures$;
    \item the result is a \typingerrorterm{} indicating the $\op$ cannot be applied to the arguments
          with the types given by $\astlabel(\vlone)$ and $\astlabel(\vltwo)$.
  \end{itemize}

  \item \AllApplyCase{add\_int}
  \begin{itemize}
    \item $\op$ is $\ADD$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal integer for $a+b$.
  \end{itemize}

  \item \AllApplyCase{sub\_int}
  \begin{itemize}
    \item $\op$ is $\SUB$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal integer for $a-b$.
  \end{itemize}

  \item \AllApplyCase{mul\_int}
  \begin{itemize}
    \item $\op$ is $\MUL$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal integer for $a\times b$.
  \end{itemize}

  \item \AllApplyCase{div\_int}
  \begin{itemize}
    \item $\op$ is $\DIV$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is positive yields $\True$\ProseOrTypeError;
    \item define $n$ as $a$ divided by $b$ (note that $n$ is potentially a fraction);
    \item checking that $n$ is an integer yields $\True$\ProseOrTypeError;
    \item define $\vr$ as the literal integer for $a\div b$.
  \end{itemize}

  \item \AllApplyCase{fdiv\_int}
  \begin{itemize}
    \item $\op$ is $\DIVRM$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is positive yields $\True$\ProseOrTypeError;
    \item define $n$ as $a$ divided by $b$, rounded down (if $a$ is negative, $n$ is rounded down towards infinity);
    \item define $\vr$ as the literal integer for $n$.
  \end{itemize}

  \item \AllApplyCase{frem\_int}
  \begin{itemize}
    \item $\op$ is $\MOD$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item applying $\binopliterals$ to $\DIVRM$ with $\vlone$ and $\vltwo$ yields $c$\ProseOrTypeError;
    \item define $n$ as $a-c$;
    \item define $\vr$ as the literal integer for $n$.
  \end{itemize}

  \item \AllApplyCase{exp\_int}
  \begin{itemize}
    \item $\op$ is $\POW$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item define $n$ as $a^b$;
    \item define $\vr$ as the literal integer for $n$.
  \end{itemize}

  \item \AllApplyCase{shl}
  \begin{itemize}
    \item $\op$ is $\SHL$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item applying $\binopliterals$ to $\POW$ with $2$ and $\vltwo$ yields the literal integer for $e$;
    \item applying $\binopliterals$ to $\MUL$ with $2$ and the literal integer for $e$ yields $\vr$.
  \end{itemize}

  \item \AllApplyCase{shr}
  \begin{itemize}
    \item $\op$ is $\SHR$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item applying $\binopliterals$ to $\POW$ with $2$ and $\vltwo$ yields the literal integer for $e$;
    \item applying $\binopliterals$ to $\DIVRM$ with $2$ and the literal integer for $e$ yields $\vr$.
  \end{itemize}

  \item \AllApplyCase{eq\_int}
  \begin{itemize}
    \item $\op$ is $\EQ$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is equal to $b$.
  \end{itemize}

  \item \AllApplyCase{ne\_int}
  \begin{itemize}
    \item $\op$ is $\NE$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is different from $b$ holds.
  \end{itemize}

  \item \AllApplyCase{le\_int}
  \begin{itemize}
    \item $\op$ is $\LE$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than or equal to $b$s.
  \end{itemize}

  \item \AllApplyCase{lt\_int}
  \begin{itemize}
    \item $\op$ is $\LT$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than $b$s.
  \end{itemize}

  \item \AllApplyCase{ge\_int}
  \begin{itemize}
    \item $\op$ is $\GE$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater or equal than $b$s.
  \end{itemize}

  \item \AllApplyCase{gt\_int}
  \begin{itemize}
    \item $\op$ is $\GT$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater than $b$s.
  \end{itemize}

  \item \AllApplyCase{and\_bool}
  \begin{itemize}
    \item $\op$ is $\BAND$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if both $a$ and $b$ are $\True$.
  \end{itemize}

  \item \AllApplyCase{or\_bool}
  \begin{itemize}
    \item $\op$ is $\BOR$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if at least one of $a$ and $b$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{implies\_bool}
  \begin{itemize}
    \item $\op$ is $\IMPL$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is $\False$ or $b$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{eq\_bool}
  \begin{itemize}
    \item $\op$ is either $\BEQ$ or $\EQ$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is equal to $b$.
  \end{itemize}

  \item \AllApplyCase{ne\_bool}
  \begin{itemize}
    \item $\op$ is $\NE$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is different from $b$.
  \end{itemize}

  \item \AllApplyCase{mul\_int\_real}
  \begin{itemize}
    \item $\op$ is $\MUL$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the literal real for $a\times b$.
  \end{itemize}

  \item \AllApplyCase{mul\_real\_int}
  \begin{itemize}
    \item $\op$ is $\MUL$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal real for $a\times b$.
  \end{itemize}

  \item \AllApplyCase{add\_real}
  \begin{itemize}
    \item $\op$ is $\ADD$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the real literal for $a + b$.
  \end{itemize}

  \item \AllApplyCase{sub\_real}
  \begin{itemize}
    \item $\op$ is $\SUB$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the real literal for $a - b$.
  \end{itemize}

  \item \AllApplyCase{mul\_real}
  \begin{itemize}
    \item $\op$ is $\MUL$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the real literal for $a \times b$.
  \end{itemize}

  \item \AllApplyCase{div\_real}
  \begin{itemize}
    \item $\op$ is $\RDIV$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item checking whether $b$ is different from $0$ yields $\True$\ProseOrTypeError;
    \item define $\vr$ as the real literal for $a \div b$.
  \end{itemize}

  \item \AllApplyCase{exp\_real}
  \begin{itemize}
    \item $\op$ is $\POW$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal integer for $b$;
    \item since exponentiation is undefined when $a$ is 0 and $b$ is negative,
          checking whether $a$ is different from $0$ or $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item define $\vr$ as the real literal for $a^b$.
  \end{itemize}

  \item \AllApplyCase{eq\_real}
  \begin{itemize}
    \item $\op$ is $\EQ$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is equal to $b$.
  \end{itemize}

  \item \AllApplyCase{ne\_real}
  \begin{itemize}
    \item $\op$ is $\NE$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is different from $b$.
  \end{itemize}

  \item \AllApplyCase{le\_real}
  \begin{itemize}
    \item $\op$ is $\LE$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than or equal to $b$.
  \end{itemize}

  \item \AllApplyCase{lt\_real}
  \begin{itemize}
    \item $\op$ is $\LT$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than $b$.
  \end{itemize}

  \item \AllApplyCase{ge\_real}
  \begin{itemize}
    \item $\op$ is $\GE$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater than or equal to $b$.
  \end{itemize}

  \item \AllApplyCase{gt\_real}
  \begin{itemize}
    \item $\op$ is $\GT$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater than $b$.
  \end{itemize}

  \item \AllApplyCase{bitwise\_different\_bitwidths}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is a bitvector literal for $b$;
    \item the lengths of $a$ and $b$ are different;
    \item the result is a \typingerrorterm{} indicating that the bitvectors must be of the same width.
  \end{itemize}

  \item \AllApplyCase{bitwise\_empty}
  \begin{itemize}
    \item $\vvone$ is the empty bitvector literal;
    \item $\vvtwo$ is the empty bitvector literal;
    \item $\op$ is one of $\OR$, $\AND$, $\XOR$, $\ADD$, or $\SUB$;
    \item define $\vr$ as the empty bitvector literal.
  \end{itemize}

  \item \AllApplyCase{eq\_bits\_empty}
  \begin{itemize}
    \item $\vvone$ is the empty bitvector literal;
    \item $\vvtwo$ is the empty bitvector literal;
    \item $\op$ is $\EQ$;
    \item define $\vr$ as the Boolean literal for $\True$.
  \end{itemize}

  \item \AllApplyCase{eq\_bits\_not\_empty}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\EQ$;
    \item define $\vb$ as $\True$ if and only if $a_i$ is equal to $b_i$, for $i=1..k$;
    \item define $\vr$ as the Boolean literal for $\vb$.
  \end{itemize}

  \item \AllApplyCase{ne\_bits}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is a bitvector literal for $b$;
    \item $\op$ is $\NE$;
    \item applying $\binopliterals$ to $\NE$ for $\vvone$ and $\vvtwo$ yields the Boolean literal for $\vb$\ProseOrTypeError;
    \item define $\vr$ as the Boolean literal for $\neg\vb$.
  \end{itemize}

  \item \AllApplyCase{or\_bits}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\OR$;
    \item define $c_i$ as the maximum of $a_i$ and $b_i$ for $i=1..k$;
    \item define $\vr$ as the bitvector literal for $c_{1..k}$.
  \end{itemize}

  \item \AllApplyCase{and\_bits}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\AND$;
    \item define $c_i$ as the minimum of $a_i$ and $b_i$ for $i=1..k$;
    \item define $\vr$ as the bitvector literal for $c_{1..k}$.
  \end{itemize}

  \item \AllApplyCase{xor\_bits}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\XOR$;
    \item define $c_i$ as $1$ if $a_i$ is different from $b_i$ and $0$ otherwise, for $i=1..k$;
    \item define $\vr$ as the bitvector literal for $c_{1..k}$.
  \end{itemize}

  \item \AllApplyCase{add\_bits}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\ADD$;
    \item define $a$ as the natural number represented by $a_{1..k}$;
    \item define $b$ as the natural number represented by $b_{1..k}$;
    \item define $c$ as the two's complement little endian representation of $a+b$ in $k$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item \AllApplyCase{sub\_bits}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\SUB$;
    \item define $a$ as the natural number represented by $a_{1..k}$;
    \item define $b$ as the natural number represented by $b_{1..k}$;
    \item define $c$ as the two's complement little endian representation of $a-b$ in $k$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item \AllApplyCase{concat\_bits}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..l}$;
    \item $\op$ is $\BVCONCAT$;
    \item define $\vr$ as the bitvector literal for $a_{1..k}b_{1..l}$.
  \end{itemize}

  \item \AllApplyCase{add\_bits\_int}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is an integer literal for $b$;
    \item $\op$ is $\ADD$;
    \item define $y$ as the natural number represented by $a$;
    \item define $c$ as the two's complement little endian representation of $y+b$ in $\listlen{a}$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item \AllApplyCase{sub\_bits\_int}
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is an integer literal for $b$;
    \item $\op$ is $\SUB$;
    \item define $y$ as the natural number represented by $a$;
    \item define $c$ as the two's complement little endian representation of $y-b$ in $\listlen{a}$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item \AllApplyCase{eq\_string}
  \begin{itemize}
    \item $\op$ is $\EQ$, $\vlone$ is the literal string for $a$, and $\vltwo$ is the literal string for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is equal to $b$.
  \end{itemize}

  \item \AllApplyCase{ne\_string}
  \begin{itemize}
    \item $\op$ is $\NE$, $\vlone$ is the literal string for $a$, and $\vltwo$ is the literal string for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is different from $b$.
  \end{itemize}

  \item \AllApplyCase{concat\_strings}
  \begin{itemize}
    \item $\vvone$ and $\vvtwo$ are not both bitvector literals;
    \item $\op$ is $\STRCONCAT$;
    \item define $\vsone$ as $\literaltostring(\vvone)$;
    \item define $\vstwo$ as $\literaltostring(\vvtwo)$;
    \item define $\vr$ as the string literal for the concatenation of $\vsone$ and $\vstwo$.
  \end{itemize}

  \item \AllApplyCase{eq\_label}
  \begin{itemize}
    \item $\op$ is $\EQ$, $\vlone$ is the literal label for $a$, and $\vltwo$ is the literal label for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is equal to $b$.
  \end{itemize}

  \item \AllApplyCase{ne\_label}
  \begin{itemize}
    \item $\op$ is $\NE$, $\vlone$ is the literal label for $a$, and $\vltwo$ is the literal label for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is different from $b$.
  \end{itemize}

\end{itemize}

\FormallyParagraph

\begin{mathpar}
\inferrule[error]{
  (\op, \astlabel(\vlone), \astlabel(\vltwo)) \not\in \binopsignatures
}{
  \binopliterals(\op, \overname{\vlone}{\vvone}, \overname{\vltwo}{\vvtwo}) \typearrow \TypeErrorVal{\BadOperands}
}
\end{mathpar}

\subsubsection{Arithmetic Operators Over Integer Values \label{sec:AthimeticOverInt}}
\begin{mathpar}
\inferrule[add\_int]{}{
  \binopliterals(\overname{\ADD}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LInt(a + b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_int]{}{
  \binopliterals(\overname{\SUB}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LInt(a - b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul\_int]{}{
  \binopliterals(\overname{\MUL}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LInt(a \times b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_int]{
  \techeck(b > 0, \BadOperands) \typearrow \True \OrTypeError\\\\
  n \eqdef a \div b \\\\
  \techeck(n \in \Z, \BadOperands) \typearrow \True \OrTypeError
}{
  \binopliterals(\overname{\DIV}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LInt(n)}{\vr}
}
\and
\inferrule[fdiv\_int]{
  \techeck(b > 0, \BadOperands) \typearrow \True \OrTypeError\\\\
  n \eqdef \choice{a \geq 0}{\lfloor a \div b \rfloor}{-(\lceil (-a) \div b \rceil)}
}{
  \binopliterals(\overname{\DIVRM}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LInt(n)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[frem\_int]{
  \binopliterals(\DIVRM, \LInt(a), \LInt(b)) \typearrow \LInt(c) \OrTypeError
}{
  \binopliterals(\overname{\MOD}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LInt(a - (c \times b))}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_int]{
  \techeck(b \geq 0, \BadOperands) \typearrow \True \OrTypeError
}{
  \binopliterals(\overname{\POW}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LInt(a^b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[shl]{
  \techeck(b \geq 0, \BadOperands) \typearrow \True \OrTypeError\\\\
  \binopliterals(\POW, \LInt(2), \LInt(b)) \typearrow \LInt(e)\\
  \binopliterals(\MUL, \LInt(a), \LInt(e)) \typearrow \vr
}{
  \binopliterals(\overname{\SHL}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \vr
}
\end{mathpar}

\begin{mathpar}
\inferrule[shr]{
  \techeck(b \geq 0, \BadOperands) \typearrow \True \OrTypeError\\\\
  \binopliterals(\POW, \LInt(2), \LInt(b)) \typearrow \LInt(e)\\
  \binopliterals(\DIVRM, \LInt(a), \LInt(e)) \typearrow \vr
}{
  \binopliterals(\overname{\SHR}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \vr
}
\end{mathpar}

\subsubsection{Comparison Operators Over Integer Values \label{sec:ComparisonOverInt}}
\begin{mathpar}
\inferrule[eq\_int]{}{
  \binopliterals(\overname{\EQ}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LBool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_int]{}{
  \binopliterals(\overname{\NE}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LBool(a \neq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_int]{}{
  \binopliterals(\overname{\LE}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LBool(a \leq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[lt\_int]{}{
  \binopliterals(\overname{\LT}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LBool(a < b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ge\_int]{}{
  \binopliterals(\overname{\GE}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LBool(a \geq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[gt\_int]{}{
  \binopliterals(\overname{\GT}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LBool(a > b)}{\vr}
}
\end{mathpar}

\subsubsection{Boolean Operators Over Boolean Values \label{sec:BooleanOverBoolean}}
\begin{mathpar}
\inferrule[and\_bool]{}{
  \binopliterals(\overname{\BAND}{\op}, \overname{\LBool(a)}{\vvone}, \overname{\LBool(b)}{\vvtwo}) \typearrow \overname{\LBool(a \land b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[or\_bool]{}{
  \binopliterals(\overname{\BOR}{\op}, \overname{\LBool(a)}{\vvone}, \overname{\LBool(b)}{\vvtwo}) \typearrow \overname{\LBool(a \lor b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[implies\_bool]{}{
  \binopliterals(\overname{\IMPL}{\op}, \overname{\LBool(a)}{\vvone}, \overname{\LBool(b)}{\vvtwo}) \typearrow \overname{\LBool(\neg a \lor b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_bool]{
  \op \in \{\EQ, \BEQ\}
}{
  \binopliterals(\op, \overname{\LBool(a)}{\vvone}, \overname{\LBool(b)}{\vvtwo}) \typearrow \overname{\LBool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_bool]{}{
  \binopliterals(\overname{\NE}{\op}, \overname{\LBool(a)}{\vvone}, \overname{\LBool(b)}{\vvtwo}) \typearrow \overname{\LBool(a \neq b)}{\vr}
}
\end{mathpar}

\subsubsection{Arithmetic Operators Over Real Values \label{sec:AthimeticOverReal}}
\begin{mathpar}
\inferrule[mul\_int\_real]{}{
  \binopliterals(\overname{\MUL}{\op}, \overname{\LInt(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LReal(a\times b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul\_real\_int]{}{
  \binopliterals(\overname{\MUL}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LReal(a\times b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[add\_real]{}{
  \binopliterals(\overname{\ADD}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LReal(a+b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_real]{}{
  \binopliterals(\overname{\SUB}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LReal(a-b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul\_real]{}{
  \binopliterals(\overname{\MUL}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LReal(a\times b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_real]{
  \techeck(b \neq 0, \BadOperands) \typearrow \True \OrTypeError
}{
  \binopliterals(\overname{\RDIV}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LReal(a\div b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_real]{
  \techeck(a \neq 0 \lor b \geq 0, \BadOperands) \typearrow \True \OrTypeError
}{
  \binopliterals(\overname{\POW}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LReal(a^b)}{\vr}
}
\end{mathpar}

\subsubsection{Comparison Operators Over Real Values \label{sec:ComparisonOverReal}}
\begin{mathpar}
\inferrule[eq\_real]{}{
  \binopliterals(\overname{\EQ}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LBool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_real]{}{
  \binopliterals(\overname{\NE}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LBool(a \neq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_real]{}{
  \binopliterals(\overname{\LE}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LBool(a \leq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[lt\_real]{}{
  \binopliterals(\overname{\LT}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LBool(a < b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ge\_real]{}{
  \binopliterals(\overname{\GE}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LBool(a \geq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[gt\_real]{}{
  \binopliterals(\overname{\GT}{\op}, \overname{\LReal(a)}{\vvone}, \overname{\LReal(b)}{\vvtwo}) \typearrow \overname{\LBool(a > b)}{\vr}
}
\end{mathpar}

\subsubsection{Operators Over Bitvectors \label{sec:BitvectorOperations}}
\RenderRelation{binary_to_unsigned}
\BackupOriginalRelation{
The function $\binarytounsigned : \KleeneStar{\Bit} \rightarrow \N$ converts a non-empty sequence of bits
into a natural number.
} % END_OF_BACKUP_RELATION

It is defined as follows for a non-empty bit sequence:
\[
  \binarytounsigned(a_{n..0}) \triangleq \sum_{i=0}^n a_i \cdot 2^{i}
\]
and as $0$ for an empty bit sequence:
\[
  \binarytounsigned(\emptylist) \triangleq 0 \enspace.
\]

\RenderRelation{int_to_bits}
\BackupOriginalRelation{
The function $\inttobits : \overname{\Z}{\texttt{val}} \times \overname{\Z}{\texttt{width}} \rightarrow \KleeneStar{\Bit}$
converts an integer \texttt{val} to its two's complement little endian representation
of \texttt{width} bits.
} % END_OF_BACKUP_RELATION

\begin{mathpar}
\inferrule[bitwise\_different\_bitwidths]{
  \listlen{a} \neq \listlen{b}
}{
  \binopliterals(\op, \overname{\LBitvector(a)}{\vvone}, \overname{\LBitvector(b)}{\vvtwo}) \typearrow
  \TypeErrorVal{\BadOperands}
}
\and
\inferrule[bitwise\_empty]{
  \op \in \{\OR, \AND, \XOR, \ADD, \SUB\}
}{
  \binopliterals(\op, \overname{\LBitvector(\emptylist)}{\vvone}, \overname{\LBitvector(\emptylist)}{\vvtwo}) \typearrow
  \overname{\LBitvector(\emptylist)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_bits\_empty]{}{
  \binopliterals(\overname{\EQ}{\op}, \overname{\LBitvector(\emptylist)}{\vvone}, \overname{\LBitvector(\emptylist)}{\vvtwo}) \typearrow
  \overname{\LBool(\True)}{\vr}
}
\and
\inferrule[eq\_bits\_not\_empty]{
  \vb \eqdef \bigwedge_{i=1}^k a_i = b_i
}{
  \binopliterals(\overname{\EQ}{\op}, \overname{\LBitvector(a_{1..k})}{\vvone}, \overname{\LBitvector(b_{1..k})}{\vvtwo}) \typearrow
  \overname{\LBool(\vb)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_bits]{
  \binopliterals(\EQ, \LBitvector(a), \LBitvector(b)) \typearrow \LBool(\vb) \OrTypeError
}{
  \binopliterals(\overname{\NE}{\op}, \overname{\LBitvector(a)}{\vvone}, \overname{\LBitvector(b)}{\vvtwo}) \typearrow \LBool(\neg\vb)
}
\end{mathpar}

\begin{mathpar}
\inferrule[or\_bits]{
  i=1..k: c_i = \max(a_i, b_i)
}{
  \binopliterals(\overname{\OR}{\op}, \overname{\LBitvector(a_{1..k})}{\vvone}, \overname{\LBitvector(b_{1..k})}{\vvtwo}) \typearrow \LBitvector(c_{1..k})
}
\end{mathpar}

\begin{mathpar}
\inferrule[and\_bits]{
  i=1..k: c_i = \min(a_i, b_i)
}{
  \binopliterals(\overname{\AND}{\op}, \overname{\LBitvector(a_{1..k})}{\vvone}, \overname{\LBitvector(b_{1..k})}{\vvtwo}) \typearrow \LBitvector(c_{1..k})
}
\end{mathpar}

\begin{mathpar}
\inferrule[xor\_bits]{
  {
    \textit{xor\_bit} = \lambda a,b\in\Bit.\ \left\{
      \begin{array}{ll}
        0 & \text{ if } a = b\\
        1 & \text{ otherwise}
      \end{array}
    \right.
  }\\
  i=1..k: c_i=\textit{xor\_bit}(a_i, b_i)
}{
  \binopliterals(\overname{\XOR}{\op}, \overname{\LBitvector(a_{1..k})}{\vvone}, \overname{\LBitvector(b_{1..k})}{\vvtwo}) \typearrow \LBitvector(c_{1..k})
}
\end{mathpar}

\begin{mathpar}
\inferrule[add\_bits]{
  a \eqdef \binarytounsigned(a_{1..k})\\
  b \eqdef \binarytounsigned(b_{1..k})\\
  c \eqdef \inttobits(a + b, k)
}{
  \binopliterals(\overname{\ADD}{\op}, \overname{\LBitvector(a_{1..k})}{\vvone}, \overname{\LBitvector(b_{1..k})}{\vvtwo}) \typearrow \overname{\LBitvector(c)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_bits]{
  a \eqdef \binarytounsigned(a_{1..k})\\
  b \eqdef \binarytounsigned(b_{1..k})\\
  c \eqdef \inttobits(a - b, k)
}{
  \binopliterals(\overname{\SUB}{\op}, \overname{\LBitvector(a_{1..k})}{\vvone}, \overname{\LBitvector(b_{1..k})}{\vvtwo}) \typearrow \overname{\LBitvector(c)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[concat\_bits]{}{
  {
  \begin{array}{r}
  \binopliterals(\overname{\BVCONCAT}{\op}, \overname{\LBitvector(a_{1..k})}{\vvone}, \overname{\LBitvector(b_{1..l})}{\vvtwo}) \typearrow \\
  \overname{\LBitvector(a_{1..k})\LBitvector(b_{1..l})}{\vr}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[add\_bits\_int]{
  y \eqdef \binarytounsigned(a)\\
  c \eqdef \inttobits(y + b, \listlen{a})
}{
  \binopliterals(\overname{\ADD}{\op}, \overname{\LBitvector(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LBitvector(c)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_bits\_int]{
  y \eqdef \binarytounsigned(a)\\
  c \eqdef \inttobits(y - b, \listlen{a})
}{
  \binopliterals(\overname{\SUB}{\op}, \overname{\LBitvector(a)}{\vvone}, \overname{\LInt(b)}{\vvtwo}) \typearrow \overname{\LBitvector(c)}{\vr}
}
\end{mathpar}

\subsubsection{Operators Over String Values \label{sec:StringOperations}}
\begin{mathpar}
\inferrule[eq\_string]{}{
  \binopliterals(\overname{\EQ}{\op}, \overname{\LString(a)}{\vvone}, \overname{\LString(b)}{\vvtwo}) \typearrow \overname{\LBool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_string]{}{
  \binopliterals(\overname{\NE}{\op}, \overname{\LString(a)}{\vvone}, \overname{\LString(b)}{\vvtwo}) \typearrow \overname{\LBool(a \neq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[concat\_strings]{
  \vvone \neq \LBitvector(\Ignore) \lor \vvtwo \neq \LBitvector(\Ignore) \\
  \vsone \eqdef \literaltostring(\vvone) \\
  \vstwo \eqdef \literaltostring(\vvtwo)
}{
  {
  \begin{array}{r}
  \binopliterals(\overname{\STRCONCAT}{\op}, \vvone, \vvtwo) \typearrow
  \overname{\vsone \concat \vstwo}{\vr}
  \end{array}
  }
}
\end{mathpar}

\subsubsection{Operators Over Label Values \label{sec:LabelOperations}}
\begin{mathpar}
\inferrule[eq\_label]{}{
  \binopliterals(\overname{\EQ}{\op}, \overname{\LLabel(a)}{\vvone}, \overname{\LLabel(b)}{\vvtwo}) \typearrow \overname{\LBool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_label]{}{
  \binopliterals(\overname{\NE}{\op}, \overname{\LLabel(a)}{\vvone}, \overname{\LLabel(b)}{\vvtwo}) \typearrow \overname{\LBool(a \neq b)}{\vr}
}
\end{mathpar}

\SemanticsRulesDef{Primitive Operations}

\SemanticsRuleDef{UnopValues}
\RenderRelation{eval_unop}
\BackupOriginalRelation{
The function
\[
  \evalunop(\overname{\unop}{\op} \aslsep \overname{\nativevalue}{\vv}) \aslto \overname{\nativevalue}{\vw} \cup \TDynError
\]
evaluates a unary operator $\op$ over a \nativevalueterm{} $\vv$ and returns the \nativevalueterm{} $\vw$ or an error.
} % END_OF_BACKUP_RELATION

\ExampleDef{Valid Unary Operation}
The following grounded rule shows how the application of negation
to the literal integer for $1$
translates into the application of negation to the \nativevalueterm{} for $1$.
\begin{mathpar}
\inferrule{
  \unopliterals(\NEG, \LInt(1)) \typearrow \LInt(-1)
}{
  \evalunop(\NEG, \nvint(1)) \evalarrow \nvint(-1)
}
\end{mathpar}

\ExampleDef{Invalid Unary Operation}
The following grounded rule shows how the application of negation
to the literal Boolean for $\True$
translates the resulting \typingerrorterm{} into the corresponding \dynamicerrorterm{}.
\begin{mathpar}
\inferrule{
  \unopliterals(\NEG, \LBool(\True)) \typearrow \TypeErrorVal{\BadOperands}
}{
  \evalunop(\NEG, \nvint(\True)) \evalarrow \DynamicErrorVal{\DynamicBadOperands}
}
\end{mathpar}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{ok}
  \begin{itemize}
    \item $\vv$ is a literal native value, that is, $\NVLiteral(l)$;
    \item statically evaluating $\op$ on the literal $l$ yields a literal $l'$;
    \item $\vw$ is the native literal value for $l'$.
  \end{itemize}

  \item \AllApplyCase{static\_error}
  \begin{itemize}
    \item $\vv$ is a literal native value, that is, $\NVLiteral(l)$;
    \item statically evaluating $\op$ on $l$ yields a \typingerrorterm{};
    \item the result is a \dynamicerrorterm{}.
  \end{itemize}

  \item \AllApplyCase{non\_literal}
  \begin{itemize}
    \item $\vv$ is not a literal native value;
    \item the result is a \dynamicerrorterm{} indicating the mismatch.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[ok]{
  \unopliterals(\op, l) \typearrow l' \\
  l' \neq \TypeErrorVal{\Ignore}
}{
  \evalunop(\op, \overname{\NVLiteral(l)}{\vv}) \evalarrow \overname{\NVLiteral(l')}{\vw}
}
\end{mathpar}

\begin{mathpar}
\inferrule[static\_error]{
  \unopliterals(\op, l) \typearrow \TypeErrorVal{\Ignore} \\
}{
  \evalunop(\op, \overname{\NVLiteral(l)}{\vv}) \evalarrow \DynamicErrorVal{\DynamicBadOperands}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_literal]{
  \astlabel(\vv) \neq \NVLiteral
}{
  \evalunop(\op, \vv) \evalarrow \DynamicErrorVal{\DynamicBadOperands}
}
\end{mathpar}

\SemanticsRuleDef{BinopValues}
\RenderRelation{eval_binop}
\BackupOriginalRelation{
The function
\[
  \evalbinop(\overname{\binop}{\op} \aslsep \overname{\nativevalue}{\vvone} \aslsep \overname{\nativevalue}{\vvtwo})
  \aslto \overname{\nativevalue}{\vw} \cup \TDynError
\]
evaluates a binary operator $\op$ over a pair of \nativevaluesterm{}  --- $\vvone$ and $\vvtwo$ --- and returns the
\nativevalueterm{}  $\vw$ or an error.
} % END_OF_BACKUP_RELATION

\ExampleDef{Valid Binary Operation}
The following grounded rule shows how the application of addition
to the literal integer for $2$ and the literal integer for $3$
translates into the application of addition to the \nativevalueterm{} for $2$
and the \nativevalueterm{} for $3$.
\begin{mathpar}
\inferrule{
  \binopliterals(\ADD, \LInt(2), \LInt(3)) \typearrow \LInt(5)
}{
  \evalbinop(\ADD, \nvint(2), \nvint(3)) \evalarrow \nvint(5)
}
\end{mathpar}

\ExampleDef{Invalid Binary Operation}
The following grounded rule shows how the invalid application of addition
to the literal integer for $2$ and the literal real for $1/2$
translates the resulting \typingerrorterm{} into the corresponding \dynamicerrorterm{}.
\begin{mathpar}
\inferrule{
  \binopliterals(\ADD, \LInt(2), \LReal(1/2)) \typearrow \TypeErrorVal{\BadOperands}
}{
  \evalbinop(\ADD, \nvint(2), \nvreal(1/2)) \evalarrow \DynamicErrorVal{\DynamicBadOperands}
}
\end{mathpar}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{ok}
  \begin{itemize}
    \item $\vvone$ is a literal native value, that is, $\NVLiteral(l_1)$;
    \item $\vvtwo$ is a literal native value, that is, $\NVLiteral(l_2)$;
    \item statically evaluating $\op$ on the literals $l_1$ and $l_2$ yields a literal $l'$;
    \item $\vw$ is the native literal value for $l'$.
  \end{itemize}

  \item \AllApplyCase{static\_error}
  \begin{itemize}
    \item $\vvone$ is a literal native value, that is, $\NVLiteral(l_1)$;
    \item $\vvtwo$ is a literal native value, that is, $\NVLiteral(l_2)$;
    \item statically evaluating $\op$ on the literals $l_1$ and $l_2$ yields a \typingerrorterm{};
    \item the result is a \dynamicerrorterm{} ($\DynamicBadOperands$).
  \end{itemize}

  \item \AllApplyCase{non\_literal}
  \begin{itemize}
    \item either $\vvone$ or $\vvtwo$ is not a literal native value;
    \item the result is a \dynamicerrorterm{} indicating the mismatch ($\DynamicBadOperands$).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[ok]{
  \binopliterals(\op, l_1, l_2) \typearrow l' \\
  l' \neq \TypeErrorVal{\Ignore}
}{
  \evalbinop(\op, \overname{\NVLiteral(l_1)}{\vvone}, \overname{\NVLiteral(l_2)}{\vvtwo}) \evalarrow \overname{\NVLiteral(l')}{\vw}
}
\end{mathpar}

\begin{mathpar}
\inferrule[static\_error]{
  \binopliterals(\op, l_1, l_2) \typearrow \TypeErrorVal{\Ignore} \\
}{
  \evalbinop(\op, \overname{\NVLiteral(l_1)}{\vvone}, \overname{\NVLiteral(l_2)}{\vvtwo}) \evalarrow \DynamicErrorVal{\DynamicBadOperands}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_literal]{
  \astlabel(\vvone) \neq \NVLiteral \lor \astlabel(\vvtwo) \neq \NVLiteral
}{
  \evalbinop(\op, \vvone, \vvtwo) \evalarrow \DynamicErrorVal{\DynamicBadOperands}
}
\end{mathpar}
