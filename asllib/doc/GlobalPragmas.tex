\chapter{Global Pragma Declarations\label{chap:Global Pragma Declarations}}

Global pragmas are statically checked by the typechecker, but do not produce \typedast{} nodes,
and thus are not associated with a dynamic semantics.

\ExampleDef{Global Pragma Declarations}
The specification in \listingref{GlobalPragma} contains two global pragmas,
which are ignored by the dynamic semantics.
\ASLListing{Global pragmas}{GlobalPragma}{\definitiontests/GlobalPragma.asl}

It is recommended that tools which process ASL should warn users of unrecognized tool specific pragmas.
\identi{SLNQ}

For example, a tool processing the specification in \listingref{GlobalPragma2} may recognize \\
\verb|my_tool_pragma1| but not \verb|other_tool_op|, and warn about it.
\ASLListing{Warning of pragmas not recognized by tools}{GlobalPragma2}{\definitiontests/GlobalPragma2.asl}

\ChapterOutline
\begin{itemize}
    \item \FormalRelationsRef{Global Pragma Declarations} defines the formal relations for global pragma declarations;
    \item \SyntaxRef{Global Pragma Declarations} defines the syntax of global pragma declarations;
    \item \AbstractSyntaxRef{Global Pragma Declarations} defines the abstract syntax of global pragma declarations; and
    \item \TypeRulesRef{Global Pragma Declarations} defines the type rules for global pragma declarations.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Global Pragma Declarations}

\paragraph{Syntax:} Global pragma declarations are grammatically derived from $\Ndecl$;

\paragraph{Abstract Syntax:} Global pragma declarations are derived in the abstract syntax from $\decl$,
    and generated via $\builddecl$ (see \ASTRuleRef{GlobalPragma});

\paragraph{Typing:} Global pragma declarations are checked by $\checkglobalpragma$ (see \TypingRuleRef{CheckGlobalPragma}); and

\paragraph{Semantics:} since global pragma declarations are discarded after typechecking,
    they have no associated dynamic semantics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SyntaxDef{Global Pragma Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{flalign*}
\Ndecl  \derives \ & \Tpragma \parsesep \Tidentifier \parsesep \ClistZero{\Nexpr} \parsesep \Tsemicolon&
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\AbstractSyntaxDef{Global Pragma Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RenderTypes[remove_hypertargets]{decl_global_pragma}
\BackupOriginalAST{
\begin{flalign*}
\decl \derives\ & \DPragma(\Tidentifier, \overtext{\KleeneStar{\expr}}{args})
\end{flalign*}
}

\ASTRuleDef{GlobalPragma}
\begin{mathpar}
\inferrule[global\_pragma]{
  \buildclist[\Nexpr](\vargs) \astarrow \astversion{\vargs}
}{
  {
  \begin{array}{r}
  \builddecl(\overname{\Ndecl(\Tpragma, \Tidentifier(\id), \namednode{\vargs}{\ClistZero{\Nexpr}}, \Tsemicolon)}{\vparsednode})
  \astarrow \\
    \overname{\left[\DPragma(\id, \astversion{\vargs})\right]}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\TypeRulesDef{Global Pragma Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\TypingRuleDef{CheckGlobalPragma}
\RenderRelation{check_global_pragma}
\BackupOriginalRelation{
The function
\[
  \checkglobalpragma(
    \overname{\globalstaticenvs}{\genv} \aslsep
    \overname{\decl}{\vd}
  )
  \aslto
  \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
typechecks a global pragma declaration $\vd$ in the \globalstaticenvironmentterm{} $\genv$,
yielding $\True$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Checking Global Pragmas}
The specification in \listingref{CheckGlobalPragma} shows a well-typed global pragma,
whereas the specification in \listingref{CheckGlobalPragma-bad} shows an ill-typed
global pragma where the expression \verb|x| is ill-typed, since the identifier \verb|x|
is undefined and the expression \verb|(2==3.0)| uses the operator \verb|==|
without matching any operation.
\ASLListing{A well-typed global pragma}{CheckGlobalPragma}{\typingtests/TypingRule.CheckGlobalPragma.asl}
\ASLListing{An ill-typed global pragma}{CheckGlobalPragma-bad}{\typingtests/TypingRule.CheckGlobalPragma.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vd$ is a global pragma declaration with any identifier and expression list $\vargs$. that is, $\DPragma(\Ignore, \vargs)$;
  \item applying $\withemptylocal$ to $\genv$ yields $\tenv$;
  \item applying $\annotateexprlist$ to $\vargs$ in $\tenv$ yields $\vargsp$ \ProseOrTypeError;
  \item $\vargsp$ is ignored;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \withemptylocal(\genv) \typearrow \tenv \\
  \annotateexprlist(\tenv, \vargs) \typearrow \vargsp \OrTypeError \\
}{
  \checkglobalpragma(\genv, \overname{\DPragma(\Ignore, \vargs)}{\vd}) \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckGlobalPragmaBegin}{\CheckGlobalPragmaEnd}{../Typing.ml}
