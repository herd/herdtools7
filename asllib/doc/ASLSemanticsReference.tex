\documentclass{book}
\input{ASLmacros}

\input{ASLSemanticsLines}

\newcommand{\testdir}{../tests/ASLSemanticsReference.t}

\author{Arm Architecture Technology Group}
\title{ASL Semantics Reference}
\begin{document}
\maketitle

\tableofcontents{}

\chapter{Non-Confidential Proprietary Notice}

This document is protected by copyright and other related rights and the
practice or implementation of the information contained in this document may be
protected by one or more patents or pending patent applications. No part of
this document may be reproduced in any form by any means without the express
prior written permission of Arm. No license, express or implied, by estoppel or
otherwise to any intellectual property rights is granted by this document
unless specifically stated.
               
Your access to the information in this document is conditional upon your
acceptance that you will not use or permit others to use the information for
the purposes of determining whether implementations infringe any third party
patents.
 
THIS DOCUMENT IS PROVIDED “AS IS”. ARM PROVIDES NO REPRESENTATIONS AND NO
WARRANTIES, EXPRESS, IMPLIED OR STATUTORY, INCLUDING, WITHOUT LIMITATION, THE
IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY QUALITY, NON-INFRINGEMENT
OR FITNESS FOR A PARTICULAR PURPOSE WITH RESPECT TO THE DOCUMENT. For the
avoidance of doubt, Arm makes no representation with respect to, and has
undertaken no analysis to identify or understand the scope and content of, any
patents, copyrights, trade secrets, trademarks, or other rights. 
 
This document may include technical inaccuracies or typographical errors.
 
TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ARM BE LIABLE FOR ANY
DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL,
INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS
OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF
ARM HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 
This document consists solely of commercial items. You shall be responsible for
ensuring that any use, duplication or disclosure of this document complies
fully with any relevant export laws and regulations to assure that this
document or any portion thereof is not exported, directly or indirectly, in
violation of such export laws. Use of the word “partner” in reference to Arm’s
customers is not intended to create or refer to any partnership relationship
with any other company. Arm may make changes to this document at any time and
without notice.
 
This document may be translated into other languages for convenience, and you
agree that if there is any conflict between the English version of this
document and any translation, the terms of the English version of this document
shall prevail.
 
The Arm corporate logo and words marked with ® or ™ are registered trademarks
or trademarks of Arm Limited (or its affiliates) in the US and/or elsewhere.
All rights reserved.  Other brands and names mentioned in this document may be
the trademarks of their respective owners. Please follow Arm’s trademark usage
guidelines at \url{https://www.arm.com/company/policies/trademarks.}

Copyright © [2023,2024] Arm Limited (or its affiliates). All rights reserved. 
 
Arm Limited. Company 02557590 registered in England.  110 Fulbourn Road,
Cambridge, England CB1 9NJ.  (LES-PRE-20349)

\chapter{Disclaimer}

This document is part of the ASLRef material. This material covers both ASLv0
(viz, the existing ASL pseudocode language which appears in the Arm
Architecture Reference Manual) and ASLv1, a new, experimental, and as yet
unreleased version of ASL.

The development version of ASLRef can be found here \url{~/herdtools7/asllib}.

A list of open items being worked on can be found here
\url{~/herdtools7/asllib/doc/ASLRefProgress.tex}.

This material is work in progress, more precisely at Alpha quality as
per Arm’s quality standards. In particular, this means that it would be
premature to base any production tool development on this material.

However, any feedback, question, query and feature request would be most
welcome; those can be sent to Arm’s Architecture Formal Team Lead Jade Alglave
\texttt{(jade.alglave@arm.com)} or by raising issues or PRs to the herdtools7
github repository.

\chapter{Preamble}

The semantics of ASL are embodied in a function that takes as input an ASL program
and returns all possible behaviours of that program.

\section{Environments}

An environment is what the semantics operates over: a structure
which amongst other things associates values to variables.
Intuitively, the evaluation of a program makes an initial
environment evolve, with new values as given by the operations
of the program. Environments map names to variables and subprograms.

\section{Variables}
Variables have two different possible scopes: global to the whole program which
come with an initial value and cannot be declared inside a subprogram, or local
to a subprogram. Global variables are initialised at the start of the evaluation
of the program.

\section{Functions}
Functions are declared statically: they are declared before the start of the
program and are not values, thus a subprogram call uses directly a function name.

Formally, an environment $E \in \mathcal{E}$ is a pair of a binding from global
variable names to their value, and a binding from local variable names to their
values:

%
\[
  \mathcal{E} = \left( \X \hookrightarrow \mathcal{V} \right)
         % \times \left( \X^\text{F} \hookrightarrow {\X^\text{L}}^* \times \mathcal{S} \right)
         \times \left( \X \hookrightarrow \mathcal{V} \right)
\]

We define some notations, for an environment $E = (G, F, L)$, a variable $x$
and a value $v$:
%
\begin{mathpar}
  E\globals \triangleq G
  \and
  % E^\text{F} \triangleq F
  % \and
  E\locals \triangleq L
  \and
  \text{Env}(G, L) \triangleq E
  \and
  E[x \mapsto v] \triangleq
    \left\{
      \begin{array}{ll}
        (G[x \mapsto v], L) &\text{if}\ x \in \dom (G) \\
        (G, L[x \mapsto v]) &\text{otherwise} \\
      \end{array}
    \right.
\end{mathpar}
%
The notation $E\globals$ refers to the global part of the environment, and
$E\locals$ to the local variable mappings, and $\text{Env} (G, L)$ is the
environment formed with the global mappings in $G$ and the local from $L$.
%
The notation $E[x \mapsto v]$ is the environment $E$ modified so $x$ is bound
to $v$.
%
Furthermore, $v?$ refers to $v$ or $\bot$, and the usage of $v$ without a
question mark implies that $v \neq \bot$.
%
In particular, the over-writing of a variable in an environment depends on
whether the variable is a global or local variable.

\section{Evaluation}

Evaluating a program is evaluating its ``main'' subprogram.
Constructively, evaluating a program requires following its
Abstract Syntax Tree and evaluating each of its components.

The semantics of a program are given by applying a set of
\texttt{eval\_<label>} functions. Each \texttt{eval\_<label>} function
describes how to evaluate a specific label, as follows.
\begin{itemize}
\item \texttt{eval\_expr} evaluates expressions: it takes an
environment and an expression and returns a value and a
new environment (see Chapter~\ref{chap:eval_expr});
\item \texttt{eval\_lexpr} evaluates left-hand sides of assignments: it takes
an environment, the left-hand side of an assignment and a value to be written,
and returns a environment updated with the new value (see
Chapter~\ref{chap:eval_lexpr});
\item \texttt{eval\_slices} evaluates slices (see Chapter~\ref{chap:eval_slices});
\item \texttt{eval\_patterns} evaluates patterns (see Chapter~\ref{chap:eval_pattern});
\item \texttt{eval\_local\_decl} evaluates local declarations (see Chapter~\ref{chap:eval_local_decl});
\item \texttt{eval\_stmt} evaluates statements: it takes an
environment and a statement and returns a new
environment, viz, the environment updated with the side-effects
of the statement (see Chapter~\ref{chap:eval_stmt});
\item \texttt{eval\_block} evaluates blocks (see Chapter~\ref{chap:eval_block});
\item \texttt{eval\_loop} evaluates both \texttt{while} and \texttt{repeat} loops (see Section~\ref{sec:SemanticsRule.Loop});
\item \texttt{eval\_for} evaluates \texttt{for} loops (see Section~\ref{sec:SemanticsRule.For});
\item \texttt{eval\_catchers} evaluates catchers (see Chapter~\ref{chap:eval_catchers});
\item \texttt{eval\_func} evaluates subprograms: it takes an
environment, a subprogram name and its arguments, and returns a
list of the return values of the subprogram (see Chapter~\ref{chap:eval_func}).
\end{itemize}

\chapter{Reading guide}

The definition of each \texttt{eval\_<label>} function is given by a number of
rules, which follow the possible shapes the \texttt{label} can have. For
example, an expression can be a literal, or a binary operator, amongst other
things. Each of those has its own evaluation rule: SemanticsRule.Lit in
Section~\ref{sec:SemanticsRule.Lit}, Semantics.Binop in
Section~\ref{sec:SemanticsRule.Binop} respectively.

Each rule is presented using the following template:
\begin{itemize}
\item a Prose paragraph gives the rule in English, and corresponds as much as possible to the code of the reference implementation ASLRef given at \url{~/herdtools7/asllib};
\item one or several Example, which as much as possible are also given as regression tests in \url{~/herdtools7/asllib/tests/ASLSemanticsReference.t}
\item a Code paragraph which gives a verbatim of the corresponding implementation in the interpreter of ASLRef \url{~/herdtools7/asllib/Interpreter.ml};
\item a Formal paragraph for the sequential case, which gives a formal
definition of the rule: the sequential case essentially gives the same
information as the Prose paragraph;
\item a Formal paragraph for the concurrent case: the concurrent case augments
the information given by the sequential case with a set of \texttt{herd7}
execution graphs. This enables building, for each AArch64 instruction, the
Intrinsic dependencies used by the AArch64 memory model from this instruction's
ASL code.
\end{itemize}
%
Formally, the semantics of different language constructs are given by the functions
$\interp{\cdot}_F$ that map an environment to a set of pair of values and
environments, where $F$ is a given set of ASL subprograms.
%
In the following, for simplicity, we will omit the indices $F$ from the
semantics definitions, apart when defined, as they are constant in the whole
evaluation.
%
Furthermore, the variable names inside set definitions are implicitly
quantified. For example the two following definitions are equivalent:
%
\begin{gather*}
  X + Y \triangleq \left\{ n \st{} n_1 \in X \ \text{and}\ n_2 \in Y \text{and}\ n = n_1 + n_2 \right\}
  \\
  X + Y \triangleq \left\{ n \st{} \exists n_1 \in X, \exists n_2 \in Y, n = n_1 + n_2 \right\}
\end{gather*}


\chapter{Evaluation of Expressions \label{chap:eval_expr}}

\texttt{eval\_expr} specifies how to evaluate an expression \texttt{e} in an
environment \texttt{env}.

Evaluation of the expression \texttt{e} under an environment \texttt{env} is
either a value \texttt{v} together with a potentially updated
environment \texttt{new\_env}, or an error, and one of the following applies:
\begin{itemize}
\item SemanticsRule.Lit (see Section~\ref{sec:SemanticsRule.Lit});
\item SemanticsRule.ELocalVar (see Section~\ref{sec:SemanticsRule.ELocalVar})
\item SemanticsRule.EGlobalVar (see Section~\ref{sec:SemanticsRule.EGlobalVar})
\item SemanticsRule.EUndefIdent (see Section~\ref{sec:SemanticsRule.EUndefIdent})
\item SemanticsRule.BinopAnd (see Section~\ref{sec:SemanticsRule.BinopAnd})
\item SemanticsRule.BinopOr (see Section~\ref{sec:SemanticsRule.BinopOr})
\item SemanticsRule.BinopImpl (see Section~\ref{sec:SemanticsRule.BinopImpl})
\item SemanticsRule.Binop (see Section~\ref{sec:SemanticsRule.Binop})
\item SemanticsRule.Unop (see Section~\ref{sec:SemanticsRule.Unop})
\item SemanticsRule.ECond (see Section~\ref{sec:SemanticsRule.ECond})
\item SemanticsRule.ESlice (see Section~\ref{sec:SemanticsRule.ESlice})
\item SemanticsRule.ECall (see Section~\ref{sec:SemanticsRule.ECall})
\item SemanticsRule.EGetArray (see Section~\ref{sec:SemanticsRule.EGetArray})
\item SemanticsRule.ERecord (see Section~\ref{sec:SemanticsRule.ERecord})
\item SemanticsRule.EGetField (see Section~\ref{sec:SemanticsRule.EGetField})
\item SemanticsRule.EConcat (see Section~\ref{sec:SemanticsRule.EConcat})
\item SemanticsRule.ETuple (see Section~\ref{sec:SemanticsRule.ETuple})
\item SemanticsRule.EUnknown (see Section~\ref{sec:SemanticsRule.EUnknown})
\item SemanticsRule.EPattern (see Section~\ref{sec:SemanticsRule.EPattern})
\item SemanticsRule.CTC (see Section~\ref{sec:SemanticsRule.CTC})
\end{itemize}


\section{SemanticsRule.Lit \label{sec:SemanticsRule.Lit}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a Literal \texttt{l};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the value of \texttt{l};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example}
  In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Lit.asl}
  the expression \texttt{3} evaluates to the value \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\LitBegin, lastline=\LitEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  The evaluation of a literal value \texttt{v} associates any environment
\texttt{env} to itself coupled with \texttt{v}:

\begin{align}
  \interp{\texttt{v}}(\texttt{env}) & \triangleq \left\{ (\texttt{v}, \texttt{env}) \right\}
  \label{eq:sem-seq-lit}
  \end{align}

  \subsection{Formally: concurrent case}
  \begin{align}
  \interp{\texttt{v}}(\texttt{env}) & \triangleq \left\{ (\texttt{v}, \texttt{env}, \varnothing) \right\}
  \label{eq:sem-conc-lit}
  \end{align}
\end{formal}

\isempty{\subsection{Comments}}


\section{SemanticsRule.ELocalVar \label{sec:SemanticsRule.ELocalVar}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a variable \texttt{x} which is bound locally in \texttt{env};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the value of \texttt{x} in \texttt{env};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRuleELocalVar.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ELocalVar.asl}
    the evaluation of \texttt{x} within \texttt{assert x == 3;} uses SemanticsRule.ELocalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\ELocalVarBegin, lastline=\ELocalVarEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  The evaluation of a variable \texttt{x} in an environment \texttt{env} that maps \texttt{x} to \texttt{v}
  is the tuple $(\texttt{v},\texttt{env})$:
  \begin{align}
  \interp{\texttt{x}}(\texttt{env}) & \triangleq \left\{ (\texttt{env}[\texttt{x}], \texttt{env})) \right\}
  \label{eq:sem-seq-var}
  \end{align}

  \subsection{Formally: concurrent case}
  \begin{align}
  \interp{x}(\texttt{env}) & \triangleq \left\{ (\texttt{env}[\texttt{x}], \texttt{env}, \texttt{R(x)}) \right\}
  \label{eq:sem-conc-var}
  \end{align}
\end{formal}

  \subsection{Comments}
  When there exists a global variable called \texttt{x} then an ASL program
  cannot use the name \texttt{x} as a local variable. ASLRef checks that this
  property, sometimes called ``banning shadowing'', is true at type-checking.

\section{SemanticsRule.EGlobalVar \label{sec:SemanticsRule.EGlobalVar}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a variable \texttt{x} which is bound globally in \texttt{env};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the value of \texttt{x} in \texttt{env};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRuleEGlobalVar.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGlobalVar.asl}
    the evaluation of \texttt{global\_x} within \texttt{assert global\_x == 3;}
    uses SemanticsRule.EGlobalVar.

%  \subsection{Example: SemanticsRuleEGlobalVarError.asl}
%    The program:
%    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGlobalVarError.asl}
%    raises a type error because \texttt{x} is already declared locally in
%    \texttt{stdlib.asl}.

  \subsection{Code}
  \VerbatimInput[firstline=\EGlobalVarBegin, lastline=\EGlobalVarEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  \begin{align}
  \interp{\texttt{x}}(\texttt{env}) & \triangleq \left\{ (\texttt{env}[\texttt{x}], \texttt{env})) \right\}
  \label{eq:sem-seq-var}
  \end{align}

  \subsection{Formally: concurrent case}
  \begin{align}
  \interp{\texttt{x}}(\texttt{env}) & \triangleq \left\{ (\texttt{env}[\texttt{x}], \texttt{env}, \texttt{R(x)}) \right\}
  \label{eq:sem-conc-var}
  \end{align}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EUndefIdent \label{sec:SemanticsRule.EUndefIdent}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{res} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a variable \texttt{x} which is not bound in \texttt{env};
  \item \texttt{res} is an ``\texttt{Undefined Identifier}'' error.
  \end{itemize}

  \subsection{Example: SemanticsRule.EUndefIdent.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUndefIdent.asl}
    raises an \texttt{Undefined Identifier} error: the variable \texttt{y} is
    undefined in the environment where $\mathtt{x}$ is bound to $\mathtt{42}$.

  \subsection{Code}
  \VerbatimInput[firstline=\EUndefIdentBegin, lastline=\EUndefIdentEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.BinopAnd \label{sec:SemanticsRule.BinopAnd}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a conjunction over two expressions \texttt{e1} and \texttt{e2};
  \item \texttt{(res,new\_env)} is the result of the evaluation of \texttt{if
e1 then e2 else false} (see Section~\ref{sec:SemanticsRule.ECond}).
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopAndFalse.asl}

 \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopAndFalse.asl}
    the expression \texttt{FALSE \&\& fail()} evaluates to the value \texttt{FALSE}. Notice that the function \texttt{fail} is not called.

  \subsection{Code}
  \VerbatimInput[firstline=\BinopAndBegin, lastline=\BinopAndEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

  \subsection{Comments}
  This aims to encompass \identr{BKNT}, and \identi{QRXP}.

\section{SemanticsRule.BinopOr \label{sec:SemanticsRule.BinopOr}}
  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a disjunction over two expressions \texttt{e1} and \texttt{e2};
  \item \texttt{(res,new\_env)} is the result of the evaluation of \texttt{if
e1 then true else e2} (see Section~\ref{sec:SemanticsRule.ECond}).
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopOrTrue.asl}
\VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopOrTrue.asl}
    the expression \texttt{(0 == 1) \textbar\textbar \&\& (1 == 1)} evaluates to the value \texttt{TRUE}.

  \subsection{Code}
  \VerbatimInput[firstline=\BinopOrBegin, lastline=\BinopOrEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

  \subsection{Comments}
  This aims to encompass \identr{BKNT}, and \identi{QRXP}.

\section{SemanticsRule.BinopImpl \label{sec:SemanticsRule.BinopImpl}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes an implication over two expressions \texttt{e1} and \texttt{e2};
  \item \texttt{e} is evaluated as \texttt{if e1 then e2 else true}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopImplExFalso.asl}
\VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopImplExFalso.asl}
the expression \texttt{(0 == 1) --> (1 == 0)} evaluates to the value \texttt{TRUE}, according to the definition of implication.

  \subsection{Code}
  \VerbatimInput[firstline=\BinopImplBegin, lastline=\BinopImplEnd]{../Interpreter.ml}
\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\subsection{Comments}
  This aims to encompass \identr{BKNT}, and \identi{QRXP}.

\section{SemanticsRule.Binop \label{sec:SemanticsRule.Binop}}

  \subsection{Prose}
Evaluation of the expression \texttt{e} under environment \texttt{env} is \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a Binary Operator \texttt{op} over two expressions \texttt{e1} and \texttt{e2};
  \item The evaluation of the expression \texttt{e1} under \texttt{env} is \texttt{v1};
  \item \texttt{env'} is the result of modifying \texttt{env} after evaluation of the expression \texttt{e1} under \texttt{env};
  \item The evaluation of the expression \texttt{e2} under \texttt{env} is \texttt{v2};
  \item \texttt{new\_env} is the result of modifying \texttt{env'} after evaluation of the expression \texttt{e2} under \texttt{env'};
  \item \texttt{v} is the result of applying the Binary Operator \texttt{op} to \texttt{v1} and \texttt{v2};
  \item \texttt{res} is \texttt{v};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopPlusAssert.asl}
    In this program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopPlusAssert.asl}
    the expression \texttt{3 + 2} evaluates to the value \texttt{5}.

  \subsection{Example: SemanticsRule.EDIVBackendDefinedError.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopDIVBackendDefinedError.asl}
    \begin{itemize}
    \item in ASLv0, the expression \texttt{3 DIV 0} raises a backend-defined
      error, e.g.
      \texttt{ASL Execution error: Illegal application of operator DIV for values 3 and 0.}
    \item in ASLv1, the expression \texttt{3 DIV 0} raises a type error.
    \end{itemize}

  \subsection{Code}
  \VerbatimInput[firstline=\BinopBegin, lastline=\BinopEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}

  \begin{align}
  \interp{\texttt{e1} + \texttt{e2}} (\texttt{env}) & \triangleq
    \left\{ (v, \texttt{new\_env}) \st{}
    \begin{aligned}
      & \texttt{v1} + \texttt{v2} = \texttt{v}
      \\ \text{and}\ &
      (\texttt{v1}, \texttt{env'}) \in{} \interp{\texttt{e1}} (E)
      \\ \text{and}\ &
      (\texttt{v2}, \texttt{new\_env}) \in{} \interp{\texttt{e2}} (\texttt{env'})
    \end{aligned}
    \right\}
  \label{eq:sem-seq-plus}
  \end{align}

  \subsection{Formally: concurrent case}
  For the ordering constraints, the different arguments of a n-ary subprogram
are considered computed in parallel:
  \begin{align}
    \interp{\texttt{e1} + \texttt{e2}} (\texttt{env}) & \triangleq
    \left\{ (\texttt{v}, \texttt{new\_env}, S_1 \parallel S_2) \st{}
    \begin{aligned}
      & \texttt{v1} + \texttt{v2} = \texttt{v}
      \\ \text{and}\ &
      (\texttt{v1}, \texttt{env'}, S_1) \in{} \interp{\texttt{e1}} (\texttt{env})
      \\ \text{and}\ &
      (\texttt{v2}, \texttt{new\_env}, S_2) \in{} <\interp{\texttt{e2}} (\texttt{env'})
    \end{aligned}
    \right\}
  \label{eq:sem-conc-plus}
  \end{align}
\end{formal}

\subsection{Comments}
  This aims to encompass \identr{BKNT}.

\section{SemanticsRule.Unop \label{sec:SemanticsRule.Unop}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a Unary Operator \texttt{op} over an expression \texttt{e'} in an environment \texttt{env};
  \item The evaluation of the expression \texttt{e'} under \texttt{env} is \texttt{v',new\_env};
  \item \texttt{v, new\_env} is the result of applying the Unary Operator \texttt{op} to \texttt{v'}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EUnopAssert.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnopAssert.asl}
    the expression \texttt{NOT '1010'} evaluates to the value \texttt{'0101'}.

  \subsection{Code}
  \VerbatimInput[firstline=\UnopBegin, lastline=\UnopEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ECond \label{sec:SemanticsRule.ECond}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a conditional expression \texttt{e\_cond} with two options \texttt{e1} and \texttt{e2};
  \item The evaluation of the conditional expression \texttt{e\_cond} under \texttt{env} is \texttt{m\_cond};
  \item The evaluation of \texttt{e1} or \texttt{e2}, depending on \texttt{m\_cond}, is \texttt{v}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ECondFalse.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECondFalse.asl}
    the expression \texttt{if FALSE then Return42() else 3} evaluates to the value \texttt{3}.

  \subsection{Example: SemanticsRule.ECondUNKNOWN3or42.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECondUNKNOWN3or42.asl}
the expression \texttt{if UNKNOWN: boolean then 3 else Return42()} will
evaluate either \texttt{3} or \texttt{Return42()} depending on how
\texttt{UNKNOWN} is implemented.

  \subsection{Code}
  \VerbatimInput[firstline=\ECondBegin, lastline=\ECondEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

  \subsection{Comments}
  This aims to encompass \identr{YCDB}.

\section{SemanticsRule.ESlice \label{sec:SemanticsRule.ESlice}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes an expression \texttt{e\_bv} sliced as per \texttt{slices};
  \item The evaluation of \texttt{e\_bv} under \texttt{env} is \texttt{v\_bv};
  \item The evaluation of \texttt{slices} under \texttt{env} is \texttt{positions};
  \item \texttt{v} is the value read in \texttt{v\_bv} from \texttt{positions}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ESlice.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ESlice.asl}
    the expression \texttt{'11110000'[5:2]} evaluates to the value \texttt{'1100'}.

  \subsection{Code}
  \VerbatimInput[firstline=\ESliceBegin, lastline=\ESliceEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ECall \label{sec:SemanticsRule.ECall}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a subprogram call \texttt{(name, params, actual\_args)};
  \item The evaluation of that subprogram call under \texttt{env} is \texttt{ms};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the value read from \texttt{ms};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ECall.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECall.asl}
    the expression \texttt{Return42()} evaluates to the value \texttt{42} because the
    subprogram \texttt{Return42()} is implemented to return the value \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\ECallBegin, lastline=\ECallEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EGetArray \label{sec:SemanticsRule.EGetArray}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  such that all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes an array \texttt{e\_array} and an index \texttt{e\_index};
  \item The evaluation of \texttt{e\_array} under \texttt{env} is \texttt{v\_array};
  \item The evaluation of \texttt{e\_index} under \texttt{env} is \texttt{v\_index};
  \item One of the following applies:
        \begin{itemize}
        \item All of the following apply:
          \begin{itemize}
          \item the result of evaluation of \texttt{e} under \texttt{env} is \texttt{(res, env)};
          \item \texttt{res} is a value \texttt{v};
          \item \texttt{v} is the value found at the index \texttt{v\_index} of \texttt{v\_array};
          \item \texttt{new\_env} is \texttt{env};
          \end{itemize}

        \item \texttt{res} is a typing error.
        \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.EGetArray.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGetArray.asl}
    the expression \texttt{my\_array[2]} evaluates to the value \texttt{42} since the element
    indexed by \texttt{2} in \texttt{my\_array} is \texttt{42}.

  \subsection{Example: SemanticsRule.EGetArrayTooSmall.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGetArrayTooSmall.asl}
    raises a typing error since we are trying to access index \texttt{3} of an array
    which has indexes \texttt{0}, \texttt{1} and \texttt{2} only.

  \subsection{Code}
  \VerbatimInput[firstline=\EGetArrayBegin, lastline=\EGetArrayEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ERecord \label{sec:SemanticsRule.ERecord}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a record value \texttt{names} and associated expressions
    \texttt{fields};
  \item \texttt{fields} evaluates in \texttt{env} to \texttt{v\_fields};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the record built by associating the names \texttt{names} to \texttt{v\_fields}.
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ERecord.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ERecord.asl}
    the expression \texttt{MyRecordType { a=3, b=42 }} evaluates to the value \texttt{{a:
3, b: 42}}.

  \subsection{Code}
  \VerbatimInput[firstline=\ERecordBegin, lastline=\ERecordEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EGetField \label{sec:SemanticsRule.EGetField}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a field name \texttt{field\_name} in a record value \texttt{e\_vec};
  \item the evaluation of \texttt{e\_vec} in \texttt{env} is \texttt{v\_vec};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the value mapped by \texttt{field\_name} in \texttt{v\_vec};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ERecord.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ERecord.asl}
    the expression \texttt{my\_record.a} evaluates to the value \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\EGetFieldBegin, lastline=\EGetFieldEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}


\isempty{\subsection{Comments}}

\section{SemanticsRule.EConcat \label{sec:SemanticsRule.EConcat}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a list of bitvector expressions \texttt{e\_list};
  \item the evaluation of \texttt{e\_list} in \texttt{env} is \texttt{v\_list};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the concatenation of \texttt{v\_list};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EConcat}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EConcat.asl}
    the expression \texttt{['10', '11']} evaluates to the value \texttt{'1011'}.

  \subsection{Code}
  \VerbatimInput[firstline=\EConcatBegin, lastline=\EConcatEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ETuple \label{sec:SemanticsRule.ETuple}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a list of expression \texttt{e\_list};
  \item the evaluation of \texttt{e\_list} in \texttt{env} is \texttt{v\_list};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the tuple built from \texttt{v\_list};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ETuple.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ETuple.asl}
    the expression \texttt{(3, Return42())} evaluates to the value \texttt{(3, 42)}.

  \subsection{Code}
  \VerbatimInput[firstline=\ETupleBegin, lastline=\ETupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EUnknown \label{sec:SemanticsRule.EUnknown}}

  \subsection{Domain of a type}

  The domain of a type $t$, written $D(t)$, is defined as follows:
  \[
  D(t) \triangleq \left\{
    \begin{array}{ll}
      \{\text{true}, \text{false} \} & \text{if } t \text{ is boolean}  \\
      \mathbb{Z}                     & \text{if } t \text{ is integer}  \\
      {\{0, 1\}}^n                   & \text{if } t \text{ is bits} (n) \\
    \end{array}
  \right.
  \]

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a type \texttt{t};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is a value in the domain of \texttt{t};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EUnknownInteger3.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnknownInteger3.asl}
    the expression \texttt{[UNKNOWN : integer]} evaluates to an integer value.

  \subsection{Example: SemanticsRule.EUnknownIntegerRange3-42-3.asl}

    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnknownIntegerRange3-42-3.asl}
    the expression \texttt{UNKNOWN : integer \{3, 42\}} evaluates to either the value
\texttt{3} or the value \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\EUnknownBegin, lastline=\EUnknownEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}

  \begin{align}
  \interp{\syntt{unknown:}\ t} (E) & \triangleq \left\{ (v, E) \st{} v \in{} D(t) \right\}
  \label{eq:sem-seq-unknown}
  \end{align}

  \subsection{Formally: concurrent case}

  \begin{align}
  \interp{\syntt{unknown:} t} (E) & \triangleq \left\{ (v, E, \varnothing) \st{} v \in{} D(t) \right\}
  \label{eq:sem-conc-unknown}
  \end{align}
\end{formal}

\subsection{Comments}
  This aims to encompass \identr{WLCH}.

\section{SemanticsRule.EPattern \label{sec:SemanticsRule.EPattern}}


  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a pattern \texttt{e,p};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the boolean determining whether the evaluation of \texttt{e} in \texttt{env} matches \texttt{p};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EPatternFALSE.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EPatternFALSE.asl}
    the expression \texttt{42 IN \{0..3, -4\}} evaluates to the value \texttt{FALSE}.

  \subsection{Example: SemanticsRule.EPatternTRUE.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EPatternTRUE.asl}
    the expression \texttt{42 IN \{0..3, 42\}} evaluates to \texttt{TRUE}.

  \subsection{Code}
  \VerbatimInput[firstline=\EPatternBegin, lastline=\EPatternEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CTC \label{sec:SemanticsRule.CTC}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{(e,\_t)} denotes an expression \texttt{e} and a type \texttt{t};
  \item \texttt{v} is the result of evaluating \texttt{e} in \texttt{env};
  \item \texttt{new\_env} is \texttt{env} modified after evaluating \texttt{e} in \texttt{env};
  \item \texttt{b} is \texttt{true} or \texttt{false} depending on whether \texttt{v} is of type \texttt{t} in \texttt{env};
  \item One of the following applies:
        \begin{itemize}
        \item All of the following apply:
              \begin{itemize}
              \item \texttt{b} is \texttt{true};
              \item \texttt{res} is \texttt{v};
              \item \texttt{new\_env} is \texttt{new\_env}
              \end{itemize}
        \item All of the following apply:
              \begin{itemize}
              \item \texttt{b} is \texttt{false};
              \item a type error is raised.
              \end{itemize}
        \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.CTCValue.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CTCValue.asl}

  \subsection{Example: SemanticsRule.CTCError.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CTCError.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\CTCBegin, lastline=\CTCEnd]
                {../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}


\chapter{Evaluation of Left-Hand-Side Expressions \label{chap:eval_lexpr}}

Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is either \texttt{new\_env}
or an error is raised and one of the following applies:
\begin{itemize}
\item SemanticsRule.LEDiscard (see Section~\ref{sec:SemanticsRule.LEDiscard});
\item SemanticsRule.LELocalVar (see Section~\ref{sec:SemanticsRule.LELocalVar});
\item SemanticsRule.LEGlobalVar (see Section~\ref{sec:SemanticsRule.LEGlobalVar});
\item SemanticsRule.LEUndefIdentV0 (see Section~\ref{sec:SemanticsRule.LEUndefIdentV0});
\item SemanticsRule.LEUndefIdentV1 (see Section~\ref{sec:SemanticsRule.LEUndefIdentV1});
\item SemanticsRule.LESlice (see Section~\ref{sec:SemanticsRule.LESlice});
\item SemanticsRule.LESetArray (see Section~\ref{sec:SemanticsRule.LESetArray});
\item SemanticsRule.LESetField (see Section~\ref{sec:SemanticsRule.LESetField});
\item SemanticsRule.LEDestructuring (see Section~\ref{sec:SemanticsRule.LEDestructuring}).
\end{itemize}

\section{SemanticsRule.LEDiscard \label{sec:SemanticsRule.LEDiscard}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} can be discarded;
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

  \subsection{Example: SemanticsRule.LEDiscard.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEDiscard.asl}
  \texttt{- = 42;} does not affect the environment.

  \subsection{Code}
  \VerbatimInput[firstline=\LEDiscardBegin, lastline=\LEDiscardEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LELocalVar \label{sec:SemanticsRule.LELocalVar}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a variable \texttt{x};
    \item \texttt{x} is locally bound in \texttt{env};
    \item \texttt{new\_env} is \texttt{env} where \texttt{x} is bound to \texttt{v}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LELocalVar.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LELocalVar.asl}
    the evaluation of the left-hand-side expression \texttt{x} within \texttt{x = 42;} uses SemanticsRule.LELocalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\LELocalVarBegin, lastline=\LELocalVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LEGlobalVar \label{sec:SemanticsRule.LEGlobalVar}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a variable \texttt{x};
    \item \texttt{x} is globally bound in \texttt{env};
    \item \texttt{new\_env} is \texttt{env} where \texttt{x} is bound to \texttt{v}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LEGlobalVar.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEGlobalVar.asl}
    the evaluation of the left-hand-side expression \texttt{x} within \texttt{x = 42;} uses SemanticsRule.LEGlobalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\LEGlobalVarBegin, lastline=\LEGlobalVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LEUndefIdentV0 \label{sec:SemanticsRule.LEUndefIdentV0}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a variable \texttt{x} which is not bound in \texttt{env};
    \item the ASL language version is \texttt{V0};
    \item \texttt{new\_env} is \texttt{env} where \texttt{x} has been declared
a local variable bound to the value \texttt{v}.
    \end{itemize}

  \subsection{Example: SemanticsRule.LEUndefIdentV0.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEUndefIdentV0.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\LEUndefIdentZeroBegin, lastline=\LEUndefIdentZeroEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LEUndefIdentV1 \label{sec:SemanticsRule.LEUndefIdentV1}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a variable \texttt{x} which is not bound in \texttt{env};
    \item the ASL language version is \texttt{V1};
    \item an \texttt{UndefinedIdentifier} error is raised.
    \end{itemize}

    \subsection{Example: SemanticsRule.LEUndefIdentV1.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEUndefIdentV1.asl}
    the evaluation of the left-hand-side expression \texttt{y} within \texttt{y
= 3;} raises an ``Undefined identifier'' error in the environment where
\texttt{x} is bound to \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\LEUndefIdentOneBegin, lastline=\LEUndefIdentOneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LESlice \label{sec:SemanticsRule.LESlice}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a left-hand-side expression sliced as per \texttt{slices};
    \item The right-hand-side expression corresponding to \texttt{le} is \texttt{re\_bv};
    \item The evaluation of \texttt{re\_bv} under \texttt{env} is \texttt{rv\_bv};
    \item The evaluation of \texttt{slices} under \texttt{env} is \texttt{positions};
    \item \texttt{new\_m\_bv} is \texttt{rv\_bv} where the positions \texttt{positions} have been updated to \texttt{v};
    \item \texttt{new\_env} is \texttt{env} where \texttt{le} is bound to \texttt{new\_m\_bv}.
    \end{itemize}

   \subsection{Example: SemanticsRule.LESlice.asl}
   In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESlice.asl}
   \texttt{x[3:0] = '0000'} binds \texttt{x} to \texttt{'11110000'} in the environment where \texttt{x} is bound to \texttt{'11111111'}.

  \subsection{Code}
  \VerbatimInput[firstline=\LESliceBegin, lastline=\LESliceEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LESetArray \label{sec:SemanticsRule.LESetArray}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes an array \texttt{le\_array} and an index \texttt{e\_index};
    \item The right-hand-side expression corresponding to \texttt{le\_array} is \texttt{re\_array};
    \item The evaluation of \texttt{re\_array} under \texttt{env} is \texttt{rv\_array};
    \item The evaluation of \texttt{e\_index} under \texttt{env} is \texttt{v\_index};
    \item \texttt{new\_v\_array} is \texttt{rv\_array} where the value at index \texttt{v\_index} has been
      updated to \texttt{v};
    \item \texttt{new\_env} is \texttt{env} where \texttt{le\_array} is bound to
      \texttt{new\_v\_array}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LESetArray.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESetArray.asl}
    binds the third element of \texttt{my\_array} to the value \texttt{53}.

  \subsection{Code}
  \VerbatimInput[firstline=\LESetArrayBegin, lastline=\LESetArrayEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LESetField \label{sec:SemanticsRule.LESetField}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a field name \texttt{field\_name} in a record \texttt{le\_record};
    \item The right-hand-side expression corresponding to \texttt{le\_record} is
      \texttt{re\_record};
    \item The evaluation of \texttt{re\_record} under \texttt{env} is \texttt{rv\_record};
    \item \texttt{new\_v\_record} is \texttt{rv\_record} where the field \texttt{field\_name} has been
      updated to \texttt{v};
    \item \texttt{new\_env} is \texttt{env} where \texttt{le\_record} is bound to
      \texttt{new\_v\_record}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LESetField.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESetField.asl}
    \texttt{my\_record.a = 42;} binds \texttt{my\_record} to \texttt{\{a: 42, b: 42\}} in the environment where \texttt{my\_record} is bound to \texttt{\{a: 3, b: 42\}}.

  \subsection{Code}
  \VerbatimInput[firstline=\LESetFieldBegin, lastline=\LESetFieldEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LEDestructuring \label{sec:SemanticsRule.LEDestructuring}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a list of left-hand-side expressions \texttt{le\_list};
    \item \texttt{new\_env} is \texttt{env} where each left-hand-side expression in \texttt{le\_list} has
      been assigned the value at the corresponding index in \texttt{v}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LEDestructuring.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEDestructuring.asl}
    \texttt{(x, y) = (3, 42)} binds \texttt{x} to \texttt{3} and \texttt{y} to \texttt{42} in the environment where \texttt{x} is bound to \texttt{42} and \texttt{y} is bound to \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\LEDestructuringBegin, lastline=\LEDestructuringEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Evaluation of Slices \label{chap:eval_slices}}
\texttt{eval\_slices env slices} is the list of pair \texttt{(start\_n, length\_n)} that
corresponds to the start (included) and the length of each slice in
\texttt{slices}.

Evaluation of the slice \texttt{s} under environment \texttt{env} is
\texttt{((start, length), new\_env)}, or an error, and one of the following applies:
\begin{itemize}
\item SemanticsRule.SliceSingle (see Section~\ref{sec:SemanticsRule.SliceSingle}),
\item SemanticsRule.SliceLength (see Section~\ref{sec:SemanticsRule.SliceLength}),
\item SemanticsRule.SliceRange (see Section~\ref{sec:SemanticsRule.SliceRange}),
\item SemanticsRule.SliceStar (see Section~\ref{sec:SemanticsRule.SliceStar}).
\end{itemize}

\section{SemanticsRule.SliceSingle \label{sec:SemanticsRule.SliceSingle}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all
of the following apply:
  \begin{itemize}
    \item \texttt{s} is the single expression \texttt{e};
    \item \texttt{start} is the result of evaluation of the expression~\texttt{e}
      in the environment \texttt{env};
    \item \texttt{new\_env} is the environment \texttt{env} modified after
      evaluation of the expression~\texttt{e};
    \item \texttt{length} is the integer value 1.
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceSingle.asl}
  In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceSingle.asl}
  the slice \texttt{[2]} evaluates to \texttt{(2, 1)}, i.\,e.\ the slice of
  length 1 starting at index 2.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceSingleBegin, lastline=\SliceSingleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceLength \label{sec:SemanticsRule.SliceLength}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all of the following
apply:
  \begin{itemize}
    \item \texttt{s} is the slice which starts at expression~\texttt{e\_start} with length~\texttt{e\_length};
    \item \texttt{start} is the result of evaluation of the
      expression~\texttt{e\_start} in the environment \texttt{env};
    \item \texttt{env\_1} is the environment \texttt{env} modified after
      evaluation of the expression~\texttt{e\_start};
    \item \texttt{length} is the result of evaluation of the
      expression~\texttt{e\_length} in the environment \texttt{env\_1};
    \item \texttt{new\_env} is the environment \texttt{env\_1} modified after
      evaluation of the expression~\texttt{e\_length}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceLength.asl}
  In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceLength.asl}
  \texttt{2+:3} evaluates to \texttt{(2, 3)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceLengthBegin, lastline=\SliceLengthEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceRange \label{sec:SemanticsRule.SliceRange}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all of the following apply:
  \begin{itemize}
    \item \texttt{s} is the slice range between the
      expressions~\texttt{e\_start} and~\texttt{e\_top};
    \item \texttt{v\_top} is the result of evaluation of the
      expression~\texttt{e\_top} in the environment \texttt{env};
    \item \texttt{env\_1} is the environment \texttt{env} modified after
      evaluation of the expression~\texttt{e\_top};
    \item \texttt{start} is the result of evaluation of the
      expression~\texttt{e\_start} in the environment \texttt{env\_1};
    \item \texttt{new\_env} is the environment \texttt{env\_1} modified after
      evaluation of the expression~\texttt{e\_start};
    \item \texttt{length} is the integer value \texttt{(vtop - start) + 1};
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceRange.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceRange.asl}
  \texttt{4:2} evaluates to \texttt{(2, 3)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceRangeBegin, lastline=\SliceRangeEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceStar \label{sec:SemanticsRule.SliceStar}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all of the following
apply:
  \begin{itemize}
    \item \texttt{s} is the slice with factor given by the
      expression~\texttt{e\_factor} and length given by the
      expression~\texttt{e\_length};
    \item \texttt{v\_factor} is the result of evaluation of the
      expression~\texttt{e\_factor} in the environment \texttt{env};
    \item \texttt{env\_1} is the environment \texttt{env} modified after
      evaluation of the expression~\texttt{e\_factor};
    \item \texttt{length} is the result of evaluation of the
      expression~\texttt{e\_length} in the environment \texttt{env\_1};
    \item \texttt{new\_env} is the environment \texttt{env\_1} modified after
      evaluation of the expression~\texttt{e\_length};
    \item \texttt{start} is the integer value
      $\texttt{v\_factor} \times \texttt{length}$.
  \end{itemize}


  \subsection{Example: SemanticsRule.SliceStar.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceStar.asl}
  \texttt{x[2*:3]} evaluates to \texttt{(6, 2)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceStarBegin, lastline=\SliceStarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Evaluation of Patterns \label{chap:eval_pattern}}
\texttt{eval\_pattern env pos v p} determines if \texttt{v} matches the pattern \texttt{p}.

Evaluation of the pattern \texttt{p} under environment \texttt{env} with
respect to value \texttt{v} is \texttt{b}, or an error, and one of the
following applies:
\begin{itemize}
\item SemanticsRule.PAll (see Section~\ref{sec:SemanticsRule.PAll})
\item SemanticsRule.PAny (see Section~\ref{sec:SemanticsRule.PAny})
\item SemanticsRule.PGeq (see Section~\ref{sec:SemanticsRule.PGeq})
\item SemanticsRule.PLeq (see Section~\ref{sec:SemanticsRule.PLeq})
\item SemanticsRule.PNot (see Section~\ref{sec:SemanticsRule.PNot})
\item SemanticsRule.PRange (see Section~\ref{sec:SemanticsRule.PRange})
\item SemanticsRule.PSingle (see Section~\ref{sec:SemanticsRule.PSingle})
\item SemanticsRule.PMask (see Section~\ref{sec:SemanticsRule.PMask})
\item SemanticsRule.PTuple (see Section~\ref{sec:SemanticsRule.PTuple})
\end{itemize}

\section{SemanticsRule.PAll \label{sec:SemanticsRule.PAll}}

  \subsection{Prose}
  Evaluation of the pattern \texttt{p} under environment \texttt{env} with
  respect to value \texttt{v} is \texttt{b} and all of the following apply:
  \begin{itemize}
    \item \texttt{p} is the pattern which matches everything, and therefore
      matches \texttt{v};
    \item \texttt{b} is the boolean value \texttt{true}.
  \end{itemize}

  \subsection{Example: SemanticsRule.PAll.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAll.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PAllBegin, lastline=\PAllEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PAny \label{sec:SemanticsRule.PAny}}

    \subsection{Prose}
  Evaluation of the pattern \texttt{p} under environment \texttt{env} with
  respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is a list of patterns \texttt{ps};
      \item \texttt{bs} is the list resulting of the evaluation of the patterns in \texttt{ps} under environment \texttt{env} with respect to value \texttt{v};
      \item \texttt{b} is the disjunction of the values in \texttt{bs}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PAnyTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAnyTRUE.asl}

    \subsection{Example: SemanticsRule.PAnyFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAnyFALSE.asl}

    \subsection{Code}
    \VerbatimInput[firstline=\PAnyBegin, lastline=\PAnyEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally: sequential case}

    \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PGeq \label{sec:SemanticsRule.PGeq}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the condition corresponding to being greater or equal
        than the side-effect-free expression \texttt{e};
      \item \texttt{v'} is the side-effect-free evaluation of \texttt{e} in
        \texttt{env};
      \item \texttt{b} is the boolean value corresponding to whether \texttt{v}
        is greater or equal to \texttt{v'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PGeqTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PGeqTRUE.asl}

    \subsection{Example: SemanticsRule.PGeqFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PGeqFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PGeqBegin, lastline=\PGeqEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PLeq \label{sec:SemanticsRule.PLeq}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the condition corresponding to being less or equal
        than the side-effect-free expression \texttt{e};
      \item \texttt{v'} is the side-effect-free evaluation of \texttt{e} in
        \texttt{env};
      \item \texttt{b} is the boolean value corresponding to whether \texttt{v}
        is less or equal to \texttt{v'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PLeqTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PLeqTRUE.asl}

    \subsection{Example: SemanticsRule.PLeqFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PLeqFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PLeqBegin, lastline=\PLeqEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PNot \label{sec:SemanticsRule.PNot}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the negation of the pattern \texttt{p'};
      \item \texttt{b'} is the result of the evaluation of the pattern
        \texttt{p'} under environment \texttt{env} with respect to the value
        \texttt{v};
      \item \texttt{b} is the boolean negation of \texttt{b'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PNotTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PNotTRUE.asl}

    \subsection{Example: SemanticsRule.PNotFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PNotFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PNotBegin, lastline=\PNotEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PRange \label{sec:SemanticsRule.PRange}}

    \subsection{Prose}
  Evaluation of the pattern \texttt{p} under environment \texttt{env} with
  respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the condition corresponding to being greater or equal
        to \texttt{e1}, and lesser or equal to \texttt{e2};
      \item \texttt{e1} and \texttt{e2} are side-effect-free expressions;
      \item \texttt{v1} is the side-effect-free evaluation of \texttt{e1} in
        \texttt{env};
      \item \texttt{v2} is the side-effect-free evaluation of \texttt{e2} in
        \texttt{env};
      \item \texttt{b1} is the boolean value corresponding to whether
        \texttt{v} is greater or equal to \texttt{v1}.
      \item \texttt{b2} is the boolean value corresponding to whether
        \texttt{v} is less or equal to \texttt{v2}.
      \item \texttt{b} is the boolean conjunction of \texttt{b1} and
        \texttt{b2}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PRangeTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PRangeTRUE.asl}

    \subsection{Example: SemanticsRule.PRangeFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PRangeFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PRangeBegin, lastline=\PRangeEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PSingle \label{sec:SemanticsRule.PSingle}}

    \subsection{Prose}
  Evaluation of the pattern \texttt{p} under environment \texttt{env} with
  respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the condition corresponding to being equal to the
        side-effect-free expression \texttt{e};
      \item \texttt{v'} is the side-effect-free evaluation of \texttt{e} in
        environment \texttt{env};
      \item \texttt{b} is the boolean value corresponding to whether \texttt{v}
        is equal to \texttt{v'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PSingleTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PSingleTRUE.asl}

    \subsection{Example: SemanticsRule.PSingleFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PSingleFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PSingleBegin, lastline=\PSingleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PMask \label{sec:SemanticsRule.PMask}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is a mask \texttt{m} of length $n$ (with spaces removed);
      \item \texttt{m\_set} is the bitvector value of length $n$ with bit set
        at index $i$ if the mask requires a bit set at index $i$, i.\,e.\
        $\texttt{m}[i] = '1'$;
      \item \texttt{m\_unset} is the bitvector value of length $n$ with bit set
        at index $i$ if the mask requires a bit unset at index $i$, i.\,e.\
        $\texttt{m}[i] = '0'$;
      \item \texttt{m\_specified} is the bitwise disjunction of \texttt{m\_set}
        and \texttt{m\_unset};
      \item \texttt{nv} is the bitwise negation of \texttt{v};
      \item \texttt{v\_set} is the bitwise conjunction of \texttt{m\_set} and
        \texttt{v};
      \item \texttt{v\_unset} is the bitwise conjunction of \texttt{m\_unset} and
        \texttt{nv};
      \item \texttt{v\_set\_or\_unset} is the bitwise disjunction of
        \texttt{v\_set} and \texttt{v\_unset};
      \item \texttt{b} is the boolean value of the bitwise equality of
        \texttt{v\_set\_or\_unset} and \texttt{m\_specified}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PMaskTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PMaskTRUE.asl}

    \subsection{Example: SemanticsRule.PMaskFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PMaskFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PMaskBegin, lastline=\PMaskEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PTuple \label{sec:SemanticsRule.PTuple}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} gives a list of patterns \texttt{ps} of length $n$;
      \item \texttt{v} gives a tuple of values \texttt{vs} of length $n$;
      \item for all $1 \leq i \leq n$, $\texttt{b}_i$ is the evaluation result
        of $\texttt{p}_i$ with respect to the value $\texttt{v}_i$ in
        environment \texttt{env};
      \item \texttt{bs} is the list of all $\texttt{b}_i$ for $1 \leq i \leq n$;
      \item \texttt{b} is the conjunction of the boolean values of \texttt{bs}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PTupleTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PTupleTRUE.asl}

    \subsection{Example: SemanticsRule.PTupleFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PTupleFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PTupleBegin, lastline=\PTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Evaluation of Local Declarations \label{chap:eval_local_decl}}

\texttt{eval\_local\_decl ldi env m\_init\_opt} declares local variables
\texttt{ldi} in \texttt{env} with an optional initialisation value
\texttt{m\_init\_opt}.  Evaluation of the local variables \texttt{ldi}
under an environment \texttt{env} is either \texttt{new\_env} or raises an
error and one of the following applies:
\begin{itemize}
\item SemanticsRule.LDDiscard (see Section~\ref{sec:SemanticsRule.LDDiscard},
\item SemanticsRule.LDVar (see Section~\ref{sec:SemanticsRule.LDVar},
\item SemanticsRule.LDTypedVar (see Section~\ref{sec:SemanticsRule.LDTypedVar},
\item SemanticsRule.LDTuple (see Section~\ref{sec:SemanticsRule.LDTuple},
\item SemanticsRule.LDTypedTuple (see Section~\ref{sec:SemanticsRule.LDTypedTuple},
\item SemanticsRule.LDUninitialisedTuple (see Section~\ref{sec:SemanticsRule.LDUninitialisedTuple}.
\end{itemize}

\section{SemanticsRule.LDDiscard \label{sec:SemanticsRule.LDDiscard}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} indicates that the initialisation value will be discarded;
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDDiscard.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDDiscard.asl}
    \texttt{var - : integer;} does not modify the environment.

  \subsection{Code}
  \VerbatimInput[firstline=\LDDiscardBegin, lastline=\LDDiscardEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDVar \label{sec:SemanticsRule.LDVar}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} is a variable \texttt{x};
    \item \texttt{m\_init\_opt} is a value \texttt{m};
    \item \texttt{new\_env} is \texttt{env} modified to declare \texttt{x} as a
local variable bound to value \texttt{m}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDVar0.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDVar0.asl}
    \texttt{var x = 3;} binds \texttt{x} to the evaluation of \texttt{3} in \texttt{env}.

    \subsection{Example: SemanticsRule.LDVar1.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDVar1.asl}
    \texttt{var x : integer = 3;} binds \texttt{x} to the evaluation of
\texttt{3} in \texttt{env}, without type consideration at runtime.

  \subsection{Code}
  \VerbatimInput[firstline=\LDVarBegin, lastline=\LDVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDTypedVar \label{sec:SemanticsRule.LDTypedVar}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} is a variable \texttt{x} of type \texttt{ty};
    \item \texttt{m\_init\_opt} is \texttt{None};
    \item \texttt{new\_env} is \texttt{env} modified to declare \texttt{x} as a local variable bound to
      the base value of \texttt{ty}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDTypedVar.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDTypedVar.asl}
    \texttt{var x : integer;} binds \texttt{x} in \texttt{env} to the base value of \texttt{integer}.

  \subsection{Code}
  \VerbatimInput[firstline=\LDTypedVarBegin, lastline=\LDTypedVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDTuple \label{sec:SemanticsRule.LDTuple}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} gives a list of local variables \texttt{ldis};
    \item \texttt{m\_init\_opt} is a list of values \texttt{liv};
    \item \texttt{new\_env} is \texttt{env} modified to declare each element of \texttt{ldis} to be bound
      to the corresponding value in \texttt{liv}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDTuple.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDTuple.asl}
    \texttt{var (x,y,z) = (1,2,3);} binds \texttt{x} (resp. \texttt{y}, \texttt{z}) to the evaluation of
    \texttt{1} (resp. \texttt{2}, \texttt{3}) in \texttt{env}.

  \subsection{Code}
  \VerbatimInput[firstline=\LDTupleBegin, lastline=\LDTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDTypedTuple \label{sec:SemanticsRule.LDTypedTuple}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} gives a list of local variables \texttt{ldis} and a type \texttt{ty};
    \item \texttt{m\_init\_opt} is \texttt{None};
    \item \texttt{new\_env} is \texttt{env} modified to declare each element of \texttt{ldis} with type \texttt{ty}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDTypedTuple.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDTypedTuple.asl}
    \texttt{var (x,y,z) : integer;} binds \texttt{x}, \texttt{y} and \texttt{z} in \texttt{env} to the base value
    of \texttt{integer}.

  \subsection{Code}
  \VerbatimInput[firstline=\LDTypedTupleBegin, lastline=\LDTypedTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDUninitialisedTuple \label{sec:SemanticsRule.LDUninitialisedTuple}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} gives a list of local variables \texttt{ldis};
    \item \texttt{new\_env} is \texttt{env} modified to declare each element of \texttt{ldis}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDUninitalisedTuple.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDUninitialisedTuple.asl}
   \texttt{var (x : integer, y : boolean);} binds \texttt{x} to the base value of \texttt{integer}
    and \texttt{y} to the base value of \texttt{boolean}.

  \subsection{Code}
  \VerbatimInput[firstline=\LDUninitialisedTupleBegin, lastline=\LDUninitialisedTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Evaluation of Statements \label{chap:eval_stmt}}
Evaluation \texttt{eval\_stmt env s} of a statement \texttt{s} under
environment \texttt{env} is either a \texttt{Throwing}, an interruption
\texttt{Returning vs} or a new environment \texttt{new\_env}. Formally, one of
the following applies:
\begin{itemize}
\item SemanticsRule.SPass (see Section~\ref{sec:SemanticsRule.SPass}),
\item SemanticsRule.SAssign (see Section~\ref{sec:SemanticsRule.SAssign}),
\item SemanticsRule.SAssignCall (see Section~\ref{sec:SemanticsRule.SAssignCall}),
\item SemanticsRule.SAssignTuple (see Section~\ref{sec:SemanticsRule.SAssignTuple}),
\item SemanticsRule.SReturnNone (see Section~\ref{sec:SemanticsRule.SReturnNone}),
\item SemanticsRule.SReturnOne (see Section~\ref{sec:SemanticsRule.SReturnOne}),
\item SemanticsRule.SReturnSome (see Section~\ref{sec:SemanticsRule.SReturnSome}),
\item SemanticsRule.SSeq (see Section~\ref{sec:SemanticsRule.SSeq}),
\item SemanticsRule.SCall (see Section~\ref{sec:SemanticsRule.SCall}),
\item SemanticsRule.SCond (see Section~\ref{sec:SemanticsRule.SCond}),
\item SemanticsRule.SCase (see Section~\ref{sec:SemanticsRule.SCase}),
\item SemanticsRule.SAssert (see Section~\ref{sec:SemanticsRule.SAssert}),
\item SemanticsRule.SWhile (see Section~\ref{sec:SemanticsRule.SWhile}),
\item SemanticsRule.SRepeat (see Section~\ref{sec:SemanticsRule.SRepeat}),
\item SemanticsRule.SFor (see Section~\ref{sec:SemanticsRule.SFor}),
\item SemanticsRule.SThrowNone (see Section~\ref{sec:SemanticsRule.SThrowNone}),
\item SemanticsRule.SThrowSomeTyped (see Section~\ref{sec:SemanticsRule.SThrowSomeTyped}),
\item SemanticsRule.STry (see Section~\ref{sec:SemanticsRule.STry}),
\item SemanticsRule.SDeclSome (see Section~\ref{sec:SemanticsRule.SDeclSome}),
\item SemanticsRule.SDeclNone (see Section~\ref{sec:SemanticsRule.SDeclNone}).
\end{itemize}

\section{SemanticsRule.SPass \label{sec:SemanticsRule.SPass}}

  \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} is a \texttt{pass} statement;
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SPass.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SPass.asl}
  \texttt{pass;} does nothing.

  \subsection{Code}
  \VerbatimInput[firstline=\SPassBegin, lastline=\SPassEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  \begin{align}
  \interp{\syntt{pass}} (\texttt{env}) & \triangleq \{ (\bot, \texttt{env}) \}
  \label{eq:sem-seq-spass}
\end{align}

  \subsection{Formally: concurrent case}
  \begin{align}
  \interp{\syntt{pass}} (\texttt{env}) & \triangleq \{ (\bot, \texttt{env}, \varnothing) \}
  \label{eq:sem-conc-spass}
  \end{align}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssign \label{sec:SemanticsRule.SAssign}}

  \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} is an assignment \texttt{le = re};
  \item \texttt{v} is the evaluation of the expression \texttt{re} under \texttt{env} as per Chapter~\ref{chap:eval_expr};
  \item \texttt{r\_env} is \texttt{env} modified after evaluation of the expression \texttt{re} under \texttt{env} as per Chapter~\ref{chap:eval_expr};
  \item \texttt{new\_env} is \texttt{r\_env} modified after evaluation of \texttt{le} under \texttt{r\_env} with
    \texttt{v}, as per Chapter~\ref{chap:eval_lexpr}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SAssign.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssign.asl}
  \texttt{x = 3;} binds \texttt{x} to \texttt{3} in the environment where \texttt{x} is bound to \texttt{42}, and \texttt{new\_env} is such that \texttt{x} is bound to \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\SAssignBegin, lastline=\SAssignEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  \begin{align}
    \interp{\texttt{le = re}} (\texttt{env}) \triangleq
      \left\{ \left(\bot, \texttt{env'}[\texttt{le} \mapsto \texttt{v} ]\right) \st{} (\texttt{v}, \texttt{env'}) \in \interp{\texttt{re}} (\texttt{env}) \right\}
    \label{eq:sem-seq-sassign}
  \end{align}

  \subsection{Formally: concurrent case}
  \begin{align}
    \interp{\texttt{le = re}} (\texttt{env}) \triangleq
      \left\{ \left(\bot, \texttt{env'}[\texttt{le} \mapsto \texttt{v} ], S \xrightarrow{\asldata} \texttt{W(le)}\right) \st{}
        (\texttt{v}, \texttt{env'}, S) \in \interp{\texttt{re}} (\texttt{E})
      \right\}
    \label{eq:sem-conc-sassign}
  \end{align}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssignCall \label{sec:SemanticsRule.SAssignCall}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} gives a left-hand-side tuple expression \texttt{les} and a subprogram call \texttt{(name, args, named\_args)};
  \item \texttt{vs} is the list of values resulting from the evaluation of the subprogram call;
  \item \texttt{env'} is the environment resulting from modifying \texttt{env} after the evaluation of the subprogram call;
  \item \texttt{new\_env} is the result of modifying \texttt{env'} after assigning each values in \texttt{vs} to the elements of the tuple \texttt{les}.
  \end{itemize}

    \subsection{Example: SemanticsRule.SAssignCall.asl}

\VerbatimInput{\testdir/SemanticsRule.SAssignCall.asl}
  given that the function call \texttt{f(1)} returns the pair of values \texttt{(1,2)}, statement \texttt{(a,b) = f(1)} assigns the value \texttt{1} to the mutable variable \texttt{a} and the value \texttt{2} to the mutable variable~\texttt{b}.
  \subsection{Code}
  \VerbatimInput[firstline=\SAssignCallBegin, lastline=\SAssignCallEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssignTuple \label{sec:SemanticsRule.SAssignTuple}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} gives a left-hand-side tuple expression \texttt{les} and a tuple expression \texttt{exprs};
  \item \texttt{vs} is the list of values resulting from the evaluation of \texttt{exprs};
  \item \texttt{env'} is the environment resulting from modifying \texttt{env} after the evaluation of \texttt{exprs};
  \item \texttt{new\_env} is the result of modifying \texttt{env'} after assigning each values in \texttt{vs} to the elements of the tuple \texttt{les}.
  \end{itemize}

    \subsection{Example: SemanticsRule.SAssignTuple.asl}
\VerbatimInput{\testdir/SemanticsRule.SAssignTuple.asl}
statement \texttt{(b,x)} assigns the value \texttt{TRUE} to the mutable variable \texttt{b} and the value~\texttt{42} to the mutable variable~\texttt{x}.

  \subsection{Code}
  \VerbatimInput[firstline=\SAssignTupleBegin, lastline=\SAssignTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnNone \label{sec:SemanticsRule.SReturnNone}}

    \subsection{Prose}
Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{Returning vs} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{return} statement;
    \item \texttt{vs} is \texttt{[]};
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

    \subsection{Example: SReturnNoneReturn.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnNone.asl}
    exits the current procedure.

  \subsection{Code}
  \VerbatimInput[firstline=\SReturnNoneBegin, lastline=\SReturnNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnOne \label{sec:SemanticsRule.SReturnOne}}

    \subsection{Prose}
Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{Returning vs} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{return} statement;
    \item \texttt{s} gives an expression \texttt{e};
    \item \texttt{v} is the evaluation of \texttt{e} under \texttt{env};
    \item \texttt{vs} is \texttt{[v]};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the expression \texttt{e} under \texttt{env} as per Chapter~\ref{chap:eval_expr}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SReturnOne.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnOne.asl}
    \texttt{return 3;} exits the current subprogram with value \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\SReturnOneBegin, lastline=\SReturnOneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnSome \label{sec:SemanticsRule.SReturnSome}}

    \subsection{Prose}
Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{Returning vs} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{return} statement;
    \item \texttt{s} gives a list of expressions \texttt{es};
    \item \texttt{vs} is the result of the evaluation of each element of the list \texttt{es} under \texttt{env} as per Chapter~\ref{chap:eval_expr};
    \item \texttt{new\_env} is \texttt{env} modified after the evaluation of each element of the list \texttt{es} under \texttt{env} as per Chapter~\ref{chap:eval_expr}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SReturnSome.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnSome.asl}
    \texttt{return (3, 42);} exits the current subprogram with value \texttt{(3, 42)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SReturnSomeBegin, lastline=\SReturnSomeEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  \begin{align}
  \interp{\syntt{return}\ e} (E) & \triangleq \interp{e} (E)
  \label{eq:sem-seq-sreturn}
  \end{align}

  \subsection{Formally: concurrent case}
  \begin{align}
  \interp{\syntt{return}\ e} (E) & \triangleq \interp{e} (E)
  \label{eq:sem-conc-sreturn}
  \end{align}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SSeq \label{sec:SemanticsRule.SSeq}}

  \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} is a sequence statement \texttt{s1; s2};
  \item \texttt{env'} is \texttt{env} modified after evaluation of \texttt{s1};
  \item \texttt{new\_env} is \texttt{env'} modified after evaluation of \texttt{s2}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SSeq.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SSeq.asl}
  \texttt{let x = 3; let y = x + 1} evaluates \texttt{let x = 3} then \texttt{let y = x + 1}.

  \subsection{Code}
  \VerbatimInput[firstline=\SSeqBegin, lastline=\SSeqEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  The semantics of~\texttt{s1; s2} is the semantics of~\texttt{s2} applied to the results
  of the semantics of~\texttt{s1} if they do not perform an early return, in which
  case it is the semantics of~\texttt{s1}.
  \begin{align}
    \interp{\texttt{s1; s2}} (\texttt{env}) \triangleq
      \left\{ (\texttt{v?}, \texttt{new\_env}) \st{}
      \begin{aligned}
        & (\texttt{v}, \texttt{new\_env}) \in \interp{\texttt{s1}} (\texttt{env})
        \\ \text{or}\ &
        \left(
        \begin{aligned}
            & (\bot{}, \texttt{env'}) \in \interp{\texttt{s1}} (\texttt{env})
            \\ \text{and}\ &
            (\texttt{v?}, \texttt{new\_env}) \in \interp{\texttt{s2}} (\texttt{env'})
        \end{aligned}
        \right)
      \end{aligned}
      \right\}
    \label{eq:sem-seq-sseq}
  \end{align}

  \subsection{Formally: concurrent case}
  The evaluation of two statements introduces an $\aslpo$ arrow between the two
graphs produced by their interpretations:
  \begin{align}
    \interp{\texttt{s1; s2}} (\texttt{env}) \triangleq
      \left\{ (\texttt{v?}, \texttt{new\_env}, S) \st{}
      \begin{aligned}
        & (\texttt{v}, \texttt{new\_env}, S) \in \interp{\texttt{s1}} (\texttt{env})
        \\ \text{or}\ &
        \left(
        \begin{aligned}
            & (\bot{}, \texttt{env'}, S') \in \interp{\texttt{s1}} (\texttt{env})
            \\ \text{and}\ &
            (v, \texttt{new\_env}, S'') \in \interp{\texttt{s2}} (\texttt{env'})
            \\ \text{and}\ &
            S = S' \xrightarrow{\aslpo} S''
        \end{aligned}
        \right)
      \end{aligned}
      \right\}
    \label{eq:sem-conc-sseq}
  \end{align}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCall \label{sec:SemanticsRule.SCall}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a call statement;
    \item \texttt{s} gives a subprogram name \texttt{name} with actual arguments \texttt{actual\_args};
    \item \texttt{env'} is \texttt{env} modified after evaluation of the subprogram call;
    \item \texttt{new\_env} is \texttt{env'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCall.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCall.asl}
    \texttt{Zeros(3)} evaluates to \texttt{'000'}.

  \subsection{Code}
  \VerbatimInput[firstline=\SCallBegin, lastline=\SCallEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCond \label{sec:SemanticsRule.SCond}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} gives a condition \texttt{cond} and two conditional blocks \texttt{s1} and \texttt{s2};
    \item \texttt{v\_cond} is the evaluation of \texttt{cond};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of \texttt{s1} or \texttt{s2} depending on
      \texttt{v\_cond}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCond.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCond.asl}
    does not raise any Assertion Error.

  \subsection{Code}
  \VerbatimInput[firstline=\SCondBegin, lastline=\SCondEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  The semantics of a conditional statement $\ife{e}{s_1}{s_2}$ chooses between
  the semantics of~$s_1$ or $s_2$ depending on the evaluation of $e$:
  \begin{align}
    \interp{\begin{array}{l}
      \syntt{if}\ e\\
      \syntt{then}\ s_1\\
      \syntt{else}\ s_2\ \syntt{end}
    \end{array}} (E) \triangleq
    % \interp{\ife{e}{s_1}{s_2}} (E) & \triangleq
      \left\{ (v?, E'') \st{} \
      \begin{aligned}
        & (b, E') \in \interp{e} (E)
        \\ \text{and}\ &
        \left( \begin{aligned}
          & \left(b = \syntt{true} \ \text{and} \ s' = s_1 \right)
          \\ \text{or}\ &
          \left( b = \syntt{false} \ \text{and}\ s' = s_2 \right)
        \end{aligned} \right)
        \\ \text{and}\ &
        (v?, E'') \in \interp{s'} (E')
      \end{aligned}
      \right\}
    \label{eq:sem-seq-scond}
  \end{align}

  \subsection{Formally: concurrent case}
  A conditional statement introduces control dependencies $\aslctrl$ between its
  condition and its body:
  \begin{align}
    \interp{\begin{array}{l}
      \syntt{if}\ e\\
      \syntt{then}\ s_1\\
      \syntt{else}\ s_2\ \syntt{end}
    \end{array}} (E) \triangleq
      \left\{ (v, E'', S'') \st{} \
      \begin{aligned}
        & (b, E', S) \in \interp{e} (E)
        \\ \text{and}\ &
        \left( \begin{aligned}
          & \left(b = \syntt{true}\ \text{and}\ s' = s_1 \right)
          \\ \text{or}\ &
          \left( b = \syntt{false}\ \text{and}\ s' = s_2 \right)
        \end{aligned} \right)
        \\ \text{and}\ &
        (v, E'', S') \in \interp{s'} (E')
        \\ \text{and}\ &
        S'' = S \xrightarrow{\aslctrl} S'
      \end{aligned}
      \right\}
    \label{eq:sem-conc-scond}
  \end{align}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCase \label{sec:SemanticsRule.SCase}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} gives a condition \texttt{cond} and a number of statements \texttt{s\_1}, $\cdots$, \texttt{s\_n};
    \item \texttt{v\_cond} is the evaluation of \texttt{cond};
    \item \texttt{new\_env} is \texttt{env'} modified after evaluation of one of the statements \texttt{s\_i} depending on \texttt{v\_cond}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCase.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCase.asl}
    uses the second \texttt{when} clause because \texttt{3} is less than \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\SCaseBegin, lastline=\SCaseEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssert \label{sec:SemanticsRule.SAssert}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} or an error and all of the following apply:
    All of the following apply:
    \begin{itemize}
    \item \texttt{s} is an \texttt{assert} statement;
    \item \texttt{s} gives an expression \texttt{e};
    \item \texttt{v} is the evaluation of the expression \texttt{e} as per Chapter~\ref{chap:eval_expr};
    \item One of the following applies:
          \begin{itemize}
          \item \texttt{v} is \texttt{true} and \texttt{new\_env} is \texttt{env},
          \item an ``AssertionFailed'' error is raised.
          \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.SAssertOk.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssertOk.asl}
    \texttt{assert (42 != 3);} ensures that \texttt{3} is not equal to \texttt{42}.

    \subsection{Example: SemanticsRule.SAssertNo.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssertNo.asl}
    \texttt{assert (42 == 3);} raises an ``\texttt{AssertionFailed}'' error.

  \subsection{Code}
  \VerbatimInput[firstline=\SAssertBegin, lastline=\SAssertEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SWhile \label{sec:SemanticsRule.SWhile}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{while} statement;
    \item \texttt{s} gives an expression \texttt{e} and a loop body \texttt{body};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the loop \texttt{(e,body)} as per Section~\ref{sec:SemanticsRule.Loop}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SWhile.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SWhile.asl}
    prints ``\texttt{0123}''.

  \subsection{Code}
  \VerbatimInput[firstline=\SWhileBegin, lastline=\SWhileEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SRepeat \label{sec:SemanticsRule.SRepeat}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{repeat} statement;
    \item \texttt{s} gives an expression \texttt{e} and a loop body \texttt{body};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the loop \texttt{(e,body)} as per Section~\ref{sec:SemanticsRule.Loop}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SRepeat.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SRepeat.asl}
    prints ``\texttt{0123}''.

  \subsection{Code}
  \VerbatimInput[firstline=\SRepeatBegin, lastline=\SRepeatEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SFor \label{sec:SemanticsRule.SFor}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{for} statement;
    \item \texttt{s} gives \texttt{(id,e1,dir,e2,s)};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the \texttt{for} loop \texttt{(id,e1,dir,e2,s)} as per Section~\ref{sec:SemanticsRule.For}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SFor.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SFor.asl}
    prints ``\texttt{0123}''.

  \subsection{Code}
  \VerbatimInput[firstline=\SForBegin, lastline=\SForEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SThrowNone \label{sec:SemanticsRule.SThrowNone}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{throw} statement which gives no expression;
    \item \texttt{new\_env} is \texttt{env};
    \item an exception is thrown with \texttt{new\_env}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SThrowNone.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SThrowNone.asl}
    throws a ``\texttt{MyException}'' exception.

  \subsection{Code}
  \VerbatimInput[firstline=\SThrowNoneBegin, lastline=\SThrowNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SThrowSomeTyped \label{sec:SemanticsRule.SThrowSomeTyped}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{throw} statement which gives an expression \texttt{e} and a type \texttt{t};
    \item \texttt{v} is the result of evaluating the expression \texttt{e} in \texttt{env};
    \item \texttt{new\_env} is the environment modified after evaluating the expression \texttt{e} in \texttt{env};
    \item an exception is thrown with \texttt{v} and \texttt{new\_env}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SThrowSomeTyped.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SThrowSomeTyped.asl}
    throws a ``\texttt{MyException \{a: 3, b: 42\}}'' exception.

  \subsection{Code}
  \VerbatimInput[firstline=\SThrowSomeTypedBegin, lastline=\SThrowSomeTypedEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.STry \label{sec:SemanticsRule.STry}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{try} statement \texttt{[(s', catchers, otherwise\_opt)};
    \item \texttt{s\_m} is the evaluation of the block \texttt{s'} under \texttt{env};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the catchers \texttt{(catchers
      otherwise\_opt s\_m)} as per Chapter~\ref{chap:eval_catchers}.
    \end{itemize}

    \subsection{Example: SemanticsRule.STry.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.STry.asl}
    does not raise any Assertion error, and the program terminates with the exit code 0.

  \subsection{Code}
  \VerbatimInput[firstline=\STryBegin, lastline=\STryEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SDeclSome \label{sec:SemanticsRule.SDeclSome}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a declaration \texttt{(ldi, Some e)};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the local declaration
      \texttt{ldi env (Some m)} as per Chapter~\ref{chap:eval_local_decl}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SDeclSome.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SDeclSome.asl}
    \texttt{let x = 3;} binds \texttt{x} to \texttt{3} in the empty environment.

  \subsection{Code}
  \VerbatimInput[firstline=\SDeclSomeBegin, lastline=\SDeclSomeEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SDeclNone \label{sec:SemanticsRule.SDeclNone}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a declaration \texttt{(ldi, None)};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the local declaration
      \texttt{ldi env None} as per Chapter~\ref{chap:eval_local_decl}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SDeclNone.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SDeclNone.asl}
    \texttt{var x : integer;} binds \texttt{x} in \texttt{env} to the base value of \texttt{integer}.

  \subsection{Code}
  \VerbatimInput[firstline=\SDeclNoneBegin, lastline=\SDeclNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Evaluation of Blocks \label{chap:eval_block}}

\section{SemanticsRule.Block \label{sec:SemanticsRule.Block}}

    \subsection{Prose}
    \texttt{eval\_block env stm} is \texttt{new\_env} and all of the following applies:
    \begin{itemize}
    \item \texttt{block\_env'} is \texttt{env} modified after the evaluation of the statement \texttt{stm} as per Chapter~\ref{chap:eval_stmt};
    \item \texttt{new\_env} is \texttt{block\_env'} after restoring the
variable bindings of \texttt{env} with the updated values of
\texttt{block\_env'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.Block.asl}
    In the program:
    \VerbatimInput{\testdir/SemanticsRule.Block.asl}
    the conditional statement \texttt{if TRUE then\ldots{} end;} defines a
block structure. Thus, the scope of the declaration \texttt{let y = 2;} is
limited to its declaring block---or the binding for \texttt{y} no longer exists
once the block is exited. As a consequence, the subsequent declaration
\texttt{let y = 1} is valid.  By contrast, the assigment of the mutable
variable~\texttt{x} persists after block end. However, observe that \texttt{x}
is defined before the block and hence still exists after the block.

  \subsection{Code}
    \VerbatimInput[firstline=\BlockBegin,lastline=\BlockEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Evaluation of Loops \label{chap:eval_loops}}

The evaluation of loop is a common part of the evaluation of multiple loop
statements.
%
For example, the semantic rule \emph{Loop} is used by the semantic rule
\emph{SWhile} at Section~\ref{sec:SemanticsRule.SWhile} and the semantic rule
\emph{SRepeat} at Section~\ref{sec:SemanticsRule.SRepeat}.
%
The semantic rule \emph{For} is only used by the semantic rule \emph{SFor} at
Section~\ref{sec:SemanticsRule.SFor}.

\section{SemanticsRule.Loop \label{sec:SemanticsRule.Loop}}
\texttt{eval\_loop is\_while env e\_cond body} evaluates \texttt{body} in
\texttt{env}: this is either an interruption \texttt{Returning vs}, a
\texttt{Throwing} or a new environment \texttt{new\_env}.

    \subsection{Prose}
    \texttt{cond\_m} evaluates to \texttt{e\_cond} or \texttt{not e\_cond} as
determined by \texttt{is\_while} and one of the following applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{false};
      \item \texttt{new\_env} is \texttt{env}---the loop is exited.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{true};
      \item \texttt{env1} is \texttt{env} modified after the evaluation of the
statement \texttt{body}---this step might affect the value of \texttt{cond\_m}
eventually leading to exiting the loop;
      \item \texttt{new\_env} is \texttt{env1} modified after the evaluation of
\texttt{eval\_loop is\_while env e\_cond body}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.Loop.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Loop.asl}
    does not raise any Assertion Error and the program terminates with exit
    code 0.

    \subsection{Code}
    \VerbatimInput[firstline=\LoopBegin, lastline=\LoopEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.For \label{sec:SemanticsRule.For}}
\texttt{eval\_for undet env index\_name v\_start dir v\_end body} evaluates
\texttt{body} in \texttt{env}: this is either an interruption \texttt{Returning
vs} or a new environment \texttt{new\_env}.

    \subsection{Prose}
    \texttt{cond\_m} evaluates to \texttt{leq v\_end v\_start} or \texttt{geq
v\_end v\_start} as determined by \texttt{dir} and one of the following
applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{true};
      \item \texttt{new\_env} is \texttt{env} as the loop is exited.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{false};
      \item \texttt{env1} is \texttt{env} modified after the evaluation of the statement \texttt{body};
      \item \texttt{env2} is \texttt{env1} modified such that \texttt{index\_name} is bound to \texttt{v\_step};
      \item \texttt{v\_step} evaluates to \texttt{v\_start+1} or \texttt{v\_start-1} as determined by \texttt{dir};
      \item \texttt{new\_env} is \texttt{env2} modified after the evaluation of \texttt{eval\_for undet
        env index\_name v\_step dir v\_end body}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.For.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.For.asl}
    does not raise any assertion error, and the program terminates with exit-code 0.

    \subsection{Code}
    \VerbatimInput[firstline=\ForBegin, lastline=\ForEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Evaluation of Catchers \label{chap:eval_catchers}}
\texttt{eval\_catchers env catchers otherwise\_opt s\_m}, given the result
\texttt{s\_m} of the evaluation of a statement under environment \texttt{env}
is \texttt{res} which is either a \texttt{Throwing (v, v\_ty, env\_throw)}, an
interruption \texttt{Returning vs} or a new environment \texttt{new\_env}.
Formally, one of the following applies:
\begin{itemize}
\item SemanticsRule.Catch (see Section~\ref{sec:SemanticsRule.Catch}),
\item SemanticsRule.CatchNamed (see Section~\ref{sec:SemanticsRule.CatchNamed}),
\item SemanticsRule.CatchOtherwise (see Section~\ref{sec:SemanticsRule.CatchOtherwise}),
\item SemanticsRule.CatchNone (see Section~\ref{sec:SemanticsRule.CatchNone}),
\item SemanticsRule.CatchNoThrow (see Section~\ref{sec:SemanticsRule.CatchNoThrow}).
\end{itemize}

\section{SemanticsRule.Catch \label{sec:SemanticsRule.Catch}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{catcher} is the first catcher in \texttt{catchers} that matches \texttt{v\_ty};
    \item \texttt{catcher} does not declare a name;
    \item \texttt{catcher} gives a statement \texttt{s};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{env\_throw} and \texttt{env} have the same scope, and \texttt{env1} is \texttt{env\_throw};
      \item \texttt{env1} is the environment formed with the global part of \texttt{env\_throw}
        and the local part of \texttt{env};
      \end{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{Throwing (None, None, env\_throw1)} is the result of the evaluation of
        the block \texttt{s} in \texttt{env1}, and \texttt{res} is \texttt{Throwing (v, v\_ty, env\_throw1)};
      \item \texttt{res} is the result of the evaluation of the block \texttt{s} in \texttt{env1}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.Catch.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Catch.asl}
    prints ``\texttt{MyException}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchBegin, lastline=\CatchEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNamed \label{sec:SemanticsRule.CatchNamed}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{catcher} is the first catcher in \texttt{catchers} that matches \texttt{v\_ty};
    \item \texttt{catcher} declares a name \texttt{name};
    \item \texttt{catcher} gives a statement \texttt{s};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{env\_throw} and \texttt{env} have the same scope, and \texttt{env1} is \texttt{env\_throw};
      \item \texttt{env1} is the environment formed with the global part of \texttt{env\_throw}
        and the local part of \texttt{env};
      \item \texttt{env2} is \texttt{env1} modified after binding locally \texttt{name} to the exception
        \texttt{v} raised by \texttt{s\_m};
      \end{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{Throwing (None, None, env\_throw1)} is the result of the evaluation of
        the block \texttt{s} in \texttt{env2}, and \texttt{res} is \texttt{Throwing (v, v\_ty, env\_throw1)};
      \item \texttt{env3} is \texttt{env2} modified after the evaluation of the block \texttt{s} in
        \texttt{env2}, and \texttt{new\_env} is \texttt{env3} modified after unbinding \texttt{name} from
        \texttt{env3}.
      \item \texttt{res} is the result of the evaluation of the block \texttt{s} in \texttt{env2}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchNamed.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNamed.asl}
    prints ``\texttt{My exception with my message}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchNamedBegin, lastline=\CatchNamedEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchOtherwise \label{sec:SemanticsRule.CatchOtherwise}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{otherwise\_opt} is \texttt{Some s};
    \item no catcher matches \texttt{v\_ty};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{env\_throw} and \texttt{env} have the same scope, and \texttt{env1} is \texttt{env\_throw};
      \item \texttt{env1} is the environment formed with the global part of \texttt{env\_throw}
        and the local part of \texttt{env};
      \end{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{Throwing (None, None, env\_throw1)} is the result of the evaluation of
        the block \texttt{s} in \texttt{env1}, and \texttt{res} is \texttt{Throwing (v, v\_ty, env\_throw1)};
      \item \texttt{res} is the result of the evaluation of the block \texttt{s} in \texttt{env1}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchOtherwise.asl}
     The program:
     \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchOtherwise.asl}
     prints ``\texttt{Another exception}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchOtherwiseBegin, lastline=\CatchOtherwiseEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNone \label{sec:SemanticsRule.CatchNone}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{otherwise\_opt} is \texttt{None};
    \item no catcher matches \texttt{v\_ty};
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchNone.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNone.asl}
    does not print anything.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchNoneBegin, lastline=\CatchNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNoThrow \label{sec:SemanticsRule.CatchNoThrow}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is not \texttt{Throwing};
    \item \texttt{res} is \texttt{s\_m}.
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchNoThrow.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNoThrow.asl}
    prints ``\texttt{No exception raised}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchNoThrowBegin, lastline=\CatchNoThrowEnd]{../Interpreter.ml}

    \subsection{Comments}

\chapter{Evaluation of Functions \label{chap:eval_func}}
\texttt{eval\_func genv name pos actual\_args params} evaluates the subprogram
named \texttt{name} in the global environment \texttt{genv}, with
\texttt{actual\_args} the list of actual arguments, and \texttt{params} the
list of arguments deduced by type equality. This is a new global environment
\texttt{new\_genv} and a list of values \texttt{vs}, or an error is raised.
One of the following applies:
\begin{itemize}
\item SemanticsRule.FUndefIdent (see Section~\ref{sec:SemanticsRule.FUndefIdent}),
\item SemanticsRule.FPrimitive (see Section~\ref{sec:SemanticsRule.FPrimitive}),
\item SemanticsRule.FCall (see Section~\ref{sec:SemanticsRule.FCall}).
\end{itemize}

\section{SemanticsRule.FUndefIdent \label{sec:SemanticsRule.FUndefIdent}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{name} is undeclared in \texttt{genv};
  \item an \texttt{UndefinedIdentifier} error is raised.
  \end{itemize}

  \subsection{Example: SemanticsRule.FUndefIdent.asl}
  The program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.FUndefIdent.asl}
  raises an \texttt{UndefinedIdentifier "Foo"} error.

  \subsection{Code}
  \VerbatimInput[firstline=\FUndefIdentBegin, lastline=\FUndefIdentEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.FPrimitive \label{sec:SemanticsRule.FPrimitive}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{name} is bound in \texttt{genv} to a primitive subprogram with a body \texttt{body};
  \item \texttt{new\_genv} is \texttt{genv};
  \item \texttt{vs} is the application of \texttt{body} on \texttt{actual\_args}.
  \end{itemize}

  \subsection{Example}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.FPrimitive.asl}
  \texttt{print ("Hello, world!");} calls the primitive \texttt{print} on the evaluation of \texttt{"Hello, world!"}.

  \subsection{Code}
  \VerbatimInput[firstline=\FPrimitiveBegin, lastline=\FPrimitiveEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.FCall \label{sec:SemanticsRule.FCall}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{name} is bound in \texttt{genv} to a subprogram with a list of formal arguments
    \texttt{arg\_decls} and a body statement \texttt{body};
  \item \texttt{env1} is the environment made of \texttt{genv} and the empty local environment,
  \item \texttt{env2} is \texttt{env1} modified so that each formal argument in \texttt{arg\_decls} is
    locally bound to the corresponding actual argument in \texttt{actual\_args};
  \item \texttt{env3} is \texttt{env2} modified so that each parameter in \texttt{params} is declared;
  \item \texttt{res} is the evaluation of \texttt{body} in \texttt{env3} and one of the following
    applies:
      \begin{itemize}
      \item \texttt{res} is an environment \texttt{env4} and \texttt{new\_genv} is the global environment
        given by \texttt{env4}---e.g. where the subprogram called is either a setter or
        a procedure;
      \item \texttt{res} is an interruption \texttt{Returning(xs,ret\_genv)} and \texttt{new\_genv} is
        \texttt{ret\_genv}---this is the general case.
      \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.FCall.asl}
  The program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.FCall.asl}
  calls the function \texttt{foo} and the procedure \texttt{bar}.

  \subsection{Code}
  \VerbatimInput[firstline=\FCallBegin, lastline=\FCallEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  The evaluation of a n-ary subprogram evaluates the arguments in order then
  calls the subprogram:
  \begin{align}
  \interp{f (e_1, \dotsc e_n)} (E_0) & \triangleq
    \left\{ (v, E') \st{}
    \begin{aligned}
      & \forall i \in \llbracket 1, n \rrbracket, (v_i, E_i) \in \interp{e_i} (E_{i - 1})
      \\ \text{and}\ &
      (v, E') \in \interp{\left\langle f, v_1, \dotsc v_n \right\rangle} \left(E_n\right)
    \end{aligned}
    \right\}
  \label{eq:sem-seq-fcall}
  \end{align}

  \subsection{Formally: concurrent case}
  For $i$ ranging implicitly from 1 to $n$ included, a call to a subprogram $f$
  is interpreted as the interpretation of the subprogram call (see to $f$ after
  evaluating every argument in order:

  \begin{align}
    \interp{f (e_i)} (E_0) \triangleq
      \left\{ (v, E', S) \st{}
      \begin{aligned}
        & % \forall i \in \llbracket 1, n \rrbracket,
          (v_i, E_i, S_i) \in \interp{e_i} (E_{i - 1})
        \\ \text{and}\ &
        (v, E', S) \in \interp{\left\langle f, (v_i,S_i) \right\rangle} \left(E_n\right)
      \end{aligned}
      \right\}
    \label{eq:sem-conc-fcall}
  \end{align}
\end{formal}

  \subsection{Comments}
  This aims to encompass \identr{DFWZ}.

\chapter{Evaluation of Programs}

  \section{SemanticsRule.TopLevel \label{sec:SemanticsRule.TopLevel}}

  \subsection{Prose}
  The evaluation of a program \texttt{ast} is \texttt{res} or an error
  and all of the following apply:
  \begin{itemize}
  \item \texttt{ast’} is \texttt{ast} modified to add the standard library;
  \item \texttt{ast\_typed, static\_env} is the result of typing \texttt{ast’};
  \item \texttt{genv} is the global environment built using \texttt{static\_env} and evaluating the global constants in \texttt{ast\_typed} following the Directed Acyclic Graph of their definitions;
  \item \texttt{res} is the result of evaluating the function ``\texttt{main}, without any argument, in \texttt{genv};
  \item One of the following applies:
        \begin{itemize}
	\item \texttt{res} is a value \texttt{v}, or
	\item All of the following apply:
              \begin{itemize}
              \item \texttt{res} is an implicitly thrown exception;
	      \item An error ``\texttt{Uncaught exception: implicitly thrown out of a try-catch}'' is raised;
              \end{itemize}
	\item All of the following apply:
              \begin{itemize}
              \item \texttt{res} is an exception \texttt{exn} with an associated type \texttt{ty};
	      \item An error ``\texttt{Uncaught exception: \{ty\} \{exn\}}'' is raised.
              \end{itemize}
        \end{itemize}
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\TopLevelBegin, lastline=\TopLevelEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Side-effects}

Side-effects can arise due to:
\begin{itemize}
\item Reads and Writes to global variables;
\item Exceptions;
\item Calls to primitives.
\end{itemize}

\bibliographystyle{plain}
\bibliography{ASL}
\end{document}
