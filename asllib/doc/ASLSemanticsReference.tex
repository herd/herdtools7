\documentclass{book}
\input{ASLmacros}

% The following macros will be moved to ASLmacros.tex when we unify all reference documents.
\newcommand\exprequalcase[0]{\texttt{expr\_equal\_case}}
\newcommand\exprequalnorm[0]{\texttt{expr\_equal\_norm}}
\newcommand\exprequal[0]{\texttt{expr\_equal}}

\newcommand\typearrow[0]{\xrightarrow{\mathsf{type}}}

\newcommand\Nodes[0]{\hyperlink{def-nodes}{\mathcal{N}}}
\newcommand\Read[0]{\hyperlink{def-read}{\text{Read}}}
\newcommand\Write[0]{\hyperlink{def-write}{\text{Write}}}
\newcommand\Labels[0]{\hyperlink{def-labels}{\mathcal{L}}}
\newcommand\XGraphs[0]{\hyperlink{def-xgraphs}{\mathcal{G}}}
\newcommand\WriteEffect[0]{\hyperlink{def-writeeffect}{\textsf{WriteEffect}}}
\newcommand\ReadEffect[0]{\hyperlink{def-writeeffect}{\textsf{ReadEffect}}}

\newcommand\emptyenv[0]{\hyperlink{def-emptyenv}{\emptyset_{\env}}}
\newcommand\ordered[3]{{#1}\hyperlink{def-ordered}{\xrightarrow{#2}}{#3}}
\newcommand\parallelcomp[0]{\hyperlink{def-parallel}{\parallel}}

\newcommand\graphof[1]{\hyperlink{def-graphof}{\texttt{graph}}({#1})}
\newcommand\withgraph[2]{{#1}(\hyperlink{def-withgraph}{\texttt{graph}}\mapsto{#2})}
\newcommand\environof[1]{\hyperlink{def-environof}{\texttt{environ}}({#1})}
\newcommand\withenviron[2]{{#1}(\hyperlink{def-withenviron}{\texttt{environ}}\mapsto{#2})}

\newcommand\primitiverel[0]{\hyperlink{def-primitiverel}{\textsf{primitive}}}
\newcommand\evalprimitivearrow[0]{\hyperlink{def-evalprimitivearrow}{\stackrel{\primitiverel}{\rightsquigarrow}}}
\newcommand\ContinuingConfig[0]{\hyperlink{def-continuingconfig}{\texttt{\#C}}}
\newcommand\ReturningConfig[0]{\hyperlink{def-returningconfig}{\texttt{\#R}}}
\newcommand\ThrowingConfig[0]{\hyperlink{def-throwingconfig}{\texttt{\#T}}}
\newcommand\ErrorConfig[0]{\hyperlink{def-errorconfig}{\texttt{\#DE}}}
\newcommand\OrAbnormal[0]{\terminateas \ThrowingConfig, \ErrorConfig}
\newcommand\ProseOrAbnormal[0]{or an abnormal configuration, which short-circuits the entire evaluation}
\newcommand\ProseOrError[0]{or an error configuration, which short-circuits the entire evaluation}
\newcommand\TNormal[0]{\hyperlink{def-tnormal}{\textsf{TNormal}}}
\newcommand\TError[0]{\hyperlink{def-terror}{\textsf{TDynError}}}
\newcommand\TThrowing[0]{\hyperlink{def-tthrowing}{\textsf{TThrowing}}}
\newcommand\TContinuing[0]{\hyperlink{def-tcontinuing}{\textsf{TContinuing}}}
\newcommand\TReturning[0]{\hyperlink{def-treturning}{\textsf{TReturning}}}
\newcommand\TOutConfig[0]{\hyperlink{def-toutconfig}{\textsf{TOutConfig}}}

\newcommand\evalexpr[1]{\hyperlink{def-evalexpr}{\texttt{eval\_expr}}(#1)}
\newcommand\evalexprsef[1]{\hyperlink{def-evalexprsef}{\texttt{eval\_expr\_sef}}(#1)}
\newcommand\evallexpr[1]{\hyperlink{def-evallexpr}{\texttt{eval\_lexpr}}(#1)}
\newcommand\evalexprlist[1]{\hyperlink{def-evalexprlist}{\texttt{eval\_expr\_list}}(#1)}
\newcommand\evalexprlistm[1]{\hyperlink{def-evalexprlistm}{\texttt{eval\_expr\_list\_m}}(#1)}
\newcommand\evalpattern[1]{\hyperlink{def-evalpattern}{\texttt{eval\_pattern}}(#1)}
\newcommand\evallocaldecl[1]{\hyperlink{def-evallocaldecl}{\texttt{eval\_local\_decl}}(#1)}
\newcommand\evalslices[1]{\hyperlink{def-evalslices}{\texttt{eval\_slices}}(#1)}
\newcommand\evalslice[1]{\hyperlink{def-evalslice}{\texttt{eval\_slice}}(#1)}
\newcommand\evalstmt[1]{\hyperlink{def-evalstmt}{\texttt{eval\_stmt}}(#1)}
\newcommand\evalblock[1]{\hyperlink{def-evalblock}{\texttt{eval\_block}}(#1)}
\newcommand\evalloop[1]{\hyperlink{def-evalloop}{\texttt{eval\_loop}}(#1)}
\newcommand\evalfor[1]{\hyperlink{def-evalfor}{\texttt{eval\_for}}(#1)}
\newcommand\evalcatchers[1]{\hyperlink{def-evalcatchers}{\texttt{eval\_catchers}}(#1)}
\newcommand\evalsubprogram[1]{\hyperlink{def-evalsubprogram}{\texttt{eval\_subprogram}}(#1)}
\newcommand\evalcall[1]{\hyperlink{def-evalcall}{\texttt{eval\_call}}(#1)}
\newcommand\evalprimitive[1]{\hyperlink{def-evalprimitive}{\texttt{eval\_primitive}}(#1)}
\newcommand\evalmultiassignment[1]{\hyperlink{def-evalmultiassign}{\texttt{multi\_assign}}(#1)}
\newcommand\rethrowimplicit[0]{\hyperlink{def-rethrowimplicit}{\texttt{rethrow\_implicit}}}
\newcommand\assignargs[0]{\hyperlink{def-assignargs}{\texttt{assign\_args}}}
\newcommand\assignnamedargs[0]{\hyperlink{def-assignnamedargs}{\texttt{assign\_named\_args}}}
\newcommand\matchfuncres[0]{\hyperlink{def-matchfuncres}{\texttt{match\_func\_res}}}
\newcommand\buildgenv[0]{\hyperlink{def-buildgenv}{\texttt{build\_genv}}}
\newcommand\topologicaldecls[0]{\hyperlink{def-topologicaldecls}{\texttt{topological\_decls}}}
\newcommand\evalglobals[0]{\hyperlink{def-evalglobals}{\texttt{eval\_globals}}}
\newcommand\evalspec[1]{\hyperlink{def-evalspec}{\texttt{eval\_spec}}(#1)}
\newcommand\lexprisvar[0]{\hyperlink{def-lexprisvar}{\texttt{lexpr\_is\_var}}}
\newcommand\casetoconds[0]{\hyperlink{def-casetoconds}{\texttt{case\_to\_conds}}}
\newcommand\findcatcher[0]{\hyperlink{def-findcatcher}{\texttt{find\_catcher}}}

\newcommand\declarelocalidentifier[0]{\hyperlink{def-declarelocalidentifier}{\texttt{declare\_local\_identifier}}}
\newcommand\declarelocalidentifierm[0]{\hyperlink{def-declarelocalidentifierm}{\texttt{declare\_local\_identifier\_m}}}
\newcommand\declarelocalidentifiermm[0]{\hyperlink{def-declarelocalidentifermm}{\texttt{declare\_local\_identifier\_mm}}}
\newcommand\removelocal[0]{\hyperlink{def-removelocal}{\texttt{remove\_local}}}
\newcommand\readidentifier[0]{\hyperlink{def-readidentifier}{\texttt{read\_identifier}}}
\newcommand\writeidentifier[0]{\hyperlink{def-writeidentifier}{\texttt{write\_identifier}}}
\newcommand\createbitvector[0]{\hyperlink{def-createbitvector}{\texttt{create\_bitvector}}}
\newcommand\concatbitvectors[0]{\hyperlink{def-concatbitvector}{\texttt{concat\_bitvectors}}}
\newcommand\readfrombitvector[0]{\hyperlink{def-readfrinbitvector}{\texttt{read\_from\_bitvector}}}
\newcommand\writetobitvector[0]{\hyperlink{def-writetobitvector}{\texttt{write\_to\_bitvector}}}
\newcommand\asbitvector[0]{\hyperlink{def-asbitvector}{\texttt{as\_bitvector}}}
\newcommand\slicestopositions[0]{\hyperlink{def-slicestopositions}{\texttt{slices\_to\_positions}}}
\newcommand\getindex[0]{\hyperlink{def-getindex}{\texttt{get\_index}}}
\newcommand\setindex[0]{\hyperlink{def-setindex}{\texttt{set\_index}}}
\newcommand\getfield[0]{\hyperlink{def-getfield}{\texttt{get\_field}}}
\newcommand\setfield[0]{\hyperlink{def-setfield}{\texttt{set\_field}}}
\newcommand\declareglobal[0]{\hyperlink{def-declareglobal}{\texttt{declare\_global}}}
\newcommand\basevalue[0]{\hyperlink{def-basevalue}{\texttt{base\_value}}}
\newcommand\isvaloftype[0]{\hyperlink{def-isvaloftype}{\texttt{is\_val\_of\_type}}}
\newcommand\positioninrange[0]{\hyperlink{def-positioninrange}{\texttt{position\_in\_range}}}
\newcommand\integerconstraintsatisfied[0]{\hyperlink{def-integerconstraintsatisfied}{\texttt{int\_constraint\_sat}}}

\newcommand\unoprel[0]{\hyperlink{def-unoprel}{\texttt{unop}}}
\newcommand\binoprel[0]{\hyperlink{def-binoprel}{\texttt{binop}}}

\newcommand\findfunc[0]{\hyperlink{def-findfunc}{\texttt{find\_func}}}
\newcommand\unknownval[0]{\texttt{unknown\_val}}

\newcommand\valuereadfrom[0]{\hyperlink{def-valuereadfrom}{\textsf{value\_read\_from}}}
\newcommand\Normal[0]{\hyperlink{def-normal}{\textsf{Normal}}}
\newcommand\Throwing[0]{\hyperlink{def-throwing}{\textsf{Throwing}}}
\newcommand\Continuing[0]{\hyperlink{def-continuing}{\textsf{Continuing}}}
\newcommand\Returning[0]{\hyperlink{def-returning}{\textsf{Returning}}}
\newcommand\Error[0]{\hyperlink{def-error}{\textsf{DynError}}}

\newcommand\ErrorVal[1]{\Error(\texttt{"ERROR[#1]"})}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Names for variables appearing in rules

\newcommand\caselist[0]{\texttt{case\_list}}
\newcommand\casecond[0]{\texttt{case\_cond}}
\newcommand\parsedspec[0]{\texttt{parsed\_spec}}
\newcommand\parsedstd[0]{\texttt{parsed\_std}}
\newcommand\parsedast[0]{\texttt{parsed\_ast}}
\newcommand\typedspec[0]{\texttt{typed\_spec}}

\newcommand\env[0]{\hyperlink{def-env}{\texttt{env}}}
\newcommand\denvone[0]{\textsf{denv1}}
\newcommand\denvtwo[0]{\textsf{denv2}}
\newcommand\envthree[0]{\texttt{env3}}
\newcommand\envfour[0]{\texttt{env4}}
\newcommand\envp[0]{\texttt{env'}}
\newcommand\vex[0]{\texttt{ex}}
\newcommand\vc[0]{\texttt{c}}
\newcommand\vg[0]{\texttt{g}}
\newcommand\newg[0]{\texttt{new\_g}}
\newcommand\vgp[0]{\texttt{g'}}
\newcommand\vvp[0]{\texttt{v'}}
\newcommand\vep[0]{\texttt{e'}}
\newcommand\vl[0]{\texttt{l}}
\newcommand\vm[0]{\texttt{m}}
\newcommand\vp[0]{\texttt{p}}
\newcommand\vpone[0]{\texttt{p1}}
\newcommand\vy[0]{\texttt{y}}
\newcommand\vs[0]{\texttt{s}}
\newcommand\vt[0]{\texttt{t}}
\newcommand\vu[0]{\texttt{u}}
\newcommand\vw[0]{\texttt{w}}
\newcommand\vvsg[0]{\texttt{vsg}}
\newcommand\vvs[0]{\texttt{vs}}
\newcommand\vvsone[0]{\texttt{vs1}}
\newcommand\vms[0]{\texttt{ms}}
\newcommand\vmsone[0]{\texttt{ms1}}
\newcommand\vmstwo[0]{\texttt{ms2}}
\newcommand\vles[0]{\texttt{les}}
\newcommand\vre[0]{\texttt{re}}
\newcommand\vres[0]{\texttt{res}}
\newcommand\vvone[0]{\texttt{v1}}
\newcommand\vvtwo[0]{\texttt{v2}}
\newcommand\vsp[0]{\texttt{s'}}
\newcommand\vsone[0]{\texttt{s1}}
\newcommand\vstwo[0]{\texttt{s2}}
\newcommand\vmone[0]{\texttt{m1}}
\newcommand\vmtwo[0]{\texttt{m2}}
\newcommand\veone[0]{\texttt{e1}}
\newcommand\vetwo[0]{\texttt{e2}}
\newcommand\vefour[0]{\texttt{e4}}
\newcommand\vefive[0]{\texttt{e5}}
\newcommand\veonetwo[0]{\texttt{e12}}
\newcommand\vefourfive[0]{\texttt{e45}}
\newcommand\vgthree[0]{\texttt{g3}}
\newcommand\vgfour[0]{\texttt{g4}}
\newcommand\ebv[0]{\texttt{e\_bv}}
\newcommand\mbv[0]{\texttt{m\_bv}}
\newcommand\mcond[0]{\texttt{m\_cond}}
\newcommand\vbv[0]{\texttt{v\_bv}}
\newcommand\mpositions[0]{\texttt{m\_positions}}
\newcommand\vslice[0]{\texttt{slice}}
\newcommand\vsliceone[0]{\texttt{slice1}}
\newcommand\slices[0]{\texttt{slices}}
\newcommand\slicesone[0]{\texttt{slices1}}
\newcommand\indices[0]{\texttt{indices}}
\newcommand\positions[0]{\texttt{positions}}
\newcommand\name[0]{\texttt{name}}
\newcommand\args[0]{\texttt{args}}
\newcommand\actualargs[0]{\texttt{actual\_args}}
\newcommand\argdecls[0]{\texttt{arg\_decls}}
\newcommand\namedargs[0]{\texttt{named\_args}}
\newcommand\nargs[0]{\texttt{nargs}}
\newcommand\nargsm[0]{\texttt{nargs\_m}}
\newcommand\nargsone[0]{\texttt{nargs1}}
\newcommand\nargstwo[0]{\texttt{nargs2}}
\newcommand\nargsthree[0]{\texttt{nargs3}}
\newcommand\nargstwom[0]{\texttt{nargs2\_m}}
\newcommand\vvargs[0]{\texttt{vargs}}
\newcommand\vargsm[0]{\texttt{vargs\_m}}
\newcommand\params[0]{\texttt{params}}
\newcommand\paramsone[0]{\texttt{params1}}
\newcommand\earray[0]{\texttt{e\_array}}
\newcommand\eindex[0]{\texttt{e\_index}}
\newcommand\marray[0]{\texttt{m\_array}}
\newcommand\mindex[0]{\texttt{m\_index}}
\newcommand\varray[0]{\texttt{v\_array}}
\newcommand\vindex[0]{\texttt{v\_index}}
\newcommand\efields[0]{\texttt{e\_fields}}
\newcommand\names[0]{\texttt{names}}
\newcommand\fields[0]{\texttt{fields}}
\newcommand\vvfields[0]{\texttt{v\_fields}}
\newcommand\erecord[0]{\ERecord}
\newcommand\vrecord[0]{\texttt{v\_record}}
\newcommand\fieldname[0]{\texttt{field\_name}}
\newcommand\elist[0]{\texttt{e\_list}}
\newcommand\vlist[0]{\texttt{v\_list}}
\newcommand\stm[0]{\texttt{stm}}
\newcommand\blockenv[0]{\texttt{block\_env}}
\newcommand\blockenvone[0]{\texttt{block\_env1}}
\newcommand\rearray[0]{\texttt{re\_array}}
\newcommand\rvarray[0]{\texttt{rv\_array}}
\newcommand\rmarray[0]{\texttt{rm\_array}}
\newcommand\record[0]{\texttt{record}}
\newcommand\rerecord[0]{\texttt{re\_record}}
\newcommand\rmrecord[0]{\texttt{rm\_record}}
\newcommand\rvrecord[0]{\texttt{rv\_record}}
\newcommand\vlelist[0]{\texttt{le\_list}}
\newcommand\vmlist[0]{\texttt{vm\_list}}
\newcommand\vlelistone[0]{\texttt{le\_list1}}
\newcommand\vmlistone[0]{\texttt{vm\_list1}}
\newcommand\nmonads[0]{\texttt{nmonads}}
\newcommand\start[0]{\texttt{start}}
\newcommand\mstart[0]{\texttt{m\_start}}
\newcommand\vstart[0]{\texttt{v\_start}}
\newcommand\vend[0]{\texttt{v\_end}}
\newcommand\estart[0]{\texttt{e\_start}}
\newcommand\elength[0]{\texttt{e\_length}}
\newcommand\mlength[0]{\texttt{m\_length}}
\newcommand\vlength[0]{\texttt{v\_length}}
\newcommand\vdiff[0]{\texttt{v\_diff}}
\newcommand\etop[0]{\texttt{e\_top}}
\newcommand\vvtop[0]{\texttt{v\_top}}
\newcommand\mtop[0]{\texttt{m\_top}}
\newcommand\efactor[0]{\texttt{e\_factor}}
\newcommand\mfactor[0]{\texttt{m\_factor}}
\newcommand\vfactor[0]{\texttt{v\_factor}}
\newcommand\range[0]{\texttt{range}}
\newcommand\ranges[0]{\texttt{ranges}}
\newcommand\rangesone[0]{\texttt{ranges1}}
\newcommand\ldi[0]{\texttt{ldi}}
\newcommand\ldione[0]{\texttt{ldi1}}
\newcommand\ldis[0]{\texttt{ldis}}
\newcommand\liv[0]{\texttt{liv}}
\newcommand\minitopt[0]{\texttt{m\_init\_opt}}
\newcommand\les[0]{\texttt{les}}
\newcommand\wid[0]{\texttt{wid}}
\newcommand\es[0]{\texttt{es}}
\newcommand\ms[0]{\texttt{ms}}
\newcommand\body[0]{\text{body}}
\newcommand\vbody[0]{\texttt{body}}
\newcommand\dir[0]{\texttt{dir}}
\newcommand\catchers[0]{\texttt{catchers}}
\newcommand\catchersone[0]{\texttt{catchers1}}
\newcommand\otherwiseopt[0]{\texttt{otherwise\_opt}}
\newcommand\iswhile[0]{\texttt{is\_while}}
\newcommand\econd[0]{\ECond}
\newcommand\condm[0]{\texttt{cond\_m}}
\newcommand\condv[0]{\texttt{cond\_v}}
\newcommand\condg[0]{\texttt{cond\_g}}
\newcommand\vindexname[0]{\texttt{index\_name}}
\newcommand\envthrow[0]{\texttt{env\_throw}}
\newcommand\envthrowone[0]{\texttt{env\_throw1}}
\newcommand\denvthrow[0]{\texttt{denv\_throw}}
\newcommand\sm[0]{\texttt{s\_m}}
\newcommand\sg[0]{\texttt{s\_g}}
\newcommand\ety[0]{\texttt{e\_ty}}
\newcommand\vvty[0]{\texttt{v\_ty}}
\newcommand\nameopt[0]{\texttt{name\_opt}}
\newcommand\vbone[0]{\texttt{b1}}
\newcommand\vbtwo[0]{\texttt{b2}}
\newcommand\vps[0]{\texttt{ps}}
\newcommand\vbs[0]{\texttt{bs}}
\newcommand\xs[0]{\texttt{xs}}
\newcommand\retenv[0]{\texttt{ret\_env}}
\newcommand\vglobal[0]{\texttt{global}}
\newcommand\rid[0]{\texttt{rid}}
\newcommand\genv[0]{\texttt{genv}}
\newcommand\envm[0]{\texttt{envm}}
\newcommand\vacc[0]{\texttt{acc}}
\newcommand\vvsm[0]{\texttt{vsm}}
\newcommand\vvsmone[0]{\texttt{vsm1}}
\newcommand\vdecls[0]{\texttt{decls}}
\newcommand\bv[0]{\texttt{bv}}
\newcommand\src[0]{\texttt{src}}
\newcommand\dst[0]{\texttt{dst}}
\newcommand\vvec[0]{\texttt{vec}}
\newcommand\velem[0]{\texttt{v\_elem}}
\newcommand\bits[0]{\texttt{bits}}
\newcommand\eid[0]{\texttt{e\_id}}
\newcommand\newmbv[0]{\texttt{new\_m\_bv}}
\newcommand\truep[0]{\texttt{true'}}
\newcommand\falsep[0]{\texttt{false'}}
\newcommand\vardecl[0]{\texttt{vardecl}}
\newcommand\compfordir[0]{\texttt{comp\_for\_dir}}
\newcommand\evalforstep[0]{\texttt{eval\_for\_step}}
\newcommand\evalforloop[0]{\texttt{eval\_for\_loop}}
\newcommand\opfordir[0]{\texttt{op\_for\_dir}}
\newcommand\vstep[0]{\texttt{v\_step}}

%%%%%%%%%%

\input{ASLSemanticsLines}

% Increase indentation of sections in the table of contents
% to allow a space between the section numbers and their titles.
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{2.6em}}
\makeatother

\setcounter{tocdepth}{1}

\newcommand{\testdir}{../tests/ASLSemanticsReference.t}

\author{Arm Architecture Technology Group}
\title{ASL Semantics Reference \\
       DDI 0621}
\begin{document}
\maketitle

\tableofcontents{}

\include{notice.tex}

\include{disclaimer.tex}

\chapter{Introduction}

The semantics of ASL define all valid behaviors of a given ASL specification.
More precisely, an ASL specification is first parsed into an \emph{abstract syntax tree},
or AST, for short. Second, a type checker analyzes the \emph{parsed AST} for well-typedness and,
if successful, returns a \emph{static environment} and a \emph{typed AST}. Otherwise, it returns a type error.

Tools such as interpreters, Verilog simulators, and verifiers can operate over the typed AST, based on the definition
of the semantics in this document, to test and analyze a given specification.

\paragraph{Related documents:}
\begin{itemize}
  \item The ASL Language Reference Manual~\cite{LRM} (LRM, for short) introduces the concrete syntax and intent
  of all ASL language constructs.
  Please note that the LRM will be retired in due course. For ease of reviewing, we currently indicate which statement
  of the LRM the present rules correspond to.
  \item The Abstract Syntax Reference~\cite{ASLAbstractSyntaxReference} defines the abstract syntax, parsed AST, and typed AST.
  \item The ASL Typing Reference~\cite{ASLTypingReference} defines the set of parsed ASTs that are considered statically valid
  and how to produce the corresponding typed ASTs and static environments.
\end{itemize}

\paragraph{Undestanding the Semantics Formalization:}
We assume basic familiarity with the ASL language constructs (see the Language Reference Manual~\cite{LRM}).
The ASL semantics is defined in terms of its AST,
and familiarity with the AST is \underline{required} to understand it.
The few components of the type system needed to understand the ASL semantics are explained in context.
The mathematical background needed to understand the mathematical formalization
of the ASL semantics appears in \chapref{formal} and \chapref{semanticsbuildingblocks}.

\section{When Do ASL Specifications Have Meaning \label{sec:MeaningfulASLSpecifications}}
The ASL semantics defined here assign meaning only to \emph{well-typed specifications}.
That is, specifications for which the type-checker produces a static environment rather than
a type error.
Specifications that are not well-typed have no defined semantics.
In the rest of this document, we assume well-typed specifications.

ASL admits non-determinism, for example via the \texttt{UNKNOWN} expression.
This means that a given specification might have (potentially infinitely) many
\hyperlink{def-derivationtree}{derivation trees}.

An ASL specification is \emph{terminating} when \underline{all} of its derivation trees are finite.

Although ASL does not require specifications to terminate, the semantics defined in this
document assign meaning only to terminating specifications.
A future version of this document, will assign meaning to potentially non-terminating specifications.

\section{Basic Semantic Concepts}
The ASL semantics are given by relations between \emph{semantic configurations},
or \hyperlink{def-configuration}{\emph{configurations}}~\cite{SemanticsWithApplicationsBook}, for short.
We refer to relations between semantic configurations as \emph{semantic relations}.
Configurations encapsulate information needed to transition into other configurations, such as:
\begin{itemize}
  \item a \emph{dynamic environment}, which binds variables to values;
  \item the typed AST node that needs to be evaluated;
  \item a \emph{concurrent execution graph}, as per a given memory model; and
  \item values resulting from evaluating expressions.
\end{itemize}
The semantic relations are constructively defined via \emph{semantic rules}.
These semantic rules are defined by induction over the typed AST.

\paragraph{Execution:}
A valid execution of an ASL specification transitions from an \emph{initial configuration},
which consists of the given specification and the standard library specification, to an output configuration
consisting of an output value and a concurrent execution graph.

\paragraph{Primitive Subprograms:}
The semantics of ASL are parameterized by a set of primitive subprograms ---
subprograms whose implementation is not defined by ASL statements and whose effect on the dynamic environment
is defined externally. Critically, access to memory is given by primitive subprograms.

We define two types of semantics --- \emph{sequential semantics} and \emph{concurrent semantics}.

\paragraph{Concurrent Semantics:}
The concurrent semantics operate over concurrent execution graphs.
Intuitively, these graphs define Read Effects and Write Effects to variables and constraints over those effects.
Together with the constraints that define a given memory model (such as the ARM memory model~\cite{AlglaveDGHM21}),
these graphs axiomatically define
the valid interactions of shared variables of a given specification.

\paragraph{Sequential Semantics:}
The sequential semantics correspond to executing an ASL specification in the context of a single thread
of execution; notice that ASL does not contain any concurrency constructs.
%
Technically, the sequential semantics are defined by omitting the concurrent execution graph components
from all configurations.

\input{ASLFormal.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Semantics Building Blocks}
\label{chap:semanticsbuildingblocks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter defines the mathematical types over which our semantics are defined.
An \hyperlink{eval-example}{example} of semantic evaluation appears at the end.

%% This section is repeated, with small changes, in the typing reference.
\section{Native Values \label{sec:nativevalues}}
\hypertarget{def-vals}{}
The semantics of an ASL specification associates \emph{native values} to variables.
The set of native values $\vals$ is the minimal set defined by the following recursive rules (\texttt{NV} stands for Native Value):
\hypertarget{def-nvliteral}{}
\hypertarget{def-nvvector}{}
\hypertarget{def-nvrecord}{}
\begin{mathpar}
  \inferrule[(Basis Set: Integers, Reals, Booleans, Strings, and Bitvectors)]
  {\vv \in \literal}
  { \nvliteral{\vv} \in \vals }
  \and
  \inferrule[(Tuple Values and Array Values)]{\vvl \in \vals^*}
  { \nvvector{\vvl} \in \vals }
  \and
  \inferrule[(Record Values)]
  {\vr : \Identifiers \rightarrowfin \vals}
  { \nvrecord{\vr} \in \vals }
\end{mathpar}

We define the following shorthands for native value literals:
\hypertarget{def-nvint}{}
\[
\begin{array}{rcl}
\nvint(z)       &\triangleq& \nvliteral{\lint(z)}           \hypertarget{def-nvbool}{}\\
\nvbool(b)      &\triangleq& \nvliteral{\lbool(b)}          \hypertarget{def-nvreal}{}\\
\nvreal(r)      &\triangleq& \nvliteral{\lreal(r)}          \hypertarget{def-nvstring}{}\\
\nvstring(s)    &\triangleq& \nvliteral{\lstring(s)}        \hypertarget{def-nvbitvector}{}\\
\nvbitvector(v) &\triangleq& \nvliteral{\lbitvector(v)}\\
\end{array}
\]

We define the following types of native values:
\hypertarget{def-tint}{}
\[
\begin{array}{rcl}
  \tint       &\triangleq& \{ \nvint(z) \;|\; z \in \Z\}                                        \hypertarget{def-tbool}{}\\
  \tbool      &\triangleq& \{ \nvbool(\True), \nvbool(\False) \}                                \hypertarget{def-treal}{}\\
  \treal      &\triangleq& \{ \nvreal(r) \;|\; r \in \Q\}                                       \hypertarget{def-tstring}{}\\
  \tstring    &\triangleq& \{ \nvstring(s) \;|\; \texttt{"}s\texttt{"} \in \texttt{<string>}\}  \hypertarget{def-tbitvector}{}\\
  \tbitvector &\triangleq& \{ \nvbitvector(\textit{bits}) \;|\; \textit{bits} \in \{0,1\}^*\}   \hypertarget{def-tvector}{}\\
  \tvector    &\triangleq& \{ \nvvector{\textit{vals}} \;|\; \textit{vals} \in \vals^*\}        \hypertarget{def-trecord}{}\\
  \trecord  &\triangleq& \{ \nvrecord{\fieldmap} \;|\; \fieldmap \in \Identifiers\rightarrow\vals\}\\
\end{array}
\]

\section{Semantic Configurations \label{sec:configurations}}

In the sequel, we use the term configurations to refer to semantic configurations.

Configurations express intermediate states related by \emph{semantic relations}.
%
More precisely, semantic relations relate two distinct sets of configurations ---
\emph{input configurations} and \emph{output configurations}.
Input configurations consist of an environment and an AST node.
Output configurations consist of an output environment, values,
and concurrent execution graphs.
%
Configurations wrap together elements such as environments and AST nodes
and associate them with a \emph{configuration domain}. Input configuration domains
determine the semantic relation they pertain to, while output configuration
domains distinguish between conceptually different kinds of outputs, for example
ones where an exception was raised, ones when a dynamic error occurred, etc.

We now explain the components over which configurations are defined:
\begin{itemize}
  \item Static Environments (\defref{staticenvironments}) consist of the information inferred
  by the type-checker for the specification.
  \item Dynamic Environments (\defref{dynamicenvironments}) associate native values to variables.
  \item Concurrent Execution Graphs (\secref{concurrentexecutiongraphs}) track Read and Write Effects over variables.
\end{itemize}

\hypertarget{def-dynamicenvs}{}
\begin{definition}[Dynamic Environments \label{def:dynamicenvironments}]
A \emph{sequential dynamic environment}, or \\ \emph{dynamic environment}, for short, is a structure which,
amongst other things, associates native values to variables.
Formally, a sequential environment $\denv \in \dynamicenvs$ is a pair consisting of a partial function
(see \defref{PartialFunction}) from global
variable names to their native value, and a partial function from local variable names to their
native values:
\[
\begin{array}{rcl}
  \dynamicenvs          &\triangleq&  \mathbb{G} \times \mathbb{L} \\
  \mathbb{G}            &\triangleq&  (\Identifiers \partialto \vals) \\
  \mathbb{L}            &\triangleq&  (\Identifiers \partialto \vals) \\
\end{array}
\]
\end{definition}

\hypertarget{def-staticenvs}{}
\begin{definition}[Static Environment \label{def:staticenvironments}]
A \emph{static environment}~\cite{ASLTypingReference} $\tenv \in \staticenvs$ (also referred to as a \emph{type environment})
is produced by the type-checker from the parsed AST.

We assume that the static environment supports the following functions:
\hypertarget{def-findfunc}{}
\hypertarget{def-typesatisfies}{}
\[
  \begin{array}{rcl}
    \findfunc       &:& \staticenvs \times \Identifiers \partialto \func\\
    \typesat  &:& \staticenvs \times (\ty \times \ty) \rightarrow \{\True, \False\}
  \end{array}
\]
The partial function $\findfunc$ returns the typed AST of the subprogram for a given identifier.
(Recall that ASL allows subprogram overloading so a name does not uniquely identify
a specific subprogram.
However, the type-checker renames each function uniquely so that it can be accessed based
on its name alone.)
%
The function $\typesat(\vt, \vs)$ returns true
if the type $\vt$ \emph{type-satisfies} the type $\vs$
(see TypingRule.TypeSatisfaction~\cite{ASLTypingReference}).
This is used in matching a raised exception to a corresponding catch clause.
\end{definition}

\hypertarget{def-envs}{}
\begin{definition}[Environments]
Environments simply pair static environments with dynamic environments:
$\envs = \staticenvs \times \dynamicenvs$.
\end{definition}
\hypertarget{def-env}{}
We write $\env \in \envs$ to range over environments.
%
From the perspective of the semantics, the static environment is immutable.
That is, all environments share the same static environment.

\subsection{Concurrent Execution Graphs \label{sec:concurrentexecutiongraphs}}

The concurrent semantics of an ASL specification utilize \emph{concurrent execution graphs}
(\emph{execution graphs}, for short),
which track the Read and Write Effects over variables, yielded by the sequential semantics,
and the \emph{ordering constraints} between those effects.
The graphs resulting from executing an ASL specification are converted into
\emph{candidate execution graphs}, which are introduced, defined,
and used in~\cite{AlglaveMT14,alglave2016syntax,AlglaveDGHM21}.

\hypertarget{def-xgraphs}{}
Formally, an execution graph $\xgraph = (N^\xgraph, E^\xgraph, O^\xgraph) \in \XGraphs$
is defined via a set of \emph{nodes} ($N^\xgraph$), \emph{edges} ($E^\xgraph$), and \emph{output nodes} ($O^\xgraph$):
\hypertarget{def-nodes}{}
\[
\begin{array}{rcl}
\XGraphs &\triangleq& \pow{\Nodes} \times \pow{\Nodes \times \Nodes \times \Labels} \times \Nodes  \hypertarget{def-read}{}\hypertarget{def-write}{}\\
\Nodes   &\triangleq& \N \times \{ \Read, \Write \} \times \Identifiers \hypertarget{def-labels}{}\\
\Labels  &\triangleq& \{ \asldata, \aslctrl, \aslpo \}
\end{array}
\]

Nodes represent unique Read and Write Effects. Formally, a node $(u,l,\id) \in \Nodes$ associates a unique instance counter $u$
to an \emph{ordering label} $l$, which specifies whether it represents a Read Effect of a Write Effect to a variable named $\id$.
%
We say that en Effect \texttt{E1} is \emph{$l$-before} another Effect \texttt{E2}, for $l\in \Labels$ and a given execution graph
$g$, when $(\texttt{E1}, l, \texttt{E2}) \in E^g$.

An edge represents an ordering constraint between two effects, which can be one of the following:
\hypertarget{def-asldata}{}
\begin{description}
\item[$\asldata$] Represents a \emph{data dependency}.
That is, when one effect hands over its data to another effect.
\hypertarget{def-aslctrl}{}
\item[$\aslctrl$] Represents a \emph{control dependency}.
That is, when a Read Effect to a variable determines the flow of control (e.g., which condition of a branch is taken),
which then leads to another Read/Write Effect.
\hypertarget{def-aslpo}{}
\item[$\aslpo$] Represents a \emph{program order}.
That is, when two Effects are generated by ASL constructs, which are separated by a semicolon in the text of the specification,
or appear in successive loop unrollings.
% That is, when two effects are defined to be ordered according to the sequential semantics.
\end{description}

An execution graph is \emph{well-formed} if all nodes have unique instance counters, edges connect graph nodes,
and the output nodes are contained in the set of nodes:
\[
  \begin{array}{rcl}
  \forall n, n' \in N^\xgraph &.& n=(u,l,\id) \wedge n=(u',l',\id') \;\Rightarrow\; u \neq u' \\
  \forall e \in E^\xgraph &.& e=(n, n', l) \;\Rightarrow\; n, n' \in N^\xgraph \\
  & & O^\xgraph \subseteq N^\xgraph \enspace.
  \end{array}
\]
\hypertarget{def-emptygraph}{}

We denote the empty execution graph $\emptygraph \triangleq (\emptyset, \emptyset, \emptyset)$.
%
We define the following functions, which return an execution graph that represents a single Read/Write Effect to a variable \texttt{x}.
\hypertarget{def-writeeffect}{}
\hypertarget{def-readeffect}{}
\begin{definition}[Read/Write Effects]
\[
  \begin{array}{rclll}
    \WriteEffect(\vx) &\triangleq& (\{n\}, \emptyset, \{n\}) & \text{where } n=(u, \Write, \vx), & u\in\N \text{ is fresh}\\
    \ReadEffect(\vx)  &\triangleq& (\{n\}, \emptyset, \{n\}) & \text{where } n=(u, \Read, \vx),   & u\in\N \text{ is fresh}\\
  \end{array}
\]
\end{definition}

We also define two ways to compose execution graphs --- \emph{unordered composition} and
\emph{ordered composition with a given label}.

\hypertarget{def-parallel}{}
\begin{definition}[Unordered Graph Composition]
Given two execution graphs $S_1 = (N_1, E_1, O_1)$ and $S_1 = (N_2, E_2, O_2)$ their unordered composition,
denoted $S_1 \parallelcomp S_2$ is defined as follows:
\[
  S_1 \parallelcomp S_2\triangleq (N_1 \cup N_2, E_1 \cup E_2, O_1 \cup O_2) \enspace.
\]
Intuitively, this composition conveys the fact that there are no ordering constraints between the effects
in the arguments graphs.
\end{definition}

\hypertarget{def-ordered}{}
\begin{definition}[Ordered Graph Composition]
Given two execution graphs, \\ $S_1 = (N_1, E_1, O_1)$ and $S_1 = (N_2, E_2, O_2)$ and an ordering label $l$,
the ordered composition $\ordered{S_1}{l}{S_2}$ is defined as follows:
\[
  \ordered{S_1}{l}{S_2} \triangleq (N_1 \cup N_2, E_1 \cup E_2 \cup (O_1 \times N_2 \times \{l\}, O_2)) \enspace.
\]
Intuitively, this composition constrains the output effects of $S_1$ to appear before any effect of $S_2$ with respect
to the given ordering label.
\end{definition}

\subsection{Kinds of Semantic Configurations \label{sec:KindsOfSemanticConfigurations}}

Recall that the ASL semantics defines a relation between input configurations and output configurations
(\secref{configurations}).
Input configuration domains are unique to the semantic relation that employs them.
For that reason, we name semantic relations by the name of the corresponding input configuration domain.
For example, the semantic relation that employs input configurations with the domain $\texttt{eval\_expr}$
is named $\texttt{eval\_expr}$.
%
We will often use the prefix \texttt{eval} for semantic relations with the intuition being that their input configurations
should be ``semantically evaluated'', yielding an output configuration.

ASL semantics mainly utilizes the following types of output configurations:
\begin{description}
  \item[Normal Values.] \hypertarget{def-normal}{}
  Configurations consisting of different combinations of values,
  execution graphs, and environments, representing intermediate results
  generated while evaluating statements:
  \begin{itemize}
  \item $\Normal(\vals \times \XGraphs)$,
  \item $\Normal((\vals \times \XGraphs), \envs)$,
  \item $\Normal(((\vals \times \vals)^* \times \XGraphs), \envs)$,
  \item $\Normal(\XGraphs, \envs)$,
  \item $\Normal((\vals^* \times \XGraphs), \envs)$, and
  \item $\Normal((\vals\times\XGraphs)^*, \envs)$.
  \end{itemize}

  \hypertarget{def-throwing}{}
  \item[Exceptions.] Configurations in
  \[
    \Throwing((\langle \valuereadfrom(\vals,\Identifiers) \times \ty\rangle \times \XGraphs, \envs)
  \]
  represent thrown exceptions.
  \hypertarget{def-valuereadfrom}{}
  There are two flavors of exceptions:
  exceptions without an exception value (as in \texttt{throw;}), and ones with an exception value,
  an identifier to which the Read Effect is attributed, and an associated type.
  The type $\valuereadfrom(\vals,\Identifiers)$ is a configuration nested inside
  The ASL semantics propagates these \emph{exceptional configurations} to the nearest catch clause that matches
  them, and otherwise they are ``caught'' at the top-level and reported as errors (see dynamic errors below).

  \hypertarget{def-returning}{}
  \item[Returned Values.] Configurations in $\Returning((\vals^* \times \XGraphs), \envs)$
  represent (tuples of) values being returned by the currently executing subprogram.
  The ASL semantics propagates these \emph{early return configurations} to the respective call expression/statement.

  \hypertarget{def-continuing}{}
  \item[Subprogram In-flight.] Configurations in $\Continuing(\XGraphs, \envs)$
  represent the fact that a subprogram has more statements to execute.
  The ASl semantics treats these configurations as a signal to keep evaluating the remainder
  of the subprogram currently being evaluated.

  \hypertarget{def-error}{}
  \item[Dynamic Errors.] Configurations in $\Error(\texttt{<string>})$
  represent runtime errors (for example, division by zero).
  The ASL semantics is set up such that when these \emph{error configurations} appear,
  the evaluation of the entire specification terminates by outputting them.
\end{description}
Helper relations often have output configurations that are just tuples, without an associated configuration domain.

We define the following shorthands for types of output configurations:
\hypertarget{def-tnormal}{}
\hypertarget{def-tcontinuing}{}
\hypertarget{def-tthrowing}{}
\hypertarget{def-treturning}{}
\hypertarget{def-terror}{}
\[
  \begin{array}{rcl}
    \TNormal          & \triangleq & \Normal(\vals, \XGraphs) \cup \Normal((\vals \times \XGraphs), \envs)\ \cup \\
                      &            & \Normal(((\vals \times \vals)^* \times \XGraphs), \envs) \cup  \Normal(\XGraphs, \envs)\ \cup   \\
                      &            & \Normal((\vals^* \times \XGraphs), \envs) \cup \Normal((\vals\times\XGraphs)^*, \envs)\\
    \TThrowing        & \triangleq & \Throwing(\langle\vals \times \ty\rangle \times \XGraphs, \envs)\\
    \TContinuing      & \triangleq & \Continuing(\XGraphs, \envs)\\
    \TReturning       & \triangleq & \Returning((\vals^* \times \XGraphs), \envs)\\
    \TError           & \triangleq & \Error(\texttt{<string>})\\
  \end{array}
\]

We will say that a semantic transition \emph{terminates normally} when the output configuration domain is $\Normal$,
\emph{terminates exceptionally} when the output configuration domain is $\Throwing$,
\emph{terminates erroneously} when the output configuration domain is $\Error$,
and \emph{terminates abnormally} when it either terminates exceptionally or erroneously.

We introduce the following shorthands for configurations where all variables
appearing are \hyperlink{def-freshvariables}{fresh}:
\begin{itemize}
\hypertarget{def-throwingconfig}{}
\item $\ThrowingConfig \triangleq \Throwing((\vv, \vg), \newenv)$.
\hypertarget{def-errorconfig}{}
\item $\ErrorConfig \triangleq \Error(\vs)$.
\hypertarget{def-returningconfig}{}
\item $\ReturningConfig \triangleq \Returning((\vvs,\newg), \newenv)$
is an ``early return'' configuration.
\hypertarget{def-continuingconfig}{}
\item $\ContinuingConfig \triangleq \Continuing(\newg, \newenv)$.
\end{itemize}

\subsection{Extracting and Substituting Elements of Configurations}

\hypertarget{def-graphof}{}
\hypertarget{def-environof}{}
Given a configuration $C$, we define the graph component of the configuration, \\
$\graphof{C}$, and the environment of the configuration, $\environof{C}$, as follows:
\[
\begin{array}{lcc}
  C & \graphof{C} & \environof{C}\\
  \hline
  \Normal(\vv,\vg) & \vg & \text{undefined}\\
  \Normal((\vv,\vg), \env) & \vg & \env\\
  \Normal(([i=1..k: (\texttt{va}_i,\texttt{vb})],\vg), \env) & \vg & \env\\
  \Normal(\vg, \env) & \vg & \env\\
  \Normal([\vv_{1..k}], \vg) & \vg & \env\\
  \Normal([i=1..k: (\vv_i,\vg_i)], \env) & \text{undefined} & \env\\
  \Throwing((\valuereadfrom(\vx,\vv),\vg), \env) & \vg & \env\\
  \Returning(([\vv_{1..k}],\vg), \env) & \vg & \env\\
  \Continuing(\vg, \env) & \vg & \env\\
\end{array}
\]

\hypertarget{def-withgraph}{}
Given a configuration $C$, we define $\withgraph{C}{\vgp}$ to be a configuration
like $C$ where the graph component is substituted with $\vgp$:
\[
\begin{array}{ll}
  C & \withgraph{C}{\vgp}\\
  \hline
  \Normal(\vv,\vg) & \Normal(\vv,\vgp)\\
  \Normal((\vv,\vg), \env) & \Normal((\vv,\vgp), \env)\\
  \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \env) & \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vgp), \env)\\
  \Normal(\vg, \env) & \Normal(\vgp, \env)\\
  \Normal(i=1..k: \vv_i, \vg) & \Normal(i=1..k: \vv_i, \vgp)\\
  \Normal([i=1..k: (\vv_i,\vg_i)], \env) & \text{undefined}\\
  \Throwing((\valuereadfrom(\vx,\vv),\vg), \env) & \Throwing((\valuereadfrom(\vx,\vv),\vgp), \env)\\
  \Returning((i=1..k: \vv_i,\vg), \env) & \Returning((i=1..k: \vv_i,\vgp), \env)\\
  \Continuing(\vg, \env) & \Continuing(\vgp, \env)\\
\end{array}
\]
\hypertarget{def-withenviron}{}
Similarly, we define the $\withenviron{C}{\envp}$ to be a configuration
like $C$ where the environment component, if one exists, is substituted with $\envp$:
\[
\begin{array}{ll}
  \textbf{Configuration} & \withenviron{C}{\envp}\\
  \hline
  \Normal(\vv,\vg) & \text{undefined}\\
  \Normal((\vv,\vg), \env) & \Normal((\vv,\vg), \envp)\\
  \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \env) & \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \envp)\\
  \Normal(\vg, \env) & \Normal(\vg, \envp)\\
  \Normal(i=1..k: \vv_i, \vg) & \Normal(i=1..k: \vv_i, \vg)\\
  \Normal([i=1..k: (\vv_i,\vg_i)], \env) & \Normal([i=1..k: (\vv_i,\vg_i)], \envp)\\
  \Throwing((\valuereadfrom(\vx,\vv),\vg), \env) & \Throwing((\valuereadfrom(\vx,\vv),\vg), \envp)\\
  \Returning((i=1..k: \vv_i,\vg), \env) & \Returning((i=1..k: \vv_i,\vg), \envp)\\
  \Continuing(\vg, \env) & \Continuing(\vg, \envp)\\
\end{array}
\]

\section{Semantic Evaluation}
\hypertarget{def-evalrel}{}
\hypertarget{def-primitiverel}{}
The semantics of ASL is given by the relations\footnote{The reason that relations, rather than functions, are used is due to the
potential non-determinism in the primitive subprograms
and the non-determinism inherent in the \texttt{UNKNOWN} expression.}
\evalrel\ and \primitiverel.
The relation \evalrel\ is defined as the disjoint union of the relations defined in this document.
The relation \primitiverel\ provides the semantics of primitive subprograms and is not otherwise defined
constructively.

\subsection{Natural Operational Semantics}
We define the ASL semantics in the style of \emph{natural operational semantics}~\cite{SemanticsWithApplicationsBook}
(also known as \emph{big step semantics}).
Natural operational semantics evaluates the AST inductively.
That is, it concludes transitions for configurations starting from
non-leaf AST nodes by concluding transitions from configurations starting from their children nodes.

\subsubsection{No Undefined Behaviors}
When an input configuration does not satisfy any semantic rule,
there is no output configuration for it to transition to. We say that
the configuration is \emph{stuck} and the ASL semantics is undefined for that
input configuration.

The ASL semantics is defined for well-typed ASL specifications
and gets stuck only in cases of non-terminating specifications
(due to non-terminating loops, or infinite recursion).
Otherwise, for every input configuration there is at least one rule that can be used to take a semantic transition.

\hypertarget{eval-example}{}
\subsubsection{Evaluation Example}
\newcommand\elint[1]{\ELiteral(\lint(#1))}
The following example shows how to utilize the rules for expression literals and binary operator expressions
to derive a transition from an input configuration with the expression $(1+2)*(4+5)$,
given by the AST
\[
  \begin{array}{rl}
  \EBinop(\MUL, &\overname{\EBinop(\PLUS, \overname{\elint{1}}{\veone}, \overname{\elint{2}}{\vetwo})}{\veonetwo}, \\
                &\overname{\EBinop(\PLUS, \overname{\elint{4}}{\vefour}, \overname{\elint{5}}{\vefive})}{\vefourfive})
  \end{array}
\]
to an output configuration with the value resulting from the calculation of the expression.

We annotate sub-expressions to allow referring to them.

\hypertarget{def-emptyenv}{}
We write $\emptyenv$ to stand for a trivial environment (that is, one where all functions are empty).

Notice that, we have dropped the execution graph component and simplified pairs of the form $(\vv,\vg)$,
where $\vv$ is a native value and $\vg$ is an execution graph, to just $\vv$.
This is because we are interested in demonstrating the sequential semantics (also, the execution graphs
in this case are all empty).

The example shows (using references to the relevant rules on the right), how the expression for $1+2$ is evaluated
using the rule for literal expressions, the rule for binary operator (for addition), and the rules for binary expressions.
Similarly, the expression for $4+5$ is evaluated.
Finally, the transitions for both of the sub-expressions are used as premises for the binary expression
rule, along with the rule for binary operator (for multiplication), to evaluate the entire expression.

\begin{mathpar}
  \inferrule*[right=\ref{sec:SemanticsRule.Binop}]{
    \inferrule*[right=\ref{sec:SemanticsRule.Lit}]{}{ \evalexpr{\emptyenv, \veone} \evalarrow \Normal(\nvint(1), \emptyenv) } \\\\
    \inferrule*[right=\ref{sec:SemanticsRule.Lit}]{}{ \evalexpr{\emptyenv, \vetwo} \evalarrow \Normal(\nvint(2), \emptyenv) } \\\\
    \inferrule*[right=\ref{sec:SemanticsRule.BinopOperator}]{}{\binoprel(\PLUS, \nvint(1), \nvint(2)) \evalarrow \nvint(3)}
  }
  {
    \evalexpr{ \emptyenv, \veonetwo } \evalarrow
    \Normal(\nvint(3), \emptyenv)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule*[right=\ref{sec:SemanticsRule.Binop}]{
    \inferrule*[right=\ref{sec:SemanticsRule.Lit}]{}{ \evalexpr{\emptyenv, \vefour} \evalarrow \Normal(\nvint(4), \emptyenv) } \\\\
    \inferrule*[right=\ref{sec:SemanticsRule.Lit}]{}{ \evalexpr{\emptyenv, \vefive} \evalarrow \Normal(\nvint(5), \emptyenv) } \\\\
    \inferrule*[right=\ref{sec:SemanticsRule.BinopOperator}]{}{\binoprel(\PLUS, \nvint(4), \nvint(5)) \evalarrow \nvint(9)}
  }
  {
    \evalexpr{ \emptyenv, \vefourfive } \evalarrow
    \Normal(\nvint(9), \emptyenv)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule*[right=\ref{sec:SemanticsRule.Binop}]{
    \evalexpr{ \emptyenv, \veonetwo } \evalarrow \Normal(\nvint(3), \emptyenv)\\
    \evalexpr{ \emptyenv, \vefourfive } \evalarrow \Normal(\nvint(9), \emptyenv)\\
    \inferrule*[right=\ref{sec:SemanticsRule.BinopOperator}]{}{\binoprel(\MUL, \nvint(3), \nvint(9)) \evalarrow \nvint(27)}
  }
  {
    \evalexpr{ \emptyenv, \EBinop(\MUL, \veonetwo, \vefourfive) } \evalarrow
    \Normal(\nvint(27), \emptyenv)
  }
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Reading guide}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The set of rules for each type of AST node is further split according to the ``shape'' of the AST node.
For example, expressions are split into literal expressions, binary operation expressions, etc.
Each such subset of rules is named accordingly and appears in a section with the same name.
For example, the rule for literal expressions is named SemanticsRule.Lit\footnote{Sometimes rules are split into cases.
We then drop the SemanticsRule prefix from each case, for succinctness.
The same convention applies to helper rules.} and defined in
\secref{SemanticsRule.Lit}.

Each rule is presented using the following template:
\begin{itemize}
\item a Prose paragraph gives the rule in English, and corresponds, as much as possible, to the code of the reference implementation ASLRef given at
 \href{https://github.com/herd/herdtools7//tree/master/asllib}{/herdtools7/asllib};

 \item one or several Example paragraphs, which, as much as possible, are also given as regression tests in
\href{https://github.com/herd/herdtools7//tree/master/asllib/tests/ASLSemanticsReference.t}{/herdtools7/asllib/tests/ASLSemanticsReference.t};

\ifcode
\item a Code paragraph which gives a verbatim of the corresponding OCaml implementation in the interpreter of ASLRef
\href{https://github.com/herd/herdtools7//tree/master/asllib/Interpreter.ml}{/herdtools7/asllib/Interpreter.ml};
\fi

\ifformal
\item a Formal paragraph, which provides semantic rules that essentially give the same information as the Prose paragraph, for both
the sequential semantics and the concurrent semantics, in the form of concurrent execution graphs.
The latter enables defining, for each AArch64 instruction,
the Intrinsic dependencies used by the AArch64 memory model from the ASL code of the instruction~\cite[B2.3.2]{ArmARM}.
\fi

\item Comments paragraphs which may refer to one or more rules from the Language Reference Manual~\cite{LRM}
      and may add more information.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Expressions \label{chap:eval_expr}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The relation
\hypertarget{def-evalexpr}{}
\[
  \evalexpr{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
            \Normal((\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg}) \aslsep \overname{\envs}{\newenv}) \cup
            \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates the expression $\ve$ in an environment $\env$ and one of the following applies:
\begin{itemize}
  \item the evaluation terminates normally, returning a native value $\vv$, a concurrent execution graph $\vg$,
  and a modified environment $\newenv$;
  \item the evaluation terminates abnormally.
\end{itemize}

The evaluation of an expression is specialized by the shape of the expression $\ve$,
and one of the following applies:
\begin{itemize}
\item SemanticsRule.Lit (see Section~\ref{sec:SemanticsRule.Lit});
\item SemanticsRule.ELocalVar (see Section~\ref{sec:SemanticsRule.ELocalVar})
\item SemanticsRule.EGlobalVar (see Section~\ref{sec:SemanticsRule.EGlobalVar})
\item SemanticsRule.BinopAnd (see Section~\ref{sec:SemanticsRule.BinopAnd})
\item SemanticsRule.BinopOr (see Section~\ref{sec:SemanticsRule.BinopOr})
\item SemanticsRule.BinopImpl (see Section~\ref{sec:SemanticsRule.BinopImpl})
\item SemanticsRule.Binop (see Section~\ref{sec:SemanticsRule.Binop})
\item SemanticsRule.Unop (see Section~\ref{sec:SemanticsRule.Unop})
\item SemanticsRule.ECond (see Section~\ref{sec:SemanticsRule.ECond})
\item SemanticsRule.ESlice (see Section~\ref{sec:SemanticsRule.ESlice})
\item SemanticsRule.ECall (see Section~\ref{sec:SemanticsRule.ECall})
\item SemanticsRule.EGetArray (see Section~\ref{sec:SemanticsRule.EGetArray})
\item SemanticsRule.ERecord (see Section~\ref{sec:SemanticsRule.ERecord})
\item SemanticsRule.EGetField (see Section~\ref{sec:SemanticsRule.EGetField})
\item SemanticsRule.EConcat (see Section~\ref{sec:SemanticsRule.EConcat})
\item SemanticsRule.ETuple (see Section~\ref{sec:SemanticsRule.ETuple})
\item SemanticsRule.EUnknown (see Section~\ref{sec:SemanticsRule.EUnknown})
\item SemanticsRule.EPattern (see Section~\ref{sec:SemanticsRule.EPattern})
\item SemanticsRule.ATC (see Section~\ref{sec:SemanticsRule.ATC})
\item SemanticsRule.ATC (see Section~\ref{sec:SemanticsRule.ATC})
\end{itemize}

We also define the following helper relations:
\begin{itemize}
  \item SemanticsRule.EExprList (see Section~\ref{sec:SemanticsRule.EExprList});
  \item SemanticsRule.EExprListM (see Section~\ref{sec:SemanticsRule.EExprListM});
  \item SemanticsRule.ESideEffectFreeExpr (see Section~\ref{sec:SemanticsRule.ESideEffectFreeExpr});
\end{itemize}

\section{SemanticsRule.Lit \label{sec:SemanticsRule.Lit}}
\subsection{Prose}
  Evaluation of a literal expression $\ELiteral(\vv)$,
  in environment \env\ is the configuration
  $\Normal((\vres,\vg),\newenv)$ and all of the following apply:
  \begin{itemize}
  \item $\vres$ is the native value corresponding to $\vv$;
  \item $\vg$ is the empty graph, as literal do not yield any Read and Write Effects;
  \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example}
  In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Lit.asl}
  each of the expressions \texttt{3} evaluates to the native value $\nvint(3)$.

\CodeSubsection{\LitBegin}{\LitEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{\vres \eqdef \nvliteral{\vv} \\
  \vg \eqdef \emptygraph \\
  \newenv \eqdef \env}
  { \evalexpr{\env, \ELiteral(\vv)} \evalarrow \Normal((\vres,\vg), \env) }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ELocalVar \label{sec:SemanticsRule.ELocalVar}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is
  $\Normal((\vv, \vg), \newenv)$ and all of the following apply:
  Evaluation of the expression $\ve$ in an environment $\env$ is
  $\Normal((\vv, \vg), \newenv)$ and all of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a variable expression, $\EVar(\vx)$,
    which is bound locally in $\env$;
    \item $\vv$ is the value of $\vx$ in $\env$;
    \item $\newenv$ is $\env$.
    \item $\vg$ is the graph containing a single Read Effect for $\vx$.
  \end{itemize}

  \subsection{Example: SemanticsRuleELocalVar.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ELocalVar.asl}
    the evaluation of \texttt{x} within \texttt{assert x == 3;} uses SemanticsRule.ELocalVar.

  \CodeSubsection{\ELocalVarBegin}{\ELocalVarEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \env \eqname (\tenv, \denv)\\
    \vx \in \dom(L^\denv)\\
    \vv \eqdef L^\denv(\vx) \\
    \vg \eqdef \ReadEffect(\vx)\\
    \newenv \eqname \env
  }
  {\evalexpr{\env, \EVar(\vx)} \evalarrow \Normal((\vv, \vg), \newenv)}
  \end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  When there exists a global variable $\vx$, the type system
  forbids having $\vx$ as a local variable.
  This is enforced by TypingRule.LDVar and TypingRule.DeclareOneFunc.

\section{SemanticsRule.EGlobalVar \label{sec:SemanticsRule.EGlobalVar}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is
  $\Normal((\vv, \vg), \newenv)$ and all of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a variable expression, $\EVar(\vx)$, which is bound globally in $\env$;
    \item $\vv$ is the value of $\vx$ in $\env$;
    \item $\newenv$ is $\env$.
    \item $\vg$ is the graph containing a single Read Effect for $\vx$.
  \end{itemize}

  \subsection{Example: SemanticsRuleEGlobalVar.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGlobalVar.asl}
    the evaluation of~\texttt{global\_x} within~\texttt{assert global\_x == 3;}
    uses the rule \\ SemanticsRule.EGlobalVar.

  \CodeSubsection{\EGlobalVarBegin}{\EGlobalVarEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \env \eqname (\tenv, \denv)\\
    \vx \in \dom(G^\denv)\\
    \vv \eqdef G^\denv(\vx) \\
    \vg \eqdef \ReadEffect(\vx)\\
    \newenv \eqname \env
  }
  {\evalexpr{\denv, \EVar(\vx)} \evalarrow \Normal((\vv, \vg), \newenv)}
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.BinopAnd \label{sec:SemanticsRule.BinopAnd}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is the configuration $C$,
  and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a conjunction over two expressions,
  $\EBinop(\BAND, \veone, \vetwo)$;
  \item $C$ is the result of the evaluation of the expression
  \texttt{if e1 then e2 else false} (see \secref{SemanticsRule.ECond}).
  \end{itemize}
  \subsection{Example: SemanticsRule.EBinopAndFalse.asl}

 \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopAndFalse.asl}
    the expression \texttt{FALSE \&\& fail()} evaluates to the value \texttt{FALSE}. Notice that the function \texttt{fail} is never called.


  \CodeSubsection{\BinopAndBegin}{\BinopAndEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \falsep \eqdef \ELiteral(\lbool(\False))\\
    \evalexpr{\env, \ECond(\veone, \vetwo, \falsep)} \evalarrow C
  }
  {
  \evalexpr{\env, \EBinop(\BAND, \veone, \vetwo)} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
  it evalutes to \True, is $\vetwo$ evaluated.

  This is related to \identr{BKNT}, \identr{XKGC} and \identi{QRXP}.

\section{SemanticsRule.BinopOr \label{sec:SemanticsRule.BinopOr}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is
  the configuration $C$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a disjunction of two expressions, $\EBinop(\BOR, \veone, \vetwo)$;
  \item $C$ is the result of the evaluation of
  \texttt{if e1 then true else e2} (see \secref{SemanticsRule.ECond}).
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopOrTrue.asl}
\VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopOrTrue.asl}
  The expression \texttt{(0 == 1) || (1 == 1)} evaluates to the value \True.


  \CodeSubsection{\BinopOrBegin}{\BinopOrEnd}{../Interpreter.ml}

\begin{emptyformal}
  \begin{mathpar}
    \inferrule{
      \truep \eqdef \ELiteral(\lbool(\True))\\
      \evalexpr{\env, \ECond(\veone, \truep, \texttt{e2})} \evalarrow C
    }
    {
    \evalexpr{\env, \EBinop(\BOR, \veone, \texttt{e2})} \evalarrow C
    }
  \end{mathpar}
  The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
  it evalutes to \True, is $\vetwo$ evaluated.
\end{emptyformal}

  \subsection{Comments}
  This is related to \identr{BKNT}, \identr{XKGC} and \identi{QRXP}.

\section{SemanticsRule.BinopImpl \label{sec:SemanticsRule.BinopImpl}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is
  the configuration $C$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes an implication over two expressions, $\EBinop(\IMPL, \veone, \vetwo)$;
  \item $\ve$ is evaluated as \texttt{if e1 then e2 else true}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopImplExFalso.asl}
\VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopImplExFalso.asl}
the expression \texttt{(0 == 1) --> (1 == 0)} evaluates to the value \True, according to the definition of implication.


  \CodeSubsection{\BinopImplBegin}{\BinopImplEnd}{../Interpreter.ml}
\begin{emptyformal}
  \begin{mathpar}
    \inferrule{
      \truep \eqdef \ELiteral(\lbool(\True))\\
      \evalexpr{\env, \ECond(\veone, \vetwo, \truep)} \evalarrow C
    }
    {
    \evalexpr{\env, \EBinop(\IMPL, \veone, \vetwo)} \evalarrow C
    }
  \end{mathpar}
  The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
  it evalutes to \True, is $\vetwo$ evaluated.
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{BKNT}, and \identi{QRXP}.

\section{SemanticsRule.Binop \label{sec:SemanticsRule.Binop}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is either $\Normal((\vv, \vg), \newenv)$,
  or an abnormal configuration, and all of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a Binary Operator $\op$ over two expressions, $\EBinop(\op, \veone, \vetwo)$;
    \item the operator is not one of $\BAND$, $\BOR$, or $\IMPL$, which are handled by the
    rule presented previoiusly;
    \item the evaluation of the expression $\veone$ in $\env$ is the configuration $\Normal(\vmone, \envone)$,
    \ProseOrAbnormal;
    \item the evaluation of the expression $\vetwo$ in $\envone$ is the configuration \\ $\Normal(\vmtwo, \newenv)$,
    \ProseOrAbnormal;
    \item $\vmone$ consists of the value $\vvone$ and the execution graph $\vgone$;
    \item $\vmtwo$ consists of the value $\vvtwo$ and the execution graph $\vgtwo$;
    \item applying the Binary Operator $\op$ to $\vvone$ and $\vvtwo$ results in either $\vv$,
    or an error, which short-circuits the entire evaluation;
    \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopPlusAssert.asl}
    In this specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopPlusAssert.asl}
    the expression \texttt{3 + 2} evaluates to the value \texttt{5}.

  \subsection{Example: \\ SemanticsRule.EDIVBackendDefinedError.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopDIVBackendDefinedError.asl}
    the expression \texttt{3 DIV 0} results in a type error.


  \CodeSubsection{\BinopBegin}{\BinopEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\
      \evalexpr{ \env, \veone} \evalarrow \Normal(\vmone, \envone) \OrAbnormal \\\\
      \evalexpr{ \envone, \vetwo } \evalarrow \Normal(\vmtwo, \newenv) \OrAbnormal \\\\
      \vmone \eqname (\vvone, \vgone) \\
      \vmtwo \eqname (\vvtwo, \vgtwo) \\
      \binoprel(\op, \vvone, \vvtwo) \evalarrow \vv \terminateas \ErrorConfig\\\\
      \vg \eqdef \vgone \parallelcomp \vgtwo
    }
    {
      \evalexpr{ \env, \EBinop(\op, \veone, \vetwo) } \evalarrow
      \Normal((\vv, \vg), \newenv)
    }
  \end{mathpar}
  The rule above applies to many binary operators, including $\EQOP$ (which is used for \texttt{<->}
  as well as \texttt{==}).
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{XKGC} and \identr{BKNT}.

Notice that when one of the sub-expressions terminates exceptionally,
the other expression must be side effect-free and non-throwing (\identi{QJTN}).

The semantics takes a semantic transition over the left sub-expression before the right sub-expression.
This is an arbitrary choice as the type-checker must ensure that either order of evaluation of the operands
yields the same result.

\section{SemanticsRule.Unop \label{sec:SemanticsRule.Unop}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is either \\
  $\Normal((\vv, \vg), \newenv)$,
  or an abnormal configuration, and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a Unary Operator $\op$ over an expression, $\EUnop(\op, \veone)$;
  \item the evaluation of the expression $\veone$ in $\env$ is either \\ $\Normal((\vvone, \vg), \newenv)$,
  or an abnormal configuration, which circuits the entire evaluation;
  \item applying the Unary Operator $\op$ to $\vvone$ is $\vv$.
  \end{itemize}

  \subsection{Example: SemanticsRule.EUnopAssert.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnopAssert.asl}
    the expression \texttt{NOT '1010'} evaluates to the value \texttt{'0101'}.


  \CodeSubsection{\UnopBegin}{\UnopEnd}{../Interpreter.ml}

\begin{emptyformal}
\begin{mathpar}
  \inferrule{
    \evalexpr{ \env, \veone} \evalarrow \Normal((\vvone,\vg), \newenv) \OrAbnormal\\\\
    \unoprel(\op, \vvone) \evalarrow \vv
  }
  {
    \evalexpr{ \env, \EUnop(\op, \veone) } \evalarrow
    \Normal((\vv, \vg), \newenv)
  }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ECond \label{sec:SemanticsRule.ECond}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is either $\Normal((\vv, \vg), \newenv)$,
  or an abnormal configuration, and all of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a conditional expression $\econd$ with two options $\veone$ and $\vetwo$,
    that is, $\ECond(\econd, \veone, \vetwo)$;
    \item the evaluation of the conditional expression $\econd$ in $\env$ is either \\
    $\Normal(\mcond, \envone)$, \ProseOrAbnormal;
    \item $\mcond$ consists of a native Boolean for $\vb$ and execution graph $\vgone$;
    \item $\vep$ is $\veone$ if $\vb$ is $\True$ and $\vetwo$ otherwise;
    \item the evaluation of $\vep$ in $\envone$ is either $\Normal((\vvtwo, \vgtwo), \newenv)$,
      \ProseOrAbnormal;
    \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ECondFalse.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECondFalse.asl}
    the expression \texttt{if FALSE then Return42() else 3} evaluates to the value \texttt{3}.

  \subsection{Example: \\ SemanticsRule.ECondUNKNOWN3or42.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECondUNKNOWN3or42.asl}
the expression \texttt{if UNKNOWN: boolean then 3 else Return42()} will
evaluate either \texttt{3} or \texttt{Return42()} depending on how
\texttt{UNKNOWN} is implemented.


  \CodeSubsection{\ECondBegin}{\ECondEnd}{../Interpreter.ml}

\begin{emptyformal}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ECond} \evalarrow \Normal(\mcond, \envone) \OrAbnormal\\\\
    \mcond \eqname (\nvbool(\vb), \vgone)\\
    \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\\\
    \evalexpr{\envone, \vep} \evalarrow \Normal((\vv, \vgtwo), \newenv)  \OrAbnormal\\\\
    \vg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
  }
  {
    \evalexpr{\env, \ECond(\ECond, \veone, \vetwo)} \evalarrow
    \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  This is related to \identr{YCDB}.

\section{SemanticsRule.ESlice \label{sec:SemanticsRule.ESlice}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is either $\Normal((\vv, \vg), \newenv)$,
  or an abnormal configuration, and all of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a slicing expression, $\ESlice(\ebv, \slices)$;
    \item the evaluation of $\ebv$ in $\env$ is either $\Normal(\mbv, \envone)$,
    \ProseOrAbnormal;
    \item the evaluation of $\slices$ in $\env$ is either $\Normal(\mpositions, \envone)$,
    \ProseOrAbnormal;
    \item $\mpositions$ consists of $\positions$ --- all the indices that need to be added to the
    resulting bitvector --- and the execution graph $\vgone$;
    \item reading from $\vbv$ as a bitvector at the indices indicated by $\positions$
    (see \secref{SemanticsRule.ReadFromBitvector}) either results in the bitvector $\vv$,
    which concatenates all of the values from the indicates indices,
    \ProseOrError;
    \item $\newenv$ is $\envone$;
    \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ESlice.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ESlice.asl}
    the expression \texttt{'11110000'[6:3]} evaluates to the value \texttt{'1110'}.


  \CodeSubsection{\ESliceBegin}{\ESliceEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ebv} \evalarrow \Normal(\mbv, \envone)  \OrAbnormal\\\\
    \mbv \eqname (\vbv,\vgone) \\
    \evalslices{\envone, \slices} \evalarrow \Normal(\mpositions, \envone)  \OrAbnormal \\
    \mpositions \eqname (\positions, \vgtwo) \\
    \readfrombitvector(\vbv, \positions) \evalarrow \vv \terminateas \ErrorConfig\\
    \newenv \eqdef\envone \\
    \vg \eqdef \vgone \parallelcomp \vgtwo
  }
  {
    \evalexpr{\env, \ESlice(\ebv, \slices)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ECall \label{sec:SemanticsRule.ECall}}
  Evaluation of the expression $\ve$ in an environment $\env$ is either $\Normal((\vv, \vg), \newenv)$,
  or an abnormal configuration, and all of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a subprogram call, $\ECall(\name, \actualargs, \params)$;
    \item the evaluation of that subprogram call in $\env$ is either
    $\Normal(\vms, \newenv)$, or an abnormal configuration,
    which short-circuits the entire evaluation;
    \item one of the following apply:
    \begin{itemize}
      \item all of the following apply (\textsc{single\_returned\_value}):
      \begin{itemize}
        \item $\vms$ consists of a single returned value $(\vv,\vg)$,
        which go into the output configuration $\Normal((\vv, \vg), \newenv)$.
      \end{itemize}

      \item all of the following apply (\textsc{multipe\_returned\_values}):
      \begin{itemize}
        \item $\vms$ consists of a list of returned value $(\vv_i,\vg_i)$, for $i=1..k$;
        \item $\vg$ is the parallel composition of $\vg_i$, for $i=1..k$;
        \item $\vv$ is the native value vector of values $\vv_i$, for $i=1..k$;
        \item the resulting configuration is $\Normal((\vv, \vg), \newenv)$.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.ECall.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECall.asl}
    the expression \texttt{Return42()} evaluates to the value \texttt{42} because the
    subprogram \texttt{Return42()} is implemented to return the value \texttt{42}.


  \CodeSubsection{\ECallBegin}{\ECallEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule[single\_returned\_value]{
    \evalcall{\env, \name, \actualargs, \params} \evalarrow \Normal(\vms, \newenv) \OrAbnormal\\
    \vms \eqname [(\vv, \vg)]
  }
  {
    \evalexpr{\env, \ECall(\name, \actualargs, \params)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\and
\inferrule[multiple\_returned\_values]{
  \evalcall{\env, \name, \actualargs, \params} \evalarrow \Normal(\vms, \newenv) \OrAbnormal\\
  \vms \eqname [i=1..k: (\vv_i, \vg_i)]\\
  \vg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k \\
  \vv \eqdef \nvvector{\vv_{1..k}}
}
{
  \evalexpr{\env, \ECall(\name, \actualargs, \params)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EGetArray \label{sec:SemanticsRule.EGetArray}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is either \\
  $\Normal((\vv, \vg), \newenv)$, or an abnormal configuration, and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes an array access expression, $\EGetArray(\earray, \eindex)$;
  \item the evaluation of $\earray$ in $\env$ is either $\Normal(\marray, \envone)$,
  \ProseOrAbnormal;
  \item the evaluation of $\eindex$ in $\env$ is either  $\Normal(\mindex, \newenv)$,
  \ProseOrAbnormal;
  \item $\marray$ consists of the native vector $\varray$ and execution graph $\vgone$;
  \item $\mindex$ consists of the native integer $\vindex$ and execution graph $\vgtwo$;
  \item $\vindex$ is the native integer for $\vi$;
  \item evaluating the value at index $\vi$ of $\varray$ is $\vv$;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
  \end{itemize}

  \subsection{Example: SemanticsRule.EGetArray.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGetArray.asl}
    the expression \texttt{my\_array[2]} appearing in the assertion evaluates to the value \texttt{42} since the element
    indexed by \texttt{2} in \texttt{my\_array} is \texttt{42}.

  \subsection{Example: SemanticsRule.EGetArrayTooSmall.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGetArrayTooSmall.asl}
    results in a typing error since we are trying to access index \texttt{3} of an array
    which has indexes \texttt{0}, \texttt{1} and \texttt{2} only.


  \CodeSubsection{\EGetArrayBegin}{\EGetArrayEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \evalexpr{\env, \earray} \evalarrow \Normal(\marray, \envone)  \OrAbnormal\\
      \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \newenv)  \OrAbnormal\\
      \marray \eqname (\varray, \vgone)\\
      \mindex \eqname (\vindex, \vgtwo)\\
      \vindex \eqname \nvint(\vi)\\
      \getindex(\vi, \varray) \evalarrow \vv\\
      \vg \eqdef \vgone \parallelcomp \vgtwo\\
    }
    {
      \evalexpr{\env, \EGetArray(\earray, \eindex)} \evalarrow \Normal((\vv, \vg), \newenv)
    }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ERecord \label{sec:SemanticsRule.ERecord}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is either \\
  $\Normal((\vv, \vg), \newenv)$, or an abnormal configuration, and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a record creation expression, $\ERecord(\names, \efields)$;
  \item the names of of the fields are $\id_{1..k}$;
  \item the expressions associated with the fields are $\ve_{1..k}$;
  \item evaluating the expressions of $\fields$ in order either
  results in \\
  $\Normal((\vvfields,\vg), \newenv)$, \ProseOrAbnormal;
  \item $\vvfields$ is a list of native values $\vv_{1..k}$;
  \item $\vv$ is the native record that maps $\id_i$ to $\vv_i$, for $i=1..k$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ERecord.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ERecord.asl}
    the expression \texttt{MyRecordType \{ a=3, b=42 \}} evaluates to the value
    \texttt{\{a: 3, b: 42\}}.


  \CodeSubsection{\ERecordBegin}{\ERecordEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \efields \eqname [i=1..k: (\id_i, \ve_i)]\\
    \names \eqdef \id_{1..k} \\
    \fields \eqdef \ve_{1..k} \\
    \evalexprlist{\env, \fields} \evalarrow \Normal((\vvfields,\vg), \newenv)  \OrAbnormal\\
    \vvfields \eqname \vv_{1..k}\\
    \vv \eqdef \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}}
  }
  {
    \evalexpr{\env, \ERecord(\Ignore, \efields)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EGetField \label{sec:SemanticsRule.EGetField}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is either \\
  $\Normal((\vv, \vg), \newenv)$, or an abnormal configuration, and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a field access expression, $\EGetField(\erecord, \fieldname)$;
  \item the evaluation of $\erecord$ in $\env$ is either $\Normal((\vrecord, \vg), \newenv)$,
  \ProseOrAbnormal;
  \item $\vv$ is the value mapped by $\fieldname$ in the native record $\vrecord$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ERecord.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ERecord.asl}
    the expression \texttt{my\_record.a} evaluates to the value \texttt{3}.


  \CodeSubsection{\EGetFieldBegin}{\EGetFieldEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \erecord} \evalarrow \Normal((\vrecord, \vg), \newenv)  \OrAbnormal\\
    \getfield(\fieldname, \vrecord) \evalarrow \vv
  }
  {
    \evalexpr{\env, \EGetField(\erecord, \fieldname)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EConcat \label{sec:SemanticsRule.EConcat}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is either \\
  $\Normal((\vv, \vg), \newenv)$, or an abnormal configuration, and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a concatenation of bitvector expressions, $\EConcat(\elist)$;
  \item the evaluation of $\elist$ in $\env$ is either $\Normal((\vlist, \vg), \newenv)$,
  \ProseOrAbnormal;
  \item $\vv$ is the bitvector constructed from the concatenation of $\vlist$.
  \end{itemize}

  \subsection{Example: SemanticsRule.EConcat}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EConcat.asl}
    the expression \texttt{['10', '11']} evaluates to the value \texttt{'1011'}.


  \CodeSubsection{\EConcatBegin}{\EConcatEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \newenv)  \OrAbnormal\\
    \concatbitvectors(\vlist) \evalarrow \vv
  }
  {
    \evalexpr{\env, \EConcat(\elist)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{BRCM}.

\section{SemanticsRule.ETuple \label{sec:SemanticsRule.ETuple}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is either \\
  $\Normal((\vv, \vg), \newenv)$, or an abnormal configuration, and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a tuple expression, $\ETuple(\elist)$;
  \item the evaluation of $\elist$ in $\env$ is either $\Normal((\vlist, \vg), \newenv)$,
  \ProseOrAbnormal;
  \item $\vv$ is the native vector constructed from the values in $\vlist$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ETuple.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ETuple.asl}
    the expression \texttt{(3, Return42())} evaluates to the value \texttt{(3, 42)}.


  \CodeSubsection{\ETupleBegin}{\ETupleEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \newenv)  \OrAbnormal\\
    \vv \eqdef \nvvector{\vlist}
  }
  {
    \evalexpr{\env, \ETuple(\elist)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EUnknown \label{sec:SemanticsRule.EUnknown}}
  \begin{definition}[Domain of a Type]
  The domain of a type $\vt$ in an environment $\env=(\tenv,\denv)$,
  denoted by $\textsf{dyn-dom}(\tenv, \denv, \vt)$, is defined by the type system~\cite{ASLTypingReference}
  (TypingRule.Domain)
  as the set of values that $\vt$ may store in $\env$. The reason that the dynamic environment is
  needed to determine the domain is due to subprogram parameters, which constrain integer parameters to
  a singleton value domain.
  \end{definition}

  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is \\
  $\Normal((\vv, \vg), \newenv)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes the \texttt{UNKNOWN} expression annotated with type $\vt$;
  \item $\vv$ is an arbitrary value in the domain of $\vt$ in $\env$;
  \item $\newenv$ is $\env$.
  \item $\vg$ is the empty execution graph.
  \end{itemize}

  \subsection{Example: SemanticsRule.EUnknownInteger3.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnknownInteger3.asl}
    the expression \texttt{[UNKNOWN : integer]} evaluates to an integer value.

  \subsection{Example: \\ SemanticsRule.EUnknownIntegerRange3-42-3.asl}

    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnknownIntegerRange3-42-3.asl}
    the expression \texttt{UNKNOWN : integer \{3, 42\}} evaluates to either the value
\texttt{3} or the value \texttt{42}.


  \CodeSubsection{\EUnknownBegin}{\EUnknownEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{\env \eqname (\tenv, \denv)\\
    \vv \in \textsf{dyn-dom}(\tenv, \env, \vt) \\
  \newenv \eqdef\env
  }
  {
    \evalexpr{\env, \EUnknown} \evalarrow \Normal(\newenv, \vv, \emptygraph)
  }
\end{mathpar}
Notice that this rule introduces non-determinism.
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WLCH}.

\section{SemanticsRule.EPattern \label{sec:SemanticsRule.EPattern}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is
  $\Normal((\vv, \vg), \newenv)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a pattern expression, $\EPattern(\ve, \vp)$;
  \item evaluating the expression $\ve$ in an environment $\env$ either results in \\
  $\Normal((\vvone, \vgone), \newenv)$, \ProseOrAbnormal;
  \item evaluating whether the pattern $\vp$ matches the value $\vvone$ in $\env$
  results in $\Normal(\vv, \vgtwo)$ where is a native Boolean that determines
  whether the is indeed a match;
  \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
  \end{itemize}

  \subsection{Example: SemanticsRule.EPatternFALSE.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EPatternFALSE.asl}
    the expression \texttt{42 IN \{0..3, -4\}} evaluates to the value \texttt{FALSE}.

  \subsection{Example: SemanticsRule.EPatternTRUE.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EPatternTRUE.asl}
    the expression \texttt{42 IN \{0..3, 42\}} evaluates to \True.


  \CodeSubsection{\EPatternBegin}{\EPatternEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \newenv)  \OrAbnormal\\
    \evalpattern{\env, \vvone, \vp} \evalarrow \Normal(\vv, \vgtwo)\\
    \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalexpr{\env, \EPattern(\ve, \vp)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ATC \label{sec:SemanticsRule.ATC}}
\section{SemanticsRule.ATC \label{sec:SemanticsRule.ATC}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ in an environment $\env$ is \\
  $\Normal((\vv, \vg), \newenv)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes an asserted type conversion expression, $\EATC(\veone, \vt)$;
  \item evaluating $\veone$ in $\env$ either results in \Normal((\vv, \vgone), \newenv),
  \ProseOrAbnormal;
  \item evaluating whether $\vv$ has type $\vt$ in $\env$ either results in (\vb, \vgtwo)
  or in an error configuration, which short-circuits the entire evaluation;
  \item one of the following applies:
        \begin{itemize}
        \item all of the following apply (\textsc{okay}):
              \begin{itemize}
              \item $\vb$ is the native Boolean for \True;
              \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
              \end{itemize}
        \item all of the following apply (\textsc{error}):
              \begin{itemize}
              \item $\vb$ is the native Boolean for \True;
              \item an asserted type conversion error is returned.
              \end{itemize}
        \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.ATCValue.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ATCValue.asl}

  \subsection{Example: SemanticsRule.ATCError.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ATCError.asl}


  \CodeSubsection{\ATCBegin}{\ATCEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule[okay]{
    \evalexpr{\env, \veone} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\\\
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vgtwo) \terminateas \ErrorConfig\\\\
    \vb \eqname \nvbool(\True)\\
    \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalexpr{\env, \EATC(\veone, \vt)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\and
\inferrule[error]{
  \evalexpr{\env, \veone} \evalarrow \Normal((\vv, \Ignore), \Ignore)\\
  \neg\isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \Ignore)\\
  \vb \eqname \nvbool(\False)
}
{
  \evalexpr{\env, \EATC(\veone, \vt)} \evalarrow \ErrorVal{ATC\_TypeMismatch}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WZVX}, \identi{VQLX}, \identr{YCPX}, \identi{TCST}, \identi{CGRH}.

\section{SemanticsRule.EExprList \label{sec:SemanticsRule.EExprList}}
\subsection{Prose}
The relation
\hypertarget{def-evalexprlist}{}
\[
  \evalexprlist{\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vle}} \;\aslrel\;
  \Normal((\overname{\vals^*}{\vv} \times \overname{\XGraphs}{\vg})\aslsep \overname{\envs}{\newenv}) \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates the list of expressions $\vle$ in left-to-right order in the initial environment $\env$
and returns the resulting value $\vv$, the parallel composition of the execution graphs
generated from evaluating each expression, and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[empty]{}
  {
    \evalexprlist{\env, \emptylist} \evalarrow \Normal((\emptylist, \emptygraph), \env)
  }
\and
  \inferrule[nonempty]{
    \texttt{le} \eqname [\ve] \concat \vle1\\
    \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \envone) \OrAbnormal\\
    \evalexprlist{\envone, \vle1} \evalarrow \Normal((\vvs, \vgtwo), \newenv) \OrAbnormal\\
    \vg \eqdef \vgone \parallelcomp \vgtwo \\
    \vv \eqdef [\vvone] \concat \vvs
  }
  {
    \evalexprlist{\env, \vle} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.EExprListM \label{sec:SemanticsRule.EExprListM}}
\subsection{Prose}
The relation
\[
  \evalexprlistm{\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vle}} \;\aslrel\;
          \Normal(\overname{(\vals\times\XGraphs)^* }{\vms} \aslsep \envs) \cup
          \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates a list of expressions $\vle$ in left-to-right in the initial environment $\env$
and returns the list of values associated with graphs $\vms$ and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[empty]{}
  {
    \evalexprlistm{\env, \emptylist} \evalarrow \Normal((\emptylist, \emptygraph), \env)
  }
\and
  \inferrule[nonempty]{
    \vle \eqname [\ve] \concat \vle1\\
    \vms \eqname [\vmone] \concat \vmsone\\
    \evalexpr{\env, \ve} \evalarrow \Normal(\vmtwo, \envone) \OrAbnormal\\
    \evalexprlistm{\envone, \vle1} \evalarrow \Normal(\vmstwo, \newenv) \OrAbnormal
  }
  {
    \evalexprlistm{\env, \vle} \evalarrow \Normal([\vmtwo]\concat\vmstwo, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.ESideEffectFreeExpr \label{sec:SemanticsRule.ESideEffectFreeExpr}}
\subsection{Prose}
The relation
\hypertarget{def-evalexprsef}{}
\[
  \evalexprsef{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
  \Normal(\overname{\vals}{\vv}\aslsep\overname{\XGraphs}{\vg}) \cup
  \overname{\TError}{\ErrorConfig}
\]
specializes the expression evaluation relation for side-effect-free expressions
by omitting throwing configurations as possible output configurations.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv,\vg), \env) \terminateas \ErrorConfig
  }
  {
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vv, \vg)
  }
\end{mathpar}
Notice that the output configuration does not contain an environment,
since side-effect-free expressions do not modify the environment.
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Left-Hand Side Expressions \label{chap:eval_lexpr}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The relation
\hypertarget{def-evallexpr}{}
\[
  \evallexpr{\overname{\envs}{\env} \aslsep \overname{\lexpr}{\vle} \aslsep (\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg})} \;\aslrel\;
    \Normal(\overname{\XGraphs}{\newg},\overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates the assignment of a value $\vv$
to the left-hand-side expression $\vle$ in an environment $\env$,
resulting in either a configuration $\Normal(\newg, \env)$ or an abnormal configuration.

One of the following applies:
\begin{itemize}
\item SemanticsRule.LEDiscard (see Section~\ref{sec:SemanticsRule.LEDiscard});
\item SemanticsRule.LELocalVar (see Section~\ref{sec:SemanticsRule.LELocalVar});
\item SemanticsRule.LEGlobalVar (see Section~\ref{sec:SemanticsRule.LEGlobalVar});
\item SemanticsRule.LESlice (see Section~\ref{sec:SemanticsRule.LESlice});
\item SemanticsRule.LESetArray (see Section~\ref{sec:SemanticsRule.LESetArray});
\item SemanticsRule.LESetField (see Section~\ref{sec:SemanticsRule.LESetField});
\item SemanticsRule.LEDestructuring (see Section~\ref{sec:SemanticsRule.LEDestructuring}).
\end{itemize}

We also define the helper rule SemanticsRule.LEMultiAssign (\ref{sec:SemanticsRuleLEMultiAssign}).

\hypertarget{def-rexpr}{}
Some of the rules require viewing left-hand-side expressions as their corresponding right-hand side expressions.
The correspondence is defined in the ASL Syntax Reference~\cite[Chapter 5]{ASLAbstractSyntaxReference}
and given by the function $\torexpr : \lexpr \rightarrow \expr$.
%
For example, \hyperlink{SemanticsRule.LESetField}{SemanticsRule.LESetField}
needs to evaluate the record sub-expression $\rerecord$, which is a left-hand-side expression.
To achieve this, $\torexpr(\record)$ is used to obtain a right-hand-side expression, which then allows
using $\texttt{eval\_expr}$ to evaluate it.

\paragraph{Naming Convention:}
In this chapter, variables containing $\vm$ range over $\vals\times\XGraphs$
while variables where the $\vm$ is replaced with $\vv$ correspond to their value component.
For example, $\rmarray\eqname(\rvarray,\vgtwo)$ and $\mindex\eqname(\vindex, \vgone)$.

\section{SemanticsRule.LEDiscard \label{sec:SemanticsRule.LEDiscard}}
    \subsection{Prose}
    Evaluation of the left-hand-side expression $\vle$ associated with a
    value $\vv$ in an environment $\env$ is $\Normal(\newg, \newenv)$
    and all of the following apply:
    \begin{itemize}
    \item $\vle$ is a discarding expression, $\LEDiscard$;
    \item $\newg$ is $\vg$;
    \item $\newenv$ is $\env$.
    \end{itemize}

  \subsection{Example: SemanticsRule.LEDiscard.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEDiscard.asl}
  \texttt{- = 42;} does not affect the environment.


  \CodeSubsection{\LEDiscardBegin}{\LEDiscardEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \newg\eqdef\vg\\
      \newenv\eqdef\env
    }
    { \evallexpr{\env, \LEDiscard, (\vv, \vg)} \evalarrow \Normal(\newg, \newenv) }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LELocalVar \label{sec:SemanticsRule.LELocalVar}}
  \subsection{Prose}
  Evaluation of the left-hand-side expression $\vle$ associated with a
  value $\vv$ in an environment $\env$ is $\Normal(\newg, \newenv)$
  and all of the following apply:
  \begin{itemize}
  \item $\vle$ denotes a variable, $\LEVar(\vx)$;
  \item $\vx$ is locally bound in $\env$;
  \item $\newg$ is the ordered composition of $\vg$ and a Write Effect for $\vx$ with the $\asldata$ edge;
  \item $\newenv$ is $\env$ where $\vx$ is bound to $\vv$ in the local component of the environment.
  \end{itemize}

  \subsection{Example: SemanticsRule.LELocalVar.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LELocalVar.asl}
  SemanticsRule.LELocalVar is (only) used to assign the value $42$ to the left-hand-side expression
  \texttt{x} within \texttt{x = 42;}.


  \CodeSubsection{\LELocalVarBegin}{\LELocalVarEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \env \eqname (\tenv, \denv)\\
      \vx \in \dom(L^\denv)\\
      \newenv \eqdef (\tenv, (G^\denv, L^\denv[\vx \mapsto \vv]))\\
      \newg \eqdef \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
    }
    { \evallexpr{\env, \LEVar(\vx), (\vv, \vg)} \evalarrow \Normal(\newg,\newenv) }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LEGlobalVar \label{sec:SemanticsRule.LEGlobalVar}}
  \subsection{Prose}
  Evaluation of the left-hand-side expression $\vle$ associated with a
  value $\vv$ in an environment $\env$ is $\Normal(\newg, \newenv)$
  and all of the following apply:
  \begin{itemize}
    \item $\vle$ denotes a variable $\vx$, $\LEVar(\vx)$;
    \item $\vx$ is globally bound in $\env$;
    \item $\newg$ is the ordered composition of $\vg$ and a Write Effect for $\vx$ with the $\asldata$ edge;
    \item $\newenv$ is $\env$ where $\vx$ is bound to $\vv$ in the global component of the environment.
    \end{itemize}

  \subsection{Example: SemanticsRule.LEGlobalVar.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEGlobalVar.asl}
  SemanticsRule.LEGlobalVar is (only) used to assign the value $42$ to the left-hand-side expression
  \texttt{x} within \texttt{x = 42;}.


  \CodeSubsection{\LEGlobalVarBegin}{\LEGlobalVarEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \env \eqname (\tenv, \denv)\\
      \vx \in \dom(G^\denv)\\
      \newenv \eqdef(\tenv, (G^\denv[\vx \mapsto \vv], L^\denv))\\
      \newg \eqdef \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
    }
    { \evallexpr{\env, \LEVar(\vx), (\vv, \vg)} \evalarrow \Normal(\newg,\newenv) }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LESlice \label{sec:SemanticsRule.LESlice}}
  \subsection{Prose}
  Evaluation of the left-hand-side expression $\vle$ associated with a
  value $\vv$ in an environment $\env$ is the output configuration $C$
  and all of the following apply:
  \begin{itemize}
    \item $\vle$ denotes a left-hand-side slicing expression, $\LESlice(\ebv, \slices)$;
    \item evaluating the right-hand-side expression that corresponds to $\ebv$
    (given by applying $\torexpr$ to $\ebv$) in $\env$
      is either $\Normal(\mbv,\envone)$, \ProseOrAbnormal;
    \item evaluating $\slices$ in $\envone$ is either $\Normal(\mpositions, \envtwo)$,
    \ProseOrAbnormal;
    \item $\mpositions$ consists of the execution graph $\vgone$ and the list of indices $\positions$;
    \item $\mbv$ consists of the native bitvector $\vbv$ and the execution graph $\vgtwo$;
    \item writing to the bitvector $\vbv$ at indices $\positions$ using the values from $\vv$
    results in the updated native bitvector $\vvone$ \ProseOrError;
    \item $\vgthree$ is the parallel composition of $\vg$, $\vgone$, and $\vgtwo$;
    \item $\newmbv$ is a pair consisting of $\vvone$ and the execution graph $\vgthree$;
    \item the steps so far computed the updated bitvector, but have not assigned it to the
    variable bound to the bitvector given by $\ebv$, which is achieved next.
    Evaluating the left-hand-side expression $\ebv$ with
    $\newmbv$ in an environment $\envtwo$ is the output configuration $C$,
  \end{itemize}

   \subsection{Example: SemanticsRule.LESlice.asl}
   In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESlice.asl}
   \texttt{x[3:0] = '0000'} binds \texttt{x} to \texttt{'11110000'}
   via the rule SemanticsRule.LESlice.asl
   in the environment where \texttt{x} is bound to \texttt{'11111111'}.


  \CodeSubsection{\LESliceBegin}{\LESliceEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \evalexpr{\env, \torexpr(\ebv)} \evalarrow \Normal(\mbv,\envone) \OrAbnormal\\
      \evalslices{\envone, \slices} \evalarrow \Normal(\mpositions, \envtwo) \OrAbnormal\\
      \mpositions \eqname (\vgone, \positions)\\
      \mbv \eqname (\vbv, \vgtwo)\\\\
      \writetobitvector(\positions, \vv, \vbv) \evalarrow \vvone \terminateas \Error\\\\
      \vgthree \eqdef \vg \parallelcomp \vgone \parallelcomp \vgtwo\\
      \newmbv \eqdef (\vvone, \vgthree)\\
      \evallexpr{\envtwo, \ebv, \newmbv} \evalarrow C
    }
    { \evallexpr{\envtwo, \LESlice(\ebv, \slices), (\vv, \vg)} \evalarrow C }
  \end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WHRS}.

\section{SemanticsRule.LESetArray \label{sec:SemanticsRule.LESetArray}}
  \subsection{Prose}
  Evaluation of the left-hand-side expression $\vle$ associated with a
  value $\vv$ in an environment $\env$ is the output configuration $C$
  and all of the following apply:
  \begin{itemize}
  \item $\vle$ denotes an array update expression, $\LESetArray(\rearray, \eindex)$;
  \item evaluating the right-hand-side expression corresponding to $\rearray$ in $\env$
  is either \Normal(\rmarray, \envone), \ProseOrAbnormal;
  \item evaluating $\eindex$ in $\envone$ is either \Normal(\mindex, \envtwo), \ProseOrAbnormal;
  \item $\mindex$ consists of the native integer $\vindex$ and the execution graph $\vgone$;
  \item $\vindex$ is the native integer for $\vi$;
  \item $\rmarray$ consists of the native vector $\rvarray$ and the execution graph $\vgtwo$;
  \item setting the value $\vv$ at index $\vi$ of $\rvarray$ is the native vector $\vvone$;
  \item $\vmone$ is the pair consisting of $\vvone$ and the parallel composition of $\vgone$ and $\vgtwo$;
  \item the steps so far computed the updated array, but have not assigned it to the variable
  bound to the array given by $\rearray$, which is achieved next.
  Evaluating the left-hand-side expression $\rearray$ in an environment $\envtwo$ with $\vmone$
  is the output configuration $C$.
  \end{itemize}

  \subsection{Example: SemanticsRule.LESetArray.asl}
  The specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESetArray.asl}
  binds the third element of \texttt{my\_array} to the value \texttt{53}.


  \CodeSubsection{\LESetArrayBegin}{\LESetArrayEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \torexpr(\rearray)} \evalarrow \Normal(\rmarray, \envone) \OrAbnormal\\
    \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \envtwo) \OrAbnormal\\
    \mindex \eqname (\vindex, \vgone)\\
    \vindex \eqname \nvint(\vi)\\
    \rmarray \eqname (\rvarray, \vgtwo)\\
    \setindex(\vi, \vv, \rvarray) \evalarrow \vvone\\
    \vmone \eqdef (\vvone, \vgone \parallelcomp \vgtwo)\\
    \evallexpr{\envtwo, \rearray, \vmone} \evalarrow C
  }
  { \evallexpr{\env, \LESetArray(\rearray, \eindex), (\vv, \vg)} \evalarrow C }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WHRS}.

  We note that the index is guaranteed by the type-checker to be within the array bounds
  via TypingRule.LESetArray.

\hypertarget{SemanticsRule.LESetField}{}
\section{SemanticsRule.LESetField \label{sec:SemanticsRule.LESetField}}

  \subsection{Prose}
    Evaluation of the left-hand-side expression $\vle$ associated with a
    value $\vv$ in an environment $\env$ is the output configuration $C$
    and all of the following apply:
    \begin{itemize}
    \item $\vle$ denotes a field update expression, $\LESetField(\rerecord, \fieldname)$;
    \item evaluating the right-hand-side expression corresponding to $\rerecord$
    in $\env$ is either $\Normal(\rmrecord, \envone)$ \ProseOrAbnormal
    \item $\rmrecord$ is a pair consisting of the native record $\rvrecord$ and
    the execution graph $\vgone$;
    \item setting the field $\fieldname$ in the native record $\rvrecord$ to $\vv$
    is the updated native record $\vvone$;
    \item $\vmone$ is the pair consisting of the native vector $\vvone$ and the
    execution graph that is, the parallel composition of $\vg$ and $\vgone$;
    \item the steps so far computed the updated record, but have not assigned it to
    the variable holding the record given by $\record$, which is achieved next.
    Evaluating the left-hand-side expression $\rerecord$ in an environment $\envone$ with $\vmone$
    is the output configuration $C$.
  \end{itemize}

    \subsection{Example: SemanticsRule.LESetField.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESetField.asl}
    \texttt{my\_record.a = 42;} binds \texttt{my\_record} to \texttt{\{a: 42, b: 100\}} in the environment where \texttt{my\_record} is bound to \texttt{\{a: 3, b: 100\}}.


  \CodeSubsection{\LESetFieldBegin}{\LESetFieldEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \torexpr(\rerecord)} \evalarrow \Normal(\rmrecord, \envone) \OrAbnormal\\
    \rmrecord \eqname (\rvrecord, \vgone)\\
    \setfield(\fieldname, \vv, \rvrecord) \evalarrow \vvone\\
    \vmone \eqdef (\vvone, \vg \parallelcomp \vgone)\\
    \evallexpr{\env1, \rerecord, \vmone} \evalarrow C
  }
  { \evallexpr{\env, \LESetField(\rerecord, \fieldname), (\vv, \vg)} \evalarrow C }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WHRS}.

  We note that the type-check guarantees that $\fieldname$ exists in the record given by $\record$
  via TypingRule.LESetStructuredField.

\section{SemanticsRule.LEDestructuring \label{sec:SemanticsRule.LEDestructuring}}
    \subsection{Prose}
    Evaluation of the left-hand-side expression $\vle$ associated with a
    native vector $\vv$ in an environment $\env$ is the output configuration $C$
    and all of the following apply:
    \begin{itemize}
    \item $\vle$ denotes a list of left-hand-side expressions, $\LEDestructuring(\vlelist)$;
    \item $\vlelist$ is the list of expressions $\vle_{1..k}$;
    \item getting the values from the native vector $\vv$ at each index $i=1..k$
    results in $\vv_{i=1..k}$;
    \item $\nmonads$ is the list of pairs consisting of $\vv_i$ and $\vg$ for $i=1..k$;
    \item evaluating the multi-assignment between $\vlelist$ and the list $\nmonads$
    in $\env$ achieves the effects of assigning each value to the respective
    subexpressions, resulting in the output configuration $C$.
    \end{itemize}

    \subsection{Example: SemanticsRule.LEDestructuring.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEDestructuring.asl}
    \texttt{(x, y) = (3, 42)} binds \texttt{x} to \texttt{3} and \texttt{y} to \texttt{42} in the environment where \texttt{x} is bound to \texttt{42} and \texttt{y} is bound to \texttt{3}.

  \CodeSubsection{\LEDestructuringBegin}{\LEDestructuringEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vlelist \eqname [\vle_{1..k}]\\
    i=1..k: \getindex(i, \vv) \evalarrow \vv_i\\
    \nmonads \eqdef [i=1..k: (\vv_i, \vg)]\\
    \evalmultiassignment{\env, \vlelist, \nmonads} \evalarrow C
  }
  { \evallexpr{\env, \LEDestructuring(\vlelist), (\vv, \vg)} \evalarrow C }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LEMultiAssign \label{sec:SemanticsRuleLEMultiAssign}}
\subsection{Prose}
The helper relation
\hypertarget{def-evalmultiassign}{}
\[
  \evalmultiassignment{\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vlelist} \aslsep \overname{(\vals \times \XGraphs)^*}{\vmlist}} \;\aslrel\;
  \Normal(\overname{\XGraphs}{\newg} \aslsep \overname{\envs}{\newenv}) \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates multi-assignments.
That is, the simultaneous assignment of the list of value-execution graph pairs $\vmlist$
to the corresponding list of left-hand side expressions $\vlelist$, in the environment $\env$.
The result is either the execution graph $\vg$ and new environment $\newenv$ or an abnormal configuration.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[empty]{}
  {
    \evalmultiassignment{\env, \emptylist, \emptylist} \evalarrow \Normal(\emptygraph, \env)
  }
\and
\inferrule[nonempty]{
  \vlelist \eqname [\vle] \concat \vlelistone\\
  \vmlist \eqname [\vm] \concat \vmlistone\\
  \evallexpr{\env, \vle, \vm} \evalarrow \Normal(\envone, \vgone) \OrAbnormal\\
  \evalmultiassignment{\envone, \vlelistone, \vmlistone} \evalarrow \Normal(\newenv, \vgtwo) \OrAbnormal\\
  \newg \eqdef \ordered{\vgone}{\aslpo}{\vgtwo}
}
{
  \evalmultiassignment{\env, \vlelist, \vmlist} \evalarrow \Normal(\newg, \newenv)
}
\end{mathpar}
Notice that this rule is only defined when the lists $\vlelist$ and $\vmlist$ have the same length.
To see this, notice that
to form a derivation tree, we must employ the \textsc{nonempty} case, which ensures both lists
have at least one element and shortens the lengths of both lists by one,
until both lists become empty
which is when the \textsc{empty} axiom case is used.
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Slices \label{chap:eval_slices}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The rule for evaluating a list of slices is
SemanticsRule.Slices (see \secref{SemanticsRule.Slices}).

The relation for evaluating a single slice is
\hypertarget{def-evalslice}{}
\[
  \begin{array}{rl}
  \evalslice{\overname{\envs}{\env} \aslsep \overname{\slice}{\vs}} \;\aslrel &
    \Normal(((\overname{\tint}{\vstart} \times \overname{\tint}{\vlength}) \times \overname{\XGraphs}{\newg}), \overname{\envs}{\newenv})\ \cup \\
    & \overname{\Throwing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
  \end{array}
\]

where a single slice $\vs$ is evaluated in an environment $\env$ is,
resulting either in $\Normal(((\vstart, \vlength), \vg), \newenv)$
or an error configuration,
and one of the following applies:
\begin{itemize}
  \item SemanticsRule.SliceSingle (see \secref{SemanticsRule.SliceSingle}),
  \item SemanticsRule.SliceLength (see \secref{SemanticsRule.SliceLength}),
  \item SemanticsRule.SliceRange (see \secref{SemanticsRule.SliceRange}),
  \item SemanticsRule.SliceStar (see \secref{SemanticsRule.SliceStar}).
  \end{itemize}

\section{SemanticsRule.Slices \label{sec:SemanticsRule.Slices}}
\subsection{Prose}
The relation
\hypertarget{def-evalslices}{}
\[
  \begin{array}{rl}
  \evalslices{\overname{\envs}{\env} \aslsep \overname{\slice^*}{\slices}} \;\aslrel &
    \Normal((\overname{(\vals \times \vals)^*}{\ranges} \times \overname{\XGraphs}{\newg}), \overname{\envs}{\newenv})\ \cup \\
    & \overname{\Throwing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
  \end{array}
\]

evaluates a list of slices $\slices$ in an environment $\env$, resulting in either \\
$\Normal((\ranges, \newg), \newenv)$ or an abnormal configuration,
and one of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item the list of slices is empty;
    \item $\ranges$ is the empty list;
    \item $\newg$ is the empty graph;
    \item $\newenv$ is $\env$;
  \end{itemize}

  \item All of the following apply (\textsc{nonempty}):
  \begin{itemize}
    \item the list of slices has $\slice$ as the head and $\slicesone$ as the tail;
    \item evaluating the slice $\vslice$ in $\env$ either results in \\
    $\Normal((\range, \vgone), \envone)$     \ProseOrAbnormal;
    \item evaluating the tail list $\slicesone$ in $\envone$ either results in \\
    $\Normal((\rangesone, \vgtwo), \newenv)$ \ProseOrAbnormal;
    \item $\ranges$ is the concatenation of $\range$ to $\rangesone$;
    \item $\newg$ is the parallel composition of $\vgone$ and $\vgtwo$.
  \end{itemize}
\end{itemize}

\texttt{eval\_slices env slices} is the list of pairs \texttt{(start\_n, length\_n)} that
correspond to the start (included) and the length of each slice in
$\slices$.


\CodeSubsection{\SlicesBegin}{\SlicesEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[empty]{}
  {
    \evalslices{\env, \emptylist} \evalarrow \Normal((\emptylist, \emptygraph), \env)
  }
  \and
  \inferrule[nonempty]{
    \slices \eqname [\vslice] \concat \slicesone\\
    \evalslice{\env, \vslice} \evalarrow \Normal((\range, \vgone), \envone) \OrAbnormal\\
    \evalslices{\envone, \slicesone} \evalarrow \Normal((\rangesone, \vgtwo), \newenv) \OrAbnormal\\
    \ranges \eqdef [\range] \concat \rangesone\\
    \newg \eqdef \vgone \parallelcomp \vgtwo
  }
  {
    \evalslices{\env, \slices} \evalarrow \Normal((\ranges, \newg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceSingle \label{sec:SemanticsRule.SliceSingle}}
  \subsection{Prose}
  evaluating the slice $\vs$ in an environment $\env$ is either \\
  $\Normal(((\start, \vlength), \vg), \newenv)$
  or an abnormal configuration and all of the following apply:
  \begin{itemize}
    \item $\vs$ is a single value slicing expression, $\SliceSingle(\ve)$;
    \item evaluating $\ve$ in $\env$ either results in \Normal((\vstart, \newg), \newenv)
    \ProseOrAbnormal;
    \item $\vlength$ is the integer value 1.
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceSingle.asl}
  In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceSingle.asl}
  the slice \texttt{[2]} evaluates to \texttt{(2, 1)}, i.\,e.\ the slice of
  length 1 starting at index 2.


  \CodeSubsection{\SliceSingleBegin}{\SliceSingleEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vstart, \newg), \newenv) \OrAbnormal\\
    \vlength \eqdef \nvint(1)
  }
  {
    \evalslice{\env, \SliceSingle(\ve)} \evalarrow \Normal(((\vstart, \vlength), \newg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceLength \label{sec:SemanticsRule.SliceLength}}
  \subsection{Prose}
  evaluating the slice $\vs$ in an environment $\env$ is either \\
  $\Normal(((\start, \vlength), \vg), \newenv)$
  or an abnormal configuration and all of the following apply:
  \begin{itemize}
    \item $\vs$ is the slice which starts at expression~$\estart$ with length~$\elength$,
    that is, $\SliceLength(\estart, \elength)$;
    \item evaluating $\estart$ in $\env$ is either \Normal(\mstart, \envone) \ProseOrAbnormal;
    \item evaluating $\elength$ in $\envone$ is either \Normal(\mlength, \newenv) \ProseOrAbnormal;
    \item $\mstart$ is a pair consisting of the native integer $\vstart$ and execution graph $\vgone$;
    \item $\mlength$ is a pair consisting of the native integer $\vlength$ and execution graph $\vgtwo$;
    \item $\newg$ is the parallel composition of $\vgone$ and $\vgtwo$.
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceLength.asl}
  In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceLength.asl}
  \texttt{2+:3} evaluates to \texttt{(2, 3)}.


  \CodeSubsection{\SliceLengthBegin}{\SliceLengthEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \estart} \evalarrow \Normal(\mstart, \envone) \OrAbnormal\\
    \evalexpr{\envone, \elength} \evalarrow \Normal(\mlength, \newenv) \OrAbnormal\\
    \mstart \eqname (\vstart, \vgone)\\
    \mlength \eqname (\vlength, \vgtwo)\\
    \newg \eqdef \vgone \parallelcomp \vgtwo
  }
  {
    \evalslice{\env, \SliceLength(\estart, \elength)} \evalarrow \\ \Normal(((\vstart, \vlength), \newg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceRange \label{sec:SemanticsRule.SliceRange}}
  \subsection{Prose}
  evaluating the slice $\vs$ in an environment $\env$ is either \\
  $\Normal(((\start, \vlength), \vg), \newenv)$
  or an abnormal configuration and all of the following apply:
  \begin{itemize}
    \item $\vs$ is the slice range between the
      expressions $\estart$ and $\etop$, that is, \\ $\SliceRange(\etop, \estart)$;
    \item evaluating $\etop$ in $\env$ is either $\Normal(\mtop, \envone)$ \ProseOrAbnormal;
    \item $\mtop$ is a pair consisting of the native integer $\vvtop$ and execution graph $\vgone$;
    \item evaluating $\estart$ in $\envone$ is either $\Normal(\mstart, \newenv)$ \ProseOrAbnormal;
    \item $\mstart$ is a pair consisting of the native integer $\vstart$ and execution graph $\vgtwo$;
    \item $\vlength$ is the integer value \texttt{(v\_top - v\_start) + 1};
    \item $\newg$ is the parallel composition of $\vgone$ and $\vgtwo$.
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceRange.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceRange.asl}
  \texttt{4:2} evaluates to \texttt{(2, 3)}.


  \CodeSubsection{\SliceRangeBegin}{\SliceRangeEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \etop} \evalarrow \Normal(\mtop, \envone) \OrAbnormal\\\\
    \mtop \eqname (\vvtop, \vgone)\\
    \evalexpr{\envone, \estart} \evalarrow \Normal(\mstart, \newenv) \OrAbnormal\\\\
    \mstart \eqname (\vstart, \vgtwo)\\
    \binoprel(\MINUS, \vvtop, \vstart) \evalarrow \vdiff\\
    \binoprel(\PLUS, \nvint(1), \vdiff) \evalarrow \vlength\\
    \newg \eqdef \vgone \parallelcomp \vgtwo
  }
  {
    \evalslice{\env, \SliceRange(\etop, \estart)} \evalarrow \\ \Normal(((\vstart, \vlength), \newg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceStar \label{sec:SemanticsRule.SliceStar}}
  \subsection{Prose}
  evaluating the slice $\vs$ in an environment $\env$ is either \\
  $\Normal(((\start, \vlength), \vg), \newenv)$
  or an abnormal configuration and all of the following apply:
  \begin{itemize}
    \item $\vs$ is the slice with factor given by the
      expression $\efactor$ and length given by the
      expression $\elength$, that is, $\SliceStar(\efactor, \elength)$;
    \item evaluating $\efactor$ in $\env$ is either $\Normal(\mfactor, \envone)$ \ProseOrAbnormal;
    \item $\mfactor$ is a pair consisting of the native integer $\vfactor$ and execution graph $\vgone$;
    \item evaluating $\elength$ in $\env$ is either $\Normal(\mlength, \newenv)$ \ProseOrAbnormal;
    \item $\mlength$ is a pair consisting of the native integer $\vlength$ and execution graph $\vgtwo$;
    \item $\vstart$ is the native integer $\vfactor \times \vlength$;
   \item $\newg$ is the parallel composition of $\vgone$ and $\vgtwo$.
   \end{itemize}


  \subsection{Example: SemanticsRule.SliceStar.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceStar.asl}
  \texttt{x[3*:2]} evaluates to \texttt{'11'}.


  \CodeSubsection{\SliceStarBegin}{\SliceStarEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \efactor} \evalarrow \Normal(\mfactor, \envone) \OrAbnormal\\
    \mfactor \eqname (\vfactor, \vgone)\\
    \evalexpr{\envone, \elength} \evalarrow \Normal(\mlength, \newenv) \OrAbnormal\\
    \mlength \eqname (\vlength, \vgtwo)\\
    \binoprel(\MUL, \vfactor, \vlength) \evalarrow \vstart \\
    \newg \eqdef \vgone \parallelcomp \vgtwo
  }
  {
    \evalslice{\env, \SliceStar(\efactor, \elength)} \evalarrow \\ \Normal(((\vstart, \vlength), \newg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Patterns \label{chap:eval_pattern}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The relation
\hypertarget{def-evalpattern}{}
\[
  \evalpattern{\overname{\envs}{\env} \aslsep \overname{\vals}{\vv} \aslsep \overname{\pattern}{\vp}} \;\aslrel\;
  \Normal(\overname{\tbool}{\vb}, \overname{\XGraphs}{\newg})
\]
determines whether a value $\vv$ matches the pattern $\vp$ in an environment $\env$
resulting in either $\Normal(\vb, \newg)$ or an abnormal configuration,
and one of the following applies:
\begin{itemize}
\item SemanticsRule.PAll (see \secref{SemanticsRule.PAll})
\item SemanticsRule.PAny (see \secref{SemanticsRule.PAny})
\item SemanticsRule.PGeq (see \secref{SemanticsRule.PGeq})
\item SemanticsRule.PLeq (see \secref{SemanticsRule.PLeq})
\item SemanticsRule.PNot (see \secref{SemanticsRule.PNot})
\item SemanticsRule.PRange (see \secref{SemanticsRule.PRange})
\item SemanticsRule.PSingle (see \secref{SemanticsRule.PSingle})
\item SemanticsRule.PMask (see \secref{SemanticsRule.PMask})
\item SemanticsRule.PTuple (see \secref{SemanticsRule.PTuple})
\end{itemize}

\section{SemanticsRule.PAll \label{sec:SemanticsRule.PAll}}
  \subsection{Prose}
  Evaluation of the pattern $\vp$ in an environment $\env$ with
  respect to value $\vv$ is \\ $\Normal(\vb, \newg)$, and all of the following apply:
  \begin{itemize}
    \item $\vp$ is the pattern which matches everything, $\PatternAll$, and therefore
      matches $\vv$;
    \item $\vb$ is the native Boolean value \True;
    \item $\newg$ is the empty graph.
  \end{itemize}

  \subsection{Example: SemanticsRule.PAll.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAll.asl}


  \CodeSubsection{\PAllBegin}{\PAllEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalpattern{\env, \Ignore, \PatternAll} \evalarrow \Normal(\nvbool(\True), \emptygraph)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PAny \label{sec:SemanticsRule.PAny}}
    \subsection{Prose}
    Evaluation of the pattern $\vp$ in an environment $\env$ with
    respect to value $\vv$ is either $\Normal(\vb, \newg)$ or an abnormal configuration,
    and all of the following apply:
    \begin{itemize}
      \item $\vp$ is a list of patterns, $\PatternAny(\vps)$;
      \item $\vps$ is $\vp_{1..k}$;
      \item evaluating each pattern $\vp_i$ in $\env$ either results in $\Normal(\nvbool(\vb_i), \vg_i)$ \ProseOrAbnormal;
      \item $\vb$ is the native Boolean which is the disjunction of $\vb_i$, for $i=1..k$;
      \item $\newg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$.
    \end{itemize}

    \subsection{Example: SemanticsRule.PAnyTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAnyTRUE.asl}

    \subsection{Example: SemanticsRule.PAnyFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAnyFALSE.asl}


    \CodeSubsection{\PAnyBegin}{\PAnyEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vps \eqname \vp_{1..k}\\
    i=1..k : \evalpattern{\env, \vv, \vp_i} \evalarrow \Normal(\nvbool(\vb_i), \vg_i) \terminateas \ErrorConfig\\
    \vb \eqdef \nvbool(\bigvee_{i=1..k} \vb_i)\\
    \newg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k
  }
  {
    \evalpattern{\env, \vv, \PatternAny(\vps)} \evalarrow \Normal(\vb, \newg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PGeq \label{sec:SemanticsRule.PGeq}}
    \subsection{Prose}
    Evaluation of the pattern $\vp$ in an environment $\env$ with
    respect to value $\vv$ is either $\Normal(\vb, \newg)$ or an error configuration,
    and all of the following apply:
    \begin{itemize}
      \item $\vp$ is the condition corresponding to being greater than or equal
        than the side-effect-free expression $\ve$, $\PatternGeq(\ve)$;
      \item the side-effect-free evaluation of $\ve$ is either
      $\Normal(\vvone, \newg)$ \ProseOrError;
      \item $\vb$ is the Boolean value corresponding to whether $\vv$
        is greater than or equal to $\vvone$.
    \end{itemize}

    \subsection{Example: SemanticsRule.PGeqTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PGeqTRUE.asl}

    \subsection{Example: SemanticsRule.PGeqFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PGeqFALSE.asl}


  \CodeSubsection{\PGeqBegin}{\PGeqEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vvone, \newg) \terminateas \ErrorConfig\\\\
    \binoprel(\GEQ, \vv, \vvone) \evalarrow \vb
  }
  {
    \evalpattern{\env, \vv, \PatternGeq(\ve)} \evalarrow \Normal(\vb, \newg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PLeq \label{sec:SemanticsRule.PLeq}}
  \subsection{Prose}
  Evaluation of the pattern $\vp$ in an environment $\env$ with
  respect to value $\vv$ is either $\Normal(\vb, \newg)$ or an error configuration,
  and all of the following apply:
  \begin{itemize}
    \item $\vp$ is the condition corresponding to being less than or equal
      to the side-effect-free expression $\ve$, $\PatternLeq(\ve)$;
    \item the side-effect-free evaluation of $\ve$ is either
    $\Normal(\vvone, \newg)$ \ProseOrError;
    \item $\vb$ is the Boolean value corresponding to whether $\vv$
      is less than or equal to $\vvone$.
  \end{itemize}

    \subsection{Example: SemanticsRule.PLeqTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PLeqTRUE.asl}

    \subsection{Example: SemanticsRule.PLeqFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PLeqFALSE.asl}


  \CodeSubsection{\PLeqBegin}{\PLeqEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vvone, \newg) \terminateas \ErrorConfig\\\\
    \binoprel(\LEQ, \vv, \vvone) \evalarrow \vb
  }
  {
    \evalpattern{\env, \vv, \PatternLeq(\ve)} \evalarrow \Normal(\vb, \newg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PNot \label{sec:SemanticsRule.PNot}}
    \subsection{Prose}
    Evaluation of the pattern $\vp$ in an environment $\env$ with
    respect to value $\vv$ is either $\Normal(\vb, \newg)$ or an error configuration,
    and all of the following apply:
      \begin{itemize}
      \item $\vp$ is a negation pattern, $\PatternNot(\vpone)$;
      \item evaluating that pattern $\vpone$ in an environment $\env$ is either \\
      $\Normal(\vbone, \newg)$ \ProseOrError;
      \item $\vb$ is the Boolean negation of $\vbone$.
    \end{itemize}

    \subsection{Example: SemanticsRule.PNotTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PNotTRUE.asl}

    \subsection{Example: SemanticsRule.PNotFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PNotFALSE.asl}


  \CodeSubsection{\PNotBegin}{\PNotEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \vpone} \evalarrow \Normal(\vbone, \newg) \terminateas \ErrorConfig\\\\
    \unoprel(\BNOT, \vbone) \evalarrow \vb
  }
  {
    \evalpattern{\env, \vv, \PatternNot(\vpone)} \evalarrow \Normal(\vb, \newg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PRange \label{sec:SemanticsRule.PRange}}
    \subsection{Prose}
    Evaluation of the pattern $\vp$ in an environment $\env$ with
    respect to value $\vv$ is either $\Normal(\vb, \newg)$ or an error configuration,
    and all of the following apply:
    \begin{itemize}
      \item $\vp$ is the condition corresponding to being greater than or equal
        to $\veone$, and lesser or equal to $\vetwo$, that is, $\PatternRange(\veone, \vetwo)$;
      \item $\veone$ and $\vetwo$ are side-effect-free expressions;
      \item the side-effect-free evaluation of $\veone$ in $\env$ is either $\Normal(\vvone, \vgone)$ \ProseOrError;
      \item the side-effect-free evaluation of $\vetwo$ in $\env$ is either $\Normal(\vvtwo, \vgtwo)$ \ProseOrError;
      \item $\vbone$ is the Boolean value corresponding to whether
        $\vv$ is greater than or equal to $\vvone$;
        \item $\vbtwo$ is the Boolean value corresponding to whether
        $\vv$ is greater than or equal to $\vvtwo$;
      \item $\vb$ is the Boolean conjunction of $\vbone$ and
      $\vbtwo$;
      \item $\newg$ is the parallel composition of $\vgone$ and $\vgtwo$.
    \end{itemize}

    \subsection{Example: SemanticsRule.PRangeTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PRangeTRUE.asl}

    \subsection{Example: SemanticsRule.PRangeFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PRangeFALSE.asl}


  \CodeSubsection{\PRangeBegin}{\PRangeEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvone, \vgone) \terminateas \ErrorConfig\\
    \binoprel(\GEQ, \vv, \vvone) \evalarrow \vbone\\
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvtwo, \vgtwo) \terminateas \ErrorConfig\\
    \binoprel(\GEQ, \vv, \vvtwo) \evalarrow \vbtwo\\
    \binoprel(\BAND, \vbone, \vbtwo) \evalarrow \vb\\
    \newg \eqdef \vgone \parallelcomp \vgtwo
  }
  {
    \evalpattern{\env, \vv, \PatternRange(\veone, \vetwo)} \evalarrow \Normal(\vb, \newg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PSingle \label{sec:SemanticsRule.PSingle}}
    \subsection{Prose}
    Evaluation of the pattern $\vp$ in an environment $\env$ with
    respect to value $\vv$ is either $\Normal(\vb, \newg)$ or an error configuration,
    and all of the following apply:
    \begin{itemize}
      \item $\vp$ is the condition corresponding to being equal to the
        side-effect-free expression $\ve$, $\PatternSingle(\ve)$;
      \item the side-effect-free evaluation of $\ve$ in
        environment $\env$ is either \\ $\Normal(\vvone, \newg)$ \ProseOrError;
      \item $\vb$ is the Boolean value corresponding to whether $\vv$
        is equal to $\vvone$.
    \end{itemize}

    \subsection{Example: SemanticsRule.PSingleTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PSingleTRUE.asl}

    \subsection{Example: SemanticsRule.PSingleFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PSingleFALSE.asl}


  \CodeSubsection{\PSingleBegin}{\PSingleEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvone, \newg) \terminateas \ErrorConfig\\\\
    \binoprel(\EQOP, \vvone, \vvone) \evalarrow \vb
  }
  {
    \evalpattern{\env, \vv, \PatternSingle(\ve)} \evalarrow \Normal(\vb, \newg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PMask \label{sec:SemanticsRule.PMask}}
    \subsection{Prose}
    Evaluation of the pattern $\vp$ in an environment $\env$ with
    respect to value $\vv$ is either $\Normal(\vb, \newg)$ or an error configuration,
    and all of the following apply:
    \begin{itemize}
      \item $\vp$ is a mask pattern, $\PatternMask(\vm)$,
      of length $n$ (with spaces removed);
      \item $\vv$ is a native bitvector of bits $\vu_{1..n}$;
      \item $\vb$ is the native Boolean formed from the conjunction of Boolean values for each $i$,
      where the bit $\vu_i$ is checked for matching the mask character $\vm_i$;
      \item $\newg$ is the empty graph.
    \end{itemize}

    \subsection{Example: SemanticsRule.PMaskTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PMaskTRUE.asl}

    \subsection{Example: SemanticsRule.PMaskFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PMaskFALSE.asl}


  \CodeSubsection{\PMaskBegin}{\PMaskEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \newcommand\maskmatch[0]{\text{mask\_match}}
  The helper function $\maskmatch : \{0, 1, \vx\} \times \{0,1\} \rightarrow \Bool$,
  checks whether a bit value (second operand) matches a mask value (first operand),
  is defined by the following table:
\[
  \begin{array}{|c|c|c|c|}
    \hline
    \textbf{\maskmatch} & 0 & 1 & \vx\\
    \hline
    0 & \True & \False & \True\\
    \hline
    1 & \False & \True & \True\\
    \hline
  \end{array}
\]

\begin{mathpar}
  \inferrule{
    \vm \eqname \vm_{1..n}\\
    \vv \eqname \nvbitvector(\vu_{1..n})\\
    \vb \eqdef \nvbool(\bigwedge_{i=1..n} \maskmatch(\vm_i, \vu_i))
  }
  {
    \evalpattern{\env, \vv, \PatternMask(\vm)} \evalarrow \Normal(\vb, \emptygraph)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PTuple \label{sec:SemanticsRule.PTuple}}

    \subsection{Prose}
    Evaluation of the pattern $\vp$ in an environment $\env$ with
    respect to value $\vv$ is $\vb$ and all of the following apply:
    \begin{itemize}
      \item $\vp$ gives a list of patterns $\vps$ of length $k$, $\PatternTuple(\vps)$;
      \item $\vv$ gives a tuple of values $\vvs$ of length $k$;
      \item for all $1 \leq i \leq n$, $\vb_i$ is the evaluation result
        of $\vp_i$ with respect to the value $\vv_i$ in
        environment $\env$;
      \item $\vbs$ is the list of all $\vb_i$ for $1 \leq i \leq k$;
      \item $\vb$ is the conjunction of the Boolean values of $\vbs$.
    \end{itemize}

    \subsection{Example: SemanticsRule.PTupleTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PTupleTRUE.asl}

    \subsection{Example: SemanticsRule.PTupleFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PTupleFALSE.asl}


  \CodeSubsection{\PTupleBegin}{\PTupleEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vps \eqname \vp_{1..k}\\
    i=1..k: \getindex(i, \vv) \evalarrow \vvs_i\\
    i=1..k: \evalpattern{\env, \vvs_i, \vp_i} \evalarrow \Normal(\nvbool(\vbs_i), \vg_i) \terminateas \ErrorConfig\\
    \vres \eqdef \nvbool(\bigwedge_{i=1..k} \vbs_i)\\
    \vg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k
  }
  {
    \evalpattern{\env, \vv, \PatternTuple(\vps)} \evalarrow \Normal(\vres, \emptygraph)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Local Declarations \label{chap:eval_local_decl}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The relation
\hypertarget{def-evallocaldecl}{}
\[
  \evallocaldecl{\overname{\envs}{\env} \aslsep \localdeclitem \aslsep \langle\overname{\vals}{\vv}\times\overname{\XGraphs}{\vgone}\rangle} \;\aslrel\;
                         \Normal(\overname{\XGraphs}{\newg}, \overname{\envs}{\newenv})
\]
declares local variables
$\ldi$ in $\env$ with an optional initialisation value
$\minitopt$.  Evaluation of the local variables $\ldi$
in an environment $\env$ is either $\Normal(\vg, \newenv)$
or an abnormal configuration and one of the following applies:
\begin{itemize}
  \item SemanticsRule.LDDiscard (see \secref{SemanticsRule.LDDiscard}),
  \item SemanticsRule.LDVar (see \secref{SemanticsRule.LDVar}),
  \item SemanticsRule.LDTyped (see \secref{SemanticsRule.LDTyped}),
  \item SemanticsRule.LDTuple (see \secref{SemanticsRule.LDTuple}),
  \item SemanticsRule.LDUninitialisedTyped (see \secref{SemanticsRule.LDUninitialisedTyped}),
\end{itemize}

Recall that ASL has three different categories of variable declarations ---
constants, mutable variables (declared via \texttt{var}), and immutable variables (declared via \texttt{let}).
From the perspective of evaluating the semantics of local declarations (and local declarations statements
in \chapref{eval_stmt}), they are all treated the same way.

\section{SemanticsRule.LDDiscard \label{sec:SemanticsRule.LDDiscard}}
    \subsection{Prose}
    Evaluation of the local variables $\ldi$ in the environment \\
    $\env$ is $\Normal(\vg, \newenv)$ and all of the following apply:
    \begin{itemize}
    \item $\ldi$ indicates that the initialisation value will be discarded,
    $\LDIDiscard$;
    \item $\newg$ is the empty graph;
    \item $\newenv$ is $\env$.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDDiscard.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDDiscard.asl}
    \texttt{var - : integer;} does not modify the environment.


  \CodeSubsection{\LDDiscardBegin}{\LDDiscardEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evallocaldecl{\env, \LDIDiscard, \Ignore} \evalarrow \Normal(\emptygraph, \env)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDVar \label{sec:SemanticsRule.LDVar}}
    \subsection{Prose}
    Evaluation of the local variables $\ldi$ in the environment \\
    $\env$ is $\Normal(\vg, \newenv)$ and all of the following apply:
    \begin{itemize}
    \item $\ldi$ is a variable declaration, $\LDIVar(\vx)$;
    \item $\minitopt$ is $\vm$;
    \item $\vm$ is a pair consisting of the value $\vv$ and execution graph $\vgone$;
    \item declaring $\vx$ in $\env$ is $(\newenv, \vgtwo)$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDVar0.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDVar0.asl}
    \texttt{var x = 3;} binds \texttt{x} to the evaluation of \texttt{3} in $\env$.

    \subsection{Example: SemanticsRule.LDVar1.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDVar1.asl}
    \texttt{var x : integer = 3;} binds \texttt{x} to the evaluation of
\texttt{3} in $\env$, without type consideration at runtime.


  \CodeSubsection{\LDVarBegin}{\LDVarEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm \eqname (\vv, \vgone)\\
    \declarelocalidentifier(\env, \vx, \vv)\evalarrow(\newenv, \vgtwo)\\
    \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evallocaldecl{\env, \LDIVar(\vx), \langle \vm\rangle} \evalarrow \Normal(\newg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDTyped \label{sec:SemanticsRule.LDTyped}}
    \subsection{Prose}
    Evaluation of the local variables $\ldi$ in the environment \\
    $\env$ is $\Normal(\vg, \newenv)$ or an abnormal configuration
    and all of the following apply:
    \begin{itemize}
      \item $\ldi$ is a typed declaration, $\LDITyped(\ldione, \vt)$;
      \item $\minitopt$ is $\vm$;
      \item the resulting configuration is obtained via the evaluation
      of the local declaration $\ldione$ in $\env$ with $\minitopt$ as $\vm$,
      that is, \\ $\evallocaldecl{\env, \ldi1, \langle \vm\rangle}$.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDTyped.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDTyped.asl}
    \texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.


  \CodeSubsection{\LDTypedBegin}{\LDTypedEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallocaldecl{\env, \ldi1, \langle \vm\rangle} \evalarrow C
  }
  {
    \evallocaldecl{\env, \LDITyped(\ldi1, \Ignore), \langle \vm\rangle} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDTuple \label{sec:SemanticsRule.LDTuple}}
    \subsection{Prose}
    Evaluation of the local variables $\ldi$ in the environment \\
    $\env$ is $\Normal(\vg, \newenv)$ or an abnormal configuration
    and all of the following apply:
    \begin{itemize}
    \item $\ldi$ declares a list of local variables, $\LDITuple(\ldis)$;
    \item $\minitopt$ is $\vm$;
    \item $\vm$ is a pair consisting of the native vector $\vv$ and execution graph $\vg$;
    \item $\ldis$ is a list of local declaration items $\ldi_{1..k}$;
    \item the value at each index of $\vv$ is $\vv_i$, for $i=1..k$;
    \item $\liv$ is the list of pairs $(\vv_i, \vg)$, for $i=1..k$;
    \item the output configuration is obtained by declare each local declaration item $\ldi_i$
    with the corresponding value ($\minitopt$ component) $(\vv_i, \vg)$.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDTuple.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDTuple.asl}
    \texttt{var (x,y,z) = (1,2,3);} binds \texttt{x} to the evaluation of
\texttt{1}, \texttt{y} to the evaluation of \texttt{2}, and \texttt{z} to the
evaluation of \texttt{3}) in $\env$.


  \CodeSubsection{\LDTupleBegin}{\LDTupleEnd}{../Interpreter.ml}

\begin{emptyformal}
\newcommand\ldituplefolder[1]{\texttt{ldi\_tuple\_folder}(#1)}

  \subsection{Formally}
We first define the helper semantic relation
\[
    \ldituplefolder{\overname{\envs}{\env} \aslsep \overname{\localdeclitem^*}{\ldis} \aslsep \overname{(\vals \times \XGraphs)^*}{\liv}} \;\aslrel\;
     \Normal(\overname{\XGraphs}{\vg} \aslsep \overname{\envs}{\newenv})
\]
via the following rules:
\begin{mathpar}
  \inferrule{}
  {
    \ldituplefolder{\env, \emptylist, \emptylist} \evalarrow \Normal(\emptygraph, \env)
  }
\and
  \inferrule{
    \ldis \eqname [\ldi] \concat \ldis'\\
    \liv \eqname [\vm] \concat \liv'\\
    \vm \eqname (\vv, \vgone)\\
    \evallocaldecl{\env, \ldi, \langle\vm\rangle} \evalarrow \Normal(\vgone, \envone)\\
    \ldituplefolder{\envone, \ldis', \liv'} \evalarrow \Normal(\vgtwo, \newenv)\\
    \newg \eqdef \vgone \parallelcomp \vgtwo
  }
  {
    \ldituplefolder{\env, \ldis, \liv} \evalarrow \Normal(\newg, \newenv)
  }
\end{mathpar}

We now use the helper rules to define the rule for local declaration item tuples:
\begin{mathpar}
  \inferrule{
    \vm \eqname (\vv, \vg)\\
    \ldis \eqname \ldi_{1..k}\\
    i=1..k: \getindex(i, \vv) \evalarrow \vv_i\\
    \liv \eqname [i=1..k: (\vv_i, \vg)]\\
    \ldituplefolder{\env, \ldis, \liv} \evalarrow C
  }
  {
    \evallocaldecl{\env, \LDITuple(\ldis), \langle \vm\rangle} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDUninitialisedTyped\label{sec:SemanticsRule.LDUninitialisedTyped}}
    \subsection{Prose}
    Evaluation of the local variables $\ldi$ in the environment \\
    $\env$ is $\Normal(\vg, \newenv)$ or an abnormal configuration
    and all of the following apply:
    \begin{itemize}
      \item $\ldi$ gives a local declaration with a type, but no initial value, $\LDITyped(\ldione, \vt)$;
      \item $\minitopt$ is $\None$;
      \item the base value of $\vt$ is either $\vm$ \ProseOrError;
      \item evaluating the local declaration $\ldione$ with $\vm$
      as the $\minitopt$ component yields the output configuration.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDUninitialisedTyped.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDUninitialisedTyped.asl}
    \texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.


  \CodeSubsection{\LDUninitialisedTypedBegin}{\LDUninitialisedTypedEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \basevalue(\env, \vt) \evalarrow \vm \terminateas \ErrorConfig\\\\
    \evallocaldecl{\env, \ldione, \langle \vm \rangle} \evalarrow C
  }
  {
    \evallocaldecl{\env, \LDITyped(\ldione, \vt), \None} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Statements \label{chap:eval_stmt}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The relation
\hypertarget{def-evalstmt}{}
\[
  \evalstmt{\overname{\envs}{\env} \aslsep \overname{\stmt}{\vs}} \;\aslrel\;
  \left(
  \begin{array}{cl}
  \overname{\TReturning}{\Returning((\vvs,\newg), \newenv)} & \cup\\
  \overname{\TContinuing}{\Continuing(\newg,\newenv)} & \cup\\
  \overname{\TThrowing}{\ThrowingConfig} & \cup \\
  \overname{\TError}{\ErrorConfig} &
  \end{array}
  \right)
\]
evaluates a statement $\vs$ in an environment $\env$, resulting in one of four types of configurations
(see more details in \secref{KindsOfSemanticConfigurations}):
\begin{itemize}
  \item returning configurations with values $\vvs$, execution graph $\newg$, and a modified environment $\newenv$;
  \item continuing configurations with an execution graph $\newg$ and modified environment $\newenv$;
  \item throwing configurations;
  \item error configurations.
\end{itemize}

In evaluating a statement $\vs$, one of the following apply:
\begin{itemize}
\item SemanticsRule.SPass (see \secref{SemanticsRule.SPass}),
\item SemanticsRule.SAssign (see \secref{SemanticsRule.SAssign}),
\item SemanticsRule.SAssignCall (see \secref{SemanticsRule.SAssignCall}),
\item SemanticsRule.SAssignTuple (see \secref{SemanticsRule.SAssignTuple}),
\item SemanticsRule.SReturnNone (see \secref{SemanticsRule.SReturnNone}),
\item SemanticsRule.SReturnOne (see \secref{SemanticsRule.SReturnOne}),
\item SemanticsRule.SReturnSome (see \secref{SemanticsRule.SReturnSome}),
\item SemanticsRule.SSeq (see \secref{SemanticsRule.SSeq}),
\item SemanticsRule.SCall (see \secref{SemanticsRule.SCall}),
\item SemanticsRule.SCond (see \secref{SemanticsRule.SCond}),
\item SemanticsRule.SCase (see \secref{SemanticsRule.SCase}),
\item SemanticsRule.SAssert (see \secref{SemanticsRule.SAssert}),
\item SemanticsRule.SWhile (see \secref{SemanticsRule.SWhile}),
\item SemanticsRule.SRepeat (see \secref{SemanticsRule.SRepeat}),
\item SemanticsRule.SFor (see \secref{SemanticsRule.SFor}),
\item SemanticsRule.SThrowNone (see \secref{SemanticsRule.SThrowNone}),
\item SemanticsRule.SThrowSomeTyped (see \secref{SemanticsRule.SThrowSomeTyped}),
\item SemanticsRule.STry (see \secref{SemanticsRule.STry}),
\item SemanticsRule.SDeclSome (see \secref{SemanticsRule.SDeclSome}),
\item SemanticsRule.SDeclNone (see \secref{SemanticsRule.SDeclNone}).
\end{itemize}

\section{SemanticsRule.SPass \label{sec:SemanticsRule.SPass}}
  \subsection{Prose}
  Evaluation of the statement $\vs$ in an environment $\env$ is \\
  $\Continuing(\newg, \newenv)$ and all of the following apply:
  \begin{itemize}
  \item $\vs$ is a \texttt{pass} statement, $\SPass$;
  \item $\newg$ is the empty graph;
  \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example: SemanticsRule.SPass.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SPass.asl}
  \texttt{pass;} does nothing.

  \CodeSubsection{\SPassBegin}{\SPassEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  { \evalstmt{\env, \SPass} \evalarrow \Continuing(\emptygraph, \env) }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssign \label{sec:SemanticsRule.SAssign}}
  \subsection{Prose}
  Evaluation of the statement $\vs$ in an environment $\env$ is \\
  $\Continuing(\newg, \newenv)$ and all of the following apply:
  \begin{itemize}
  \item $\vs$ is an assignment statement, $\SAssign(\vle, \vre)$;
  \item evaluating the expression $\vre$ in $\env$ as per \chapref{eval_expr} is either \\
  $\Normal(\vm, \envone)$ (here, $\vm$ is a pair consisting of a value and an execution graph) \ProseOrAbnormal;
  \item evluating the left-hand-side expression $\vle$ with $\vm$ in $\envone$,
  as per \chapref{eval_lexpr}, is either
  $\Normal(\newg, \newenv)$ \ProseOrAbnormal.
  \end{itemize}

  \subsection{Example: SemanticsRule.SAssign.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssign.asl}
  \texttt{x = 3;} binds \texttt{x} to \texttt{3} in the environment where \texttt{x} is bound to \texttt{42}, and $\newenv$ is such that \texttt{x} is bound to \texttt{3}.


  \CodeSubsection{\SAssignBegin}{\SAssignEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \vre} \evalarrow \Normal(\vm, \envone) \OrAbnormal\\
    \evallexpr{\envone, \vle, \vm} \evalarrow \Normal(\newg, \newenv) \OrAbnormal
  }
  {
    \evalstmt{\env, \SAssign(\vle, \vre)} \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
Notice that this rule first produces a value for the right-hand side expression
and then completes the update via an appropriate rule for evaluating the left-hand side expression,
which in turn handles variables, tuples, bitvectors, etc.

\section{SemanticsRule.SAssignCall \label{sec:SemanticsRule.SAssignCall}}
  \subsection{Prose}
  Evaluation of the statement $\vs$ in an environment $\env$ is \\
  $\Continuing(\newg, \newenv)$ and all of the following apply:
  \begin{itemize}
  \item $\vs$ assigns a left-hand-side expression list from a subprogram call, \\
  $\SAssign(\LEDestructuring(\les),\ECall(\name, \args, \namedargs))$;
  \item $\les$ is a list of left-hand-side expressions, each of which is either \\ a variable ($\LEVar(\Ignore)$)
  or a discarded variable (\LEDiscard);
  \item evaluating the subprogram call as per \chapref{eval_call} is either \\
  $\Normal((\vvs, \vgone), \envone)$ \ProseOrAbnormal;
  \item assigning each value in $\vvs$ to the respective element of the tuple $\les$ is either
  $\Normal(\vgtwo, \newenv)$ \ProseOrAbnormal;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge.
  \end{itemize}

    \subsection{Example: SemanticsRule.SAssignCall.asl}

\VerbatimInput{\testdir/SemanticsRule.SAssignCall.asl}
  given that the function call \texttt{f(1)} returns the pair of values \texttt{(1,2)}, statement \texttt{(a,b) = f(1)} assigns the value \texttt{1} to the mutable variable \texttt{a} and the value \texttt{2} to the mutable variable~\texttt{b}.

  \CodeSubsection{\SAssignCallBegin}{\SAssignCallEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
We first define the syntactic relation
\hypertarget{def-lexprisvar}{}
\[
  \lexprisvar(\lexpr) \bigtimes \True
\]
which holds when a left-hand side expression
represents a variable:
\begin{mathpar}
  \inferrule{}{ \lexprisvar(\LEVar(\Ignore)) \evalarrow \True}
  \and
  \inferrule{}{ \lexprisvar(\LEDiscard) \evalarrow \True}
\end{mathpar}

We now define the evaluation of assigning from a subprogram call:
\begin{mathpar}
  \inferrule{
    \vles \eqdef \vle_{1..k}\\
    i=1..k: \lexprisvar(\vle_i) \evalarrow \True\\
    \evalcall{\env, \name, \args, \namedargs} \evalarrow \Normal((\vvs, \vgone), \envone) \OrAbnormal\\
    \evalmultiassignment{\envone, \vles, \vvs} \evalarrow \Normal(\vgtwo, \newenv) \OrAbnormal\\
    \newg \eqdef \ordered{\vgone}{\aslpo}{\vgtwo}
  }
  {
    \evalstmt{\env, \SAssign(\LEDestructuring(\les),\ECall(\name, \args, \namedargs))} \\
    \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssignTuple \label{sec:SemanticsRule.SAssignTuple}}
  \subsection{Prose}
  Evaluation of the statement $\vs$ in an environment $\env$ is \\
  $\Continuing(\newg, \newenv)$ and all of the following apply:
  \begin{itemize}
  \item $\vs$ is an assignment to a list of left-hand-side expressions, \\
  $\SAssign(\LEDestructuring(\vles), \ETuple(\exprs))$;
  \item $\les$ is a list of left-hand-side expressions, each of which is either a variable \\ ($\LEVar(\Ignore)$)
  or a discarded variable (\LEDiscard);
  \item evaluating $\exprs$ is either $\Normal(\vms, \envone)$ (where $\vms$ is a list of pairs consisting of values and execution graphs)
  \ProseOrAbnormal;
  \item assigning each of the pairs of values and execution graphs to the respective expression in $\les$ in $\envone$ results in
  either $\Normal(\newg, \newenv)$ \ProseOrAbnormal.
  \end{itemize}

    \subsection{Example: SemanticsRule.SAssignTuple.asl}
\VerbatimInput{\testdir/SemanticsRule.SAssignTuple.asl}
statement \texttt{(b,x)} assigns the value \True to the mutable variable \texttt{b} and the value~\texttt{42} to the mutable variable~\vx.


  \CodeSubsection{\SAssignTupleBegin}{\SAssignTupleEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vles \eqdef [\vle_{1..k}]\\
    i=1..k: \lexprisvar(\vle_i) \evalarrow \True\\
    \evalexprlistm{\env, \exprs} \evalarrow \Normal(\vms, \envone) \OrAbnormal\\
    \evalmultiassignment{\envone, \les, \vms} \evalarrow \Normal(\newg, \newenv) \OrAbnormal
  }
  {
    \evalstmt{\env, \SAssign(\LEDestructuring(\vles), \ETuple(\exprs))} \\
    \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnNone \label{sec:SemanticsRule.SReturnNone}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is \\
    $\Returning((\vvs, \newg), \newenv)$ and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a \texttt{return} statement, $\SReturn(\None)$;
    \item $\vvs$ is the empty list, $\emptylist$;
    \item $\newg$ is the empty graph;
    \item $\newenv$ is $\env$.
    \end{itemize}

    \subsection{Example: SReturnNoneReturn.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnNone.asl}
    exits the current procedure.


  \CodeSubsection{\SReturnNoneBegin}{\SReturnNoneEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalstmt{\env, \SReturn(\None)} \evalarrow \Returning((\emptylist, \emptygraph), \env)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnOne \label{sec:SemanticsRule.SReturnOne}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is \\
    $\Returning((\vvs, \newg), \newenv)$ and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a \texttt{return} statement;
    \item $\vs$ is a \texttt{return} statement for a single expression, $\SReturn(\langle\ve\rangle)$;
    \item evaluating $\ve$ in $\env$ is either $\Normal((\vv, \vgone), \newenv)$ \ProseOrAbnormal;
    \item $\vvs$ is $[\vv]$;
    \item $\vgtwo$ is the result of adding a Write Effect for a fresh identifier and the value $\vv$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
    \end{itemize}

    \subsection{Example: SemanticsRule.SReturnOne.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnOne.asl}
    \texttt{return 3;} exits the current subprogram with value \texttt{3}.


  \CodeSubsection{\SReturnOneBegin}{\SReturnOneEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\\\
    \wid \in \Identifiers\text{ is fresh}\\
    \writeidentifier(\wid, \vv) \evalarrow \vgtwo\\
    \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalstmt{\env, \SReturn(\langle\ve\rangle)} \evalarrow \Returning(([\vv], \newg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnSome \label{sec:SemanticsRule.SReturnSome}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is \\
    $\Returning((\vvs, \newg), \newenv)$ and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a \texttt{return} statement for a list of expressions, $\SReturn(\langle\ETuple(\es)\rangle)$;
    \item evaluating each expression in $\es$ separately as per \secref{SemanticsRule.EExprListM}
    is either \\ $\Normal(\ms, \newenv)$ \ProseOrAbnormal;
    \item writing the list of values in $\vms$ results in $(\vvs, \newg)$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SReturnSome.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnSome.asl}
    \texttt{return (3, 42);} exits the current subprogram with value \texttt{(3, 42)}.


  \CodeSubsection{\SReturnSomeBegin}{\SReturnSomeEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\newcommand\writefolder[1]{\texttt{write\_folder}(#1)}

We first define the helper relation
\[
  \writefolder{\overname{(\vals\times\XGraphs)^*}{\vms}} \aslrel (\overname{\vals^*}{\vvs}, \overname{\XGraphs}{\newg}) \enspace,
\]
which concatenates the input values in $\vms$ and generates an execution graph
by composing the graphs in $\vms$ with Write Effects for the respective values.

\begin{mathpar}
  \inferrule[empty]{}{
    \writefolder{\emptylist} \evalarrow (\emptylist, \emptygraph)
  }
  \and
  \inferrule[nonempty]{
    \vms \eqname [\vm] \concat \vmsone\\
    \vm \eqdef (\vv, \vg)\\
    \wid \in \Identifiers\text{ is fresh}\\
    \writeidentifier(\wid, \vv) \evalarrow \vgone\\
    \writefolder{\vmsone, \vgone} \evalarrow (\vvsone, \vgtwo)\\
    \vvs \eqdef [\vv] \concat \vvsone\\
    \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \writefolder{\vms} \evalarrow (\vvs, \ordered{\vg}{\aslpo}{\newg})
  }
\end{mathpar}

We now use the helper relation \texttt{write\_folder} to define the rule for returning a tuple of values:
\begin{mathpar}
  \inferrule{
    \evalexprlistm{\env, \es} \evalarrow \Normal(\ms, \newenv) \OrAbnormal\\
    \writefolder{\ms} \evalarrow (\vvs, \newg)
  }
  {
    \evalstmt{\env, \SReturn(\langle\ETuple(\es)\rangle)} \evalarrow \Returning((\vvs, \newg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SSeq \label{sec:SemanticsRule.SSeq}}
  \subsection{Prose}
  Evaluation of the statement $\vs$ in an environment $\env$ is
  either a configuration $D$ (which is not a returning configuration),
  a returning configuration (that is, \\ $\Returning((\vvs, \newg), \newenv)$),
  or an abnormal configuration,
  and all of the following apply:
  \begin{itemize}
    \item $\vs$ is a \emph{sequencing statement} \texttt{s1; s2}, that is, $\SSeq(\vsone, \vstwo)$;
    \item evaluating $\vsone$ in $\env$ is either $\Continuing(\vgone, \envone)$ in which case
    the evaluation continues,
    or a returning configuration ($\Returning((\vvs, \newg), \newenv)$) or an abnormal configuration,
    which short-circuit the entire evaluation;
    \item evaluating $\vstwo$ in $\envone$ is either a non-abnormal configuration $C$
    \ProseOrAbnormal;
    \item $\newg$ is the ordered composition of $\vgone$ and the execution graph of $C$ with the
    $\aslpo$ edge;
    \item $D$ is the configuration $C$ with the execution graph component replaced with $\newg$.
  \end{itemize}

  \subsection{Example: SemanticsRule.SSeq.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SSeq.asl}
  \texttt{let x = 3; let y = x + 1} evaluates \texttt{let x = 3} then \texttt{let y = x + 1}.


  \CodeSubsection{\SSeqBegin}{\SSeqEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalstmt{\env, \vsone} \evalarrow \Continuing(\vgone, \envone) \terminateas \ReturningConfig,\ThrowingConfig,\ErrorConfig\\
    \evalstmt{\envone, \vstwo} \evalarrow C \OrAbnormal\\
    \newg \eqdef \ordered{\vgone}{\aslpo}{\graphof{C}}\\
    D \eqdef \withgraph{C}{\newg}
  }
  {
    \evalstmt{\env, \SSeq(\vsone, \vstwo)} \evalarrow D
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCall \label{sec:SemanticsRule.SCall}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is
    either \\ $\Continuing(\newg, \newenv)$ or an abnormal configuration,
    and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a call statement;
    \item $\vs$ is a call statement, $\SCall(\name, \args, \namedargs)$;
    \item evaluating the subprogram call as per \chapref{eval_call} is
    either \\ $\Normal(\newg, \newenv)$ \ProseOrAbnormal;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCall.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCall.asl}
    \texttt{Zeros(3)} evaluates to \texttt{'000'}.


  \CodeSubsection{\SCallBegin}{\SCallEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalcall{\env, \name, \args, \namedargs} \evalarrow \Normal(\newg, \newenv) \OrAbnormal
  }
  {
    \evalstmt{\env, \SCall(\name, \args, \namedargs)} \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCond \label{sec:SemanticsRule.SCond}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is
    the output configuration $D$, and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a condition statement, $\SCond(\ve, \vsone, \vstwo)$;
    \item evaluating $\ve$ in $\env$ is either $\Normal((\vv, \vgone)$ \ProseOrAbnormal;
    \item $\vv$ is a native Boolean for $\vb$;
    \item the statement $\vsp$ is $\vsone$ is $\vb$ is $\True$ and $\vstwo$ otherwise
    (so that $\vsone$ will be evaluated if the condition evaluates to $\True$ and otherwise
    $\vstwo$ will be evaluated);
    \item evaluating $\vsp$ in $\envone$ as per \chapref{eval_block} is either
    a configuration $C$, which is not abnormal \ProseOrAbnormal;
    \item $\vg$ is the ordered composition of $\vgone$ and the execution graph of the configuration $C$;
    \item $D$ is the configuration $C$ with the execution graph component updated to be $\vg$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCond.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCond.asl}
    does not result in any Assertion Error.


  \CodeSubsection{\SCondBegin}{\SCondEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \envone) \OrAbnormal\\
    \vv \eqname \nvbool(\vb)\\
    \vsp \eqdef \choice{\vb}{\vsone}{\vstwo}\\
    \evalblock{\envone, \vsp} \evalarrow C \OrAbnormal\\\\
    \vg \eqdef \ordered{\vgone}{\aslctrl}{\graphof{C}}\\
    D \eqdef \withgraph{C}{\vg}
  }
  {
    \evalstmt{\env, \SCond(\ve, \vsone, \vstwo)} \evalarrow D
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCase \label{sec:SemanticsRule.SCase}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is a configuration $C$,
    and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a case statement, $\SCase(\ve, \caselist)$;
    \item de-sugaring $\vs$ gives a statement $\vsone$, which assigns $\ve$ to a fresh variable
    and then matches its value against a list of patterns corresponding to $\caselist$ nested conditions.
    In particular, this means that the cases are considered in order and only one of them is executed;
    \item evaluating $\vsone$ in $\env$ results in the output configuration $C$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCase.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCase.asl}
    uses the second \texttt{when} clause because \texttt{3} is less than \texttt{42}.


  \CodeSubsection{\SCaseBegin}{\SCaseEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \hypertarget{def-casetoconds}{}
A case statement is syntactic sugar for a ``condition ladder'' where each
of the alternatives is a pattern.
That is, a statement of the form
\texttt{if e1 then s1; else if e2 then s2; else if e3 then s3; ... else pass;}


We define the relation
\[
  \casetoconds(\expr, (\pattern \times \stmt)^*) \;\bigtimes\; \stmt
\]
which performs this AST-to-AST transformation, effectively desugaring
the case statement.

\begin{mathpar}
  \inferrule[var-empty]{}
  {
    \casetoconds(\EVar(\vx), \emptylist) \evalarrow \SPass
  }
  \and
  \inferrule[var-non-empty]{
    \casetoconds(\EVar(\vx), \caselist) \evalarrow \caselist'
  }
  {
    \casetoconds(\EVar(\vx), [(\vp, \vs)] \concat \caselist) \evalarrow \\
    \SCond(\EPattern(\EVar(\vx), \vp), \vs, \caselist')
  }
  \and
  \inferrule[non-var]{
    \astlabel(\ve) \neq \EVar\\
    \vy \in \Identifiers \text{ is fresh}\\
    \vardecl \eqname \SDecl(\LDKLet, \LDITyped(\LDIVar(\vy), \TInt(\unconstrained)))\\
    \casetoconds(\EVar(\vy), \caselist) \evalarrow \casecond
  }
  {
    \casetoconds(\ve, \caselist) \evalarrow
    \SSeq(\vardecl, \casecond)
  }
\end{mathpar}

We now define the semantics of a case statement in terms of the desugared statement:
\begin{mathpar}
  \inferrule{
    \casetoconds(\ve, \caselist) \evalarrow \vsone\\
    \evalstmt{\env, \vsone} \evalarrow C
  }
  {
    \evalstmt{\env, \SCase(\ve, \caselist)} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssert \label{sec:SemanticsRule.SAssert}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is
    $\Continuing(\newg, \newenv)$ or an abnormal configuration,
    and all of the following apply:
    \begin{itemize}
      \item $\vs$ is an assertion statement, $\SAssert(\ve)$;
      \item one of the following holds:
      \begin{itemize}
        \item all of the following hold (\textsc{okay}):
        \begin{itemize}
          \item evaluating $\ve$ in $\env$ is either $\Normal((\vv, \newg), \newenv)$
          \ProseOrAbnormal;
          \item $\vv$ is a native Boolean value for $\True$;
          \item the resulting configuration is $\Continuing(\newg, \newenv)$.
        \end{itemize}

        \item all of the following hold (\textsc{error}):
        \begin{itemize}
          \item evaluating $\ve$ in $\env$ is either $\Normal((\vv, \newg), \newenv)$;
          \item $\vv$ is a native Boolean value for $\False$;
          \item an ``AssertionFailed'' error is returned.
        \end{itemize}
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.SAssertOk.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssertOk.asl}
    \texttt{assert (42 != 3);} ensures that \texttt{3} is not equal to \texttt{42}.

    \subsection{Example: SemanticsRule.SAssertNo.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssertNo.asl}
    \texttt{assert (42 == 3);} results in an ``\texttt{AssertionFailed}'' error.


  \CodeSubsection{\SAssertBegin}{\SAssertEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule[okay]{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \newg), \newenv) \OrAbnormal\\\\
    \vv \eqname \nvbool(\True)
  }
  {
    \evalstmt{\env, \SAssert(\ve)} \evalarrow \Continuing(\newg, \newenv)
  }
  \and
  \inferrule[error]{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \Ignore), \Ignore)\\
    \vv \eqname \nvbool(\False)
  }
  {
    \evalstmt{\env, \SAssert(\ve)} \evalarrow \ErrorVal{AssertionFailed}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SWhile \label{sec:SemanticsRule.SWhile}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is
    the output configuration $C$ and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a \texttt{while} statement, $\SWhile(\ve, \vbody)$;
    \item evaluating the loop as per \secref{SemanticsRule.Loop} in an environment $\env$,
    with the arguments $\True$ (which conveys that this is a \texttt{while} statement), $\ve$, and $\vbody$
    results in $C$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SWhile.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SWhile.asl}
    prints ``\texttt{0123}''.


  \CodeSubsection{\SWhileBegin}{\SWhileEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalloop{\env, \True, \ve, \vbody} \evalarrow C
  }
  {
    \evalstmt{\env, \SWhile(\ve, \vbody)} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SRepeat \label{sec:SemanticsRule.SRepeat}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is
    either \\ $\Returning((\vvs, \newg), \newenv)$ or an output configuration $D$ and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a \texttt{repeat} statement, $\SRepeat(\ve, \vbody)$;
    \item evaluating $\vbody$ in $\env$ as per \chapref{eval_block} \\
    \ProseOrAbnormal,
    or an early return configuration $\Returning((\vvs, \newg), \newenv)$, which also short-circuits the entire evaluation,
    or a non-returning non-abnormal (that is, $\Normal$ or $\Continuing$) $C$;
    \item evaluating the loop as per \secref{SemanticsRule.Loop} in an environment $\envone$,
    with the arguments $\False$ (which conveys that this is a \texttt{repeat} statement), $\ve$, and $\vbody$
    results in $C$;
    \item $\vgtwo$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge;
    \item the output configuration $D$ is the output configuration $C$ with its execution graph
    substituted with $\vgtwo$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SRepeat.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SRepeat.asl}
    prints
    \begin{Verbatim}
      0
      1
      2
      3
    \end{Verbatim}


  \CodeSubsection{\SRepeatBegin}{\SRepeatEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalblock{\env, \vbody} \evalarrow \Continuing(\vgone, \envone) \terminateas \ReturningConfig,\ThrowingConfig,\ErrorConfig\\
    \evalloop{\envone, \False, \ve, \vbody} \evalarrow C\\
    \vgtwo \eqdef \ordered{\vgone}{\aslpo}{\graphof{C}}\\
    D \eqdef \withgraph{C}{\vgtwo}
  }
  {
    \evalstmt{\env, \SRepeat(\ve, \vbody)} \evalarrow D
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SFor \label{sec:SemanticsRule.SFor}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is
    either $\Continuing(\newg, \newenv)$ or an abnormal configuration,
    and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a \texttt{for} statement, $\SFor(\id, \veone, \dir, \vetwo, \vs)$;
    \item evaluating the side-effect-free expression $\veone$ in $\env$ is either
    $\Normal(\vvone, \vgone)$ \ProseOrError;
    \item evaluating the side-effect-free expression $\vetwo$ in $\env$ is either
    $\Normal(\vvtwo, \vgtwo)$ \ProseOrError;
    \item declaring the local identifier $\id$ in $\env$ with value $\vvone$ is $(\vgthree, \envone)$;
    \item evaluating the \texttt{for} loop with arguments $(\id, \veone, \dir, \vetwo, \vs)$ in $\envone$,
    as per \secref{SemanticsRule.For} is either $\Normal(\vgfour, \envtwo)$ \ProseOrAbnormal;
    \item removing the local $\id$ from $\envtwo$ is $\envthree$;
    \item $\newg$ is formed as follows: taking the parallel composition of $\vgone$ and $\vgtwo$,
    then taking the ordered composition of the result with the $\asldata$ edge,
    and finally taking the ordered composition of the result with the $\aslpo$ edges;
    \item $\newenv$ is $\envthree$.
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SFor.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SFor.asl}
    prints
    \begin{Verbatim}
      0
      1
      2
      3
    \end{Verbatim}


  \CodeSubsection{\SForBegin}{\SForEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
Recall that the expressions for the \texttt{for} loop range are side-effect-free,
which is why they are evaluated via the rule for evaluating side-effect-free expressions.
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvone, \vgone) \terminateas \Error\\
    \evalexprsef{\env, \vetwo} \evalarrow \Normal(\vvtwo, \vgtwo) \terminateas \Error\\
    \declarelocalidentifier(\env, \id, \vvone) \evalarrow (\vgthree,\envone)\\
    \evalfor{\envone, \id, \vvone, \dir, \vvtwo, \vs} \evalarrow \Normal(\vgfour, \envtwo) \OrAbnormal\\
    \removelocal(\envtwo, \id) \evalarrow \envthree\\
    \newg \eqdef \ordered{(\vgone \parallelcomp \vgtwo)}{\asldata}{ \ordered{\vgthree}{\aslpo}{\vgfour}   }\\
    \newenv \eqdef \envthree
  }
  {
    \evalstmt{\env, \SFor(\id, \veone, \dir, \vetwo, \vs)} \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SThrowNone \label{sec:SemanticsRule.SThrowNone}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ is $\Throwing((\vex, \newg), \newenv)$,
    and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a \texttt{throw} statement that does not provide an expression, $\SThrow(\None)$;
    \item $\newenv$ is $\env$;
    \item $\vex$ is $\None$;
    \item $\newg$ is the empty graph;
    \item an exception is thrown with $\newenv$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SThrowNone.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SThrowNone.asl}
    throws a ``\texttt{MyException}'' exception.


  \CodeSubsection{\SThrowNoneBegin}{\SThrowNoneEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalstmt{\env, \SThrow(\None)} \evalarrow \Throwing((\None, \emptygraph), \env)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SThrowSomeTyped \label{sec:SemanticsRule.SThrowSomeTyped}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ is either $\Throwing((\vex, \newg), \newenv)$
    or an abnormal configuration,
    and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a \texttt{throw} statement that provides an expression and a type,
    $\SThrow(\langle\ve, \langle\vt\rangle\rangle)$;
    \item evaluating $\ve$ in $\env$ is either $\Normal((\vv, \vgone), \newenv)$ \ProseOrAbnormal;
    \item $\name$ is a fresh identifier (which conceptually holds the exception value);
    \item $\vgtwo$ is a Write Effect to $\name$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge;
    \item $\vex$ consists of the exception value $\vv$, the name of the variable holding it ---
    $\name$, and the type annotation for the exception --- $\vt$;
    \item the result of the entire evaluation is $\Throwing((\vex, \newg), \env)$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SThrowSomeTyped.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SThrowSomeTyped.asl}
    throws a ``\texttt{MyException \{a: 3, b: 42\}}'' exception.


  \CodeSubsection{\SThrowSomeTypedBegin}{\SThrowSomeTypedEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\
    \name\in\Identifiers \text{ is fresh}\\
    \vgtwo \eqdef \WriteEffect(\name)\\
    \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}\\
    \vex \eqdef \langle(\valuereadfrom(\vv, \name),\vt)\rangle
  }
  {
    \evalstmt{\env, \SThrow(\langle\ve, \langle\vt\rangle\rangle)} \evalarrow
    \Throwing((\vex, \newg), \newenv)
  }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.STry \label{sec:SemanticsRule.STry}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ is either a non-abnormal configuration $C$
    or an abnormal configuration,
    and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a \texttt{try} statement, $\STry(\vs, \catchers, \otherwiseopt)$;
    \item evaluating $\vsone$ in $\env$ as per \chapref{eval_block}
    is either a non-abnormal configuration $\sm$ \ProseOrAbnormal;
    \item evaluating $(\catchers, \otherwiseopt, \sm)$ as per \chapref{eval_catchers}
    is $C$, which is the result of the entire evaluation.
    \end{itemize}

    \subsection{Example: SemanticsRule.STry.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.STry.asl}
    does not result in any Assertion error, and the specification terminates with the exit code $0$.


  \CodeSubsection{\STryBegin}{\STryEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalblock{\env, \vsone} \evalarrow \sm \OrAbnormal\\
    \evalcatchers{\env, \catchers, \otherwiseopt, \sm} \evalarrow C
  }
  {
    \evalstmt{\env, \STry(\vsone, \catchers, \otherwiseopt)} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SDeclSome \label{sec:SemanticsRule.SDeclSome}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is
    either $\Continuing(\newg, \newenv)$ or an abnormal configuration,
    and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a declaration with an initial value,
    $\SDecl(\text{ldk}, \ldi, \langle\ve\rangle)$;
    \item evaluating $\ve$ in $\env$ is either $\Normal(\vm, \envone)$ \ProseOrAbnormal;
    \item evaluating the local declaration $\ldi$ with $\langle\vm\rangle$ as the initializing
    value in $\envone$ as per \chapref{eval_local_decl} is $\Normal(\newg, \newenv)$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SDeclSome.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SDeclSome.asl}
    \texttt{let x = 3;} binds \texttt{x} to \texttt{3} in the empty environment.


  \CodeSubsection{\SDeclSomeBegin}{\SDeclSomeEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal(\vm, \envone) \OrAbnormal\\
    \evallocaldecl{\envone, \ldi, \langle\vm\rangle} \evalarrow \Normal(\newg, \newenv)\\
  }
  {
    \evalstmt{\env, \SDecl(\Ignore, \ldi, \langle\ve\rangle)} \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SDeclNone \label{sec:SemanticsRule.SDeclNone}}
    \subsection{Prose}
    Evaluation of the statement $\vs$ in an environment $\env$ is
    either $\Continuing(\newg, \newenv)$ or an abnormal configuration,
    and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a declaration without an initial value, $\SDecl(\Ignore, \ldi, \None)$;
    \item evaluating the local declaration $(\ldi, \None)$ as per \chapref{eval_local_decl}
    is \\ $\Normal(\newg, \newenv)$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SDeclNone.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SDeclNone.asl}
    \texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.


  \CodeSubsection{\SDeclNoneBegin}{\SDeclNoneEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallocaldecl{\env, \vs, \ldi, \None} \evalarrow \Normal(\newg, \newenv)\\
  }
  {
    \evalstmt{\env, \SDecl(\Ignore, \ldi, \None)} \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Blocks \label{chap:eval_block}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The relation
\hypertarget{def-evalblock}{}
\[
  \evalblock{\overname{\envs}{\env} \times \overname{\stmt}{\stm}} \;\aslrel\;
  \overname{\TContinuing}{\Continuing(\newg, \newenv)} \cup
  \overname{\TReturning}{\ReturningConfig} \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup
  \overname{\TError}{\ErrorConfig}
\]
evaluates a statement $\stm$ as a \emph{block}. That is, $\stm$ is evaluated in a fresh local environment,
which drops back to the original local environment of $\env$ when the evaluation terminates.

\section{SemanticsRule.Block \label{sec:SemanticsRule.Block}}
    \subsection{Prose}
    Evaluation of a statement $\stm$ in an environment $\env$ is either
    a continuing configuration $\Continuing(\newg, \newenv)$,
    a returning configuration, or an abnormal configuration,
    and all of the following apply:
    \begin{itemize}
      \item $\blockenv$ is the environment $\env$ modified by replacing the local component
      (of the inner dynamic environment) by an empty one;
      \item evaluating $\stm$ in $\blockenv$, as per \chapref{eval_stmt},
      is either \\ \Continuing(\newg, \blockenvone)
      or a returning configuration or an abnormal configuration, which short-circuit the entire
      evaluation;
      \item $\newenv$ is formed from $\blockenvone$ after restoring the
      variable bindings of $\env$ with the updated values of $\blockenv$.
      The effect is that of discarding the bindings for variables declared inside $\stm$;
      \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}

    \subsection{Example: SemanticsRule.Block.asl}
    In the specification:
    \VerbatimInput{\testdir/SemanticsRule.Block.asl}
    the conditional statement \texttt{if TRUE then\ldots{} end;} defines a
block structure. Thus, the scope of the declaration \texttt{let y = 2;} is
limited to its declaring block---or the binding for \texttt{y} no longer exists
once the block is exited. As a consequence, the subsequent declaration
\texttt{let y = 1} is valid.  By contrast, the assigment of the mutable
variable~\texttt{x} persists after block end. However, observe that \texttt{x}
is defined before the block and hence still exists after the block.

    \CodeSubsection{\BlockBegin}{\BlockEnd}{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{definition}[Function Restriction]
The \emph{restriction} of a function $f : X \rightarrow Y$ to a subset of its domain
$A \subseteq \dom(f)$, denoted as $f|_A$, is defined as follows (the set of input-output pairs):
\[
  f|_A \triangleq \{ (x, f(x)) \;|\; x \in A \} \enspace.
\]
\end{definition}

\begin{mathpar}
  \inferrule{
    \env \eqname (\tenv,\denv)\\
    \blockenv \eqdef (\tenv, (G^\denv, \emptylist))\\
    \evalstmt{\blockenv, \stm} \evalarrow \Continuing(\newg, \blockenvone) \terminateas \ReturningConfig,\ThrowingConfig,\ErrorConfig\\
    \blockenvone\eqdef(\tenv, \denvone)\\
    \newenv \eqdef(\tenv, (G^{\denvone}, L^{\denvone}|_{\dom(L^\denv)}))
  }
  {
    \evalblock{\env, \stm} \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}

That is, evaluating a block discards the bindings for variables declared inside $\stm$.
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Loops \label{chap:eval_loops}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The evaluation of loop is a common part of the evaluation of multiple loop
statements.
%
For example, the semantic rule \emph{Loop} is used by the semantic rule
\emph{SWhile} at \secref{SemanticsRule.SWhile} and the semantic rule
\emph{SRepeat} at \secref{SemanticsRule.SRepeat}.
%
The semantic rule \emph{For} is only used by the semantic rule \emph{SFor} at
\secref{SemanticsRule.SFor}.

\section{SemanticsRule.Loop \label{sec:SemanticsRule.Loop}}
The relation
\hypertarget{def-evalloop}{}
\[
  \evalloop{\overname{\envs}{\env} \aslsep \overname{\Bool}{\iswhile} \aslsep \overname{\expr}{\ve} \aslsep \overname{\stmt}{\vbody}}
  \;\aslrel\;
  \left(
    \begin{array}{cl}
      \Continuing(\overname{\XGraphs}{\newg} \aslsep \overname{\envs}{\newenv}) & \cup \\
      \overname{\TReturning}{\ReturningConfig} & \cup \\
      \overname{\TThrowing}{\ThrowingConfig} & \cup \\
      \overname{\TError}{\ErrorConfig} &
    \end{array}
  \right)
\]
evaluates $\vbody$ in $\env$ as long as $\ve$ holds when $\iswhile$ is $\True$
or until $\ve$ holds when $\iswhile$ is $\False$.
The result is either the continuing configuration $\Continuing(\newg,\newenv)$,
an early return configuration, or an abnormal configuration.

\subsection{Prose}
One of the following applies:
\begin{itemize}
\item all of the following apply (\textsc{exit}):
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is either $\Normal(\condm, \newenv)$ \ProseOrAbnormal;
    \item $\condm$ consists of a native Boolean for $\vb$ and an execution graph $\newg$;
    \item $\vb$ is not equal to $\iswhile$;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$
    and the loop is exited.
  \end{itemize}
\item all of the following apply (\textsc{continue}):
  \begin{itemize}
    \item evaluating $\econd$ in $\env$ is $\Normal(\condm, \envone)$;
    \item $\mcond$ consists of a native Boolean for $\vb$ and an execution graph $\vgone$;
    \item $\vb$ is equal to $\iswhile$;
    \item evaluating $\vbody$ in $\envone$ as per \chapref{eval_block} is either
    $\Continuing(\vgtwo, \envtwo)$ or one of a returning configuration or an abnormal
    configuration, which short-circuits the entire evaluation;
    \item evaluating $(\iswhile, \econd, \vbody)$ in $\envtwo$ as a loop is either \\
    $\Continuing(\vgthree, \newenv)$ or one of a returning configuration or an abnormal
    configuration, which short-circuits the entire evaluation;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label
    and then the ordered composition of the result and $\vgthree$ with the $\aslpo$ edge;
    \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
  \end{itemize}
\end{itemize}

    \subsection{Example: SemanticsRule.Loop.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Loop.asl}
    does not result in any Assertion Error and the specification terminates with exit
    code $0$.


    \CodeSubsection{\LoopBegin}{\LoopEnd}{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally}
The premise $\vb \neq \iswhile$ is $\True$ in the case of a \texttt{while} loop
and the loop condition $\ve$ not holding, which is exactly when we want the
loop to exit. The opposite holds for a \texttt{repeat} loop.
The negation of the condition is used to decide whether to continue the loop iteration.

\begin{mathpar}
  \inferrule[exit]{
    \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \newenv) \OrAbnormal\\
    \condm \eqname (\nvbool(\vb), \newg)\\
    \vb \neq \iswhile
  }
  {
    \evalloop{\env, \iswhile, \econd, \vbody} \evalarrow \Continuing(\newg, \newenv)
  }
\and
  \inferrule[continue]{
    \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \envone)\\
    \condm \eqname (\nvbool(\vb), \vgone)\\
    \vb = \iswhile\\
    \evalblock{\envone, \vbody} \evalarrow \Continuing(\vgtwo, \envtwo) \terminateas \ReturningConfig, \ThrowingConfig, \ErrorConfig\\
    \evalloop{\envtwo, \iswhile, \econd, \vbody} \evalarrow \Continuing(\vgthree, \newenv) \terminateas \ReturningConfig, \ThrowingConfig, \ErrorConfig\\
    \newg \eqdef \ordered{\ordered{\vgone}{\aslctrl}{\vgtwo}}{\aslpo}{\vgthree}
  }
  {
    \evalloop{\env, \iswhile, \econd, \vbody} \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.For \label{sec:SemanticsRule.For}}
The relation
\hypertarget{def-evalfor}{}
\[
  \evalfor{\overname{\envs}{\env} \aslsep \overname{\Identifiers}{\vindexname} \aslsep \overname{\tint}{\vstart}
  \aslsep \overname{\{\UP, \DOWN\}}{\dir} \aslsep \overname{\tint}{\vend} \aslsep \overname{\stmt}{\vbody}}
  \;\aslrel\;
  \left(
    \begin{array}{cl}
    \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TContinuing}{\ContinuingConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup \\
    \overname{\TError}{\ErrorConfig} &
    \end{array}
    \right)
\]
evaluates the \texttt{for} loop with the index variable $\vindexname$ starting from the value
$\vstart$ going in the direction given by $\dir$ until the value given by $\vend$,
executing $\vbody$ on each iteration.
%
The evaluation utilizes two helper relations: $\evalforstep$ and $\evalforloop$.

The helper relation
\[
  \evalforstep(
    \overname{\envs}{\env},
    \overname{\Identifiers}{\vindexname},
    \overname{\tint}{\vstart},
    \overname{\{\UP,\DOWN\}}{\dir})
    \;\aslrel\;
    ((\overname{\tint}{\vstep} \times \overname{\envs}{\newenv}) \times \overname{\XGraphs}{\newg})
\]
either increments or decrements the index variable,
returning the new value of the index variable, the modified environment,
and the resulting execution graph.

The helper relation
\[
  \evalforloop(\overname{
    \envs}{\env},
    \overname{\Identifiers}{\vindexname},
    \overname{\tint}{\vstart},
    \overname{\{\UP,\DOWN\}}{\dir},
    \overname{\tint}{\vend},
    \overname{\stmt}{\vbody}) \;\aslrel\;
    \left(
    \begin{array}{cl}
      \overname{\TContinuing}{\Continuing(\newg, \newenv)} & \cup\\
      \overname{\TReturning}{\ReturningConfig} & \cup\\
    \overname{\TThrowing}{\ThrowingConfig} & \cup \\
    \overname{\TError}{\ErrorConfig} &
    \end{array}
    \right)
\]
executes one iteration of the loop body and then uses $\texttt{eval\_for}$ to execute the remaining
iterations.

\subsection{Prose}
\subsubsection{Stepping the Index Variable}
Evaluating $\evalforstep(\env, \vindexname, \vstart, \dir)$ results in \\ $((\vstep, \newenv), \newg)$
and all of the following apply:
\begin{itemize}
  \item $\opfordir$ is either $\PLUS$ when $\dir$ is $\UP$ or $\MINUS$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item applying the binary operator $\opfordir$ to $\vstart$ and the native integer for $1$ is $\vstep$;
  \item the execution graph for writing $\vstep$ into the identifier $\vindexname$ gives $\vgtwo$;
  \item updating the local component of the dynamic environment of $\env$ by binding \\ $\vindexname$ to $\vstep$
  gives $\newenv$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}

\subsubsection{Running the Loop Body}
Evaluating $\evalforloop(\env, \vindexname, \vstart, \dir, \vend, \vbody)$ gives the configuration
$\Continuing(\newg, \newenv)$
and all of the following apply:
\begin{itemize}
  \item evaluating $\vbody$ as a block statement (see \chapref{eval_block}) in $\env$
  is either \\ $\Continuing(\vgone, \envone)$ or an early return configuration or an abnormal configuration,
  which short-circuits the entire evaluation;
  \item stepping the index $\vindexname$ with $\vstart$ and the direction $\dir$ in $\envone$,
  that is, $\evalforstep(\envone, \vindexname, \vstart, \dir)$ gives $((\vstep, \envtwo), \vgtwo)$;
  \item evaluating the \texttt{for} loop with $(\vindexname, \vstep, \dir, \vend, \vbody)$
  in $\envtwo$ wither results in a continuing configuration $\Continuing(\vgthree, \newenv)$
  or an early return configuration
  or an abnormal configuration, which short-circuits the entire evaluation;
  \item $\newg$ is the ordered composition of $\vgone$, $\vgtwo$, and $\vgthree$ with the $\aslpo$
  edge.
\end{itemize}

\subsubsection{Overall Evaluation}

Evaluating $(\vindexname, \vstart, \dir, \vend, \vbody)$ in $\env$ is either
a continuing configuration $\Continuing(\newg, \newenv)$ or a returning configuration
(in case the body of the loop results in an early return)
or an abnormal configuration,
and All of the following apply:
\begin{itemize}
  \item $\compfordir$ is either $\LT$ when $\dir$ is $\UP$ or $\GT$ when $\dir$ is $\DOWN$;
  \item reading $\vstart$ into the identifier $\vindexname$ gives $\vgone$;
  \item One of the following applies:
    \begin{itemize}
    \item All of the following apply (\textsc{return}):
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native Boolean for $\True$;
      \item $\newg$ is $\vgone$;
      \item $\newenv$ is $\env$;
      \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
    \end{itemize}
    \item All of the following apply (\textsc{continue}):
    \begin{itemize}
      \item using $\compfordir$ to compare $\vend$ to $\vstart$ gives the native Boolean for $\False$;
      \item evaluating the loop body via $\evalforloop$ with \\ $(\vindexname, \vstart, \dir, \vend, \vbody)$
      in $\env$ is either \\ $\Continuing(\vgtwo, \newenv)$ or an early return configuration
      of an abnormal configuration, which short-circuits the entire evaluation;
      \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslctrl$ label.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example: SemanticsRule.For.asl}
The specification:
\VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.For.asl}
does not result in any assertion error, and the specification terminates with exit-code $0$.


\CodeSubsection{\ForBegin}{\ForEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}

Advancing the loop counter one step towards the end of its range is achieved via the following rule:
\begin{mathpar}
  \inferrule{
    \opfordir \eqdef \choice{\dir = \UP}{\PLUS}{\MINUS}\\
    \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\
    \binoprel(\opfordir, \vstart, \nvint(1)) \evalarrow \vstep\\
    \writeidentifier(\vindex, \vstep) \evalarrow \vgtwo\\
    \env \eqname (\tenv, \denv)\\
    \newenv \eqdef (\tenv, (G^\denv, L^\denv[\vindexname\mapsto\vstep]))\\
    \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalforstep(\env, \vindexname, \vstart, \dir) \evalarrow ((\vstep, \newenv), \newg)
  }
\end{mathpar}

Running the loop body is achieved via the following rule:
\begin{mathpar}
  \inferrule{
    \evalblock{\env, \vbody} \evalarrow \Continuing(\vgone, \envone) \terminateas \ReturningConfig, \ThrowingConfig, \ErrorConfig\\
    \evalforstep(\envone, \vindexname, \vstart, \dir) \evalarrow ((\vstep, \envtwo), \vgtwo)\\
    \evalfor{\envtwo, \vindexname, \vstep, \dir, \vend, \vbody} \evalarrow \Continuing(\vgthree, \newenv) \terminateas \ReturningConfig, \ThrowingConfig, \ErrorConfig\\
    \newg \eqdef \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\vgthree}
  }
  {
    \evalforloop(\env, \vindexname, \vstart, \dir, \vend, \vbody) \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}

Finally, the rules for evaluating a \texttt{for} loop utilize both $\evalforstep$
and $\evalforloop$ (the latter in a mutually recursive manner):
\begin{mathpar}
  \inferrule[return]{
    \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
    \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\
    \binoprel(\compfordir, \vend, \vstart) \evalarrow \nvbool(\True)\\
    \newg \eqdef \vgone\\
    \newenv = \env
  }
  {
    \evalfor{\env, \vindexname, \vstart, \dir, \vend, \vbody} \evalarrow \Continuing(\newg, \newenv)
  }
  \and
  \inferrule[continue]{
    \compfordir \eqdef \choice{\dir = \UP}{\LT}{\GT}\\
    \readidentifier(\vindexname, \vstart) \evalarrow \vgone\\
    \binoprel(\compfordir, \vend, \vstart) \evalarrow \nvint(\False)\\
    \evalforloop(\env, \vindexname, \vstart, \dir, \vend, \vbody) \evalarrow \\
    \Continuing(\vgtwo, \newenv) \terminateas \ReturningConfig, \ThrowingConfig, \ErrorConfig\\\\
    \newg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
  }
  {
    \evalfor{\env, \vindexname, \vstart, \dir, \vend, \vbody} \evalarrow \Continuing(\newg, \newenv)
  }
\end{mathpar}

%     Intuitively, a \texttt{for}-loop \texttt{for $i$ = $e_1$ to $e_2$ do $S$} is syntactic sugar for
%     \texttt{$i$ = $e_1$; while $i$ < $e_2$ do $S$; $i$=$i$+1 end}.
%     Similarly, \texttt{for $i$ = $e_1$ downto $e_2$ do $S$} is syntactic sugar for
%     \texttt{$i$ = $e_1$; while $i$ > $e_2$ do $S$; $i$=$i$-1 end}. The important difference between
%     the statement involving the \texttt{while} loop and the original \texttt{for} loop is that the
%     scope of the counter variable is restricted to the body of the \texttt{for}. Notice that this
%     aspect is already handled by the rule for \SFor.

%     To reflect this, we constructs the following two ASTs for each of the cases for the direction of the loop:
% \[
% \begin{array}{rcl}
%   \texttt{Ei}         &\triangleq& \EVar(\vindexname)\\
%   \texttt{plus\_one}   &\triangleq& \SAssign(\texttt{Ei}, \EBinop(\texttt{"+"}, \texttt{Ei}, \texttt{E\_Lit}(\texttt{L\_Int}(1))))\\
%   \texttt{Up\_for\_body}  &\triangleq& \SSeq(\vbody, \texttt{plus\_one})\\
%   \texttt{Up\_cond}       &\triangleq& \EBinop(\LT, \texttt{Ei}, \vend)\\
%   \texttt{Up\_for}       &\triangleq& \SSeq(\SAssign(\texttt{Ei}, \vstart), \SWhile(\texttt{Up\_cond}, \texttt{Up\_for\_body}))\\
%   \hline
%   \texttt{minus\_one}   &\triangleq& \SAssign(\texttt{Ei}, \EBinop(\texttt{"-"}, \texttt{Ei}, \texttt{E\_Lit}(\texttt{L\_Int}(1))))\\
%   \texttt{Down\_for\_body}  &\triangleq& \SSeq(\vbody, \texttt{minus\_one})\\
%   \texttt{Down\_cond}       &\triangleq& \EBinop(\GT, \texttt{Ei}, \vend)\\
%   \texttt{Down\_for}       &\triangleq& \SSeq(\SAssign(\texttt{Ei}, \vstart), \SWhile(\texttt{Down\_cond}, \texttt{Down\_for\_body}))
% \end{array}
% \]

%   We now use the (de-sugared) ASTs to evaluate the statement:
% \begin{mathpar}
%   \inferrule{
%     \evalstmt{\env, \texttt{Up\_for}} \evalarrow C
%   }
%   {
%     \evalfor{\env, \vindexname, \vstart, \texttt{Up}, \vend, \vbody} \evalarrow C
%   }
%   \and
%   \inferrule{
%     \evalstmt{\env, \texttt{Down\_for}} \evalarrow C
%   }
%   {
%     \evalfor{\env, \vindexname, \vstart, \texttt{Down}, \vend, \vbody} \evalarrow C
%   }
% \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Catchers \label{chap:eval_catchers}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The semantic relation for evaluating catchers employs input configurations
consisting of output configuration as an argument.
This argument corresponds to the output configuration resulting from raising
an exception.
The type of this argument is defined as follows:
\hypertarget{def-toutconfig}{}
\[
  \TOutConfig \triangleq \TNormal \cup  \TThrowing \cup \TContinuing \cup \TReturning \cup \TError \enspace.
\]

The relation
\hypertarget{def-evalcatchers}{}
\[
  \evalcatchers{\overname{\envs}{\env} \aslsep \overname{\catcher^*}{\catchers} \aslsep \overname{\langle\stmt\rangle}{\otherwiseopt}
   \aslsep \overname{\TOutConfig}{\sm}} \;\aslrel\;
  \left(
    \begin{array}{cl}
      \TReturning   & \cup\\
      \TContinuing  & \cup\\
      \TThrowing    & \cup \\
      \TError       &
    \end{array}
  \right)
\]
evaluates a list of \texttt{catch} clauses $\catchers$, an \texttt{otherwise} clause,
and a configuration $\sm$ resulting from the evaluation of the throwing expression,
in the environment $\env$. The result is either a continuation configuration,
an early return configuration, or an abnormal configuration.

One of the following applies:
\begin{itemize}
\item SemanticsRule.Catch (see \secref{SemanticsRule.Catch}),
\item SemanticsRule.CatchNamed (see \secref{SemanticsRule.CatchNamed}),
\item SemanticsRule.CatchOtherwise (see \secref{SemanticsRule.CatchOtherwise}),
\item SemanticsRule.CatchNone (see \secref{SemanticsRule.CatchNone}),
\item SemanticsRule.CatchNoThrow (see \secref{SemanticsRule.CatchNoThrow}).
\end{itemize}

We also define two helper relations:
\begin{itemize}
  \item SemanticsRule.FindCatcher (see \secref{SemanticsRule.FindCatcher}),
  \item SemanticsRule.RethrowImplicit (see \secref{SemanticsRule.RethrowImplicit}).
\end{itemize}

\section{SemanticsRule.Catch \label{sec:SemanticsRule.Catch}}
  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item $\sm$ is $\Throwing((\langle \valuereadfrom(\vv, \eid), \vvty \rangle, \sg), \envthrow)$;
  \item $\env$ consists of the static environment $\tenv$ and dynamic environment $\denv$;
  \item $\envthrow$ consists of the static environment $\tenv$ and dynamic environment \\ $\denvthrow$;
  \item $\envone$ is defined by taking the static environment $\tenv$, the global component of the dynamic
  environment from $\denvthrow$ and the local component of the dynamic environment from $\denv$;
  \item finding the first catcher with the static environment $\tenv$, the exception type $\vvty$,
  and the list of catchers $\catchers$ gives a catcher that does not declare a name ($\None$) and gives a statement $\vs$;
  \item evaluating $\vs$ in $\envone$ as a block (\chapref{eval_block}) is either a non-error
  configuration $C$ \ProseOrError;
  \item editing potential implicit throwing configurations via $\rethrowimplicit(\vv, \vvty, C)$
  gives the configuration $D$;
  \item $\newg$ is the ordered composition of $\sg$ and the graph of $D$;
  \item the result of the entire evaluation is $D$ with its graph substituted with $\newg$.
  \end{itemize}

    \subsection{Example: SemanticsRule.Catch.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Catch.asl}
    prints ``\texttt{MyException}''.


  \CodeSubsection{\CatchBegin}{\CatchEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \sm \eqname \Throwing((\langle \valuereadfrom(\vv, \eid), \vvty \rangle, \sg), \envthrow)\\
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \envthrow \eqname (\tenv, (G^{\denvthrow}, L^{\denvthrow}))\\
    \envone \eqdef (\tenv, (G^{\denvthrow}, L^{\denv}))\\
    \findcatcher(\tenv, \vvty, \catchers) \eqname \langle (\None, \Ignore, \vs) \rangle\\
    \evalblock{\envone, \vs} \evalarrow C \terminateas \ErrorConfig\\
    D \eqdef \rethrowimplicit(\vv, \vvty, C)\\
    \newg \eqdef \ordered{\sg}{\aslpo}{\graphof{D}}
  }
  {
    \evalcatchers{\env, \catchers, \otherwiseopt, \sm} \evalarrow \withgraph{D}{\newg}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNamed \label{sec:SemanticsRule.CatchNamed}}
  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
    \item $\sm$ is $\Throwing((\langle \valuereadfrom(\vv, \eid), \vvty \rangle, \sg), \envthrow)$;
    \item $\env$ consists of the static environment $\tenv$ and dynamic environment $\denv$;
    \item $\envthrow$ consists of the static environment $\tenv$ and dynamic environment \\ $\denvthrow$;
    \item $\envone$ is defined by taking the static environment $\tenv$, the global component of the dynamic
    environment from $\denvthrow$ and the local component of the dynamic environment from $\denv$;
    \item finding the first catcher with the static environment $\tenv$, the exception type $\vvty$,
    and the list of catchers $\catchers$ gives a catcher that declares the name $\name$ and gives a statement $\vs$;
    \item $\vgone$ is the execution graph resulting from reading $\vv$ into the identifier $\eid$;
    \item declaring a local identifier $\name$ with $(\veone, \vgone)$ in $\envone$ gives $(\envtwo, \vgtwo)$;
    \item evaluating $\vs$ in $\envtwo$ asa block (\chapref{eval_block}) is either a non-error
    configuration $C$ \ProseOrError;
    \item $\envthree$ is the environment of the configuration $C$;
    \item removing the binding for $\name$ from the local component of the dynamic environment in $\envthree$
    gives $\envfour$;
    \item substituting the environment of $C$ with $\envfour$ gives $D$;
    \item editing potential implicit throwing configurations via $\rethrowimplicit(\vv, \vvty, D)$
    gives the configuration $E$;
    \item $\newg$ is the ordered composition of $\sg$, $\vgone$, $\vgtwo$, and the graph of $E$,
    with the $\aslpo$ edges;
    \item the result of the entire evaluation is $E$ with its graph substituted with $\newg$.
  \end{itemize}

    \subsection{Example: SemanticsRule.CatchNamed.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNamed.asl}
    prints ``\texttt{My exception with my message}''.


  \CodeSubsection{\CatchNamedBegin}{\CatchNamedEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \sm \eqname \Throwing((\langle \valuereadfrom(\vv, \eid), \vvty \rangle, \sg), \envthrow)\\
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \envthrow \eqname (\tenv, (G^{\denvthrow}, L^{\denvthrow}))\\
    \envone \eqdef (\tenv, (G^{\denvthrow}, L^{\denv}))\\
    \findcatcher(\tenv, \vvty, \catchers) \eqname \langle (\langle\name\rangle, \Ignore, \vs) \rangle\\
    \vgone \eqdef \readidentifier(\eid, \vv)\\
    \declarelocalidentifierm(\envone, \name, (\veone, \vgone)) \evalarrow (\envtwo, \vgtwo)\\
    \evalblock{\envtwo, \vs} \evalarrow C \terminateas \ErrorConfig\\
    \envthree \eqdef \environof{C}\\
    \removelocal(\envthree, \name) \evalarrow \envfour\\
    D \eqdef \withenviron{C}{\envfour}\\
    E \eqdef \rethrowimplicit(\vv, \vvty, D)\\
    \newg \eqdef \ordered{\sg}{\aslpo}{ \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\graphof{E}} }
  }
  {
    \evalcatchers{\env, \catchers, \otherwiseopt, \sm} \evalarrow \withgraph{E}{\newg}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchOtherwise \label{sec:SemanticsRule.CatchOtherwise}}
  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
    \item $\sm$ is $\Throwing((\langle \valuereadfrom(\vv, \eid), \vvty \rangle, \sg), \envthrow)$;
    \item $\env$ consists of the static environment $\tenv$ and dynamic environment $\denv$;
    \item $\envthrow$ consists of the static environment $\tenv$ and dynamic environment \\ $\denvthrow$;
    \item $\envone$ is defined by taking the static environment $\tenv$, the global component of the dynamic
    environment from $\denvthrow$ and the local component of the dynamic environment from $\denv$;
    \item finding the first catcher with the static environment $\tenv$, the exception type $\vvty$,
    and the list of catchers $\catchers$ gives a catcher that declares the name $\name$ and gives $\None$
    (that is, neither of the \texttt{catch} clauses matches the raised exception);
    \item evaluating the \texttt{otherwise} statement $\vs$ in $\envtwo$ asa block (\chapref{eval_block})
    is either a non-error configuration $C$ \ProseOrError;
    \item editing potential implicit throwing configurations via $\rethrowimplicit(\vv, \vvty, C)$
    gives the configuration $D$;
    \item $\newg$ is the ordered composition of $\sg$ and the graph of $D$,
    with the $\aslpo$ edge;
    \item the result of the entire evaluation is $D$ with its graph substituted with $\newg$.
  \end{itemize}

    \subsection{Example: SemanticsRule.CatchOtherwise.asl}
     The specification:
     \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchOtherwise.asl}
     prints ``\texttt{Another exception}''.


  \CodeSubsection{\CatchOtherwiseBegin}{\CatchOtherwiseEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \sm \eqname \Throwing((\langle \valuereadfrom(\vv, \eid), \vvty \rangle, \sg), \envthrow)\\
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \envthrow \eqname (\tenv, (G^{\denvthrow}, L^{\denvthrow}))\\
    \envone \eqdef (\tenv, (G^{\denvthrow}, L^{\denv}))\\
    \findcatcher(\tenv, \vvty, \catchers) = \None\\
    \evalblock{\envone, \vs} \evalarrow C \terminateas \ErrorConfig\\
    D \eqdef \rethrowimplicit(\vv, \vvty, C)\\
    \vg \eqdef \ordered{\sg}{\aslpo}{\graphof{D}}
  }
  {
    \evalcatchers{\env, \catchers, \langle\vs\rangle, \sm} \evalarrow \withgraph{D}{\vg}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNone \label{sec:SemanticsRule.CatchNone}}
  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
    \item $\sm$ is $\Throwing((\langle \valuereadfrom(\vv, \eid), \vvty \rangle, \sg), \envthrow)$;
    \item $\env$ consists of the static environment $\tenv$ and dynamic environment $\denv$;
    \item $\envthrow$ consists of the static environment $\tenv$ and dynamic environment \\ $\denvthrow$;
    \item finding the first catcher with the static environment $\tenv$, the exception type $\vvty$,
    and the list of catchers $\catchers$ gives a catcher that declares the name $\name$ and gives $\None$
    (that is, neither of the \texttt{catch} clauses matches the raised exception);
    \item since there no \texttt{otherwise} clause, the result is $\sm$.
  \end{itemize}

    \subsection{Example: SemanticsRule.CatchNone.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNone.asl}
    does not print anything.


  \CodeSubsection{\CatchNoneBegin}{\CatchNoneEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \sm \eqname \Throwing((\langle \valuereadfrom(\vv, \eid), \vvty \rangle, \sg), \envthrow)\\
    \env \eqname (\tenv, \denv)\\
    \findcatcher(\tenv, \vvty, \catchers) = \None
  }
  {
    \evalcatchers{\env, \catchers, \None, \sm} \evalarrow \sm
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNoThrow \label{sec:SemanticsRule.CatchNoThrow}}
  \subsection{Prose}
  all of the following apply:
  \begin{itemize}
    \item One of the following holds:
    \begin{itemize}
      \item (\textsc{implicit\_throw}) $\sm$ is $\Throwing((\None, \sg), \envthrow)$ (that is, an implicit throw);
      \item (\textsc{non\_throwing}) $\sm$ is a normal configuration (that is, the domain of $\sm$ is $\Normal$);
    \end{itemize}
    \item the result is $\sm$.
  \end{itemize}

  \subsection{Example: SemanticsRule.CatchNoThrow.asl}
  The specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNoThrow.asl}
  prints ``\texttt{No exception raised}''.


\CodeSubsection{\CatchNoThrowBegin}{\CatchNoThrowEnd}{../Interpreter.ml}

  % For some reason the emptyformal environment here fails LaTeX compilation.
  %\begin{emptyformal}
    \subsection{Formally}
      \begin{mathpar}
      \inferrule[implicit\_throw]{
        \sm \eqname \Throwing((\None, \sg), \envthrow)
      }
      {
        \evalcatchers{\env, \catchers, \Ignore, \sm} \evalarrow \sm
      }
      \and
      \inferrule[non\_throwing]{
        \configdomain{\sm} = \Normal
      }
      {
        \evalcatchers{\env, \catchers, \Ignore, \sm} \evalarrow \sm
      }
    \end{mathpar}
  %\end{emptyformal}

  \isempty{\subsection{Comments}}

  \section{SemanticsRule.FindCatcher \label{sec:SemanticsRule.FindCatcher}}

\hypertarget{def-findcatcher}{}
The (recursively-defined) helper relation
\[
  \findcatcher(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vvty}, \overname{\catcher^*}{\catchers})
  \;\aslrel\; \langle \catcher \rangle \enspace,
\]
returns the first catcher clause in $\catchers$ that matches the type $\vvty$ (as a singleton set), or an empty set ($\None$),
by invoking $\typesat$ with the static environment $\tenv$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\catchers$ is an empty list;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{match}):
  \begin{itemize}
    \item $\catchers$ has $\vc$ as its head and $\catchersone$ as its tail;
    \item $\vc$ consists of $(\nameopt, \ety, \vs)$;
    \item $\vvty$ type-satisfies $\ety$ in the static environment $\tenv$;
    \item the result is the singleton set for $\vc$.
  \end{itemize}

  \item All of the following apply (\textsc{no\_match}):
  \begin{itemize}
    \item $\catchers$ has $\vc$ as its head and $\catchersone$ as its tail;
    \item $\vc$ consists of $(\nameopt, \ety, \vs)$;
    \item $\vvty$ does not type-satisfy $\ety$ in the static environment $\tenv$;
    \item the result of finding a catcher for $\vvty$ with the type environment $\tenv$ in the tail list $\catchersone$
    is $d$;
    \item the result is $d$.
  \end{itemize}
\end{itemize}


\CodeSubsection{\FindCatcherBegin}{\FindCatcherEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[empty]{}{\findcatcher(\tenv, \vvty, \emptylist) \evalarrow \None}
\and
\inferrule[match]{
  \catchers \eqname [\vc] \concat \catchersone\\
  \vc \eqname (\nameopt, \ety, \vs) \\
  \typesat(\tenv, \vvty, \ety)
}
{
  \findcatcher(\tenv, \vvty, \catchers) \evalarrow \langle\vc\rangle
}
\and
\inferrule[no\_match]{
  \catchers \eqname [\vc] \concat \catchersone\\
  \vc \eqname (\nameopt, \ety, \vs) \\
  \neg\typesat(\tenv, \vvty, \ety)\\
  d \eqdef \findcatcher(\tenv, \vvty, \catchersone)
}
{
  \findcatcher(\tenv, \vvty, \catchers) \evalarrow d
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
This is related to \identr{SPNM}.

\section{SemanticsRule.RethrowImplicit \label{sec:SemanticsRule.RethrowImplicit}}

The helper relation
\hypertarget{def-rethrowimplicit}{}
\[
  \rethrowimplicit(\overname{\valuereadfrom(\vals,\Identifiers)}{\vv} \aslsep \overname{\ty}{\vvty} \aslsep \overname{\TOutConfig}{\vres}) \;\aslrel\; \TOutConfig
\]

changes \emph{implicit throwing configurations} into \emph{explicit throwing configurations}.
That is, configurations of the form $\Throwing((\None, \vg), \envthrowone))$.

$\rethrowimplicit$ leaves non-throwing configurations, and \emph{explicit throwing configurations},
which have the form $\Throwing(\langle(\valuereadfrom(\vv', \eid), \vvty')\rangle, \vg)$, as is.
Implicit throwing configurations are changed by substituting the optional $\valuereadfrom$ configuration-exception type
pair with $\vv$ and $\vvty$, respectively.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{implicit\_throwing}):
  \begin{itemize}
    \item $\vres$ is $\Throwing((\None, \vg), \envthrowone)$, which is an implicit throwing configuration;
    \item the result is $\Throwing((\langle(\vv, \vvty)\rangle, \vg), \envthrowone)$.
  \end{itemize}

  \item All of the following apply (\textsc{explicit\_throwing}):
  \begin{itemize}
    \item $\vres$ is $\Throwing(\langle(\vv', \vvty')\rangle, \vg)$, which is an ``explicit throwing configuration''
    (due to $(\vv', \vvty')$);
    \item the result is $\Throwing((\langle(\vv', \vvty')\rangle, \vg), \envthrowone)$. \\
    That is, the same throwing configuration is returned.
  \end{itemize}

  \item All of the following apply (\textsc{non\_throwing}):
  \begin{itemize}
    \item the configuration, $C$, domain is non-throwing;
    \item the result is $C$.
  \end{itemize}
\end{itemize}


\CodeSubsection{\RethrowImplicitBegin}{\RethrowImplicitEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[implicit\_throwing]{}
  {
    \rethrowimplicit(\vv, \vvty, \Throwing((\None, \vg), \envthrowone)) \evalarrow \\
    \Throwing((\langle(\valuereadfrom(\vv, \eid), \vvty)\rangle, \vg), \envthrowone)
  }
\and
\inferrule[explicit\_throwing]{}
{
  \rethrowimplicit(\vv, \vvty, \Throwing((\langle(\vv', \vvty')\rangle, \vg), \envthrowone)) \evalarrow \\
  \Throwing((\langle(\vv', \vvty')\rangle, \vg), \envthrowone)
}
\and
\inferrule[non\_throwing]{
  \configdomain{C} \neq \Throwing
}
{
  \rethrowimplicit(\Ignore, \Ignore, C, \Ignore) \evalarrow C
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
This is related to \identr{GVKS}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Subprograms \label{chap:eval_call}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The relation
\hypertarget{def-evalcall}{}
\[
  \begin{array}{c}
    \evalcall{\overname{\envs}{\env} \aslsep
    \overbracket{\Identifiers}^{\texttt{name}} \aslsep
    \overbracket{\expr^*}^{\texttt{args}} \aslsep
    \overbracket{(\overname{\Identifiers}{\id_i}\times\overname{\expr}{\ve_i})^*}^{\texttt{named\_args}}} \;\aslrel\; \\
    \Normal(\overbracket{(\vals\times\XGraphs)^*}^{\vmstwo}, \overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
  \end{array}
\]
evaluates a call to the subprogram named $\name$ in the environment $\env$,
with the argument expressions
$\args$, and the parameter expressions $\namedargs$.
The evaluation results in either a list of returned values, each one associated
with an execution graph, and a new environment;
or an abnormal configuration.

The evaluation first evaluates the expressions corresponding to the arguments
and parameters and then passes their values in a resulting configuration
to the helper relation \texttt{eval\_subprogram}.

The relation
\hypertarget{def-evalsubprogram}{}
\[
  \begin{array}{c}
    \evalsubprogram{\overname{\envs}{\env} \aslsep
    \overname{\Identifiers}{\name} \aslsep
    \overname{(\vals \times \XGraphs)^*}{\actualargs} \aslsep
    \overname{(\Identifiers\times\vals)^*}{\params}} \aslrel \\
    \Normal(\overname{(\vals^* \aslsep \XGraphs)}{\vvs}, \overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup
    \overname{\TError}{\ErrorConfig}
  \end{array}
\]
evaluates the subprogram named $\name$ in the environment $\env$, with
$\actualargs$ the list of actual arguments, and $\params$ the
list of arguments deduced by type equality.
The result is either a normal configuration or an abnormal configuration.
In the case of a normal configuration, it consists of a list of pairs
with a value and an identifier, and a new environment $\newenv$.
The values represent values returned by the subprogram call and the
identifiers are used in generating execution graph constraints for the
returned values.

The main subprogram call relation is given by
SemanticsRule.Call (see \secref{SemanticsRule.Call}).
%
The different types of subprogram calls are given by one of the following:
\begin{itemize}
\item SemanticsRule.FPrimitive (see \secref{SemanticsRule.FPrimitive}),
\item SemanticsRule.FCall (see \secref{SemanticsRule.FCall}).
\end{itemize}

\section{SemanticsRule.ReadValueFrom \label{sec:SemanticsRule.ReadValueFrom}}
\newcommand\readvaluefrom[0]{\texttt{read\_value\_from}}
The helper relation
\[
  \readvaluefrom(\vals \aslsep \Identifiers) \;\aslrel\; (\vals \times \XGraphs)
\]
generates an execution graph for reading the given value to a variable given
by the identifier, and pairs it with the given value.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item reading the value $\vv$ into the variable named $\id$ gives $\newg$;
  \item the result is $(\vv, \newg)$.
\end{itemize}


\CodeSubsection{\ReadValueFromBegin}{\ReadValueFromEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \readidentifier(\vv, \id) \evalarrow \newg
  }
  {
    \readvaluefrom(\vv, \id) \evalarrow (\vv, \newg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.Call \label{sec:SemanticsRule.Call}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\namedargs$ is a list of identifier-expression pairs $(\id_i, \ve_i)$, for $i=1..k$;
  \item $\names$ is the list of identifiers in $\namedargs$;
  \item $\nargsone$ is the list of argument expressions in $\namedargs$;
  \item evaluating each expression in $\args$ separately in $\env$ as per \secref{SemanticsRule.EExprListM}
  is either $\Normal(\vargs, \envone)$ \ProseOrAbnormal;
  \item evaluating each expression in $\nargs$ separately in $\envone$ as per \secref{SemanticsRule.EExprListM}
  is either $\Normal(\nargstwo, \envtwo)$ \ProseOrAbnormal;
  \item $\nargstwo$ is the list of value-execution graph pairs $\vm_i$, for $i=1..k$;
  \item $\nargsthree$ is the list of pairs $(\id_i, \vm_i)$, for $i=1..k$ (this is the format needed
  for \texttt{eval\_subprogram});
  \item $\envtwo$ consists of the static environment $\tenv$ and the dynamic environment $\denvtwo$;
  \item the environment $\envtwo'$ is defined as the environment
  consisting of the static environment $\tenv$ and the dynamic environment with the global component
  of $\denvtwo$ and an empty local component (intuitively, this is because the called subprogram does not have access
  to the local environment of the caller);
  \item evaluating the subprogram named $\name$ with arguments $\vvargs$ and parameters $\nargsthree$ in
  $\denvtwo'$ is either $\Normal(\vms, (\vglobal, \Ignore))$ (that is, we ignore the local environment
  of the callee) \ProseOrAbnormal;
  \item the list $\vms$ consists of value-identifier pairs $(\vv_j, \rid_j)$, for $i=1..n$;
  \item applying the helper relation $\readvaluefrom$ to each $(\vv_j, \rid_j)$
  results in $\vmstwo_j$, for $i=1..n$;
  \item $\vmstwo$ is defined as the list of $\vmstwo_j$, for $i=1..n$;
  \item $\newenv$ consists of the static environment $\tenv$ and the dynamic environment consisting
  of $\vglobal$ as the global component and the local component of $\denvtwo$ (that is, we restore
  the local environment to that of the caller and drop the local environment of the callee).
  \item the entire evaluation results in $\Normal(\vmstwo, \newenv)$.
\end{itemize}


\CodeSubsection{\CallBegin}{\CallEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \namedargs \eqname [i=1..k: (\id_i, \ve_i)]\\
  \names \eqdef [i=1..k: \id_i]\\
  \nargsone \eqdef [i=1..k: \ve_i]\\
  \evalexprlistm{\env, \args} \evalarrow \Normal(\vvargs, \envone)\OrAbnormal\\
  \evalexprlistm{\envone, \nargs1} \evalarrow \Normal(\nargstwo, \envtwo)\OrAbnormal\\
  \nargstwo \eqname [i=1..k: \vm_i]\\
  \nargsthree \eqdef [i=1...k: (\id_i, \vm_i)]\\
  \envtwo \eqname (\tenv, \denvtwo)\\
  \envtwo' \eqdef (\tenv,(G^\denvtwo,\emptyfunc))\\
  \evalsubprogram{\envtwo', \name, \vvargs, \nargsthree} \evalarrow \\ \Normal(\vms, (\vglobal, \Ignore)) \OrAbnormal\\
  \vms \eqname [j=1..n: (\vv_j, \rid_j)]\\
  j=1..n: \readvaluefrom(\vv_j, \rid_j) \evalarrow \vmstwo_j\\
  \vms \eqdef [j=1..n: \vmstwo_j]\\
  \newenv \eqdef (\tenv, (\vglobal, L^{\denvtwo}))
}
{
  \evalcall{\env, \name, \args, \namedargs} \evalarrow \Normal(\vmstwo, \newenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.WriteRetVals \label{sec:SemanticsRule.WriteRetVals}}
\newcommand\writeretvals[0]{\texttt{write\_ret\_vals}}
The helper relation
\[
  \writeretvals(\overname{(\overname{\overname{\vals}{\vv}\times\overname{\XGraphs}{\vgone}}{\vm})^*}{\vvsm}) \;\aslrel\;
  (\overname{\vals^*}{\vvs}\times\overname{\XGraphs}{\newg}) \enspace.
\]
generates Write Effects for the values
returned by the evaluation of a primitive subprogram:

\subsection{Prose}
  One of the following apply:
  \begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item the list of value-execution graphs $\vvsm$ is empty;
    \item the result is a pair consisting of an empty list and an empty graph.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item the list of value-execution graphs $\vvsm$ has $\vm$ as its head and $\vvsmone$ as its tail;
    \item $\vx$ is a fresh identifier;
    \item $\vm$ consists of the value $\vv$ and execution graph $\vgone$;
    \item the execution graph $\vgtwo$ is generating by writing the value $\vv$ for the variable named $\vx$;
    \item writing the returned values in $\vvsmone$ gives $(\vvsone, \vgthree)$;
    \item $\vs$ is defined as the list with $\vv$ as its head and $\vvsone$ as its tail;
    \item $\newg$ is defined by first taking the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge
    and then composing the resulting execution graph in parallel with $\vgthree$;
    \item the result of the entire evaluation is $(\vvs, \newg)$.
  \end{itemize}
\end{itemize}

%% Annotating the OCaml code is problematic, since the code for this rule is inside the code
%% for FPrimitive. One option is to factor it out into a seperate function.
%
%   \CodeSubsection{\WriteRetValsBegin}{\WriteRetValsEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule[empty]{}
    {
      \writeretvals(\emptylist) \evalarrow (\emptylist, \emptygraph)
    }
    \and
    \inferrule[non\_empty]{
      \vvsm \eqname [\vm] \concat \vvsmone\\
      \vx \in \Identifiers \text{ is fresh}\\
      \vm \eqname (\vv, \vgone)\\
      \writeidentifier(\vx, \vv) \evalarrow \vgtwo\\
      \writeretvals(\vvsmone) \evalarrow (\vvsone, \vgthree)\\
      \vvs \eqdef [\vv] \concat \vvsone\\
      \newg \eqdef (\ordered{\vgone}{\asldata}{\vgtwo}) \parallelcomp \vgthree
    }
    {
      \writeretvals(\vvsm) \evalarrow (\vvs, \newg)
    }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.FPrimitive \label{sec:SemanticsRule.FPrimitive}}
  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item $\env$ consists of the static environment $\tenv$ and the dynamic environment with $\genv$ as its
  global component and an empty local component;
  \item finding the function named $\name$ in the static environment $\tenv$ gives a $\func$ AST node
  with the body field \SBPrimitive;
  \item evaluating the primitive subprogram $\name$ with the actual arguments $\actualargs$
  is either $\Normal(\vms, \vgone)$ \ProseOrError;
  \item writing the returned values $\vms$ as per \secref{SemanticsRule.WriteRetVals} gives $\vvsm$;
  \item $\vvsm$ is a pair consisting of the list of values $\vvs$ and execution graph $\vgtwo$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ label;
  \item $\newenv$ is the environment with $\tenv$ as its static environment component
  and the dynamic environment consisting of $\genv$ as its global component and an empty local component;
  \item the result of the entire evaluation is $\Normal((\vvs, \newg), \newenv)$.
  \end{itemize}

  \subsection{Example}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.FPrimitive.asl}
  \texttt{print ("Hello, world!");} calls the primitive \texttt{print} on the evaluation of \texttt{"Hello, world!"}.


  \CodeSubsection{\FPrimitiveBegin}{\FPrimitiveEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  The following rule utilizes the transition relation
  \hypertarget{def-evalprimitive}{}
  \[
    \evalprimitive{\overname{\Identifiers}{\name} \aslsep \overname{(\vals\times\XGraphs)^*}{\actualargs}} \bigtimes
    \Normal(\overname{(\vals\times\XGraphs)^*}{\vms} \aslsep \overname{\XGraphs}{\vgone}) \cup \overname{\TError}{\ErrorConfig} \enspace,
  \]
  which parameterizes the ASL semantics and allows evaluating primitive subprograms.
  That is, it is not a part of $\evalarrow$ but rather a separate transition relation denoted $\evalprimitivearrow$.

  \begin{mathpar}
    \inferrule{
      \env \eqname (\tenv, (\genv, \emptyfunc))\\
      \findfunc(\tenv, \name) = \{ \body = \SBPrimitive \ldots \}\\
      \evalprimitive{\name, \actualargs} \evalprimitivearrow \Normal(\vms, \vgone) \terminateas \ErrorConfig\\
      \writeretvals(\vms) \evalarrow \vvsm\\
      \vvsm \eqname (\vvs, \vgtwo)\\
      \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}\\
      \newenv \eqdef (\tenv, (\genv, \emptyfunc))
    }
    {
      \evalsubprogram{\env, \name, \actualargs, \params} \evalarrow \Normal((\vvs, \newg), \newenv)
    }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.AssignArgs \label{sec:SemanticsRule.AssignArgs}}
The helper relation
\hypertarget{def-assignargs}{}
\[
  \assignargs((\overname{\envs}{\env}\times\overname{\XGraphs}{\vgone})\aslsep \overname{(\Identifiers\times\ty)^*}{\texttt{arg\_decls}}
                  \aslsep \overname{(\vals\times\XGraphs)^*} {\texttt{actual\_args}}) \;\aslrel\;
              (\overname{\envs}{\newenv} \times \overname{\XGraphs}{\newg})
\]
assigns the values of (the actual) arguments to the
formal variables of a given subprogram.

\subsection{Prose}
One of the following apply:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item both $\argdecls$ and $\actualargs$ are empty lists;
    \item the result is $(\env, \vgone)$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\argdecls$ has $(\vx, \Ignore)$ as its head and $\argdecls$ as its tail,
    and $\actualargs$ has $\vm$ as its head and $\actualargs$ as its tail;
    \item declaring the local identifier $\vx$ with $\vm$ in $\env$ as per \secref{SemanticsRule.DeclareLocalIdentifierMM}
    gives \\ $(\envone, \vgtwo)$.
    \item assigning the remaining lists $\argdecls$ and $\actualargs$ with the environment $\envone$ and the ordered
    composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge gives $(\newenv, \newg)$.
    \item the entire result of the evaluation is $(\newenv, \newg)$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
    \inferrule[empty]{}
    {
      \assignargs((\env, \vgone), \emptylist, \emptylist) \evalarrow (\env, \vgone)
    }
    \and
    \inferrule[non\_empty]{
      \declarelocalidentifiermm(\env, \vx, \vm) \evalarrow (\envone, \vgtwo)\\
      \assignargs((\envone, \ordered{\vgone}{\aslpo}{\vgtwo}), \argdecls, \actualargs) \evalarrow (\newenv, \vg)
    }
    {
      \assignargs((\env, \vgone), [(\vx, \Ignore)] \concat \argdecls, [\vm] \concat \actualargs) \evalarrow (\newenv, \vg)
    }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.AssignNamedArgs \label{sec:SemanticsRule.AssignNamedArgs}}
The helper relation
\hypertarget{def-assignnamedargs}{}
\[
  \begin{array}{c}
    \assignnamedargs((\overname{\envs}{\env}\times\overname{\XGraphs}{\vgone}) \aslsep
    \overname{(\overname{\Identifiers}{\vx}\times\overname{(\vals\times\XGraphs)}{\vm})^*}{\params}) \;\aslrel\;
    (\overname{\envs}{\newenv}\times\overname{\XGraphs}{\newg})
  \end{array}
\]
assigns values to the variables that correspond
to the parameters of a given subprogram.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\params$ is an empty list;
    \item the result is $\env, \vgone$;
  \end{itemize}

  \item All of the following apply (\textsc{declared}):
  \begin{itemize}
    \item $\params$ has $(\vx,\vm)$ as its head and $\paramsone$ as its tail;
    \item $\env$ consists of the static environment $\tenv$ and dynamic environment $\denv$;
    \item $\vx$ is bound to a value in $\denv$;
    \item $\vacc$ is defined as $(\env,\vgone)$;
    \item assigning the named args with $\vacc$ and $\paramsone$ gives $(\newenv, \vgtwo)$;
    \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge.
    \item the result is $(\newenv, \newg)$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_declared}):
  \begin{itemize}
    \item $\params$ has $(\vx,\vm)$ as its head and $\paramsone$ as its tail;
    \item $\env$ consists of the static environment $\tenv$ and dynamic environment $\denv$;
    \item $\vx$ is not bound to a value in $\denv$;
    \item declaring the local identifier $\vx$ with $\vm$ in $\env$, as per \secref{SemanticsRule.DeclareLocalIdentifierM},
    gives $(\envone, \vgtwo)$;
    \item $\vacc$ is defined as $(\envone,\vgtwo)$;
    \item assigning the named args with $\vacc$ and $\paramsone$ gives $(\newenv, \vgthree)$;
    \item $\newg$ is the ordered composition of $\vgone$, $\vgtwo$, and $\vgthree$ with the $\aslpo$ edge.
    \item the result is $(\newenv, \newg)$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\newcommand\isbound[0]{\hyperlink{def-isbound}{\texttt{is\_bound}}}
\hypertarget{def-isbound}{}
We use the helper predicate
\[
\isbound(\denv, \vx) \triangleq G^\denv(\vx) \neq \bot \vee L^\denv(\vx) \neq \bot
\]
to test whether the variable $\vx$ is bound in the dynamic environment $\denv$.

\begin{mathpar}
  \inferrule[empty]{}
  {
    \assignnamedargs((\env, \vgone), \emptylist) \evalarrow (\env, \vgone)
  }
  \and
  \inferrule[declared]{
    \params \eqname [(\vx, \vm)] \concat \paramsone\\
    \env \eqname (\tenv, \denv)\\
    \isbound(\denv,\vx)\\
    \vacc \eqdef (\env, \vgone) \\
    \assignnamedargs(\vacc, \paramsone) \evalarrow (\newenv, \vgtwo)\\
    \newg \eqdef \ordered{\vgone}{\aslpo}{\vgtwo}
  }
  {
    \assignnamedargs((\env, \vgone), \params) \evalarrow (\newenv, \newg)
  }
  \and
  \inferrule[not\_declared]{
    \params \eqname [(\vx, \vm)] \concat \paramsone\\
    \env \eqname (\tenv, \denv)\\
    \neg\isbound(\denv,\vx)\\
    \declarelocalidentifierm(\env, \vx, \vm) \evalarrow (\envone, \vgtwo)\\
    \vacc \eqdef (\envone, \vgtwo) \\
    \assignnamedargs(\vacc, \paramsone) \evalarrow (\newenv, \vgthree)\\
    \newg \eqdef \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\vgthree}
  }
  {
    \assignnamedargs((\env, \vgone), \params) \evalarrow (\newenv, \newg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.MatchFuncRes \label{sec:SemanticsRule.MatchFuncRes}}
The helper relation
\hypertarget{def-matchfuncres}{}
\[
    \matchfuncres(\TContinuing \cup \TReturning) \;\aslrel\;
                  \Normal(((\Identifiers\times\vals)^*\times\XGraphs)\aslsep\envs)
\]
converts normal and throwing configurations
into corresponding normal configurations that can be returned by a subprogram evaluation.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{continuing}):
  \begin{itemize}
    \item the given configuration is $\Continuing(\vg, \env)$. This happens when,
    for example, the subprogram called is either a setter or a procedure;
    \item the result is $\Normal((\emptylist, \vg), \env)$.
  \end{itemize}

  \item All of the following apply (\textsc{returning}):
  \begin{itemize}
    \item the given configuration is $\Returning(\xs, \retenv)$, which is the case of a function;
    \item $\xs$ is the list $\vv_i$, for $i=1..k$;
    \item define the list of fresh identifiers $\id_i$, for $i=1..k$;
    \item define $\vvs$ to be $(\vv_i, \id_i)$, for $i=1..k$;
    \item the result is $\Normal((\vvs, \emptygraph), \retenv)$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[continuing]{}
  {
    \matchfuncres(\Continuing(\vg, \env)) \evalarrow \Normal((\emptylist, \vg), \env)
  }
  \and
  \inferrule[returning]{
    \xs \eqname [i=1..k: \vv_i]\\
    i=1..k: \id_i \in \Identifiers\text{ is fresh}\\
    \vvs \eqdef [i=1..k: (\vv_i, \id_i)]
  }
  {
    \matchfuncres(\Returning(\xs, \retenv)) \evalarrow \Normal((\vvs, \emptygraph), \retenv)
  }
\end{mathpar}

\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.FCall \label{sec:SemanticsRule.FCall}}
  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
    \item $\env$ consists of the static environment $\tenv$ and the dynamic environment with the global
    component $\genv$ and an empty local component;
    \item finding the function named $\name$ in $\tenv$ gives the AST $\func$ node with body
    $\SBASL(\vbody)$ and arguments $\argdecls$;
    \item $\envone$ is the environment consisting of the static environment $\tenv$ and the dynamic1
    environment consisting of the dynamic component from $\denv$ and an empty local component;
    \item assigning the actual arguments with $((\envone, \emptygraph), \argdecls, \actualargs)$
    as per \secref{SemanticsRule.AssignArgs} gives $(\envtwo, vgtwo)$ make sure that each
    formal arugment in $\argdecls$ is
    locally bound to the corresponding actual argument in $\actualargs$;
    \item declaring and assigning the parameter values with $((\envtwo, \vgtwo), \params)$
    as per \secref{SemanticsRule.AssignNamedArgs} gives $(\envthree, \vgthree)$;
    \item evaluating the body of the subprogram $\vbody$ as a statement in in $\envthree$
    is either $\vres$ \ProseOrAbnormal;
    \item matching the result $\vres$ to obtain a normal configuration as per \secref{SemanticsRule.MatchFuncRes}
    gives $C$;
    \item $\newg$ is the ordered composition of $\vgtwo$ and $\vgthree$ with the $\aslpo$ edge;
    \item the result is $C$ with its graph substituted for $\newg$.
  \end{itemize}

  \subsection{Example: SemanticsRule.FCall.asl}
  The specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.FCall.asl}
  calls the function \texttt{foo} and the procedure \texttt{bar}.

  \CodeSubsection{\FCallBegin}{\FCallEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \env \eqname (\tenv, \denv)\\
      \findfunc(\tenv, \name) \eqname \{ \body: \SBASL(\vbody), \args: \argdecls, \ldots \}\\
        \envone \eqdef (\tenv, (G^\denv, \emptyfunc))\\
        \assignargs((\envone, \emptygraph), \argdecls, \actualargs) \evalarrow (\envtwo, \vgtwo)\\
        \assignnamedargs((\envtwo, \vgtwo), \params) \evalarrow (\envthree, \vgthree)\\
        \evalstmt{\envthree, \vbody} \evalarrow \vres \OrAbnormal\\
        \matchfuncres(\vres) \evalarrow C\\
        \newg \eqdef \ordered{\vgtwo}{\aslpo}{\vgthree}\\
    }
    {
      \evalsubprogram{\env, \name, \actualargs, \params} \evalarrow \withgraph{C}{\newg}
    }
  \end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  This is related to \identr{DFWZ}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Specifications \label{chap:eval_spec}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The rule SemanticsRule.TopLevel (see \secref{SemanticsRule.TopLevel})
evaluates entire specifications with the help of the following rules:
\begin{itemize}
  \item SemanticsRule.EvalGlobals (see \secref{SemanticsRule.EvalGlobals});
  \item SemanticsRule.BuildGlobalEnv (see \secref{SemanticsRule.BuildGlobalEnv}).
\end{itemize}

\section{SemanticsRule.TopLevel \label{sec:SemanticsRule.TopLevel}}
The relation
\hypertarget{def-evalspec}{}
\[
  \evalspec{\overname{\spec}{\parsedast}, \overname{\spec}{\parsedstd}} \;\aslrel\;
   ((\overname{\vals}{\vv}\times \overname{\XGraphs}{\vg}) \cup \overname{\TError}{\ErrorConfig})
\]
evaluates the \texttt{main} function in a given specification and standard library.

\newcommand\annotatespec[0]{\hyperlink{def-annotatespec}{\texttt{annotate\_spec}}}
\hypertarget{def-annotatespec}{}
The function $\annotatespec$, which is defined in the typing reference~\cite{ASLTypingReference},
takes an initial typing environment and a parsed AST and returns a corresponding typed AST and typing
environment.

\subsection{Prose}
  All of the following apply:
  \begin{itemize}
    \item the AST for the parsed specification, $\parsedspec$, and AST for the parsed standard library,
    $\parsedstd$, are concatenated to give $\parsedast$;
    \item applying the type-checker to $\parsedast$ with an empty static environment is either
    $(\typedspec, \tenv)$ \ProseOrError;
    \item populating the environment with the declarations of the global storage elements
    is either $(\env, \vgone)$ \ProseOrError;
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply (\textsc{normal}):
      \begin{itemize}
        \item evaluating the subprogram \texttt{main} with an empty list of actual arguments and empty list of parameters
        in $\env$ is either $\Normal([(\vv, \vgtwo)], \Ignore)$ \ProseOrError;
        \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge;
        \item the result of the entire evaluation is $(\vv, \newg)$.
      \end{itemize}

      \item All of the following apply (\textsc{throwing}):
      \begin{itemize}
        \item evaluating the subprogram \texttt{main} with an empty list of actual arguments and empty list of parameters
        in $\env$ is $\Throwing(\texttt{v\_opt}, \Ignore)$, which is an uncaught exception;
        \item the result of the entire evaluation is an error indicating that an exception was not caught.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\TopLevelBegin}{\TopLevelEnd}{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
  \inferrule[normal]{
    \parsedast \eqdef \parsedspec \concat \parsedstd\\
    \annotatespec(\emptytenv, \parsedast) \eqname (\typedspec,\tenv)\\
    \buildgenv(\typedspec, (\tenv, (\emptyfunc, \emptyfunc))) \evalarrow (\env, \vgone) \terminateas \ErrorConfig\\
    \evalsubprogram{\env, \texttt{"main"}, \emptylist, \emptylist} \evalarrow \Normal([(\vv, \vgtwo)], \Ignore) \terminateas \ErrorConfig\\
    \newg \eqdef \ordered{\vgone}{\aslpo}{\vgtwo}
  }
  {
    \evalspec{\parsedast, \parsedstd} \evalarrow (\vv, \newg)
  }
  \and
  \inferrule[throwing]{
    \parsedast \eqdef \parsedspec \concat \parsedstd\\
    \annotatespec(\emptytenv, \parsedast) \eqdef (\typedspec,\tenv)\\
    \buildgenv(\typedspec, (\tenv, (\emptyfunc, \emptyfunc))) \evalarrow (\env, \vgone)\\
    \evalsubprogram{\env, \texttt{"main"}, \emptylist, \emptylist} \evalarrow \Throwing(\texttt{v\_opt}, \Ignore)
  }
  {
    \evalspec{\parsedspec, \parsedstd} \evalarrow \ErrorVal{UncaughtException}
  }
\end{mathpar}
Notice that when the type-checker fails due to a type error in the given specification,
the corresponding premise in the rule above does not hold, and the semantics
is undefined. Indeed, the ASL semantics is only defined for well-typed specifications.
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EvalGlobals \label{sec:SemanticsRule.EvalGlobals}}
The relation
\hypertarget{def-evalglobals}{}
\[
  \evalglobals(\overname{\decl^*}{\vdecls}, (\overname{\overname{\envs}{\env} \times \overname{\XGraphs}{\vgone}}{\envm}))
  \;\aslrel\; \overname{(\envs \times \XGraphs)}{C} \cup \overname{\TError}{\ErrorConfig}
\]
updates the input environment and execution graph by initializing the global storage declarations,
either from their initializing expression or from the base value defined for their type as per \secref{SemanticsRule.BaseValue}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item there are no declarations of global variables;
    \item the result is $\envm$.
  \end{itemize}

  \item All of the following apply (\textsc{with\_initial\_value}):
  \begin{itemize}
    \item $\vdecls$ has $\vd$ as its head and $\vdecls'$ as its tail;
    \item $d$ is the AST node for declaring a global storage element with initial value $\ve$,
    name $\name$, and type $\vt$;
    \item $\envm$ is the environment-execution graph pair $(\env, \vgone)$;
    \item evaluating the side-effect-free expression $\ve$ in $\env$ as per \secref{SemanticsRule.ESideEffectFreeExpr}
    is either $(\vv, \vgtwo)$ \ProseOrError;
    \item declaring the global $\name$ with value $\vv$ in $\env$ gives $\envtwo$;
    \item evaluating the remaining global declarations $\vdecls'$ with the environment $\envtwo$ and the execution graph
    that is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ label gives $C$;
    \item the result of the entire evaluation is $C$.
  \end{itemize}

  \item All of the following apply (\textsc{no\_initial\_value}):
  \begin{itemize}
    \item $\vdecls$ has $\vd$ as its head and $\vdecls'$ as its tail;
    \item $d$ is the AST node for declaring a global storage element with no initial value,
    name $\name$, and type $\vt$;
    \item $\envm$ is the environment-execution graph pair $(\env, \vgone)$;
    \item the base value of type $\vt$ in $\env$ is either $(\vv, \vgtwo)$ \ProseOrError;
    \item declaring the global $\name$ with value $\vv$ in $\env$ gives $\envtwo$;
    \item evaluating the remaining global declarations $\vdecls'$ with the environment $\envtwo$ and the execution graph
    that is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ label gives $C$;
    \item the result of the entire evaluation is $C$.
  \end{itemize}
\end{itemize}
\subsection{Example}


% \CodeSubsection{\EvalGlobalsBegin}{\EvalGlobalsEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[empty]{
    \vdecls \eqname \emptylist
  }
  {
    \evalglobals(\vdecls, \envm) \evalarrow \envm
  }
  \and
  \inferrule[with\_initial\_value]{
    \vdecls \eqname [\vd] \concat \vdecls'\\
    \vd \eqname \texttt{D\_GlobalStorage}(\{ \text{initial\_value}=\langle\ve\rangle, \text{name}:\name, \text{ty}:\vt, \ldots \})\\
    \envm \eqname (\env, \vgone)\\
    \evalexprsef{\env, \ve} \evalarrow (\vv, \vgtwo) \terminateas \ErrorConfig\\\\
    \declareglobal(\name, \vv, \env) \evalarrow \envtwo\\
    \evalglobals(\vdecls', (\envtwo, \ordered{\vgone}{\aslpo}{ \vgtwo })) \evalarrow C
  }
  {
    \evalglobals(\vdecls, \envm) \evalarrow C
  }
  \and
  \inferrule[no\_initial\_value]{
    \vdecls \eqname [\vd] \concat \vdecls'\\
    \vd \eqname \texttt{D\_GlobalStorage}(\{ \text{initial\_value}:\None, \text{name}:\name, \text{ty}:\vt, \ldots \})\\
    \envm \eqname (\env, \vgone)\\
    \basevalue(\env, \vt) \evalarrow (\vv, \vgtwo) \terminateas \ErrorConfig\\\\
    \declareglobal(\name, \vv, \env) \evalarrow \envtwo\\
    \evalglobals(\vdecls', (\envtwo, \ordered{\vgone}{\aslpo}{ \vgtwo })) \evalarrow C
  }
  {
    \evalglobals(\vdecls, \envm) \evalarrow C
  }
\end{mathpar}
\end{emptyformal}
\isempty{\subsection{Comments}}

\section{SemanticsRule.BuildGlobalEnv \label{sec:SemanticsRule.BuildGlobalEnv}}
The helper relation
\hypertarget{def-buildgenv}{}
\[
  \buildgenv(\overname{\envs}{\env}, \overname{\spec}{\typedspec}) \;\aslrel\;
  (\overname{\envs}{\newenv}\times\overname{\XGraphs}{\newg}) \cup \overname{\TError}{\ErrorConfig}
\]
``populates'' the environment and output execution graph with the global
storage declarations.
This works by traversing the global storage declarations in \emph{dependency order}
and updating the environment accordingly. By dependency order, we mean that if
a declaration $b$ refers to an identifier declared in $a$ then $a$ is evaluated
before $b$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item sorting the declarations of the global storage elements in topological order with respect to the dependency order
  gives $\vdecls$;
  \item evaluating the global storage declarations in $\vdecls$ in $\env$ with the empty execution graph
  is either $(\newenv, \newg)$ \ProseOrError.
  \item the result of the entire evaluation is $(\newenv, \newg)$.
\end{itemize}
\subsection{Example}


\CodeSubsection{\BuildGlobalEnvBegin}{\BuildGlobalEnvEnd}{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
\hypertarget{def-topologicaldecls}{}
The helper relation $\topologicaldecls(\overname{\decl^*}{\parsedspec}, \overname{\decl^*}{\parsedstd})$
accepts a specification and returns the subset of global storage declarations ordered by
dependency order.

\begin{mathpar}
  \inferrule{
    \topologicaldecls(\typedspec) \evalarrow \vdecls\\
    \evalglobals(\vdecls, (\env, \emptygraph)) \evalarrow (\newenv, \newg) \terminateas \ErrorConfig
  }
  {
    \buildgenv(\env, \typedspec) \evalarrow (\newenv, \newg)
  }
\end{mathpar}
\end{emptyformal}
\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basic Utility Relations \label{chap:utility}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we define helper relations for operating on native values,
environments, and operations involving values and types.
%
In this chapter rules are presented without examples and the corresponding code.

We now define the following relations:
\begin{itemize}
  \item SemanticsRule.RemoveLocal \secref{SemanticsRule.RemoveLocal};
  \item SemanticsRule.ReadIdentifier \secref{SemanticsRule.ReadIdentifier};
  \item SemanticsRule.WriteIdentifier \secref{SemanticsRule.WriteIdentifier};
  \item SemanticsRule.CreateBitvector \secref{SemanticsRule.CreateBitvector};
  \item SemanticsRule.ConcatBitvectors \secref{SemanticsRule.ConcatBitvectors};
  \item SemanticsRule.ReadFromBitvector \secref{SemanticsRule.ReadFromBitvector};
  \item SemanticsRule.WriteToBitvector \secref{SemanticsRule.WriteToBitvector};
  \item SemanticsRule.GetIndex \secref{SemanticsRule.GetIndex};
  \item SemanticsRule.SetIndex \secref{SemanticsRule.SetIndex};
  \item SemanticsRule.GetField \secref{SemanticsRule.GetField};
  \item SemanticsRule.SetField \secref{SemanticsRule.SetField};
  \item SemanticsRule.DeclareLocalIdentifier \secref{SemanticsRule.DeclareLocalIdentifier};
  \item SemanticsRule.DeclareLocalIdentifierM\secref{SemanticsRule.DeclareLocalIdentifierM};
  \item SemanticsRule.DeclareLocalIdentifierMM \secref{SemanticsRule.DeclareLocalIdentifierMM};
  \item SemanticsRule.DeclareGlobal \secref{SemanticsRule.DeclareGlobal};
  \item SemanticsRule.BaseValue \secref{SemanticsRule.BaseValue};
\end{itemize}

\section{SemanticsRule.RemoveLocal \label{sec:SemanticsRule.RemoveLocal}}
\subsection{Prose}
The relation
\hypertarget{def-removelocal}{}
\[
  \removelocal(\overname{\envs}{\env} \aslsep \overname{\Identifiers}{\name}) \;\aslrel\; \overname{\envs}{\newenv}
\]
removes the binding of the identifier $\name$ from the local storage of the environment $\env$.

Removal of the identifier $\name$ from the local storage of the environment $\env$
is the environment $\newenv$ and all of the following apply:
\begin{itemize}
  \item $\env$ consists of the static environment $\tenv$ and dynamic environment $\denv$;
  \item $\newenv$ consists of the static environment $\tenv$ and the dynamic environment
  with the same global component as $\denv$ --- $G^\denv$, and local compoenent $L^\denv$,
  with the identifier $\name$ removed from its domain.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
(Recall that $[\name\mapsto\bot]$ means that $\name$ is not in the domain of the resulting function.)
\begin{mathpar}
  \inferrule{
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \newenv \eqdef (\tenv, (G^\denv, L^\denv[\name \mapsto \bot]))
  }
  {
    \removelocal(\env, \name) \evalarrow \newenv
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.ReadIdentifier \label{sec:SemanticsRule.ReadIdentifier}}
\subsection{Prose}
The relation
\hypertarget{def-readidentifier}{}
\[
  \readidentifier(\overname{\Identifiers}{\name}\aslsep\overname{\vals}{\vv}) \;\aslrel\; (\overname{\vals}{\vv} \times \XGraphs)
\]
reads a value $\vv$ into a storage element given by an identifier $\name$.
The result is the value and an execution graph containing a single Read Effect,
which denoting reading from $\name$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \readidentifier(\name, \vv) \evalarrow (\vv, \ReadEffect(\name))
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.WriteIdentifier \label{sec:SemanticsRule.WriteIdentifier}}
\subsection{Prose}
The relation
\hypertarget{def-writeidentifier}{}
\[
  \writeidentifier(\overname{\Identifiers}{\name}\aslsep\overname{\vals}{\vv}) \;\aslrel\; \XGraphs
\]
writes the value $\vv$ into a storage element given by an identifier $\name$.
The result is an execution graph containing a single Write Effect,
which denotes writing into $\name$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \writeidentifier(\name, \vv) \evalarrow \WriteEffect(\name)
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.CreateBitvector \label{sec:SemanticsRule.CreateBitvector}}
\subsection{Prose}
The relation
\[
  \createbitvector(\overname{\vals^*}{\vvs}) \;\aslrel\; \tbitvector
\]
creates a native vector value bitvector from a sequence of values $\vvs$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \createbitvector(\vvs) \evalarrow \nvbitvector{\vvs}
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.ConcatBitvectors \label{sec:SemanticsRule.ConcatBitvectors}}
\subsection{Prose}
The relation
\[
  \concatbitvectors(\overname{\tbitvector^*}{\vvs}) \;\aslrel\; \tbitvector
\]
transforms a (possibly empty) list of bitvector native values $\vvs$ into a single bitvector.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[ConcatBitvector.Empty]{}
  {
    \concatbitvectors(\emptylist) \evalarrow \nvbitvector(\emptylist)
  }
  \and
  \inferrule[ConcatBitvector.NonEmpty]{
    \vvs \eqname [\vv] \concat \vvs'\\
    \vv\eqname\nvbitvector(\bv)\\
    \concatbitvectors(\vvs') \evalarrow \nvbitvector(\bv')\\
    \vres \eqdef \bv \concat \bv'
  }
  {
    \concatbitvectors(\vvs) \evalarrow \nvbitvector(\vres)
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.ReadFromBitvector \label{sec:SemanticsRule.ReadFromBitvector}}
\subsection{Prose}
The relation
\[
  \readfrombitvector(\overname{\tbitvector}{\bv} \aslsep \overname{(\tint\times\tint)^*}{\slices}) \;\aslrel\;
  \overname{\tbitvector}{\vv} \cup \overname{\TError}{\ErrorConfig}
\]
reads from a bitvector $\bv$, or an integer seen as a bitvector, the indices specified by the list of slices $\slices$,
thereby concatenating their values,
and one of the following apply:
\begin{itemize}
  \item all indices are in range for $\bv$ and the returned bitvector consists of the concatenated bits specified
  by the slices.
  \item there exists an out-of-range index and an error is returned.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
We start by introducing a few helper relations.

\hypertarget{def-positioninrange}{}
The predicate $\positioninrange(\vs, \vl, n)$ checks whether the indices starting at index $\vs$ and
up to $\vs + \vl$, inclusive, would refer to actual indices of a bitvector of length $n$:
\[
  \positioninrange(\vs, \vl, \vn) \triangleq (\vs \geq 0) \land (\vl \geq 0) \land (\vs + \vl < \vn) \enspace.
\]

The relation
\hypertarget{def-slicestopositions}{}
\[
  \slicestopositions(\overname{\N}{\vn} \aslsep \overname{(\overname{\tint}{\vs_i}\times\overname{\tint}{\vl_i})^+}{\slices}) \;\aslrel\;
  (\overname{\N^*}{\positions} \cup\ \TError)
\]
returns the list of positions (indices) specified by the slices $\slices$,
unless an index would be out of range for a bitvector of length $\vn$, in which case it returns an error configuration.

\begin{mathpar}
  \inferrule[SlicesToPositionsOutOfRange]{
    \slices \eqname [i=1..k: (\nvint(\vs_i), \nvint(\vl_i))]\\
    j \in 1..k: \neg\positioninrange(\vs_j, \vl_j, \vn)
  }
  {
    \slicestopositions(\vn, \slices) \evalarrow \ErrorVal{Slice\_PositionOutOfRange}
  }
  \and
  \inferrule[SlicesToPositionsInRange]{
    \slices \eqname [i=1..k: (\nvint(\vs_i), \nvint(\vl_i))]\\
    i=1..k: \positioninrange(\vs_i, \vl_i, \vn)\\
    \positions \eqdef [\vs_1,\ldots,\vs_1+\vl_1] \concat \ldots \concat [\vs_k,\ldots,\vs_k+\vl_k]\\
  }
  {
    \slicestopositions(\vn, \slices) \evalarrow \positions
  }
\end{mathpar}

\hypertarget{def-asbitvector}{}
The function $\asbitvector : (\tbitvector\cup\tint) \rightarrow \{0,1\}^*$ transforms native value integers and native value bitvectors into
a sequence of binary values:
\begin{mathpar}
  \inferrule[AsBitvectorBitvector]{}
  {
    \asbitvector(\nvbitvector(\bv)) \evalarrow \bv
  }
  \and
  \inferrule[AsBitvectorInt]{
    \bv \eqdef \text{ two's complement representation of }n
  }
  {
    \asbitvector(\nvint(n)) \evalarrow \bv
  }
\end{mathpar}

Finally, the rules below distinguish between empty bitvectors and non-empty bitvectors.
\begin{mathpar}
  \inferrule[ReadFromBitvector.Empty]{}
  {
    \readfrombitvector(\bv, \emptylist) \evalarrow \nvbitvector(\emptylist)
  }
  \and
  \inferrule[ReadFromBitvector.NonEmpty]{
    \asbitvector(\bv) \eqdef \vb_n \ldots \vb_1\\
    \slicestopositions(n, \slices) \evalarrow [j_{1..m}] \terminateas \ErrorConfig\\
    \vv \eqdef \nvbitvector(\vb_{j_m + 1}\ldots\vb_{j_1 + 1})
  }
  {
    \readfrombitvector(\bv, \slices) \evalarrow \vv
  }
\end{mathpar}
Notice that the bits of a bitvector go from the least significant bit being on the right to the most significant bit being on the left,
which is reflected by how the rules list the bits.
The effect of placing the bits in sequence is that of concatenating the results
from all of the given slices.
Also notice that bitvector bits are numbered from 1 and onwards, which is why we add 1 to the indices specified
by the slices when accessing a bit.
\end{emptyformal}

\section{SemanticsRule.WriteToBitvector \label{sec:SemanticsRule.WriteToBitvector}}
\subsection{Prose}
The relation
\[
  \writetobitvector(\overname{(\tint\times\tint)^*}{\slices} \aslsep \overname{\tbitvector}{\src} \aslsep \overname{\tbitvector}{\dst})
  \;\bigtimes\; \overname{\tbitvector}{\vv} \cup \overname{\TError}{\ErrorConfig}
\]
overwrites the bits of $\dst$ at the positions given by $\slices$ with the bits of $\src$
and one of the following apply:
\begin{itemize}
  \item all positions specified by $\slices$ are within range for $\dst$ and the modified version
  of $\dst$ with the bits of $\src$ at the specified positions is returned;
  \item there exists a position in $\slices$ that is not in range for $\dst$ and an error is returned.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[WriteToBitvector.Empty]{}
  {
    \writetobitvector(\emptylist, \nvbitvector(\emptylist), \nvbitvector(\emptylist)) \evalarrow \nvbitvector(\emptylist)
  }
  \and
  \inferrule[WriteToBitvector.NonEmpty]{
    \vs_n \ldots \vs_1 \eqdef \asbitvector(\src)\\
    \vd_n \ldots \vd_1 \eqdef \asbitvector(\dst)\\
    \slicestopositions(n, \slices) \evalarrow \positions \terminateas \ErrorConfig\\
    {\mathit{bit} = \lambda i \in 1..n.\left\{ \begin{array}{ll}
     \vs_i & i \in \positions\\
     \vd_i & \text{otherwise}
    \end{array} \right.}\\
    \vv\eqdef\nvbitvector(\mathit{bit}(n-1)\ldots \mathit{bit}(0))\\
  }
  {
    \writetobitvector(\slices, \src, \dst) \evalarrow \vv
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.GetIndex \label{sec:SemanticsRule.GetIndex}}
\subsection{Prose}
The relation
\hypertarget{def-getindex}{}
\[
  \getindex(\overname{\N}{\vi} \aslsep \overname{\tvector}{\vvec}) \;\aslrel\; \overname{\tvector}{\vv_{\vi}}
\]
reads the value $\vv_i$ from the vector of values $\vvec$ at the index $\vi$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vvec \eqname \vv_{0..k}\\
    \vi \leq k\\
  }
  {
    \getindex(\vi, \vvec) \evalarrow \vv_{\vi}
  }
\end{mathpar}
Notice that there is no rule to handle the case where the index is out of range ---
this is guaranteed by the type-checker not to happen. Specifically,
\begin{itemize}
  \item \texttt{TypingRule.EGetArray} ensures that an index is within the bounds of the array
  being accessed via a check that the type of the index satisfies the type of the array size.
  \item Typing rules \texttt{TypingRule.LEDestructuring}, \texttt{TypingRule.PTuple},
  and \\ \texttt{TypingRule.LDTuple} use the same index sequences for the tuples
  involved and the corresponding lists of expressions.
\end{itemize}
If the rules listed above do not hold the type checker fails.
\end{emptyformal}

\section{SemanticsRule.SetIndex \label{sec:SemanticsRule.SetIndex}}
\subsection{Prose}
The relation
\hypertarget{def-setindex}{}
\[
  \setindex(\overname{\N}{\vi} \aslsep \overname{\vals}{\vv} \aslsep \overname{\tvector}{\vvec}) \;\aslrel\; \overname{\tvector}{\vres}
\]
overwrites the value at the given index $\vi$ in a vector of values $\vvec$ with the new value $\vv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vvec \eqname \vu_{0..k}\\
    \vi \leq k\\
    \vres \eqname \vw_{0..k}\\
    \vv \eqdef \vw_{\vi} \\
    j \in \{0..k\} \setminus \{\vi\}.\ \vw_{j} = \vu_j\\
  }
  {
    \setindex(\vi, \vv, \vvec) \evalarrow \vres
  }
\end{mathpar}
Similar to $\getindex$, there is no need to handle the out-of-range index case.
\end{emptyformal}

\section{SemanticsRule.GetField \label{sec:SemanticsRule.GetField}}
\subsection{Prose}
The relation
\hypertarget{def-getfield}{}
\[
  \getfield(\overname{\Identifiers}{\name} \aslsep \overname{\trecord}{\record}) \;\aslrel\; \vals
\]
retrieves the value corresponding to the field name $\name$ from the record value $\record$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \record \eqname \nvrecord{\fieldmap}
  }
  {
    \getfield(\name, \record) \evalarrow \fieldmap(\name)
  }
\end{mathpar}
The type-checker ensures, via TypingRule.EGetRecordField, that the field $\name$ exists in $\record$.
\end{emptyformal}

\section{SemanticsRule.SetField \label{sec:SemanticsRule.SetField}}
\subsection{Prose}
The relation
\hypertarget{def-setfield}{}
\[
  \setfield(\overname{\Identifiers}{\name} \aslsep \overname{\vals}{\vv} \aslsep \overname{\trecord}{\record}) \;\aslrel\; \trecord
\]
overwrites the value corresponding to the field name $\name$ in the record value $\record$ with the value $\vv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \record \eqname \nvrecord{\fieldmap}\\
    \fieldmap' \eqdef \fieldmap[\name\mapsto\vv]
  }
  {
    \setfield(\name, \vv, \record) \evalarrow \nvrecord{\fieldmap'}
  }
\end{mathpar}
The type-checker ensures that the field $\name$ exists in $\record$.
\end{emptyformal}

\section{SemanticsRule.DeclareLocalIdentifier \label{sec:SemanticsRule.DeclareLocalIdentifier}}
\subsection{Prose}
The relation
\hypertarget{def-declarelocalidentifier}{}
\[
  \declarelocalidentifier(\overname{\envs}{\env} \aslsep \overname{\Identifiers}{\name} \aslsep \overname{\vals}{\vv}) \;\aslrel\;
  (\overname{\envs}{\newenv}\times\overname{\XGraphs}{\vg})
\]
associates $\vv$ to $\name$ as a local storage element in the environment $\env$ and
returns the updated environment $\newenv$ with the execution graph consisting of a Write Effect to $\name$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vg \eqdef \WriteEffect(\name)\\
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \newenv \eqdef (\tenv, (G^\denv, L^\denv[\name\mapsto \vv]))
  }
  { \declarelocalidentifier(\env, \name, \vv) \evalarrow (\newenv, \vg)  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.DeclareLocalIdentifierM \label{sec:SemanticsRule.DeclareLocalIdentifierM}}
\subsection{Prose}
\hypertarget{def-declarelocalidentifierm}{}
The relation
\[
  \declarelocalidentifierm(\overname{\envs}{\env} \aslsep
   \overname{\Identifiers}{\vx} \aslsep
   \overname{(\overname{\vals}{\vv}\times\overname{\XGraphs}{\vg})}{\vm}) \;\aslrel\;
  (\overname{\envs}{\newenv} \times \overname{\XGraphs}{\newg})
\]
declares the local identifier $\vx$ in the environment $\env$, in the context
of the value-graph pair $(\vv, \vg)$, and all of the following apply:
\begin{itemize}
  \item \newenv\ is the environment $\env$ modified to declare the variable $\vx$ as a local storage element;
  \item $\vgone$ is the execution graph resulting from the declaration of $\vx$;
  \item $\vgtwo$ is the execution graph resulting from the ordered composition of $\vg$ and $\vgone$
  with the $\asldata$ edge.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm \eqname (\vv, \vg)\\
    \declarelocalidentifier(\env, \vx, \vv) \evalarrow (\newenv, \vgone)\\
    \newg \eqdef \ordered{\vg}{\asldata}{\vgone}
  }
  {
    \declarelocalidentifierm(\env, \vx, \vm) \evalarrow (\newenv, \newg)
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.DeclareLocalIdentifierMM \label{sec:SemanticsRule.DeclareLocalIdentifierMM}}
\subsection{Prose}
\hypertarget{def-declarelocalidentifermm}{}
The relation
\[
  \declarelocalidentifiermm(\overname{\envs}{\env} \aslsep
   \overname{\Identifiers}{\vx} \aslsep
   \overname{(\overname{\vals}{\vv}\times\overname{\XGraphs}{\vg})}{\vm}) \;\aslrel\;
  (\overname{\envs}{\newenv} \times \overname{\XGraphs}{\vgtwo})
\]
declares the local identifier $\vx$ in the environment $\env$,
in the context of the value-graph pair $(\vv, \vg)$,
and all of the following apply:
\begin{itemize}
  \item \newenv\ is the environment $\env$ modified to declare the variable $\vx$ as a local storage element;
  \item $\vgone$ is the execution graph resulting from the declaration of $\vx$;
  \item $\vgtwo$ is the execution graph resulting from the ordered composition of $\vg$ and $\vgone$
  with the $\aslpo$ edge.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm \eqname (\vv, \vg)\\
    \declarelocalidentifierm(\env, \vx, \vv) \evalarrow (\newenv, \vgone)\\
    \vgtwo \eqdef \ordered{\vg}{\aslpo}{\vgone}
  }
  {
    \declarelocalidentifiermm(\env, \vx, \vm) \evalarrow (\newenv, \vgtwo)
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.DeclareGlobal \label{sec:SemanticsRule.DeclareGlobal}}
\subsection{Prose}
The relation
\hypertarget{def-declareglobal}{}
\[
  \declareglobal(\overname{\Identifiers}{\name} \aslsep \overname{\vals}{\vv} \aslsep \overname{\envs}{\env}) \;\aslrel\; \overname{\envs}{\newenv}
\]
updates the environment $\env$ by mapping $\name$ to $\vv$ as a global storage element.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \newenv \eqdef (\tenv, (G^\denv[\name\mapsto \vv], L^\denv))
  }
  { \declareglobal(\name, \vv, \env) \evalarrow \newenv  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.BaseValue \label{sec:SemanticsRule.BaseValue}}
\subsection{Prose}
The relation
\hypertarget{def-basevalue}{}
\[
  \basevalue(\overname{\envs}{\env} \aslsep \overname{\ty}{\vt}) \;\aslrel\;
  (\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg}) \cup \overname{\TError}{\ErrorConfig}
\]
attempts to return the \emph{base value} of a type.

\hypertarget{def-tstruct}{}
\paragraph{Type Structure} To obtain the base value of a type, we first obtain its \emph{structure}, using the function
$\tstruct : \ty \partialto \ty$.
The structure of a type is the type that can hold the same set of values, but does not itself
contain any other type names.
This is essentially done by recursively replacing type names by their definition.
For more information refer to TypingRule.Structure in
ASL Typing Reference~\cite{ASLTypingReference}.
%
Since we assume the specification is well-typed (\secref{MeaningfulASLSpecifications}),
$\tstruct$ returns a valid type.

The base value of the type $\vt$ in the environment $\env$ is $\vv$,
as well as the execution graph $\vg$ that results
from evaluating any of the side-effect-free expressions appearing in $\vt$,
or an error, and one of the following apply:
\begin{itemize}
  \item all of the following apply (\textsc{boolean}):
  \begin{itemize}
    \item the structure of $\vt$ is the Boolean type;
    \item $\vv$ is the native Boolean "true" value;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item all of the following apply (\textsc{real}):
  \begin{itemize}
    \item the structure of $\vt$ is the real type;
    \item $\vv$ is the native real value $0$;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item all of the following apply (\textsc{string}):
  \begin{itemize}
    \item the structure of $\vt$ is the string type;
    \item $\vv$ is the native value for the empty string;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item all of the following apply (\textsc{bitvector}):
  \begin{itemize}
    \item the structure of $\vt$ is the bitvector with the length expression $\ve$;;
    \item evaluating the side-effect-free expression $\ve$ results in the native value $\length$
    and execution graph $\vg$,
    or an error is returned, short-circuiting the entire rule;
    \item $\vv$ is the bitvector of length $\length$ where all bits are $0$.
  \end{itemize}

  \item all of the following apply (\textsc{enum}):
  \begin{itemize}
    \item the structure of $\vt$ is the enumeration type where the first identifier is $\id_1$;
    \item $\vl$ is the literal associated with $\id_1$ in the static environment;
    \item $\vv$ is the native value literal for $\vl$;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item all of the following apply (\textsc{unconstrained\_integer}):
  \begin{itemize}
    \item the structure of $\vt$ is that of the unconstrained integer;
    \item $\vv$ is the native value integer $0$;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item all of the following apply (\textsc{well\_constrained\_integer}):
  \begin{itemize}
    \item the structure of $\vt$ is that of the well-constrained integer where the first constraint
    is exact with the expression $\ve$;
    \item $(\vv, \vg)$ is the result of evaluating the side-effect-free expression $\ve$.
  \end{itemize}

  \item all of the following apply (\textsc{record}):
  \begin{itemize}
    \item the structure of $\vt$ is that of a record or an exception;
    \item the base value of each field is obtained, and if any of the base values results in an error
    then the entire rule short-circuits with that error;
    \item $\vv$ is the native value record where each identifier in the record is mapped to its
    respective base value;
    \item $\vg$ is the parallel composition of the graphs resulting from the base value evaluation
    of all the fields.
  \end{itemize}

  \item all of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item the structure of $\vt$ is that of a tuple of types;
    \item the base value of each type in the tuple is obtained, and if any of the base values results in an error
    then the entire rule short-circuits with that error;
    \item $\vv$ is the native value vector consisting of the base values in the order of the corresponding types
    of the tuple;
    \item $\vg$ is the parallel composition of the graphs resulting from the base value evaluation
    of all the tuple types.
  \end{itemize}

  \item all of the following apply (\textsc{array\_length\_global\_constant}):
  \begin{itemize}
    \item the structure of $\vt$ is that of an array with length expression $\elength$ and element type $\vvty$;
    \item $\elength$ is the value of a declared constant;
    \item $\elength$ is a variable expression with the variable name $\vx$;
    \item the constant value for $\vx$ in the static environment is the literal integer for $n$;
    \item either the base value of $\vvty$ in $\env$ is $(\velem, \vg)$ or an error, which short-circuits
    the entire evaluation;
    \item $\vv$ is the native value vector of length $n$ where each element is $\velem$;
  \end{itemize}

  \item all of the following apply (\textsc{array\_length\_expression}):
  \begin{itemize}
    \item the structure of $\vt$ is that of an array with length expression $\elength$ and element type $\vvty$;
    \item $\elength$ is not the value of a declared constant;
    \item either the base value of $\vvty$ in $\env$ is $(\velem, \vg)$ or an error, which short-circuits
    the entire evaluation;
    \item either evaluating the side-effect-free expression $\elength$ in the environment $\env$
    results in $(\vlength, \vgtwo)$ or an error, which short-circuits
    the entire evaluation;
    \item $\vlength$ is the native value integer for $n$;
    \item $\vv$ is the native value vector of length $n$ where each element is $\velem$;
    \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
Evaluating the inner expressions of the type $\vt$ is done via the relation\\
$\texttt{eval\_expr\_sef}$~\ref{sec:SemanticsRule.ESideEffectFreeExpr}.
If evaluating an inner expression results in an error, there is no base value and an error configuration is returned.

\begin{mathpar}
  \inferrule[bool]{
    \tstruct(\vt) = \TBool
  }
  {
    \basevalue(\env, \vt) \evalarrow (\nvbool(\True), \emptygraph)
  }
  \and
  \inferrule[real]{
    \tstruct(\vt) = \TReal
  }
  {
    \basevalue(\env, \vt) \evalarrow (\nvreal(0), \emptygraph)
  }
  \and
  \inferrule[string]{
    \tstruct(\vt) = \TString
  }
  {
    \basevalue(\env, \vt) \evalarrow (\nvliteral{\lstring(\emptylist)}, \emptygraph)
  }
\end{mathpar}

The base value of a bitvector is a bitvector native value consisting of a sequence of zeros
of the length specified by the type (\ve). If the length is $0$, the bitvector consists of an
empty sequence:
\begin{mathpar}
  \inferrule[bitvector]{
    \tstruct(\vt) \eqname \TBits(\ve, \Ignore)\\
    \evalexprsef{\env, \ve} \evalarrow (\nvint(\length), \vg) \terminateas \ErrorConfig
  }
  {
    \basevalue(\env, \vt) \evalarrow (\nvbitvector(\overbrace{0\ldots 0}^{\length}), \vg)
  }
\end{mathpar}

\hypertarget{def-constantvalues}{}
The base value of an enumeration is obtained from its first declared literal.
Accessing this literal is done via the \constantvalues map in the
global component of the static environment:
\begin{mathpar}
  \inferrule[enum]{
    \tstruct(\vt) \eqname \TEnum(\id_{1..k})\\
    \env \eqname (\tenv, \denv)\\
    \tenv \eqname (G^\tenv, L^\tenv)\\
    G^\tenv.\constantvalues(\id_1) \eqname \vl
  }
  {
    \basevalue(\env, \vt) \evalarrow (\nvliteral{\vl}, \emptygraph)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[integer\_unconstrained]{
    \tstruct(\vt) \eqname \TInt(\unconstrained)
  }
  {
    \basevalue(\env, \vt) \evalarrow (\nvint(0), \emptygraph)
  }
  \and
  \inferrule[integer\_constraint\_exact]{
    \tstruct(\vt) \eqname \TInt(\wellconstrained([\constraintexact(\ve)] \concat \Ignore))\\
    \evalexprsef{\env, \ve} \evalarrow C
  }
  {
    \basevalue(\env, \vt) \evalarrow C
  }
  \and
  \and
  \inferrule[integer\_constraint\_range]{
    \tstruct(\vt) \eqname \TInt(\wellconstrained([\constraintrange(\ve, \Ignore)] \concat \Ignore))\\
    \evalexprsef{\env, \ve} \evalarrow C
  }
  {
    \basevalue(\env, \vt) \evalarrow C
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[record]{
    \tstruct(\vt) \eqname L([i=1..k: (\id_i, \vt_i)])\\
    L \in \{\TRecord, \TException\}\\
    i=1..k: \basevalue(\env, \vt_i) \evalarrow (\vv_i, \vg_i) \terminateas \ErrorConfig\\
    \vv \eqdef \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}}\\
    \vg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k
  }
  {
    \basevalue(\env, \vt) \evalarrow (\vv, \vg)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tuple]{
    \tstruct(\vt) \eqname \TTuple([i=1..k: \vt_i])\\
    i=1..k: \basevalue(\env, \vt_i) \evalarrow (\vv_i, \vg_i) \terminateas \ErrorConfig\\
    \vv \eqdef \nvvector{\vv_{1..k}}\\
    \vg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k
  }
  {
    \basevalue(\env, \vt) \evalarrow (\vv, \vg)
  }
\end{mathpar}

\newcommand\isconstant[0]{\texttt{is\_contant}}
The predicate $\isconstant$ checks whether the expression $\ve$ is a variable
declared as a constant.
\begin{mathpar}
  \inferrule[IsConstant]{
    \ve\eqname\EVar(\vx)\\
    \env \eqname (\tenv, \denv)\\
    \tenv \eqname (G^\tenv, L^\tenv)\\
    G^\tenv.\texttt{declared\_types}(\vx) \neq \bot
  }
  {
    \isconstant(\env, \ve)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[array\_length\_global\_constant]{
    \tstruct(\vt) \eqname \TArray(\elength, \vvty)\\
    \basevalue(\env, \vvty) \evalarrow (\velem, \vg) \terminateas \ErrorConfig\\\\
    \isconstant(\elength)\\
    \elength \eqname \EVar(\vx)\\
    \env \eqname (\tenv, \denv)\\
    \tenv \eqname (G^\tenv, L^\tenv)\\
    G^\tenv.\texttt{constants\_values}(\vx) \eqname \lint(n)\\
    \vv \eqdef \nvvector{i=1..n: \velem}
  }
  {
    \basevalue(\env, \vt) \evalarrow (\vv, \vg)
  }
  \and
  \inferrule[array\_length\_expression]{
    \tstruct(\vt) \eqname \TArray(\elength, \vvty)\\
    \basevalue(\env, \vvty) \evalarrow (\velem, \vgone) \terminateas \ErrorConfig\\\\
    \neg\isconstant(\elength)\\
    \evalexprsef{\env, \elength} \evalarrow (\vlength, \vgtwo) \terminateas \ErrorConfig\\
    \vlength \eqname \nvint(n)\\
    \vv \eqdef \nvvector{i=1..n: \velem}\\
    \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \basevalue(\env, \vt) \evalarrow (\vv, \vg)
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.IsValOfType}
\subsection{Prose}
\hypertarget{def-isvaloftype}{}
The relation
\[
  \isvaloftype(\overname{\envs}{\env} \aslsep \overname{\vals}{\vv} \aslsep \overname{\ty}{\vt}) \;\aslrel\;
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg}) \cup \overname{\TError}{\ErrorConfig}
\]
checks whether the value $\vv$ can be stored in a variable of type $\vt$ in the environment $\env$,
resulting in a Boolean value $\vb$ and execution graph $\vg$, \ProseOrError.

This relation is used in the context of a asserted type conversion,
which means the type-checker rule TypingRule.ATC was already applied,
thus filtering cases where the type inferred for the converted expression
does not type-satisfy $\vt$. The semantics takes this into account and
only returns \False\ in cases where dynamic information is required.

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{basic}):
  \begin{itemize}
    \item $\vt$ has the structure of a Boolean, a real, a string, or an enumeration;
    \item $\vb$ is \True;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item All of the following apply (\textsc{int\_unconstrained}):
  \begin{itemize}
    \item $\vt$ has the structure of the unconstrained integer;
    \item $\vb$ is \True;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item All of the following apply (\textsc{int\_wellconstrained}):
  \begin{itemize}
    \item $\vt$ has the structure of a well-constrained integer with constraints $\vc_{1..k}$;
    \item $\vv$ is the native value integer for $n$;
    \item either the evaluation of every constraint $\vc_i$ with $n$ in environment $\env$
    yields a Boolean value $\vb_i$ and an execution graph $\vg_i$,
    or the evaluation of one of the constraints results in an error, which short-circuits the entire
    evaluation;
    \item $\vb$ is the Boolean disjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
  \end{itemize}

  \item All of the following apply (\textsc{record}):
  \begin{itemize}
    \item $\vt$ has the structure of a record or an exception, with a list of field names
    $\id_i$, for $i=1..k$, associated with types $\vt_i$, for $i=1..k$;
    \item the value of every field $\id_i$ in $\vv$ is $\vu_i$, for $i=1..k$,
    \item either the evaluation of $\isvaloftype$ for every value $\vu_i$
    and corresponding type $\vt_i$, for $i=1..k$,
    results in a Boolean $\vb_i$ and execution graph $\vg_i$,
    or one of the evaluations results in an error,
    which short-circuits the entire evaluation;
    \item $\vb$ is the Boolean conjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
    of the constraints.
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\vt$ has the structure of a tuple with types $\vt_i$, for $i=1..k$;
    \item the value at every index $i=1..k$ of $\vv$ is $\vu_i$, for $i=1..k$,
    \item either the evaluation of $\isvaloftype$ for every value $\vu_i$
    and corresponding type $\vt_i$, for $i=1..k$,
    results in a Boolean $\vb_i$ and execution graph $\vg_i$,
    or one of the evaluations results in an error,
    which short-circuits the entire evaluation;
    \item $\vb$ is the Boolean conjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
    of the constraints.
  \end{itemize}

  \item All of the following apply (\textsc{array}):
  \begin{itemize}
    \item $\vt$ has the structure of an array with length expression $\vt$
    and element type $\vtone$;
    \item evaluating the side-effect-free expression $\ve$ in environment $\env$
    results in the native value integer for $k$ and execution graph $\vg$;
    \item obtaining the values at indices $i=1..k$ from $\vv$ result in $\vv_i$;
    \item either evaluating $\isvaloftype$ for $\vv_i$ and $\vtone$, for $i=1..k$,
    all result in Boolean values $\vb_i$ and execution graphs $\vg_i$,
    or one of the evaluations returns an error,
    which short-circuits the entire evaluation;
    \item $\vb$ is the Boolean conjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
    of the constraints.
  \end{itemize}
\end{itemize}

%
%   \CodeSubsection{\ValOfTypeBegin}{\ValOfTypeEnd}{../Interpreter.ml}

\begin{emptyformal}
\hypertarget{def-astlabel}{}
\subsection{Formally}
\begin{mathpar}
  \inferrule[Basic (bool, real, string, enum)]{
    \astlabel(\tstruct(\env, \vt)) \in \{\TBool, \TReal, \TString, \TEnum\}\\
    \vg \eqdef \emptygraph
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\True, \vg)
  }
  \and
  \inferrule[int\_unconstrained]{
    \tstruct(\env, \vt) \eqname \TInt(\unconstrained)\\
    \vg \eqdef \emptygraph
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\True, \vg)
  }
\end{mathpar}

\hypertarget{def-integerconstraintsatisfied}{}
To handle \emph{well-constrained integers} (integers with a non-empty list of constraints),
we introduce the helper relation
\[
  \integerconstraintsatisfied(\overname{\envs}{\env} \aslsep \overname{\intconstraint}{\vc} \aslsep \overname{\Z}{n}) \;\aslrel\;
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg})
\]
which checks whether the integer value $n$ \emph{meets the constraint} $\vc$
(that is, whether $n$ is within the range of values defined by $\vc$) in the environment $\env$
and returns a Boolean answer $\vb$ and the execution graph $\vg$ resulting from evaluating
the expressions appearing in $\vc$:
\begin{mathpar}
\inferrule[Constraint\_Exact\_Sat]{
  \evalexprsef{\env, \ve} \evalarrow (\nvint(m), \vg) \terminateas \ErrorConfig\\\\
  \vb \eqdef m = n
}
{
  \integerconstraintsatisfied(\env, \constraintexact(\ve), n) \evalarrow (\vb, \vg)
}
\and
\inferrule[Constraint\_Range\_Sat]{
  \evalexprsef{\env, \veone} \evalarrow (\nvint(a), \vgone) \terminateas \ErrorConfig\\\\
  \evalexprsef{\env, \vetwo} \evalarrow (\nvint(b), \vgtwo) \terminateas \ErrorConfig\\\\
  \vb \eqdef \choice{a \leq n \wedge n \leq b}{\True}{\False}\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}
{
  \integerconstraintsatisfied(\env, \constraintrange(\veone, \vetwo), n) \evalarrow (\vb, \vg)
}
\end{mathpar}

Finally, we can check whether an integer value satisfies any of the constraints:
\begin{mathpar}
  \inferrule[int\_wellconstrained]{
    \tstruct(\env, \vt) \eqname \TInt(\wellconstrained(\vc_{1..k}))\\
    \vv \eqname \nvint(n)\\
    i=1..k: \integerconstraintsatisfied(\env, \vc_i, n) \evalarrow (\vb_i, \vg_i) \terminateas \ErrorConfig\\\\
    \vb \eqdef \bigvee_{i=1}^k \vb_i\\
    \vg \eqdef \parallel_{i=1}^k \vg_i
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[record]{
    \tstruct(\env, \vt) \eqname L(i=1..k: \id_i\mapsto \vt_i)\\
    L \in \{\TRecord, \TException\}\\
    i=1..k: \getfield(\id_i, \vv) \evalarrow \vu_i\\
    i=1..k: \isvaloftype(\env, \vu_i, \vt_i) \evalarrow (\vb_i, \vg_i) \terminateas \ErrorConfig\\\\
    \vb \eqdef \bigwedge_{i=1}^k \vb_i \\
    \vg \eqdef \parallel_{i=1}^k \vg_i
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tuple]{
    \tstruct(\env, \vt) \eqname \TTuple(i=1..k: \vt_i)\\
    i=1..k: \getindex(i, \vv) \evalarrow \vu_i\\
    i=1..k: \isvaloftype(\env, \vu_i, \vt_i) \evalarrow (\vb_i, \vg_i) \terminateas \ErrorConfig\\\\
    \vb \eqdef \bigwedge_{i=1}^k \vb_i \\
    \vg \eqdef \parallel_{i=1}^k \vg_i
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[array]{
    \tstruct(\env, \vt) \eqname \TArray(\ve, \vtone)\\
    \evalexprsef{\env, \ve} \evalarrow (\nvint(k), \vg)\\
    i=1..k: \getindex(i, \vv) \evalarrow \vv_i\\
    i=1..k: \isvaloftype(\env, \vv_i, \vtone) \evalarrow (\vb_i, \vg_i) \terminateas \ErrorConfig\\\\
    \vb \eqdef \bigwedge_{i=1}^k \vb_i \\
    \vg \eqdef \parallel_{i=1}^k \vg_i
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

Notice that these rules cover all types, including named types ($\TNamed$),
since $\tstruct$ replaces named types by their type definitions.
%
Underconstrained integers (integers with an empty set of constraints)
cannot appear as a type, since ASL syntax does not allow the following:
\begin{itemize}
\item Declaring an underconstrained integer as a variable,
\item Declaring an alias to an underconstrained integer type, and
\item Declaring an underconstrained integer in a compound type.
\end{itemize}
\end{emptyformal}

\section{Applying a Unary Operator \label{sec:UnaryOperator}}
\subsection{Prose}
\hypertarget{def-unoprel}{}
The relation
\[
  \unoprel(\unop \aslsep \vals) \;\aslrel\; \vals
\]
evaluates an operator over a native value and returns the resulting
native value (the \unop\ appearing as an argument of the \unoprel\ relation
is the AST non-terminal for deriving unary operators).

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[negate\_int]{}{
    \unoprel(\NEG, \nvint(n)) \evalarrow \nvint(- n)
  }
  \and
  \inferrule[negate\_real]{}{
    \unoprel(\NEG, \nvreal(z)) \evalarrow \nvint(- z)
  }
  \and
  \inferrule[not\_bool]{}{
    \unoprel(\BNOT, \nvbool(b)) \evalarrow \nvint(\neg b)
  }
  \and
  \inferrule[not\_bits]{
    I \eqdef \listrange(\bits)\\
    c \eqdef [\ i\in I: 1-\bits[i]\ ]
  }{
    \unoprel(\NOT, \nvbitvector(\bits)) \evalarrow \nvbitvector(c)
  }
\end{mathpar}
\end{emptyformal}

\section{SemanticsRule.BinopOperator \label{sec:SemanticsRule.BinopOperator}}
\subsection{Prose}
\hypertarget{def-binoprel}{}
The relation
\[
  \binoprel(\binop \aslsep \vals \aslsep \vals) \;\aslrel\; (\vals \cup \TError)
\]
evaluates an operator over a pair of native values and returns the resulting
native value or an error, if it is considered illegal to apply the operator
to the given values (the \binop\ appearing as an argument of the \binoprel\ relation
is the AST non-terminal for deriving binary operators).

\begin{emptyformal}
\subsection{Formally}

\subsubsection{Arithmetic Operators Over Integer Values \label{sec:AthimeticOverInt}}
\begin{mathpar}
  \inferrule[add\_int]{ n \eqdef a + b }{
    \binoprel(\PLUS, \nvint(a), \nvint(b)) \evalarrow \nvint(n)
  }
  \and
  \inferrule[sub\_int]{ n \eqdef a - b }{
    \binoprel(\MINUS, \nvint(a), \nvint(b)) \evalarrow \nvint(\texttt{n})
  }
  \and
  \inferrule[mul\_int]{ n \eqdef a \times b }{
    \binoprel(\MUL, \nvint(a), \nvint(b)) \evalarrow \nvint(\texttt{n})
  }
  \and
  \inferrule[div\_int]{  b > 0 \\
    n \eqdef a \div b \\
    n \in \Z}{
    \binoprel(\DIV, \nvint(a), \nvint(b)) \evalarrow \nvint(n)
  }
  \and
  \inferrule[div\_int\_error\_denominator\_negative]{  b \leq 0 }{
    \binoprel(\DIV, \nvint(a), \nvint(b)) \evalarrow \ErrorVal{DIVInt\_DenominatorNegative}
  }
  \and
  \inferrule[div\_int\_error\_indivisible]{  b > 0 \\
  n \eqdef a \div b \\
  n \not\in \Z
  }{
    \binoprel(\DIV, \nvint(a), \nvint(b)) \evalarrow \ErrorVal{DIVInt\_Indivisibile}
  }
  \and
  \inferrule[fdiv\_int\_pos]{  b > 0 \\
  a \geq 0 \\
  n \eqdef \lfloor a \div b \rfloor
  }{ \binoprel(\DIVRM, \nvint(a), \nvint(b)) \evalarrow \nvint(n) }
  \and
  \inferrule[fdiv\_int\_neg]{  b > 0 \\
  a < 0 \\
  n \eqdef -(\lceil (-a) \div b \rceil)
  }{ \binoprel(\DIVRM, \nvint(a), \nvint(b)) \evalarrow \nvint(n) }
  \and
  \inferrule[fdiv\_int\_denominator\_negative]{  b \leq 0 }{ \binoprel(\DIVRM, \nvint(a), \nvint(b)) \evalarrow \ErrorVal{DIVRM\_DenominatorNegative} }
  \and
  \inferrule[frem\_int\_pos]{  b > 0 \\
    \binoprel(\DIVRM, \nvint(a), \nvint(b)) \evalarrow c \\
    n \eqdef a - (b \times c)
  }{ \binoprel(\MOD, \nvint(a), \nvint(b)) \evalarrow \nvint(n) }
  \and
  \inferrule[frem\_int\_error\_denominator\_not\_positive]{  b \leq 0
  }{ \binoprel(\MOD, \nvint(a), \nvint(b)) \evalarrow \ErrorVal{MOD\_DenominatorNotPositive} }
\end{mathpar}

\begin{mathpar}
  \inferrule[exp\_int]{  b \geq 0 \\ n \eqdef a^b
  }{ \binoprel(\POW, \nvint(a), \nvint(b)) \evalarrow \nvint(n)}
  \and
  \inferrule[exp\_int\_error]{  b < 0 \\ n \eqdef a^b
  }{ \binoprel(\POW, \nvint(a), \nvint(b)) \evalarrow \ErrorVal{POW\_ExponentNegative} }
  \and
  \inferrule[shiftleft\_int]{  \binoprel(\MUL, \nvint(a), \binoprel(\POW, \nvint(2), \nvint(b))) \evalarrow C
  }{ \binoprel(\SHL, \nvint(a), \nvint(b)) \evalarrow C}
  \and
  \inferrule[shift\_right]{  \binoprel(\DIVRM, \nvint(a), \binoprel(\POW, \nvint(2), \nvint(b))) \evalarrow C
  }{ \binoprel(\SHR, \nvint(a), \nvint(b)) \evalarrow C}
\end{mathpar}

\subsubsection{Relational Operators Over Integer Values \label{sec:RelationalOverInt}}
\begin{mathpar}
  \inferrule[eq\_real]{  c\eqdef a = b }{ \binoprel(\EQOP, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[ne\_real]{  c\eqdef a = b }{ \binoprel(\NEQ, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[le\_real]{  c\eqdef a \leq b }{ \binoprel(\LEQ, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[lt\_real]{  c\eqdef a < b }{ \binoprel(\LT, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[ge\_real]{  c\eqdef a \geq b }{ \binoprel(\GEQ, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[gt\_real]{  c\eqdef a > b }{ \binoprel(\GT, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
\end{mathpar}

\subsubsection{Boolean Operators Over Boolean Values \label{sec:BooleanOverBoolean}}
\begin{mathpar}
\inferrule[and\_bool]{}{ \binoprel(\BAND, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(a \wedge b)}
\and
\inferrule[or\_bool]{}{ \binoprel(\BOR, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(a \vee b)}
\and
\inferrule[implies\_bool]{}{ \binoprel(\IMPL, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(\neg a \vee b)}
\and
\inferrule[eq\_bool]{
  c \eqdef a = b
}{ \binoprel(\EQOP, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(c)}
\and
\inferrule[ne\_bool]{
  c \eqdef a \neq b
}{ \binoprel(\NEQ, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(c)}
\end{mathpar}

\subsubsection{Arithmetic Operators Over Real Values \label{sec:AthimeticOverReal}}
\begin{mathpar}
  \inferrule[add\_real]{}{\binoprel(\PLUS, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a+b)}
\and
\inferrule[sub\_real]{}{\binoprel(\MINUS, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a-b)}
\and
\inferrule[mul\_real]{}{\binoprel(\MUL, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a\times b)}
\and
\inferrule[div\_real]{b \neq 0}{\binoprel(\RDIV, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a\div b)}
\and
\inferrule[div\_real\_error]{b = 0}{\binoprel(\RDIV, \nvreal(a), \nvreal(b)) \evalarrow \ErrorVal{RDIV\_DenominatorZero}}
\and
\inferrule[exp\_real]{b \geq 0}{\binoprel(\POW, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a^b)}
\end{mathpar}

\subsubsection{Relational Operators Over Real Values \label{sec:RealtionalOverReal}}
\begin{mathpar}
  \inferrule[eq\_real]{  c\eqdef a = b }{ \binoprel(\EQOP, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[ne\_real]{  c\eqdef a = b }{ \binoprel(\NEQ, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[le\_real]{  c\eqdef a \leq b }{ \binoprel(\LEQ, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[lt\_real]{  c\eqdef a < b }{ \binoprel(\LT, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[ge\_real]{  c\eqdef a \geq b }{ \binoprel(\GEQ, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[gt\_real]{  c\eqdef a > b }{ \binoprel(\GT, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
\end{mathpar}

\subsection{Operators Over Bitvectors \label{sec:BitvectorOperations}}

\newcommand\bintounsigned[0]{\hyperlink{def-bintounsigned}{\textsf{binary\_to\_unsigned}}}
\hypertarget{def-bintounsigned}{}
The function $\bintounsigned : \{0,1\}^+ \rightarrow \N$ converts a sequence of bits
into a natural number:
\[
  \bintounsigned(a_{n..1}) \triangleq \sum_{i=1}^n 2^{a_i}
\]

\begin{mathpar}
  \inferrule[eq\_bits]{
    \vb \eqdef \bigvee_{i=1}^k a_i = b_i
  }
  {
    \binoprel(\EQOP, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbool(\vb)
  }
  \and
  \inferrule[ne\_bits]{
    \binoprel(\EQOP, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbool(\vb')\\
    \vb \eqdef \neg \vb'
  }
  {
    \binoprel(\NEQ, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbool(\vb)
  }
  \and
  \inferrule[or\_bits]{
    i=1..k: c_i = \max(a_i, b_i)
  }
  {
    \binoprel(\OR, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c_{1..k})
  }
  \and
  \inferrule[and\_bits]{
    i=1..k: c_i = \min(a_i, b_i)
  }
  {
    \binoprel(\AND, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c_{1..k})
  }
  \and
  \inferrule[xor\_bits]{
    {
      \textit{xor\_bits} = \lambda a,b\in\{0,1\}.\ \left\{
        \begin{array}{ll}
          0 & \text{ if } a = b\\
          1 & \text{ otherwise}
        \end{array}
      \right.
    }\\
    i=1..k: c_i=\textit{xor\_bits}(a_i, b_i)
  }
  {
    \binoprel(\EOR, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c_{1..k})
  }
  \and
  \inferrule[add\_bits]{
    a \eqname \bintounsigned(a_{1..k})\\
    b \eqname \bintounsigned(b_{1..k})\\
    c \eqdef \text{two's complement little endian representation of } a + b
  }
  {
    \binoprel(\PLUS, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c)
  }
  \and
  \inferrule[sub\_bits]{
    a \eqname \bintounsigned(a_{1..k})\\
    b \eqname \bintounsigned(b_{1..k})\\
    c \eqdef \text{two's complement little endian representation of } a - b
  }
  {
    \binoprel(\MINUS, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c)
  }
  \and
  \inferrule[add\_bits\_int]{
    a \eqname \bintounsigned(a_{1..k})\\
    c \eqdef \text{two's complement little endian representation of } a + b
  }
  {
    \binoprel(\PLUS, \nvbitvector(a_{1..k}), \nvint(b)) \evalarrow \nvbitvector(c)
  }
  \and
  \inferrule[sub\_bits\_int]{
    a \eqname \bintounsigned(a_{1..k})\\
    c \eqdef \text{two's complement little endian representation of } a - b
  }
  {
    \binoprel(\MINUS, \nvbitvector(a_{1..k}), \nvint(b)) \evalarrow \nvbitvector(c)
  }
\end{mathpar}
\end{emptyformal}

\bibliographystyle{plain}
\bibliography{ASL}
\end{document}
