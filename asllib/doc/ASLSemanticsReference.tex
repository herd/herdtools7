\documentclass{book}
\input{ASLmacros}

\newtheorem{definition}{Definition}
\newcommand\defref[1]{Def.~\ref{def:#1}}
\newcommand\secref[1]{Section~\ref{sec:#1}}

\newcommand\torexpr[0]{\textsf{rexpr}}
\newcommand\semantic[1]{\llbracket #1 \rrbracket}
\newcommand\tododefine[1]{\texttt{#1}}

\usepackage{relsize}
%\newcommand\eqname[0]{=}
\newcommand\eqname[0]{\stackrel{\mathsmaller{\mathsf{name}}}{=}}
%\newcommand\overname[2]{#1}
\newcommand\overname[2]{\overbracket{#1}^{#2}}

\newcommand\eq[0]{\textsf{eq}}
\newcommand\xgraph[0]{\textsf{g}}
\newcommand\emptygraph[0]{{\emptyset}_\xgraph}
\newcommand\Nodes[0]{\mathcal{N}}
\newcommand\Read[0]{\text{Read}}
\newcommand\Write[0]{\text{Write}}
\newcommand\Labels[0]{\mathcal{L}}
\newcommand\XGraphs[0]{\mathcal{G}}
\newcommand\WriteEffect[0]{\textsf{WriteEffect}}
\newcommand\ReadEffect[0]{\textsf{ReadEffect}}

\newcommand\emptyenv[0]{\underline{e}}
\newcommand\tenv[0]{\textsf{tenv}}
\newcommand\denv[0]{\textsf{denv}}
\newcommand\denvtwo[0]{\textsf{denv2}}
\newcommand\vals[0]{\mathcal{V}}
\newcommand\ordered[3]{{#1}\xrightarrow{#2}{#3}}
\newcommand\nvliteral[1]{\texttt{NV\_Literal}(#1)}
\newcommand\nvvector[1]{\texttt{NV\_Vector}(#1)}
\newcommand\nvrecord[1]{\texttt{NV\_Record}(#1)}
\newcommand\nvint[0]{\texttt{Int}}
\newcommand\nvbool[0]{\texttt{Bool}}
\newcommand\nvreal[0]{\texttt{Real}}
\newcommand\nvstring[0]{\texttt{String}}
\newcommand\nvbitvector[0]{\texttt{Bitvector}}
\newcommand\tint[0]{\mathcal{Z}}
\newcommand\tbool[0]{\mathcal{B}}
\newcommand\treal[0]{\mathcal{R}}
\newcommand\tstring[0]{\mathcal{S}\mathcal{T}\mathcal{R}}
\newcommand\tbitvector[0]{\mathcal{B}\mathcal{V}}
\newcommand\tvector[0]{\mathcal{V}\mathcal{E}\mathcal{C}}
\newcommand\trecord[0]{\mathcal{R}\mathcal{E}\mathcal{C}}

\newcommand\configdomain[1]{\texttt{config\_domain}({#1})}
\newcommand\graphof[1]{\texttt{graph}({#1})}
\newcommand\withgraph[2]{{#1}(\texttt{graph}\mapsto{#2})}
\newcommand\environof[1]{\texttt{environ}({#1})}
\newcommand\withenviron[2]{{#1}(\texttt{environ}\mapsto{#2})}

\newcommand\evalarrow[0]{\stackrel{\mathsf{asl}}{\rightsquigarrow}}
\newcommand\aslrel[0]{\bigtimes}
\newcommand\aslsep[0]{\mathbf{,}}
\newcommand\evalprimitivearrow[0]{\stackrel{\mathsf{primitive}}{\rightsquigarrow}}
\newcommand\sslash[0]{\mathbin{/\mkern-6mu/}}
\newcommand\rightdownarrow[0]{\rotatebox[origin=c]{270}{$\Rsh$}}
\newcommand\terminateas[0]{\;\sslash\;}
\newcommand\ThrowingConfig[0]{\texttt{\#T}}
\newcommand\ErrorConfig[0]{\texttt{\#E}}
\newcommand\OrAbnormal[0]{\terminateas \ThrowingConfig, \ErrorConfig}
\newcommand\TError[0]{\textsf{TError}}
\newcommand\TThrowing[0]{\textsf{TThrowing}}
\newcommand\TContinuing[0]{\textsf{TContinuing}}
\newcommand\TReturning[0]{\textsf{TReturning}}
\newcommand\TOutConfig[0]{\textsf{TOutConfig}}

\newcommand\evalexpr[1]{\texttt{eval\_expr}(#1)}
\newcommand\evalexprsef[1]{\texttt{eval\_expr\_sef}(#1)}
\newcommand\evallexpr[1]{\texttt{eval\_lexpr}(#1)}
\newcommand\evalexprlist[1]{\texttt{eval\_expr\_list}(#1)}
\newcommand\evalexprlistm[1]{\texttt{eval\_expr\_list\_m}(#1)}
\newcommand\evalpattern[1]{\texttt{eval\_pattern}(#1)}
\newcommand\evallocaldecl[1]{\texttt{eval\_local\_decl}(#1)}
\newcommand\evalslices[1]{\texttt{eval\_slices}(#1)}
\newcommand\evalslice[1]{\texttt{eval\_slice}(#1)}
\newcommand\evalstmt[1]{\texttt{eval\_stmt}(#1)}
\newcommand\evalblock[1]{\texttt{eval\_block}(#1)}
\newcommand\evalloop[1]{\texttt{eval\_loop}(#1)}
\newcommand\evalfor[1]{\texttt{eval\_for}(#1)}
\newcommand\evalcatchers[1]{\texttt{eval\_catchers}(#1)}
\newcommand\evalsubprogram[1]{\texttt{eval\_subprogram}(#1)}
\newcommand\evalcall[1]{\texttt{eval\_call}(#1)}
\newcommand\evalprimitive[1]{\texttt{eval\_primitive}(#1)}
\newcommand\evalmultiassignment[1]{\texttt{multi\_assign}(#1)}
\newcommand\rethrowimplicit[0]{\texttt{rethrow\_implicit}}
\newcommand\assignargs[0]{\texttt{assign\_args}}
\newcommand\assignnamedargs[0]{\texttt{assign\_named\_args}}
\newcommand\matchfuncres[0]{\texttt{match\_func\_res}}
\newcommand\emptytenv[0]{\emptyset_{\tenv}}
\newcommand\parsedspec[0]{\texttt{parsed\_spec}}
\newcommand\parsedstd[0]{\texttt{parsed\_std}}
\newcommand\parsedast[0]{\texttt{parsed\_ast}}
\newcommand\typedspec[0]{\texttt{typed\_spec}}
\newcommand\buildgenv[0]{\texttt{build\_genv}}
\newcommand\topologicaldecls[0]{\texttt{topological\_decls}}
\newcommand\evalglobals[0]{\texttt{eval\_globals}}
\newcommand\evalspec[1]{\texttt{eval\_spec}(#1)}
\newcommand\lexprisvar[0]{\texttt{lexpr\_is\_var}}

\newcommand\findfunc[0]{\texttt{find\_func}}
\newcommand\unknownval[0]{\texttt{unknown\_val}}
\newcommand\typesatisfies[0]{\texttt{type\_satisfies}}
\newcommand\constantsvalues[1]{\text{constants\_values}}

\newcommand\exprvals[0]{\textsf{ExprVals}}
\newcommand\Normal[0]{\textsf{Normal}}
\newcommand\Throwing[0]{\textsf{Throwing}}
\newcommand\Continuing[0]{\textsf{Continuing}}
\newcommand\Returning[0]{\textsf{Returning}}
\newcommand\Error[0]{\textsf{Error}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Names for variables appearing in rules

\newcommand\newenv[0]{\texttt{new\_env}}
\newcommand\env[0]{\texttt{env}}
\newcommand\envone[0]{\texttt{env1}}
\newcommand\envtwo[0]{\texttt{env2}}
\newcommand\envthree[0]{\texttt{env3}}
\newcommand\envfour[0]{\texttt{env4}}
\newcommand\envp[0]{\texttt{env'}}
\newcommand\vc[0]{\texttt{c}}
\newcommand\ve[0]{\texttt{e}}
\newcommand\vi[0]{\texttt{i}}
\newcommand\vg[0]{\texttt{g}}
\newcommand\vgp[0]{\texttt{g'}}
\newcommand\vvp[0]{\texttt{v'}}
\newcommand\vep[0]{\texttt{e'}}
\newcommand\vl[0]{\texttt{l}}
\newcommand\vm[0]{\texttt{m}}
\newcommand\vn[0]{\texttt{n}}
\newcommand\vp[0]{\texttt{p}}
\newcommand\vv[0]{\texttt{v}}
\newcommand\vx[0]{\texttt{x}}
\newcommand\vs[0]{\texttt{s}}
\newcommand\vt[0]{\texttt{t}}
\newcommand\vu[0]{\texttt{u}}
\newcommand\vw[0]{\texttt{w}}
\newcommand\vvsg[0]{\texttt{vsg}}
\newcommand\vvs[0]{\texttt{vs}}
\newcommand\vms[0]{\texttt{ms}}
\newcommand\vmstwo[0]{\texttt{ms2}}
\newcommand\vle[0]{\texttt{le}}
\newcommand\vles[0]{\texttt{les}}
\newcommand\vre[0]{\texttt{re}}
\newcommand\vres[0]{\texttt{res}}
\newcommand\vvone[0]{\texttt{v1}}
\newcommand\vvtwo[0]{\texttt{v2}}
\newcommand\vsone[0]{\texttt{s1}}
\newcommand\vstwo[0]{\texttt{s2}}
\newcommand\vmone[0]{\texttt{m1}}
\newcommand\vmtwo[0]{\texttt{m2}}
\newcommand\veone[0]{\texttt{e1}}
\newcommand\vetwo[0]{\texttt{e2}}
\newcommand\vgone[0]{\texttt{g1}}
\newcommand\vgtwo[0]{\texttt{g2}}
\newcommand\vgthree[0]{\texttt{g3}}
\newcommand\vgfour[0]{\texttt{g4}}
\newcommand\ebv[0]{\texttt{e\_bv}}
\newcommand\mbv[0]{\texttt{m\_bv}}
\newcommand\mcond[0]{\texttt{m\_cond}}
\newcommand\vbv[0]{\texttt{v\_bv}}
\newcommand\mpositions[0]{\texttt{m\_positions}}
\newcommand\slices[0]{\texttt{slices}}
\newcommand\indices[0]{\texttt{indices}}
\newcommand\positions[0]{\texttt{positions}}
\newcommand\name[0]{\texttt{name}}
\newcommand\args[0]{\texttt{args}}
\newcommand\actualargs[0]{\texttt{actual\_args}}
\newcommand\argdecls[0]{\texttt{arg\_decls}}
\newcommand\namedargs[0]{\texttt{named\_args}}
\newcommand\nargs[0]{\texttt{nargs}}
\newcommand\nargsm[0]{\texttt{nargs\_m}}
\newcommand\nargsone[0]{\texttt{nargs1}}
\newcommand\nargstwo[0]{\texttt{nargs2}}
\newcommand\nargsthree[0]{\texttt{nargs3}}
\newcommand\vargs[0]{\texttt{vargs}}
\newcommand\vargsm[0]{\texttt{vargs\_m}}
\newcommand\params[0]{\texttt{params}}
\newcommand\earray[0]{\texttt{e\_array}}
\newcommand\eindex[0]{\texttt{e\_index}}
\newcommand\marray[0]{\texttt{m\_array}}
\newcommand\mindex[0]{\texttt{m\_index}}
\newcommand\varray[0]{\texttt{v\_array}}
\newcommand\vindex[0]{\texttt{v\_index}}
\newcommand\efields[0]{\texttt{e\_fields}}
\newcommand\names[0]{\texttt{names}}
\newcommand\fields[0]{\texttt{fields}}
\newcommand\vvfields[0]{\texttt{v\_fields}}
\newcommand\erecord[0]{\texttt{e\_record}}
\newcommand\vrecord[0]{\texttt{v\_record}}
\newcommand\fieldname[0]{\texttt{field\_name}}
\newcommand\elist[0]{\texttt{e\_list}}
\newcommand\vlist[0]{\texttt{v\_list}}
\newcommand\stm[0]{\texttt{stm}}
\newcommand\blockenv[0]{\texttt{block\_env}}
\newcommand\rearray[0]{\texttt{re\_array}}
\newcommand\rvarray[0]{\texttt{rv\_array}}
\newcommand\rmarray[0]{\texttt{rm\_array}}
\newcommand\record[0]{\texttt{record}}
\newcommand\rerecord[0]{\texttt{re\_record}}
\newcommand\rmrecord[0]{\texttt{rm\_record}}
\newcommand\rvrecord[0]{\texttt{rv\_record}}
\newcommand\vlelist[0]{\texttt{le\_list}}
\newcommand\vmlist[0]{\texttt{vm\_list}}
\newcommand\nmonads[0]{\texttt{nmonads}}
\newcommand\start[0]{\texttt{start}}
\newcommand\mstart[0]{\texttt{m\_start}}
\newcommand\vstart[0]{\texttt{v\_start}}
\newcommand\vend[0]{\texttt{v\_end}}
\newcommand\estart[0]{\texttt{e\_start}}
\newcommand\elength[0]{\texttt{e\_length}}
\newcommand\length[0]{\texttt{length}}
\newcommand\mlength[0]{\texttt{m\_length}}
\newcommand\vlength[0]{\texttt{v\_length}}
\newcommand\etop[0]{\texttt{e\_top}}
\newcommand\vvtop[0]{\texttt{v\_top}}
\newcommand\mtop[0]{\texttt{m\_top}}
\newcommand\efactor[0]{\texttt{e\_factor}}
\newcommand\mfactor[0]{\texttt{m\_factor}}
\newcommand\vfactor[0]{\texttt{v\_factor}}
\newcommand\range[0]{\texttt{range}}
\newcommand\ranges[0]{\texttt{ranges}}
\newcommand\ldi[0]{\texttt{ldi}}
\newcommand\ldis[0]{\texttt{ldis}}
\newcommand\liv[0]{\texttt{liv}}
\newcommand\minitopt[0]{\texttt{m\_init\_opt}}
\newcommand\les[0]{\texttt{les}}
\newcommand\exprs[0]{\texttt{exprs}}
\newcommand\wid[0]{\texttt{wid}}
\newcommand\es[0]{\texttt{es}}
\newcommand\ms[0]{\texttt{ms}}
\newcommand\body[0]{\text{body}}
\newcommand\vbody[0]{\texttt{body}}
\newcommand\dir[0]{\texttt{dir}}
\newcommand\catchers[0]{\texttt{catchers}}
\newcommand\otherwiseopt[0]{\texttt{otherwise\_opt}}
\newcommand\iswhile[0]{\texttt{is\_while}}
\newcommand\econd[0]{\texttt{e\_cond}}
\newcommand\condm[0]{\texttt{cond\_m}}
\newcommand\condv[0]{\texttt{cond\_v}}
\newcommand\condg[0]{\texttt{cond\_g}}
\newcommand\vindexname[0]{\texttt{index\_name}}
\newcommand\envthrow[0]{\texttt{env\_throw}}
\newcommand\envthrowone[0]{\texttt{env\_throw1}}
\newcommand\denvthrow[0]{\texttt{denv\_throw}}
\newcommand\sm[0]{\texttt{s\_m}}
\newcommand\sg[0]{\texttt{s\_g}}
\newcommand\ety[0]{\texttt{e\_ty}}
\newcommand\vvty[0]{\texttt{v\_ty}}
\newcommand\nameopt[0]{\texttt{name\_opt}}
\newcommand\vb[0]{\texttt{b}}
\newcommand\vbone[0]{\texttt{b1}}
\newcommand\vbtwo[0]{\texttt{b2}}
\newcommand\vps[0]{\texttt{ps}}
\newcommand\vbs[0]{\texttt{bs}}
\newcommand\xs[0]{\texttt{xs}}
\newcommand\retenv[0]{\texttt{ret\_env}}
\newcommand\vglobal[0]{\texttt{global}}
\newcommand\rid[0]{\texttt{rid}}
\newcommand\genv[0]{\texttt{genv}}
\newcommand\envm[0]{\texttt{envm}}
\newcommand\vacc[0]{\texttt{acc}}
\newcommand\vvsm[0]{\texttt{vsm}}
\newcommand\vd[0]{\texttt{d}}
\newcommand\vdecls[0]{\texttt{decls}}
\newcommand\bv[0]{\texttt{bv}}
\newcommand\src[0]{\texttt{src}}
\newcommand\dst[0]{\texttt{dst}}
\newcommand\vvec[0]{\texttt{vec}}
\newcommand\fieldmap[0]{\textit{field\_map}}
\newcommand\velem[0]{\texttt{v\_elem}}
\newcommand\vcs[0]{\texttt{cs}}
\newcommand\bits[0]{\texttt{bits}}

\input{ASLSemanticsLines}

% Increase indentation of sections in the table of contents
% to allow a space between the section numbers and their titles.
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{2.6em}}
\makeatother

\setcounter{tocdepth}{1}

\newcommand{\testdir}{../tests/ASLSemanticsReference.t}

\author{Arm Architecture Technology Group}
\title{ASL Semantics Reference \\
       DDI 0621}
\begin{document}
\maketitle

\tableofcontents{}

\include{notice.tex}

\include{disclaimer.tex}

\chapter{Preamble}

The semantics of ASL defines all valid behaviors of a given ASL specification.
More precisely, an ASL specification is first parsed into an \emph{abstract syntax tree},
or AST, for short. Second, a type checker analyzes the \emph{parsed AST} for correctness and,
if successful, returns a \emph{static environment} and a \emph{typed AST}.

Tools such as interpreters and verifiers can operate over the typed AST, based on the definition
of the semantics, to test and analyze a given specification.

The abstract syntax, parsed AST, and typed AST are defined in the abstract syntax reference~\cite{ASLAbstractSyntaxReference}.
The ASL type system, which defines the set of parsed ASTs that are considered valid and how to
produce the corresponding typed ASTs and static environments is defined in the typing reference~\cite{ASLTypingReference}.

\section{When Do ASL Specifications Have Meaning \label{sec:MeaningfulASLSpecifications}}
The ASL semantics defined here assigns meaning only to well-typed specifications.
That is, if the type-checker does not produce a static environment for a given specification,
then that specification has undefined semantics.
For the rest of this document, we only discuss well-typed specifications.

ASL admits non-determinism, for example via the \texttt{UNKOWN} expression.
This means that the same ASL specification might terminate in one instance
(for certain choices of values for \texttt{UNKNOWN}) but not in others,
due to infinite loops and/or infinite recursion.
The ASL semantics describes only terminating executions.

\section{Basic Semantic Concepts}
The ASL semantics is given by a set of \emph{semantic relations} between \emph{semantic configurations},
or \emph{configurations}~\cite{SemanticsWithApplicationsBook}, for short.
Intuitively, configurations encapsulate the information needed to transition into other configurations,
such as:
\begin{itemize}
  \item a \emph{dynamic environment}, which binds variables to values;
  \item the typed AST node that needs to be evaluated;
  \item a \emph{concurrent execution graph}, as per a given memory model; and
  \item values resulting from evaluating expressions.
\end{itemize}
The semantic relations are constructively defined via \emph{semantic rules}.
These semantic rules are defined by induction over the typed AST.

\paragraph{Execution}
A valid execution of an ASL specification transitions from an \emph{initial configuration},
which consists of the given specification and the standard library specification, to an output configuration
consisting of an output value and a concurrent execution graph.

\paragraph{Primitive Subprograms}
The semantics of ASL is parameterized by a set of primitive subprograms ---
subprograms whose implementation is not defined by an ASL body and whose effect on the dynamic environment
is defined externally. Critically, access to memory is given by primitive subprograms.

We define two types of semantics --- a \emph{sequential semantics} and a \emph{concurrent semantics}.

\paragraph{Concurrent Semantics}
The concurrent semantics includes concurrent execution graphs.
Intuitively, these graphs define Read Effects and Write Effects to variables and constraints over those effects.
Together with the constraints that define a given memory model (such as the ARM memory model~\cite{AlglaveDGHM21}),
these graphs axiomatically define
the valid interactions of shared variables of a given specification.

\paragraph{Sequential Semantics}
The sequential semantics corresponds to executing an ASL specification in the context of a single (conceptual) process
of execution --- notice that ASL does not contain any concurrency constructs.
%
Technically, the sequential semantics is defined by omitting the concurrent execution graph components
from configurations.

\section{Mathematical Definitions and Notations}

\input{ASLNotations.tex}

\paragraph{OCaml-style Notations}
We use the notation $L(v_{1..k})$, where $L$ is a label and $v_{1..k}$ is a (possibly singleton) tuple of mathematical values,
to denote the tuple $(L,v_{1..k})$.
We also write $L(T_{1..k})$, where $T_{1..k}$ denote mathematical type of values, to stand for
$\{L\} \times T_1 \times \ldots \times T_k$.
%
We later use these notations to define \emph{semantic configurations} (for example, $\Normal(\vv, \vg)$)
and \emph{native values} (for example $\nvint(\lint(1))$).
%
The notation $\langle \cdot \rangle$ stands for either an empty set or a singleton set,
where $\None\triangleq\langle\rangle$ denotes an empty set
and $\langle v \rangle$ denotes a set containing the single element $v$.
%
The notation $\langle T \rangle$, where $T$ denotes a mathematical types of values, stands for
$\{ \langle\rangle \} \cup \{\langle v \rangle \;|\; v \in T\}$.

\paragraph{Miscellaneous}
We define the following shorthand notations for the true and false expressions:
\newcommand\etrue[0]{\texttt{ETrue}}
\newcommand\efalse[0]{\texttt{EFalse}}
\[
\begin{array}{rcl}
  \etrue &\triangleq& \texttt{E\_Literal}(\texttt{L\_Bool}(\texttt{True}))\\
  \efalse &\triangleq& \texttt{E\_Literal}(\texttt{L\_Bool}(\texttt{False}))\\
\end{array}
\]

\section{Native Values \label{sec:nativevalues}}
The semantics of an ASL specification associates \emph{native values} to variables.
The set of native values is the minimal set defined by the following recursive rules (\texttt{NV} stands for Native Value):
\begin{mathpar}
  \inferrule[(Basis Set: Integers, Reals, Booleans, Strings, and Bitvectors)]{\vv \in \literal}
  { \nvliteral{v} \in \vals }
  \and
  \inferrule[(Tuple Values and Array Values)]{i=1..k: v_i \in \vals}
  { \nvvector{v_{1..k}} \in \vals }
  \and
  \inferrule[(Record Values)]{m \in \identifier \rightarrowfin \vals}
  { \nvrecord{m} \in \vals }
\end{mathpar}

We define the following shorthands for native value literals:
\[
\begin{array}{rcl}
\nvint(z)       &\triangleq& \nvliteral{\lint(z)}\\
\nvbool(b)      &\triangleq& \nvliteral{\lbool(b)}\\
\nvreal(r)      &\triangleq& \nvliteral{\lreal(r)}\\
\nvstring(s)    &\triangleq& \nvliteral{\lstring(s)}\\
\nvbitvector(v) &\triangleq& \nvliteral{\lbitvector(v)}\\
\end{array}
\]

We define the following shorthands for different types of native values:
\[
\begin{array}{rcl}
\tint       &\triangleq& \{ \nvint(z) \;|\; z \in \Z\}\\
\tbool      &\triangleq& \{ \nvbool(\True), \nvbool(\False) \}\\
\treal      &\triangleq& \{ \nvreal(r) \;|\; r \in \Q\}\\
\tstring    &\triangleq& \{ \nvstring(s) \;|\; \texttt{"}s\texttt{"} \in \texttt{<string>}\}\\
\tbitvector &\triangleq& \{ \nvbitvector(\textit{bits}) \;|\; \textit{bits} \in \{0,1\}^+\}\\
\tvector    &\triangleq& \{ \nvvector{\textit{vals}} \;|\; \textit{vals} \in \vals^*\}\\
\trecord    &\triangleq& \{ \nvrecord{\fieldmap} \;|\; \fieldmap \in \identifier\rightarrow\vals\}\\
\end{array}
\]

\section{Configurations \label{sec:configurations}}

Configurations express intermediate states related by \emph{semantic relations}.
%
More precisely, semantic relations relate two distinct sets of configurations ---
\emph{input configurations} and \emph{output configurations}.
Input configurations consist of an environment and an AST node.
Output configurations consist of an output environment, values,
and concurrent execution graphs.
%
Configurations wrap together elements such as environments and AST nodes
and associate them with a \emph{configuration domain}. Input configuration domains
determine the semantic relation they pertain to, while output configuration
domains distinguish between conceptually different kinds of outputs, for example
ones where an exception was raised, ones when a dynamic error occurred, etc.

We now explain the components over which configurations are defined:
\begin{itemize}
  \item Native Values~\ref{sec:nativevalues}, which correspond values associated with ASL types.
  \item Dynamic Environments~\ref{sec:dynamicenvironments}, which associate native values to variables.
  \item Static Environments~\ref{sec:staticenvironments}, consist of the information inferred
  by the type-checker for the specification. Also referred to as \emph{type environments}.
  \item Concurrent Execution Graphs~\ref{sec:concurrentexecutiongraphs}, which track Read and Write Effects over variables.
\end{itemize}

\subsection{Dynamic Environments \label{sec:dynamicenvironments}}

A \emph{sequential dynamic environment}, or \emph{dynamic environment}, for short, is a structure which,
amongst other things, associates native values to variables.
Formally, a sequential environment $\denv \in \dynamicenvs$ is a pair consisting of a partial function
(see \defref{PartialFunction}) from global
variable names to their native value, and a partial function from local variable names to their
native values:
\[
\begin{array}{rcl}
  \dynamicenvs          &\triangleq&  \mathbb{G} \times \mathbb{L} \\
  \mathbb{G}            &\triangleq&  (\identifier \partialto \vals) \\
  \mathbb{L}            &\triangleq&  (\identifier \partialto \vals) \\
\end{array}
\]

\subsection{Static Environments \label{sec:staticenvironments}}

A \emph{static environment}~\cite{ASLTypingReference} $\tenv \in \staticenvs$ (also referred to as a \emph{type environment})
is produced by the type-checker from the parsed AST.

In defining the semantics, we will refer to the following functions defined for a static environment:
\[
  \begin{array}{rcl}
    \findfunc       &:& \staticenvs \times \identifier \partialto \func\\
    \typesatisfies  &:& \staticenvs \times (\ty \times \ty) \rightarrow \{\True, \False\}
  \end{array}
\]
The partial function $\findfunc$ returns the typed AST of the subprogram for a given identifier.
(Recall that ASL allows subprogram overloading so a name does not uniquely identify
a specific subprogram.
However, the type-checker renames each function uniquely so that it can be accessed based
on its name alone.)
%
The function $\typesatisfies(\texttt{t}, \texttt{s})$ returns true
if the type \texttt{t} \emph{type-satisfies} the type \texttt{s}
(see TypingRule.TypeSatisfaction~\cite{ASLTypingReference}).
This is used in matching a raised exception to a corresponding catch clause.

Environments simply pair static environments with dynamic environments:
$\envs = \staticenvs \times \dynamicenvs$. We write $\env \in \envs$ to range over environments.
%
We note that this semantics always maintains the same static environment.

\subsection{Concurrent Execution Graphs \label{sec:concurrentexecutiongraphs}}

The concurrent semantics of an ASL specification utilizes \emph{concurrent execution graphs}
(\emph{execution graphs}, for short),
which track the Read and Write Effects over variables, yielded by the sequential semantics, and the \emph{ordering constraints}
between those effects.
Concurrent execution graphs are introduced, defined, and used in~\cite{AlglaveMT14,alglave2016syntax,AlglaveDGHM21},

Formally, an execution graph $\xgraph = (N^\xgraph, E^\xgraph, O^\xgraph) \in \XGraphs$
is defined via a set of \emph{nodes} ($N^\xgraph$), \emph{edges} ($E^\xgraph$), and \emph{output nodes} ($O^\xgraph$):
\[
\begin{array}{rcl}
  \XGraphs   	    &\triangleq& \pow{\Nodes} \times \pow{\Nodes \times \Nodes \times \Labels} \times \Nodes  \\
  \Nodes            &\triangleq& \N \times \{ \Read, \Write \} \times \identifier \\
  \Labels           &\triangleq& \{ \asldata, \aslctrl, \aslpo \}
\end{array}
\]

Nodes represent unique Read and Write Effects. Formally, a node $(u,l,\id)$ associates a unique instance counter $u$
to an \emph{ordering label} $l$, which specifies whether it represents a Read Effect of a Write Effect to a variable named $\id$.
%
We say that en Effect $E_1$ is \emph{$l$-before} another Effect $E_2$, for $l\in \Labels$ and a given execution graph
$g$, when $(\texttt{E1}, l, \texttt{E2}) \in E^g$.

An edge represents an ordering constraint between two effects, which can be one of the following:
\begin{description}
\item[$\asldata$] Represents a \emph{data dependency}.
That is, when one effect hands over its data to another effect.
\item[$\aslctrl$] Represents a \emph{control dependency}.
That is, when a Read Effect to a variable determines the flow of control (e.g., which condition of a branch is taken),
which then leads to another Read/Write Effect.
\item[$\aslpo$] Represents a \emph{program order}.
That is, when two effects are defined to be ordered according to the sequential semantics.
\end{description}

An execution graph is \emph{well-formed} if all nodes have unique instance counters, edges connect graph nodes,
and the output nodes are contained in the set of nodes:
\[
  \begin{array}{rcl}
  \forall n, n' \in N^\xgraph &.& n=(u,l,\id) \wedge n=(u',l',\id') \;\Rightarrow\; u \neq u' \\
  \forall e \in E^\xgraph &.& e=(n, n', l) \;\Rightarrow\; n, n' \in N^\xgraph \\
  & & O^\xgraph \subseteq N^\xgraph \enspace.
  \end{array}
\]

We denote the empty execution graph $\emptygraph \triangleq (\emptyset, \emptyset, \emptyset)$.
%
We define the following functions, which return an execution graph that represents a single Read/Write Effect to a variable \texttt{x}:
\[
  \begin{array}{rclll}
    \WriteEffect(\vx) &\triangleq& (\{n\}, \emptyset, \{n\}) & \text{where } n=(u, \Write, \vx), & u\in\N \text{ is fresh}\\
    \ReadEffect(\vx)  &\triangleq& (\{n\}, \emptyset, \{n\}) & \text{where } n=(u, \Read, \vx),   & u\in\N \text{ is fresh}\\
  \end{array}
\]

We also define two ways to compose execution graphs --- \emph{unordered composition} and
\emph{ordered composition with a given label}.

Given two execution graphs $S_1 = (N_1, E_1, O_1)$ and $S_1 = (N_2, E_2, O_2)$ their unordered composition,
denoted $S_1 \parallel S_2$ is defined as follows:
\[
  S_1 \parallel S_2\triangleq (N_1 \cup N_2, E_1 \cup E_2, O_1 \cup O_2) \enspace.
\]
Intuitively, this composition conveys the fact that there are no ordering constraints between the effects
in the arguments graphs.

Given two execution graphs $S_1 = (N_1, E_1, O_1)$ and $S_1 = (N_2, E_2, O_2)$ and an ordering label $l$,
the ordered composition $\ordered{S_1}{l}{S_2}$ is defined as follows:
\[
  \ordered{S_1}{l}{S_2} \triangleq (N_1 \cup N_2, E_1 \cup E_2 \cup (O_1 \times N_2 \times \{l\}, O_2)) \enspace.
\]
Intuitively, this composition constrains the output effects of $S_1$ to appear before any effect of $S_2$ with respect
to the given ordering label.

\subsection{Input Configurations and Output Configurations}

Recall that the ASL semantics defines a relation between input configurations and output configurations
(\secref{configurations}).
Input configuration domains are unique to the semantic relation that employs them.
For that reason, we name semantic relations by the name of the corresponding input configuration domain.
For example, the semantic relation that employs input configurations with the domain $\texttt{eval\_expr}$
is named $\texttt{eval\_expr}$.
%
We will often use the prefix \texttt{eval} for semantic relations with the intuition being that their input configurations
should be ``semantically evaluated'', yielding an output configuration.

ASL semantics mainly utilizes the following types of output configurations:
\begin{description}
  \item[Normal Values.] Configurations consisting of different combinations of values,
  execution graphs, and environments, representing intermediate results
  generated while evaluating statements:
  \begin{itemize}
  \item $\Normal(\vals \times \XGraphs)$,
  \item $\Normal((\vals \times \XGraphs), \envs)$,
  \item $\Normal(((\vals \times \vals)^* \times \XGraphs), \envs)$,
  \item $\Normal(\XGraphs, \envs)$,
  \item $\Normal((\vals^* \times \XGraphs), \envs)$, and
  \item $\Normal((\vals\times\XGraphs)^*, \envs)$.
  \end{itemize}

  \item[Exceptions.] Configurations in $\Throwing((\langle\vals \times \ty\rangle \times \XGraphs, \envs)$
  represent thrown exceptions,
  either without an exception value (as in \texttt{throw;}) or ones with an exception value and an associated type.
  The ASL semantics propagates these \emph{exceptional configurations} to the nearest catch clause that matches
  them, and otherwise they are ``caught'' at the top-level and reported as errors (see dynamic errors below).

  \item[Returned Values.] Configurations in $\Returning((\vals^* \times \XGraphs), \envs)$
  represent (tuples of) values being returned by the currently executing subprogram.
  The ASL semantics propagates these \emph{returning configurations} to the respective call expression/statement.

  \item[Subprogram In-flight.] Configurations in $\Continuing(\XGraphs, \envs)$
  represent the fact that a subprogram has more statements to execute.
  The ASl semantics treats these configurations as a signal to keep evaluating the remainder
  of the subprogram currently being evaluated.

  \item[Dynamic Errors.] Configurations in $\Error(\texttt{<string>})$
  represent runtime errors (for example, division by zero).
  The ASL semantics is set up such that when these \emph{error configurations} appear,
  the evaluation of the entire specification terminates by outputting them.
  The actual strings in an error configuration are not considered part of the specification.
  That is, an implementation of the semantics may use other strings.
\end{description}
Helper relations often have output configurations that are just tuples, without an associated domain.

We define the following shorthands for types of output configurations:
\[
  \begin{array}{rcl}
    \TThrowing        &\triangleq& \Throwing(\langle\vals \times \ty\rangle \times \XGraphs, \envs)\\
    \TContinuing      &\triangleq& \Continuing(\XGraphs, \envs)\\
    \TReturning       &\triangleq& \Returning((\vals^* \times \XGraphs), \envs)\\
    \TError           &\triangleq& \Error(\texttt{<string>})\\
  \end{array}
\]

We will say that a semantic transition \emph{terminates normally} when the output configuration domain is $\Normal$,
\emph{terminates exceptionally} when the output configuration domain is $\Throwing$,
\emph{terminates erroneously} when the output configuration domain is $\Error$,
and \emph{terminates abnormally} when it either terminates exceptionally or erroneously.

When an input configuration does not satisfy any semantic rule,
there is no output configuration for it to transition to, and we will say that
the configuration is \emph{stuck} --- the ASL semantics is undefined for that
input configuration.

\subsection{Extracting and Substituting Elements of Configurations}

We define the \emph{domain} of a configuration $C=M(\ldots)$, denoted $\configdomain{C}$, to be $M$.

Given a configuration $C$, we define the graph component of the configuration, $\graphof{C}$,
and the environment of the configuration, $\environof{C}$, as follows:
\[
\begin{array}{lcc}
  C & \graphof{C} & \environof{C}\\
  \hline
  \Normal(\vv,\vg) & \vg & \text{undefined}\\
  \Normal((\vv,\vg), \env) & \vg & \env\\
  \Normal(([i=1..k: (\texttt{va}_i,\texttt{vb})],\vg), \env) & \vg & \env\\
  \Normal(\vg, \env) & \vg & \env\\
  \Normal([\vv_{1..k}], \vg) & \vg & \env\\
  \Normal([i=1..k: (\vv_i,\vg_i)], \env) & \text{undefined} & \env\\
  \Throwing((\vx,\vg), \env) & \vg & \env\\
  \Returning(([\vv_{1..k}],\vg), \env) & \vg & \env\\
  \Continuing(\vg, \env) & \vg & \env\\
\end{array}
\]

Given a configuration $C$, we define $\withgraph{C}{\vgp}$ to be a configuration
like $C$ where the graph component is substituted with $\vgp$:
\[
\begin{array}{ll}
  C & \withgraph{C}{\vgp}\\
  \hline
  \Normal(\vv,\vg) & \Normal(\vv,\vgp)\\
  \Normal((\vv,\vg), \env) & \Normal((\vv,\vgp), \env)\\
  \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \env) & \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vgp), \env)\\
  \Normal(\vg, \env) & \Normal(\vgp, \env)\\
  \Normal(i=1..k: \vv_i, \vg) & \Normal(i=1..k: \vv_i, \vgp)\\
  \Normal([i=1..k: (\vv_i,\vg_i)], \env) & \text{undefined}\\
  \Throwing((\vx,\vg), \env) & \Throwing((\vx,\vgp), \env)\\
  \Returning((i=1..k: \vv_i,\vg), \env) & \Returning((i=1..k: \vv_i,\vgp), \env)\\
  \Continuing(\vg, \env) & \Continuing(\vgp, \env)\\
\end{array}
\]
Similarly, we define the $\withenviron{C}{\envp}$ to be a configuration
like $C$ where the environment component, if one exists, is substituted with $\envp$:
\[
\begin{array}{ll}
  \textbf{Configuration} & \withenviron{C}{\envp}\\
  \hline
  \Normal(\vv,\vg) & \text{undefined}\\
  \Normal((\vv,\vg), \env) & \Normal((\vv,\vg), \envp)\\
  \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \env) & \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \envp)\\
  \Normal(\vg, \env) & \Normal(\vg, \envp)\\
  \Normal(i=1..k: \vv_i, \vg) & \Normal(i=1..k: \vv_i, \vg)\\
  \Normal([i=1..k: (\vv_i,\vg_i)], \env) & \Normal([i=1..k: (\vv_i,\vg_i)], \envp)\\
  \Throwing((\vx,\vg), \env) & \Throwing((\vx,\vg), \envp)\\
  \Returning((i=1..k: \vv_i,\vg), \env) & \Returning((i=1..k: \vv_i,\vg), \envp)\\
  \Continuing(\vg, \env) & \Continuing(\vg, \envp)\\
\end{array}
\]

\section{Semantic Evaluation}

The semantics of ASL is given by the relations\footnote{The reason that relations, rather than functions, are used is due to the
potential non-determinism in the primitive subprograms,
the choice of execution graph node identifiers,
and the non-determinism inherent in the \texttt{UNKOWN} expression.}
$\evalarrow$ and $\evalprimitivearrow$.
The latter relation provides the semantics of primitive functions and is not otherwise defined
constructively.
The relation $\evalarrow$ is defined as the disjoint union of the relations defined in this document.
% \[
%   \begin{array}{rcl}
%   \evalarrow &\triangleq& \textit{main\_asl\_relations} \cupdot \textit{secondary\_asl\_relations}\\
%   \textit{main\_asl\_relations} &\triangleq& \texttt{eval\_expr} \cupdot \texttt{eval\_lexpr} \cupdot \texttt{eval\_slices}\\
%    & & \texttt{eval\_pattern} \cupdot \texttt{eval\_local\_decl} \cupdot \texttt{eval\_stmt}\\
%    & & \texttt{eval\_block} \cup \texttt{eval\_loop}\\
%    & & \texttt{eval\_catchers} \cupdot \texttt{eval\_call} \cupdot \texttt{eval\_spec}\\
%    \textit{secondary\_asl\_relations} &\triangleq& ...
%   \end{array}
% \]
The semantics of the various types of AST nodes is given by a set of \emph{semantic relations} between
input configurations and output configurations.

% ASL defines the following relations between input configurations and output configurations
% for the corresponding labels (input configurations reference AST elements~\cite{ASLAbstractSyntaxReference}
% \expr, \lexpr, \stmt, \slice, \localdeclitem, \identifier, \fordirection, and \catcher):

% \begin{tabular}{ll}
%   \textbf{\texttt{label}} & \textbf{Input Configurations $\aslrel$} \\
%                           & \textbf{Output Configurations} \\
%   \hline
%   \hline
%   \texttt{eval\_expr}         & $\evalexpr{\envs \times \expr} \aslrel$\\
%                         & $\Normal(\vals \times \XGraphs) \cup \TThrowing \cup \TError$\\
%   \hline
%   \texttt{eval\_lexpr}        & $\evallexpr{\envs \times \lexpr \times (\vals \times \XGraphs)} \aslrel$\\
%                         & $\Normal(\XGraphs,\envs) \cup \TThrowing \cup \TError$\\
%   \hline
%   \texttt{eval\_slices}       & $\evalslices{\envs \times \slice^*} \aslrel$\\
%                         & $\Normal((\vals \times \vals)^*, \envs) \cup \Throwing \cup \TError$ \\
%   \hline
%   \texttt{eval\_pattern}      & $\evalpattern{\envs \times \vals \times \pattern} \aslrel$\\
%                         & $\Normal(\vals, \XGraphs)$ \\
%   \hline
%   \texttt{eval\_local\_decl}  & $\evallocaldecl{\envs \times \localdeclitem \times \langle\vals\times\XGraphs\rangle} \aslrel$\\
%                         & $\Normal(\XGraphs, \envs)$ \\
%   \hline
%   \texttt{eval\_stmt}         & $\evalstmt{\envs \times \stmt} \aslrel$\\
%                         & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
%   \hline
%   \texttt{eval\_block}        & $\evalblock{\envs \times \stmt} \aslrel$\\
%                         & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
%   \hline
%   \texttt{eval\_loop}         & $\evalloop{\envs \times \{\True,\False\} \times \expr \times \stmt} \aslrel$\\
%                         & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
%   \hline
%   \texttt{eval\_for}          & $\evalfor{\envs \times \identifier \times \vals \times \fordirection \times \vals} \aslrel$\\
%                         & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
%   \hline
%   \texttt{eval\_catchers}     & $\evalcatchers{\envs \times \catcher^* \times \langle\stmt\rangle \times \TOutConfig} \aslrel$\\
%                         & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
%   \hline
%   \texttt{eval\_call}         & $\evalcall{\envs \times \identifier \times \expr^* \times (\identifier\times\expr)^*} \aslrel$ \\
%                         & $\Normal((\vals\times\XGraphs)^* \times \envs) \cup \TThrowing \cup \TError$ \\
%   \hline
%   \texttt{eval\_spec}    & $\evalspec{\spec\times\spec} \aslrel$ \\
%                         & $((\vals\times \XGraphs) \cup \TError)$ \\
%   \end{tabular}

  We use the notation $C \evalarrow C'$ to denote a transition between input and output configurations.
  That is, $(C, C') \in\ \evalarrow$.
%  We denote elements of a semantic relation by $\texttt{eval\_<label>}(\env, n) \evalarrow L'(v'_{1..n})$.
%We define the semantic relation $\semantic{\texttt{label}}$, for each label, as
% the set of all its semantic transitions:
% \[
%   \semantic{\texttt{label}} \triangleq \{ \texttt{eval\_<label>}(\env, n) \evalarrow L'(v'_{1..n})  \;|\;
% \env \in \envs,\; \texttt{label}(n) \} \enspace.
% \]

  When introducing semantic relations, instead of using the mathematical notation
  \[
    \text{relation name} : \text{type of left elements} \;\times\; \text{type of right elements} \enspace,
  \]
  we will simply write
  \[
    \text{type of left elements} \;\times\; \text{type of right elements} \enspace.
  \]
  This is because the type of the left-hand side elements are configurations where the
  configuration domain is the relation name.
  %
  Also, we associate names with the types appearing in the type of the relation.
  These names refer to the free variables in the rules that constructively define the type.
  We also refer to these variable names when explaining the intent of the relation.
  For example, the following defines the relation $\texttt{eval\_expr}$:
  \[
    \evalexpr{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \aslrel \Normal(\overname{\vals}{\vv} \aslsep \overname{\XGraphs}{\vg}) \cup \TThrowing \cup \TError
  \]
  The type of the left element is that of configurations $\evalexpr{\envs \aslsep \expr}$.
  The rules defining this relation use the variable names
  $\env$, $\ve$, $\vv$, and $\vg$ to the refer to the input environment, the expression that needs to be evaluated,
  the output value and the output execution graph, respectively.

\subsection{Natural Operational Semantics}
We define the ASL semantics in the style of \emph{natural operational semantics}~\cite{SemanticsWithApplicationsBook}.
Natural operational semantics evaluates the AST inductively.
That is, it concludes transitions for configurations starting from
non-leaf AST nodes by concluding transitions from configurations starting from their children nodes.

One implication of utilizing this style of semantics is that non-terminating loops and non-terminating
recursive subprograms calls are not assigned any meaning as there are no semantic transitions that they can take.
(Technically, in a non-terminating specification, a subset of the premises yield transitions into configurations
with more premises and so on.)

\subsubsection{Evaluation Example}

The example shows how the rules for expression literals and binary operator expressions can be combined
to infer a transition from an input configuration with the expression for $(1+2)*(4+5)$ to an output configuration
with the value resulting from the calculation of the expression.

For succinctness, we write $E(\texttt{<expression>})$
for the AST node parsed from an expression $\texttt{<expression>}$.
% That is, for an integer $n$, $E(n) \triangleq\texttt{E\_Literal}(\lint(n))$
% and
%
We write $\emptyenv$ to stand for a trivial environment (that is, one where all functions are empty).

Notice that, we have dropped the execution graph component and simplified pairs of the form $(\vv,\vg)$,
where $\vv$ is a native value and $\vg$ is an execution graph, to just $\vv$.
This is because we are interested in demonstrating the sequential semantics (also, the execution graphs
in this case are all empty).

The example shows, using references to the relevant rules, how the expression for $1+2$ is evaluated
using the rule for literal expressions, the rule for binary operator (for addition), and the rules for binary expressions.
Similarly, the expression for $4+5$ is evaluated.
Finally, the the transitions for both of the sub-expressions are used as premises for the binary expression
rule, along with the rule for binary operator (for multiplication), to evaluate the entire expression.

\newcommand\elint[1]{\texttt{E\_Literal}(\lint(#1))}

\begin{mathpar}
  \inferrule*[right=\ref{sec:SemanticsRule.Binop}]{
    \inferrule*[right=\ref{sec:SemanticsRule.Lit}]{}{ \evalexpr{\emptyenv, E(1)} \evalarrow \Normal(\nvint(1), \emptyenv) } \\\\
    \inferrule*[right=\ref{sec:SemanticsRule.Lit}]{}{ \evalexpr{\emptyenv, E(2)} \evalarrow \Normal(\nvint(2), \emptyenv) } \\\\
    \inferrule*[right=\ref{sec:BinaryOperator}]{}{\binop(\PLUS, \nvint(1), \nvint(2)) \evalarrow \nvint(3)}
  }
  {
    \evalexpr{ \emptyenv, E(1+2) } \evalarrow
    \Normal(\nvint(3), \emptyenv)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule*[right=\ref{sec:SemanticsRule.Binop}]{
    \inferrule*[right=\ref{sec:SemanticsRule.Lit}]{}{ \evalexpr{\emptyenv, E(4)} \evalarrow \Normal(\nvint(4), \emptyenv) } \\\\
    \inferrule*[right=\ref{sec:SemanticsRule.Lit}]{}{ \evalexpr{\emptyenv, E(5)} \evalarrow \Normal(\nvint(5), \emptyenv) } \\\\
    \inferrule*[right=\ref{sec:BinaryOperator}]{}{\binop(\PLUS, \nvint(4), \nvint(5)) \evalarrow \nvint(9)}
  }
  {
    \evalexpr{ \emptyenv, E(4+5) } \evalarrow
    \Normal(\nvint(9), \emptyenv)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule*[right=\ref{sec:SemanticsRule.Binop}]{
    \evalexpr{ \emptyenv, E(1+2) } \evalarrow \Normal(\nvint(3), \emptyenv)\\
    \evalexpr{ \emptyenv, E(4+5) } \evalarrow \Normal(\nvint(9), \emptyenv)\\
    \inferrule*[right=\ref{sec:BinaryOperator}]{}{\binop(\MUL, \nvint(3), \nvint(9)) \evalarrow \nvint(27)}
  }
  {
    \evalexpr{ \emptyenv, E((1+2)*(4+5)) } \evalarrow
    \Normal(\nvint(27), \emptyenv)
  }
\end{mathpar}

\subsubsection{No Undefined Behaviors}
This semantics is defined for well-typed ASL specifications.
This semantics gets stuck only in cases of non-terminating executions
(for example, non-terminating loops, or infinite recursion).
Otherwise, for every input configuration there is at least one rule that can be used to take a semantic transition.

\subsection{Short-Circuit Rule Templates}

Short-circuit rule templates allow us to succinctly define sets of rules.
Specifically, they allow us to capture situations where if a transition
into an output configuration occurs in a premise then the rest of the rule
can be ignored as the input configuration in the verdict also transitions
into that output configuration. These output configurations are usually
due to raised exceptions or dynamic errors.

A template rule:
\begin{mathpar}
  \inferrule{
    i=1..k: P_i\\\\
    C \evalarrow C' \terminateas E\\\\
    j=1..n: Q_i\\
  }
  {
    D \evalarrow D'
  }
\end{mathpar}

Stands for the following pair of rules (the second of which is possibly a template rule itself):
\begin{mathpar}
  \inferrule[(Short-circuited)]{
    i=1..k: P_i\\\\
    C \evalarrow E
  }
  {
    D \evalarrow E
  }
\and
  \inferrule{
    i=1..k: P_i\\\\
    C \evalarrow C' \\\\
    j=1..n: Q_i\\
  }
  {
    D \evalarrow D'
  }
\end{mathpar}

We allow several short-cirtcuiting configurations in a template.
Specifically, a template rule:
\begin{mathpar}
  \inferrule{
    i=1..k: P_i\\\\
    C \evalarrow C' \terminateas E_{1...m}\\\\
    j=1..n: Q_i\\
  }
  {
    D \evalarrow D'
  }
\end{mathpar}
Stands for the set of template rules
\begin{mathpar}
  \inferrule{
    i=1..k: P_i\\\\
    C \evalarrow C' \terminateas E_1\\\\
    j=1..n: Q_i\\
  }
  {
    D \evalarrow D'
  }
\and
\inferrule{\ldots}{}
\and
\inferrule{
  i=1..k: P_i\\\\
  C \evalarrow C' \terminateas E_m\\\\
  j=1..n: Q_i\\
}
{
  D \evalarrow D'
}
\end{mathpar}

We introduce the following shorthands for abnormal configurations:
$\ThrowingConfig \triangleq \Throwing((\vv, \vg), \newenv)$
and $\ErrorConfig \triangleq \Error(\vs)$.

% \subsection{ASL Semantic Rules}

% The set of ASL semantic rules is grouped as follows:

% \begin{tabular}{lll}
% % \textbf{\texttt{label}} & \textbf{Description} & \textbf{Chapter/Section} \\
% % \hline
% Expressions & Chapter~\ref{chap:eval_expr}\\
% Left-hand sides of assignments & Chapter~\ref{chap:eval_lexpr}\\
% Slices & Chapter~\ref{chap:eval_slices}\\
% Patterns & Chapter~\ref{chap:eval_pattern}\\
% Local declarations & Chapter~\ref{chap:eval_local_decl}\\
% Statements & Chapter~\ref{chap:eval_stmt}\\
% Statement blocks & Chapter~\ref{chap:eval_block}\\
% \texttt{while} and \texttt{repeat} loops & Section~\ref{sec:SemanticsRule.Loop}\\
% \texttt{for} loops & Section~\ref{sec:SemanticsRule.For}\\
% Exception catchers & Chapter~\ref{chap:eval_catchers}\\
% Subprogram invocations & Chapter~\ref{chap:eval_call}\\
% Specifications & Chapter~\ref{chap:eval_spec}\\
% \end{tabular}\\

\chapter{Reading guide}

The set of rules for each label is further split according to the ``shape'' of the AST node.
For example, expressions are split into literal expressions, binary operation expressions, etc.
Each such subset of rules is named accordingly and appears in a section with the same name.
For example, the rule for literal expressions is named SemanticsRule.Lit and defined in
Section~\ref{sec:SemanticsRule.Lit}.

Each rule is presented using the following template:
\begin{itemize}
\item a Prose paragraph gives the rule in English, and corresponds, as much as possible, to the code of the reference implementation ASLRef given at
 \href{https://github.com/herd/herdtools7//tree/master/asllib}{/herdtools7/asllib};
\item one or several Example, which as much as possible are also given as regression tests in
\href{https://github.com/herd/herdtools7//tree/master/asllib/tests/ASLSemanticsReference.t}{/herdtools7/asllib/tests/ASLSemanticsReference.t};
\item a Code paragraph which gives a verbatim of the corresponding implementation in the interpreter of ASLRef
\href{https://github.com/herd/herdtools7//tree/master/asllib/Interpreter.ml}{/herdtools7/asllib/Interpreter.ml};
\item a Formal paragraph, which provides semantic rules that essentially give the same information as the Prose paragraph, for both
the sequential semantics and the concurrent semantics, in the form of concurrent execution graphs.
The latter enables building, for each AArch64 instruction,
the Intrinsic dependencies used by the AArch64 memory model from the ASL code of the instruction~\cite[B2.3.2]{ArmARM}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basic Utility Relations \label{chap:utility}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we define helper relations for operating on native values,
environments, and operations involving values and types.

\newcommand\declarelocalidentifier[0]{\texttt{declare\_local\_identifier}}
\newcommand\declarelocalidentifierm[0]{\texttt{declare\_local\_identifier\_m}}
\newcommand\declarelocalidentifiermm[0]{\texttt{declare\_local\_identifier\_mm}}
\newcommand\removelocal[0]{\texttt{remove\_local}}
\newcommand\readidentifier[0]{\texttt{read\_identifier}}
\newcommand\writeidentifier[0]{\texttt{write\_identifier}}
\newcommand\createbitvector[0]{\texttt{create\_bitvector}}
\newcommand\concatbitvectors[0]{\texttt{concat\_bitvectors}}
\newcommand\readfrombitvector[0]{\texttt{read\_from\_bitvector}}
\newcommand\writetobitvector[0]{\texttt{write\_to\_bitvector}}
\newcommand\asbitvector[0]{\texttt{as\_bitvector}}
\newcommand\slicestopositions[0]{\texttt{slices\_to\_positions}}
\newcommand\getindex[0]{\texttt{get\_index}}
\newcommand\setindex[0]{\texttt{set\_index}}
\newcommand\getfield[0]{\texttt{get\_field}}
\newcommand\setfield[0]{\texttt{set\_field}}
\newcommand\declareglobal[0]{\texttt{declare\_global}}
\newcommand\basevalue[0]{\texttt{base\_value}}
\newcommand\isvaloftype[0]{\texttt{is\_val\_of\_type}}

\section{Dropping an Identifier from the Local Storage}
The relation
\[
  \removelocal(\overname{\envs}{\env} \aslsep \overname{\identifier}{\name}) \;\aslrel\; \overname{\envs}{\envp}
\]
unmaps the identifier $\name$ from the local storage of the environment $\env$.
We use the notation $[\name\mapsto\bot]$ to mean that $\name$ is no part of the domain of the resulting function.
\begin{mathpar}
  \inferrule{
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \envp = (\tenv, (G^\denv, L^\denv[\name \mapsto \bot]))
  }
  {
    \removelocal(\env, \name) \evalarrow \envp
  }
\end{mathpar}

\section{Reading an Identifier}

The relation
\[
  \readidentifier(\overname{\identifier}{\name}\aslsep\overname{\vals}{\vv}) \;\aslrel\; (\overname{\vals}{\vv} \times \XGraphs)
\]
represents reading a value $\vv$ into a storage element given by an identifier $\name$.
The result is the value and a graph containing a single Read Effect denoting
reading $\vv$ into $\name$.

\begin{mathpar}
  \inferrule[read\_identifier]{}
  {
    \readidentifier(\name, \vv) \evalarrow (\vv, \ReadEffect(\name))
  }
\end{mathpar}

\section{Writing to an Identifier}

The relation
\[
  \writeidentifier(\overname{\identifier}{\name}\aslsep\overname{\vals}{\vv}) \;\aslrel\; (\overname{\vals}{\vv} \times \XGraphs)
\]
represents reading a value $\vv$ into a storage element given by an identifier $\name$.
The result is the value and a graph containing a single Read Effect denoting
reading $\vv$ into $\name$.

\begin{mathpar}
  \inferrule[write\_identifier]{}
  {
    \writeidentifier(\name, \vv) \evalarrow \WriteEffect(\name)
  }
\end{mathpar}

\section{Creating a Bitvector}
The relation
\[
  \createbitvector(\overname{\vals^*}{\vvs}) \;\aslrel\; \tbitvector
\]
creates a native vector value from a sequence of values.

\begin{mathpar}
  \inferrule[create\_vector]{}
  {
    \createbitvector(\vvs) \evalarrow \nvbitvector{\vvs}
  }
\end{mathpar}

\section{Concatenating Bitvectors}
The relation
\[
  \concatbitvectors(\overname{\tbitvector^*}{\vvs}) \;\aslrel\; \tbitvector
\]
transforms a, possibly empty, list of bitvector native values into a single bitvector.

(Recall that $\epsilon$ stands for an empty sequence and $\cdot$ concatenates sequences.)
\begin{mathpar}
  \inferrule[concat\_bitvectors\_empty]{}
  {
    \concatbitvectors(\emptylist) \evalarrow \nvbitvector(\epsilon)
  }
  \and
  \inferrule[concat\_bitvectors\_non\_empty]{
    \vvs \eqname [\vv] + \vvs'\\
    \vv\eqname\nvbitvector(\bv)\\
    \concatbitvectors(\vvs') \evalarrow \nvbitvector(\bv')\\
    \vres = \bv \cdot \bv'
  }
  {
    \concatbitvectors(\vvs) \evalarrow \nvbitvector(\vres)
  }
\end{mathpar}

\section{Reading from a Bitvector}
We start by introducing a few helper relations.

\newcommand\positioninrange[0]{\texttt{position\_in\_range}}
The predicate $\positioninrange(\vs, \vl, n)$ checks whether the indices starting at index $\vs$ and
up to $\vs + \vl$, inclusive, would refer to actual indices of a bitvector of length $n$:
\begin{mathpar}
  \inferrule[position\_in\_range]{
    \vs \geq 0\\
    \vl \geq 0\\
    \vs + \vl < \vn
  }
  {
    \positioninrange(\vs, \vl, \vn)
  }
\end{mathpar}

The relation
\[
  \slicestopositions(\overname{\N}{\vn} \aslsep \overname{(\overname{\tint}{\vs_i}\times\overname{\tint}{\vl_i})^+}{\slices}) \;\aslrel\;
  (\overname{\N^*}{\positions} \cup\ \TError)
\]
returns the list of positions (indices) specified by the slices $\slices$,
unless an index would be out of range for a bitvector of length $\vn$, in which case it returns an error configuration.

\begin{mathpar}
  \inferrule[slices\_to\_positions\_out\_of\_range]{
    \slices \eqname [i=1..k: (\nvint(\vs_i), \nvint(\vl_i))]\\
    j \in 1..k: \neg\positioninrange(\vs_j, \vl_j, \vn)
  }
  {
    \slicestopositions(\vn, \slices) \evalarrow \Error(\texttt{"Slice position out of range"})
  }
  \and
  \inferrule[slices\_to\_positions\_in\_range]{
    \slices \eqname [i=1..k: (\nvint(\vs_i), \nvint(\vl_i))]\\
    i=1..k: \positioninrange(\vs_i, \vl_i, \vn)\\
    \positions = [\vs_1,\ldots,\vs_1+\vl_1] + \ldots + [\vs_k,\ldots,\vs_k+\vl_k]\\
  }
  {
    \slicestopositions(\vn, \slices) \evalarrow \positions
  }
\end{mathpar}

The function $\asbitvector : (\tbitvector\cup\tint) \rightarrow \{0,1\}^*$ transforms native value integers and native value bitvectors into
a sequence of binary values:
\begin{mathpar}
  \inferrule[as\_bitvector\_bitvector]{}
  {
    \asbitvector(\nvbitvector(\bv)) \evalarrow \bv
  }
  \and
  \inferrule[as\_bitvector\_int]{
    \bv = \text{ two's complement representation of }n
  }
  {
    \asbitvector(\nvint(n)) \evalarrow \bv
  }
\end{mathpar}

Finally, the relation
\[
  \readfrombitvector(\overname{\tbitvector}{\bv} \aslsep \overname{(\tint\times\tint)^*}{\slices}) \;\aslrel\;
  \overname{\tbitvector}{\vv} \cup \overname{\TError}{\ErrorConfig}
\]
reads from a bitvector $\bv$, or an integer seen as a bitvector, the indices specified by the list of slices $\slices$.
If all indices are in range for $\bv$, then the returned bitvector consists of the concatenated bits specified
by the slices.
Otherwise, an error configuration is returned.
%
The rules below distinguish between empty bitvectors and non-empty bitvectors.
\begin{mathpar}
  \inferrule[read\_from\_bitvector\_empty]{}
  {
    \readfrombitvector(\bv, \emptylist) \evalarrow \nvbitvector(\epsilon)
  }
  \and
  \inferrule[read\_from\_bitvector\_non\_empty]{
    \asbitvector(\bv) = \vb_n \ldots \vb_1\\
    \slicestopositions(n, \slices) \evalarrow [j_{1..m}] \terminateas \ErrorConfig\\
    \vv = \nvbitvector(\vb_{j_m + 1}\ldots\vb_{j_1 + 1})
  }
  {
    \readfrombitvector(\bv, \slices) \evalarrow \vv
  }
\end{mathpar}
Notice that the bits of a bitvector go from the least significant bit being on the right to the most significant bit being on the left,
which is reflected by how the rules list the bits.
Also notice that bitvector bits are numbered from 1 and on, which is why we add 1 to the indices specified
by the slices when accessing a bit.

\section{Writing to a Bitvector}
The relation
\[
  \writetobitvector(\overname{(\tint\times\tint)^*}{\slices} \aslsep \overname{\tbitvector}{\src} \aslsep \overname{\tbitvector}{\dst})
  \;\bigtimes\; \overname{\tbitvector}{\vv} \cup \overname{\TError}{\ErrorConfig}
\]
overwrites the bits of $\dst$ at the positions given by $\slices$ with the bits of $\src$.

\begin{mathpar}
  \inferrule[write\_to\_bitvector\_empty]{}
  {
    \writetobitvector(\emptylist, \nvbitvector(\epsilon), \nvbitvector(\epsilon)) \evalarrow \nvbitvector(\epsilon)
  }
  \and
  \inferrule[write\_to\_bitvector\_non\_empty]{
    \asbitvector(\src) = \vs_n \ldots \vs_1\\
    \asbitvector(\dst) = \vd_n \ldots \vd_1\\
    \slicestopositions(n, \slices) \evalarrow \positions \terminateas \ErrorConfig\\
    {\mathit{bit} = \lambda i \in 1..n.\left\{ \begin{array}{ll}
     \vs_i & i \in \positions\\
     \vd_i & \text{else}
    \end{array} \right.}\\
    \vv=\nvbitvector(\mathit{bit}(n-1)\ldots \mathit{bit}(0))\\
  }
  {
    \writetobitvector(\slices, \src, \dst) \evalarrow \vv
  }
\end{mathpar}

\section{Reading from a Vector}
The relation
\[
  \getindex(\overname{\N}{\vi} \aslsep \overname{\tvector}{\vvec}) \;\aslrel\; \overname{\tvector}{\vv_{\vi}}
\]
reads the value $\vv_i$ from the vector of values $\vvec$ at the index $\vi$.

\begin{mathpar}
  \inferrule[get\_index]{
    \vvec \eqname [\vv_{i=0..k}]\\
    \vi \leq k\\
  }
  {
    \getindex(\vi, \vvec) \evalarrow \vv_{\vi}
  }
\end{mathpar}
Notice that there is no rule to handle the case where the index is out of range ---
this is guaranteed by the type-checker not to happen. Specifically,
\begin{itemize}
  \item \texttt{TypingRule.EGetArray} ensures that an index is within the bounds of the array
  being accessed via a check that the type of the index satisfies the type of the array size.
  \item Typing rules \texttt{TypingRule.LEDestructuring}, \texttt{TypingRule.PTuple},
  and \texttt{TypingRule.LDTuple} use the same index sequences for the tuples
  involved and the corresponding lists of expressions.
\end{itemize}
If the rules listed above do not hold the type checker fails.

\section{Writing to a Vector}
The relation
\[
  \setindex(\overname{\N}{\vi} \aslsep \overname{\vals}{\vv} \aslsep \overname{\tvector}{\vvec}) \;\aslrel\; \overname{\tvector}{\vres}
\]
overwrites the value at the given index $\vi$ in a vector of values $\vvec$ with the new value $\vv$.

\begin{mathpar}
  \inferrule[set\_index]{
    \vvec \eqname [\vu_{0..k}]\\
    \vi \leq k\\
    \vres \eqname [\vw_{0..k}]\\
    \vw_{\vi} = \vv\\
    j \in \{0..k\} \setminus \{\vi\}.\ \vw_{j} = \vu_j\\
  }
  {
    \setindex(\vi, \vv, \vvec) \evalarrow \vres
  }
\end{mathpar}
Similar to $\getindex$, there is no need to handle the out-of-range index case.

\section{Reading a Field}
The relation
\[
  \getfield(\overname{\identifier}{\name} \aslsep \overname{\trecord}{\record}) \;\aslrel\; \vals
\]
retrieves the value corresponding to the field name $\name$ from the record value $\record$.

\begin{mathpar}
  \inferrule[get\_field]{
    \record \eqname \nvrecord{\fieldmap}
  }
  {
    \getfield(\name, \record) \evalarrow \fieldmap(\name)
  }
\end{mathpar}
The type-checker ensures, via TypingRule.EGetRecordField, that the field $\name$ exists in $\record$.

\section{Writing a Field}
The relation
\[
  \setfield(\overname{\identifier}{\name} \aslsep \overname{\vals}{\vv} \aslsep \overname{\trecord}{\record}) \;\aslrel\; \trecord
\]
overwrites the value corresponding to the field name $\name$ in the record value $\record$ with the value $\vv$.

\begin{mathpar}
  \inferrule[set\_field]{
    \record \eqname \nvrecord{\fieldmap}\\
    \fieldmap' = \fieldmap[\name\mapsto\vv]
  }
  {
    \setfield(\name, \vv, \record) \evalarrow \nvrecord{\fieldmap'}
  }
\end{mathpar}
The type-checker ensures that the field $\name$ exists in $\record$.

\section{Declaring a Local Identifier}
The relation
\[
  \declarelocalidentifier(\overname{\envs}{\env} \aslsep \overname{\identifier}{\name} \aslsep \overname{\vals}{\vv}) \;\aslrel\;
  (\overname{\envs}{\envp}\times\overname{\XGraphs}{\vg})
\]
associates $\vv$ to $\name$ as a local storage element in the environment $\env$ and
returns the updated environment $\envp$ with the execution graph that consists of a Write Effect to $\name$.

\begin{mathpar}
  \inferrule[declare\_local\_identifier]{
    \vg = \WriteEffect(\name)\\
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \envp = (\tenv, (G^\denv, L^\denv[\name\mapsto \vv]))
  }
  { \declarelocalidentifier(\env, \name, \vv) \evalarrow (\envp, \vg)  }
\end{mathpar}

The relation
\[
  \declarelocalidentifierm(\overname{\envs}{\env} \aslsep
   \overname{\identifier}{\vx} \aslsep
   \overname{(\overname{\vals}{\vv}\times\overname{\XGraphs}{\vg})}{\vm}) \;\aslrel\;
  (\overname{\envs}{\envp} \times \overname{\XGraphs}{\vgtwo})
\]
declares the local identifier $\vx$ in the environment $\env$ and composes it using
a data label with the graph $\vg$:
\begin{mathpar}
  \inferrule[declare\_local\_identifier\_m]{
    \vm \eqname (\vv, \vg)\\
    \declarelocalidentifier(\env, \vx, \vv) \evalarrow (\envp, \vgp)\\
    \vgtwo = \ordered{\vg}{\asldata}{\vgp}
  }
  {
    \declarelocalidentifierm(\env, \vx, \vm) \evalarrow (\envp, \vgtwo)
  }
\end{mathpar}

The relation
\[
  \declarelocalidentifiermm(\overname{\envs}{\env} \aslsep
   \overname{\identifier}{\vx} \aslsep
   \overname{(\overname{\vals}{\vv}\times\overname{\XGraphs}{\vg})}{\vm}) \;\aslrel\;
  (\overname{\envs}{\envp} \times \overname{\XGraphs}{\vgtwo})
\]
declares the local identifier $\vx$ in the environment $\env$ and composes it using
a program order label with the graph $\vg$:
\begin{mathpar}
  \inferrule[declare\_local\_identifier\_mm]{
    \vm \eqname (\vv, \vg)\\
    \declarelocalidentifierm(\env, \vx, \vv) \evalarrow (\envp, \vgp)\\
    \vgtwo = \ordered{\vg}{\aslpo}{\vgp}
  }
  {
    \declarelocalidentifiermm(\env, \vx, \vm) \evalarrow (\envp, \vgtwo)
  }
\end{mathpar}

\section{Declaring a Global Identifier}
The relation
\[
  \declareglobal(\overname{\identifier}{\name} \aslsep \overname{\vals}{\vv} \aslsep \overname{\envs}{\env}) \;\aslrel\; \overname{\envs}{\envp}
\]
updates the environment $\env$ by mapping $\name$ to $\vv$ as a global storage element.

\begin{mathpar}
  \inferrule[declare\_global]{
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \envp = (\tenv, (G^\denv[\name\mapsto \vv], L^\denv))
  }
  { \declareglobal(\name, \vv, \env) \evalarrow \envp  }
\end{mathpar}


\section{Obtaining the Base Value of a Type \label{sec:basevalue}}
The relation
\[
  \basevalue(\overname{\envs}{\env} \aslsep \overname{\ty}{\vt}) \;\aslrel\;
  (\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg}) \cup \overname{\TError}{\ErrorConfig}
\]
returns the \emph{base value} $\vv$ of the type $\vt$ in the environment $\env$, as well as the execution graph $\vg$ that results
from evaluating any of the side-effect-free expressions appearing in $\vt$.
%
Evaluating those inner expressions is done via the relation $\texttt{eval\_expr\_sef}$~\ref{sec:SemanticsRule.ESideEffectFreeExpr}.
If evaluating an inner expression results in an error, there is no base value and an error configuration is returned.

To obtain the base value of a type, we first obtain its \emph{structure}, using the function
$\tstruct : \ty \partialto \ty$.
The structure of a type is the type that can hold the same set of values, but does not itself
contain any other type names.
This is essentially done by recursively replacing type names by their definition.
For more information refer to TypingRule.Structure in
ASL Typing Reference~\cite{ASLTypingReference}.
%
Since we assume the specification is well-typed (\secref{MeaningfulASLSpecifications}), $\tstruct$ always returns a valid type.

\begin{mathpar}
  \inferrule[base\_value\_bool]{
    \tstruct(\vt) \eqname \TBool
  }
  {
    \basevalue(\env, \vt) \evalarrow \nvbool(\True)
  }
  \and
  \inferrule[base\_value\_real]{
    \tstruct(\vt) \eqname \TReal
  }
  {
    \basevalue(\env, \vt) \evalarrow \nvreal(0)
  }
  \and
  \inferrule[base\_value\_string]{
    \tstruct(\vt) \eqname \TString
  }
  {
    \basevalue(\env, \vt) \evalarrow \nvliteral{\lstring(\epsilon)}
  }
\end{mathpar}

The base value of a bitvector is a bitvector native value consisting of a sequence of zeros
of the length specified by the type (\ve). If the length is $0$, the bitvector consists of an
empty sequence:
\begin{mathpar}
  \inferrule[base\_value\_bitvector]{
    \tstruct(\vt) \eqname \TBits(\ve, \Ignore)\\
    \evalexprsef{\env, \ve} \evalarrow (\nvint(\length), \emptygraph) \terminateas \ErrorConfig
  }
  {
    \basevalue(\env, \vt) \evalarrow \nvbitvector(\overbrace{0\ldots 0}^{\length})
  }
\end{mathpar}

The base value of an enumeration is obtained from its first declared literal.
Accessing this literal is done via the \constantsvalues\ map in the
global component of the static environment:
\begin{mathpar}
  \inferrule[base\_value\_enum]{
    \tstruct(\vt) \eqname \TEnum(\id_{1..k})\\
    \env \eqname (\tenv, \denv)\\
    \tenv \eqname (G^\tenv, L^\tenv)\\
    G^\tenv.\constantsvalues(\id_1) = \vl
  }
  {
    \basevalue(\env, \vt) \evalarrow (\nvliteral{\vl}, \emptygraph)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[base\_value\_integer\_unconstrained]{
    \tstruct(\vt) \eqname \TInt(\unconstrained)
  }
  {
    \basevalue(\env, \vt) \evalarrow (\nvint(0), \emptygraph)
  }
  \and
  \inferrule[base\_value\_integer\_constraint\_exact]{
    \tstruct(\vt) \eqname \TInt(\wellconstrained([\constraintexact(\ve)] + \Ignore))\\
    \evalexprsef{\env, \ve} \evalarrow C
  }
  {
    \basevalue(\env, \vt) \evalarrow C
  }
  \and
  \and
  \inferrule[base\_value\_integer\_constraint\_range]{
    \tstruct(\vt) \eqname \TInt(\wellconstrained([\constraintrange(\ve, \Ignore)] + \Ignore))\\
    \evalexprsef{\env, \ve} \evalarrow C
  }
  {
    \basevalue(\env, \vt) \evalarrow C
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[base\_value\_record]{
    \tstruct(\vt) \eqname L([i=1..k: (\id_i, \vt_i)])\\
    L \in \{\TRecord, \TException\}\\
    i=1..k: \basevalue(\env, \vt_i) \evalarrow (\vv_i, \vg_i) \terminateas \ErrorConfig\\
    \vv = \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}}\\
    \vg = \vg_1 \parallel \ldots \parallel \vg_k
  }
  {
    \basevalue(\env, \vt) \evalarrow (\vv, \vg)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[base\_value\_tuple]{
    \tstruct(\vt) \eqname \TTuple([i=1..k: \vt_i])\\
    i=1..k: \basevalue(\env, \vt_i) \evalarrow (\vv_i, \vg_i) \terminateas \ErrorConfig\\
    \vv = \nvvector{\vv_{1..k}}\\
    \vg = \vg_1 \parallel \ldots \parallel \vg_k
  }
  {
    \basevalue(\env, \vt) \evalarrow (\vv, \vg)
  }
\end{mathpar}

\newcommand\isconstant[0]{\texttt{is\_contant}}
The predicate $\isconstant$ checks whether the expression $\ve$ is a variable
declared as a constant.
\begin{mathpar}
  \inferrule{
    \ve=\texttt{E\_Var}(\vx)\\
    \env \eqname (\tenv, \denv)\\
    \tenv \eqname (G^\tenv, L^\tenv)\\
    G^\tenv.\texttt{declared\_types}(\vx) \neq \bot
  }
  {
    \isconstant(\env, \ve)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[base\_value\_array\_length\_global\_constant]{
    \tstruct(\vt) \eqname \TArray(\elength, \vvty)\\
    \basevalue(\env, \vvty) \evalarrow (\velem, \vg) \terminateas \ErrorConfig\\
    \isconstant(\elength)\\
    \elength \eqname \texttt{E\_Var}(\vx)\\
    \env \eqname (\tenv, \denv)\\
    \tenv \eqname (G^\tenv, L^\tenv)\\
    G^\tenv.\texttt{constants\_values}(\vx) = \lint(n)\\
    \vv = \nvvector{i=1..n: \velem}
  }
  {
    \basevalue(\env, \vt) \evalarrow (\vv, \vg)
  }
  \and
  \inferrule[base\_value\_array\_length\_expression]{
    \tstruct(\vt) \eqname \TArray(\elength, \vvty)\\
    \basevalue(\env, \vvty) \evalarrow (\velem, \vgone) \terminateas \ErrorConfig\\
    \neg\isconstant(\elength)\\
    \evalexprsef{\env, \elength} \evalarrow (\vlength, \vgtwo) \terminateas \ErrorConfig\\
    \vlength \eqname \nvint(n)\\
    \vv = \nvvector{i=1..n: \velem}\\
    \vg = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \basevalue(\env, \vt) \evalarrow (\vv, \vg)
  }
\end{mathpar}

\section{Checking Whether a Value Matches a Type}
\subsection{Prose}
The relation
\[
  \isvaloftype(\overname{\envs}{\env} \aslsep \overname{\vals}{\vv} \aslsep \overname{\ty}{\vt}) \;\aslrel\;
  (\overname{\{\True,\False\}}{\vb} \times \overname{\XGraphs}{\vg}) \cup \overname{\TError}{\ErrorConfig}
\]
checks whether the value $\vv$ can be stored in a variable of type $\vt$ in the environment $\env$ and
one of the following applies:
\begin{itemize}
  \item Evaluation of all inner expressions in $\vt$ succeeds and the Boolean answer
  along with the execution graph generated by evaluating any inner expressions of $\vt$.
  \item Evaluation of an inner expression in $\vt$ fails and an error configuration is returned.
\end{itemize}
This relation is used in the context of a checked type conversion.

% \subsection{Code}
%   \VerbatimInput[firstline=\ValOfTypeBegin, lastline=\ValOfTypeEnd]{../Interpreter.ml}

  \subsection{Formally}
  \newcommand\tstructglobal[0]{\texttt{get\_global\_structure}}
  The helper relation
  \[
    \tstructglobal(\overname{\envs}{\env} \aslsep \overname{\ty}{\vt}) \;\aslrel\; \overname{\ty}{\vt'}
  \]
  obtains the structure of the type (see \secref{basevalue} for a description of type structuers)
  $\vt$ in a static environment obtained from $\env$ by substituting
  the local static environment with an empty one.
  \newcommand\Bool[1]{\textsf{Boolean}(#1)}
  In the following rules, we write $\Bool{p}$ to mean $\True$ when the condition $p$ holds and $\False$
  otherwise.

  \begin{mathpar}
    \inferrule{
      \env \eqname (\tenv, \Ignore)\\
      \tstruct((G^\tenv, \emptyfunc), \vt) = \vt'
    }
    {
      \tstructglobal(\env, \vt) \evalarrow \vt'
    }
  \end{mathpar}

\begin{mathpar}
  \inferrule[is\_val\_of\_type\_bool]{
    \tstructglobal(\env, \vt) \evalarrow \TBool\\
    \vb = \Bool{\vv \in \tbool}\\
    \vg = \emptygraph
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
  \and
  \inferrule[is\_val\_of\_type\_real]{
    \tstructglobal(\env, \vt) \evalarrow \TReal\\
    \vb = \Bool{\vv \in \treal}\\
    \vg = \emptygraph
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
  \and
  \inferrule[is\_val\_of\_type\_string]{
    \tstructglobal(\env, \vt) \evalarrow \TString\\
    \vb = \Bool{\vv \in \tstring}\\
    \vg = \emptygraph
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
  \and
  \inferrule[is\_val\_of\_type\_enum]{
    \tstructglobal(\env, \vt) \evalarrow \TEnum(\id_{0..k})\\
    \vb = \Bool{\exists j \in 1..k.\ \vv = \nvint(j)}\\
    \vg = \emptygraph
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[is\_val\_of\_type\_int\_unconstrained]{
    \tstructglobal(\env, \vt) \evalarrow \TInt(\unconstrained)\\
    \vb = \Bool{\vv \in \tint}\\
    \vg = \emptygraph
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

\newcommand\integerconstraintsatisfied[0]{\texttt{int\_constraint\_sat}}
To handle \emph{well-constrained integers} (integers with a non-empty list of constraints),
we introduce the helper relation
\[
  \integerconstraintsatisfied(\overname{\envs}{\env} \aslsep \overname{\intconstraint}{\vc} \aslsep \overname{\Z}{n}) \;\aslrel\;
  (\overname{\{\True,\False\}}{\vb} \times \overname{\XGraphs}{\vg})
\]
which checks whether the integer value $n$ \emph{meets the constraint} $\vc$
(that is, whether $n$ is within the range of values defined by $\vc$) in the environment $\env$
and returns a Boolean result $\vb$ and the execution graph $\vg$ resulting from evaluating
the expressions appearing in $\vc$:
\begin{mathpar}
\inferrule[Constraint\_Exact\_Sat]{
  \evalexprsef{\env, \ve} \evalarrow (\nvint(m), \vg) \terminateas \ErrorConfig\\
  \vb = \Bool{m = n}
}
{
  \integerconstraintsatisfied(\env, \constraintexact(\ve), n) \evalarrow (\vb, \vg)
}
\and
\inferrule[Constraint\_Range\_Sat]{
  \evalexprsef{\env, \veone} \evalarrow (\nvint(a), \vgone) \terminateas \ErrorConfig\\
  \evalexprsef{\env, \vetwo} \evalarrow (\nvint(b), \vgtwo) \terminateas \ErrorConfig\\
  \vb = \Bool{a \leq n \wedge n \leq b}\\
  \vg = \vgone \parallel \vgtwo
}
{
  \integerconstraintsatisfied(\env, \constraintrange(\veone, \vetwo), n) \evalarrow (\vb, \vg)
}
\end{mathpar}

Finally, we can check whether an integer value satisfies any of the constraints:
\begin{mathpar}
  \inferrule[is\_val\_of\_type\_int\_wellconstrained]{
    \tstructglobal(\env, \vt) \evalarrow \TInt(\wellconstrained(\vc_{1..k}))\\
    \vv = \nvint(n)\\
    i=1..k: \integerconstraintsatisfied(\env, \vc_i, n) \evalarrow (\vb_i, \vg_i) \terminateas \ErrorConfig\\
    \vb = \Bool{\bigvee_{i=1}^k \vb_i}\\
    \vg = \parallel_{i=1}^k \vg_i
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[is\_val\_of\_type\_record]{
    \tstructglobal(\env, \vt) \evalarrow \TRecord(i=1..k: \id_i\mapsto \vt_i)\\
    i=1..k: \getfield(\id_i, \vv) \evalarrow \vu_i\\
    i=1..k: \isvaloftype(\env, \vu_i, \vt_i) \evalarrow (\vb_i, \vg_i) \terminateas \ErrorConfig\\
    \vb = \Bool{ \bigwedge_{i=1}^k \vb_i }\\
    \vg = \parallel_{i=1}^k \vg_i
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[is\_val\_of\_type\_tuple]{
    \tstructglobal(\env, \vt) \evalarrow \TTuple(i=1..k: \vt_i)\\
    i=1..k: \getindex(i, \vv) \evalarrow \vu_i \terminateas \ErrorConfig\\
    i=1..k: \isvaloftype(\env, \vu_i, \vt_i) \evalarrow (\vb_i, \vg_i) \terminateas \ErrorConfig\\
    \vb = \Bool{ \bigwedge_{i=1}^k \vb_i }\\
    \vg = \parallel_{i=1}^k \vg_i
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[is\_val\_of\_type\_array]{
    \tstructglobal(\env, \vt) \evalarrow \TArray(\ve, \vt')\\
    \evalexprsef{\env, \ve} \evalarrow (\nvint(k), \vg) \terminateas \ErrorConfig\\
    i=1..k: \getindex(i, \vv) \evalarrow \vv_i\\
    i=1..k: \isvaloftype(\env, \vv_i, \vt') \evalarrow (\vb_i, \vg_i) \terminateas \ErrorConfig\\
    \vb = \Bool{ \bigwedge_{i=1}^k \vb_i }\\
    \vg = \parallel_{i=1}^k \vg_i
  }
  {
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vg)
  }
\end{mathpar}

Notice that these rules cover all types, including named types ($\TNamed$),
since $\tstructglobal$ replaces named types by their type definitions.
%
Underconstrained integers (integers with an empty set of constraints)
cannot appear as a type, since ASL syntax does not allow to:
\begin{itemize}
\item Declare an underconstrained integer as a variable,
\item Declare an alias to an underconstrained integer type, and
\item Declare an underconstrained integer in a compound type.
\end{itemize}

\section{Applying a Unary Operator \label{sec:UnaryOperator}}

The relation
\[
  \unop(\op \aslsep \vals) \;\aslrel\; \vals
\]
evaluates an operator over a native value and returns the resulting
native value.

\begin{mathpar}
  \inferrule[negate\_int]{}{
    \unop(\NEG, \nvint(n)) \evalarrow \nvint(- n)
  }
  \and
  \inferrule[negate\_real]{}{
    \unop(\NEG, \nvreal(z)) \evalarrow \nvint(- z)
  }
  \and
  \inferrule[not\_bool]{}{
    \unop(\BNOT, \nvbool(b)) \evalarrow \nvint(\neg b)
  }
  \and
  \inferrule[not\_bits]{
    c = \seq{b\in \bits: 1 - b}
  }{
    \unop(\NOT, \nvbitvector(\bits)) \evalarrow \nvbitvector(c)
  }
\end{mathpar}

\section{Applying a Binary Operator \label{sec:BinaryOperator}}

The relation
\[
  \binop(\op \aslsep \vals \aslsep \vals) \;\aslrel\; (\vals \cup \TError)
\]
evaluates an operator over a pair of native values and returns the resulting
native value or an error, if it is considered illegal to apply the operator
to the given values.

\newcommand\ErrorDivDenominatorNegative[0]{\texttt{"DivDenominatorNegative"}}
\subsection{Arithmetic Operators Over Integer Values \label{sec:AthimeticOverInt}}
\begin{mathpar}
  \inferrule[add\_int]{ n = a + b }{
    \binop(\PLUS, \nvint(a), \nvint(b)) \evalarrow \nvint(n)
  }
  \and
  \inferrule[sub\_int]{ n = a - b }{
    \binop(\MINUS, \nvint(a), \nvint(b)) \evalarrow \nvint(\texttt{n})
  }
  \and
  \inferrule[mul\_int]{ n = a \times b }{
    \binop(\MUL, \nvint(a), \nvint(b)) \evalarrow \nvint(\texttt{n})
  }
  \and
  \inferrule[div\_int]{  b > 0 \\
    n = a \div b \\
    n \in \Z}{
    \binop(\DIV, \nvint(a), \nvint(b)) \evalarrow \nvint(n)
  }
  \and
  \inferrule[div\_int\_error\_denominator\_negative]{  b \leq 0 }{
    \binop(\DIV, \nvint(a), \nvint(b)) \evalarrow \Error(\ErrorDivDenominatorNegative)
  }
  \and
  \inferrule[div\_int\_error\_indivisible]{  b > 0 \\
  n = a \div b \\
  n \not\in \Z
  }{
    \binop(\DIV, \nvint(a), \nvint(b)) \evalarrow \Error(\texttt{"/ indivisibility error!"})
  }
  \and
  \inferrule[fdiv\_int\_pos]{  b > 0 \\
  a \geq 0 \\
  n = \lfloor a \div b \rfloor
  }{ \binop(\DIVRM, \nvint(a), \nvint(b)) \evalarrow \nvint(n) }
  \and
  \inferrule[fdiv\_int\_neg]{  b > 0 \\
  a < 0 \\
  n = -(\lceil (-a) \div b \rceil)
  }{ \binop(\DIVRM, \nvint(a), \nvint(b)) \evalarrow \nvint(n) }
  \and
  \inferrule[fdiv\_int\_denominator\_negative]{  b \leq 0 }{ \binop(\DIVRM, \nvint(a), \nvint(b)) \evalarrow \Error(\texttt{"DIVRM denominator error!"}) }
  \and
  \inferrule[frem\_int\_pos]{  b > 0 \\
    \binop(\DIVRM, \nvint(a), \nvint(b)) \evalarrow c \\
    n = a - (b \times c)
  }{ \binop(\MOD, \nvint(a), \nvint(b)) \evalarrow \nvint(n) }
  \and
  \inferrule[frem\_int\_error\_denominator\_not\_positive]{  b \leq 0
  }{ \binop(\MOD, \nvint(a), \nvint(b)) \evalarrow \Error(\texttt{"MOD denominator error!"}) }
\end{mathpar}

\begin{mathpar}
  \inferrule[exp\_int]{  b \geq 0 \\ n = a^b
  }{ \binop(\POW, \nvint(a), \nvint(b)) \evalarrow \nvint(n)}
  \and
  \inferrule[exp\_int\_error]{  b < 0 \\ n = a^b
  }{ \binop(\POW, \nvint(a), \nvint(b)) \evalarrow \Error(\texttt{"POW exponent error!"}) }
  \and
  \inferrule[shiftleft\_int]{  \binop(\MUL, \nvint(a), \binop(\POW, \nvint(2), \nvint(b))) \evalarrow C
  }{ \binop(\SHL, \nvint(a), \nvint(b)) \evalarrow C}
  \and
  \inferrule[shift\_right]{  \binop(\DIVRM, \nvint(a), \binop(\POW, \nvint(2), \nvint(b))) \evalarrow C
  }{ \binop(\SHR, \nvint(a), \nvint(b)) \evalarrow C}
\end{mathpar}

\subsection{Relational Operators Over Integer Values \label{sec:RelationalOverInt}}
\begin{mathpar}
  \inferrule[eq\_real]{  c=\Bool{a = b} }{ \binop(\EQOP, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[ne\_real]{  c=\Bool{a = b} }{ \binop(\NEQ, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[le\_real]{  c=\Bool{a \leq b} }{ \binop(\LEQ, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[lt\_real]{  c=\Bool{a < b} }{ \binop(\LT, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[ge\_real]{  c=\Bool{a \geq b} }{ \binop(\GEQ, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[gt\_real]{  c=\Bool{a > b} }{ \binop(\GT, \nvint(a), \nvint(b)) \evalarrow \nvbool(c)}
\end{mathpar}

In the following definitions, we
employ the mathematical meaning of logical conjunction $\wedge$, logical disjunction $\vee$,
and logical negation $\neg$, over the Boolean values $\True$ and $\False$.

\subsection{Boolean Operators Over Boolean Values \label{sec:BooleanOverBoolean}}
\begin{mathpar}
\inferrule[and\_bool]{}{ \binop(\BAND, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(a \wedge b)}
\and
\inferrule[or\_bool]{}{ \binop(\BOR, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(a \vee b)}
\and
\inferrule[implies\_bool]{}{ \binop(\IMPL, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(\neg a \vee b)}
\and
\inferrule[eq\_bool]{
  c = \Bool{a = b}
}{ \binop(\EQOP, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(c)}
\and
\inferrule[ne\_bool]{
  c = \Bool{a \neq b}
}{ \binop(\NEQ, \nvbool(a), \nvbool(b)) \evalarrow \nvbool(c)}
\end{mathpar}

\subsection{Arithmetic Operators Over Real Values \label{sec:AthimeticOverReal}}
\begin{mathpar}
  \inferrule[add\_real]{}{\binop(\PLUS, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a+b)}
\and
\inferrule[sub\_real]{}{\binop(\MINUS, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a-b)}
\and
\inferrule[mul\_real]{}{\binop(\MUL, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a\times b)}
\and
\inferrule[div\_real]{b \neq 0}{\binop(\RDIV, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a\div b)}
\and
\inferrule[div\_real\_error]{b = 0}{\binop(\RDIV, \nvreal(a), \nvreal(b)) \evalarrow \Error(\texttt{"/ denominator is 0!})}
\and
\inferrule[exp\_real]{b \geq 0}{\binop(\POW, \nvreal(a), \nvreal(b)) \evalarrow \nvreal(a^b)}
\end{mathpar}

\subsection{Relational Operators Over Real Values \label{sec:RealtionalOverReal}}
\begin{mathpar}
  \inferrule[eq\_real]{  c=\Bool{a = b} }{ \binop(\EQOP, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[ne\_real]{  c=\Bool{a = b} }{ \binop(\NEQ, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[le\_real]{  c=\Bool{a \leq b} }{ \binop(\LEQ, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[lt\_real]{  c=\Bool{a < b} }{ \binop(\LT, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[ge\_real]{  c=\Bool{a \geq b} }{ \binop(\GEQ, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
  \and
  \inferrule[gt\_real]{  c=\Bool{a > b} }{ \binop(\GT, \nvreal(a), \nvreal(b)) \evalarrow \nvbool(c)}
\end{mathpar}

\subsection{Operators Over Bitvectors \label{sec:BitvectorOperations}}

\newcommand\bintounsigned[0]{\textsf{binary\_to\_unsigned}}
The function $\bintounsigned : \{0,1\}^+ \rightarrow \N$ converts a sequence of bits
into an unsigned integer:
\[
  \bintounsigned(a_{n..1}) \triangleq \sum_{i=1}^n 2^{a_i}
\]

\begin{mathpar}
  \inferrule[eq\_bits]{
    \vb = \Bool{\bigvee_{i=1}^k a_i = b_i}
  }
  {
    \binop(\EQOP, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbool(\vb)
  }
  \and
  \inferrule[ne\_bits]{
    \binop(\EQOP, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbool(\vb')\\
    \vb = \neg \vb'
  }
  {
    \binop(\NEQ, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbool(\vb)
  }
  \and
  \inferrule[or\_bits]{
    i=1..k: c_i = \max(a_i, b_i)
  }
  {
    \binop(\OR, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c_{1..k})
  }
  \and
  \inferrule[and\_bits]{
    i=1..k: c_i = \min(a_i, b_i)
  }
  {
    \binop(\AND, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c_{1..k})
  }
  \and
  \inferrule[xor\_bits]{
    {
      \textit{xor\_bits} = \lambda a,b\in\{0,1\}.\ \left\{
        \begin{array}{ll}
          0 & \text{ if } a = b\\
          1 & \text{ else}
        \end{array}
      \right.
    }\\
    i=1..k: c_i=\textit{xor\_bits}(a_i, b_i)
  }
  {
    \binop(\EOR, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c_{1..k})
  }
  \and
  \inferrule[add\_bits]{
    a = \bintounsigned(a_{1..k})\\
    b = \bintounsigned(b_{1..k})\\
    c = \text{two's complement little endian representation of } a + b
  }
  {
    \binop(\PLUS, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c)
  }
  \and
  \inferrule[sub\_bits]{
    a = \bintounsigned(a_{1..k})\\
    b = \bintounsigned(b_{1..k})\\
    c = \text{two's complement little endian representation of } a - b
  }
  {
    \binop(\MINUS, \nvbitvector(a_{1..k}), \nvbitvector(b_{1..k})) \evalarrow \nvbitvector(c)
  }
  \and
  \inferrule[add\_bits\_int]{
    a = \bintounsigned(a_{1..k})\\
    c = \text{two's complement little endian representation of } a + b
  }
  {
    \binop(\PLUS, \nvbitvector(a_{1..k}), \nvint(b)) \evalarrow \nvbitvector(c)
  }
  \and
  \inferrule[sub\_bits\_int]{
    a = \bintounsigned(a_{1..k})\\
    c = \text{two's complement little endian representation of } a - b
  }
  {
    \binop(\MINUS, \nvbitvector(a_{1..k}), \nvint(b)) \evalarrow \nvbitvector(c)
  }
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Expressions \label{chap:eval_expr}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The relation
\[
  \evalexpr{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
            \Normal((\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg}) \aslsep \overname{\envs}{\newenv}) \cup
            \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates the expression $\ve$ under environment $\env$.
When the evaluation terminates normally it returns a native value $\vv$, a concurrent execution graph $\vg$,
and a modified environment $\newenv$.
Otherwise, the evaluation terminates abnormally.

We start by defining the following helper relations:
\begin{itemize}
  \item SemanticsRule.EExprList (see Section~\ref{sec:SemanticsRule.EExprList});
  \item SemanticsRule.EExprListM (see Section~\ref{sec:SemanticsRule.EExprListM});
  \item SemanticsRule.ESideEffectFreeExpr (see Section~\ref{sec:SemanticsRule.ESideEffectFreeExpr});
\end{itemize}

The evaluation of an expression is specialized on the shape of the expression $\ve$,
and one of the following applies:
\begin{itemize}
\item SemanticsRule.Lit (see Section~\ref{sec:SemanticsRule.Lit});
\item SemanticsRule.ELocalVar (see Section~\ref{sec:SemanticsRule.ELocalVar})
\item SemanticsRule.EGlobalVar (see Section~\ref{sec:SemanticsRule.EGlobalVar})
\item SemanticsRule.BinopAnd (see Section~\ref{sec:SemanticsRule.BinopAnd})
\item SemanticsRule.BinopOr (see Section~\ref{sec:SemanticsRule.BinopOr})
\item SemanticsRule.BinopImpl (see Section~\ref{sec:SemanticsRule.BinopImpl})
\item SemanticsRule.Binop (see Section~\ref{sec:SemanticsRule.Binop})
\item SemanticsRule.Unop (see Section~\ref{sec:SemanticsRule.Unop})
\item SemanticsRule.ECond (see Section~\ref{sec:SemanticsRule.ECond})
\item SemanticsRule.ESlice (see Section~\ref{sec:SemanticsRule.ESlice})
\item SemanticsRule.ECall (see Section~\ref{sec:SemanticsRule.ECall})
\item SemanticsRule.EGetArray (see Section~\ref{sec:SemanticsRule.EGetArray})
\item SemanticsRule.ERecord (see Section~\ref{sec:SemanticsRule.ERecord})
\item SemanticsRule.EGetField (see Section~\ref{sec:SemanticsRule.EGetField})
\item SemanticsRule.EConcat (see Section~\ref{sec:SemanticsRule.EConcat})
\item SemanticsRule.ETuple (see Section~\ref{sec:SemanticsRule.ETuple})
\item SemanticsRule.EUnknown (see Section~\ref{sec:SemanticsRule.EUnknown})
\item SemanticsRule.EPattern (see Section~\ref{sec:SemanticsRule.EPattern})
\item SemanticsRule.CTC (see Section~\ref{sec:SemanticsRule.CTC})
\end{itemize}

\section{SemanticsRule.EExprList \label{sec:SemanticsRule.EExprList}}
The relation
\[
  \evalexprlist{\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vle}} \;\aslrel\;
  \Normal((\overname{\vals^*}{\vv} \times \overname{\XGraphs}{\vg})\aslsep \overname{\envs}{\newenv}) \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates the list of expressions $\vle$ in left-to-right order in the initial environment $\env$
and returns the resulting value $\vv$, the parallel composition of the execution graphs
generated from evaluating each expression, and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.
(Recall that $+$ stands for list concatenation):
\begin{mathpar}
  \inferrule[eval\_expr\_list\_empty]{}
  {
    \evalexprlist{\env, \emptylist} \evalarrow \Normal((\emptylist, \emptygraph), \env)
  }
\and
  \inferrule[eval\_expr\_list\_nonempty]{
    \texttt{le} \eqname [\ve] + \vle'\\
    \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \envp) \OrAbnormal\\
    \evalexprlist{\envp, \vle'} \evalarrow \Normal((\vvs, \vgtwo), \newenv) \OrAbnormal\\
    \vg = \vgone \parallel \vgtwo \\
    \vv = [\vvone] + \vvs
  }
  {
    \evalexprlist{\env, \vle} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}

\section{SemanticsRule.EExprListM \label{sec:SemanticsRule.EExprListM}}
The relation
\[
  \evalexprlistm{\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vle}} \;\aslrel\;
          \Normal(\overname{(\vals\times\XGraphs)^* }{\vms} \aslsep \envs) \cup
          \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates a list of expressions $\vle$ in left-to-right in the initial environment $\env$
and returns the list of values associated with graphs $\vms$ and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.
(Recall that $+$ stands for list concatenation):
\begin{mathpar}
  \inferrule[eval\_expr\_list\_m\_empty]{}
  {
    \evalexprlistm{\env, \emptylist} \evalarrow \Normal((\emptylist, \emptygraph), \env)
  }
\and
  \inferrule[eval\_expr\_list\_m\_nonempty]{
    \vle \eqname [\ve] + \vle'\\
    \vms \eqname [\vm] + \vms'\\
    \evalexpr{\env, \ve} \evalarrow \Normal(\vm, \envp) \OrAbnormal\\
    \evalexprlistm{\envp, \vle'} \evalarrow \Normal(\vms', \newenv) \OrAbnormal\\
  }
  {
    \evalexprlistm{\env, \vle} \evalarrow \Normal(\vms, \newenv)
  }
\end{mathpar}

\section{SemanticsRule.ESideEffectFreeExpr \label{sec:SemanticsRule.ESideEffectFreeExpr}}
The relation
\[
  \evalexprsef{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
  \Normal(\overname{\vals}{\vv}\aslsep\overname{\XGraphs}{\vg}) \cup
  \overname{\TError}{\ErrorConfig}
\]
specializes the expression evaluation relation for side-effect-free expressions:
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv,\vg), \env) \terminateas \ErrorConfig
  }
  {
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vv, \vg)
  }
\end{mathpar}
Notice that the output configuration does not contain an environment,
since side-effect-free expressions do not modify the environment.

\section{SemanticsRule.Lit \label{sec:SemanticsRule.Lit}}

  \subsection{Prose}
  Evaluation of a literal expression of a value $\vv$
  in environment \env\ is the configuration
  \texttt{\Normal(res,env,g)} and all of the following apply:
  \begin{itemize}
  \item $\vres$ is the native value corresponding to $\vv$;
  \item $\vg$ is the empty graph, as literal do not yield any Read and Write Effects.
  \end{itemize}

  \subsection{Example}
  In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Lit.asl}
  the expression \texttt{3} evaluates to the value \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\LitBegin, lastline=\LitEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{\vres = \nvliteral{\vv} \\ \vg = \emptygraph}
  { \evalexpr{\env, \texttt{E\_Literal}(\vv)} \evalarrow \Normal(\vres, \env, \vg) }
\end{mathpar}

\end{formal}

\isempty{\subsection{Comments}}


\section{SemanticsRule.ELocalVar \label{sec:SemanticsRule.ELocalVar}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a variable $\vx$ which is bound locally in $\env$;
    \item $\vres$ is a value $\vv$;
    \item $\vv$ is the value of $\vx$ in $\env$;
    \item $\newenv$ is $\env$.
    \item $\vg$ is the graph containing a single Read Effect for $\vx$.
  \end{itemize}

  \subsection{Example: SemanticsRuleELocalVar.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ELocalVar.asl}
    the evaluation of \texttt{x} within \texttt{assert x == 3;} uses SemanticsRule.ELocalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\ELocalVarBegin, lastline=\ELocalVarEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
  \begin{mathpar}
  \inferrule{\env \eqname (\tenv, \denv)\\
    \vx \in \dom(L^\denv)\\
    \vv = L^\denv(\vx) \\
    \vg = \ReadEffect(\vx)}
  {\evalexpr{\env, \evar(\vx)} \evalarrow \Normal((\vv, \vg), \env)}
  \end{mathpar}
\end{formal}

  \subsection{Comments}
  When there exists a global variable \texttt{x}, the type system
  forbids having \texttt{x} as a local variable.
  This is enforced by TypingRule.LDVar and TypingRule.DeclareOneFunc.

\section{SemanticsRule.EGlobalVar \label{sec:SemanticsRule.EGlobalVar}}

  \subsection{Prose}
  Let $\ve$ be an expression denoting a variable \vx.
  Evaluation of $\ve$ under environment $\env$ terminates normally with
  \texttt{((v,g),env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{x} which is bound globally in $\env$;
  \item $\vv$ is the native value of \texttt{x} in $\env$;
  \item $\vg$ is the graph containing a single Read Effect for \vx.
  \end{itemize}

  \subsection{Example: SemanticsRuleEGlobalVar.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGlobalVar.asl}
    the evaluation of~\texttt{global\_x} within~\texttt{assert global\_x == 3;}
    uses the rule SemanticsRule.EGlobalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\EGlobalVarBegin, lastline=\EGlobalVarEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \env \eqname (\tenv, \denv)\\
    \vx \in \dom(G^\denv)\\
    \vv = G^\denv(\vx) \\
    \vg = \ReadEffect(\vx)}
  {\evalexpr{\denv, \evar(\vx)} \evalarrow \Normal((\vv, \vg), \env)}
  \end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.BinopAnd \label{sec:SemanticsRule.BinopAnd}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a conjunction over two expressions \texttt{e1} and \texttt{e2};
  \item \texttt{(res,new\_env)} is the result of the evaluation of \texttt{if
e1 then e2 else false} (see Section~\ref{sec:SemanticsRule.ECond}).
  \end{itemize}
  \subsection{Example: SemanticsRule.EBinopAndFalse.asl}

 \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopAndFalse.asl}
    the expression \texttt{FALSE \&\& fail()} evaluates to the value \texttt{FALSE}. Notice that the function \texttt{fail} is never called.

  \subsection{Code}
  \VerbatimInput[firstline=\BinopAndBegin, lastline=\BinopAndEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \texttt{E\_Cond}(\texttt{e1}, \texttt{e2}, \efalse)} \evalarrow C
  }
  {
  \evalexpr{\env, \texttt{E\_Binop}(\BAND, \texttt{e1}, \texttt{e2})} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  This is related to \identr{BKNT}, \identr{XKGC} and \identi{QRXP}.

\section{SemanticsRule.BinopOr \label{sec:SemanticsRule.BinopOr}}
  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a disjunction over two expressions \texttt{e1} and \texttt{e2};
  \item \texttt{(res,new\_env)} is the result of the evaluation of \texttt{if
e1 then true else e2} (see Section~\ref{sec:SemanticsRule.ECond}).
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopOrTrue.asl}
\VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopOrTrue.asl}
  The expression \texttt{(0 == 1) || (1 == 1)} evaluates to the value \texttt{TRUE}.

  \subsection{Code}
  \VerbatimInput[firstline=\BinopOrBegin, lastline=\BinopOrEnd]{../Interpreter.ml}

\begin{emptyformal}
  \begin{mathpar}
    \inferrule{
      \evalexpr{\env, \texttt{E\_Cond}(\texttt{e1}, \etrue, \texttt{e2})} \evalarrow C
    }
    {
    \evalexpr{\env, \texttt{E\_Binop}(\BOR, \texttt{e1}, \texttt{e2})} \evalarrow C
    }
  \end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  This is related to \identr{BKNT}, \identr{XKGC} and \identi{QRXP}.

\section{SemanticsRule.BinopImpl \label{sec:SemanticsRule.BinopImpl}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item $\ve$ denotes an implication over two expressions \texttt{e1} and \texttt{e2};
  \item $\ve$ is evaluated as \texttt{if e1 then e2 else true}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopImplExFalso.asl}
\VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopImplExFalso.asl}
the expression \texttt{(0 == 1) --> (1 == 0)} evaluates to the value \texttt{TRUE}, according to the definition of implication.

  \subsection{Code}
  \VerbatimInput[firstline=\BinopImplBegin, lastline=\BinopImplEnd]{../Interpreter.ml}
\begin{emptyformal}
  \begin{mathpar}
    \inferrule{
      \evalexpr{\env, \texttt{E\_Cond}(\texttt{e1}, \texttt{e2}, \etrue)} \evalarrow C
    }
    {
    \evalexpr{\env, \texttt{E\_Binop}(\IMPL, \texttt{e1}, \texttt{e2})} \evalarrow C
    }
  \end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{BKNT}, and \identi{QRXP}.

\section{SemanticsRule.Binop \label{sec:SemanticsRule.Binop}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a Binary Operator \texttt{op} over two expressions \texttt{e1} and \texttt{e2};
    \item The evaluation of the expression \texttt{e1} under $\env$ is \texttt{v1};
    \item $\envp$ is the result of modifying $\env$ after evaluation of the expression \texttt{e1} under $\env$;
    \item The evaluation of the expression \texttt{e2} under $\env$ is \texttt{v2};
    \item $\newenv$ is the result of modifying $\envp$ after evaluation of the expression \texttt{e2} under $\envp$;
    \item $\vv$ is the result of applying the Binary Operator \texttt{op} to \texttt{v1} and \texttt{v2};
    \item $\vres$ is $\vv$;
    \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopPlusAssert.asl}
    In this specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopPlusAssert.asl}
    the expression \texttt{3 + 2} evaluates to the value \texttt{5}.

  \subsection{Example: \\ SemanticsRule.EDIVBackendDefinedError.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopDIVBackendDefinedError.asl}
    \begin{itemize}
    \item in ASLv0, the expression \texttt{3 DIV 0} results in a backend-defined
      error, e.g.
      \texttt{ASL Execution error: Illegal application of operator DIV for \\ values 3 and 0.}
    \item in ASLv1, the expression \texttt{3 DIV 0} results in a type error.
    \end{itemize}

  \subsection{Code}
  \VerbatimInput[firstline=\BinopBegin, lastline=\BinopEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \evalexpr{ \env, \veone} \evalarrow \Normal(\vmone, \envp) \OrAbnormal \\\\
      \evalexpr{ \envp, \vetwo } \evalarrow \Normal(\vmtwo, \newenv) \OrAbnormal \\\\
      \vmone \eqname (\vvone, \vgone) \\
      \vmtwo \eqname (\vvtwo, \vgtwo) \\
      \binop(\op, \vvone, \vvtwo) \evalarrow \vv \terminateas \ErrorConfig\\\\
      \vg = \vgone \parallel \vgtwo
    }
    {
      \evalexpr{ \env, \texttt{E\_Binop}(\op, \veone, \vetwo) } \evalarrow
      \Normal((\vv, \vg), \newenv)
    }
  \end{mathpar}
\end{formal}

\subsection{Comments}
  This is related to \identr{XKGC} and \identr{BKNT}.

Notice that when one of the sub-expressions terminates exceptionally,
the other expression must be side effect-free and non-throwing (\identi{QJTN}).

The semantics takes a semantic transition over the left sub-expression before the right sub-expression.
This is an arbitrary choice as the type-checker must ensure that either order of evaluation of the operands
yields the same result.

\section{SemanticsRule.Unop \label{sec:SemanticsRule.Unop}}
  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a Unary Operator \texttt{op} over an expression \texttt{e'} in an environment $\env$;
  \item The evaluation of the expression \texttt{e'} under $\env$ is \texttt{v',new\_env};
  \item \texttt{v, new\_env} is the result of applying the Unary Operator \texttt{op} to \texttt{v'}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EUnopAssert.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnopAssert.asl}
    the expression \texttt{NOT '1010'} evaluates to the value \texttt{'0101'}.

  \subsection{Code}
  \VerbatimInput[firstline=\UnopBegin, lastline=\UnopEnd]{../Interpreter.ml}

\begin{emptyformal}
\begin{mathpar}
  \inferrule{
    \evalexpr{ \env, \vep} \evalarrow \Normal((\vvp,\vg), \newenv)\\
    \unop(\op, \vvp) \evalarrow \vv
  }
  {
    \evalexpr{ \env, \texttt{E\_Unop}(\op, \vep) } \evalarrow
    \Normal((\vv, \vg), \newenv)
  }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ECond \label{sec:SemanticsRule.ECond}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a conditional expression \texttt{e\_cond} with two options \texttt{e1} and \texttt{e2};
    \item The evaluation of the conditional expression \texttt{e\_cond} under $\env$ is \texttt{m\_cond};
    \item The evaluation of \texttt{e1} or \texttt{e2}, depending on \texttt{m\_cond}, is $\vv$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ECondFalse.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECondFalse.asl}
    the expression \texttt{if FALSE then Return42() else 3} evaluates to the value \texttt{3}.

  \subsection{Example: \\ SemanticsRule.ECondUNKNOWN3or42.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECondUNKNOWN3or42.asl}
the expression \texttt{if UNKNOWN: boolean then 3 else Return42()} will
evaluate either \texttt{3} or \texttt{Return42()} depending on how
\texttt{UNKNOWN} is implemented.

  \subsection{Code}
  \VerbatimInput[firstline=\ECondBegin, lastline=\ECondEnd]{../Interpreter.ml}

\begin{emptyformal}
\begin{mathpar}
  \inferrule[(Condition True)]{
    \evalexpr{\env, \texttt{e\_cond}} \evalarrow \Normal(\mcond, \envp) \OrAbnormal\\
    \mcond \eqname (\nvbool(\True), \vgone)\\
    \evalexpr{\envp, \veone} \evalarrow \Normal((\vv, \vgtwo), \newenv)  \OrAbnormal\\
    \vg = \ordered{\vgone}{\aslctrl}{\vgtwo}
  }
  {
    \evalexpr{\env, \texttt{E\_Cond}(\texttt{e\_cond}, \veone, \vetwo)} \evalarrow
    \Normal((\vv, \vg), \newenv)
  }
\and
\inferrule[(Condition False)]{
  \evalexpr{\env, \texttt{e\_cond}} \evalarrow \Normal(\mcond, \envp) \OrAbnormal\\
  \mcond \eqname (\nvbool(\False), \vgone)\\
  \evalexpr{\envp, \vetwo} \evalarrow \Normal((\vv, \vgtwo), \newenv)  \OrAbnormal\\
  \vg = \ordered{\vgone}{\aslctrl}{\vgtwo}
}
{
  \evalexpr{\env, \texttt{E\_Cond}(\texttt{e\_cond}, \veone, \vetwo)} \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  This is related to \identr{YCDB}.

\section{SemanticsRule.ESlice \label{sec:SemanticsRule.ESlice}}
  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
    \item $\ve$ denotes an expression \texttt{e\_bv} sliced as per \texttt{slices};
    \item The evaluation of \texttt{e\_bv} under $\env$ is \texttt{v\_bv};
    \item The evaluation of \texttt{slices} under $\env$ is \texttt{positions};
    \item $\vv$ is the value read in \texttt{v\_bv} from \texttt{positions}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ESlice.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ESlice.asl}
    the expression \texttt{'11110000'[5:2]} evaluates to the value \texttt{'1100'}.

  \subsection{Code}
  \VerbatimInput[firstline=\ESliceBegin, lastline=\ESliceEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ebv} \evalarrow \Normal(\mbv, \envone)  \OrAbnormal\\
    \mbv \eqname (\vbv,\vgone) \\
    \evalslices{\envone, \slices} \evalarrow \Normal(\mpositions, \envp)  \OrAbnormal \\
    \mpositions \eqname (\positions, \vgtwo) \\
    \readfrombitvector(\vbv, \positions) \evalarrow \vv \terminateas \ErrorConfig\\
    \newenv = \envp \\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \evalexpr{\env, \texttt{E\_Slice}(\ebv, \slices)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ECall \label{sec:SemanticsRule.ECall}}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
    \item $\ve$ denotes a subprogram call \texttt{(name, params, actual\_args)};
    \item The evaluation of that subprogram call under $\env$ is \texttt{ms};
    \item $\vres$ is a value $\vv$;
    \item $\vv$ is the value read from \texttt{ms};
    \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ECall.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECall.asl}
    the expression \texttt{Return42()} evaluates to the value \texttt{42} because the
    subprogram \texttt{Return42()} is implemented to return the value \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\ECallBegin, lastline=\ECallEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule[(Single returned value)]{
    \evalcall{\env, \name, \actualargs, \params} \evalarrow \Normal(\vms, \newenv)  \OrAbnormal\\
    \vms \eqname [(\vv, \vg)]
  }
  {
    \evalexpr{\env, \texttt{E\_Call}(\name, \actualargs, \params)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\and
\inferrule[(Multiple returned values)]{
  \evalcall{\env, \name, \actualargs, \params} \evalarrow \Normal(\vms, \newenv)  \OrAbnormal\\
  \vms \eqname [i=1..k: (\vv_i, \vg_i)]\\
  \vg = \vg_1 \parallel \ldots \parallel \vg_k \\
  \vv = \nvvector{\vv_{1..k}}
}
{
  \evalexpr{\env, \texttt{E\_Call}(\name, \actualargs, \params)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EGetArray \label{sec:SemanticsRule.EGetArray}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  such that all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes an array \texttt{e\_array} and an index \texttt{e\_index};
  \item The evaluation of \texttt{e\_array} under $\env$ is \texttt{v\_array};
  \item The evaluation of \texttt{e\_index} under $\env$ is \texttt{v\_index};
  \item One of the following applies:
        \begin{itemize}
        \item All of the following apply:
          \begin{itemize}
          \item the result of evaluation of $\ve$ under $\env$ is \texttt{(res, env)};
          \item $\vres$ is a value $\vv$;
          \item $\vv$ is the value found at the index \texttt{v\_index} of \texttt{v\_array};
          \item $\newenv$ is $\env$;
          \end{itemize}

        \item $\vres$ is a typing error.
        \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.EGetArray.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGetArray.asl}
    the expression \texttt{my\_array[2]} evaluates to the value \texttt{42} since the element
    indexed by \texttt{2} in \texttt{my\_array} is \texttt{42}.

  \subsection{Example: SemanticsRule.EGetArrayTooSmall.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGetArrayTooSmall.asl}
    results in a typing error since we are trying to access index \texttt{3} of an array
    which has indexes \texttt{0}, \texttt{1} and \texttt{2} only.

  \subsection{Code}
  \VerbatimInput[firstline=\EGetArrayBegin, lastline=\EGetArrayEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \evalexpr{\env, \earray} \evalarrow \Normal(\marray, \envone)  \OrAbnormal\\
      \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \newenv)  \OrAbnormal\\
      \marray \eqname (\varray, \vgone)\\
      \mindex \eqname (\vindex, \vgtwo)\\
      \vindex \eqname \nvint(\vi)\\
      \getindex(\vi, \varray) \evalarrow \vv\\
      \vg = \vgone \parallel \vgtwo\\
    }
    {
      \evalexpr{\env, \texttt{E\_GetArray}(\earray, \eindex)} \evalarrow \Normal((\vv, \vg), \newenv)
    }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ERecord \label{sec:SemanticsRule.ERecord}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a record value \texttt{names} and associated expressions
    \texttt{fields};
  \item \texttt{fields} evaluates in $\env$ to \texttt{v\_fields};
  \item $\vres$ is a value $\vv$;
  \item $\vv$ is the record built by associating the names \texttt{names} to \texttt{v\_fields}.
  \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ERecord.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ERecord.asl}
    the expression \texttt{MyRecordType { a=3, b=42 }} evaluates to the value \texttt{{a:
3, b: 42}}.

  \subsection{Code}
  \VerbatimInput[firstline=\ERecordBegin, lastline=\ERecordEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \efields \eqname [i=1..k: (\id_i, \ve_i)]\\
    \names = [i=1..k: \id_i] \\
    \fields = [i=1..k: \ve_i] \\
    \evalexprlist{\env, \fields} \evalarrow \Normal((\vvfields,\vg), \envp)  \OrAbnormal\\
    \vvfields = (i=1..k: \vv_i)\\
    \vv = \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}}\\
    \newenv = \envp
  }
  {
    \evalexpr{\env, \texttt{E\_Record}(\Ignore, \efields)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EGetField \label{sec:SemanticsRule.EGetField}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a field name \texttt{field\_name} in a record value \texttt{e\_vec};
  \item the evaluation of \texttt{e\_vec} in $\env$ is \texttt{v\_vec};
  \item $\vres$ is a value $\vv$;
  \item $\vv$ is the value mapped by \texttt{field\_name} in \texttt{v\_vec};
  \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ERecord.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ERecord.asl}
    the expression \texttt{my\_record.a} evaluates to the value \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\EGetFieldBegin, lastline=\EGetFieldEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \erecord} \evalarrow \Normal((\vrecord, \vg), \envp)  \OrAbnormal\\
    \getfield(\fieldname, \vrecord) = \vv\\
    \newenv = \envp
  }
  {
    \evalexpr{\env, \texttt{E\_GetField}(\erecord, \fieldname)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}


\isempty{\subsection{Comments}}

\section{SemanticsRule.EConcat \label{sec:SemanticsRule.EConcat}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a list of bitvector expressions \texttt{e\_list};
  \item the evaluation of \texttt{e\_list} in $\env$ is \texttt{v\_list};
  \item $\vres$ is a value $\vv$;
  \item $\vv$ is the concatenation of \texttt{v\_list};
  \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example: SemanticsRule.EConcat}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EConcat.asl}
    the expression \texttt{['10', '11']} evaluates to the value \texttt{'1011'}.

  \subsection{Code}
  \VerbatimInput[firstline=\EConcatBegin, lastline=\EConcatEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \envp)  \OrAbnormal\\
    \concatbitvectors(\vlist) = \vv\\
    \newenv = \envp
  }
  {
    \evalexpr{\env, \texttt{E\_Concat}(\elist)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{BRCM}.

\section{SemanticsRule.ETuple \label{sec:SemanticsRule.ETuple}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a list of expression \texttt{e\_list};
  \item the evaluation of \texttt{e\_list} in $\env$ is \texttt{v\_list};
  \item $\vres$ is a value $\vv$;
  \item $\vv$ is the tuple built from \texttt{v\_list};
  \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example: SemanticsRule.ETuple.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ETuple.asl}
    the expression \texttt{(3, Return42())} evaluates to the value \texttt{(3, 42)}.

  \subsection{Code}
  \VerbatimInput[firstline=\ETupleBegin, lastline=\ETupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \envp)  \OrAbnormal\\
    \vv = \nvvector{\vlist}\\
    \newenv = \envp
  }
  {
    \evalexpr{\env, \texttt{E\_Tuple}(\elist)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EUnknown \label{sec:SemanticsRule.EUnknown}}

  \paragraph{Domain of a Type}

  The domain of a type $\vt$ in an environment $\env=(\tenv,\denv)$,
  denoted by $\textsf{dyn-dom}(\tenv, \denv, \vt)$, is defined by the type system~\cite{ASLTypingReference}
  (TypingRule.Domain)
  as the set of values that $\vt$ may store. The reason that the dynamic environment is
  needed to determine the domain is due to subprogram parameters, which constrain integer parameters to
  a singleton value domain.

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ terminates normally with
  \texttt{(v,new\_env,g)} and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes the \texttt{UNKNOWN} expression annotated with type \texttt{t};
  \item $\vv$ is a value in the domain of \texttt{t};
  \item $\newenv$ is $\env$.
  \item $\vg$ is the empty execution graph.
  \end{itemize}

  \subsection{Example: SemanticsRule.EUnknownInteger3.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnknownInteger3.asl}
    the expression \texttt{[UNKNOWN : integer]} evaluates to an integer value.

  \subsection{Example: \\ SemanticsRule.EUnknownIntegerRange3-42-3.asl}

    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnknownIntegerRange3-42-3.asl}
    the expression \texttt{UNKNOWN : integer \{3, 42\}} evaluates to either the value
\texttt{3} or the value \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\EUnknownBegin, lastline=\EUnknownEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{\env \eqname (\tenv, \denv)\\
    \vv \in \textsf{dyn-dom}(\tenv, \env, \vt) \\
  \newenv = \env
  }
  {
    \evalexpr{\env, \texttt{E\_Unknown}} \evalarrow \Normal(\newenv, \vv, \emptygraph)
  }
\end{mathpar}
\end{formal}

\subsection{Comments}
  This is related to \identr{WLCH}.

\section{SemanticsRule.EPattern \label{sec:SemanticsRule.EPattern}}


  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a pattern \texttt{e,p};
  \item $\vres$ is a value $\vv$;
  \item $\vv$ is the boolean determining whether the evaluation of $\ve$ in $\env$ matches $\vp$;
  \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example: SemanticsRule.EPatternFALSE.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EPatternFALSE.asl}
    the expression \texttt{42 IN \{0..3, -4\}} evaluates to the value \texttt{FALSE}.

  \subsection{Example: SemanticsRule.EPatternTRUE.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EPatternTRUE.asl}
    the expression \texttt{42 IN \{0..3, 42\}} evaluates to \texttt{TRUE}.

  \subsection{Code}
  \VerbatimInput[firstline=\EPatternBegin, lastline=\EPatternEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \envp)  \OrAbnormal\\
    \evalpattern{\env, \vvone, \vp} \evalarrow \Normal(\vv, \vgtwo)\\
    \newenv = \envp\\
    \vg = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalexpr{\env, \texttt{E\_Pattern}(\ve, \vp)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CTC \label{sec:SemanticsRule.CTC}}

  \subsection{Prose}
  Evaluation of the expression $\ve$ under environment $\env$ is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{(e,\_t)} denotes an expression $\ve$ and a type \texttt{t};
  \item $\vv$ is the result of evaluating $\ve$ in $\env$;
  \item $\newenv$ is $\env$ modified after evaluating $\ve$ in $\env$;
  \item \texttt{b} is \texttt{true} or \texttt{false} depending on whether $\vv$ is of type \texttt{t} in $\env$;
  \item One of the following applies:
        \begin{itemize}
        \item All of the following apply:
              \begin{itemize}
              \item \texttt{b} is \texttt{true};
              \item $\vres$ is $\vv$;
              \item $\newenv$ is $\newenv$
              \end{itemize}
        \item All of the following apply:
              \begin{itemize}
              \item \texttt{b} is \texttt{false};
              \item a type conversion error is returned.
              \end{itemize}
        \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.CTCValue.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CTCValue.asl}

  \subsection{Example: SemanticsRule.CTCError.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CTCError.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\CTCBegin, lastline=\CTCEnd]
                {../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv)  \OrAbnormal\\
    \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vgtwo) \terminateas \ErrorConfig\\
    \vb \eqname \nvbool(\True)\\
    \vg = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalexpr{\env, \texttt{E\_CTC}(\ve, \vt)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\and
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \Ignore), \Ignore)\\
  \neg\isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \Ignore)\\
  \vb \eqname \nvbool(\False)
}
{
  \evalexpr{\env, \texttt{E\_CTC}(\ve, \vt)} \evalarrow \Error(\texttt{"Type mismatch!"})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WZVX}, \identi{VQLX}, \identr{YCPX}, \identi{TCST}, \identi{CGRH}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Left-Hand Side Expressions \label{chap:eval_lexpr}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The relation
\[
  \evallexpr{\overname{\envs}{\env} \aslsep \overname{\lexpr}{\vle} \aslsep (\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg})} \;\aslrel\;
    \Normal(\overname{\XGraphs}{\vgp},\overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates the left-hand-side expression \texttt{le} associated with a
value $\vv$ under an environment $\env$ is either $\newenv$
or an error is returned and one of the following applies:
\begin{itemize}
\item SemanticsRule.LEDiscard (see Section~\ref{sec:SemanticsRule.LEDiscard});
\item SemanticsRule.LELocalVar (see Section~\ref{sec:SemanticsRule.LELocalVar});
\item SemanticsRule.LEGlobalVar (see Section~\ref{sec:SemanticsRule.LEGlobalVar});
\item SemanticsRule.LESlice (see Section~\ref{sec:SemanticsRule.LESlice});
\item SemanticsRule.LESetArray (see Section~\ref{sec:SemanticsRule.LESetArray});
\item SemanticsRule.LESetField (see Section~\ref{sec:SemanticsRule.LESetField});
\item SemanticsRule.LEDestructuring (see Section~\ref{sec:SemanticsRule.LEDestructuring}).
\end{itemize}

\section{SemanticsRule.LEMultiAssign \label{sec:SemanticsRuleLEMultiAssign}}
The helper relation
\[
  \evalmultiassignment{\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vlelist} \aslsep \overname{(\vals \times \XGraphs)^*}{\vmlist}} \aslrel
  \Normal(\overname{\XGraphs}{\vg} \aslsep \overname{\envs}{\newenv}) \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
\]
evaluates multi-assignments.
That is, the simultaneous assignment of the list of value-execution graph pairs $\vmlist$
to the corresponding list of left-hand side expressions $\vlelist$ under the environment $\env$.
The result is either the execution graph $\vg$ and new environment $\newenv$ or an abnormal configuration.

\begin{mathpar}
  \inferrule{}
  {
    \evalmultiassignment{\env, \emptylist, \emptylist} \evalarrow \Normal(\emptygraph, \env)
  }
\and
\inferrule{
  \vlelist \eqname [\vle] + \vlelist'\\
  \vmlist \eqname [\vm] + \vmlist'\\
  \evallexpr{\env, \vle, \vm} \evalarrow \Normal(\envp, \vgone) \OrAbnormal\\
  \evalmultiassignment{\envp, \vlelist', \vmlist'} \evalarrow \Normal(\newenv, \vgtwo) \OrAbnormal\\
  \vg = \ordered{\vgone}{\aslpo}{\vgtwo}
}
{
  \evalmultiassignment{\env, \vlelist, \vmlist} \evalarrow \Normal(\vg, \newenv)
}

\end{mathpar}

\section{SemanticsRule.LEDiscard \label{sec:SemanticsRule.LEDiscard}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value $\vv$ under an environment $\env$ is $\newenv$ and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} can be discarded;
    \item $\newenv$ is $\env$.
    \end{itemize}

  \subsection{Example: SemanticsRule.LEDiscard.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEDiscard.asl}
  \texttt{- = 42;} does not affect the environment.

  \subsection{Code}
  \VerbatimInput[firstline=\LEDiscardBegin, lastline=\LEDiscardEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{\vgp=\vg}
    { \evallexpr{\env, \texttt{LE\_Discard}, (\vv, \vg)} \evalarrow \Normal(\vgp, \env) }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LELocalVar \label{sec:SemanticsRule.LELocalVar}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value $\vv$ under an environment $\env$ is $\newenv$ and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a variable \vx;
    \item \texttt{x} is locally bound in $\env$;
    \item $\newenv$ is $\env$ where \texttt{x} is bound to $\vv$.
    \end{itemize}

    \subsection{Example: SemanticsRule.LELocalVar.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LELocalVar.asl}
    the evaluation of the left-hand-side expression \texttt{x} within \texttt{x = 42;} uses SemanticsRule.LELocalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\LELocalVarBegin, lastline=\LELocalVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \env \eqname (\tenv, \denv)\\
      \vx \in \dom(L^\denv)\\
      \newenv = (\tenv, (G^\denv, L^\denv[\vx \mapsto \vv]))\\
      \vg' = \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
    }
    { \evallexpr{\env, \texttt{LE\_Var}(\vx), (\vv, \vg)} \evalarrow \Normal(\vg',\newenv) }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LEGlobalVar \label{sec:SemanticsRule.LEGlobalVar}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value $\vv$ under an environment $\env$ is $\newenv$ and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a variable \vx;
    \item \texttt{x} is globally bound in $\env$;
    \item $\newenv$ is $\env$ where \texttt{x} is bound to $\vv$.
    \end{itemize}

    \subsection{Example: SemanticsRule.LEGlobalVar.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEGlobalVar.asl}
    the evaluation of the left-hand-side expression \texttt{x} within \texttt{x = 42;} uses SemanticsRule.LEGlobalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\LEGlobalVarBegin, lastline=\LEGlobalVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \env \eqname (\tenv, \denv)\\
      \vx \in \dom(G^\denv)\\
      \newenv = (\tenv, (G^\denv[\vx \mapsto \vv], L^\denv))\\
      \vg' = \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
    }
    { \evallexpr{\env, \texttt{LE\_Var}(\vx), (\vv, \vg)} \evalarrow \Normal(\vg',\newenv) }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LESlice \label{sec:SemanticsRule.LESlice}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value $\vv$ under an environment $\env$ is $\newenv$ and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a left-hand-side expression sliced as per \texttt{slices};
    \item The right-hand-side expression corresponding to \texttt{le} is \texttt{re\_bv};
    \item The evaluation of \texttt{re\_bv} under $\env$ is \texttt{rv\_bv};
    \item The evaluation of \texttt{slices} under $\env$ is \texttt{positions};
    \item \texttt{new\_m\_bv} is \texttt{rv\_bv} where the positions \texttt{positions} have been updated to $\vv$;
    \item $\newenv$ is $\env$ where \texttt{le} is bound to \texttt{new\_m\_bv}.
    \end{itemize}

   \subsection{Example: SemanticsRule.LESlice.asl}
   In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESlice.asl}
   \texttt{x[3:0] = '0000'} binds \texttt{x} to \texttt{'11110000'} in the environment where \texttt{x} is bound to \texttt{'11111111'}.

  \subsection{Code}
  \VerbatimInput[firstline=\LESliceBegin, lastline=\LESliceEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \vm \eqname (\vv, \vg)\\
      \evalexpr{\env, \torexpr(\ebv)} \evalarrow \Normal(\mbv,\envone) \OrAbnormal\\
      \evalslices{\envone, \slices} \evalarrow \Normal(\mpositions, \envtwo) \OrAbnormal\\
      \mpositions \eqname (\vgone, \positions)\\
      \vbv \eqname (\mbv, \vgtwo)\\\\
      \writetobitvector(\positions, \vv, \vbv) \evalarrow \vv' \terminateas \Error\\
      \vg' = \vg \parallel \vgone \parallel \vgtwo\\
      \evallexpr{\env, \texttt{LE\_Slice}(\ebv, \slices), (\vv', \vg')} \evalarrow C
    }
    { \evallexpr{\envtwo, \texttt{LE\_Slice}(\ebv), \vm} \evalarrow C }
  \end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WHRS}.

\section{SemanticsRule.LESetArray \label{sec:SemanticsRule.LESetArray}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value $\vv$ under an environment $\env$ is $\newenv$ and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes an array \texttt{le\_array} and an index \texttt{e\_index};
    \item The right-hand-side expression corresponding to \texttt{le\_array} is \texttt{re\_array};
    \item The evaluation of \texttt{re\_array} under $\env$ is \texttt{rv\_array};
    \item The evaluation of \texttt{e\_index} under $\env$ is \texttt{v\_index};
    \item \texttt{new\_v\_array} is \texttt{rv\_array} where the value at index \texttt{v\_index} has been
      updated to $\vv$;
    \item $\newenv$ is $\env$ where \texttt{le\_array} is bound to
      \texttt{new\_v\_array}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LESetArray.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESetArray.asl}
    binds the third element of \texttt{my\_array} to the value \texttt{53}.

  \subsection{Code}
  \VerbatimInput[firstline=\LESetArrayBegin, lastline=\LESetArrayEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm \eqname (\vv, \vg)\\
    \evalexpr{\env, \torexpr(\rearray)} \evalarrow \Normal(\rmarray, \envone) \OrAbnormal\\
    \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \envtwo) \OrAbnormal\\
    \mindex \eqname (\vindex, \vgone)\\
    \vindex \eqname \nvint(\vi)\\
    \rmarray \eqname (\rvarray, \vgtwo)\\
    \setindex(\vi, \vv, \rvarray) \evalarrow \vv'\\
    \vm' \eqname (\vv', \vgone \parallel \vgtwo)\\
    \evallexpr{\envtwo, \rearray, \vm'} \evalarrow C
  }
  { \evallexpr{\env, \texttt{LE\_SetArray}(\rearray, \eindex), \vm} \evalarrow C }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WHRS}.


\section{SemanticsRule.LESetField \label{sec:SemanticsRule.LESetField}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value $\vv$ under an environment $\env$ is $\newenv$ and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a field name \texttt{field\_name} in a record \texttt{le\_record};
    \item The right-hand-side expression corresponding to \texttt{le\_record} is
      \texttt{re\_record};
    \item The evaluation of \texttt{re\_record} under $\env$ is \texttt{rv\_record};
    \item \texttt{new\_v\_record} is \texttt{rv\_record} where the field \texttt{field\_name} has been
      updated to $\vv$;
    \item $\newenv$ is $\env$ where \texttt{le\_record} is bound to
      \texttt{new\_v\_record}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LESetField.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESetField.asl}
    \texttt{my\_record.a = 42;} binds \texttt{my\_record} to \texttt{\{a: 42, b: 42\}} in the environment where \texttt{my\_record} is bound to \texttt{\{a: 3, b: 42\}}.

  \subsection{Code}
  \VerbatimInput[firstline=\LESetFieldBegin, lastline=\LESetFieldEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm \eqname (\vv, \vg)\\
    \evalexpr{\env, \torexpr(\rerecord)} \evalarrow \Normal(\rmrecord, \envone) \OrAbnormal\\
    \rmrecord \eqname (\rvrecord, \vgone)\\
    \setfield(\fieldname, \vv, \rvrecord) \evalarrow \vv'\\
    \vm' = (\vv', \vg \parallel \vgone)\\
    \evallexpr{\env1, \rerecord, \vm'} \evalarrow C
  }
  { \evallexpr{\env, \texttt{LE\_SetField}(\rerecord, \fieldname), \vm} \evalarrow C }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WHRS}.


\section{SemanticsRule.LEDestructuring \label{sec:SemanticsRule.LEDestructuring}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value $\vv$ under an environment $\env$ is $\newenv$ and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a list of left-hand-side expressions \texttt{le\_list};
    \item $\newenv$ is $\env$ where each left-hand-side expression in \texttt{le\_list} has
      been assigned the value at the corresponding index in $\vv$.
    \end{itemize}

    \subsection{Example: SemanticsRule.LEDestructuring.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEDestructuring.asl}
    \texttt{(x, y) = (3, 42)} binds \texttt{x} to \texttt{3} and \texttt{y} to \texttt{42} in the environment where \texttt{x} is bound to \texttt{42} and \texttt{y} is bound to \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\LEDestructuringBegin, lastline=\LEDestructuringEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm \eqname (\vv, \vg)\\
    \vlelist = [\vle_{1..k}]\\
    i=1..k: \getindex(i, \vv) \evalarrow \vv_i\\
    \nmonads = [i=1..k: (\vv_i, \vg)]\\
    \evalmultiassignment{\env, \vlelist, \nmonads} \evalarrow C
  }
  { \evallexpr{\env, \texttt{LE\_Destructuring}(\vlelist), \vm} \evalarrow C }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Slices \label{chap:eval_slices}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\texttt{eval\_slices env slices} is the list of pair \texttt{(start\_n, length\_n)} that
corresponds to the start (included) and the length of each slice in
\texttt{slices}.

We define evaluation of a list of slices in terms of the following rules,
which make use of the rules for evaluating a single slice, in the sequel of this chapter:
\begin{mathpar}
  \inferrule{}
  {
    \evalslices{\env, \emptylist} \evalarrow \Normal((\emptylist, \emptygraph), \env)
  }
  \and
  \inferrule{
    \evalslice{\env, \slice} \evalarrow \Normal((\range, \vgone), \envone) \OrAbnormal\\
    \evalslices{\envone, \slices} \evalarrow \Normal((\ranges, \vgtwo), \newenv) \OrAbnormal\\
  }
  {
    \evalslices{\env, \slice + \slices} \evalarrow \Normal([\range] + \ranges, \vgone \parallel \vgtwo), \newenv)
  }
\end{mathpar}

Evaluation of a single slice \texttt{s} under environment $\env$ is
\texttt{((start, length), new\_env)}, or an error, and one of the following applies:
\begin{itemize}
\item SemanticsRule.SliceSingle (see Section~\ref{sec:SemanticsRule.SliceSingle}),
\item SemanticsRule.SliceLength (see Section~\ref{sec:SemanticsRule.SliceLength}),
\item SemanticsRule.SliceRange (see Section~\ref{sec:SemanticsRule.SliceRange}),
\item SemanticsRule.SliceStar (see Section~\ref{sec:SemanticsRule.SliceStar}).
\end{itemize}

\section{SemanticsRule.SliceSingle \label{sec:SemanticsRule.SliceSingle}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all
of the following apply:
  \begin{itemize}
    \item \texttt{s} is the single expression $\ve$;
    \item \texttt{start} is the result of evaluation of the expression~$\ve$
      in the environment $\env$;
    \item $\newenv$ is the environment $\env$ modified after
      evaluation of the expression~$\ve$;
    \item \texttt{length} is the integer value 1.
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceSingle.asl}
  In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceSingle.asl}
  the slice \texttt{[2]} evaluates to \texttt{(2, 1)}, i.\,e.\ the slice of
  length 1 starting at index 2.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceSingleBegin, lastline=\SliceSingleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallexpr{\env, \ve} \evalarrow \Normal((\start, \vg), \newenv) \OrAbnormal\\
  }
  {
    \evalslice{\env, \texttt{Slice\_Single}(\ve)} \evalarrow \Normal(((\start, \nvint(1)), \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceLength \label{sec:SemanticsRule.SliceLength}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all of the following
apply:
  \begin{itemize}
    \item \texttt{s} is the slice which starts at expression~\texttt{e\_start} with length~\texttt{e\_length};
    \item \texttt{start} is the result of evaluation of the
      expression~\texttt{e\_start} in the environment $\env$;
    \item \texttt{env\_1} is the environment $\env$ modified after
      evaluation of the expression~\texttt{e\_start};
    \item \texttt{length} is the result of evaluation of the
      expression~\texttt{e\_length} in the environment \texttt{env\_1};
    \item $\newenv$ is the environment \texttt{env\_1} modified after
      evaluation of the expression~\texttt{e\_length}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceLength.asl}
  In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceLength.asl}
  \texttt{2+:3} evaluates to \texttt{(2, 3)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceLengthBegin, lastline=\SliceLengthEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallexpr{\env, \estart} \evalarrow \Normal(\mstart, \envone) \OrAbnormal\\
    \evallexpr{\envone, \elength} \evalarrow \Normal(\mlength, \newenv) \OrAbnormal\\
    \mstart \eqname (\vstart, \vgone)\\
    \mlength \eqname (\vlength, \vgtwo)\\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \evalslice{\env, \texttt{Slice\_Length}(\estart, \elength)} \evalarrow \\ \Normal(((\vstart, \vlength), \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceRange \label{sec:SemanticsRule.SliceRange}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all of the following apply:
  \begin{itemize}
    \item \texttt{s} is the slice range between the
      expressions~\texttt{e\_start} and~\texttt{e\_top};
    \item \texttt{v\_top} is the result of evaluation of the
      expression~\texttt{e\_top} in the environment $\env$;
    \item \texttt{env\_1} is the environment $\env$ modified after
      evaluation of the expression~\texttt{e\_top};
    \item \texttt{start} is the result of evaluation of the
      expression~\texttt{e\_start} in the environment \texttt{env\_1};
    \item $\newenv$ is the environment \texttt{env\_1} modified after
      evaluation of the expression~\texttt{e\_start};
    \item \texttt{length} is the integer value \texttt{(vtop - start) + 1};
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceRange.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceRange.asl}
  \texttt{4:2} evaluates to \texttt{(2, 3)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceRangeBegin, lastline=\SliceRangeEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallexpr{\env, \etop} \evalarrow \Normal(\mtop, \envone) \OrAbnormal\\
    \mtop \eqname (\vvtop, \vgone)\\
    \evallexpr{\envone, \estart} \evalarrow \Normal(\mstart, \newenv) \OrAbnormal\\
    \mstart \eqname (\vstart, \vgtwo)\\
    \binop(\PLUS, \nvint(1), \binop(\MINUS, \vvtop, \vstart)) \evalarrow \length\\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \evalslice{\env, \texttt{Slice\_Range}(\etop, \estart)} \evalarrow \\ \Normal(((\start, \length), \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceStar \label{sec:SemanticsRule.SliceStar}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all of the following
apply:
  \begin{itemize}
    \item \texttt{s} is the slice with factor given by the
      expression~\texttt{e\_factor} and length given by the
      expression~\texttt{e\_length};
    \item \texttt{v\_factor} is the result of evaluation of the
      expression~\texttt{e\_factor} in the environment $\env$;
    \item \texttt{env\_1} is the environment $\env$ modified after
      evaluation of the expression~\texttt{e\_factor};
    \item \texttt{length} is the result of evaluation of the
      expression~\texttt{e\_length} in the environment \texttt{env\_1};
    \item $\newenv$ is the environment \texttt{env\_1} modified after
      evaluation of the expression~\texttt{e\_length};
    \item \texttt{start} is the integer value
      $\texttt{v\_factor} \times \texttt{length}$.
  \end{itemize}


  \subsection{Example: SemanticsRule.SliceStar.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceStar.asl}
  \texttt{x[2*:3]} evaluates to \texttt{(6, 2)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceStarBegin, lastline=\SliceStarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallexpr{\env, \efactor} \evalarrow \Normal(\mfactor, \envone) \OrAbnormal\\
    \mfactor = (\vfactor, \vgone)\\
    \evallexpr{\envone, \elength} \evalarrow \Normal(\mlength, \newenv) \OrAbnormal\\
    \mlength = (\vlength, \vgtwo)\\
    \binop(\texttt{"*"}, \vfactor, \vlength) \evalarrow \length \\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \evalslice{\env, \texttt{Slice\_Star}(\efactor, \elength)} \evalarrow \\ \Normal(((\start, \length), \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Patterns \label{chap:eval_pattern}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\texttt{eval\_pattern env pos v p} determines if $\vv$ matches the pattern $\vp$.

Evaluation of the pattern $\vp$ under environment $\env$ with
respect to value $\vv$ is \texttt{b}, or an error, and one of the
following applies:
\begin{itemize}
\item SemanticsRule.PAll (see Section~\ref{sec:SemanticsRule.PAll})
\item SemanticsRule.PAny (see Section~\ref{sec:SemanticsRule.PAny})
\item SemanticsRule.PGeq (see Section~\ref{sec:SemanticsRule.PGeq})
\item SemanticsRule.PLeq (see Section~\ref{sec:SemanticsRule.PLeq})
\item SemanticsRule.PNot (see Section~\ref{sec:SemanticsRule.PNot})
\item SemanticsRule.PRange (see Section~\ref{sec:SemanticsRule.PRange})
\item SemanticsRule.PSingle (see Section~\ref{sec:SemanticsRule.PSingle})
\item SemanticsRule.PMask (see Section~\ref{sec:SemanticsRule.PMask})
\item SemanticsRule.PTuple (see Section~\ref{sec:SemanticsRule.PTuple})
\end{itemize}

\section{SemanticsRule.PAll \label{sec:SemanticsRule.PAll}}

  \subsection{Prose}
  Evaluation of the pattern $\vp$ under environment $\env$ with
  respect to value $\vv$ is \texttt{b} and all of the following apply:
  \begin{itemize}
    \item $\vp$ is the pattern which matches everything, and therefore
      matches $\vv$;
    \item \texttt{b} is the boolean value \texttt{true}.
  \end{itemize}

  \subsection{Example: SemanticsRule.PAll.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAll.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PAllBegin, lastline=\PAllEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalpattern{\env, \Ignore, \texttt{Pattern\_All}} \evalarrow \Normal(\nvbool(\True), \emptygraph)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PAny \label{sec:SemanticsRule.PAny}}

    \subsection{Prose}
  Evaluation of the pattern $\vp$ under environment $\env$ with
  respect to value $\vv$ is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item $\vp$ is a list of patterns \texttt{ps};
      \item \texttt{bs} is the list resulting of the evaluation of the patterns in \texttt{ps} under environment $\env$ with respect to value $\vv$;
      \item \texttt{b} is the disjunction of the values in \texttt{bs}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PAnyTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAnyTRUE.asl}

    \subsection{Example: SemanticsRule.PAnyFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAnyFALSE.asl}

    \subsection{Code}
    \VerbatimInput[firstline=\PAnyBegin, lastline=\PAnyEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vps \eqname \vp_{1..k}\\
    i=1..k : \evalpattern{\env, \vv, \vp_i} \evalarrow \Normal(\nvbool(\vb_i), \vg_i) \terminateas \ErrorConfig\\
    \vv = \nvbool(\bigvee_{i=1..k} \vb_i)\\
    \vg = \vg_1 \parallel \ldots \parallel \vg_k
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Any}(\vps)} \evalarrow \Normal(\vv, \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PGeq \label{sec:SemanticsRule.PGeq}}

    \subsection{Prose}
    Evaluation of the pattern $\vp$ under environment $\env$ with
    respect to value $\vv$ is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item $\vp$ is the condition corresponding to being greater or equal
        than the side-effect-free expression $\ve$;
      \item \texttt{v'} is the side-effect-free evaluation of $\ve$ in
        $\env$;
      \item \texttt{b} is the boolean value corresponding to whether $\vv$
        is greater or equal to \texttt{v'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PGeqTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PGeqTRUE.asl}

    \subsection{Example: SemanticsRule.PGeqFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PGeqFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PGeqBegin, lastline=\PGeqEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vv', \vg) \terminateas \ErrorConfig
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Geq}(\ve)} \evalarrow \Normal(\binop(\GEQ, \vv, \vv'), \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PLeq \label{sec:SemanticsRule.PLeq}}

    \subsection{Prose}
    Evaluation of the pattern $\vp$ under environment $\env$ with
    respect to value $\vv$ is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item $\vp$ is the condition corresponding to being less or equal
        than the side-effect-free expression $\ve$;
      \item \texttt{v'} is the side-effect-free evaluation of $\ve$ in
        $\env$;
      \item \texttt{b} is the boolean value corresponding to whether $\vv$
        is less or equal to \texttt{v'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PLeqTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PLeqTRUE.asl}

    \subsection{Example: SemanticsRule.PLeqFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PLeqFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PLeqBegin, lastline=\PLeqEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vv', \vg) \terminateas \ErrorConfig
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Geq}(\ve)} \evalarrow \Normal(\binop(\LEQ, \vv, \vv'), \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PNot \label{sec:SemanticsRule.PNot}}

    \subsection{Prose}
    Evaluation of the pattern $\vp$ under environment $\env$ with
    respect to value $\vv$ is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item $\vp$ is the negation of the pattern \texttt{p'};
      \item \texttt{b'} is the result of the evaluation of the pattern
        \texttt{p'} under environment $\env$ with respect to the value
        $\vv$;
      \item \texttt{b} is the boolean negation of \texttt{b'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PNotTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PNotTRUE.asl}

    \subsection{Example: SemanticsRule.PNotFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PNotFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PNotBegin, lastline=\PNotEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vb, \vg) \terminateas \ErrorConfig\\
    \unop(\BNOT, \vb) \evalarrow \vb'
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Not}(\vp')} \evalarrow \Normal(\vb', \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PRange \label{sec:SemanticsRule.PRange}}

    \subsection{Prose}
  Evaluation of the pattern $\vp$ under environment $\env$ with
  respect to value $\vv$ is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item $\vp$ is the condition corresponding to being greater or equal
        to \texttt{e1}, and lesser or equal to \texttt{e2};
      \item \texttt{e1} and \texttt{e2} are side-effect-free expressions;
      \item \texttt{v1} is the side-effect-free evaluation of \texttt{e1} in
        $\env$;
      \item \texttt{v2} is the side-effect-free evaluation of \texttt{e2} in
        $\env$;
      \item \texttt{b1} is the boolean value corresponding to whether
        $\vv$ is greater or equal to \texttt{v1}.
      \item \texttt{b2} is the boolean value corresponding to whether
        $\vv$ is less or equal to \texttt{v2}.
      \item \texttt{b} is the boolean conjunction of \texttt{b1} and
        \texttt{b2}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PRangeTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PRangeTRUE.asl}

    \subsection{Example: SemanticsRule.PRangeFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PRangeFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PRangeBegin, lastline=\PRangeEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvone, \vgone) \terminateas \ErrorConfig\\
    \binop(\GEQ, \vv, \vvone) \evalarrow \vbone\\
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvtwo, \vgtwo) \terminateas \ErrorConfig\\
    \binop(\GEQ, \vv, \vvtwo) \evalarrow \vbtwo\\
    \binop(\BAND, \vbone, \vbtwo) \evalarrow \vb\\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Range}(\veone, \vetwo)} \evalarrow \Normal(\vb, \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PSingle \label{sec:SemanticsRule.PSingle}}

    \subsection{Prose}
  Evaluation of the pattern $\vp$ under environment $\env$ with
  respect to value $\vv$ is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item $\vp$ is the condition corresponding to being equal to the
        side-effect-free expression $\ve$;
      \item \texttt{v'} is the side-effect-free evaluation of $\ve$ in
        environment $\env$;
      \item \texttt{b} is the boolean value corresponding to whether $\vv$
        is equal to \texttt{v'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PSingleTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PSingleTRUE.asl}

    \subsection{Example: SemanticsRule.PSingleFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PSingleFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PSingleBegin, lastline=\PSingleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvp, \vg) \terminateas \ErrorConfig\\
    \binop(\EQOP, \vv, \vvp) \evalarrow \vb
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Single}(\ve)} \evalarrow \Normal(\vb, \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PMask \label{sec:SemanticsRule.PMask}}

    \subsection{Prose}
    Evaluation of the pattern $\vp$ under environment $\env$ with
    respect to value $\vv$ is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item $\vp$ is a mask \texttt{m} of length $n$ (with spaces removed);
      \item \texttt{m\_set} is the bitvector value of length $n$ with bit set
        at index $i$ if the mask requires a bit set at index $i$, i.\,e.\
        $\texttt{m}[i] = '1'$;
      \item \texttt{m\_unset} is the bitvector value of length $n$ with bit set
        at index $i$ if the mask requires a bit unset at index $i$, i.\,e.\
        $\texttt{m}[i] = '0'$;
      \item \texttt{m\_specified} is the bitwise disjunction of \texttt{m\_set}
        and \texttt{m\_unset};
      \item \texttt{nv} is the bitwise negation of $\vv$;
      \item \texttt{v\_set} is the bitwise conjunction of \texttt{m\_set} and
        $\vv$;
      \item \texttt{v\_unset} is the bitwise conjunction of \texttt{m\_unset} and
        \texttt{nv};
      \item \texttt{v\_set\_or\_unset} is the bitwise disjunction of
        \texttt{v\_set} and \texttt{v\_unset};
      \item \texttt{b} is the boolean value of the bitwise equality of
        \texttt{v\_set\_or\_unset} and \texttt{m\_specified}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PMaskTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PMaskTRUE.asl}

    \subsection{Example: SemanticsRule.PMaskFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PMaskFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PMaskBegin, lastline=\PMaskEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \newcommand\maskmatch[0]{\text{mask\_match}}
  The helper function $\maskmatch : \{0, 1, \vx\} \times \{0,1\} \rightarrow \{\True,\False\}$,
  which checks whether a bit value (second operand) matches a mask value (first operand),
  is defined by the following table:
\[
  \begin{array}{|c|c|c|c|}
    \hline
    \textbf{\maskmatch} & 0 & 1 & \vx\\
    \hline
    0 & \True & \False & \True\\
    \hline
    1 & \False & \True & \True\\
    \hline
  \end{array}
\]

\begin{mathpar}
  \inferrule{
    \vm \eqname \vm_{1..k}\\
    \vv \eqname \vv_{1..k}\\
    \vv = \nvbool(\bigwedge_{i=1..k} \maskmatch(\vm_i, \vv_i))
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Mask}(\vm)} \evalarrow \Normal(\vv, \emptygraph)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PTuple \label{sec:SemanticsRule.PTuple}}

    \subsection{Prose}
    Evaluation of the pattern $\vp$ under environment $\env$ with
    respect to value $\vv$ is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item $\vp$ gives a list of patterns \texttt{ps} of length $n$;
      \item $\vv$ gives a tuple of values \texttt{vs} of length $n$;
      \item for all $1 \leq i \leq n$, $\texttt{b}_i$ is the evaluation result
        of $\texttt{p}_i$ with respect to the value $\texttt{v}_i$ in
        environment $\env$;
      \item \texttt{bs} is the list of all $\texttt{b}_i$ for $1 \leq i \leq n$;
      \item \texttt{b} is the conjunction of the boolean values of \texttt{bs}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PTupleTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PTupleTRUE.asl}

    \subsection{Example: SemanticsRule.PTupleFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PTupleFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PTupleBegin, lastline=\PTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vps = \vp_{1..k}\\
    i=1..k: \getindex(i, \vv) \evalarrow \vvs_i\\
    i=1..k: \evalpattern{\env, \vvs_i, \vp_i} \evalarrow \Normal(\nvbool(\vbs_i), \vg_i) \terminateas \ErrorConfig\\
    \vres = \nvbool(\bigwedge_{i=1..k} \vbs_i)\\
    \vg = \vg_1 \parallel \ldots \parallel \vg_k
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Tuple}(\vps)} \evalarrow \Normal(\vres, \emptygraph)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Local Declarations \label{chap:eval_local_decl}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\texttt{eval\_local\_decl ldi env m\_init\_opt} declares local variables
\texttt{ldi} in $\env$ with an optional initialisation value
\texttt{m\_init\_opt}.  Evaluation of the local variables \texttt{ldi}
under an environment $\env$ is either $\newenv$ or returns an
error and one of the following applies:
\begin{itemize}
  \item SemanticsRule.LDDiscard (see Section~\ref{sec:SemanticsRule.LDDiscard}),
  \item SemanticsRule.LDVar (see Section~\ref{sec:SemanticsRule.LDVar}),
  \item SemanticsRule.LDTyped (see Section~\ref{sec:SemanticsRule.LDTyped}),
  \item SemanticsRule.LDTuple (see Section~\ref{sec:SemanticsRule.LDTuple}),
  \item SemanticsRule.LDUninitialisedTyped (see Section~\ref{sec:SemanticsRule.LDUninitialisedTyped}),
\end{itemize}

\section{SemanticsRule.LDDiscard \label{sec:SemanticsRule.LDDiscard}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
$\env$ is $\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} indicates that the initialisation value will be discarded;
    \item $\newenv$ is $\env$.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDDiscard.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDDiscard.asl}
    \texttt{var - : integer;} does not modify the environment.

  \subsection{Code}
  \VerbatimInput[firstline=\LDDiscardBegin, lastline=\LDDiscardEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evallocaldecl{\env, \texttt{LDI\_Discard}, \Ignore} \evalarrow \Normal(\emptygraph, \env)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDVar \label{sec:SemanticsRule.LDVar}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
$\env$ is $\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} is a variable \vx;
    \item \texttt{m\_init\_opt} is a value \texttt{m};
    \item $\newenv$ is $\env$ modified to declare \texttt{x} as a
local variable bound to value \texttt{m}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDVar0.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDVar0.asl}
    \texttt{var x = 3;} binds \texttt{x} to the evaluation of \texttt{3} in $\env$.

    \subsection{Example: SemanticsRule.LDVar1.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDVar1.asl}
    \texttt{var x : integer = 3;} binds \texttt{x} to the evaluation of
\texttt{3} in $\env$, without type consideration at runtime.

  \subsection{Code}
  \VerbatimInput[firstline=\LDVarBegin, lastline=\LDVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm \eqname (\vv, \vgone)\\
    \declarelocalidentifier(\env, \vx, \vv)\evalarrow(\newenv, \vgtwo)\\
    \vg = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evallocaldecl{\env, \texttt{LDI\_Var}(\vx), \langle \vm\rangle} \evalarrow \Normal(\vg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDTyped \label{sec:SemanticsRule.LDTyped}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
$\env$ is $\newenv$ and all of the following apply:
    \begin{itemize}
      \item \texttt{ldi} gives a local declaration item \texttt{ldi'} and a
        type \texttt{t};
        %
      \item \texttt{m\_init\_opt} is a value \texttt{m};
        %
      \item $\newenv$ is $\env$ modified after the evaluation of
        \texttt{ldi'} with the initialisation value \texttt{m} in $\env$.
        %
    \end{itemize}

    \subsection{Example: SemanticsRule.LDTyped.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDTyped.asl}
    \texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.

  \subsection{Code}
  \VerbatimInput[firstline=\LDTypedBegin, lastline=\LDTypedEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallocaldecl{\env, \ldi', \langle \vm\rangle} \evalarrow C
  }
  {
    \evallocaldecl{\env, \texttt{LDI\_Typed}(\ldi', \Ignore), \langle \vm\rangle} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDTuple \label{sec:SemanticsRule.LDTuple}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
$\env$ is $\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} gives a list of local variables \texttt{ldis};
    \item \texttt{m\_init\_opt} is a list of values \texttt{liv};
    \item $\newenv$ is $\env$ modified to declare each element of \texttt{ldis} to be bound
      to the corresponding value in \texttt{liv}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDTuple.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDTuple.asl}
    \texttt{var (x,y,z) = (1,2,3);} binds \texttt{x} to the evaluation of
\texttt{1}, \texttt{y} to the evaluation of \texttt{2}, and \texttt{z} to the
evaluation of \texttt{3}) in $\env$.

  \subsection{Code}
  \VerbatimInput[firstline=\LDTupleBegin, lastline=\LDTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
\newcommand\ldituplefolder[1]{\texttt{ldi\_tuple\_folder}(#1)}

  \subsection{Formally}
We first define the helper semantic relation
\[
    \ldituplefolder{\overname{\envs}{\env} \aslsep \overname{\localdeclitem^*}{\ldis} \aslsep \overname{(\vals \times \XGraphs)^*}{\liv}} \;\aslrel\;
     \Normal(\overname{\XGraphs}{\vg} \aslsep \overname{\envs}{\newenv})
\]
via the following rules:
\begin{mathpar}
  \inferrule{}
  {
    \ldituplefolder{\env, \emptylist, \emptylist} \evalarrow \Normal(\emptygraph, \env)
  }
\and
  \inferrule{
    \ldis \eqname [\ldi] + \ldis'\\
    \liv \eqname [\vm] + \liv'\\
    \vm \eqname (\vv, \vgone)\\
    \evallocaldecl{\env, \ldi, \langle\vm\rangle} \evalarrow \Normal(\vgone, \envone)\\
    \ldituplefolder{\envone, \ldis', \liv'} \evalarrow \Normal(\vgtwo, \newenv)\\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \ldituplefolder{\env, \ldis, \liv} \evalarrow \Normal(\vg, \newenv)
  }
\end{mathpar}

We now use the helper rules to define the rule for local declaration item tuples:
\begin{mathpar}
  \inferrule{
    \vm \eqname (\vv, \vg)\\
    \ldis \eqname \ldi_{1..k}\\
    i=1..k: \getindex(i, \vv) \evalarrow \vv_i\\
    \liv \eqname [i=1..k: (\vv_i, \vg)]\\
    \ldituplefolder{\env, \ldis, \liv} \evalarrow C
  }
  {
    \evallocaldecl{\env, \texttt{LDI\_Tuple}(\ldis), \langle \vm\rangle} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDUninitialisedTyped\label{sec:SemanticsRule.LDUninitialisedTyped}}

    \subsection{Prose}
    Evaluation of the local declaration item \texttt{ldi} under the environment
    $\env$ is $\newenv$ and all of the following apply:
    \begin{itemize}
      \item \texttt{ldi} gives a local declaration item \texttt{ldi'} and a
        type \texttt{t};
        %
      \item \texttt{m\_init\_opt} is \texttt{None};
        %
      \item \texttt{m} is the base value of \texttt{t} in $\env$;
        %
      \item $\newenv$ is $\env$ modified after the evaluation of
        \texttt{ldi'} with the initialisation value \texttt{m} in $\env$.
        %
    \end{itemize}

    \subsection{Example: SemanticsRule.LDUninitialisedTyped.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDUninitialisedTyped.asl}
    \texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.

  \subsection{Code}
  \VerbatimInput[firstline=\LDUninitialisedTypedBegin, lastline=\LDUninitialisedTypedEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \basevalue(\env, \vt) \evalarrow \vm \terminateas \ErrorConfig\\
    \evallocaldecl{\env, \ldi', \langle \vm \rangle} \evalarrow C
  }
  {
    \evallocaldecl{\env, \texttt{LDI\_Ttyped}(\ldi', \vt), \None} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Statements \label{chap:eval_stmt}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The semantic relation for statements is defined as follows:
\[
  \semantic{\texttt{stmt}} : \evalstmt{\envs \times \stmt} \times \left(
    \begin{array}{ll}
    \Continuing(\XGraphs, \envs) &\cup\\
    \Returning((\vals^* \times \XGraphs), \envs) &\cup\\
    \Throwing((\langle\vals \times \ty\rangle \times \XGraphs), \envs)&
    \end{array}
  \right) \enspace.
\]

Input configurations consist of an environment and a statement that should be evaluated in that environment.
Output configurations have one of three \emph{domain}: \emph{continuing domain} configurations, which signify
the flow of control should pass to the next statement in the current subprogram;
\emph{returning domain} configurations, which signify that the flow of control should resume with the caller
of the current subprogram with a list of returned values;
and \emph{throwing domain} configurations, which signify that an exception was raised, either without an exception value (as in \texttt{throw;}),
or with a given exception value and an associated exception type.

\begin{itemize}
\item SemanticsRule.SPass (see Section~\ref{sec:SemanticsRule.SPass}),
\item SemanticsRule.SAssign (see Section~\ref{sec:SemanticsRule.SAssign}),
\item SemanticsRule.SAssignCall (see Section~\ref{sec:SemanticsRule.SAssignCall}),
\item SemanticsRule.SAssignTuple (see Section~\ref{sec:SemanticsRule.SAssignTuple}),
\item SemanticsRule.SReturnNone (see Section~\ref{sec:SemanticsRule.SReturnNone}),
\item SemanticsRule.SReturnOne (see Section~\ref{sec:SemanticsRule.SReturnOne}),
\item SemanticsRule.SReturnSome (see Section~\ref{sec:SemanticsRule.SReturnSome}),
\item SemanticsRule.SSeq (see Section~\ref{sec:SemanticsRule.SSeq}),
\item SemanticsRule.SCall (see Section~\ref{sec:SemanticsRule.SCall}),
\item SemanticsRule.SCond (see Section~\ref{sec:SemanticsRule.SCond}),
\item SemanticsRule.SCase (see Section~\ref{sec:SemanticsRule.SCase}),
\item SemanticsRule.SAssert (see Section~\ref{sec:SemanticsRule.SAssert}),
\item SemanticsRule.SWhile (see Section~\ref{sec:SemanticsRule.SWhile}),
\item SemanticsRule.SRepeat (see Section~\ref{sec:SemanticsRule.SRepeat}),
\item SemanticsRule.SFor (see Section~\ref{sec:SemanticsRule.SFor}),
\item SemanticsRule.SThrowNone (see Section~\ref{sec:SemanticsRule.SThrowNone}),
\item SemanticsRule.SThrowSomeTyped (see Section~\ref{sec:SemanticsRule.SThrowSomeTyped}),
\item SemanticsRule.STry (see Section~\ref{sec:SemanticsRule.STry}),
\item SemanticsRule.SDeclSome (see Section~\ref{sec:SemanticsRule.SDeclSome}),
\item SemanticsRule.SDeclNone (see Section~\ref{sec:SemanticsRule.SDeclNone}).
\end{itemize}

\section{SemanticsRule.SPass \label{sec:SemanticsRule.SPass}}

  \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
  \begin{itemize}
  \item \texttt{s} is a \texttt{pass} statement;
  \item $\newenv$ is $\env$.
  \end{itemize}

  \subsection{Example: SemanticsRule.SPass.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SPass.asl}
  \texttt{pass;} does nothing.

  \subsection{Code}
  \VerbatimInput[firstline=\SPassBegin, lastline=\SPassEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  { \evalstmt{\env, \texttt{S\_Pass}} \evalarrow \Continuing(\emptygraph, \env) }
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssign \label{sec:SemanticsRule.SAssign}}

  \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
  \begin{itemize}
  \item \texttt{s} is an assignment \texttt{le = re};
  \item $\vv$ is the evaluation of the expression \texttt{re} under $\env$ as per Chapter~\ref{chap:eval_expr};
  \item \texttt{r\_env} is $\env$ modified after evaluation of the expression \texttt{re} under $\env$ as per Chapter~\ref{chap:eval_expr};
  \item $\newenv$ is \texttt{r\_env} modified after evaluation of \texttt{le} under \texttt{r\_env} with
    $\vv$, as per Chapter~\ref{chap:eval_lexpr}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SAssign.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssign.asl}
  \texttt{x = 3;} binds \texttt{x} to \texttt{3} in the environment where \texttt{x} is bound to \texttt{42}, and $\newenv$ is such that \texttt{x} is bound to \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\SAssignBegin, lastline=\SAssignEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \vre} \evalarrow \Normal((\vv, \vgone), \envp) \OrAbnormal\\
    \evallexpr{\envp, \vle, (\vv, \vgone)} \evalarrow \Normal(\vg, \newenv) \OrAbnormal
  }
  {
    \evalstmt{\env, \texttt{S\_Assign}(\vle, \vre)} \evalarrow \Continuing(\vg, \newenv)
  }
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssignCall \label{sec:SemanticsRule.SAssignCall}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
  \begin{itemize}
  \item \texttt{s} gives a left-hand-side tuple expression \texttt{les} and a subprogram call \texttt{(name, args, named\_args)};
  \item \texttt{vs} is the list of values resulting from the evaluation of the subprogram call;
  \item $\envp$ is the environment resulting from modifying $\env$ after the evaluation of the subprogram call;
  \item $\newenv$ is the result of modifying $\envp$ after assigning each values in \texttt{vs} to the elements of the tuple \texttt{les}.
  \end{itemize}

    \subsection{Example: SemanticsRule.SAssignCall.asl}

\VerbatimInput{\testdir/SemanticsRule.SAssignCall.asl}
  given that the function call \texttt{f(1)} returns the pair of values \texttt{(1,2)}, statement \texttt{(a,b) = f(1)} assigns the value \texttt{1} to the mutable variable \texttt{a} and the value \texttt{2} to the mutable variable~\texttt{b}.
  \subsection{Code}
  \VerbatimInput[firstline=\SAssignCallBegin, lastline=\SAssignCallEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
We first define the syntactic relation
\[
  \lexprisvar(\lexpr) \bigtimes \True
\]
which holds when a left-hand side expression
represents a variable.
\begin{mathpar}
  \inferrule{}{ \lexprisvar(\texttt{LE\_Var}(\Ignore)) \evalarrow \True}
  \and
  \inferrule{}{ \lexprisvar(\texttt{LE\_Discard}) \evalarrow \True}
\end{mathpar}

We now define the evaluation of assigning from a subprogram call:
\begin{mathpar}
  \inferrule{
    \vles = \vle_{1..k}\\
    i=1..k: \lexprisvar(\vle_i) \evalarrow \True\\
    \evalcall{\env, \name, \args, \namedargs} \evalarrow \Normal((\vvs, \vgone), \envp) \OrAbnormal\\
    \evalmultiassignment{\envp, \vles, \vvs} \evalarrow \Normal(\vgtwo, \newenv) \OrAbnormal\\
    \vg = \ordered{\vgone}{\aslpo}{\vgtwo}
  }
  {
    \evalstmt{\env, \texttt{S\_Assign}(\texttt{LE\_Destructuring}(\les),\texttt{E\_Call}(\name, \args, \namedargs))} \\
    \evalarrow \Continuing(\vg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssignTuple \label{sec:SemanticsRule.SAssignTuple}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
  \begin{itemize}
  \item \texttt{s} gives a left-hand-side tuple expression \texttt{les} and a tuple expression \texttt{exprs};
  \item \texttt{vs} is the list of values resulting from the evaluation of \texttt{exprs};
  \item $\envp$ is the environment resulting from modifying $\env$ after the evaluation of \texttt{exprs};
  \item $\newenv$ is the result of modifying $\envp$ after assigning each values in \texttt{vs} to the elements of the tuple \texttt{les}.
  \end{itemize}

    \subsection{Example: SemanticsRule.SAssignTuple.asl}
\VerbatimInput{\testdir/SemanticsRule.SAssignTuple.asl}
statement \texttt{(b,x)} assigns the value \texttt{TRUE} to the mutable variable \texttt{b} and the value~\texttt{42} to the mutable variable~\vx.

  \subsection{Code}
  \VerbatimInput[firstline=\SAssignTupleBegin, lastline=\SAssignTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vles = [\vle_{1..k}]\\
    i=1..k: \lexprisvar(\vle_i) \evalarrow \True\\
    \evalexprlistm{\env, \exprs} \evalarrow \Normal(\vms, \envp) \OrAbnormal\\
    \evalmultiassignment{\envp, \les, \vms} \evalarrow \Normal(\vg, \newenv) \OrAbnormal
  }
  {
    \evalstmt{\env, \texttt{S\_Assign}(\texttt{LE\_Destructuring}(\vles), \texttt{E\_Tuple}(\exprs))} \\
    \evalarrow \Continuing(\vg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnNone \label{sec:SemanticsRule.SReturnNone}}

    \subsection{Prose}
Evaluation of the statement \texttt{s} under environment $\env$ is
\texttt{Returning vs} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{return} statement;
    \item \texttt{vs} is \texttt{[]};
    \item $\newenv$ is $\env$.
    \end{itemize}

    \subsection{Example: SReturnNoneReturn.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnNone.asl}
    exits the current procedure.

  \subsection{Code}
  \VerbatimInput[firstline=\SReturnNoneBegin, lastline=\SReturnNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalstmt{\env, \texttt{S\_Return}(\None)} \evalarrow \Returning((\emptylist, \emptygraph), \env)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnOne \label{sec:SemanticsRule.SReturnOne}}

    \subsection{Prose}
Evaluation of the statement \texttt{s} under environment $\env$ is
\texttt{Returning vs} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{return} statement;
    \item \texttt{s} gives an expression $\ve$;
    \item $\vv$ is the evaluation of $\ve$ under $\env$;
    \item \texttt{vs} is \texttt{[v]};
    \item $\newenv$ is $\env$ modified after evaluation of the expression $\ve$ under $\env$ as per Chapter~\ref{chap:eval_expr}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SReturnOne.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnOne.asl}
    \texttt{return 3;} exits the current subprogram with value \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\SReturnOneBegin, lastline=\SReturnOneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \envp) \OrAbnormal\\
    \wid \in \identifier\text{ is fresh}\\
    \writeidentifier(\wid, \vv) \evalarrow \vgtwo\\
    \vg = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalstmt{\env, \texttt{S\_Return}(\langle\ve\rangle)} \evalarrow \Returning(([\vv], \vg), \envp)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnSome \label{sec:SemanticsRule.SReturnSome}}

    \subsection{Prose}
Evaluation of the statement \texttt{s} under environment $\env$ is
\texttt{Returning vs} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{return} statement;
    \item \texttt{s} gives a list of expressions \texttt{es};
    \item \texttt{vs} is the result of the evaluation of each element of the list \texttt{es} under $\env$ as per Chapter~\ref{chap:eval_expr};
    \item $\newenv$ is $\env$ modified after the evaluation of each element of the list \texttt{es} under $\env$ as per Chapter~\ref{chap:eval_expr}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SReturnSome.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnSome.asl}
    \texttt{return (3, 42);} exits the current subprogram with value \texttt{(3, 42)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SReturnSomeBegin, lastline=\SReturnSomeEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\newcommand\writefolder[1]{\texttt{write\_folder}(#1)}

We first define the helper relation
\[
  \writefolder{\envs, (\vals\times\XGraphs)^*} \aslrel (\vals^*, \XGraphs)
\]

via the following two rules:
\begin{mathpar}
  \inferrule{}{
    \writefolder{\env, \emptylist} \evalarrow (\emptylist, \emptygraph)
  }
  \and
  \inferrule{
    \wid \in \identifier\text{ is fresh}\\
    \vm = (\vv, \vg)\\
    \writeidentifier(\wid, \vv) \evalarrow \vgone\\
    \writefolder{\env, (\vms, \vgone)} \evalarrow (\vvs', \vgtwo)\\
  }
  {
    \writefolder{\env, ([\vm] + \vms, \vg)} \evalarrow ([\vv] + \vvs', \ordered{\vg}{\aslpo}{ (\ordered{\vgone}{\asldata}{\vgtwo}) })
  }
\end{mathpar}

We now use the helper relation to define the rule for returning a tuple of values:
\begin{mathpar}
  \inferrule{
    \evalexprlistm{\env, \es} \evalarrow \Normal(\ms, \newenv) \OrAbnormal\\
    \writefolder{\env, \ms} \evalarrow (\vvs, \vg)
  }
  {
    \evalstmt{\env, \texttt{S\_Return}(\langle\texttt{E\_Tuple}(\es)\rangle)} \evalarrow \Returning((\vvs, \vg), \newenv)
  }
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SSeq \label{sec:SemanticsRule.SSeq}}
  \subsection{Prose}
  The semantics of~\texttt{s1; s2} is the semantics of~\texttt{s2} applied to the results
  of the semantics of~\texttt{s1} if they do not perform an early return, in which
  case it is the semantics of~\texttt{s1}.
  The evaluation of two statements introduces an $\aslpo$ arrow between the two
  graphs produced by their interpretations.

  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
  \begin{itemize}
  \item \texttt{s} is a sequence statement \texttt{s1; s2};
  \item $\envp$ is $\env$ modified after evaluation of \texttt{s1};
  \item $\newenv$ is $\envp$ modified after evaluation of \texttt{s2}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SSeq.asl}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SSeq.asl}
  \texttt{let x = 3; let y = x + 1} evaluates \texttt{let x = 3} then \texttt{let y = x + 1}.

  \subsection{Code}
  \VerbatimInput[firstline=\SSeqBegin, lastline=\SSeqEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  \evalstmt{\env, \vsone} \evalarrow \Continuing(\vgone, \envone) \terminateas \Returning(\vvsg, \envp),\ThrowingConfig,\ErrorConfig\\
  \evalstmt{\envone, \vstwo} \evalarrow \Continuing(\vgtwo, \envtwo) \OrAbnormal\\
  \vg = \ordered{\vgone}{\aslpo}{\vgtwo}
}
{
  \evalstmt{\env, \texttt{S\_Seq}(\vsone, \vstwo)} \evalarrow \Continuing(\vg, \envtwo)
}
\and
\inferrule{
  \evalstmt{\env, \vsone} \evalarrow \Continuing(\vgone, \envone)\\
  \evalstmt{\envone, \vstwo} \evalarrow \Returning(\vvsg, \envtwo)\\
  \vg = \ordered{\vgone}{\aslpo}{\vgtwo}
}
{
  \evalstmt{\env, \texttt{S\_Seq}(\vsone, \vstwo)} \evalarrow \Returning(\vg, \envtwo)
}
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCall \label{sec:SemanticsRule.SCall}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a call statement;
    \item \texttt{s} gives a subprogram name \texttt{name} with actual arguments \texttt{actual\_args};
    \item $\envp$ is $\env$ modified after evaluation of the subprogram call;
    \item $\newenv$ is $\envp$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCall.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCall.asl}
    \texttt{Zeros(3)} evaluates to \texttt{'000'}.

  \subsection{Code}
  \VerbatimInput[firstline=\SCallBegin, lastline=\SCallEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalcall{\env, \name, \args, \namedargs} \evalarrow \Normal(\vg, \envp) \OrAbnormal
  }
  {
    \evalstmt{\env, \texttt{S\_Call}(\name, \args, \namedargs)} \evalarrow \Continuing(\vg, \envp)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCond \label{sec:SemanticsRule.SCond}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{s} gives a condition \texttt{cond} and two conditional blocks \texttt{s1} and \texttt{s2};
    \item \texttt{v\_cond} is the evaluation of \texttt{cond};
    \item $\newenv$ is $\env$ modified after evaluation of \texttt{s1} or \texttt{s2} depending on
      \texttt{v\_cond}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCond.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCond.asl}
    does not result in any Assertion Error.

  \subsection{Code}
  \VerbatimInput[firstline=\SCondBegin, lastline=\SCondEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \envp) \OrAbnormal\\
    \vv = \nvbool(\True)\\
    \evalblock{\envp, \vsone} \evalarrow C \OrAbnormal\\
    \vg = \ordered{\vgone}{\aslctrl}{\graphof{C}}
  }
  {
    \evalstmt{\env, \texttt{S\_Cond}(\ve, \vsone, \vstwo)} \evalarrow \withgraph{C}{\vg}
  }
\and
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \envp) \OrAbnormal\\
  \vv = \nvbool(\False)\\
  \evalblock{\envp, \vsone} \evalarrow C \OrAbnormal\\
  \vg = \ordered{\vgone}{\aslctrl}{\graphof{C}}
}
{
  \evalstmt{\env, \texttt{S\_Cond}(\ve, \vsone, \vstwo)} \evalarrow \withgraph{C}{\vg}
}
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCase \label{sec:SemanticsRule.SCase}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{s} gives a condition \texttt{cond} and a number of statements \texttt{s\_1}, $\cdots$, \texttt{s\_n};
    \item \texttt{v\_cond} is the evaluation of \texttt{cond};
    \item $\newenv$ is $\envp$ modified after evaluation of one of the statements \texttt{s\_i} depending on \texttt{v\_cond}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCase.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCase.asl}
    uses the second \texttt{when} clause because \texttt{3} is less than \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\SCaseBegin, lastline=\SCaseEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
A case statement is syntactic sugar for a ``condition-ladder''.
We use the AST-to-AST function \tododefine{case\_to\_conds} to convert a case statement
into a corresponding conditional statement.

\begin{mathpar}
  \inferrule{
    \tododefine{case\_to\_conds}(\ve, \texttt{alts}) = \vs\\
    \evalstmt{\env, \vs} \evalarrow C
  }
  {
    \evalstmt{\env, \texttt{S\_Case}(\ve, \texttt{alts})} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssert \label{sec:SemanticsRule.SAssert}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ or an error and all of the following apply:
    All of the following apply:
    \begin{itemize}
    \item \texttt{s} is an \texttt{assert} statement;
    \item \texttt{s} gives an expression $\ve$;
    \item $\vv$ is the evaluation of the expression $\ve$ as per Chapter~\ref{chap:eval_expr};
    \item One of the following applies:
          \begin{itemize}
          \item $\vv$ is \texttt{true} and $\newenv$ is $\env$,
          \item an ``AssertionFailed'' error is returned.
          \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.SAssertOk.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssertOk.asl}
    \texttt{assert (42 != 3);} ensures that \texttt{3} is not equal to \texttt{42}.

    \subsection{Example: SemanticsRule.SAssertNo.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssertNo.asl}
    \texttt{assert (42 == 3);} results in an ``\texttt{AssertionFailed}'' error.

  \subsection{Code}
  \VerbatimInput[firstline=\SAssertBegin, lastline=\SAssertEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vg), \envp) \OrAbnormal\\
    \vv = \nvbool(\True)
  }
  {
    \evalstmt{\env, \texttt{S\_Assert}(\ve)} \evalarrow \Continuing(\vg, \envp)
  }
  \and
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vg), \envp)\\
    \vv = \nvbool(\False)
  }
  {
    \evalstmt{\env, \texttt{S\_Assert}(\ve)} \evalarrow \Error(\texttt{"Assertion failed!"})
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SWhile \label{sec:SemanticsRule.SWhile}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{while} statement;
    \item \texttt{s} gives an expression $\ve$ and a loop body \texttt{body};
    \item $\newenv$ is $\env$ modified after evaluation of the loop \texttt{(e,body)} as per Section~\ref{sec:SemanticsRule.Loop}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SWhile.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SWhile.asl}
    prints ``\texttt{0123}''.

  \subsection{Code}
  \VerbatimInput[firstline=\SWhileBegin, lastline=\SWhileEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalloop{\env, \True, \ve, \body} \evalarrow C
  }
  {
    \evalstmt{\env, \texttt{S\_While}(\ve, \body)} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SRepeat \label{sec:SemanticsRule.SRepeat}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{repeat} statement;
    \item \texttt{s} gives an expression $\ve$ and a loop body \texttt{body};
    \item $\newenv$ is $\env$ modified after evaluation of the loop \texttt{(e,body)} as per Section~\ref{sec:SemanticsRule.Loop}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SRepeat.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SRepeat.asl}
    prints ``\texttt{0123}''.

  \subsection{Code}
  \VerbatimInput[firstline=\SRepeatBegin, lastline=\SRepeatEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalblock{\env, \body} \evalarrow \Continuing(\vgone, \envone) \terminateas \Returning(\vvsg, \envp),\ThrowingConfig,\ErrorConfig\\
    \evalloop{\envone, \False, \ve, \body} \evalarrow C
  }
  {
    \evalstmt{\env, \texttt{S\_Repeat}(\ve, \body)} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SFor \label{sec:SemanticsRule.SFor}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{for} statement;
    \item \texttt{s} gives \texttt{(id,e1,dir,e2,s)};
    \item $\newenv$ is $\env$ modified after evaluation of the \texttt{for} loop \texttt{(id,e1,dir,e2,s)} as per Section~\ref{sec:SemanticsRule.For}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SFor.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SFor.asl}
    prints ``\texttt{0123}''.

  \subsection{Code}
  \VerbatimInput[firstline=\SForBegin, lastline=\SForEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}


Recall that the expression for the \texttt{for} loop range are side-effect-free, which means they are guaranteed to terminate normally.
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \vvone} \evalarrow \Normal((\vvone, \vgone), \env)\\
    \evalexpr{\env, \veone} \evalarrow \Normal((\vvtwo, \vgtwo), \env)\\
    \declarelocalidentifier(\env, \id, \vvone) \evalarrow (\vgthree,\envone)\\
    \evalfor{\env, \id, \vvone, \dir, \vvtwo, \vs} \evalarrow \Normal(\vgfour, \envtwo) \OrAbnormal\\
    \removelocal(\envtwo, \id) \evalarrow \envthree\\
    \vg = \ordered{(\vgone \parallel \vgtwo)}{\asldata}{ \ordered{\vgthree}{\aslpo}{\vgfour}   }
  }
  {
    \evalstmt{\env, \texttt{S\_For}(\id, \veone, \dir, \vetwo, \vs)} \evalarrow \Continuing(\vg, \envthree)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SThrowNone \label{sec:SemanticsRule.SThrowNone}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{throw} statement which gives no expression;
    \item $\newenv$ is $\env$;
    \item an exception is thrown with $\newenv$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SThrowNone.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SThrowNone.asl}
    throws a ``\texttt{MyException}'' exception.

  \subsection{Code}
  \VerbatimInput[firstline=\SThrowNoneBegin, lastline=\SThrowNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalstmt{\env, \texttt{S\_Throw}(\None)} \evalarrow \Throwing((\None, \emptygraph), \env)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SThrowSomeTyped \label{sec:SemanticsRule.SThrowSomeTyped}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{throw} statement which gives an expression $\ve$ and a type \texttt{t};
    \item $\vv$ is the result of evaluating the expression $\ve$ in $\env$;
    \item $\newenv$ is the environment modified after evaluating the expression $\ve$ in $\env$;
    \item an exception is thrown with $\vv$ and $\newenv$.
    \end{itemize}

    \subsection{Example: SemanticsRule.SThrowSomeTyped.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SThrowSomeTyped.asl}
    throws a ``\texttt{MyException \{a: 3, b: 42\}}'' exception.

  \subsection{Code}
  \VerbatimInput[firstline=\SThrowSomeTypedBegin, lastline=\SThrowSomeTypedEnd]{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\
    \vgtwo = \WriteEffect(\name)\\
    \name\in\identifier \text{ is fresh}\\
    \vg' = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalstmt{\env, \texttt{S\_Throw}(\langle\ve, \langle\vt\rangle\rangle)} \evalarrow \Throwing((\langle(\vv,\vt)\rangle, \vg'), \env)
  }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.STry \label{sec:SemanticsRule.STry}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{try} statement \texttt{[(s', catchers, otherwise\_opt)};
    \item \texttt{s\_m} is the evaluation of the block \texttt{s'} under $\env$;
    \item $\newenv$ is $\env$ modified after evaluation of the
catchers \\ \texttt{(catchers otherwise\_opt s\_m)} as per
Chapter~\ref{chap:eval_catchers}.
    \end{itemize}

    \subsection{Example: SemanticsRule.STry.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.STry.asl}
    does not result in any Assertion error, and the specification terminates with the exit code $0$.

  \subsection{Code}
  \VerbatimInput[firstline=\STryBegin, lastline=\STryEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalblock{\env, \vs} \evalarrow C \OrAbnormal\\
    \evalcall{\env, \catchers, \otherwiseopt, C} \evalarrow C'
  }
  {
    \evalstmt{\env, \texttt{S\_Try}(\vs, \catchers, \otherwiseopt)} \evalarrow C'
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SDeclSome \label{sec:SemanticsRule.SDeclSome}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a declaration \texttt{(ldi, Some e)};
    \item $\newenv$ is $\env$ modified after evaluation of the local declaration
      \texttt{ldi env (Some m)} as per Chapter~\ref{chap:eval_local_decl}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SDeclSome.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SDeclSome.asl}
    \texttt{let x = 3;} binds \texttt{x} to \texttt{3} in the empty environment.

  \subsection{Code}
  \VerbatimInput[firstline=\SDeclSomeBegin, lastline=\SDeclSomeEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal(\vm, \envone) \OrAbnormal\\
    \evallocaldecl{\envone, \vs, \ldi, \langle\vm\rangle} \evalarrow \Normal(\vg, \envp)\\
  }
  {
    \evalstmt{\env, \texttt{S\_Decl}(\Ignore, \ldi, \langle\ve\rangle)} \evalarrow \Continuing(\vg, \envp)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SDeclNone \label{sec:SemanticsRule.SDeclNone}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment $\env$ is
$\newenv$ and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a declaration \texttt{(ldi, None)};
    \item $\newenv$ is $\env$ modified after evaluation of the local declaration
      \texttt{ldi env None} as per Chapter~\ref{chap:eval_local_decl}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SDeclNone.asl}
    In the specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SDeclNone.asl}
    \texttt{var x : integer;} binds \texttt{x} in $\env$ to the base value of \texttt{integer}.

  \subsection{Code}
  \VerbatimInput[firstline=\SDeclNoneBegin, lastline=\SDeclNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallocaldecl{\envone, \vs, \ldi, \None} \evalarrow \Normal(\vg, \envp)\\
  }
  {
    \evalstmt{\env, \texttt{S\_Decl}(\Ignore, \ldi, \langle\ve\rangle)} \evalarrow \Continuing(\vg, \envp)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Blocks \label{chap:eval_block}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SemanticsRule.Block \label{sec:SemanticsRule.Block}}

    \subsection{Prose}
    \texttt{eval\_block env stm} is $\newenv$ and all of the following applies:
    \begin{itemize}
    \item \texttt{block\_env'} is $\env$ modified after the evaluation of the statement \texttt{stm} as per Chapter~\ref{chap:eval_stmt};
    \item $\newenv$ is \texttt{block\_env'} after restoring the
variable bindings of $\env$ with the updated values of
\texttt{block\_env'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.Block.asl}
    In the specification:
    \VerbatimInput{\testdir/SemanticsRule.Block.asl}
    the conditional statement \texttt{if TRUE then\ldots{} end;} defines a
block structure. Thus, the scope of the declaration \texttt{let y = 2;} is
limited to its declaring block---or the binding for \texttt{y} no longer exists
once the block is exited. As a consequence, the subsequent declaration
\texttt{let y = 1} is valid.  By contrast, the assigment of the mutable
variable~\texttt{x} persists after block end. However, observe that \texttt{x}
is defined before the block and hence still exists after the block.

  \subsection{Code}
    \VerbatimInput[firstline=\BlockBegin,lastline=\BlockEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally}
The \emph{restriction} of a function $f : X \rightarrow Y$ to a subset of its domain values
$A \subseteq \dom(f)$, denoted as $f|_A$, is defined as follows (by defining the graph of the resulting function):
\[
  f|_A \triangleq \{ (x, f(x)) \;|\; x \in A \} \enspace.
\]

\begin{mathpar}
  \inferrule{
    \env=(\tenv,\denv)\\
    \blockenv = (\tenv, (G^\denv, \emptylist))\\
    \evalstmt{\env, \stm} \evalarrow \Continuing(\vg, \blockenv') \OrAbnormal\\
    \blockenv'=(\tenv, \denv')\\
    \newenv = (\tenv, (G^{\denv'}, L^{\denv'}|_{\dom(L^\denv)}))
  }
  {
    \evalblock{\env, \stm} \evalarrow \Continuing(\vg, \newenv)
  }
  \and
  \inferrule{
    \env=(\tenv,\denv)\\
    \blockenv = (\tenv, (G^\denv, \emptylist))\\
    \evalstmt{\env, \stm} \evalarrow \Returning((\vv_{1..k},\vg), \blockenv')\\
    \blockenv'=(\tenv, \denv')\\
    \newenv = (\tenv, (G^{\denv'}, L^{\denv'}|_{\dom(L^\denv)}))
  }
  {
    \evalblock{\env, \stm} \evalarrow \Returning((\vv_{1..k},\vg), \newenv)
  }
\end{mathpar}

That is, evaluating a block discards the bindings for variables declared inside $\stm$.
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Loops \label{chap:eval_loops}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The evaluation of loop is a common part of the evaluation of multiple loop
statements.
%
For example, the semantic rule \emph{Loop} is used by the semantic rule
\emph{SWhile} at Section~\ref{sec:SemanticsRule.SWhile} and the semantic rule
\emph{SRepeat} at Section~\ref{sec:SemanticsRule.SRepeat}.
%
The semantic rule \emph{For} is only used by the semantic rule \emph{SFor} at
Section~\ref{sec:SemanticsRule.SFor}.

\section{SemanticsRule.Loop \label{sec:SemanticsRule.Loop}}
\texttt{eval\_loop is\_while env e\_cond body} evaluates \texttt{body} in
$\env$: this is either an interruption \texttt{Returning vs}, a
\texttt{Throwing} or a new environment $\newenv$.

    \subsection{Prose}
    \texttt{cond\_m} evaluates to \texttt{e\_cond} or \texttt{not e\_cond} as
determined by \texttt{is\_while} and one of the following applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{false};
      \item $\newenv$ is $\env$---the loop is exited.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{true};
      \item \texttt{env1} is $\env$ modified after the evaluation of the
statement \texttt{body}---this step might affect the value of \texttt{cond\_m}
eventually leading to exiting the loop;
      \item $\newenv$ is \texttt{env1} modified after the evaluation of
\texttt{eval\_loop is\_while env e\_cond body}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.Loop.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Loop.asl}
    does not result in any Assertion Error and the specification terminates with exit
    code $0$.

    \subsection{Code}
    \VerbatimInput[firstline=\LoopBegin, lastline=\LoopEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \envone) \OrAbnormal\\
    \condm = (\nvbool(\False), \vgone)
  }
  {
    \evalloop{\env, \econd, \body} \evalarrow \Continuing(\vgone, \envone)
  }
\and
  \inferrule{
    \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \envone)\\
    \condm = (\nvbool(\True), \vgone)\\
    \evalblock{\envone, \body} \evalarrow \Continuing(\vgtwo, \envtwo) \OrAbnormal\\
    \evalloop{\envtwo, \iswhile, \econd, \body} \evalarrow \Continuing(\vgthree, \envthree)\\
    \vg = \ordered{\ordered{\vgone}{\aslctrl}{\vgtwo}}{\aslpo}{\vgthree}
  }
  {
    \evalloop{\env, \econd, \body} \evalarrow \Continuing(\vg, \envthree)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.For \label{sec:SemanticsRule.For}}
\texttt{eval\_for undet env index\_name v\_start dir v\_end body} evaluates
\texttt{body} in $\env$: this is either an interruption \texttt{Returning
vs} or a new environment $\newenv$.

    \subsection{Prose}
    \texttt{cond\_m} evaluates to \texttt{leq v\_end v\_start} or \texttt{geq
v\_end v\_start} as determined by \texttt{dir} and one of the following
applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{true};
      \item $\newenv$ is $\env$ as the loop is exited.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{false};
      \item \texttt{env1} is $\env$ modified after the evaluation of the statement \texttt{body};
      \item \texttt{env2} is \texttt{env1} modified such that \texttt{index\_name} is bound to \texttt{v\_step};
      \item \texttt{v\_step} evaluates to \texttt{v\_start+1} or \texttt{v\_start-1} as determined by \texttt{dir};
      \item $\newenv$ is \texttt{env2} modified after the evaluation of \texttt{eval\_for undet
        env index\_name v\_step dir v\_end body}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.For.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.For.asl}
    does not result in any assertion error, and the specification terminates with exit-code $0$.

    \subsection{Code}
    \VerbatimInput[firstline=\ForBegin, lastline=\ForEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally}
    Intuitively, a \texttt{for}-loop \texttt{for $i$ = $e_1$ to $e_2$ do $S$} is syntactic sugar for
    \texttt{$i$ = $e_1$; while $i$ < $e_2$ do $S$; $i$=$i$+1 end}.
    Similarly, \texttt{for $i$ = $e_1$ downto $e_2$ do $S$} is syntactic sugar for
    \texttt{$i$ = $e_1$; while $i$ > $e_2$ do $S$; $i$=$i$-1 end}. The important difference between
    the statement involving the \texttt{while} loop and the original \texttt{for} loop is that the
    scope of the counter variable is restricted to the body of the \texttt{for}. Notice that this
    aspect is already handled by the rule for \texttt{S\_For}.

    To reflect this, we constructs the following two ASTs for each of the cases for the direction of the loop:
\[
\begin{array}{rcl}
  \texttt{Ei}         &\triangleq& \texttt{E\_Var}(\vindexname)\\
  \texttt{plus\_one}   &\triangleq& \texttt{S\_Assign}(\texttt{Ei}, \texttt{E\_Binop}(\texttt{"+"}, \texttt{Ei}, \texttt{E\_Lit}(\texttt{L\_Int}(1))))\\
  \texttt{Up\_for\_body}  &\triangleq& \texttt{S\_Seq}(\body, \texttt{plus\_one})\\
  \texttt{Up\_cond}       &\triangleq& \texttt{E\_Binop}(\LT, \texttt{Ei}, \vend)\\
  \texttt{Up\_for}       &\triangleq& \texttt{S\_Seq}(\texttt{S\_Assign}(\texttt{Ei}, \vstart), \texttt{S\_While}(\texttt{Up\_cond}, \texttt{Up\_for\_body}))\\
  \hline
  \texttt{minus\_one}   &\triangleq& \texttt{S\_Assign}(\texttt{Ei}, \texttt{E\_Binop}(\texttt{"-"}, \texttt{Ei}, \texttt{E\_Lit}(\texttt{L\_Int}(1))))\\
  \texttt{Down\_for\_body}  &\triangleq& \texttt{S\_Seq}(\body, \texttt{minus\_one})\\
  \texttt{Down\_cond}       &\triangleq& \texttt{E\_Binop}(\GT, \texttt{Ei}, \vend)\\
  \texttt{Down\_for}       &\triangleq& \texttt{S\_Seq}(\texttt{S\_Assign}(\texttt{Ei}, \vstart), \texttt{S\_While}(\texttt{Down\_cond}, \texttt{Down\_for\_body}))
\end{array}
\]

  We now use the (de-sugared) ASTs to evaluate the statement:
\begin{mathpar}
  \inferrule{
    \evalstmt{\env, \texttt{Up\_for}} \evalarrow C
  }
  {
    \evalfor{\env, \vindexname, \vstart, \texttt{Up}, \vend, \body} \evalarrow C
  }
  \and
  \inferrule{
    \evalstmt{\env, \texttt{Down\_for}} \evalarrow C
  }
  {
    \evalfor{\env, \vindexname, \vstart, \texttt{Down}, \vend, \body} \evalarrow C
  }
\end{mathpar}

% \newcommand\compfordir[0]{\texttt{comp\_for\_dir}}
% \newcommand\opfordir[0]{\texttt{op\_for\_dir}}
% \[
%   \begin{array}{rl}
%     \compfordir = &\lambda d.\
%  \left\{
%   \begin{array}{ll}
%     \LT, & x=\texttt{Up}\\
%     \GT, & x=\texttt{Down}\\
%   \end{array}\right.\\
%   \opfordir = &\lambda d.\
%  \left\{
%   \begin{array}{ll}
%     \PLUS, & x=\texttt{Up}\\
%     \MINUS, & x=\texttt{Down}\\
%   \end{array}\right.
% \end{array}
%   \]

% \begin{mathpar}
%   \inferrule{
%     %\op = \dir=\texttt{UP} ? \LT : \GT\\
%     \tododefine{read\_identifier}(\env, \vindexname, \vstart) \evalarrow \vgone\\
%     \binop(\compfordir(\dir), \vend, \vstart) \evalarrow \condm\\
%     \condm = (\condv, \condg)\\
%     \ordered{\vgone}{\asldata}{\condg}\\
%     %\opfordir(\dir)
%   }
%   {
%     \evalfor{\env, \vindexname, \vstart, \dir, \vend, \body} \evalarrow
%   }
% \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Catchers \label{chap:eval_catchers}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The semantic relation for evaluating catchers employs input configurations
that themselves take an output configuration as an argument.
This argument corresponds to the output configuration resulting from raising
an exception.
The type of this argument is defined as follows:
\[
  \begin{array}{rcl}
    \TOutConfig          &\triangleq& \Normal(\vals, \XGraphs) \cup \Normal((\vals \times \XGraphs), \envs)\ \cup \\
    & & \Normal(((\vals \times \vals)^* \times \XGraphs), \envs) \cup  \Normal(\XGraphs, \envs)\ \cup   \\
    & & \Normal((\vals^* \times \XGraphs), \envs) \cup \Normal((\vals\times\XGraphs)^*, \envs)\ \cup \\
    & & \TThrowing \cup \TContinuing \cup \TReturning \cup \TError
  \end{array}
\]

\texttt{eval\_catchers env catchers otherwise\_opt s\_m}, given the result
\texttt{s\_m} of the evaluation of a statement under environment $\env$
is $\vres$ which is either a \texttt{Throwing (v, v\_ty, env\_throw)}, an
interruption \texttt{Returning vs} or a new environment $\newenv$.
Formally, one of the following applies:
\begin{itemize}
\item SemanticsRule.Catch (see Section~\ref{sec:SemanticsRule.Catch}),
\item SemanticsRule.CatchNamed (see Section~\ref{sec:SemanticsRule.CatchNamed}),
\item SemanticsRule.CatchOtherwise (see Section~\ref{sec:SemanticsRule.CatchOtherwise}),
\item SemanticsRule.CatchNone (see Section~\ref{sec:SemanticsRule.CatchNone}),
\item SemanticsRule.CatchNoThrow (see Section~\ref{sec:SemanticsRule.CatchNoThrow}).
\end{itemize}

\newcommand\findcatcher[0]{\texttt{find\_catcher}}
We define the (recursive) helper function $\findcatcher : (\staticenvs \times \ty, \catcher^*) \rightarrow \langle \catcher \rangle$,
which returns the first catcher clause that matches the given type (as a singleton set), or an empty set:
\begin{mathpar}
  \inferrule{}{\findcatcher(\tenv, \vvty, \emptylist) \evalarrow \None}
\and
\inferrule{
  \vc = (\nameopt, \ety, \vs) \\
  \typesatisfies(\tenv, \vvty, \ety)
}
{
  \findcatcher(\tenv, \vvty, \vc + \catchers) = \langle\vc\rangle
}
\and
\inferrule{
  \vc = (\nameopt, \ety, \vs) \\
  \neg\typesatisfies(\tenv, \vvty, \ety)\\
  \findcatcher(\tenv, \vvty, \catchers) = C
}
{
  \findcatcher(\tenv, \vvty, \vc + \catchers) = C
}
\end{mathpar}

We define the helper relation
\[
  \rethrowimplicit : (\identifier \times \ty \times \TOutConfig) \rightarrow \TOutConfig
\]
via the following rules:
\begin{mathpar}
  \inferrule{}
  {
    \rethrowimplicit(\vv, \vvty, \Throwing((\None, \vg), \envthrowone)) \evalarrow \\
    \Throwing((\langle(\vv, \vvty)\rangle, \vg), \envthrowone)
  }
\and
\inferrule{}
{
  \rethrowimplicit(\vv, \vvty, \Throwing((\langle(\vv', \vvty')\rangle, \vg), \envthrowone)) \evalarrow \\
  \Throwing((\langle(\vv', \vvty')\rangle, \vg), \envthrowone)
}
\and
\inferrule{
  \configdomain{C} \neq \Throwing
}
{
  \rethrowimplicit(\Ignore, \Ignore, C, \Ignore)) \evalarrow C
}
\end{mathpar}
This function changes \emph{implicit throwing configurations}, that is, $\Throwing$ configurations with an empty
variable name and exception type, such that they include the given variable name and exception type.
Other configurations remain unchanged.

\section{SemanticsRule.Catch \label{sec:SemanticsRule.Catch}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{catcher} is the first catcher in \texttt{catchers} that matches \texttt{v\_ty};
    \item \texttt{catcher} does not declare a name;
    \item \texttt{catcher} gives a statement \texttt{s};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{env\_throw} and $\env$ have the same scope, and \texttt{env1} is \texttt{env\_throw};
      \item \texttt{env1} is the environment formed with the global part of \texttt{env\_throw}
        and the local part of $\env$;
      \end{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{Throwing (None, None, env\_throw1)} is the result of the evaluation of
        the block \texttt{s} in \texttt{env1}, and $\vres$ is \texttt{Throwing (v, v\_ty, env\_throw1)};
      \item $\vres$ is the result of the evaluation of the block \texttt{s} in \texttt{env1}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.Catch.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Catch.asl}
    prints ``\texttt{MyException}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchBegin, lastline=\CatchEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \sm = \Throwing((\langle \vv, \vvty \rangle, \sg), \envthrow)\\
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \envthrow = (\tenv, (G^{\denvthrow}, L^{\denvthrow}))\\
    \envone = (\tenv, (G^{\denvthrow}, L^{\denv}))\\
    \findcatcher(\tenv, \vvty, \catchers) = \langle (\None, \Ignore, \vs) \rangle\\
    \evalblock{\envone, \vs} \evalarrow C \terminateas \ErrorConfig\\
    \rethrowimplicit(\vv, \vvty, C) = D\\
    \vg = \ordered{\sg}{\aslpo}{\graphof{D}}
  }
  {
    \evalcatchers{\env, \catchers, \otherwiseopt, \sm} \evalarrow \withgraph{D}{\vg}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNamed \label{sec:SemanticsRule.CatchNamed}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{catcher} is the first catcher in \texttt{catchers} that matches \texttt{v\_ty};
    \item \texttt{catcher} declares a name \texttt{name};
    \item \texttt{catcher} gives a statement \texttt{s};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{env\_throw} and $\env$ have the same scope, and \texttt{env1} is \texttt{env\_throw};
      \item \texttt{env1} is the environment formed with the global part of \texttt{env\_throw}
        and the local part of $\env$;
      \item \texttt{env2} is \texttt{env1} modified after binding locally \texttt{name} to the exception
        $\vv$ raised by \texttt{s\_m};
      \end{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{Throwing (None, None, env\_throw1)} is the result of the evaluation of
        the block \texttt{s} in \texttt{env2}, and $\vres$ is \texttt{Throwing (v, v\_ty, env\_throw1)};
      \item \texttt{env3} is \texttt{env2} modified after the evaluation of the block \texttt{s} in
        \texttt{env2}, and $\newenv$ is \texttt{env3} modified after unbinding \texttt{name} from
        \texttt{env3}.
      \item $\vres$ is the result of the evaluation of the block \texttt{s} in \texttt{env2}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchNamed.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNamed.asl}
    prints ``\texttt{My exception with my message}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchNamedBegin, lastline=\CatchNamedEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \sm \eqname \Throwing((\langle \vv, \vvty \rangle, \sg), \envthrow)\\
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \envthrow = (\tenv, (G^{\denvthrow}, L^{\denvthrow}))\\
    \envone = (\tenv, (G^{\denvthrow}, L^{\denv}))\\
    \findcatcher(\tenv, \vvty, \catchers) = \langle (\langle\name\rangle, \Ignore, \vs) \rangle\\
    \tododefine{read\_value\_from}(\vv) = (\vvone, \vgone)\\
    \declarelocalidentifierm(\envone, \name, (\veone, \vgone)) \evalarrow (\envtwo, \vgtwo)\\
    \evalblock{\envtwo, \vs} \evalarrow C \terminateas \ErrorConfig\\
    \envthree = \environof{C}\\
    \removelocal(\envthree, \name) \evalarrow \envthree'\\
    \rethrowimplicit(\vv, \vvty, \withenviron{C}{\envthree'}) = D\\
    \vg = \ordered{\sg}{\aslpo}{ \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\graphof{D}} }
  }
  {
    \evalcatchers{\env, \catchers, \otherwiseopt, \sm} \evalarrow \withgraph{D}{\vg}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchOtherwise \label{sec:SemanticsRule.CatchOtherwise}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{otherwise\_opt} is \texttt{Some s};
    \item no catcher matches \texttt{v\_ty};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{env\_throw} and $\env$ have the same scope, and \texttt{env1} is \texttt{env\_throw};
      \item \texttt{env1} is the environment formed with the global part of \texttt{env\_throw}
        and the local part of $\env$;
      \end{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{Throwing (None, None, env\_throw1)} is the result of the evaluation of
        the block \texttt{s} in \texttt{env1}, and $\vres$ is \texttt{Throwing (v, v\_ty, env\_throw1)};
      \item $\vres$ is the result of the evaluation of the block \texttt{s} in \texttt{env1}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchOtherwise.asl}
     The specification:
     \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchOtherwise.asl}
     prints ``\texttt{Another exception}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchOtherwiseBegin, lastline=\CatchOtherwiseEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \sm = \Throwing((\langle \vv, \vvty \rangle, \sg), \envthrow)\\
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \envthrow = (\tenv, (G^{\denvthrow}, L^{\denvthrow}))\\
    \envone = (\tenv, (G^{\denvthrow}, L^{\denv}))\\
    \findcatcher(\tenv, \vvty, \catchers) = \None\\
    \evalblock{\envone, \vs} \evalarrow C \terminateas \ErrorConfig\\
    \rethrowimplicit(\vv, \vvty, C) = D\\
    \vg = \ordered{\sg}{\aslpo}{\graphof{D}}
  }
  {
    \evalcatchers{\env, \catchers, \langle\vs\rangle, \sm} \evalarrow \withgraph{D}{\vg}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNone \label{sec:SemanticsRule.CatchNone}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{otherwise\_opt} is \texttt{None};
    \item no catcher matches \texttt{v\_ty};
    \item $\newenv$ is $\env$.
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchNone.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNone.asl}
    does not print anything.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchNoneBegin, lastline=\CatchNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \sm = \Throwing((\langle \vv, \vvty \rangle, \sg), \envthrow)\\
    \env \eqname (\tenv, (G^\denv, L^\denv))\\
    \findcatcher(\tenv, \vvty, \catchers) = \None
  }
  {
    \evalcatchers{\env, \catchers, \None, \sm} \evalarrow \sm
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNoThrow \label{sec:SemanticsRule.CatchNoThrow}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is not \texttt{Throwing};
    \item $\vres$ is \texttt{s\_m}.
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchNoThrow.asl}
    The specification:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNoThrow.asl}
    prints ``\texttt{No exception raised}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchNoThrowBegin, lastline=\CatchNoThrowEnd]{../Interpreter.ml}

  % For some reason the emptyformal environment here fails LaTeX compilation.
  %\begin{emptyformal}
    \subsection{Formally}
      \begin{mathpar}
      \inferrule{
        \sm = \Throwing((\None, \sg), \envthrow)
      }
      {
        \evalcatchers{\env, \catchers, \Ignore, \sm} \evalarrow \sm
      }
      \and
      \inferrule{
        \configdomain{\sm} = \Normal
      }
      {
        \evalcatchers{\env, \catchers, \Ignore, \sm} \evalarrow \sm
      }
    \end{mathpar}
  %\end{emptyformal}

  \isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Subprograms \label{chap:eval_call}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We now define the subprogram call evaluation relation:
\[
  \begin{array}{c}
    \evalcall{\overname{\envs}{\env} \aslsep
    \overbracket{\identifier}^{\texttt{name}} \aslsep
    \overbracket{\expr^*}^{\texttt{args}} \aslsep
    \overbracket{(\overname{\identifier}{\id_i}\times\overname{\expr}{\ve_i})^*}^{\texttt{named\_args}}} \;\aslrel\; \\
    \Normal((\overbracket{\vals^*}^{\vmstwo} \times \overname{\XGraphs}{\vg}), \overname{\envs}{\envp}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TError}{\ErrorConfig}
  \end{array}
\]

\texttt{eval\_call env name args named\_args} evaluates a call to the subprogram
named \texttt{name} in the environment $\env$, with the argument expressions
\texttt{args}, and the parameter expressions \texttt{named\_args}.
The evaluation results in either: (a) a list of returned values, each one associated
with an execution graph, and a new environment;
(b) a thrown exception configuration; or (c) an error configuration.

The evaluation first evaluates the expressions corresponding to the arguments
and parameters and then passes their values to in the resulting configuration
to the helper relation \texttt{eval\_subprogram}:
\[
  \begin{array}{c}
    \evalsubprogram{\envs \aslsep \identifier \aslsep (\vals \times \XGraphs)^* \aslsep (\identifier\times\vals)^*} \aslrel \\
    \Normal((\vals^* \aslsep \XGraphs), \envs) \cup \TThrowing \cup \TError
  \end{array}
\]

\texttt{eval\_subprogram env name actual\_args params} evaluates the subprogram \\
named \texttt{name} in the environment $\env$, with
\texttt{actual\_args} the list of actual arguments, and \texttt{params} the
list of arguments deduced by type equality. This is a new environment
$\newenv$ and a list of values \texttt{vs}, or an error is returned.
One of the following applies:
\begin{itemize}
\item SemanticsRule.FPrimitive (see Section~\ref{sec:SemanticsRule.FPrimitive}),
\item SemanticsRule.FCall (see Section~\ref{sec:SemanticsRule.FCall}).
\end{itemize}

\section{SemanticsRule.Call \label{sec:SemanticsRule.Call}}

\subsection{Prose}

\subsection{Code}
\VerbatimInput[firstline=\CallBegin, lastline=\CallEnd]{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \namedargs = [i=1..k: (\id_i, \ve_i)]\\
  \names = [i=1..k: \id_i]\\
  \nargsone = [i=1..k: \ve_i]\\
  \evalexprlistm{\env, \args} \evalarrow \Normal(\vargs, \envone)\OrAbnormal\\
  \evalexprlistm{\envone, \nargs1} \evalarrow \Normal(\nargstwo, \envtwo)\OrAbnormal\\
  \nargstwo = [i=1..k: \vm_i]\\
  \nargsthree = [i=1...k: (\id_i, \vm_i)]\\
  \envtwo = (\tenv, \denvtwo)\\
  \evalsubprogram{(\tenv,(G^\denvtwo,\emptyfunc)), \name, \vargs, \nargsthree} \evalarrow \\ \Normal(\vms, (\vglobal, \Ignore)) \OrAbnormal\\
  \vms = [j=1..n: (\vv_j, \rid_j)]\\
  j=1..n: \tododefine{read\_value\_from}(\vv_j, \rid_j) \evalarrow \vmstwo_j\\
  \vms = [j=1..n: \vmstwo_j]\\
  \envp = (\tenv, (\vglobal, L^{\denvtwo}))\\
  \vg = ...
}
{
  \evalcall{\env, \name, \args, \namedargs} \evalarrow \Normal((\vmstwo, \vg), \envp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.FPrimitive \label{sec:SemanticsRule.FPrimitive}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{name} is bound in \texttt{genv} to a primitive subprogram with a body \texttt{body};
  \item \texttt{new\_genv} is \texttt{genv};
  \item \texttt{vs} is the application of \texttt{body} on \texttt{actual\_args}.
  \end{itemize}

  \subsection{Example}
  In the specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.FPrimitive.asl}
  \texttt{print ("Hello, world!");} calls the primitive \texttt{print} on the evaluation of \texttt{"Hello, world!"}.

  \subsection{Code}
  \VerbatimInput[firstline=\FPrimitiveBegin, lastline=\FPrimitiveEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\newcommand\writeretvals[0]{\texttt{write\_ret\_vals}}
We first define the helper relation
\[
  \writeretvals : \writeretvals((\vals\times\XGraphs)^*) \aslrel (\vals^*\times\XGraphs) \enspace.
\]
This relation generates write events for the values
returned by the evaluation of a primitive subprogram:
  \begin{mathpar}
    \inferrule{}
    {
      \writeretvals(\emptylist) \evalarrow (\emptylist, \emptygraph)
    }
    \and
    \inferrule{
      \vx \in \identifier \text{ is fresh}\\
      \vm \eqname (\vv, \vgone)\\
      \writeidentifier(\vx, \vv) \evalarrow \vgtwo\\
      \vvsm \eqname (\vvs, \vgthree)\\
      \vg = (\ordered{\vgone}{\asldata}{\vgtwo}) \parallel \vgthree
    }
    {
      \writeretvals([\vm] + \vvsm) \evalarrow ([\vv] + \vvs, \vg)
    }
  \end{mathpar}

  We now define the rule for evaluating a primitive subprogram.
  The rule utilizes the transition relation $\evalprimitivearrow$, which parameterizes this semantics.
  \begin{mathpar}
    \inferrule{
      \env \eqname (\tenv, (\genv, \emptyfunc))\\
      \findfunc(\tenv, \name) = \{ \body = \texttt{SB\_Primitive} \ldots \}\\
      \evalprimitive{\name, \actualargs} \evalprimitivearrow \Normal(\vms, \vgone) \terminateas \ErrorConfig\\
      \writeretvals(\vms) \evalarrow \vvsm\\
      \vvsm \eqname (\vvs, \vgtwo)\\
      \vg = \ordered{\vgone}{\asldata}{\vgtwo}\\
    }
    {
      \evalsubprogram{\env, \name, \actualargs, \params} \evalarrow \Normal((\vvs, \vg), (\tenv, (\genv, \emptyfunc)))
    }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.FCall \label{sec:SemanticsRule.FCall}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{name} is bound in \texttt{genv} to a subprogram with a list of formal arguments
    \texttt{arg\_decls} and a body statement \texttt{body};
  \item \texttt{env1} is the environment made of \texttt{genv} and the empty local environment,
  \item \texttt{env2} is \texttt{env1} modified so that each formal argument in \texttt{arg\_decls} is
    locally bound to the corresponding actual argument in \texttt{actual\_args};
  \item \texttt{env3} is \texttt{env2} modified so that each parameter in \texttt{params} is declared;
  \item $\vres$ is the evaluation of \texttt{body} in \texttt{env3} and one of the following
    applies:
      \begin{itemize}
      \item $\vres$ is an environment \texttt{env4} and \texttt{new\_genv} is the global environment
        given by \texttt{env4}---e.g. where the subprogram called is either a setter or
        a procedure;
      \item $\vres$ is an interruption \texttt{Returning(xs,ret\_genv)} and \texttt{new\_genv} is
        \texttt{ret\_genv}---this is the general case.
      \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.FCall.asl}
  The specification:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.FCall.asl}
  calls the function \texttt{foo} and the procedure \texttt{bar}.

  \subsection{Code}
  \VerbatimInput[firstline=\FCallBegin, lastline=\FCallEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
We define the helper relation
\[
  \assignargs((\overname{\envs}{\env}\times\overname{\XGraphs}{\vgone})\aslsep \overname{(\identifier\times\ty)^*}{\texttt{arg\_decls}}
                  \aslsep \overname{(\vals\times\XGraphs)^*)}{\texttt{actual\_args}} \;\aslrel\;
              (\overname{\envs}{\newenv} \times \overname{\XGraphs}{\vg})
\]
which assigns the values of (the actual) arguments to the
formal variables of a given subprogram:
  \begin{mathpar}
    \inferrule{}
    {
      \assignargs((\env, \vgone), \emptylist, \emptylist) \evalarrow (\env, \vgone)
    }
    \and
    \inferrule{
      \declarelocalidentifiermm(\env, \vx, \vm) \evalarrow (\envone, \vgtwo)\\
      \assignargs((\envone, \ordered{\vgone}{\aslpo}{\vgtwo}), \argdecls, \actualargs) \evalarrow (\newenv, \vg)
    }
    {
      \assignargs((\env, \vgone), [(\vx, \Ignore)] + \argdecls, [\vm] + \actualargs) \evalarrow (\newenv, \vg)
    }
  \end{mathpar}

  We define the helper relation
  \[
    \begin{array}{c}
      \assignnamedargs((\envs\times\XGraphs) \aslsep ((\identifier\times(\vals\times\XGraphs)))^*) \;\aslrel\;
      (\envs\times\XGraphs)
    \end{array}
  \]
  which assigns values to the variables that correspond
  to the parameters of a given subprogram:
  \begin{mathpar}
    \inferrule{}
    {
      \assignnamedargs((\env, \vgone), \emptylist) \evalarrow (\env, \vgone)
    }
    \and
    \inferrule{
      \envm \eqname (\env, \vgone)\\
      \env(\vx) \neq \bot\\
      \vacc = (\env, \vgone) \\
      \assignnamedargs(\vacc, \params) \evalarrow (\newenv, \vgtwo)
    }
    {
      \assignnamedargs(\envm, [(\vx, \vm)] + \params) \evalarrow (\newenv, \ordered{\vgone}{\aslpo}{\vgtwo})
    }
    \and
    \inferrule{
      \envm \eqname (\env, \vgone)\\
      \env(\vx) = \bot\\
      \declarelocalidentifierm(\env, \vx, \vm) \evalarrow (\envone, \vgtwo)\\
      \vacc = (\envone, \vgtwo) \\
      \assignnamedargs(\vacc, \params) \evalarrow (\newenv, \vgthree)
    }
    {
      \assignnamedargs(\envm, [(\vx, \vm)] + \params) \evalarrow (\newenv, \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\vgthree})
    }
  \end{mathpar}

  We define the helper relation
  \[
      \matchfuncres(\TContinuing \cup \TReturning) \;\aslrel\;
                    \Normal(((\identifier\times\vals)^*\times\XGraphs)\aslsep\envs)
  \]
  which converts normal and throwing configurations
  into corresponding normal configurations that can be returned by a subprogram evaluation:
  \begin{mathpar}
    \inferrule{}
    {
      \matchfuncres(\Continuing(\vg, \env)) \evalarrow \Normal((\emptylist, \vg), \env)
    }
    \and
    \inferrule{
      \xs = [i=1..k: \vx_i]\\
      i=1..k: \id_i \in \identifier\text{ is fresh}\\
      \vvs = [i=1..k: (\vx, \id_i)]
    }
    {
      \matchfuncres(\Returning(\xs, \retenv)) \evalarrow \Normal((\vvs, \emptygraph), \retenv)
    }
  \end{mathpar}

  Recall that $\emptyfunc$ stands for the function with an empty domain.
  \begin{mathpar}
    \inferrule{
      \env \eqname (\tenv, (\genv, \emptyfunc))\\
      \findfunc(\tenv, \name) = \{ \body = \texttt{SB\_ASL}(\vbody), \args = \argdecls, \ldots \}\\
        \envone = (\tenv, (G^\denv, \emptyfunc))\\
        \assignargs((\envone, \emptygraph), \argdecls, \actualargs) \evalarrow (\envtwo, \vgtwo)\\
        \assignnamedargs((\envtwo, \vgtwo), \params) = (\envthree, \vgthree)\\
        \evalstmt{\envthree, \vbody} \evalarrow \vres \OrAbnormal\\
        \matchfuncres(\vres) \evalarrow \vres'\\
        \vg = \ordered{\vgtwo}{\aslpo}{\vgthree}\\
    }
    {
      \evalsubprogram{\env, \name, \actualargs, \params} \evalarrow \withgraph{\vres'}{\vg}
    }
  \end{mathpar}
\end{formal}

  \subsection{Comments}
  This is related to \identr{DFWZ}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Specifications \label{chap:eval_spec}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{SemanticsRule.TopLevel \label{sec:SemanticsRule.TopLevel}}

  \subsection{Prose}
  The evaluation of a specification \texttt{ast} is $\vres$ or an error
  and all of the following apply:
  \begin{itemize}
  \item \texttt{ast} is \texttt{ast} modified to add the standard library;
  \item \texttt{ast\_typed, static\_env} is the result of typing \texttt{ast};
  \item \texttt{genv} is the global environment built using \texttt{static\_env} and evaluating the global constants in \texttt{ast\_typed} following the Directed Acyclic Graph of their definitions;
  \item $\vres$ is the result of evaluating the function ``\texttt{main}, without any argument, in \texttt{genv};
  \item One of the following applies:
        \begin{itemize}
	\item $\vres$ is a value $\vv$, or
	\item All of the following apply:
              \begin{itemize}
              \item $\vres$ is an implicitly thrown exception;
	      \item An error ``\texttt{Uncaught exception: implicitly thrown out of a try-catch}'' is returned;
              \end{itemize}
	\item All of the following apply:
              \begin{itemize}
              \item $\vres$ is an exception \texttt{exn} with an associated type \texttt{ty};
	      \item An error ``\texttt{Uncaught exception: \{ty\} \{exn\}}'' is returned.
              \end{itemize}
        \end{itemize}
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\TopLevelBegin, lastline=\TopLevelEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  The helper relation $\topologicaldecls(\overname{\decl^*}{\parsedspec}, \overname{\decl^*}{\parsedstd})$
  accepts a specification and returns the subset of global storage declarations ordered by
  dependency order.
  The relation
  \[
    \evalglobals(\overname{\decl^*}{\vdecls}, (\overname{\overname{\envs}{\env} \times \overname{\XGraphs}{\vgone}}{\envm}))
    \;\aslrel\; \overname{(\envs \times \XGraphs)}{C} \cup \overname{\TError}{\ErrorConfig}
  \]
  updates the input environment and execution graph by initializing the global storage declarations,
  either from their initializing expression or from the base value defined for their type~\ref{sec:basevalue}.

  \begin{mathpar}
    \inferrule{
      \vdecls \eqname \emptylist
    }
    {
      \evalglobals(\vdecls, \envm) \evalarrow \envm
    }
    \and
    \inferrule{
      \vdecls \eqname [\vd] + \vdecls'\\
      \vd = \texttt{D\_GlobalStorage}(\{ \text{initial\_value}=\langle\ve\rangle, \text{name=}\name, \text{ty}=\vt, \ldots \})\\
      \envm \eqname (\env, \vgone)\\
      \evalexprsef{\env, \ve} \evalarrow ((\vv, \vgtwo), \envone) \terminateas \ErrorConfig\\
      \declareglobal(\name, \vv, \env) = \envtwo\\
      \evalglobals(\vdecls', (\envtwo, \ordered{\vgone}{\aslpo}{ \vgtwo })) \evalarrow C
    }
    {
      \evalglobals(\vdecls, \envm) \evalarrow C
    }
    \and
    \inferrule{
      \vdecls \eqname [\vd] + \vdecls'\\
      \vd = \texttt{D\_GlobalStorage}(\{ \text{initial\_value}=\None, \text{name=}\name, \text{ty}=\vt, \ldots \})\\
      \envm \eqname (\env, \vgone)\\
      \basevalue(\env, \vt) \evalarrow (\vv, \vgtwo) \terminateas \ErrorConfig\\
      \declareglobal(\name, \vv, \env) = \envtwo\\
      \evalglobals(\vdecls', (\envtwo, \ordered{\vgone}{\aslpo}{ \vgtwo })) \evalarrow C
    }
    {
      \evalglobals(\vdecls, \envm) \evalarrow C
    }
  \end{mathpar}

  The helper relation
  \[
    \buildgenv(\overname{\envs}{\env}, \overname{\spec}{\typedspec}) \;\aslrel\;
    (\overname{\envs}{\newenv}\times\overname{\XGraphs}{\vg}) \cup \TError
  \]
  ``populates'' the environment and output execution graph with the global
  storage declarations.
  This works by traversing the global storage declarations in \emph{dependency order}
  and updating the environment accordingly. By dependency order, we mean that if
  a declaration $b$ refers to an identifier declared in $a$ then $a$ is evaluated
  before $b$.

  \begin{mathpar}
    \inferrule{
      \topologicaldecls(\typedspec) \evalarrow \vdecls\\
      \evalglobals(\vdecls, (\env, \emptygraph)) \evalarrow (\newenv, \vg) \terminateas \ErrorConfig
    }
    {
      \buildgenv(\env, \typedspec) \evalarrow (\newenv, \vg)
    }
  \end{mathpar}

  The relation
  \[
    \evalspec{\overname{\spec}{\parsedast}, \overname{\spec}{\parsedstd}} \;\aslrel\;
     ((\overname{\vals}{\vv}\times \overname{\XGraphs}{\vg}) \cup \TError)
  \]
  evaluates the \texttt{main} function in a given specification and standard library.
  The function $\texttt{annotate\_spec}$, which is defined in the typing reference~\cite{ASLTypingReference},
  takes an initial typing environment and a parsed AST and returns a corresponding typed AST and typing
  environment.

  \begin{mathpar}
  \inferrule{
    \parsedast = \parsedspec + \parsedstd\\
    \texttt{annotate\_spec}(\emptytenv, \parsedast) = (\typedspec,\tenv)\\
    \buildgenv(\typedspec) \evalarrow (\env, \vgone) \terminateas \ErrorConfig\\
    \evalsubprogram{\env, \texttt{"main"}, \emptylist, \emptylist} \evalarrow \Normal([(\vv, \vgtwo)], \Ignore) \terminateas \ErrorConfig\\
    \vg = \ordered{\vgone}{\aslpo}{\vgtwo}
  }
  {
    \evalspec{\parsedast, \parsedstd} \evalarrow (\vv, \vg)
  }
  \and
  \inferrule{
    \parsedast = \parsedspec + \parsedstd\\
    \texttt{annotate\_spec}(\emptytenv, \parsedast) = (\typedspec,\tenv)\\
    \buildgenv(\typedspec, (\tenv, (\emptyfunc, \emptyfunc))) \evalarrow (\env, \vgone)\\
    \evalsubprogram{\env, \texttt{"main"}, \emptylist, \emptylist} \evalarrow \Throwing(\texttt{v\_opt}, \Ignore)
  }
  {
    \evalspec{\parsedspec, \parsedstd} \evalarrow \Error(\texttt{"Uncaught exception!"})
  }
\end{mathpar}
Notice that when the type-checker fails due to a type error in the given specification,
the corresponding premise in the rule above does not hold, and the semantics
is undefined. Indeed, this semantics is only defined for well-typed specifications.
\end{emptyformal}

\isempty{\subsection{Comments}}

\bibliographystyle{plain}
\bibliography{ASL}
\end{document}
