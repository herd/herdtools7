\chapter{Specifications\label{chap:Specifications}}
\hypertarget{def-specificationterm}{}
Specifications are grammatically derived from $\Nspec$ and represented as ASTs by \\
$\spec$.
%
Typing specifications is done by the relation $\typecheckast$, which is defined in
\TypingRuleRef{TypeCheckAST}.
%
The semantics of specifications in given by the relation $\evalspec$, which is defined in \SemanticsRuleRef{EvalSpec}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Nspec   \derives\ & \maybeemptylist{\Ndecl} &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Syntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\spec \derives\ & \decl^* &
\end{flalign*}

\ASTRuleDef{AST}
\hypertarget{build-ast}{}
The relation
\[
  \buildast : \overname{\parsenode{\Nspec}}{\vparsednode} \;\aslrel\; \overname{\spec}{\vastnode}
\]
transforms an $\Nspec$ node $\vparsednode$ into an AST specification node $\vastnode$.

We define this function for subprogram declarations, type declarations, and global storage declarations in the corresponding chapters.

\begin{mathpar}
\inferrule[ast]{
    \buildlist[\builddecl](\vdecls) \astarrow \vdeclsone \\
    \concatlist(\vdeclsone) \astarrow \vadecls
}{
    \buildast(\overname{\Nspec(\namednode{\vdecls}{\maybeemptylist{\Ndecl}})}{\vparsednode}) \astarrow \overname{\vadecls}{\vastnode}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typing Specifications\label{sec:TypingSpecifications}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The untyped AST of an ASL specification consists of a list of global declarations.
Typechecking the untyped AST succeeds if all declarations can be successfully annotated,
which is achieved via \TypingRuleRef{TypeCheckAST}. Otherwise, the result is a
\typingerrorterm{}.

We note that whether typechecking a specification succeeds or fails with a type
error, does not depend on the order in which the declarations appear in the specification.
That is, if typechecking a specification with one ordering of its declarations leads to
a \typingerrorterm{}, then typechecking that specification with any other ordering of its
declarations also leads to a \typingerrorterm{}, but the \typingerrorsterm{} may not be the same
(since there may be two erroneous declarations and the \typingerrorterm{} returned
depends on which declaration is processed first).

When typechecking declarations, it is important to process them in a certain order,
to avoid false \typingerrorsterm{} resulting from typechecking a declaration that uses an identifier
before a declaration that defines it.
This order relies on the notion of \defusedependencyterm, which we formally define in
\secref{Dependencies}.
\secref{TopologicalOrdering} formally defines how to use the inferred \defusedependenciesterm\ to
order the declarations such that false \typingerrorsterm{} are avoided.
\identi{LWQQ}

\TypingRuleDef{TypeCheckAST}
\hypertarget{def-typecheckast}{}
The relation
\[
\typecheckast(
  \overname{\globalstaticenvs}{\genv} \aslsep
  \overname{\decl^*}{\decls}
) \aslrel
(\overname{\decl^*}{\newdecls} \times \overname{\staticenvs}{\newtenv})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of declarations $\decls$ in an input global static environment $\genv$,
yielding an output static environment $\newtenv$ and annotated list of declarations $\newdecls$.
\ProseOtherwiseTypeError

\ExampleDef{Typechecking a List of Global Declarations}
The specification in \listingref{TypeCheckAST} contains numerous global declarations.

\ASLListing{Typechecking a list of global declarations}{TypeCheckAST}{\typingtests/TypingRule.TypecheckAST.asl}

The typechecker first processes subprogram overrides. Since there are none in this specification,
the list of global subprogram declarations remains the same.
The global declarations are separated into the list of pragmas --- \verb|pragma1| --- and the remaining
global declarations.

The \dependencygraphterm{} for this specifications contains a node for each one of
$\vWORDSIZE$, $\MyRecord$, $\vmain$,
$\Color$, $\RED$, $\GREEN$, $\BLUE$,
$\rotatecolor$, $\rotatezero$, $\rotateone$, $\vg$,
and the following edges
\[
\begin{array}{rcl}
  (\Other(\MyRecord)    &,& \Other(\vWORDSIZE))\\
  (\Other(\MyRecord)    &,& \Other(\Color))\\
  (\Other(\RED)       &,& \Other(\Color))\\
  (\Other(\GREEN)       &,& \Other(\Color))\\
  (\Other(\BLUE)       &,& \Other(\Color))\\
  (\Other(\vg)       &,& \Other(\MyRecord))\\
  (\Subprogram(\vmain)  &,& \Other(\vg))\\
  (\Subprogram(\vmain)  &,& \Subprogram(\rotatezero))\\
  (\Subprogram(\rotatecolor)   &,& \Other(\Color))\\
  (\Subprogram(\rotatecolor)   &,& \Other(\RED))\\
  (\Subprogram(\rotatecolor)   &,& \Other(\GREEN))\\
  (\Subprogram(\rotatecolor)   &,& \Other(\BLUE))\\
  (\Subprogram(\rotatezero)    &,& \Other(\Color))\\
  (\Subprogram(\rotatezero)    &,& \Other(\rotatecolor))\\
  (\Subprogram(\rotatezero)    &,& \Other(\rotateone))\\
  (\Subprogram(\rotateone)     &,& \Other(\Color))\\
  (\Subprogram(\rotateone)     &,& \Other(\rotatecolor))\\
  (\Subprogram(\rotateone)     &,& \Other(\rotatezero))\\
\end{array}
\]

Constructing the strongly-connected components for this graph with its edges reversed,
and topologically ordering the strongly-connected yields the following list of
components:
\[
\begin{array}{l}
  \{ \Other(\vWORDSIZE) \},\\
  \{ \Other(\MyRecord) \},\\
  \{ \Other(\vg) \},\\
  \{ \Other(\Color) \},\\
  \{ \Other(\RED) \},\\
  \{ \Other(\GREEN) \},\\
  \{ \Other(\BLUE) \},\\
  \{ \Subprogram(\rotatecolor) \},\\
  \{ \Subprogram(\rotatezero), \Subprogram(\rotateone) \},\\
  \{ \Subprogram(\vmain) \}
\end{array}
\]
The only non-trivial component (that is, a component with more than a single global declaration)
is $\{ \Subprogram(\rotatezero), \Subprogram(\rotateone) \}$, since these are the only
mutually-recursive subprograms in this specification.

The typechecker annotates each strongly-connected component listed above,
and finally checks that the pragma \verb|pragma pragma1;| is well-typed, which it is.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseoverridesubprograms{} in $\decls$ yields $\declsp$;
  \item splitting $\declsp$ into two sublists by testing each declaration to check whether
        it is that of a pragma yields $\pragmas$ and $\others$, respectively;
  \item \Prosebuilddependencies{\others}{$(\defs, \dependencies)$};
  \item define $\reverseddependencies$ as the relation $\dependencies$ with its elements in reversed order.
        That is, if $(a,b)$ is in $\dependencies$ then $\reverseddependencies$ contains $(b, a)$.
        The reversal is necessary, since we want to check a declaration $b$ before any declaration $a$
        that depends on it;
  \item \ProseSCC{$\defs$}{$\reverseddependencies$}{$\comps$};
  \item \Prosetopologicalorderingcomps{$\comps$}{$\reverseddependencies$}{$\orderedcomps$};
  \item transforming each component, which is a set, into a list, yields $\compdecls$.
        That is, $\compdecls$ is a list of lists where each sublist corresponds to one
        strongly connected component;
  \item \Proseannotatedeclcomps{$\genv$}{$\compdecls$}{$\newdecls$}{$\newtenv$\ProseOrTypeError}.
  \item for each $\vd$ in $\pragmas$, \Prosecheckglobalpragma{$\newtenv$}{$\vd$}\ProseOrTypeError;
  \item $\pragmas$ is ignored;
\end{itemize}
\CodeSubsection{\TypeCheckASTBegin}{\TypeCheckASTEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \overridesubprograms(\decls) \typearrow \declsp \OrTypeError \\\\
  \pragmas \eqdef [\ \vd \;|\; \vd \in \declsp\ \land \astlabel(\vd) = \DPragma\ ]\\
  {
  \others \eqdef \left[ \begin{array}{r|l}
    \vd & \vd \in \declsp\ \land \astlabel(\vd) \neq \DPragma
  \end{array}\right]
  }\\
  \builddependencies(\others) \typearrow (\defs, \dependencies)\\
  \reverseddependencies \eqdef [(a,b) \in \dependencies: (b,a)]\\
  \SCC(\defs, \reverseddependencies) = \comps\\
  \orderedcomps \in \topologicalorderingcomps(\comps, \reverseddependencies)\\
  \compdecls \eqdef [ \vc\in\orderedcomps: \listset(\vc) ]\\
  \annotatedeclcomps(\genv, \compdecls) \typearrow (\newdecls, \newtenv) \OrTypeError \\\\
  \vd\in\pragmas: \checkglobalpragma(\newtenv, \vd) \typearrow \True \OrTypeError
}{
  \typecheckast(\genv, \decls) \typearrow (\newdecls, \newtenv)
}
\end{mathpar}

\TypingRuleDef{AnnotateDeclComps}
\hypertarget{def-annotatedeclcomps}{}
The function
\[
\annotatedeclcomps(\overname{\globalstaticenvs}{\genv} \aslsep \overname{(\decl^*)^*}{\comps})
\aslto
(\overname{\globalstaticenvs}{\newgenv} \times \overname{\decl^*}{\newdecls})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of declaration components $\comps$
(a list of lists) in the global static environment $\genv$,
yielding the annotated list of declarations $\newdecls$ and modified global static environment $\newgenv$.
\ProseOtherwiseTypeError

We note that a strongly-connected component containing just a single declaration may contain
any kind of global declaration ---
a type declaration, a global storage declaration, or a subprogram declaration ---
whereas a strongly-connected component containing multiple declarations must be checked
to contain only subprograms. This is because the only type of mutually-recursive declarations
allows in ASL are between subprograms. The rules below handle these cases separately (\textsc{single}
for single declarations and \textsc{mutually\_recursive} for more than one declaration).

\ExampleDef{Annotating Strongly-connected Components of Declarations}
In \ExampleRef{Typechecking a List of Global Declarations},
each declaration is in its own strongly-connected component,
except for $\{ \Subprogram(\rotatezero), \Subprogram(\rotateone) \}$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\comps$ is the empty list;
    \item define $\newgenv$ as $\tenv$;
    \item define $\newdecls$ as the empty list.
  \end{itemize}

  \item \AllApplyCase{single}
  \begin{itemize}
    \item $\comps$ is a list with \head\ $\comp$ and \tail\ $\compsone$;
    \item $\comp$ is a single declaration $\vd$;
    \item applying $\typecheckdecl$ to $\vd$ in $\genv$ yields $(\vdone, \genvone)$\ProseOrTypeError;
    \item applying $\annotatedeclcomps$ to $\compsone$ in $\genvone$ yields \\ $(\newgenv, \declsone)$\ProseOrTypeError;
    \item define $\newdecls$ as the list with \head\ $\vdone$ and \tail\ $\declsone$.
  \end{itemize}

  \item \AllApplyCase{mutually\_recursive}
  \begin{itemize}
    \item $\comps$ is a list with \head\ $\comp$ and \tail\ $\compsone$;
    \item $\comp$ is a list with more than one declaration (that is, a list of mutually-recursive declarations);
    \item applying $\typecheckmutuallyrec$ to $\comp$ in $\genv$ yields \\ $(\declsone, \genvone)$\ProseOrTypeError;
    \item applying $\annotatedeclcomps$ to $\compsone$ in $\genvone$ yields \\ $(\newgenv, \declstwo)$\ProseOrTypeError;
    \item define $\newdecls$ as the concatenation of $\declsone$ and $\declstwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotatedeclcomps(\genv, \overname{\emptylist}{\comps}) \aslto (\overname{\genv}{\newgenv}, \overname{\emptylist}{\newdecls})
}
\end{mathpar}

\begin{mathpar}
\inferrule[single]{
  \comp = [\vd]\\
  \typecheckdecl(\genv, \vd) \typearrow (\vdone, \genvone) \OrTypeError\\\\
  \annotatedeclcomps(\genvone, \compsone) \typearrow (\newgenv, \declsone) \OrTypeError
}{
  \annotatedeclcomps(\genv, \overname{[\comp] \concat \compsone}{\comps}) \aslto
  (\newgenv, \overname{[\vdone] \concat \declsone}{\newdecls})
}
\end{mathpar}

\begin{mathpar}
\inferrule[mutually\_recursive]{
  |\comp| > 1\\
  \typecheckmutuallyrec(\genv, \comp) \typearrow (\declsone, \genvone) \OrTypeError\\\\
  \annotatedeclcomps(\genvone, \compsone) \typearrow (\newgenv, \declstwo) \OrTypeError
}{
  \annotatedeclcomps(\genv, \overname{[\comp] \concat \compsone}{\comps}) \aslto
  (\newgenv, \overname{\declsone \concat \declstwo}{\newdecls})
}
\end{mathpar}

\TypingRuleDef{TypeCheckMutuallyRec}
\hypertarget{def-typecheckmutuallyrec}{}
The function
\[
  \typecheckmutuallyrec(
    \overname{\globalstaticenvs}{\genv} \aslsep
    \overname{\decl^*}{\decls}
  )
  \aslto
  (
    \overname{\decl^*}{\newdecls} \times
    \overname{\globalstaticenvs}{\newgenv}
  )
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of mutually recursive declarations
$\decls$ in the global static environment $\genv$,
yielding the annotated list of subprogram declarations $\newdecls$
and modified global static environment $\newgenv$.

\ExampleDef{Checking Mutually-recursive Declarations}
In \ExampleRef{Typechecking a List of Global Declarations},
the strongly-connected component \\
$\{ \Subprogram(\rotatezero), \Subprogram(\rotateone) \}$
contains only subprogram declarations.

In the specification in \listingref{TypeCheckMutuallyRec-bad},
the global storage element \verb|g| is defined in terms of the
subprogram \verb|foo|, which is defined in terms of \verb|g|.
%
Technically, the \dependencygraphterm{} contains the strongly-connected
component $\{\Other(\vg), \Subprogram(\foo)\}$.
%
Since mutual recursion is allowed only between subprograms,
this specification is ill-typed.

\ASLListing{Illegal recursion among global declarations}{TypeCheckMutuallyRec-bad}{\typingtests/TypingRule.TypeCheckMutuallyRec.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item checking that each declaration in $\vd$ is a subprogram declaration yields $\True$\ProseTerminateAs{\BadDeclaration};
  \item applying $\annotatefuncsig$ to each node $\vf$ in $\genv$, where $\DFunc(\vf)$ is a declaration in $\decls$,
        yields $(\tenv_\vf, \vd_\vf, \vses_\vf)$\ProseOrTypeError;
  \item define $\envandfsone$ as the list of pairs, each consisting of the local environment component of $\tenv_\vf$
        the annotated subprogram $\vd_\vf$, and the \sideeffectsetterm\ $\vses_\vf$, for each subprogram declaration $\DFunc(\vf)$ in $\decls$;
  \item applying $\declaresubprograms$ to $\genv$ and $\envandfsone$ yields \\
        $(\genvtwo, \envandfstwo)$\ProseOrTypeError;
  \item for tuple in $\envandfstwo$ consisting of a local static environment, an element of $\func$,
        and a \sideeffectsetterm, $(\lenvtwo, \vf, \vses_\vf)$,
        applying $\annotatesubprogram$ to $\vf$ and $\vses_\vf$ in the static environment \\
        $(\genvtwo, \lenvtwo)$ yields $(\vnew_\vf, \vsesp_\vf)$\ProseOrTypeError;
  \item define $\newdecls$ as the list of $\DFunc(\vnew_\vf)$ for all $(\Ignore, \vf, \Ignore)$ in $\envandfstwo$;
  \item define $\vsess$ as the list of $(\vnew_\vf, \vsesp_\vf)$ for all $(\Ignore, \vf, \Ignore)$ in $\envandfstwo$;
  \item applying $\propagaterecursivecallssess$ on $\vsess$ yields $\vsessprop$;
  \item define $\tenvtwo$ as the environment with $\genvtwo$ as its static global environment
        and an empty static local environment;
  \item applying $\addsubprogramdecls$ to $\tenvtwo$ and $\vsessprop$ yields $\tenvthree$;
  \item define $\newtenv$ as the global static environment of $\tenvthree$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vd\in\decls: \checktrans{\astlabel(\vd) = \DFunc}{\BadDeclaration} \typearrow \True\OrTypeError\\\\
  \DFunc(\vf)\in\decls: \annotatefuncsig(\genv, \vf) \typearrow (\tenv_\vf, \vd_\vf, \vses_\vf)\OrTypeError\\\\
  \envandfsone \eqdef [\DFunc(\vf)\in\decls: (L^{\tenv_\vf}, \vd_\vf, \vses_\vf)]\\
  \declaresubprograms(\genv, \envandfsone) \typearrow (\genvtwo, \envandfstwo) \OrTypeError\\\\
  {
    \begin{array}{r}
  (\lenvtwo, \vf, \vses_\vf)\in\envandfstwo: \annotatesubprogram((\genvtwo, \lenvtwo), \vf, \vses_\vf) \typearrow \\
      (\vnew_\vf, \vsesp_\vf) \OrTypeError
    \end{array}
  }\\\\
  \newdecls \eqdef [(\Ignore, \vf, \Ignore)\in\envandfstwo: \DFunc(\vnew_\vf)]\\
  \vsess \eqdef [(\Ignore, \vf, \Ignore)\in\envandfstwo: (\vnew_\vf, \vsesp_\vf)]\\
  \propagaterecursivecallssess(\vsess) \typearrow \vsessprop\\
  \tenvtwo \eqdef (\genvtwo, \emptyfunc)\\
  \addsubprogramdecls(\tenvtwo, \vsessprop) \typearrow \tenvthree
}{
  \typecheckmutuallyrec(\genv, \decls) \typearrow (\newdecls, \overname{G^\tenvthree}{\newgenv})
}
\end{mathpar}
\CodeSubsection{\TypeCheckMutuallyRecBegin}{\TypeCheckMutuallyRecEnd}{../Typing.ml}

\TypingRuleDef{CheckGlobalPragma}
\hypertarget{def-checkglobalpragma}{}
The function
\[
  \checkglobalpragma(
    \overname{\globalstaticenvs}{\genv} \aslsep
    \overname{\decl}{\vd}
  )
  \aslto
  \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
typechecks a global pragma declaration $\vd$ in the global static environment $\genv$,
yielding $\True$.
\ProseOtherwiseTypeError

\ExampleDef{Checking Global Pragmas}
The specification in \listingref{CheckGlobalPragma} shows a well-typed global pragma,
whereas the specification in \listingref{CheckGlobalPragma-bad} shows an ill-typed
global pragma where the expression \verb|x| is ill-typed, since the identifier \verb|x|
is undefined and the expression \verb|(2==3.0)| uses the operator \verb|==|
without matching any operation.
\ASLListing{A well-typed global pragma}{CheckGlobalPragma}{\typingtests/TypingRule.CheckGlobalPragma.asl}
\ASLListing{An ill-typed global pragma}{CheckGlobalPragma-bad}{\typingtests/TypingRule.CheckGlobalPragma.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vd$ is a global pragma declaration with any identifier and expression list $\vargs$. that is, $\DPragma(\Ignore, \vargs)$;
  \item applying $\withemptylocal$ to $\genv$ yields $\tenv$;
  \item applying $\annotateexprlist$ to $\vargs$ in $\tenv$ yields $\vargsp$ \ProseOrTypeError;
  \item $\vargsp$ is ignored;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \withemptylocal(\genv) \typearrow \tenv \\
  \annotateexprlist(\tenv, \vargs) \typearrow \vargsp \OrTypeError \\
}{
  \checkglobalpragma(\genv, \overtext{\DPragma(\Ignore, \vargs)}{\vd}) \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckGlobalPragmaBegin}{\CheckGlobalPragmaEnd}{../Typing.ml}

\TypingRuleDef{DeclareSubprograms}
\hypertarget{def-declaresubprograms}{}
The function
\[
\begin{array}{r}
  \declaresubprograms(
    \overname{\globalstaticenvs}{\genv} \aslsep
    \overname{(\localstaticenvs\times\func)^*}{\envandfs}
  ) \aslto \\
  \overname{\globalstaticenvs}{\newgenv} \times
  \overname{(\localstaticenvs\times\func\times\TSideEffectSet)^*}{\newenvandfs}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
processes a list of pairs, each consisting of a local static environment and a subprogram declaration, $\envandfs$,
in the context of a global static environment $\genv$,
declaring each subprogram in the environment consisting of $\genv$ and the static local environment associated with
each subprogram.
The result is a modified global static environment $\newgenv$ and list of tuples $\newenvandfs$
consisting of local static environment, annotated $\func$ AST node, and \sideeffectdescriptorsetsterm.

\ExampleDef{Updating Static Environments for Subprogram Declarations}
Applying $\declaresubprograms$ for the subprogram declarations in \listingref{DeclareSubprograms}
adds the following bindings to the $\overloadedsubprograms$ map
\[
\begin{array}{rcl}
  \flipbits &\mapsto& \{\flipbits\} \\
  \addten    &\mapsto& \{\addten, \addtenone\} \\
  \factorial  &\mapsto& \{\factorial\} \\
\end{array}
\]
and updates the $\subprograms$ map by binding
strings representing unique subprogram names to the $\func$ nodes corresponding to
the subprogram signatures:
\begin{center}
\begin{tabular}{ll}
\textbf{string}     & \textbf{signature}\\
\texttt{flip\_bits} & \verb|func flip_bits{N}(bv: bits(N)) => bits(N)|\\
\texttt{add\_10}    & \verb|func add_10(x: real) => real|\\
\texttt{add\_10-1}  & \verb|func add_10(x: integer) => integer|\\
\texttt{factorial}  & \verb|func factorial(x: integer) => integer recurselimit 100|
\end{tabular}
\end{center}

Using the name \texttt{add\_10-1} for \verb|func add_10(x: integer) => integer|
and \texttt{add\_10} for \verb|func add_10(x: real) => real|, rather than
the other way around is due to the arbitrary choice of a topological ordering
of the subprogram declarations.

\ASLListing{Updating static environments for subprogram declarations}{DeclareSubprograms}{\typingtests/TypingRule.DeclareSubprograms.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\envandfs$ is the empty list;
    \item define $\newgenv$ as $\genv$;
    \item define $\newenvandfs$ as the empty list.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\envandfs$ is the list with \head\ $(\lenv, \vf, \vsesf)$ and \tail\ $\envandfsone$;
    \item define $\tenv$ as the environment where the global environment component is $\genv$ and the local environment component is $\lenv$;
    \item applying $\declareonefunc$ to $\vf$ in $\tenv$ yields $(\tenvone, \vfone)$\ProseOrTypeError;
    \item applying $\declaresubprograms$ to the global environment of $\tenvone$ and \\
          $\envandfsone$ yields $(\newgenv, \envandfstwo)$\ProseOrTypeError;
    \item define $\newenvandfs$ as the list with \head\ $(\lenv, \vfone, \vsesf)$ and \tail\ $\envandfstwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \declaresubprograms(\genv, \overname{\emptylist}{\envandfs}) \typearrow
   (\overname{\genv}{\newgenv}, \overname{\emptylist}{\newenvandfs})
}
\and
\inferrule[non\_empty]{
  \tenv \eqname (\genv, \lenv)\\
  \declareonefunc(\tenv, \vf) \typearrow (\tenvone, \vfone) \OrTypeError\\\\
  \declaresubprograms(G^\tenvone, \envandfsone) \typearrow (\newgenv, \envandfstwo) \OrTypeError\\\\
  \newenvandfs \eqdef [(\lenv, \vfone, \vsesf)] \concat \envandfstwo
}{
  \declaresubprograms(\genv, \overname{[(\lenv, \vf, \vsesf)]\concat\envandfsone}{\envandfs}) \typearrow (\overname{\genv}{\newgenv}, \newenvandfs)
}
\end{mathpar}

\TypingRuleDef{AddSubprogramDecls}
\hypertarget{def-addsubprogramdecls}{}
The function
\[
  \addsubprogramdecls(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\func\times\TSideEffectSet)^*}{\vfuncs}
  ) \aslto
  \overname{\staticenvs}{\newtenv}
\]
adds each subprogram definition given by a $\func$ AST node in $\vfuncs$
to the $\subprograms$ map of $G^\tenv$, yielding $\newtenv$.

\ExampleDef{Adding Subprogram Declarations}
The specification in \listingref{AddSubprogramDecls}
contains two subprogram declarations,
which are added to the static environment.
The subprogram with the \integertypeterm{} argument is named \verb|increment|
and the subprogram with the \realtypeterm{} argument is named \verb|increment-1|.
\ASLListing{Adding subprogram declarations}{AddSubprogramDecls}{\typingtests/TypingRule.AddSubprogramDecls.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vfuncs$ is the empty list;
    \item $\newtenv$ is $\tenv$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vfuncs$ is the list with \head\ $(\vf, \vsesf)$ and \tail\ $\vfuncsone$;
    \item applying $\addsubprogram$ to $\vf.\funcname$, $\vf$, and $\vsesf$ in $\tenv$ yields $\tenvone$;
    \item applying $\addsubprogramdecls$ to $\tenvone$ and $\vfuncsone$ yields $\newtenv$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \addsubprogramdecls(\tenv, \overname{\emptylist}{\vfuncs}) \typearrow \overname{\tenv}{\newtenv}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \addsubprogram(\tenv, \vf.\funcname, \vf, \vsesf) \typearrow \tenvone\\
  \addsubprogramdecls(\tenvone, \vfuncsone) \typearrow \newtenv
}{
  \addsubprogramdecls(\tenv, \overname{[(\vf, \vsesf)] \concat \vfuncsone}{\vfuncs}) \typearrow
  \newtenv
}
\end{mathpar}

\TypingRuleDef{PropagateRecursiveCallsSess}
\hypertarget{def-propagaterecursivecallssess}{}
The helper relation
\[
\propagaterecursivecallssess(\overname{(\func\times\TSideEffectSet)^*}{\vsess})
\aslrel
\overname{(\func\times\TSideEffectSet)^*}{\vsessnew}
\]
accepts a list that associates $\func$ AST nodes to \sideeffectdescriptorsetsterm\ and
generates a list that associates each $\func$ AST nodes to the union of all
\sideeffectdescriptorsterm\ associated with the
recursive functions it may transitively call.

We assume each $\func$ AST node occurs in exactly one pair of $\vsess$.

\ExampleDef{Propagating Recursive Call Side Effects}
Consider the specification in \listingref{PropagateRecursiveCallsSess}.
\ASLListing{Propagating recursive call side effects}{PropagateRecursiveCallsSess}{\typingtests/TypingRule.PropagateRecursiveCallsSess.asl}

\TypingRuleRef{TypeCheckMutuallyRec} applies $\propagaterecursivecallssess$
to the following subprograms and their associated \sideeffectdescriptorsterm{} are inferred for each subprogram
separately ($\funcidtoses$ in the rules below):
\begin{center}
\[
\left[
\begin{array}{ll}
\countgone, &  \left\{\begin{array}{l}
                \ReadGlobal(\vgone, \timeframeexecution, \False),\\
                \WriteGlobal(\vgone),\\
                \RecursiveCall(\countgtwo)
                \end{array}\right\}\\
&,\\
\countgtwo, & \left\{\begin{array}{l}
                \ReadGlobal(\vgtwo, \timeframeexecution, \False),\\
                \WriteGlobal(\vgtwo),\\
                \ReadGlobal(\vgthree, \timeframeexecution, \False),\\
                \RecursiveCall(\vgone)\\
                \end{array}\right\}
\end{array}
\right]
\]
\end{center}

$\propagaterecursivecallssess$ then infers the following relation between the subprograms
based on their associated \sideeffectdescriptorsetsterm{} ($\callgraph$ in the rules below):
\begin{center}
\begin{tabular}{lcl}
$(\countgone$   &,& $\countgtwo)$\\
$(\countgtwo$   &,& $\countgone)$
\end{tabular}
\end{center}

$\propagaterecursivecallssess$ then computes the transitive closure of the relation above
($\transitivecallgraph$ in the rules below):
\begin{center}
\begin{tabular}{lcl}
$(\countgone$   &,& $\countgone)$\\
$(\countgone$   &,& $\countgtwo)$\\
$(\countgtwo$   &,& $\countgone)$\\
$(\countgtwo$   &,& $\countgtwo)$
\end{tabular}
\end{center}

Then, the \sideeffectdescriptorterm{} are accumulated, excluding \RecursiveCallTerms,
which yields the final result:
\begin{center}
\[
\left[
\begin{array}{ll}
\countgone, &  \left\{\begin{array}{l}
                \ReadGlobal(\vgone, \timeframeexecution, \False),\\
                \WriteGlobal(\vgone),\\
                \ReadGlobal(\vgtwo, \timeframeexecution, \False),\\
                \WriteGlobal(\vgtwo),\\
                \ReadGlobal(\vgthree, \timeframeexecution, \False),\\
                \WriteGlobal(\vgthree),\\
                \end{array}\right\}\\
&,\\
\countgtwo, & \left\{\begin{array}{l}
                \ReadGlobal(\vgone, \timeframeexecution, \False),\\
                \WriteGlobal(\vgone),\\
                \ReadGlobal(\vgtwo, \timeframeexecution, \False),\\
                \WriteGlobal(\vgtwo),\\
                \ReadGlobal(\vgthree, \timeframeexecution, \False),\\
                \WriteGlobal(\vgthree),\\
                \end{array}\right\}
\end{array}
\right]
\]
\end{center}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\funcidtoses$}{the function that maps a subprogram name of $\vf$ to its associated \sideeffectdescriptorsetsterm{}
        $\vs$, for each pair $(\vf, \vs)$ in $\vsess$};
  \item \Proseeqdef{$\callgraph$}{the relation between subprogram names $\vfone$ and $\vftwo$ such that
        the \sideeffectdescriptorsetsterm{} associated with $\vfone$ includes the \RecursiveCallTerm{} for $\vftwo$};
  \item \Proseeqdef{$\transitivecallgraph$}{the transitive closure of $\callgraph$};
  \item \Proseeqdef{$\funcidtosesminusrec$}{the function where for each mapping of subprogram name $\id$
        to \sideeffectdescriptorsetsterm{} $\vs$ in $\funcidtoses$, there exists a mapping of $\id$
        to $\vs$ with all \RecursiveCallTerms{} removed};
  \item \Proseeqdef{$\callees$}{the function where for each pair $(\vf, \vses)$ in $\vsess$ there exists a mapping
        of $\vf$ to the set of subprogram names such that for each such subprogram name $\vsucc$,
        $(\vf.\funcname, \vsucc)$ is a member of $\transitivecallgraph$};
  \item \Proseeqdef{$\vsessnew$}{the list constructed from each pair $(\vf, \vs)$ in $\vsess$
        by associating $\vf$ to the union of \sideeffectdescriptorsetsterm{} given by the \sideeffectdescriptorsetsterm{}
        of $\funcidtosesminusrec(\vc)$ for each successor of $\vf$ in $\callees$, with all \RecursiveCallTerms{} removed}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \funcidtoses \eqdef \{ \vf.\funcname \mapsto \vs \;|\; (\vf, \vs) \in \vsess \}\\
  \callgraph \eqdef \{ (\vfone, \vftwo) \;|\; (\vfone, \vses) \in \funcidtoses \land \RecursiveCall(\vftwo) \in \vses\}\\
  \transitivecallgraph \eqdef \graphtransitive{\callgraph}\\
  {
  \begin{array}{l}
  \funcidtosesminusrec \eqdef \\ \{ \id \mapsto \vs \setminus \RecursiveCall(\Identifiers) \;|\; (\id, \vs) \in \funcgraph(\funcidtoses)\}
  \end{array}
  }\\
  {
  \begin{array}{l}
  \callees \eqdef \\
  \{ \vf \mapsto \{\vsucc \;|\; (\vf.\funcname, \vsucc) \in \transitivecallgraph\} \;|\; (\vf, \vses) \in \vsess \}
  \end{array}
  }\\
  {
  \begin{array}{l}
  \vsessnew \eqdef \\
  \left[ (\vf, \vs) \in \vsess :
  \left(\vf, \bigcup_{\vc \in \callees(\vf)} \funcidtosesminusrec(\vc) \setminus \RecursiveCall(\Identifiers)\right)
  \right]
  \end{array}
  }
}{
  \propagaterecursivecallssess(\vsess) \typearrow \vsessnew
}
\end{mathpar}

\section{Overriding Subprograms\label{sec:Overriding}}
This section defines how to override subprograms in a specification.
In particular, a subprogram marked by \texttt{impdef} can be overridden by a subprogram marked by \\
\texttt{implementation}.

\RequirementDef{OverridingMatch}
An overriding \Proseimplementationsubprogram{} subprogram \\
must match the overridden \Proseimpdefsubprogram{} subprogram in all of the following:
\begin{itemize}
  \item name of subprogram;
  \item number, names, types, and order of arguments;
  \item number, names, types, and order of parameters;
  \item return type.
\end{itemize}
In \ExampleRef{Overriding Subprograms}, the \verb|Foo| subprograms marked \texttt{impdef} and \texttt{implementation} match in all of the above.

\ExampleDef{Overriding Subprograms}
\listingref{overriding} shows a specification which defines \Proseimpdefsubprograms{} \verb|Foo| and \verb|Bar|.
The definition of \verb|Foo| is overridden by a corresponding \Proseimplementationsubprogram{}.
\ASLListing{Overriding subprograms}{overriding}{\definitiontests/Overriding.asl}

\noindent
Subprograms marked with \texttt{implementation} are subject to the following restrictions.

\RequirementDef{NonClashingImplementations}
No two \Proseimplementationsubprograms{} can \\
match each other according to \RequirementRef{OverridingMatch}.
In \ExampleRef{Invalid Overriding}, the \verb|Foo| subprograms marked \texttt{implementation}
match and are therefore invalid.

\RequirementDef{SingleOverrideCandidate}
Each \Proseimplementationsubprogram{} must override exactly one \Proseimpdefsubprogram.
In \ExampleRef{Invalid Overriding}, the \Proseimplementationsubprogram{} \verb|Bar| is
invalid as it has no corresponding \Proseimpdefsubprogram{}.

\ExampleDef{Invalid Overriding}
\listingref{overriding-bad} shows a specification which attempts to define clashing
\Proseimplementationsubprograms{} named \verb|Foo|, and define an
\Proseimplementationsubprogram{} \verb|Bar| without a corresponding \Proseimpdefsubprogram{}.
\ASLListing{Invalid overriding}{overriding-bad}{\definitiontests/OverridingBad.asl}

\noindent
Implementations may wish to emit user-configurable warnings to check either:
\begin{itemize}
  \item All \Proseimpdefsubprograms{} have been overridden by corresponding \Proseimplementationsubprograms{}.
  \item There are no \Proseimplementationsubprograms{}, so no \Proseimpdefsubprograms{} are overridden.
\end{itemize}

\TypingRuleDef{OverrideSubprograms}
\hypertarget{def-overridesubprograms}{}
The function
\[
\overridesubprograms(\overname{\decl^*}{\decls}) \aslto \overname{\decl^*}{\declsp}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
overrides subprograms in a list of declarations $\decls$, yielding the new list of declarations $\declsp$.
\ProseOtherwiseTypeError{}
See \ExampleRef{Overriding Subprograms} for an example of valid overriding.

\ProseParagraph
\AllApply
\begin{itemize}
  \item define $\vimpdefs$ as the sublist of \Proseimpdefsubprogram{} declarations in $\decls$;
  \item define $\vimpls$ as the sublist of implementation subprogram declarations in $\decls$;
  \item define $\vnormal$ as the sublist of remaining functions in $\decls$;
  \item \Prosecheckimplementationsunique{$\vimpls$} yields $\True$\ProseOrTypeError;
  \item \Proseprocessoverrides{$\vimpdefs$}{$\vimpls$} yields $\vimpdefsp$ and $\vdiscarded$\ProseOrTypeError;
  \item \Proserenamesubprograms{$\vdiscarded$}{$\vrenameddiscarded$};
  \item define $\voverridden$ as the concatenation of $\vimpdefsp$ and $\vimpls$;
  \item $\declsp$ is the concatenation of subprogram declarations in $\voverridden$, $\vrenameddiscarded$, and $\vnormal$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vimpdefs \eqdef [\vd : \DFunc(\vd) \in \decls \land \vd.\funcoverride = \Impdef] \\
  \vimpls \eqdef [\vd : \DFunc(\vd) \in \decls \land \vd.\funcoverride = \Implementation] \\
  \vnormal \eqdef [\vd : \DFunc(\vd) \in \decls \land \vd.\funcoverride \notin \{\Impdef, \Implementation\}] \\
  \checkimplementationsunique(\vimpls) \typearrow \True \OrTypeError \\\\
  \processoverrides(\vimpdefs, \vimpls) \typearrow (\vimpdefsp, \vdiscarded) \OrTypeError \\\\
  \renamesubprograms(\vdiscarded) \typearrow \vrenameddiscarded \\
  \voverridden \eqdef \vimpdefsp \concat \vimpls \\
  \declsp \eqdef [\DFunc(\vd) : \vd \in \voverridden] \concat [\DFunc(\vd) : \vd \in \vrenameddiscarded] \concat \vnormal
}{
  \overridesubprograms(\decls) \typearrow \declsp
}
\end{mathpar}

\TypingRuleDef{CheckImplementationsUnique}
\hypertarget{def-checkimplementationsunique}{}
The function
\[
\checkimplementationsunique(\overname{\func^*}{\vimpls}) \aslto \{\True\} \cup \TTypeError
\]
checks that the \Proseimplementationsubprograms{} $\vimpls$ have unique signatures.
\ProseOtherwiseTypeError{}
See \ExampleRef{Invalid Overriding} for an example of non-unique \Proseimplementationsubprograms{}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
    \begin{itemize}
      \item \Proseemptylist{$\vimpls$};
      \item the result is $\True$.
    \end{itemize}
  \item \AllApplyCase{non\_empty}
    \begin{itemize}
      \item $\vimpls$ is a \Proselist{$\vh$}{$\vt$};
      \item for each \Proselistrange{$i$}{$\vt$}, \Prosesignaturesmatch{$\vh$}{$\vt[i]$} yields $\False$\ProseTerminateAs{\OverridingError};
      \item \Prosecheckimplementationsunique{$\vt$} yields $\True$\ProseOrTypeError;
      \item the result is $\True$.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \checkimplementationsunique(\overname{\emptylist}{\vimpls}) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  i \in \listrange(\vt): \signaturesmatch(\vh, \vt[i]) \typearrow \False \terminateas \OverridingError \\\\
  \checkimplementationsunique(\vt) \typearrow \True \OrTypeError
}{
  \checkimplementationsunique(\overname{[\vh] \concat \vt}{\vimpls}) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{SignaturesMatch}
\hypertarget{def-signaturesmatch}{}
The function
\[
\signaturesmatch(\overname{\func}{\vfuncone} \aslsep \overname{\func}{\vfunctwo}) \aslto \Bool
\]
checks whether the signatures of subprograms $\vfuncone$ and $\vfunctwo$ match for overriding purposes.
\ProseOtherwiseTypeError{}
See \ExampleRef{Overriding Subprograms} for an example of matching signatures.

\ProseParagraph
\AllApply
\begin{itemize}
  \item checking that the names of $\vfuncone$ and $\vfunctwo$ are equal yields $\True$ \ProseTerminateAs{\False};
  \item checking that the declared arguments of $\vfuncone$ and $\vfunctwo$ are equal in both name and type yields $\True$ \ProseTerminateAs{\False};
  \item checking that the declared parameters of $\vfuncone$ and $\vfunctwo$ are equal in both name and type yields $\True$ \ProseTerminateAs{\False};
  \item checking that the return types of $\vfuncone$ and $\vfunctwo$ are equal yields $\True$ \ProseTerminateAs{\False}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule{
    \booltrans{\vfuncone.\funcname = \vfunctwo.\funcname} \booltransarrow \True \terminateas \False \\
    \equallength(\vfuncone.\funcargs, \vfunctwo.\funcargs) \typearrow \True \terminateas \False \\
    {
    \begin{array}{r}
      i \in \indices(\vfuncone.\funcargs),\;
        \vfuncone.\funcargs[i] \eqname (\idone, \ttyone),\;
        \vfunctwo.\funcargs[i] \eqname (\idtwo, \ttytwo): \\
        \booltrans{\idone = \idtwo \land \ttyone = \ttytwo} \booltransarrow \vbone_{i}
    \end{array}
    } \\
    \booltrans{\bigwedge_{i \in \indices(\vfuncone.\funcargs)} \vbone_{i}} \booltransarrow \True \terminateas \False \\
    {
    \begin{array}{r}
      i \in \indices(\vfuncone.\funcparameters), \hfill \\
        \vfuncone.\funcparameters[i] \eqname (\idone, \ttyone),\;
        \vfunctwo.\funcparameters[i] \eqname (\idtwo, \ttytwo): \hfill \\
        \booltrans{\idone = \idtwo \land \ttyone = \ttytwo} \booltransarrow \vbtwo_{i}
    \end{array}
    } \\
    \booltrans{\bigwedge_{i \in \indices(\vfuncone.\funcparameters)} \vbtwo_{i}} \booltransarrow \True \terminateas \False \\
    \booltrans{\vfuncone.\funcreturntype = \vfunctwo.\funcreturntype} \booltransarrow \True \terminateas \False
  }{
    \signaturesmatch(\vfuncone, \vfunctwo) \typearrow \True
  }
\end{mathpar}

\TypingRuleDef{ProcessOverrides}
\hypertarget{def-processoverrides}{}
The function
\[
\processoverrides(\overname{\func^*}{\vimpdefs} \aslsep \overname{\func^*}{\vimpls}) \aslto
(\overname{\func^*}{\vimpdefsp} \times \overname{\func^*}{\vdiscarded})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
overrides the \Proseimpdefsubprograms{} $\vimpdefs$ with the \Proseimplementationsubprograms{} $\vimpls$, yielding the new \Proseimpdefsubprograms{} $\vimpdefs$ and the discarded subprograms $\vdiscarded$.
\ProseOtherwiseTypeError{}
See \ExampleRef{Overriding Subprograms} for an example of valid replacement of an \Proseimplementationsubprogram{}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
    \begin{itemize}
      \item \Proseemptylist{$\vimpls$};
      \item $\vimpdefsp$ is $\vimpdefs$;
      \item $\vdiscarded$ is the empty list.
    \end{itemize}
  \item \AllApplyCase{non\_empty}
    \begin{itemize}
      \item $\vimpls$ is a \Proselist{$\vh$}{$\vt$};
      \item for each \Proselistrange{$i$}{$\vimpdefs$}, \Prosesignaturesmatch{$\vh$}{$\vimpdefs[i]$} yields $\vb_i$;
      \item define $\vmatching$ as the sublist of $\vimpdefs$ for which $\vb_i$ is $\True$;
      \item define $\vnonmatching$ as the sublist of $\vimpdefs$ for which $\vb_i$ is $\False$;
      \item \Prosechecktrans{the length of $\vmatching$ is 1}{\OverridingError};
      \item \Proseprocessoverrides{$\vimpls$}{$\vnonmatching$} yields $\vimpdefsp$ and $\vdiscardedp$;
      \item define $\vdiscarded$ as the concatenation of $\vmatching$ and $\vdiscardedp$.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \processoverrides(\vimpdefs, \overname{\emptylist}{\vimpls}) \typearrow (\overname{\vimpdefs}{\vimpdefsp}, \emptylist)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  i \in \listrange(\vimpdefs): \signaturesmatch(\vh, \vimpdefs[i]) \typearrow \vb_i \\
  \vmatching \eqdef [\vimpdefs[i] \;|\; i \in \listrange(\vimpdefs) \land \vb_i = \True] \\
  \vnonmatching \eqdef [\vimpdefs[i] \;|\; i \in \listrange(\vimpdefs) \land \vb_i = \False] \\
  \checktrans{\listlen{\vmatching} = 1}{\OverridingError} \checktransarrow \True \terminateas \OverridingError \\\\
  \processoverrides(\vnonmatching, \vt) \typearrow (\vimpdefsp, \vdiscardedp)
  \vdiscarded \eqdef \vmatching \concat \vdiscardedp
}{
  \processoverrides(\vimpdefs, \overname{[\vh] \concat \vt}{\vimpls}) \typearrow (\vimpdefsp, \vdiscarded)
}
\end{mathpar}

\TypingRuleDef{RenameSubprograms}
\hypertarget{def-renamesubprograms}{}
The function
\[
\renamesubprograms(\overname{\func^*}{\vdiscarded}) \aslto \overname{\func^*}{\vrenameddiscarded}
\]
renames the subprograms $\vdiscarded$ to give them fresh names.

\ExampleDef{Typechecking overridden subprograms}
The specification in \listingref{RenameSubprograms} contains an ill-typed \Proseimpdefsubprogram{} that is overridden.
This is given a fresh name by $\renamesubprograms$, so that it is still typechecked but never referred to in the resulting specification.
In particular, though the ill-typed subprogram is overridden and will not be used in the annotated specification, it still results in a
\typingerrorterm.
\ASLListing{Typechecking an overridden subprogram}{RenameSubprograms}{\typingtests/TypingRule.RenameSubprograms.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
    \begin{itemize}
      \item \Proseemptylist{$\vdiscarded$};
      \item the result is the empty list.
    \end{itemize}
  \item \AllApplyCase{non\_empty}
    \begin{itemize}
      \item $\vdiscarded$ is a \Proselist{$\vh$}{$\vt$};
      \item \Proserenamesubprograms{$\vt$}{$\vtp$};
      \item define $\vhp$ as $\vh$ with the $\funcname$ field updated to a fresh name;
      \item the result is the concatenation of $\vhp$ and $\vtp$.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \renamesubprograms(\overname{\emptylist}{\vdiscarded}) \typearrow \overname{\emptylist}{\vrenameddiscarded}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \renamesubprograms(\vt) \typearrow \vtp \\
  \name \in \Identifiers \text{ is fresh} \\
  \vhp \eqdef \vh[\funcname \mapsto \name] \\
}{
  \renamesubprograms(\overname{[\vh] \concat \vt}{\vdiscarded}) \typearrow \overname{[\vhp] \concat \vtp}{\vrenameddiscarded}
}
\end{mathpar}

\section{Establishing Def-Use Dependencies \\ Between Global Declarations\label{sec:TopologicalOrdering}}
This section defines how to construct a graph of \defusedependenciesterm\ between the identifiers associated
with global declarations.
This is achieved by associating, for each declaration $d$, the set identifiers \emph{used} by $d$,
which is formally defined by $\usedecl$, and the identifier \emph{defined} by $d$,
which is formally defined by $\defdecl$.
%
The set of \defusedependenciesterm\ associated with a declaration $\vd$ is given by
$\decldependencies(\vd)$ (see \TypingRuleRef{DeclDependencies}).

\RequirementDef{GlobalNamespace}
The global namespace effectively consists of two independent namespaces: one for subprogram names, and the other for all other identifiers.

\ExampleDef{Global Namespace}
\listingref{globalnamespace} shows a specification which defines a subprogram \verb|X|
that does not interfere with the variable declaration also named \verb|X|.
\ASLListing{Global namespace}{globalnamespace}{\definitiontests/GlobalNamespace.asl}

We distinguish between subprogram identifiers, and all other identifiers (storage elements and \namedtypes{}).
We use the following type to track \defusedependenciesterm{} between subprogram identifiers and other identifiers:
\hypertarget{ast-defusename}{} \hypertarget{ast-subprogram}{} \hypertarget{ast-other}{}
\begin{flalign*}
\defusename \derives\ & \Subprogram(\identifier) \;|\; \Other(\identifier) &
\end{flalign*}

\TypingRuleDef{BuildDependencies}
\hypertarget{def-builddependencies}{}
The function
\[
\builddependencies(\overname{\decl^*}{\decls})
\aslto
(\overname{\defusename^*}{\defs}, \overname{(\defusename\times\defusename)^*}{\dependencies})
\]
takes a set of declarations $\decls$ and
returns a graph whose set of nodes --- $\defs$ --- consists of the identifiers that are used to name declarations
and whose set of edges $\dependencies$ consists of pairs $(a,b)$
where the declaration of $a$ uses an identifier defined by the declaration of $b$.
We refer to this graph as the \emph{\dependencygraphterm} (of $\decls$).

\ExampleDef{The Dependency Graph for a List of Global Declarations}
The \dependencygraphterm{} generated for the specification in \listingref{DeclDependencies}
is as follows:
\[
\left(
\begin{array}{c}
  \{ \Other(\vg), \Other(\MyRecord), \Other(\Color), \Other(\vWORDSIZE), \Subprogram(\vmain) \},\\
  \left\{\begin{array}{rcl}
    ( \Other(\vg) &,&          \Other(\MyRecord) ),\\
    ( \Other(\MyRecord) &,&    \Other(\vWORDSIZE) ),\\
    ( \Other(\Color) &,&       \Other(\RED) ),\\
    ( \Other(\Color) &,&       \Other(\GREEN) ),\\
    ( \Other(\Color) &,&       \Other(\BLUE) ),\\
    ( \Subprogram(\vmain) &,&  \Other(\vg) )\\
  \end{array}\right\}
\end{array}
\right)
\]

\ProseParagraph
\AllApply
\begin{itemize}
  \item define $\defs$ as the union of two sets:
  \begin{enumerate}
  \item the set of identifiers obtained by applying $\defdecl$ to each declaration in $\decls$;
  \item the union of applying $\defenumlabels$ to each declaration in $\decls$.
  \end{enumerate}
  \item define $\dependencies$ as the union of applying $\decldependencies$ to each declaration in $\decls$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \defs \eqdef \{ \defdecl(\vd) \;|\; \vd \in \decls\} \cup \bigcup_{\vd\in\decls} \defenumlabels(\vd)\\
  \dependencies \eqdef \bigcup_{\vd \in \decls} \decldependencies(\vd)
}{
  \builddependencies(\decls) \typearrow (\defs, \dependencies)
}
\end{mathpar}

\TypingRuleDef{DeclDependencies}
\hypertarget{def-decldependencies}{}
The function
\[
\decldependencies(\overname{\decl}{\vd}) \aslto \overname{(\defusename\times\defusename)^*}{\dependencies}
\]
returns the set of dependent pairs of identifiers $\dependencies$ induced by the declaration $\vd$.

\ExampleDef{The Dependencies of Global Declarations}
The specification in \listingref{DeclDependencies}
shows the dependencies generated for each global declarations
in comments appearing to the right of them or just above them.
A dependency $(d_1,d_2)$ is depicted as \texttt{$d_1$ -> $d_2$}.
\ASLListing{Dependencies of global declarations}{DeclDependencies}{\typingtests/TypingRule.DeclDependencies.asl}

\ProseParagraph
Define $\dependencies$ as the union of the following two sets of pairs:
\begin{enumerate}
  \item a pair $(\idone, \idtwo)$, where $\idone$ is the result of applying $\defdecl$ to $\vd$
        and $\idtwo$ included in the result of applying $\defenumlabels$ to $\vd$; and
  \item a pair $(\idone, \idtwo)$ ,where $\idone$ is the result of applying $\defdecl$ to $\vd$
        and $\idtwo$ included in the result of applying $\usedecl$ to $\vd$.
\end{enumerate}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \begin{array}{rcll}
  \dependencies & \eqdef  & \{ (\idone, \idtwo) \;|\; \idone = \defdecl(\vd) \land \idtwo \in \defenumlabels(\vd) \} & \cup\\
                &         & \{ (\idone, \idtwo) \;|\; \idone = \defdecl(\vd) \land \idtwo \in \usedecl(\vd) \}  &
    \end{array}
  }
}{
  \decldependencies(\vd) \typearrow \dependencies
}
\end{mathpar}

\TypingRuleDef{DefDecl}
\hypertarget{def-defdecl}{}
The function
\[
\defdecl(\overname{\decl}{\vd}) \aslto \overname{\defusename}{\name}
\]
returns the identifier $\name$ being defined by the declaration $\vd$.

\ExampleDef{The Identifiers Defined by Global Declarations}
The specification given in \listingref{DefDecl},
shows examples of global declarations and the identifiers they define,
which appear in comments to their right.
\ASLListing{Identifiers defined by global declarations}{DefDecl}{\typingtests/TypingRule.DefDecl.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{d\_func}
  \begin{itemize}
    \item $\vd$ declares a subprogram for the identifier $\id$;
    \item $\name$ is $\Subprogram(\id)$.
  \end{itemize}

  \item \AllApplyCase{d\_globalstorage}
  \begin{itemize}
    \item $\vd$ declares a global storage element for the identifier $\id$;
    \item $\name$ is $\Other(\id)$.
  \end{itemize}

  \item \AllApplyCase{d\_typedecl}
  \begin{itemize}
    \item $\vd$ declares a type for the identifier $\id$.
    \item $\name$ is $\Other(\id)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[d\_func]{}{
  \defdecl(\overname{\DFunc(\funcname: \id, \ldots)}{\vd}) \typearrow \overname{\Subprogram(\id)}{\name}
}
\and
\inferrule[d\_globalstorage]{}{
  \defdecl(\overname{\DGlobalStorage(\GDname: \id, \ldots)}{\vd}) \typearrow \overname{\Other(\id)}{\name}
}
\and
\inferrule[d\_typedecl]{}{
  \defdecl(\overname{\DTypeDecl(\id, \Ignore, \Ignore)}{\vd}) \typearrow \overname{\Other(\id)}{\name}
}
\end{mathpar}

\TypingRuleDef{DefEnumLabels}
\hypertarget{def-defenumlabels}{}
The function
\[
\defenumlabels(\overname{\decl}{\vd}) \aslto \overname{\pow{\defusename}}{\vlabels}
\]
takes a declaration $\vd$ and returns the set of enumeration labels it defines in $\vlabels$,
if it defines any.

\ExampleDef{Identifiers Defined by Declaring an Enumeration Type}
The set of identifiers defined by the enumeration declaration
in \listingref{DefEnumLabels} is \\
$\{\Other(\RED), \Other(\GREEN), \Other(\BLUE)\}$.
\ASLListing{Identifiers defined by declaring an enumeration type}{DefEnumLabels}{\typingtests/TypingRule.DefEnumLabels.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{decl\_enum}
  \begin{itemize}
    \item $\vd$ is a declaration of an \enumerationtypeterm{} with labels $\vlabelsone$;
    \item $\vlabels$ is the set consisting of $\Other(\vlabel)$ for each $\vlabel$ in $\vlabelsone$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\vd$ is not a declaration of an \enumerationtypeterm{};
    \item define $\vlabels$ as the empty set.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[decl\_enum]{
  \vd = \DTypeDecl(\name, \TEnum(\vlabelsone, \Ignore)) \\
  \vlabels \eqdef \{ \Other(\vlabel) \;|\; \vlabel \in \vlabelsone \}
}{
  \defenumlabels(\vd) \typearrow \vlabels
}
\and
\inferrule[other]{
  \vd \neq \DTypeDecl(\name, \TEnum(\Ignore, \Ignore))
}{
  \defenumlabels(\vd) \typearrow \overname{\emptyset}{\vlabels}
}
\end{mathpar}

\TypingRuleDef{UseDecl}
\hypertarget{def-usedecl}{}
The function
\[
\usedecl(\overname{\decl}{\vd}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the declaration $\vd$ depends on.

\ExampleDef{Identifiers Used by Global Declarations}
The specification in \listingref{UseDecl} shows the set of identifiers
used by each global declaration via comments above it.
\ASLListing{Identifiers used by global declarations}{UseDecl}{\typingtests/TypingRule.UseDecl.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{D\_TypeDecl}
  \begin{itemize}
    \item $\vd$ declares a type $\tty$ and fields $\fields$, that is,
          $\DTypeDecl(\Ignore, \tty, \fields)$ (the first component is the name, which is being defined);
    \item define $\ids$ as the union of applying $\usety$ to $\tty$ and applying $\usesubtypes$ to $\fields$.
  \end{itemize}

  \item \AllApplyCase{D\_GlobalStorage}
  \begin{itemize}
    \item $\vd$ declares a global storage element with initial value $\initialvalue$ and type $\tty$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\initialvalue$ and applying $\usety$ to $\tty$.
  \end{itemize}

  \item \AllApplyCase{D\_Func}
  \begin{itemize}
    \item $\vd$ declares a subprogram with arguments $\vargs$, \optional\ return type \\
          $\rettyopt$, parameters $\vparams$, body statement $\body$, and optional recursion limit expression $\vrecurselimit$;
    \item define $\ids$ as the union of applying $\usety$ to each type of an argument in $\vargs$,
          applying $\usety$ to $\rettyopt$, applying $\usety$ to each type of a parameter in $\vparams$,
          applying $\usestmt$ to $\body$,
          and applying $\useexpr$ to $\vrecurselimit$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[D\_TypeDecl]{}{
  \usedecl(\overname{\DTypeDecl(\Ignore, \tty, \fields)}{\vd}) \typearrow \overname{\usety(\tty) \cup \usesubtypes(\fields)}{\ids}
}
\and
\inferrule[D\_GlobalStorage]{
  \ids \eqdef \useexpr(\initialvalue) \cup \usety(\tty)
}{
  \usedecl(\overname{\DGlobalStorage(\{
    \GDinitialvalue: \initialvalue,
    \GDty: \tty\ldots\})}{\vd})
  \typearrow \ids
}
\and
\inferrule[D\_Func]{
  {
    \begin{array}{rcll}
  \ids &\eqdef& \{ (\Ignore, \vt) \in \vargs : \usety(\vt) \} &\cup\\
  && \usety(\rettyopt) &\cup\\
  && \{ (\Ignore, \vt) \in \vparams : \usety(\vt) \} &\cup \\
  && \usestmt(\body) &\cup\\
  && \useexpr(\vrecurselimit) &
    \end{array}
  }
}{
  {
  \usedecl\left(\overname{
    \DFunc\left(
  \left\{
    \begin{array}{l}
    \funcbody: \body,\\
    \funcargs: \vargs,\\
    \funcreturntype: \rettyopt,\\
    \funcparameters: \vparams,\\
    \funcrecurselimit: \vrecurselimit,\\
    \ldots\\
    \end{array}
  \right\}
  \right)}{\vd}
  \right)
  \typearrow \ids
  }
}
\end{mathpar}

\TypingRuleDef{UseTy}
\hypertarget{def-usety}{}
The function
\[
\usety(\overname{\ty \cup \langle\ty\rangle}{\vt}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the type or \optional\ type $\vt$ depends on.

\ExampleDef{The Identifiers Used by a Type}
The specification in \listingref{UseTy} shows type annotations and the identifiers
used by them appearing as comments to their right.
\ASLListing{The identifiers used by a type}{UseTy}{\typingtests/TypingRule.UseTy.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vt$ is $\None$;
    \item define $\ids$ as $\emptyset$.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\vt$ is $\langle\tty\rangle$;
    \item applying $\usety$ to $\tty$ yields $\ids$.
  \end{itemize}

  \item \AllApplyCase{simple}
  \begin{itemize}
    \item $\vt$ is one of the following types: enumeration, Boolean, real, or string;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item \AllApplyCase{t\_named}
  \begin{itemize}
    \item $\vt$ is the named type for $\vs$;
    \item define $\ids$ as the singleton set for $\Other(\vs)$.
  \end{itemize}

  \item \AllApplyCase{int\_no\_constraints}
  \begin{itemize}
    \item $\vt$ is either the unconstrained integer type or a \parameterizedintegertype{} or a \pendingconstrainedintegertype;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item \AllApplyCase{int\_well\_constrained}
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type with constraints $\vcs$;
    \item define $\ids$ as the union of applying $\useconstraint$ to each constraint in $\vcs$.
  \end{itemize}

  \item \AllApplyCase{t\_tuple}
  \begin{itemize}
    \item $\vt$ is the \tupletypeterm{} with list of types $\vli$;
    \item define $\ids$ as the union of applying $\useconstraint$ to each constraint in $\vcs$.
  \end{itemize}

  \item \AllApplyCase{structured}
  \begin{itemize}
    \item $\vt$ is a \structuredtype\ with fields $\fields$;
    \item define $\ids$ as the union of applying $\usety$ to each field type in $\fields$.
  \end{itemize}

  \item \AllApplyCase{array\_expr}
  \begin{itemize}
    \item $\vt$ is an array expression with length expression $\ve$ and element type $\vtp$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and applying $\usety$ to $\vtp$.
  \end{itemize}

  \item \AllApplyCase{array\_enum}
  \begin{itemize}
    \item $\vt$ is an array expression with \enumerationtypeterm{} $\vs$ and element type $\vtp$;
    \item define $\ids$ as the union of the singleton set for $\Other(\vs)$ and applying $\usety$ to $\vtp$.
  \end{itemize}

  \item \AllApplyCase{t\_bits}
  \begin{itemize}
    \item $\vt$ is a bitvector type with width expression $\ve$ and bitfields $\bitfields$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and applying $\usebitfield$ to each field in $\bitfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \usety(\overname{\None}{\vt}) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[some]{
  \usety(\tty) \typearrow \ids
}{
  \usety(\overname{\langle\tty\rangle}{\vt}) \typearrow \ids
}
\and
\inferrule[simple]{
  \astlabel(\vt) \in \{\TEnum, \TBool, \TReal, \TString\}
}{
  \usety(\vt) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[t\_named]{}{
  \usety(\overname{\TNamed(\vs)}{\vt}) \typearrow \overname{\{\Other(\vs)\}}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_no\_constraints]{
  \astlabel(\vc) \in \{\unconstrained, \parameterized\}
}{
  \usety(\overname{\TInt(\vc)}{\vt}) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained]{}{
  \usety(\overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\bigcup_{\vc \in \vcs} \useconstraint(\vc)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{}{
  \usety(\overname{\TTuple(\vli)}{\vt}) \typearrow \overname{\bigcup_{\vt \in \vli} \usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}}{
  \usety(\overname{L(\fields)}{\vt}) \typearrow \overname{\bigcup_{(\Ignore, \vt) \in \fields} \usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[array\_expr]{}{
  \usety(\overname{\TArray(\ArrayLengthExpr(\ve), \vtp)}{\vt}) \typearrow \overname{\useexpr(\ve) \cup \usety(\vtp)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[array\_enum]{}{
  \usety(\overname{\TArray(\ArrayLengthEnum(\vs, \Ignore), \vtp)}{\vt}) \typearrow \overname{\{\Other(\vs)\} \cup \usety(\vtp)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{}{
  \usety(\overname{\TBits(\ve, \bitfields)}{\vt}) \typearrow \overname{\useexpr(\ve) \cup \bigcup_{\vf \in\bitfields}\usebitfield(\vf)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseSubtypes}
\hypertarget{def-usesubtypes}{}
The function
\[
\usesubtypes(\overname{\langle(\overname{\identifier}{\vx}\times\overname{\Field^*}{\subfields})\rangle}{\fields}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the \optional\ pair consisting of
identifier $\vx$ (the type being subtyped) and fields $\subfields$ depends on.

\ExampleDef{The Identifiers Used by a Subtyping Declaration}
In \listingref{UseDecl}, applying $\usesubtypes$ at
the type declaration of \verb|MyRecord| yields \\
$\{\ \Other(\RecordBase), \Other(\HalfWordBits)\ \}$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\fields$ is $\None$;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\fields$ is $\langle(\vx, \subfields)\rangle$;
    \item define $\ids$ as the union of the singleton set for $\Other(\vx)$ and the union of applying $\usety$
          to each field type in $\subfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \usesubtypes(\None) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[some]{
  \ids \eqdef \{\Other(\vx)\} \cup \bigcup_{(\Ignore, \vt) \in \subfields}\usety(\vt)
}{
  \usesubtypes(\langle(\vx, \subfields)\rangle) \typearrow \ids
}
\end{mathpar}

\TypingRuleDef{UseExpr}
\hypertarget{def-useexpr}{}
The function
\[
\useexpr(\overname{\expr}{\ve} \cup \langle\overname{\expr}{\ve}\rangle) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the expression or \optional\ expression $\ve$ depends on.

\ExampleDef{The Identifiers Used by Expressions}
The specification in \listingref{UseExpr} shows the identifiers used
by expressions on the right-hand-side of assignments in comments appearing to their right.
\ASLListing{Identifiers used by expressions}{UseExpr}{\typingtests/TypingRule.UseExpr.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\ve$ is $\None$;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\ve$ is $\langle\veone\rangle$;
    \item applying $\useexpr$ to $\veone$ yields $\ids$.
  \end{itemize}

  \item \AllApplyCase{e\_literal}
  \begin{itemize}
    \item $\ve$ is a literal expression;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item \AllApplyCase{e\_atc}
  \begin{itemize}
    \item $\ve$ is the typing assertion for expression $\ve$ and type $\tty$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\usety$ to $\tty$.
  \end{itemize}

  \item \AllApplyCase{e\_var}
  \begin{itemize}
    \item $\ve$ is the variable expression for identifier $\vx$;
    \item define $\ids$ as the singleton set for $\Other(\vx)$.
  \end{itemize}

  \item \AllApplyCase{e\_getarray}
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item \AllApplyCase{e\_getenumarray}
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and enumeration-typed index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item \AllApplyCase{e\_binop}
  \begin{itemize}
    \item $\ve$ is the binary operation expression over expressions $\veone$ and $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item \AllApplyCase{e\_unop}
  \begin{itemize}
    \item $\ve$ is the unary operation expression over any unary operation and an expression $\veone$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$.
  \end{itemize}

  \item \AllApplyCase{e\_call}
  \begin{itemize}
    \item $\ve$ is the call expression of the subprogram named $\vx$ with argument expressions $\vargs$ and parameter expressions $\namedargs$;
    \item define $\ids$ as the union of the singleton set for $\Subprogram(\vx)$, and the set obtained by applying $\useexpr$ to each expression in
          $\vargs$ and each expression in $\namedargs$.
  \end{itemize}

  \item \AllApplyCase{e\_slice}
  \begin{itemize}
    \item $\ve$ is the slicing expression over expression $\veone$ and slices $\slices$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useslice$ to each slice in $\slices$.
  \end{itemize}

  \item \AllApplyCase{e\_cond}
  \begin{itemize}
    \item $\ve$ is the conditional expression over expressions $\veone$, $\vetwo$, and $\vethree$;
    \item define $\ids$ as the union of applying $\useexpr$ to each of $\veone$, $\vetwo$, and $\vethree$.
  \end{itemize}

  \item \AllApplyCase{e\_getitem}
  \begin{itemize}
    \item $\ve$ is the tuple access expression over expression $\veone$;
    \item define $\ids$ as the application of $\useexpr$ to $\veone$.
  \end{itemize}

  \item \AllApplyCase{e\_getfield}
  \begin{itemize}
    \item $\ve$ is the field access expression over expression $\veone$;
    \item define $\ids$ as the application of $\useexpr$ to $\veone$.
  \end{itemize}

  \item \AllApplyCase{e\_getfields}
  \begin{itemize}
    \item $\ve$ is the multiple field access expression over expression $\veone$;
    \item define $\ids$ as the application of $\useexpr$ to $\veone$.
  \end{itemize}

  \item \AllApplyCase{e\_record}
  \begin{itemize}
    \item $\ve$ is the record construction expression of type $\tty$ and field initializations $\vli$;
    \item define $\ids$ as the union of applying of $\usety$ to $\tty$ and applying $\usety$ to each field type in $\vli$.
  \end{itemize}

  \item \AllApplyCase{e\_tuple}
  \begin{itemize}
    \item $\ve$ is the tuple construction expression for the expressions $\ves$;
    \item define $\ids$ as the union of applying of $\useexpr$ to each expression in $\ves$.
  \end{itemize}

  \item \AllApplyCase{e\_array}
  \begin{itemize}
    \item $\ve$ is the array construction expression for the length expression $\veone$ and value expression $\vetwo$,
          that is, $\EArray\{\EArrayLength:\veone, \EArrayValue:\vetwo\}$;
    \item define $\ids$ as the union of applying of $\useexpr$ to each of $\veone$ and $\vetwo$.
  \end{itemize}

  \item \AllApplyCase{e\_enumarray}
  \begin{itemize}
    \item $\ve$ is the array construction expression for the array with enumeration-typed index for the list of labels
          $\vlabels$ and value expression $\vvalue$,
          that is, \\
          $\EEnumArray\{\EArrayLabels:\vlabels, \EArrayValue:\vvalue\}$;
    \item define $\idsone$ as the set consisting of $\Other$ applied to each label in $\vlabels$;
    \item define $\ids$ as the union $\idsone$ and the result of applying $\useexpr$ to $\vvalue$.
  \end{itemize}

  \item \AllApplyCase{e\_arbitrary}
  \begin{itemize}
    \item $\ve$ is the arbitrary expression with type $\vt$;
    \item define $\ids$ as the application of $\usety$ to $\vt$.
  \end{itemize}

  \item \AllApplyCase{e\_pattern}
  \begin{itemize}
    \item $\ve$ is the pattern testing expression for subexpression $\veone$ and pattern $\vp$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\usepattern$ to $\vp$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \useexpr(\overname{\None}{\ve}) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[some]{
  \useexpr(\veone) \typearrow \ids
}{
  \useexpr(\overname{\langle\veone\rangle}{\ve}) \typearrow \ids
}
\and
\inferrule[e\_literal]{}{
  \useexpr(\overname{\ELiteral(\Ignore)}{\ve}) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[e\_atc]{}{
  \useexpr(\overname{\EATC(\veone, \tty)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \usety(\tty)}{\ids}
}
\and
\inferrule[e\_var]{}{
  \useexpr(\overname{\EVar(\vx)}{\ve}) \typearrow \overname{\{\Other(\vx)\}}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getarray]{}{
  \useexpr(\overname{\EGetArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getenumarray]{}{
  \useexpr(\overname{\EGetEnumArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{}{
  \useexpr(\overname{\EBinop(\Ignore, \veone, \vetwo)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{}{
  \useexpr(\overname{\EUnop(\Ignore, \veone)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_call]{
  \ids \eqdef \{\Subprogram(\vx)\} \cup  \bigcup_{\veone\in\vargs}\useexpr(\veone) \cup \bigcup_{(\Ignore, \vt)\in\namedargs}\usety(\vt)
}{
  \useexpr(\overname{\ECall(\vx, \vargs, \namedargs)}{\ve}) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice]{}{
  \useexpr(\overname{\ESlice(\veone, \slices)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \bigcup_{\vs\in\slices}\useslice(\vs)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{}{
  \useexpr(\overname{\ECond(\veone, \vetwo, \vethree)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo) \cup \useexpr(\vethree)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getitem]{}{
  \useexpr(\overname{\EGetItem(\veone, \Ignore)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\and
\inferrule[e\_getfield]{}{
  \useexpr(\overname{\EGetField(\veone, \Ignore)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfields]{}{
  \useexpr(\overname{\EGetFields(\veone, \Ignore)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record]{}{
  \useexpr(\overname{\ERecord(\tty, \vli)}{\ve}) \typearrow \overname{\usety(\tty) \cup \bigcup_{(\Ignore, \vt)\in\vli}\usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_tuple]{}{
  \useexpr(\overname{\ETuple(\ves)}{\ve}) \typearrow \overname{\bigcup_{\veone\in\ves}\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_array]{}{
  \useexpr(\overname{\EArray\{\EArrayLength:\veone, \EArrayValue:\vetwo\}}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_enumarray]{
  \idsone \eqdef \bigcup_{\vlabel\in\vlabels}\Other(\vlabel)
}{
  \useexpr(\overname{\EEnumArray\{\EArrayLabels:\vlabels, \EArrayValue:\vvalue\}}{\ve}) \typearrow \overname{\{\vlabels\} \cup \useexpr(\vvalue)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_arbitrary]{}{
  \useexpr(\overname{\EArbitrary(\vt)}{\ve}) \typearrow \overname{\usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern]{}{
  \useexpr(\overname{\EPattern(\veone, \vp)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \usepattern(\vp)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseLexpr}
\hypertarget{def-uselexpr}{}
The function
\[
\uselexpr(\overname{\lexpr}{\vle}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the left-hand-side expression $\vle$ depends on.

\ExampleDef{The Identifiers Used by Assignable Expressions}
The specification in \listingref{UseLexpr} shows the identifiers used
by the assignable expressions on the left-hand-side of assignments in comments appearing to their right.
\ASLListing{Identifiers used by assignable expressions}{UseLexpr}{\typingtests/TypingRule.UseLexpr.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{le\_var}
  \begin{itemize}
    \item $\vle$ is a left-hand-side variable expression for $\vx$;
    \item define $\ids$ as the singleton set for $\Other(\vx)$.
  \end{itemize}

  \item \AllApplyCase{le\_destructuring}
  \begin{itemize}
    \item $\vle$ is a left-hand-side expression for assigning to a list of expressions $\vles$,
          that is $\LEDestructuring(\vles)$;
    \item define $\ids$ as the union of applying $\uselexpr$ to each expression in $\vles$.
  \end{itemize}

  \item \AllApplyCase{le\_discard}
  \begin{itemize}
    \item $\vle$ is a left-hand-side discard expression;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item \AllApplyCase{le\_setarray}
  \begin{itemize}
    \item $\vle$ is a left-hand-side array update of the array given by the expression $\veone$ and index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item \AllApplyCase{le\_setenumarray}
  \begin{itemize}
    \item $\vle$ is a left-hand-side array update of the array given by the expression $\veone$ and
          the enumeration-typed index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item \AllApplyCase{le\_setfield}
  \begin{itemize}
    \item $\vle$ is a left-hand-side field update of the record given by the expression $\veone$;
    \item define $\ids$ as the application of $\uselexpr$ to $\veone$.
  \end{itemize}

  \item \AllApplyCase{le\_setfields}
  \begin{itemize}
    \item $\vle$ is a left-hand-side multiple field updates of the record given by the expression $\veone$;
    \item define $\ids$ as the application of $\uselexpr$ to $\veone$.
  \end{itemize}

  \item \AllApplyCase{le\_slice}
  \begin{itemize}
    \item $\vle$ is a left-hand-side slicing of the expression $\veone$ by slices $\slices$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\veone$ and applying $\useslice$ to each slice in $\slices$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[le\_var]{}{
  \uselexpr(\overname{\LEVar(\vx)}{\vle}) \typearrow \overname{\Other(\vx)}{\ids}
}
\and
\inferrule[le\_destructuring]{}{
  \uselexpr(\overname{\LEDestructuring(\vles)}{\vle}) \typearrow \overname{\bigcup_{\ve\in\vles}\uselexpr(\ve)}{\ids}
}
\and
\inferrule[le\_discard]{}{
  \uselexpr(\overname{\LEDiscard}{\vle}) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setarray]{}{
  \uselexpr(\overname{\LESetArray(\veone, \vetwo)}{\vle}) \typearrow \overname{\uselexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setenumarray]{}{
  \uselexpr(\overname{\LESetEnumArray(\veone, \vetwo)}{\vle}) \typearrow \overname{\uselexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setfield]{}{
  \uselexpr(\overname{\LESetField(\veone, \Ignore)}{\vle}) \typearrow \overname{\uselexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setfields]{}{
  \uselexpr(\overname{\LESetFields(\veone, \Ignore)}{\vle}) \typearrow \overname{\uselexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_slice]{}{
  \uselexpr(\overname{\LESlice(\veone, \slices)}{\vle}) \typearrow \overname{\uselexpr(\veone) \cup \bigcup_{\vs\in\slices}\useslice(\vs)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UsePattern}
\hypertarget{def-usepattern}{}
The function
\[
\usepattern(\overname{\pattern}{\vp}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the declaration $\vd$ depends on.

\ExampleDef{The Identifiers Used by a Pattern}
The specification in \listingref{UsePattern} shows examples of patterns
and the identifiers used by them, appearing in comments to their right.
\ASLListing{Identifiers used by a pattern}{UsePattern}{\typingtests/TypingRule.UsePattern.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{mask\_all}
  \begin{itemize}
    \item $\vp$ is either a mask pattern ($\PatternMask$) or a match-all pattern ($\PatternAll$);
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\vp$ is a tuple pattern list of patterns $\vli$;
    \item define $\ids$ as the union of the application of $\usepattern$ for each pattern in $\vli$.
  \end{itemize}

  \item \AllApplyCase{any}
  \begin{itemize}
    \item $\vp$ is a pattern for matching any of the patterns in the list of patterns $\vli$;
    \item define $\ids$ as the union of the application of $\usepattern$ for each pattern in $\vli$.
  \end{itemize}

  \item \AllApplyCase{single}
  \begin{itemize}
    \item $\vp$ is a pattern for matching the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item \AllApplyCase{geq}
  \begin{itemize}
    \item $\vp$ is a pattern for testing greater-or-equal with respect to the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item \AllApplyCase{leq}
  \begin{itemize}
    \item $\vp$ is a pattern for testing less-than-or-equal with respect to the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item \AllApplyCase{not}
  \begin{itemize}
    \item $\vp$ is a pattern negating the pattern $\vpone$;
    \item define $\ids$ as the application of $\usepattern$ to $\vpone$.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vp$ is a pattern for testing the range of expressions from $\veone$ to $\vetwo$;
    \item define $\ids$ as the union of the application of $\useexpr$ to both $\veone$ and $\vetwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[mask\_all]{
  \astlabel(\vp) \in \{\PatternMask, \PatternAll\}
}{
  \usepattern(\vp) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{}{
  \usepattern(\overname{\PatternTuple(\vli)}{\vp}) \typearrow \overname{\bigcup_{\vpone\in\vli}\usepattern(\vpone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[any]{}{
  \usepattern(\overname{\PatternAny(\vli)}{\vp}) \typearrow \overname{\bigcup_{\vpone\in\vli}\usepattern(\vpone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[single]{}{
  \usepattern(\overname{\PatternSingle(\ve)}{\vp}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[geq]{}{
  \usepattern(\overname{\PatternGeq(\ve)}{\vp}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[leq]{}{
  \usepattern(\overname{\PatternLeq(\ve)}{\vp}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[not]{}{
  \usepattern(\overname{\PatternNot(\vpone)}{\vp}) \typearrow \overname{\usepattern(\vpone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{}{
  \usepattern(\overname{\PatternRange(\veone, \vetwo)}{\vp}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseSlice}
\hypertarget{def-useslice}{}
The function
\[
\useslice(\overname{\slice}{\vs}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the slice $\vs$ depends on.

\ExampleDef{The Identifiers Used by a Slice}
The specification in \listingref{UseSlice} shows slicing expressions
and the identifiers they use, appearing in comments to their right.
\ASLListing{Identifiers used by a slice}{UseSlice}{\typingtests/TypingRule.UseSlice.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{single}
  \begin{itemize}
    \item $\vs$ is the slice at the position given by the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item \AllApplyCase{start\_length\_range}
  \begin{itemize}
    \item $\vs$ is a slice given by the pair of expressions $\veone$ and $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to both $\veone$ and $\vetwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[single]{}{
  \useslice(\overname{\SliceSingle(\ve)}{\vs}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\and
\inferrule[start\_length\_range]{
  L \in \{\SliceStar, \SliceLength, \SliceRange\}
}{
  \useslice(\overname{L(\veone, \vetwo)}{\vs}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseBitfield}
\hypertarget{def-usebitfield}{}
The function
\[
\usebitfield(\overname{\decl}{\vbf}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the bitfield $\vbf$ depends on.

\ExampleDef{The Identifiers Used by a Bitfield Declaration}
The specification in \listingref{UseBitfield} shows examples
of bitfield declarations and the identifiers they use,
appearing as comments to their right.
\ASLListing{Identifiers used by a bitfield declaration}{UseBitfield}{\typingtests/TypingRule.UseBitfield.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{simple}
  \begin{itemize}
    \item $\vbf$ is the single field with slices $\slices$;
    \item define $\ids$ as the union of applying $\useslice$ to each slice in $\slices$.
  \end{itemize}

  \item \AllApplyCase{nested}
  \begin{itemize}
    \item $\vbf$ is the nested bitfield with slices $\slices$ and bitfields $\bitfields$;
    \item define $\ids$ as the union of applying $\useslice$ to each slice in $\slices$ and applying
          $\usebitfield$ to each bitfield in $\bitfields$.
  \end{itemize}

  \item \AllApplyCase{type}
  \begin{itemize}
    \item $\vbf$ is the typed bitfield with slices $\slices$ and type $\tty$;
    \item define $\ids$ as the union of applying $\useslice$ to each slice in $\slices$ and applying
          $\usety$ to $\tty$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[simple]{}{
  \usebitfield(\overname{\BitFieldSimple(\Ignore, \slices)}{\vbf}) \typearrow \overname{\bigcup_{\vs\in\slices}\useslice(\vs)}{\ids}
}
\and
\inferrule[nested]{
  \ids \eqdef \bigcup_{\bfone\in\bitfields}\usebitfield(\vs) \cup \bigcup_{\vs\in\slices}\useslice(\vs)
}{
  \usebitfield(\overname{\BitFieldNested(\Ignore, \slices, \bitfields)}{\vbf}) \typearrow \ids
}
\and
\inferrule[type]{
  \ids \eqdef \bigcup_{\vs\in\slices}\useslice(\vs) \cup \usety(\tty)
}{
  \usebitfield(\overname{\BitFieldType(\Ignore, \slices, \tty)}{\vbf}) \typearrow \ids
}
\end{mathpar}

\TypingRuleDef{UseConstraint}
\hypertarget{def-useconstraint}{}
The function
\[
\useconstraint(\overname{\intconstraint}{\vc}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the integer constraint $\vc$ depends on.

\ExampleDef{The Identifiers Used by Constraints}
The specification in \listingref{UseConstraint}
shows constraints in type annotations, and the identifiers they use,
appearing in comments to their right.
\ASLListing{Identifiers used by constraints}{UseConstraint}{\typingtests/TypingRule.UseConstraint.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is the single-value expression constraint with expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is the range constraint with expressions $\veone$ and $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to both $\veone$ and $\vetwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{}{
  \useconstraint(\overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\and
\inferrule[range]{}{
  \useconstraint(\overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseStmt}
\hypertarget{def-usestmt}{}
The function
\[
\usestmt(\overname{\stmt}{\vs}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the statement $\vs$ depends on.

\ExampleDef{The Identifiers Used by Statements}
The specification in \listingref{UseStmt} shows examples of statements
and the identifiers used by them, appearing in comments to their right.
\ASLListing{Identifiers used by statements}{UseStmt}{\typingtests/TypingRule.UseStmt.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{pass\_return\_none\_throw\_none}
  \begin{itemize}
    \item $\vs$ is either a pass statement $\SPass$, a return-nothing statement $\SReturn(\None)$,
          or a throw-nothing statement ($\SThrow(\None)$);
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item \AllApplyCase{s\_seq}
  \begin{itemize}
    \item $\vs$ is a sequencing statement for $\vsone$ and $\vstwo$;
    \item define $\ids$ as the union of applying $\usestmt$ to both $\vsone$ and $\vstwo$.
  \end{itemize}

  \item \AllApplyCase{assert\_return\_some}
  \begin{itemize}
    \item $\vs$ is either an assertion with expression $\ve$ or a return statement with expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item \AllApplyCase{s\_assign}
  \begin{itemize}
    \item $\vs$ is an assignment statement with left-hand-side $\vle$ and right-hand-side $\ve$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\vle$ and $\useexpr$ to $\ve$.
  \end{itemize}

  \item \AllApplyCase{s\_call}
  \begin{itemize}
    \item $\vs$ is a call statement for the subprogram with name $\vx$, arguments $\vargs$, and list of
          pairs consisting of a parameter identifier and associated expression $\namedargs$;
    \item define $\ids$ as the union of the singleton set for $\Subprogram(\vx)$, applying $\useexpr$ to
          every expression in $\vargs$ and applying $\useexpr$ to every expression associated with
          a parameter in $\namedargs$.
  \end{itemize}

  \item \AllApplyCase{s\_cond}
  \begin{itemize}
    \item $\vs$ is the conditional statement with expression $\ve$ and statements $\vsone$ and $\vstwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and $\usestmt$ to both of $\vsone$ and $\vstwo$.
  \end{itemize}

  \item \AllApplyCase{s\_for}
  \begin{itemize}
    \item $\vs$ is the for statement $\SFor\left\{\begin{array}{rcl}
      \Forindexname &:& \Ignore\\
      \Forstarte &:& \vstarte\\
      \fordirection &:& \vdirection\\
      \Forende &:& \vende\\
      \Forbody &:& \vbody\\
      \Forlimit &:& \vlimit
    \end{array}\right\}$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\vlimit$, $\vstarte$, and $\vende$ and applying $\usestmt$ to $\vsone$.
  \end{itemize}

  \item \AllApplyCase{while\_repeat}
  \begin{itemize}
    \item $\vs$ is either a while statement or repeat statement, each with expression $\ve$, body statement $\vsone$,
          and optional limit expression $\vlimit$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\vlimit$ and to $\ve$, and applying $\usestmt$ to $\vsone$.
  \end{itemize}

  \item \AllApplyCase{s\_decl}
  \begin{itemize}
    \item $\vs$ is a declaration statement with \optional{} type annotation $\vt$ and \optional\ initialization expression $\ve$;
    \item define $\ids$ as the union of applying $\usety$ to $\vt$ and $\useexpr$ to $\ve$.
  \end{itemize}

  \item \AllApplyCase{s\_throw\_some}
  \begin{itemize}
    \item $\vs$ is a \throwstatementsterm{} with an \optional{} expression $\ve$;
    \item \Proseeqdef{$\ids$}{the result of applying $\useexpr$ to $\ve$}.
  \end{itemize}

  \item \AllApplyCase{s\_try}
  \begin{itemize}
    \item $\vs$ is a try statement with statement $\vsone$, catcher list $\catchers$, and otherwise statement $\vstwo$;
    \item define $\ids$ as the union of applying $\usestmt$ to both $\vsone$ and $\vstwo$ and $\usecatcher$ to
          every catcher in $\catchers$.
  \end{itemize}

  \item \AllApplyCase{s\_print}
  \begin{itemize}
    \item $\vs$ is a print statement with list of expressions $\vargs$;
    \item define $\ids$ as the union of applying $\useexpr$ to each expression in $\vargs$.
  \end{itemize}

  \item \AllApplyCase{s\_unreachable}
  \begin{itemize}
    \item $\vs$ is an \texttt{Unreachable()};
    \item define $\ids$ as the empty set.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[pass\_return\_none\_throw\_none]{
  \vs = \SPass \lor \vs = \SReturn(\None) \lor \vs = \SThrow(\None)
}{
  \usestmt(\vs) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_seq]{}{
  \usestmt(\overname{\SSeq(\vsone, \vstwo)}{\vs}) \typearrow \overname{\usestmt(\vsone)\cup\usestmt(\vstwo)}{\ids}
}
\and
\inferrule[assert\_return\_some]{
  \vs = \SAssert(\ve) \lor \vs = \SReturn(\langle\ve\rangle)
}{
  \usestmt(\vs) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}

\inferrule[s\_assign]{}{
  \usestmt(\overname{\SAssign(\vle, \ve)}{\vs}) \typearrow \overname{\uselexpr(\vle) \cup \useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_call]{
  \ids \eqdef \{\Subprogram(\vx)\} \cup \bigcup_{\ve\in\vargs}\useexpr(\ve) \cup \bigcup_{(\Ignore, \ve)\in\namedargs} \useexpr(\ve)
}{
  \usestmt(\overname{\SCall(\vx, \vargs, \namedargs)}{\vs}) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_cond]{}{
  \usestmt(\overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \typearrow \overname{\useexpr(\ve) \cup \usestmt(\vsone) \cup \usestmt(\vstwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_for]{
  \ids \eqdef \useexpr(\vlimit) \cup \useexpr(\vstarte) \cup \useexpr(\vende) \cup \usestmt(\vbody)
}{
  {
  \usestmt\left(\overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \Ignore\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdirection\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \vlimit
  \end{array}\right\}}{\vs}\right) \typearrow \ids
  }
}
\and
\inferrule[while\_repeat]{
  \vs = \SWhile(\ve, \vlimit, \vs) \lor \vs = \SRepeat(\vs, \ve, \vlimit)
}{
  \usestmt(\vs) \typearrow \overname{\useexpr(\vlimit) \cup \useexpr(\ve) \cup \usestmt(\vsone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_decl]{}{
  \usestmt(\overname{\SDecl(\Ignore, \Ignore, \vt, \ve)}\vs) \typearrow \overname{\usety(\vt) \cup \useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_throw\_some]{}{
  \usestmt(\overname{\SThrow(\langle\ve\rangle)}\vs) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_try]{
  \ids \eqdef \usestmt(\vsone) \cup \bigcup_{\vc\in\catchers}\usecatcher(\vc) \cup \usestmt(\vstwo)
}{
  \usestmt(\overname{\STry(\vsone, \catchers, \vstwo)}{\vs}) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_print]{}{
  \usestmt(\overname{\SPrint(\vargs, \Ignore)}{\vs}) \typearrow \overname{\bigcup_{\ve\in\vargs}\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_unreachable]{}{
  \usestmt(\overname{\SUnreachable}{\vs}) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseCatcher}
\hypertarget{def-usecatcher}{}
The function
\[
\usecatcher(\overname{\catcher}{\vc}) \aslto \overname{\pow{\defusename}}{\ids}
\]
returns the set of identifiers $\ids$ which the try statement catcher $\vc$ depends on.

\ExampleDef{The Identifiers Used by a Catcher}
The specification in \listingref{UseStmt} shows an example
of a catcher clause (towards the end of \verb|main|)
and the identifiers used by it, appearing in comments to its right.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vc$ is a case alternative with type $\tty$ and statement $\vs$;
  \item define $\ids$ as the union of applying $\usety$ to $\ty$ and applying $\usestmt$ to $\vs$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \usecatcher(\overname{(\Ignore, \tty, \vs)}{\vc}) \typearrow \overname{\usety(\tty) \cup \usestmt(\vs)}{\ids}
}
\end{mathpar}

\section{Ordering Global Declarations via Def-Use Dependencies\label{sec:Dependencies}}

\begin{definition}[Strongly Connected Components]
\hypertarget{def-scc}{}
Given a graph $G=(V, E)$, a \\ subset of its nodes $C \subseteq V$ is called
a \emph{strongly connected component} of $G$ if
every pair of nodes $u,v \in C$ reachable from one another.

The \emph{strongly connected components} of a graph $(V, E)$ uniquely partitions its set of
nodes $V$ into a set of strongly connected components:
\[
\SCC(V, E) \triangleq \{ C \subseteq V \;|\; \forall u,v\in C.\ (u,v), (v,u) \in \graphtransitivereflexive{E} \} \enspace.
\]
\end{definition}

\hypertarget{def-topologicalorderingcomps}{}
\begin{definition}[Topological Ordering of Components]
For a non-empty graph \\
$G=(V, E)$ and its strongly connected components $\comps \triangleq \SCC(V, E)$,
a listing of $\comps$ ---
$C_{1..k}$ --- is a \emph{topological ordering of components},
denoted \\
$C_{1..k} \in \topologicalorderingcomps(\comps, E)$, if the following condition holds:
\[
  \forall 1 \leq i \leq j \leq k.\ \exists c_i\in C_i.\ c_j\in C_j.\ (c_i,c_j) \in \graphtransitivereflexive{E} \;\;\Longrightarrow\;\;
  i \leq j \enspace .
\]
\end{definition}

\section{Semantics of Specifications\label{sec:SemanticsOfSpecifications}}
The semantics of specifications is defined via the relation $\evalspec$, which is defined next.

\SemanticsRuleDef{EvalSpec}
The relation
\hypertarget{def-evalspec}{}
\[
  \evalspec(\overname{\staticenvs}{\tenv} \aslsep \overname{\spec}{\vspec}) \;\aslrel\;
   ((\overname{\tint}{\vv}\times \overname{\XGraphs}{\vg}) \cup \overname{\TDynError}{\DynErrorConfig})
\]
evaluates the specification $\vspec$ with the static environment $\tenv$,
yielding the native integer value $\vv$ and execution graph $\vg$.
Otherwise, the result is a dynamic error.

\ExampleRef{Returning a Value from the Entry Point} shows a specification
whose evaluation results in returning the value $\nvint(0)$.

\ExampleRef{An Uncaught Exception} shows a specification whose evaluation
results in a \dynamicerrorterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Prosebuildgenv{$\tenv$}{$\spec$}{$\env$}{$\vg$}\ProseOrError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{normal}
    \begin{itemize}
      \item evaluating the subprogram \texttt{main} with an empty list of actual arguments and empty list of parameters
      in $\env$ yields $\Normal([(\vv, \vgtwo)], \Ignore)$\ProseOrError;
      \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge;
      \item the result of the entire evaluation is $(\vv, \vg)$.
    \end{itemize}

    \item \AllApplyCase{throwing}
    \begin{itemize}
      \item evaluating the subprogram \texttt{main} with an empty list of actual arguments and empty list of parameters
      in $\env$ yields $\Throwing(\vvopt, \Ignore)$, which is an uncaught exception;
      \item the result of the entire evaluation is an error indicating that an exception was not caught.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[normal]{
  \buildgenv(\tenv, \vspec) \evalarrow (\env, \vgone) \OrDynError\\\\
  \evalsubprogram(\env, \vmain, \emptylist, \emptylist)\evalarrow \Normal([(\vv, \vgtwo)], \Ignore) \OrDynError\\\\
  \vg \eqdef \ordered{\vgone}{\aslpo}{\vgtwo}
}{
  \evalspec(\tenv, \vspec) \evalarrow (\vv, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[throwing]{
  \buildgenv(\tenv, \vspec) \evalarrow (\env, \vgone) \OrDynError\\\\
  \evalsubprogram(\env, \vmain, \emptylist, \emptylist) \evalarrow \Throwing(\vvopt, \Ignore)
}{
  \evalspec(\tenv, \vspec) \evalarrow \DynamicErrorVal{\UncaughtException}
}
\end{mathpar}
\CodeSubsection{\EvalSpecBegin}{\EvalSpecEnd}{../Interpreter.ml}

\SemanticsRuleDef{BuildGlobalEnv}
The helper relation
\hypertarget{def-buildgenv}{}
\[
  \buildgenv(\overname{\staticenvs}{\tenv}, \overname{\spec}{\typedspec}) \;\aslrel\;
  (\overname{\envs}{\newenv}\times\overname{\XGraphs}{\newg}) \cup \overname{\TDynError}{\DynErrorConfig}
\]
populates the environment $\env$ and output execution graph $\newg$ with the global
storage declarations in $\typedspec$, starting from the static environment $\tenv$.
This works by traversing the global storage declarations
and updating the environment accordingly.
\ProseOtherwiseDynamicError

It is assumed that $\typedspec$ lists the declarations in reverse order with respect
to the \defusedependencyterm\ order
(see \TypingRuleRef{TypeCheckAST}).

See \ExampleRef{Evaluating a List of Global Declarations}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item define the environment $\env$ as consisting of the static environment $\tenv$ and the empty dynamic environment $\emptydenv$;
  \item evaluating the global storage declarations in $\typedspec$ in $\env$ with the empty execution graph
        is $(\newenv, \newg)$\ProseOrError.
  \item the result of the entire evaluation is $(\newenv, \newg)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqdef (\tenv, \emptydenv)\\
  \evalglobals(\typedspec, (\env, \emptygraph)) \evalarrow (\newenv, \newg) \OrDynError
}{
  \buildgenv(\tenv, \typedspec) \evalarrow (\newenv, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalBuildGlobalEnvBegin}{\EvalBuildGlobalEnvEnd}{../Interpreter.ml}
