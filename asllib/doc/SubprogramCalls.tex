\chapter{Subprogram Calls\label{chap:SubprogramCalls}}

Subprograms can be called via an expression or as a statement.
Subprogram calls include invocations of getters and setters.

\ExampleDef{Recursive Subprogram Calls}
Subprograms can call each other recursively.
For example, in \listingref{MutualRecursion},
the longest possible call path is \verb|foo->bar->foo->bar->foo->bar-foo->bar|.
The final call to \verb|bar| is a \dynamicerrorterm.
\ASLListing{Mutual recursion}{MutualRecursion}{\definitiontests/MutualRecursion.bad.asl}

\ExampleDef{Invoking Getters and Setters}
\listingref{AccessorDeclaration} shows an example of declaring an accessor \verb|X|
and then invoking its getter and its setter.

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Subprogram Calls} defines the formal relations for subprogram calls;
  \item \SyntaxRef{Subprogram Calls} defines the syntax of subprogram calls;
  \item \AbstractSyntaxRef{Subprogram Calls} defines the abstract syntax of subprogram calls;
  \item \TypeRulesRef{Subprogram Calls} defines the type rules for subprogram calls,
        and includes a discussion on parameter elision (\secref{ParameterElision}); and
  \item \SemanticsRulesRef{Subprogram Calls} defines the dynamic semantics of subprogram calls.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Subprogram Calls}
\paragraph{Syntax:} Subprogram calls are grammatically derived from $\Nexpr$ and $\Nstmt$.
\paragraph{Abstract Syntax:} Subprogram calls are derived in the abstract syntax by
  $\ECall$ and $\SCall$;
\paragraph{Typing:} Subprogram calls are annotated by $\annotatecall$;
\paragraph{Semantics:} Subprogram calls are evaluated by $\evalcall$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SyntaxDef{Subprogram Calls}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Nexpr \derives\  & \Tidentifier \parsesep \PlistZero{\Nexpr} &\\
\Nstmt \derives \ & \Tidentifier \parsesep \PlistZero{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\AbstractSyntaxDef{Subprogram Calls}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RenderTypes[remove_hypertargets]{calls}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \ECall(\call) &\\
\stmt \derives\ & \SCall(\call) &
\end{flalign*}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\TypeRulesDef{Subprogram Calls}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The rule for typing calls is \TypingRuleRef{AnnotateCall}.

We also define helper functions via respective rules:
\begin{itemize}
  \item \TypingRuleRef{AnnotateCallActualsTyped}
  \item \TypingRuleRef{InsertStdlibParam}
  \item \TypingRuleRef{CheckParamsTypeSat}
  \item \TypingRuleRef{RenameTyEqs}
  \item \TypingRuleRef{SubstExprNormalize}
  \item \TypingRuleRef{SubstExpr}
  \item \TypingRuleRef{SubstConstraint}
  \item \TypingRuleRef{CheckArgsTypeSat}
  \item \TypingRuleRef{AnnotateRetTy}
  \item \TypingRuleRef{SubprogramForSignature}
  \item \TypingRuleRef{FilterCallCandidates}
  \item \TypingRuleRef{CallTypeMatches}
  \item \TypingRuleRef{HasArgClash}
  \item \TypingRuleRef{ExpressionList}
\end{itemize}

\TypingRuleDef{AnnotateCall}
\RenderRelation{annotate_call}
\BackupOriginalRelation{
The function
\[
  \annotatecall(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\call}{\vcall}
   ) \aslto
  (\overname{\call}{\vcallp} \times
  \overname{\Option{ \ty }}{\rettyopt} \times
  \overname{\TSideEffectSet}{\vses}
  )
\]
annotates the call $\vcall$ to a subprogram with call type $\calltype$, resulting in the following:
\begin{itemize}
  \item $\vcallp$ --- the updated call, with all arguments/parameters annotated and \\
        $\vcall.\callname$ updated to uniquely identify the call among the set of overloading subprograms declared with the same name;
  \item $\rettyopt$ --- the \optionalterm\ annotated return type;
  \item $\vses$ --- the \sideeffectsetterm\ inferred for $\vcall$.
\end{itemize}
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Parameterized Subprogram Calls}
The specifications in \listingref{AnnotateCall} and \listingref{AnnotateCall2} are well-typed.
\ASLListing{Well-typed parameterized subprogram calls}{AnnotateCall}{\typingtests/TypingRule.AnnotateCall.asl}
\ASLListing{Well-typed parameterized subprogram calls}{AnnotateCall2}{\typingtests/TypingRule.AnnotateCall2.asl}

\ExampleDef{A Call with an Illegal Parameter Type}
The specification in \listingref{AnnotateCall-bad} is illegal since
the type of \verb|wid| --- \verb|integer{2,4,8}| --- does not \subtypesatisfyterm{}
the type of the parameter \verb|N| --- \verb|integer{2,4}|.
\ASLListing{An illegal parameter type}{AnnotateCall-bad}{\typingtests/TypingRule.AnnotateCall.bad.asl}

The specification in \listingref{AnnotateCall-bad2} is illegal since
expressions passed as parameters need to be \constrainedintegersterm.
\ASLListing{An illegal parameter type}{AnnotateCall-bad2}{\typingtests/TypingRule.AnnotateCall.bad2.asl}

The specification in \listingref{AnnotateCall-bad3} is illegal since
expressions passed as parameters need to be \constrainedintegersterm.
\ASLListing{An illegal parameter type}{AnnotateCall-bad3}{\typingtests/TypingRule.AnnotateCall.bad3.asl}

The specification in \listingref{AnnotateCall-bad4} is illegal since
the type of \verb|N| --- \verb|integer{N} --- does not \typesatisfyterm{} \verb|integer{1,2,3}|.
\ASLListing{An illegal parameter type}{AnnotateCall-bad4}{\typingtests/TypingRule.AnnotateCall.bad4.asl}

For more examples, see \ExampleRef{Annotating Calls with Typed Parameters and Typed Arguments}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\annotateexprlist$ to annotate the expression list $\vcall.\callargs$ in $\tenv$ yields \\
        $\args$\ProseOrTypeError;
  \item applying $\annotateexprlist$ to annotate the expression list $\vcall.\callparams$ in $\tenv$ yields \\
        $\params$\ProseOrTypeError;
  \item applying $\annotatecallactualstyped$ to $\vcall.\callname$, $\params$, $\args$, and \\
        $\vcall.\callcalltype$ in $\tenv$ yields $(\vcallp, \retty, \vses)$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexprlist(\tenv, \vcall.\callargs) \typearrow \args \OrTypeError\\\\
  \annotateexprlist(\tenv, \vcall.\callparams) \typearrow \params \OrTypeError\\\\
  {
    \begin{array}{r}
  \annotatecallactualstyped(\tenv, \vcall.\callname, \params, \args, \vcall.\callcalltype) \typearrow \\
   (\vcallp, \retty, \vses) \OrTypeError
    \end{array}
  }
}{
  \annotatecall(\tenv, \vcall) \typearrow
  (\vcallp, \retty)
}
\end{mathpar}
\CodeSubsection{\AnnotateCallBegin}{\AnnotateCallEnd}{../Typing.ml}
\identi{VFDP} \identd{TRFW} \identr{KMDB}
\identi{YMHX} \identr{CCVD} \identr{QYBH} \identr{PFWQ} \identr{ZLWD}
\identi{FLKF} \identd{PMBL} \identr{MWBN} \identr{TZSP} \identr{SBWR}
\identi{CMLP} \identr{BQJG} \identr{RTCF}

\TypingRuleDef{AnnotateCallActualsTyped}
\RenderRelation{annotate_call_actuals_typed}
\BackupOriginalRelation{
The function
\[
  \annotatecallactualstyped\left(
    \begin{array}{c}
      \overname{\staticenvs}{\tenv} \aslsep\\
      \overname{\Identifier}{\name} \aslsep\\
      \overname{\KleeneStar{(\ty \times\expr \times \TSideEffectSet)}}{\params} \aslsep\\
      \overname{\KleeneStar{(\ty \times\expr \times \TSideEffectSet)}}{\typedargs} \aslsep\\
      \overname{\subprogramtype}{\calltype}
    \end{array}
  \right) \aslto
  \begin{array}{c}
  (\overname{\call}{\vcall} \aslsep
  \overname{\Option{ \ty }}{\rettyopt})\\
  \cup\ \overname{\typeerror}{\TypeErrorConfig}
  \end{array}
\]
is similar to $\annotatecall$, except that it accepts the annotated versions of
the parameter and argument expressions as inputs,
that is, tuples consisting of types, annotated expressions, and \sideeffectdescriptorsetsterm.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Calls with Typed Parameters and Typed Arguments}
In \listingref{AnnotateCallActualsTyped-bad1}, the call expression \verb|xor_extend{64}(bv1, bv2)|
is ill-typed, since \\
\verb|xor_extend| has two parameters and only one was supplied.
\ASLListing{An ill-typed call expression}{AnnotateCallActualsTyped-bad1}{\typingtests/TypingRule.AnnotateCallActualsTyped.bad1.asl}

In \listingref{AnnotateCallActualsTyped-bad2}, the call expression \verb|xor_extend{64, 32}(bv1)|
is ill-typed, since \\
\verb|xor_extend| has two arguments and only one was supplied.
\ASLListing{An ill-typed call expression}{AnnotateCallActualsTyped-bad2}{\typingtests/TypingRule.AnnotateCallActualsTyped.bad2.asl}

In \listingref{AnnotateCallActualsTyped-bad3}, the call expression \verb|plus{64}(bv1, w)|
is ill-typed, since \\
the type of the argument \verb|w|, which is \verb|integer{0..128}|, does not \typesatisfyterm{}
the type of the formal argument \verb|z| (\verb|integer{0..N}|), with \verb|N| substituted by \verb|64|.
That is, \\
\verb|integer{0..64}|.
\ASLListing{An ill-typed call expression}{AnnotateCallActualsTyped-bad3}{\typingtests/TypingRule.AnnotateCallActualsTyped.bad3.asl}

In \listingref{AnnotateCallActualsTyped-bad4}, the call expression \verb|ones{myWid}()|
is ill-typed, since \verb|myWid| has the \unconstrainedintegertypeterm.
\ASLListing{An ill-typed call expression}{AnnotateCallActualsTyped-bad4}{\typingtests/TypingRule.AnnotateCallActualsTyped.bad4.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\unziplistthree$ to $\typedargs$ yields the corresponding list of types $\argtypes$,
        list of expressions $\args$, and a list of \sideeffectdescriptorsetsterm\ $\vsessargs$;
  \item define $\vsesargs$ as the union of $\vsessargs$;
  \item applying $\subprogramforsignature$ to match $\name$, $\argtypes$, and $\calltype$ in $\tenv$
        yields $(\namep, \funcsig, \vsescall)$\ProseOrTypeError;
  \item define $\vses$ as the union of $\vsesargs$ and $\vsescall$;
  \item applying $\insertstdlibparam$ to $\funcsig$, $\params$, and $\argtypes$ yields new parameters $\paramsone$;
  \item checking that the lengths of $\funcsig.\funcparameters$ and $\paramsone$ are the same yields $\True$\ProseTerminateAs{\BadCall};
  \item checking that the lengths of $\funcsig.\funcargs$ and $\args$ are the same yields $\True$\ProseTerminateAs{\BadCall};
  \item applying $\checkparamstypesat$ to $\paramsone$
        to check that the actual parameters have correct types with respect to $\funcsig.\funcparameters$
        in $\tenv$ yields $\True$\ProseOrTypeError;
  \item define $\eqs$ as the association of declared parameter names in $\funcsig.\funcparameters$ with actual parameters $\paramsone$;
  \item applying $\checkargstypesat$ to $\argtypes$ and $\eqs$
        to check that the actual arguments have correct types with respect to $\funcsig.\funcargs$
        in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\annotateretty$ to $\eqs$, $\calltype$, and $\funcsig.\funcreturntype$
        to check that the two call types match and to substitute actual parameter arguments in the formal return type
        yields $\rettyopt$ \ProseOrTypeError;
  \item define $\vcall$ as the call with name $\namep$, parameters taken from $\paramsone$, arguments $\vargs$,
        and call type $\funcsig.\funcsubprogramtype$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \unziplistthree(\typedargs) = (\argtypes, \args, \vsessargs)\\
  \vsesargs \eqdef \bigcup \vsessargs \\
  {
    \begin{array}{r}
      \subprogramforsignature(\tenv, \name, \argtypes, \calltype) \typearrow \\
      (\nameone, \funcsig, \vsescall) \OrTypeError
    \end{array}
  }\\
  \vses \eqdef \vsesargs \cup \vsescall\\
  \insertstdlibparam(\funcsig, \params, \argtypes) \typearrow \paramsone\\\\
  \equallength(\funcsig.\funcparameters, \paramsone) \typearrow \paramaritymatch \\\\
  \techeck(\paramaritymatch, \BadCall) \typearrow \True \OrTypeError\\\\
  \equallength(\funcsig.\funcargs, \args) \typearrow \aritymatch\\
  \techeck(\aritymatch, \BadCall) \typearrow \True \OrTypeError\\\\
  \checkparamstypesat(\tenv, \funcsig.\funcparameters, \paramsone) \typearrow \True \OrTypeError\\\\
  \eqs \eqdef [(\vx_i, \Ignore) \in \funcsig.\funcsigparams_i ,\; (\Ignore, \vv_i, \Ignore) \in \paramsone: (\vx_i, \vv_i) ] \\
  \checkargstypesat(\tenv, \funcsig.\funcargs, \argtypes, \eqs) \typearrow \True \OrTypeError\\\\
  \annotateretty(\tenv, \calltype, \funcsig.\funcreturntype, \eqs) \typearrow \rettyopt \OrTypeError
}{
  {
    \begin{array}{r}
  \annotatecallactualstyped(\tenv, \name, \params, \typedargs, \calltype) \typearrow \\
  \left(\overname{\left\{
      \begin{array}{rcl}
        \callname &:& \namep,\\
        \callparams &:& [(\Ignore, \vv_i, \Ignore) \in \paramsone: \vv_i],\\
        \callargs &:& \args,\\
        \callcalltype &:& \funcsig.\funcsubprogramtype
      \end{array}
  \right\}}{\vcall}
  , \rettyopt, \vses\right)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\AnnotateCallActualsTypedBegin}{\AnnotateCallActualsTypedEnd}{../Typing.ml}

\TypingRuleDef{InsertStdlibParam}
\RenderRelation{insert_stdlib_param}
\BackupOriginalRelation{
The function
\[
\insertstdlibparam(
  \overname{\func}{\funcsig} \aslsep
  \overname{\KleeneStar{(\ty\times\expr)}}{\params} \aslsep
  \overname{\KleeneStar{\ty}}{\argtypes}
  ) \aslto \\
  \overname{\KleeneStar{(\ty\times\expr\times\TSideEffectSet)}}{\paramsone}
\]
inserts the (optionally) omitted input parameter of a standard library function call.
} % END_OF_BACKUP_RELATION

Note that this function relies on all standard library functions with input parameters having one of two simple forms:
\begin{lstlisting}
  func stdlibA{N}  (arg1: bits(N), ...) => ...
  func stdlibB{M,N}(arg1: bits(N), ...) => bits(...M...)
\end{lstlisting}

\ExampleDef{Inserting Parameters in Calls to Standard Library Subprograms}
The specification in \listingref{InsertStdlibParam}
shows examples of calls to standard library functions with some or all of their
parameters elided, and the equivalent calls with all parameters included.
\ASLListing{Inserting parameters in calls to standard library subprograms}{InsertStdlibParam}{\typingtests/TypingRule.InsertStdlibParam.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \Proseeqdef{$\caninsertstdlibparam$}{the conjunction of the following conditions:
    \begin{itemize}
      \item $\canomitstdlibparam$ holds for $\funcsig$;
      \item the number of parameters $\params$ is less than the number of parameters in $\funcsig$;
      \item $\argtypes$ is not the empty list.
    \end{itemize}
  }
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{can\_insert}
    \begin{itemize}
      \item \Proseeqdef{$\vt$}{the \head{} of $\argtypes$};
      \item applying $\getbitvectorwidth$ to $\tenv$ and $\vt$ yields $\vwidth$\ProseOrTypeError;
      \item \Proseeqdef{$paramtype$}{the \wellconstrainedintegertypeterm{} for the single
            constraint consisting of the \exactconstraintterm{} for $\vwidth$};
      \item \Proseeqdef{$\paramsone$}{the list whose \head{} is $\params$ and \tail{} is
            the tuple consisting of $\paramtype$, $\vwidth$, and the empty list of \sideeffectdescriptorsetsterm}.
    \end{itemize}
  \end{itemize}

  \begin{itemize}
    \item \AllApplyCase{cannot\_insert}
    \begin{itemize}
      \item $\caninsertstdlibparam$ is $\False$;
      \item \Proseeqdef{$\paramsone$}{$\params$}.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[can\_insert]{
  {
    \caninsertstdlibparam \eqdef \left(\begin{array}{ll}
      \canomitstdlibparam(\funcsig) & \land\\
      \listlen{\params} < \listlen{\funcsig.\funcparameters} & \land\\
      \argtypes \neq \emptylist &
    \end{array}\right)
  }\\
  \caninsertstdlibparam = \True\\\\
  \argtypes \eqname [\vt] \concat \Ignore\\
  \getbitvectorwidth(\tenv, \vt) \typearrow \vwidth \OrTypeError\\\\
  \paramtype \eqdef \TInt(\WellConstrained([\AbbrevConstraintExact{\vwidth}]))\\
  \paramsone \eqdef \params \concat [(\paramtype, \vwidth, \emptyset)]
}{
  \insertstdlibparam(\funcsig, \params, \argtypes) \aslto \paramsone
}
\end{mathpar}

\begin{mathpar}
\inferrule[cannot\_insert]{
  {
    \caninsertstdlibparam \eqdef \left(\begin{array}{ll}
      \canomitstdlibparam(\funcsig) & \land\\
      \listlen{\params} < \listlen{\funcsig.\funcparameters} & \land\\
      \argtypes \neq \emptylist &
    \end{array}\right)
  }\\
  \caninsertstdlibparam = \False
}{
  \insertstdlibparam(\funcsig, \params, \argtypes) \aslto \overname{\params}{\paramsone}
}
\end{mathpar}

\TypingRuleDef{CanOmmitStdlibParam}
\RenderRelation{can_omit_stdlib_param}
\BackupOriginalRelation{
The function
\[
  \canomitstdlibparam(\overname{\func}{\funcsig}) \aslto \overname{\Bool}{\vb}
\]
tests whether the first parameter of the subprogram defined by
$\funcsig$ can be omitted (and thus automatically inserted), yielding the result in $\vb$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Determining Whether a Parameter Can be Omitted}
The following are examples of subprogram signatures
where the first parameter can be omitted:
\begin{lstlisting}
func UInt{N: integer{1..128}} (x: bits(N)) => integer{0..2^N-1}
func Len{N}(x: bits(N)) => integer {N}
func ZeroExtend {N,M} (x: bits(M)) => bits(N)
\end{lstlisting}

The following are examples of subprogram signatures
where the first parameter cannot be omitted:
\begin{lstlisting}
func ReplicateBit{N}(isZero: boolean) => bits(N)
func Ones{N}() => bits(N)
\end{lstlisting}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\funcsig$ is in the standard library;
  \item \Proseeqdef{$\declaredparam$}{
    $\some{\vn}$ if the list of parameters in $\funcsig$ contains a single parameter whose name is $\vn$
    or the list contains two parameters and the second parameter name is $\vn$;
    and $\None$ otherwise
  };
  \item \Proseeqdef{$\vb$}{$\True$ if and only if
        $\declaredparam$ is $\some{\vn}$ and the first argument of $\funcsig$
        has a \bitvectortypeterm{} where the width is defined as the variable expression for $\vn$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \funcsig.\funcbuiltin\\\\
  {
    \declaredparam \eqdef \begin{cases}
      \some{\vn} & \text{if }\funcsig.\funcparameters = [(\vn, \Ignore)]\\
      \some{\vn} & \text{if }\funcsig.\funcparameters = [\Ignore, (\vn, \Ignore)]\\
      \None      & \text{else}
    \end{cases}
  }\\
  \vb \eqdef \declaredparam = \some{\vn} \land
  \funcsig.\funcargs = (\Ignore, \TBits(\EVar(\vn), \Ignore))
}{
  \canomitstdlibparam(\funcsig) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{CheckParamsTypeSat}
\RenderRelation{check_params_typesat}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\checkparamstypesat(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\KleeneStar{(\Identifier\times\Option{\ty})}}{\funcsigparams} \aslsep
  \overname{\KleeneStar{(\ty\times\expr\times\TSideEffectSet)}}{\params}
  ) \aslto \\
  \{\True\}\ \cup \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
checks that annotated parameters $\params$ are correct with respect to the declared parameters $\funcsigparams$.
\ProseOtherwiseTypeError\
It assumes that $\funcsigparams$ and $\params$ have the same length.
} % END_OF_BACKUP_RELATION

\ExampleDef{Checking that Expression Types Type-satisfy Parameters}
In \listingref{CheckParamsTypeSat},
annotating the call expression \verb|FlipSlice{FOUR, EIGHT}(bv)|
requires checking that both expression \verb|FOUR| and \verb|EIGHT| are \symbolicallyevaluableterm{}
and constrained, which they are.
Since the parameter \verb|M| is annotated with the type \\
\verb|integer{0..64}|,
the typechecker checks that the type of \verb|FOUR|, which is \verb|integer{4}| \typesatisfiesterm{}
\verb|integer{0..64}|.
The parameter \verb|N| is not annotated with a type --- its type is
determined to be \\
$\TInt(\Parameterized(\texttt{N}))$ --- and there is no need to check that
the type of \verb|EIGHT|, which is \verb|integer{8}|, \typesatisfiesterm{} $\TInt(\Parameterized(\texttt{N}))$.

\ASLListing{Checking that expression types type-satisfy parameters}{CheckParamsTypeSat}{\typingtests/TypingRule.CheckParamsTypeSat.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\funcsigparams$ is an empty list;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApply
  \begin{itemize}
    \item $\funcsigparams$ is a non-empty list with \head\ $(\vx, \tydeclopt)$ and \\
          \tail\ $\funcsigparamsone$, and
          $\params$ is a non-empty list with \head\ \\
          $(\tyactual, \eactual, \vsesactual)$ and \tail\ $\paramsone$;
    \item \Prosechecksymbolicallyevaluable{$\vsesactual$};
    \item checking that $\tyactual$ represents a \constrainedintegerterm{} yields $\True$\ProseOrTypeError;
    \item \OneApplies
    \begin{itemize}
      \item \AllApplyCase{parameterized}
      \begin{itemize}
        \item $\tyactual$ is a \parameterizedintegertypeterm{} for the parameter $\vx$, that is, \\
              $\some{\TInt(\Parameterized(\vx))}$.
      \end{itemize}

      \item \AllApplyCase{other}
      \begin{itemize}
        \item $\tydeclopt$ is not $\None$, that is, $\some{\tydecl}$;
        \item $\tydecl$ is not the \parameterizedintegertypeterm{} for the parameter $\vx$;
        \item checking that $\tyactual$ \typesatisfiesterm{} $\tydecl$ in $\tenv$ yields
              $\True$\ProseOrTypeError;
      \end{itemize}
    \end{itemize}
    \item applying $\checkparamstypesat$ to $\funcsigparamsone$ and $\paramsone$ in $\tenv$
          yields \\ $\True$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \checkparamstypesat(\tenv, \overname{\emptylist}{\funcsigparams}, \Ignore) \typearrow \True
}
\and
\inferrule[parameterized]{
  \funcsigparams = [(\vx, \tydeclopt)] \concat \funcsigparamsone\\
  \params = [(\tyactual, \eactual, \vsesactual)] \concat \paramsone\\
  \checksymbolicallyevaluable(\vsesactual) \typearrow \True\OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \tyactual) \typearrow \True\OrTypeError\\\\
  \commonprefixline\\\\
  \tydeclopt = \some{\TInt(\Parameterized(\vx))}\\\\
  \checkparamstypesat(\tenv, \funcsigparamsone, \paramsone) \typearrow \True \OrTypeError
}{
  \checkparamstypesat(\tenv, \funcsigparams, \params) \typearrow \True
}
\and
\inferrule[other]{
  \funcsigparams = [(\vx, \tydeclopt)] \concat \funcsigparamsone\\
  \params = [(\tyactual, \eactual, \vsesactual)] \concat \paramsone\\
  \checksymbolicallyevaluable(\vsesactual) \typearrow \True\OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \tyactual) \typearrow \True\OrTypeError\\\\
  \commonprefixline\\\\
  \tydeclopt \eqname \some{\tydecl}\\
  \tydecl \neq \TInt(\Parameterized(\vx))\\
  \checktypesat(\tenv, \tyactual, \tydecl) \typearrow \True \OrTypeError\\\\
  \checkparamstypesat(\tenv, \funcsigparamsone, \paramsone) \typearrow \True \OrTypeError
}{
  \checkparamstypesat(\tenv, \funcsigparams, \params) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{RenameTyEqs}
\RenderRelation{rename_ty_eqs}
\BackupOriginalRelation{
The function
\[
\renametyeqs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\KleeneStar{(\Identifier\times\expr)}}{\eqs} \aslsep
  \overname{\ty}{\tty}
) \aslto
\overname{\ty}{\newty} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
transforms the type $\tty$ in the \staticenvironmentterm{} $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, yielding the type $\newty$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Transforming Parameterized Types Based on Actual Arguments}
In \listingref{RenameTyEqs}, annotating the call expression \verb|FlipPrefix{8}(bv, 4)|
requires substituting \verb|8| for \verb|N| in the types
\verb|bits(N)| and \verb|integer{0..N}|, yielding the types
\verb|bits(8)| and \verb|integer{0..8}|.
\ASLListing{Transforming parameterized types based on actual arguments}{RenameTyEqs}{\typingtests/TypingRule.RenameTyEqs.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{t\_bits}
  \begin{itemize}
    \item $\tty$ is a bitvector type with width expression $\ve$ and fields $\fields$, that is, $\TBits(\ve, \fields)$;
    \item applying $\substexprnormalize$ to $\eqs$ and $\ve$ in $\tenv$ yields the expression $\newe$;
    \item define $\newty$ as a bitvector type with expression $\newe$ and fields $\fields$.
  \end{itemize}

  \item \AllApplyCase{t\_int\_wellconstrained}
  \begin{itemize}
    \item $\tty$ is a well-constrained integer type with constraints $\constraints$;
    \item applying $\substconstraint$ to each constraint $\constraints[\vi]$, for $\vi$ in \\
          $\listrange(\constraints)$, yields the constraint $\newc_\vi$;
    \item define $\newconstraints$ as the list of constraints $\newc_\vi$, for $\vi$ in \\
          $\listrange(\constraints)$;
    \item define $\newty$ as the well-constrained integer type with constraints \\
          $\newconstraints$.
  \end{itemize}

  \item \AllApplyCase{t\_int\_parameterized}
  \begin{itemize}
    \item $\tty$ is a \parameterizedintegertypeterm\ for the parameter $\name$;
    \item applying $\substexprnormalize$ to $\eqs$ and the expression $\EVar(\name)$ yields $\ve$;
    \item define $\newty$ as the well-constrained integer type with the single constraint for $\ve$, that is,
          $\TInt(\WellConstrained(\ConstraintExact(\ve)))$.
  \end{itemize}

  \item \AllApplyCase{t\_tuple}
  \begin{itemize}
    \item $\tty$ is the \tupletypeterm{} over the list of tuples $\tys$, that is, $\TTuple(\tys)$;
    \item applying $\renametyeqs$ to $\eqs$ and the type $\tys[\vi]$, for each $\vi$ in \\
          $\listrange(\tys)$, yields the type $\newty_\vi$;
    \item define $\newtys$ as the list of types $\newty_\vi$, for each $\vi$ in $\listrange(\tys)$;
    \item define $\newty$ as the \tupletypeterm{} over $\newtys$, that is, $\TTuple(\newtys)$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\tty$ is not one of the types in the previous cases,
          that is, $\tty$ is not a bitvector type, nor an integer type, nor a \tupletypeterm{};
    \item $\newty$ is $\tty$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[t\_bits]{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}{
  \renametyeqs(\tenv, \eqs, \overname{\TBits(\ve, \fields)}{\tty}) \typearrow \overname{\TBits(\newe, \fields)}{\newty}
}
\and
\inferrule[t\_int\_wellconstrained]{
  \vi\in\listrange(\constraints): \substconstraint(\tenv, \constraints[\vi]) \typearrow \newc_\vi\\
  \newconstraints \eqdef [\vi\in\listrange(\constraints): \newc_\vi]\\
  \newty \eqdef \TInt(\WellConstrained(\newconstraints))
}{
  \renametyeqs(\tenv, \eqs, \overname{\TInt(\WellConstrained(\constraints))}{\tty}) \typearrow
  \newty
}
\and
\inferrule[t\_int\_parameterized]{
  \substexprnormalize(\eqs, \EVar(\name)) \typearrow \ve\\
  \newty \eqdef \TInt(\WellConstrained(\ConstraintExact(\ve)))
}{
  \renametyeqs(\tenv, \eqs, \overname{\TInt(\Parameterized(\name))}{\tty}) \typearrow \newty
}
\and
\inferrule[t\_tuple]{
  \vi\in\listrange(\tys): \renametyeqs(\eqs, \tys[\vi]) \typearrow \newty_\vi\\
  \newtys \eqdef [\vi\in\listrange(\tys): \newty_\vi]
}{
  \renametyeqs(\tenv, \eqs, \overname{\TTuple(\tys)}{\tty}) \typearrow
  \overname{\TTuple(\newtys)}{\newty}
}
\and
\inferrule[other]{
  \astlabel(\tty) \not\in \{\TBits, \TInt, \TTuple\}
}{
  \renametyeqs(\tenv, \eqs, \tty) \typearrow \overname{\tty}{\newty}
}
\end{mathpar}

\TypingRuleDef{SubstExprNormalize}
\RenderRelation{subst_expr_normalize}
\BackupOriginalRelation{
The function
\[
\substexprnormalize(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\KleeneStar{(\Identifier\times\expr)}}{\eqs} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\expr}{\newe}
\]
transforms the expression $\ve$ in the \staticenvironmentterm{} $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, and then attempting to symbolically simplify the result, yielding the expression $\newe$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Substituting Parameter Expressions and Normalizing}
In \listingref{SubstExpr},
considering the call expression \verb|plus{z + 22}(bv1, z)|,
the expression \verb|z + 22| is substituted for the parameter \verb|N| in the type
\verb|bits(N + 2)| used for the argument \verb|x| and as the return type of \verb|plus|,
resulting in the expression \verb|(40 + 22) + 2|, which is then normalized into \verb|64|.
\ASLListing{Substituting Parameter Expressions}{SubstExpr}{\typingtests/TypingRule.SubstExpr.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item transforming $\ve$ in the \staticenvironmentterm{} $\tenv$, by substituting the parameter expressions
        $\eqs$, yields $\veone$;
  \item symbolically simplifying $\veone$ in $\tenv$ yields $\newe$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \substexpr(\tenv, \ve) \typearrow \veone\\
  \normalize(\tenv, \veone) \typearrow \newe
}{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}
\end{mathpar}

\TypingRuleDef{SubstExpr}
\RenderRelation{subst_expr}
\BackupOriginalRelation{
The function
\[
\substexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\KleeneStar{(\Identifier\times\expr)}}{\substs} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\expr}{\newe}
\]
transforms the expression $\ve$ in the \staticenvironmentterm{} $\tenv$,
by substituting parameter names with their corresponding expressions in
$\substs$, yielding the expression $\newe$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

The function assumes that $\ve$ appears in the declaration of a parameter,
which means it is in the subset allowed by $\extractparameters$.

See \ExampleRef{Substituting Parameter Expressions and Normalizing}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{e\_var\_in\_substs}
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vs$, that is, $\EVar(\vs)$;
    \item applying $\assocopt$ to $\vs$ and $\substs$ yields the expression $\newe$.
          That is, $\vs$ is a parameter with an associated expression;
  \end{itemize}

  \item \AllApplyCase{e\_var\_not\_in\_substs}
  \begin{itemize}
    \item $\ve$ is the variable expression for the identifier $\vs$, that is, $\EVar(\vs)$;
    \item applying $\assocopt$ to $\vs$ and $\substs$ yields $\None$.
          That is, $\vs$ is not a parameter with an associated expression;
    \item define $\newe$ is $\ve$.
  \end{itemize}

  \item \AllApplyCase{e\_unop}
  \begin{itemize}
    \item $\ve$ is the unary operator expression for the operator $\op$ and expression $\ve$, that is, $\EUnop(\op, \veone)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the unary operator expression for the operator $\op$ and expression $\veonep$, that is, $\EUnop(\op, \veonep)$.
  \end{itemize}

  \item \AllApplyCase{e\_binop}
  \begin{itemize}
    \item $\ve$ is the binary operator expression for the operator $\op$ and expressions $\veone$ and $\vetwo$, that is, $\EBinop(\op, \veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the unary operator expression for the operator $\op$ and expression $\veonep$, that is, $\EUnop(\op, \veonep)$.
  \end{itemize}

  \item \AllApplyCase{e\_cond}
  \begin{itemize}
    \item $\ve$ is the conditional expression for expressions $\veone$, $\vetwo$, and $\vethree$, that is, \\
          $\ECond(\veone, \vetwo, \vethree)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item applying $\substexpr$ to $\substs$ and $\vethree$ in $\tenv$ yields $\vethreep$;
    \item define $\newe$ as the conditional expression for expressions $\veonep$, $\vetwop$, and $\vethreep$, that is, $\ECond(\veonep, \vetwop, \vethreep)$.
  \end{itemize}

  \item \AllApplyCase{e\_call}
  \begin{itemize}
    \item $\ve$ is the call expression for subprogram $\vx$ with arguments $\vargs$ and parameter expressions $\paramargs$,
          that is, $\ECall(\vx, \vargs, \paramargs)$;
    \item applying $\substexpr$ to $\substs$ and every argument expression $\vargs[\vi]$, for $\vi$ in
          $\listrange(\vargs)$ yields $\ve_\vi$;
    \item define $\vargsp$ as $\ve_\vi$ for each $\vi$ in $\listrange(\vargs)$;
    \item define $\newe$ as the call expression for subprogram $\vx$ with arguments $\vargsp$ and parameter expressions $\paramargs$,
    that is, $\ECall(\vx, \vargsp, \paramargs)$.
  \end{itemize}

  \item \AllApplyCase{e\_getarray}
  \begin{itemize}
    \item $\ve$ is the \arrayaccessterm\ expression for base expression $\veone$ and index expression $\vetwo$,
          that is, $\EGetArray(\veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the \arrayaccessterm\ expression for base expression $\veonep$ and index expression $\vetwop$,
    that is, $\EGetArray(\veonep, \vetwop)$.
  \end{itemize}

  \item \AllApplyCase{e\_getenumarray}
  \begin{itemize}
    \item $\ve$ is the \arrayaccessterm\ expression for base expression $\veone$ and an enumeration-typed index expression $\vetwo$,
          that is, $\EGetEnumArray(\veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the \arrayaccessterm\ expression for base expression $\veonep$ and \\
          enumeration-typed index expression $\vetwop$,
          that is, $\EGetEnumArray(\veonep, \vetwop)$.
  \end{itemize}

  \item \AllApplyCase{e\_getfield}
  \begin{itemize}
    \item $\ve$ is the field access expression for base expression $\ve$ and field $\vx$,
          that is, $\EGetField(\veone, \vx)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the field access expression for base expression $\ve$ and field $\vx$,
          that is, $\EGetField(\veonep, \vx)$.
  \end{itemize}

  \item \AllApplyCase{e\_getfields}
  \begin{itemize}
    \item $\ve$ is the access to fields $\fields$ with base expression $\veone$, that is, \\
          $\EGetFields(\veone, \fields)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the access to fields $\fields$ with base expression $\veonep$, that is, $\EGetFields(\veonep, \fields)$.
  \end{itemize}

  \item \AllApplyCase{e\_getitem}
  \begin{itemize}
    \item $\ve$ is the access to tuple item $\vi$ of the tuple expression $\veone$, that is, \\
          $\EGetItem(\veone, \vi)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the access to tuple item $\vi$ of the tuple expression $\veonep$, that is, \\
          $\EGetItem(\veonep, \vi)$.
  \end{itemize}

  \item \AllApplyCase{e\_pattern}
  \begin{itemize}
    \item $\ve$ is the pattern expression of expression $\veone$ and patterns $\vps$, that is, \\
          $\EPattern(\veone, \vps)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the pattern expression of expression $\veonep$ and patterns $\vps$, that is, $\EPattern(\veonep, \vps)$.
  \end{itemize}

  \item \AllApplyCase{e\_record}
  \begin{itemize}
    \item $\ve$ is the record expression of record type $\vt$ and list of fields $\fields$;
    \item for every pair $(\vx,\veone)$ in $\fields$, applying $\substexpr$ to $\substs$ $\veone$ in $\tenv$ yields $\veonep_\vx$;
    \item define $\fieldsp$ as the list of pairs $(\vx,\veonep_\vx)$ for every pair $(\vx,\veone)$ in $\fields$;
    \item define $\newe$ as the record expression of record type $\vt$ and list of fields $\fieldsp$.
  \end{itemize}

  \item \AllApplyCase{e\_slice}
  \begin{itemize}
    \item $\ve$ is the slicing expression for subexpression $\veone$ and list of slices $\vslices$, that is, $\ESlice(\veone, \vslices)$;
    \item applying $\substexpr$ to $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as slicing expression for subexpression $\veonep$ and list of slices \\
          $\vslices$, that is, $\ESlice(\veonep, \vslices)$.
  \end{itemize}

  \item \AllApplyCase{e\_tuple}
  \begin{itemize}
    \item $\ve$ is the tuple expression of expressions $\ves$, that is, $\ETuple(\ves)$;
    \item applying $\substexpr$ to $\substs$ and every expression $\ves[\vi]$ in $\tenv$, for every $\vi$ in $\listrange(\ves)$
          yields $\newe_\vi$;
    \item define $\vesp$ as the list of expressions $\newe_\vi$, for every $\vi$ in $\listrange(\ves)$;
    \item define $\newe$ as the tuple expression of expressions $\vesp$, that is, $\ETuple(\vesp)$.
  \end{itemize}

  \item \AllApplyCase{e\_array}
  \begin{itemize}
    \item $\ve$ is an array construction expression with length expression $\length$ and value expression $\vvalue$, that is,
          $\EArray\{\EArrayLength: \length, \EArrayValue: \vvalue\}$;
    \item applying $\substexpr$ to $\substs$ and $\length$ in $\tenv$ yields $\lengthp$;
    \item applying $\substexpr$ to $\substs$ and $\vvalue$ in $\tenv$ yields $\vvaluep$;
    \item define $\newe$ as the array construction expression with length expression \\
          $\lengthp$ and initial element value expression $\vvaluep$, that is, \\
          $\EArray\{\EArrayLength: \lengthp, \EArrayValue: \vvaluep\}$.
  \end{itemize}

  \item \AllApplyCase{e\_enumarray}
  \begin{itemize}
    \item $\ve$ is an array construction expression for an enumeration-typed index
          with list of labels $\vlabels$ and initial element value expression $\vvalue$, that is, \\
          $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \vvalue\}$;
    \item applying $\substexpr$ to $\substs$ and $\vvalue$ in $\tenv$ yields $\vvaluep$;
    \item define $\newe$ as the array construction expression with list of labels $\vlabels$
          and value expression $\vvaluep$, that is,
          $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \vvaluep\}$.
  \end{itemize}

  \item \AllApplyCase{e\_atc}
  \begin{itemize}
    \item $\ve$ is the type assertion of expression $\veone$ and type $\vt$, that is, $\EATC(\veone, \vt)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the type assertion of expression $\veonep$ and type $\vt$, that is, $\EATC(\veonep, \vt)$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\ve$ is either a literal expression or an arbitrary value expression;
    \item define $\newe$ as $\ve$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[e\_var\_in\_substs]{
  \assocopt(\vs, \substs) \typearrow \some{\newe}
}{
  \substexpr(\tenv, \substs, \overname{\EVar(\vs)}{\ve}) \typearrow \newe
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_not\_in\_substs]{
  \assocopt(\vs, \substs) \typearrow \None
}{
  \substexpr(\tenv, \substs, \overname{\EVar(\vs)}{\ve}) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\
}{
  \substexpr(\tenv, \substs, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \overname{\EUnop(\op, \veonep)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \overname{\EBinop(\op, \veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop\\
  \substexpr(\tenv, \substs, \vethreep) \typearrow \vethreep\\
}{
  \substexpr(\tenv, \substs, \overname{\ECond(\veone, \vetwo, \vethree)}{\ve}) \typearrow \overname{\ECond(\veonep, \vetwop, \vethreep)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_call]{
  \vi\in\listrange(\vargs): \substexpr(\tenv, \substs, \vargs[\vi]) \typearrow \ve_\vi\\
  \vargsp \eqdef [\vi\in\listrange(\vargs): \ve_\vi]
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\ECall(\vx, \vargs, \paramargs)}{\ve}) \typearrow \\ \overname{\ECall(\vx, \vargsp, \paramargs)}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getarray]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EGetArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\EGetArray(\veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getenumarray]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EGetEnumArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\EGetEnumArray(\veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfield]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetField(\veone, \vx)}{\ve}) \typearrow \overname{\EGetField(\veonep, \vx)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfields]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetFields(\veone, \fields)}{\ve}) \typearrow \overname{\EGetFields(\veonep, \fields)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getitem]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetItem(\veone, \vi)}{\ve}) \typearrow \overname{\EGetItem(\veonep, \vi)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EPattern(\veone, \vps)}{\ve}) \typearrow \overname{\EPattern(\veonep, \vps)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record]{
  (\vx, \veone)\in\fields: \substexpr(\tenv, \substs, \veone) \typearrow \veone_\vx\\
  \fieldsp \eqdef [(\vx, \veone)\in\fields: (\vx, \veone_\vx)]
}{
  \substexpr(\tenv, \substs, \overname{\ERecord(\vt, \fields)}{\ve}) \typearrow \overname{\ERecord(\vt, \fieldsp)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\ESlice(\veone, \slices)}{\ve}) \typearrow \overname{\ESlice(\veonep, \slices)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_tuple]{
  \vi\in\listrange(\ves): \substexpr(\tenv, \substs, \ves[\vi]) \typearrow \newe_\vi\\
  \vesp \eqdef [\vi\in\listrange(\ves): \newe_\vi]
}{
  \substexpr(\tenv, \substs, \overname{\ETuple(\ves)}{\ve}) \typearrow \overname{\ETuple(\vesp)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_array]{
  \substexpr(\tenv, \substs, \length) \typearrow \lengthp\\
  \substexpr(\tenv, \substs, \vvalue) \typearrow \vvaluep
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\EArray\{\EArrayLength: \length, \EArrayValue: \vvalue\}}{\ve}) \typearrow\\
  \overname{\EArray\{\EArrayLength: \length, \EArrayValue: \vvaluep\}}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_enumarray]{
  \substexpr(\tenv, \substs, \vvalue) \typearrow \vvaluep
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \vvalue\}}{\ve}) \typearrow\\
  \overname{\EEnumArray\{\EArrayLabels: \length, \EArrayValue: \vvaluep\}}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_atc]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EATC(\veone, \vt)}{\ve}) \typearrow \overname{\EATC(\veonep, \vt)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \in \{\ELiteral, \EArbitrary\}\
}{
  \substexpr(\tenv, \substs, \ve) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}

\CodeSubsection{\SubstExprBegin}{\SubstExprEnd}{../ASTUtils.ml}

\TypingRuleDef{SubstConstraint}
\RenderRelation{subst_constraint}
\BackupOriginalRelation{
The function
\[
\substconstraint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\KleeneStar{(\Identifier\times\expr)}}{\eqs} \aslsep
  \overname{\intconstraint}{\vc}
) \aslto \overname{\intconstraint}{\newc}
\]
transforms the integer constraint $\vc$ in the \staticenvironmentterm{} $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, and then attempting to symbolically simplify the result,
yielding the integer constraint $\newc$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Substituting Parameter Expressions in Constraints}
In \listingref{SubstExpr},
considering the call expression \verb|plus{z + 22}(bv1, z)|,
the expression \verb|z + 22| is substituted for the parameter \verb|N| in the type
\verb|integer{0..N}| used for the argument \verb|z|,
resulting in the type \verb|integer{0..64}|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\ve$ yields $\newe$;
    \item define $\newc$ as the exact constraint for the expression $\newe$, that is, \\
          $\ConstraintExact(\newe)$.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\veone$ yields $\veonep$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\vetwo$ yields $\vetwop$;
    \item define $\newc$ as the range constraint for the expressions $\veonep$ and $\vetwop$, that is, $\ConstraintRange(\veonep, \vetwop)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}{
  \substconstraint(\tenv, \eqs, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\ConstraintExact(\newe)}{\newc}
}
\and
\inferrule[range]{
  \substexprnormalize(\tenv, \eqs, \veone) \typearrow \veonep\\
  \substexprnormalize(\tenv, \eqs, \vetwo) \typearrow \vetwop
}{
  \substconstraint(\tenv, \eqs, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\ConstraintRange(\veonep, \vetwop)}{\newc}
}
\end{mathpar}

\TypingRuleDef{CheckArgsTypeSat}
\RenderRelation{check_args_typesat}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
  \checkargstypesat(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\KleeneStar{(\Identifier\times\ty)}}{\funcsigargs} \aslsep
    \overname{\KleeneStar{\ty}}{\argtypes} \aslsep
    \overname{\KleeneStar{(\Identifier\times\expr)}}{\eqs}
  ) \aslto \\
  \{\True\}\ \cup \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
checks that the types $\argtypes$ \typesatisfyterm\ the types of the corresponding
formal arguments $\funcsigargs$ with the parameters substituted with their corresponding
arguments as per $\eqs$ and results in a \typingerrorterm{} otherwise.
} % END_OF_BACKUP_RELATION

\ExampleDef{Checking that Actual Arguments Type-satisfy the Formal Arguments}
In \listingref{RenameTyEqs}, checking that the call \verb|FlipPrefix{8}(bv, 4)| is well-typed
requires checking that the types of the arguments --- \verb|bits(8)| and \verb|integer{4}| ---
\typesatisfyterm{} the corresponding types of the formal arguments --- \verb|bits(N)| and \verb|integer{0..N}| ---
once the parameter \verb|N| is substituted for \verb|8|.
That is, that \verb|bits(8)| \typesatisfiesterm{} \verb|bits(8)| and that
\verb|integer{4}| \typesatisfiesterm{} \verb|integer{0..8}|.
Since both these checks hold, the call is indeed well-typed.

In contrast, a call \verb|FlipPrefix{8}(bv, 9)| is ill-typed since
\verb|integer{9}| does not \typesatisfyterm{} \verb|integer{0..8}|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item both $\funcsigargs$ and $\argtypes$ are empty;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item view $\funcsigargs$ as a list with \head\ $(\Ignore, \tydecl)$ and \tail\ $\funcsigargsone$;
    \item view $\argtypes$ as a list with \head\ $\tyactual$ and \tail\ \\
          $\argtypesone$;
    \item applying $\renametyeqs$ to $\eqs$ and $\tydecl$ in $\tenv$
          to substitute parameter arguments in $\tydecl$ yields $\tydeclp$\ProseOrTypeError;
    \item checking that $\tyactual$ \typesatisfiesterm\ $\tydeclp$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item applying $\checkargstypesat$ to $\funcsigargsone$, $\argtypesone$, \\
          and $\eqs$ in $\tenv$
          yields $\True$\ProseOrTypeError;
    \item the result is $\True$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
We note that \TypingRuleRef{AnnotateCallActualsTyped} guarantees
that $\funcsigargs$ and $\argtypes$ have the same length.

\begin{mathpar}
\inferrule[empty]{}{
  \checkargstypesat(\tenv, \overname{\emptylist}{\funcsigargs}, \overname{\emptylist}{\argtypes}, \eqs)
  \typearrow \True
}
\and
\inferrule[non\_empty]{
  \funcsigargs = [(\Ignore, \tydecl)] \concat \funcsigargsone\\
  \argtypes = [\tyactual] \concat \argtypesone\\
  \renametyeqs(\tenv, \eqs, \tydecl) \typearrow \tydeclp\OrTypeError\\\\
  \checktypesat(\tenv, \tyactual, \tydeclp) \typearrow \True\OrTypeError\\\\
  \checkargstypesat(\tenv, \funcsigargsone, \argtypesone, \eqs) \typearrow \True\OrTypeError
}{
  \checkargstypesat(\tenv, \funcsigargs, \argtypes, \eqs) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{AnnotateRetTy}
\RenderRelation{annotate_ret_ty}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\annotateretty(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\subprogramtype}{\calltype} \aslsep
  \overname{\Option{\ty}}{\funcsigrettyopt} \aslsep
  \overname{\KleeneStar{(\Identifier\times\expr)}}{\eqsthree}
) \aslto \\
\overname{\Option{\ty}}{\rettyopt}
\cup \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates the \optionalterm\ return type $\funcsigrettyopt$ given with the subprogram type
$\calltype$ with respect to the parameter expressions $\eqs$,
yielding the \optionalterm\ annotated type $\rettyopt$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating the Return Type of a Subprogram Call}
In \listingref{AnnotateRetTy}, annotating the return type \verb|bits(N)| of the subprogram \verb|flip|
for call expression \verb|flip{64}(bv)|, yields the annotated type \verb|bits(64)|.

Since \verb|proc| does not have a return type, the call statement \verb|proc()| does not require
annotating a return type (thus $\annotateretty$ yields $\None$ for $\rettyopt$).
\ASLListing{Annotating the Return Type of a Subprogram Call}{AnnotateRetTy}{\typingtests/TypingRule.AnnotateRetTy.asl}

\listingref{AnnotateRetTy-bad} shows an example of an ill-typed call statement \verb|flip{64}(bv);|
and an ill-typed call expression \verb|proc()|, since procedures can only be used in call statements
and functions can only be used in call expressions.
\ASLListing{Ill-typed Subprogram Calls}{AnnotateRetTy-bad}{\typingtests/TypingRule.AnnotateRetTy.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{function\_or\_getter}
  \begin{itemize}
    \item $\calltype$ is one of $\STFunction$ or $\STGetter$;
    \item $\funcsig$ is $\some{\tty}$;
    \item applying $\renametyeqs$ to $\eqs$ and $\tty$ yields $\ttyone$\ProseOrTypeError;
    \item $\rettyopt$ is $\some{\ttyone}$.
  \end{itemize}

  \item \AllApplyCase{procedure\_or\_setter}
  \begin{itemize}
    \item $\calltype$ is one of $\STProcedure$ or $\STSetter$;
    \item $\funcsigrettyopt$ is $\None$;
    \item define $\rettyopt$ as $\None$.
  \end{itemize}

  \item \AllApplyCase{ret\_type\_mismatch}
  \begin{itemize}
    \item the condition that $\calltype$ is one of $\STProcedure$ or $\STSetter$
          if and only if $\funcsigrettyopt$ is $\None$ does not hold;
    \item the result is a \typingerrorterm{} indicating the mismatch.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[function\_or\_getter]{
  \calltype \in \{\STFunction, \STGetter\}\\
  \renametyeqs(\eqs, \tty) \typearrow \ttyone \OrTypeError
}{
  \annotateretty(\tenv, \calltype, \overname{\some{\tty}}{\funcsigrettyopt}, \eqs) \typearrow
  \overname{\some{\ttyone}}{\rettyopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[procedure\_or\_setter]{
  \calltype \in \{\STProcedure, \STSetter\}\\
}{
  \annotateretty(\tenv, \calltype, \overname{\None}{\funcsigrettyopt}, \eqs) \typearrow
  \overname{\None}{\rettyopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ret\_type\_mismatch]{
  {
  \neg\left(
    \begin{array}{c}\calltype \in \{\STProcedure, \STSetter\} \leftrightarrow \\
      \funcsigrettyopt=\None
    \end{array}
  \right)
  }
}{
  \annotateretty(\tenv, \calltype, \funcsigrettyopt, \eqs) \typearrow
  \TypeErrorVal{\BadCall}
}
\end{mathpar}

\TypingRuleDef{SubprogramForSignature}
\RenderRelation{subprogram_for_signature}
\BackupOriginalRelation{
The function
\[
  \begin{array}{rl}
    \subprogramforsignature(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\KleeneStar{\ty}}{\callerargtypes} \aslsep
    \overname{\subprogramtype}{\calltype}
    )
    \aslto & \\
    (
    \overname{\Strings}{\namep} \aslsep
    \overname{\func}{\callee} \aslsep
    \overname{\TSideEffectSet}{\vses}
    )
    \cup\ \overname{\typeerror}{\TypeErrorConfig}
  \end{array}
\]
looks up the \staticenvironmentterm{} $\tenv$ for a subprogram associated with $\name$, the list of argument types $\calleeargtypes$, and a subprogram type matching $\calltype$, and determines which one of the following
cases holds:
\begin{enumerate}
  \item there is no declared subprogram that matches $\name$, $\calleeargtypes$, and $\calltype$;
  \item there is exactly one subprogram that matches $\name$, $\calleeargtypes$, and $\calltype$;
\end{enumerate}
If more than one subprogram that matches $\name$ and $\calleeargtypes$,
this is detected by the rule \TypingRuleRef{DeclareSubprograms},
which invokes the rule \\ \TypingRuleRef{DeclareOneFunc},
which invokes the rule \TypingRuleRef{AddNewFunc},
which results in a \typingerrorterm{}.
} % END_OF_BACKUP_RELATION

The first case results in a \typingerrorterm{}.
If the second case holds, the function returns a tuple which comprises:
\begin{itemize}
\item $\namep$ --- the string that uniquely identifies this subprogram;
\item $\callee$ --- the AST node defining the called subprogram; and
\item $\vses$ --- the set of \sideeffectdescriptorsterm{} associated with $\name$.
\end{itemize}
\ProseOtherwiseTypeError

\ExampleDef{Matching a Subprogram to an Identifier}

\listingref{SubprogramForSignature} shows an example where all subprogram calls
match subprogram declarations.
\ASLListing{Successfully matching subprogram signatures to definitions}{SubprogramForSignature}{\typingtests/TypingRule.SubprogramForSignature.asl}

\listingref{SubprogramForSignature-undefined} shows an example where
the subprogram call \verb|add_10(5)| is illegal, since no subprogram named \verb|add_10|
is declared.
\ASLListing{Subprogram signature undefined}{SubprogramForSignature-undefined}{\typingtests/TypingRule.SubprogramForSignature.bad.undefined.asl}

\listingref{SubprogramForSignature} shows an example where
the subprogram call \verb|add_10(5.0)| is illegal, since, although a subprogram named \verb|add_10|
is declared, it does not match the required signature (the type of the first argument is
the \integertypeterm{} rather than the \realtypeterm).
\ASLListing{Subprogram name does not match signature}{SubprogramForSignature-no-candidates}{\typingtests/TypingRule.SubprogramForSignature.bad.no_candidates.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{undefined}
  \begin{itemize}
    \item $\tenv$ does not contain a binding for $\name$ in the $\overloadedsubprograms$ map
          ($G^\tenv.\overloadedsubprograms$);
    \item the result is a \typingerrorterm{} indicating that the identifier has not been declared (as a subprogram).
  \end{itemize}

  \item \AllApplyCase{no\_candidates}
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\overloadedsubprograms$ map to $\renamingset$ and $\vses$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          and call type $\calltype$ in $\tenv$ (see \\ \TypingRuleRef{FilterCallCandidates}) yields an empty set\ProseOrTypeError;
    \item the result is a \typingerrorterm{} indicating that the call given by $\name$ and \\ $\callerargtypes$
          does not match any defined subprogram.
  \end{itemize}

  \item \AllApplyCase{one\_candidate}
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\overloadedsubprograms$ map to $\renamingset$ and $\vses$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          and call type $\calltype$ in $\tenv$ (see \\ \TypingRuleRef{FilterCallCandidates}) yields \\
          $\matchingrenamings$\ProseOrTypeError;
    \item $\matchingrenamings$ contains a single element --- $(\namep, \callee)$\ProseOrTypeError;
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[undefined]{
  G^\tenv.\overloadedsubprograms(\name) = \bot
}{
  \subprogramforsignature(\tenv, \name, \callerargtypes, \calltype) \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_candidates]{
  G^\tenv.\overloadedsubprograms(\name) = (\renamingset, \vses)\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \calltype, \renamingset) \typearrow \emptyset \OrTypeError
    \end{array}
  }
}{
  \subprogramforsignature(\tenv, \name, \callerargtypes, \calltype) \typearrow \TypeErrorVal{\BadCall}
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_candidate]{
  G^\tenv.\overloadedsubprograms(\name) = (\renamingset, \vses)\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset, \calltype) \typearrow \\ \matchingrenamings \OrTypeError
    \end{array}
  }\\\\
  \matchingrenamings = [(\namep, \callee)]
}{
  {
    \begin{array}{r}
  \subprogramforsignature(\tenv, \name, \callerargtypes, \calltype) \typearrow \\ (\namep, \callee, \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SubprogramForSignatureBegin}{\SubprogramForSignatureEnd}{../Typing.ml}

\TypingRuleDef{FilterCallCandidates}
\RenderRelation{filter_call_candidates}
\BackupOriginalRelation{
The function
\[
  \filtercallcandidates(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\KleeneStar{\ty}}{\formaltypes} \aslsep
    \overname{\subprogramtype}{\calltype} \aslsep
    \overname{\pow{\Strings}}{\candidates}
    )
  \aslto \overname{\KleeneStar{(\Strings\times\func)}}{\matches}
\]
iterates over the list of unique subprogram names in $\candidates$ and checks whether
their lists of arguments clash with the types in $\formaltypes$ and their subprogram types match $\calltype$ in $\tenv$.
The result is the set of pairs consisting of the names and function definitions of the
subprograms whose arguments clash and subprogram types match in $\candidates$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

The names $\candidates$ are assumed to exist in $G^\tenv.\subprograms$.

\ExampleDef{Filtering Subprograms Matching a Call}
In \listingref{SubprogramForSignature}, filtering the
set of declared subprograms for the call expression \verb|add_10(5)| yields
the (singleton list containing the) subprogram \\
\verb|func add_10(x: integer) => integer|.
In contrast, filtering the set of declared subprograms for the call expression
\verb|add_10(5.0)| in \listingref{SubprogramForSignature-no-candidates},
yields an empty list.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{no\_candidates}
  \begin{itemize}
    \item $\candidates$ is empty;
    \item $\matches$ is empty.
  \end{itemize}

  \item \AllApplyCase{candidates\_exist}
  \begin{itemize}
    \item $\candidates$ is a list with \head\ $\name$ and \tail\ $\candidatesone$;
    \item the function definition associated with $\name$ in $\tenv$ is $\funcdef$;
    \item determining whether there is an argument clash between $\formaltypes$ and the arguments in $\funcdef$
          (that is, $\funcdef.\funcargs$) yields $\vbone$\ProseOrTypeError;
  \item determining whether $\funcdef$ is compatible with $\calltype$ via $\calltypematches$ yields $\vbtwo$;
    \item filtering the call candidates in $\candidatesone$ with $\formaltypes$ and $\calltype$ in $\tenv$ yields $\matchesone$\ProseOrTypeError;
    \item if $\vbone$ and $\vbtwo$ are both $\True$ then $\matches$ is the list with \head\ $(\name,\funcdef)$ and \tail\ $\matchesone$,
          and otherwise it is $\matchesone$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_candidates]
{}{
  \filtercallcandidates(\tenv, \formaltypes, \calltype, \overname{\emptylist}{\candidates}) \typearrow \overname{\emptylist}{\matches}
}
\end{mathpar}

\begin{mathpar}
\inferrule[candidates\_exist]
{
  \funcdef \eqdef G^\tenv.\subprograms(\name) \\
  \hasargclash(\tenv, \formaltypes, \funcdef.\funcargs) \typearrow \vbone \OrTypeError\\\\
  \calltypematches(\funcdef, \calltype) \typearrow \vbtwo \\\\
  {
  \begin{array}{r}
    \filtercallcandidates(\tenv, \formaltypes, \calltype, \candidatesone) \typearrow \\ \matchesone \OrTypeError
  \end{array}
  }\\\\
  \matches \eqdef \choice{\vbone \land \vbtwo}{\;[(\name,\funcdef)] \concat \matchesone}{\;\matchesone}
}{
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \formaltypes, \calltype, \overname{[\name] \concat \candidatesone}{\candidates}) \\ \typearrow \matches
    \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{CallTypeMatches}
\RenderRelation{call_type_matches}
\BackupOriginalRelation{
The function
\[
  \calltypematches(
    \overname{\func}{\funcdef} \aslsep
    \overname{\subprogramtype}{\calltype}
  )
  \aslto \overname{\Bool}{\vb}
\]
checks whether a function definition $\funcdef$ is compatible with the subprogram type expected by a function call, $\calltype$, yielding the result in $\vb$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Matching call types}
The table below shows keywords used to define functions, and their possible compatible call types.

\begin{center}
\begin{tabular}{ll}
\textbf{Keyword used to define function} & \textbf{Compatible call types} \\
\hline
\verb|func|                            & $\STFunction$, $\STProcedure$ \\
\verb|getter| (inside \verb|accessor|) & $\STFunction$, $\STGetter$    \\
\verb|setter| (inside \verb|accessor|) & $\STSetter$                   \\
\end{tabular}
\end{center}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{getter\_func}
  \begin{itemize}
    \item $\funcdef.\funcsubprogramtype$ is $\STGetter$;
    \item $\calltype$ is $\STFunction$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{equal}
  \begin{itemize}
    \item either $\funcdef.\funcsubprogramtype$ is not $\STGetter$, or $\calltype$ is not $\STFunction$;
    \item define $\vb$ as whether $\funcdef.\funcsubprogramtype$ is equal to $\calltype$;
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[getter\_func]{
  \funcdef.\funcsubprogramtype = \STGetter \\
  \calltype = \STFunction
}{
  \calltypematches(\func, \calltype) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[equal]{
  (\funcdef.\funcsubprogramtype \neq \STGetter \lor \calltype \neq \STFunction) \\
  \vb \eqdef \funcdef.\funcsubprogramtype = \calltype
}{
  \calltypematches(\func, \calltype) \typearrow \vb
}
\end{mathpar}

\CodeSubsection{\CallTypeMatchesBegin}{\CallTypeMatchesEnd}{../Typing.ml}

\TypingRuleDef{HasArgClash}
\RenderRelation{has_arg_clash}
\BackupOriginalRelation{
The function
\[
  \hasargclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\KleeneStar{\ty}}{\formaltys} \aslsep
    \overname{\KleeneStar{(\Identifier\times\ty)}}{\vargs}
  )
  \aslto \overname{\Bool}{\vb} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether a list of types $\formaltys$ clashes with the list of types appearing
in the list of arguments $\vargs$ in $\tenv$, yielding the result in $\vb$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Argument Clashing}
\listingref{type-clashes} shows examples of types ---
the arguments of procedures -- that do not clash and types that do clash
(shown in comments).
\ASLListing{Examples of Argument clashing}{type-clashes}{\typingtests/TypingRule.TypeClashes.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item equating the list lengths of $\formaltys$ and $\vargs$ either yields $\True$
        or $\False$, which short-circuits the entire rule;
  \item $\argtys$ is the list of types appearing in $\vargs$, in the same order;
  \item for each $\vi$ in the list of indices of $\formaltys$, applying $\typeclashes$ to
        $\formaltys[\vi]$ and $\argtys[\vi]$ in $\tenv$ yields $\True$\ProseTerminateAs{\False, \TypeErrorConfig};
  \item $\vb$ is $\True$ (unless the rule short-circuited with $\False$ or a \typingerrorterm{}).
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \equallength(\formaltypes, \vargs) \typearrow \True \terminateas \False\\\\
  \argtys \eqdef [(\Ignore, \vt) \in \vargs: \vt]\\
  \vi\in\listrange(\formaltys): \typeclashes(\tenv, \formaltys[\vi], \argtys[\vi]) \typearrow \True \terminateas \False,\TypeErrorConfig
}{
  \hasargclash(\tenv, \formaltys, \vargs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}
\CodeSubsection{\HasArgClashBegin}{\HasArgClashEnd}{../Typing.ml}

\TypingRuleDef{TypeClash}
\RenderRelation{type_clashes}
\BackupOriginalRelation{
The function
\[
  \typeclashes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
determines whether a type $\vt$ \emph{\Prosetypeclashes} with a type $\vs$ in environment $\tenv$,
returning the result $\vb$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\identd{VPZZ} \identi{PQCT} \identi{WZKM} \identi{WZKM}
Note that \Prosetypeclashing{} is an equivalence relation.
In particular note that if $T$ \Prosetypeclashes{} with $A$ and $B$ then $A$ and
$B$ \Prosetypeclash{}.

See \ExampleRef{Argument Clashing}

\ExampleDef{Ill-typed Subprogram Declarations}
In specification \listingref{TypeClash-bad}, the type \verb|SuperRec| \emph{\Prosetypeclashes} \verb|SubRec|
in the \staticenvironmentterm{} where both types have been annotated,
which is why both declarations of \verb|structured_procedure| clash and thus they are ill-typed.
\ASLListing{Ill-typed Subprogram Declarations}{TypeClash-bad}{\typingtests/TypingRule.TypeClashes.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{subtype}
  \begin{itemize}
    \item either $\vs$ subtypes $\vt$ or $\vt$ subtypes $\vs$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{simple}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structureterm\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
    \item obtaining the \structureterm\ of $\vs$ in $\tenv$ yields $\vsstruct$\ProseOrTypeError;
    \item both $\vtstruct$ and $\vsstruct$ are one of the following types: \\
          \booleantypesterm{}, \integertypeterm{}, \realtypeterm{}, or \stringtypeterm{};
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{t\_enum}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structureterm\ of $\vt$ in $\tenv$ yields an \enumerationtypeterm{} with labels $\vlit$;
    \item obtaining the \structureterm\ of $\vs$ in $\tenv$ yields an \enumerationtypeterm{} with labels $\vlis$;
    \item $\vb$ is $\True$ if and only if $\vlis$ and $\vlit$ are equal.
  \end{itemize}

  \item \AllApplyCase{t\_array}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structureterm\ of $\vt$ in $\tenv$ yields an array type with element type $\vtyt$;
    \item obtaining the \structureterm\ of $\vs$ in $\tenv$ yields an array type with element type $\vtys$;
    \item $\vb$ is $\True$ if and only if $\vtyt$ and $\vtys$ type-clash.
  \end{itemize}

  \item \AllApplyCase{t\_tuple}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structureterm\ of $\vt$ in $\tenv$ yields a \tupletypeterm{} with element types $\vt_{1..k}$;
    \item obtaining the \structureterm\ of $\vs$ in $\tenv$ yields a \tupletypeterm{} with element types $\vs_{1..n}$;
    \item if $n \neq k$ the rule short-circuits with $\vb=\False$;
    \item $\vb$ is $\True$ if and only if $\vt_i$ type-clashes with $\vs_i$, for all $i=1..k$.
  \end{itemize}

  \item \AllApplyCase{otherwise\_different\_labels}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structureterm\ of $\vt$ in $\tenv$ yields $\vtstruct$;
    \item obtaining the \structureterm\ of $\vs$ in $\tenv$ yields $\vsstruct$;
    \item $\vsstruct$ and $\vtstruct$ have different AST labels;
    \item $\vb$ is $\False$;
  \end{itemize}

  \item \AllApplyCase{otherwise\_structured}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structureterm\ of $\vt$ in $\tenv$ yields $\vtstruct$;
    \item obtaining the \structureterm\ of $\vs$ in $\tenv$ yields $\vsstruct$;
    \item $\vsstruct$ and $\vtstruct$ have the same AST label;
    \item $\vtstruct$ (and thus $\vsstruct$) is a \structuredtypeterm;
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[subtype]{
  (\issubtype(\tenv, \vs, \vt) \typearrow \True) \lor (\issubtype(\tenv, \vt, \vs) \typearrow \True)
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[simple]{
  \issubtype(\tenv, \vs, \vt) \typearrow \False\\
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \OrTypeError \\
  \astlabel(\vtstruct)=\astlabel(\vsstruct)\\
  \astlabel(\vtstruct) \in \{\TBool, \TInt, \TReal, \TString, \TBits\}
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \issubtype(\tenv, \vs, \vt) \typearrow \False\\
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \TEnum(\Ignore, \vlis) \\
  \tstruct(\tenv, \vs) \typearrow \TEnum(\Ignore, \vlit)
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\vlis = \vlit}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array]{
  \issubtype(\tenv, \vs, \vt) \typearrow \False\\
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \TArray(\Ignore, \vtyt) \\
  \tstruct(\tenv, \vs) \typearrow \TArray(\Ignore, \vtys) \\
  \typeclashes(\tenv, \vtyt, \vtys) \typearrow \vb
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  \issubtype(\tenv, \vs, \vt) \typearrow \False\\
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) \typearrow \TTuple(\vs_{1..n}) \\
  \booltrans(n = k) \booltransarrow \True \terminateas \False\\
  i=1..k: \typeclashes(\tenv, \vt_i, \vs_i) \typearrow \vb_i\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_i
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise\_different\_labels]{
  \issubtype(\tenv, \vs, \vt) \typearrow \False\\
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \\
  \astlabel(\vtstruct) \neq \astlabel(\vsstruct)
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise\_structured]{
  \issubtype(\tenv, \vs, \vt) \typearrow \False\\
  \issubtype(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \\
  \astlabel(\vtstruct) = \astlabel(\vsstruct)\\
  \astlabel(\vtstruct) \in \{\TRecord, \TException, \TCollection\}
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}
\CodeSubsection{\TypeClashBegin}{\TypeClashEnd}{../types.ml}

\subsubsection{Comment}
Note that if $\vt$ \subtypesatisfiesterm{} $\vs$ then $\vt$ and $\vs$ \Prosetypeclash, but not the other
way around.

\TypingRuleDef{ExpressionList}
\RenderRelation{annotate_exprs}
\BackupOriginalRelation{
The function
\[
  \annotateexprlist(\overname{\staticenvs}{\tenv} \aslsep \overname{\KleeneStar{\expr}}{\exprs})
  \aslto \overname{\KleeneStar{(\ty \times \expr \times \TSideEffectSet)}}{\typedexprs}
  \cup \overname{\typeerror}{\TypeErrorConfig}
\]
annotates a list of expressions $\exprs$ from left to right, yielding a list of tuples \\
$\typedexprs$,
each consisting of a type, an annotated expression, and a \sideeffectsetterm.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating a List of Expressions}
In \listingref{ExpressionList}, the list of expressions \verb|10, 20.0|
is annotated as
\[
\left[
\begin{array}{lll}
(\TInt(\WellConstrained([\AbbrevConstraintExact{\ELInt{10}}])),& \eliteral{\LInt(10)},& \emptyset),\\
(\TReal,& \eliteral{\LReal(20)},& \emptyset)
\end{array}
\right]
\]
\ASLListing{Annotating a list of expressions}{ExpressionList}{\typingtests/TypingRule.ExpressionList.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\exprs$ is empty;
    \item $\typedexprs$ is empty.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\exprs$ has $\ve$ as its \head\ expression and $\exprsone$ as its \tail;
    \item annotating $\ve$ in $\tenv$ yields the pair $\vtypedexpr$ consisting of a type
          and an expression\ProseOrTypeError;
    \item annotating the expression list $\exprsone$ in $\tenv$ yields
          $\typedexprs$\ProseOrTypeError;
    \item \Proseeqdef{$\typedexprs$}{the \Proselist{$\vtypedexpr$}{$\typedexprs$}}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \annotateexprlist(\tenv, \overname{\emptylist}{\exprs}) \typearrow \overname{\emptylist}{\typedexprs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \annotateexpr(\tenv, \ve) \typearrow \vtypedexpr \OrTypeError\\\\
  \annotateexprlist(\tenv, \exprsone) \typearrow \typedexprsone \OrTypeError
}{
  \annotateexprlist(\tenv, \overname{[\ve] \concat \exprsone}{\exprs}) \typearrow \overname{[\vtypedexpr] \concat \typedexprsone}{\typedexprs}
}
\end{mathpar}

\subsection{Parameter Elision\label{sec:ParameterElision}}

ASL allows dropping a parameter from the parameter list of a subprogram call
in two situations:
\begin{itemize}
  \item During AST building of declaration statements
        (\secref{DeclarationStatementsElidedParameter}).
        In this case, the first parameter expression may be elided when the left-hand side
        expression is explicitly annotated as a bitvector type whose width is taken to be the parameter expression.
        We refer to this as \emph{parameter elision}.
        The call must contain \verb|{...}|, even if they are empty.
  \item During type checking of standard library calls (\TypingRuleRef{InsertStdlibParam}).
        In this case, a parameter expression can be inferred by matching the call expression
        against one of two patterns (see the rule for details and examples).
        If omitting a parameter yields an empty list, the \verb|{...}| must be entirely removed.
        We refer to this as \emph{parameter omission}.
\end{itemize}

These two situations are exemplified in \listingref{ParameterElision}.
\ASLListing{Parameter elision and parameter omission}{ParameterElision}{\definitiontests/ParameterElision.asl}

The specification in \listingref{ParameterElision-bad} is ill-typed,
since the parameter for the call expression \verb|X(data, n)| is inferred based on the left-hand-side
expressions, and therefore an empty list of parameters must be given.
\ASLListing{Erroneous parameter elision}{ParameterElision-bad}{\definitiontests/ParameterElision.bad.asl}

The specification in \listingref{ParameterOmission-bad} is ill-typed,
as an empty parameter list for a standard library function must be entirely omitted.
\ASLListing{Erroneous parameter omission}{ParameterOmission-bad}{\definitiontests/ParameterOmission.bad.asl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SemanticsRulesDef{Subprogram Calls}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The rule for evaluating subprogram calls is \SemanticsRuleRef{Call}.

We also define the following helper rules:
\begin{itemize}
  \item \SemanticsRuleRef{EvalSubprogram}
  \item \SemanticsRuleRef{ReadValueFrom}
  \item \SemanticsRuleRef{AssignArgs}
  \item \SemanticsRuleRef{MatchFuncRes}
\end{itemize}

\SemanticsRuleDef{Call}
\RenderRelation{eval_call}
\BackupOriginalRelation{
The relation
\[
  \evalcall(\overname{\envs}{\env} \aslsep
  \overname{\Identifier}{\name} \aslsep
  \overname{\KleeneStar{\expr}}{\params} \aslsep
  \overname{\KleeneStar{\expr}}{\args}) \;\aslrel\;
  \left(
  \begin{array}{ll}
  \ResultCall(\overbracket{\KleeneStar{(\nativevalue\times\XGraphs)}}^{\vmstwo}, \overname{\envs}{\newenv}) & \cup \\
  \overname{\TDynError}{\DynErrorConfig} & \cup \\
  \overname{\TDiverging}{\DivergingConfig} & \\
  \end{array}
  \right)
\]
evaluates a call to the subprogram named $\name$ in the environment $\env$,
with the parameter expressions $\params$ and the argument expressions
$\args$.
The evaluation results in either a list of returned values, each one associated
with an execution graph, and a new environment.
\ProseOtherwiseAbnormal
} % END_OF_BACKUP_RELATION

The evaluation first evaluates the expressions corresponding to the arguments
and parameters and then passes their values in a resulting configuration
to the helper relation $\evalsubprogram$.

\ExampleDef{Calling Subprograms}
In \listingref{Call}, calling \verb|non_throwing_func| terminates normally,
while calling \\
\verb|throwing_func| terminates by throwing an exception.
\ASLListing{Calling subprograms}{Call}{\semanticstests/SemanticsRule.Call.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item evaluating each expression in $\params$ separately in $\env$ as per\\
        \SemanticsRuleRef{EExprListM} is $\ResultExprListM(\vvparams, \envone)$\ProseOrAbnormal;
  \item evaluating each expression in $\args$ separately in $\envone$ as per \\
        \SemanticsRuleRef{EExprListM} is $\ResultExprListM(\vvargs, \envtwo)$\ProseOrAbnormal;
  \item $\envtwo$ consists of the \staticenvironmentterm{} $\tenv$ and the dynamic environment $\denvtwo$;
  \item applying $\incrpendingcalls$ to $G^\denvtwo$ and $\name$ yields $\genv$;
  \item the environment $\envtwo'$ is defined as the environment
  consisting of the \staticenvironmentterm{} $\tenv$ and the dynamic environment with the global component
  $\genv$ and an empty local component (intuitively, this is because the called subprogram does not have access
  to the local environment of the caller);
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{normal}
    \begin{itemize}
      \item evaluating the subprogram named $\name$ with parameters $\vvparams$ and arguments $\vvargs$ in
            $\denvtwo'$ is $\ResultCall(\vms, (\vglobal, \Ignore))$ (that is, we ignore the local environment
            of the callee)\ProseOrDynErrorDiverging;
      \item applying the helper relation $\readvaluefrom$ to each element of the list $\vms$ yields the list $\vmstwo$;
      \item applying $\decrpendingcalls$ to $\vglobal$ and $\name$ yields $\genvtwo$;
      \item define $\newenv$ as the environment where the \staticenvironmentterm{} is $\tenv$ and the dynamic environment consists
            of the dynamic global environment $\genvtwo$ and the dynamic local environment is taken from $\denvtwo$
            (that is, we restore the local environment to that of the caller and drop the local environment of the callee).
      \item the entire evaluation results in $\ResultCall(\vmstwo, \newenv)$.
    \end{itemize}

    \item \AllApplyCase{throwing}
    \begin{itemize}
      \item evaluating the subprogram named $\name$ with arguments $\vvargs$ and parameters $\vvparams$ in
            $\denvtwo'$ is $\Throwing(\vv, \vt, \vg, \envthrow)$\ProseOrDynErrorDiverging;
      \item view $\envthrow$ as the environment consisting of the \staticenvironmentterm{} $\tenv$,
            and the dynamic environment whose global component is $\vglobal$;
      \item applying the helper relation $\readvaluefrom$ to $\vms$ yields $\vmstwo$;
      \item applying $\decrpendingcalls$ to $\vglobal$ and $\name$ yields $\genvtwo$;
      \item define $\newenv$ as the environment where the \staticenvironmentterm{} is $\tenv$ and the dynamic environment consists
            of the dynamic global environment $\genvtwo$ and the dynamic local environment is taken from $\denvtwo$
            (that is, we restore the local environment to that of the caller and drop the local environment of the callee).
      \item the entire evaluation results in $\ResultCall(\vmstwo, \newenv)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[normal]{
  \evalexprlistm(\env, \params) \evalarrow \ResultExprListM(\vvparams, \envone)\OrAbnormal\\\\
  \evalexprlistm(\envone, \args) \evalarrow \ResultExprListM(\vvargs, \envtwo)\OrAbnormal\\\\
  \envtwo \eqname (\tenv, \denvtwo)\\
  \incrpendingcalls(G^\denvtwo, \name) \evalarrow \genv\\\\
  \envtwo' \eqdef (\tenv, (\genv, \emptyfunc))\\\\
  \commonprefixline\\\\
  \evalsubprogram(\envtwo', \name, \vvparams, \vvargs) \evalarrow \ResultCall(\vms, (\vglobal, \Ignore)) \OrDynErrorDiverging\\\\
  \vmstwo \eqdef [\vm \in \vms: \readvaluefrom(\vm)]\\
  \decrpendingcalls(\vglobal, \name) \evalarrow \genvtwo\\
  \newenv \eqdef (\tenv, (\genvtwo, L^{\denvtwo}))
}{
  \evalcall(\env, \name, \params, \args) \evalarrow \ResultCall(\vmstwo, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[throwing]{
  \evalexprlistm(\env, \args) \evalarrow \ResultExprListM(\vvargs, \envone)\OrAbnormal\\\\
  \evalexprlistm(\envone, \params) \evalarrow \ResultExprListM(\vvparams, \envtwo)\OrAbnormal\\\\
  \envtwo \eqname (\tenv, \denvtwo)\\
  \incrpendingcalls(G^\denvtwo, \name) \evalarrow \genv\\\\
  \envtwo' \eqdef (\tenv, (\genv, \emptyfunc))\\\\
  \commonprefixline\\\\
  \evalsubprogram(\envtwo', \name, \vvparams, \vvargs) \evalarrow \Throwing(\vv, \vt, \vg, \envthrow) \OrDynErrorDiverging\\\\
  \envthrow \eqname (\tenv, (\vglobal, \Ignore))\\
  \decrpendingcalls(\vglobal, \name) \evalarrow \genvtwo\\
  \newenv \eqdef (\tenv, (\genvtwo, L^{\denvtwo}))
}{
  \evalcall(\env, \name, \params, \args) \evalarrow \Throwing(\vv, \vt, \vg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalCallBegin}{\EvalCallEnd}{../Interpreter.ml}

\SemanticsRuleDef{EvalSubprogram}
\RenderRelation{eval_subprogram}
\BackupOriginalRelation{
The relation
\[
  \evalsubprogram\left(
  \begin{array}{cl}
  \overname{\envs}{\env} & \aslsep\\
  \overname{\Identifier}{\name} & \aslsep\\
  \overname{\KleeneStar{(\nativevalue \times \XGraphs)}}{\params} & \aslsep\\
  \overname{\KleeneStar{(\nativevalue \times \XGraphs)}}{\args} &
  \end{array}
  \right)
  \;\aslrel\;
  \left(
  \begin{array}{cl}
  \ResultCall(\overname{(\KleeneStar{\nativevalue} \aslsep \XGraphs)}{\vvs}, \overname{\envs}{\newenv}) & \cup\\
  \overname{\TThrowing}{\ThrowingConfig} & \cup\\
  \overname{\TDynError}{\DynErrorConfig} & \cup\\
  \overname{\TDiverging}{\DivergingConfig} &
  \end{array}
  \right)
\]
evaluates the subprogram named $\name$ in the environment $\env$, with
$\actualargs$ the list of actual arguments, and $\params$ the
list of arguments deduced by type equality.
The result is either a \Prosenormalconfiguration{} or an abnormal configuration.
In the case of a \Prosenormalconfiguration{}, it consists of a list of pairs
with a value and an identifier, and a new environment $\newenv$.
The values represent values returned by the subprogram call and the
identifiers are used in generating execution graph constraints for the
returned values.
} % END_OF_BACKUP_RELATION


\ExampleDef{Subprogram Calls}
In \listingref{semantics-fcall},
the function \texttt{main} calls the function \texttt{foo} and the procedure \texttt{bar}.
\ASLListing{Evaluating subprogram calls}{semantics-fcall}{\semanticstests/SemanticsRule.FCall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\env$ consists of the \staticenvironmentterm{} $\tenv$ and the dynamic environment with the global
        component $\genv$ and an empty local component;
  \item finding the function named $\name$ in $\tenv$ (via the $\subprograms$ component of the static global environment of $\tenv$)
        gives the AST $\func$ node with body
        $\vbody$, parameters $\paramdecls$, arguments $\argdecls$, and optional recursion limit expression $\vrecurselimit$;
  \item $\envone$ is the environment consisting of the \staticenvironmentterm{} $\tenv$ and the dynamic
        environment consisting of the dynamic component from $\denv$ and an empty local component;
  \item applying $\checkrecurselimit$ to $\name$ and $\vrecurselimit$ in $\envone$ yields \\
        $\vgone$\ProseOrDynErrorDiverging;
  \item \Proseeqdef{$\argnames$}{the identifiers appearing as the first component of each pair in $\argdecls$};
  \item assigning the actual arguments with $((\envone, \emptygraph), \argnames, \args)$
        as per \SemanticsRuleRef{AssignArgs} gives $(\envtwo, \vgtwo)$ and ensures that each
        formal argument in $\argdecls$ is
        locally bound to the corresponding actual value in $\args$;
  \item \Proseeqdef{$\paramnames$}{the identifiers appearing as the first component of each pair in $\params$};
  \item assigning the actual parameters with $((\envtwo, \emptygraph), \paramnames, \paramdecls)$
        as per \SemanticsRuleRef{AssignArgs} gives $(\envthree, \vgthree)$ and ensures that each
        formal parameter in $\paramdecls$ is
        locally bound to the corresponding actual value in $\params$;
  \item evaluating the body of the subprogram $\vbody$ as a statement in $\envthree$
        is $\vres$\ProseOrAbnormal;
  \item matching the result $\vres$ to obtain a \Prosenormalconfiguration{} as per \\
        \SemanticsRuleRef{MatchFuncRes} gives $C$;
  \item $\newg$ is the ordered composition of $\vgone$ with the $\asldata$ and $\vgtwo$ and $\vgthree$ with the $\aslpo$ edge;
  \item the result is $C$ with its graph substituted for $\newg$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqname (\tenv, \denv)\\
  {
    G^\tenv.\subprograms(\name) \eqname \left\{
      \begin{array}{rcl}
      \funcbody &:& \vbody,\\
      \funcargs &:& \argdecls,\\
      \funcparameters &:& \paramdecls,\\
      \funcrecurselimit &:& \vrecurselimit, \\
      &&\ldots
      \end{array}
      \right\}
  }\\
  \envone \eqdef (\tenv, (G^\denv, \emptyfunc))\\
  \checkrecurselimit(\envone, \name, \vrecurselimit) \evalarrow \vgone \OrDynErrorDiverging\\\\
  \argnames \eqdef [(\vx, \Ignore) \in \argdecls: \vx]\\
  \assignargs((\envone, \emptygraph), \argnames, \actualargs) \evalarrow (\envtwo, \vgtwo)\\
  \paramnames \eqdef [(\vx, \Ignore) \in \params: \vx]\\
  \assignargs((\envtwo, \vgtwo), \paramnames, \paramdecls) \evalarrow (\envthree, \vgthree)\\
  \evalstmt(\envthree, \vbody) \evalarrow \vres \OrAbnormal\\
  \matchfuncres(\vres) \evalarrow C\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\ordered{\vgtwo}{\aslpo}{\vgthree}}\\
}{
  \evalsubprogram(\env, \name, \actualargs, \params) \evalarrow \withgraph{C}{\newg}
}
\end{mathpar}
\CodeSubsection{\EvalFCallBegin}{\EvalFCallEnd}{../Interpreter.ml}

\subsubsection{Comments}
\identr{DFWZ}
It is not an error for execution of a procedure or setter to end without a
return statement.

\SemanticsRuleDef{CheckRecurseLimit}
\RenderRelation{check_recurse_limit}
\BackupOriginalRelation{
The relation
\[
  \checkrecurselimit(\overname{\envs}{\env} \aslsep \overname{\Identifier}{\name} \aslsep \overname{\Option{\expr}}{\velimitopt}) \aslto
  \overname{\XGraphs}{\vg} \cup \overname{\TDynError}{\DynErrorConfig}
\]
checks whether the value in the optional expression $\velimitopt$ has reached the limit associated with $\name$
in $\env$, yielding the execution graph resulting from evaluating the optional expression in $\vg$.
Otherwise, the result is a \DynamicErrorConfigurationTerm{} indicating that the recursion limit has been reached.
} % END_OF_BACKUP_RELATION

\ExampleDef{Checking the Recursion Limit of a Subprogram Call}
In \listingref{CheckRecurseLimit-nolimit}, the function \verb|factorial| is specified without a limit expression,
and evaluating \verb|main| terminates normally.
\ASLListing{A recursive function with no limit expression}{CheckRecurseLimit-nolimit}{\semanticstests/SemanticsRule.CheckRecurseLimit.no_limit.asl}

In \listingref{CheckRecurseLimit}, the function \verb|factorial| specifies the limit expression \verb|11|,
and evaluating \verb|main| terminates normally.
\ASLListing{A recursive function with a limit expression}{CheckRecurseLimit}{\semanticstests/SemanticsRule.CheckRecurseLimit.asl}

In \listingref{CheckRecurseLimit-limitreached}, the function \verb|factorial| specifies the limit expression \verb|10|,
and evaluating \verb|main| terminates with a \dynamicerrorterm{} (\LimitExceeded), since the limit is exceeded.
\ASLListing{A recursive call exceeding the specified limit}{CheckRecurseLimit-limitreached}{\semanticstests/SemanticsRule.CheckRecurseLimit.limit_reached.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item applying $\evallimit$ to $\velimitopt$ in $\env$ yields $(\None, \vg)$\ProseOrDynErrorDiverging;
    \item define $\vg$ as the empty graph.
  \end{itemize}

  \item \AllApplyCase{some\_ok}
  \begin{itemize}
    \item applying $\evallimit$ to $\velimitopt$ in $\env$ yields $(\some{\vlimit}, \vg)$\ProseOrDynErrorDiverging;
    \item view $\env$ as $(\tenv, \denv)$;
    \item applying $\getpendingcalls$ to $\name$ in $\denv$ yields $\vpendingcalls$;
    \item $\vpendingcalls$ is less than $\vlimit$.
  \end{itemize}

  \item \AllApplyCase{limit\_exceeded}
  \begin{itemize}
    \item applying $\evallimit$ to $\velimitopt$ in $\env$ yields $(\some{\vlimit}, \vg)$\ProseOrDynErrorDiverging;
    \item view $\env$ as $(\tenv, \denv)$;
    \item applying $\getpendingcalls$ to $\name$ in $\denv$ yields $\vpendingcalls$;
    \item $\vpendingcalls$ is greater or equal to $\vlimit$;
    \item the result is a \dynamicerrorterm{} (\LimitExceeded).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{
  \evallimit(\env, \velimitopt) \evalarrow (\None, \vg) \OrDynErrorDiverging
}{
  \checkrecurselimit(\env, \name, \velimitopt) \evalarrow \overname{\emptygraph}{\vg}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_ok]{
  \evallimit(\env, \velimitopt) \evalarrow (\some{\vlimit}, \vg) \OrDynErrorDiverging\\\\
  \env \eqname (\tenv, \denv)\\
  \getpendingcalls(\denv, \name) \evalarrow \vpendingcalls\\
  \vpendingcalls < \vlimit
}{
  \checkrecurselimit(\env, \name, \velimitopt) \evalarrow \vg
}
\end{mathpar}

\begin{mathpar}
\inferrule[limit\_exceeded]{
  \evallimit(\env, \velimitopt) \evalarrow (\some{\vlimit}, \vg) \OrDynErrorDiverging\\\\
  \env \eqname (\tenv, \denv)\\
  \getpendingcalls(\denv, \name) \evalarrow \vpendingcalls\\
  \vpendingcalls \geq \vlimit
}{
  \checkrecurselimit(\env, \name, \velimitopt) \evalarrow \DynamicErrorVal{\LimitExceeded}
}
\end{mathpar}

\SemanticsRuleDef{ReadValueFrom}
\RenderRelation{read_value_from}
\BackupOriginalRelation{
The relation
\[
  \readvaluefrom(\valuereadfrom(\nativevalue \aslsep \Identifier)) \;\aslrel\; (\nativevalue \times \XGraphs)
\]
generates an execution graph for reading the given value to a variable given
by the identifier, and pairs it with the given value.
} % END_OF_BACKUP_RELATION

% NO_EXAMPLE

\ProseParagraph
\AllApply
\begin{itemize}
  \item reading the value $\vv$ into the variable named $\id$ gives $\newg$;
  \item the result is $(\vv, \newg)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \readidentifier(\vv, \id) \evalarrow \newg
}{
  \readvaluefrom(\vv, \id) \evalarrow (\vv, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalReadValueFromBegin}{\EvalReadValueFromEnd}{../Interpreter.ml}

\SemanticsRuleDef{AssignArgs}
\RenderRelation{assign_args}
\BackupOriginalRelation{
The relation
\[
  \assignargs(
    (\overname{\envs}{\env}\times\overname{\XGraphs}{\vgone})\aslsep
    \overname{\KleeneStar{\Identifier}}{\vids} \aslsep
    \overname{\KleeneStar{(\nativevalue\times\XGraphs)}} {\actuals}) \;\aslrel\;
              (\overname{\envs}{\newenv} \times \overname{\XGraphs}{\newg})
\]
updates the pair consisting of the environments $\env$ and \executiongraphterm\ $\vgone$
by assigning the values given by $\actuals$ to the identifiers given by $\vids$,
yielding the updated pair $(\newenv, \newg)$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Assigning Arguments}
In \listingref{AssignArgs}, the call expression \verb|plus(10, 5)| binds \verb|x| to $\nvint(10)$
and $\verb|y|$ to $\nvint(5)$. The expression \verb|x + y| then accesses
these variable values and evaluates to $\nvint(15)$.
\ASLListing{Assigning arguments}{AssignArgs}{\semanticstests/SemanticsRule.AssignArgs.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item both $\vids$ and $\actuals$ are empty lists;
    \item \Proseeqdef{$\newenv$}{$\env$};
    \item \Proseeqdef{$\newg$}{$\vgone$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vids$ has $\vx$ as its head and $\vidsone$ as its tail,
          and $\actuals$ has $\vm$ as its head and $\actualsone$ as its tail;
    \item declaring the local identifier $\vx$ with $\vm$ in $\env$ as per \SemanticsRuleRef{DeclareLocalIdentifierMM}
    gives \\ $(\envone, \vgtwo)$.
    \item assigning the remaining lists $\vidsone$ and $\actualsone$ with the environment $\envone$ and the ordered
          composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge yields\\
          $(\newenv, \newg)$.
    \item the entire result of the evaluation is $(\newenv, \newg)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \assignargs((\env, \vgone), \overname{\emptylist}{\vids}, \overname{\emptylist}{\actuals}) \evalarrow (\overname{\env}{\newenv}, \overname{\vgone}{\newg})
}
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_empty]{
  \declarelocalidentifiermm(\env, \vx, \vm) \evalarrow (\envone, \vgtwo)\\
  \assignargs((\envone, \ordered{\vgone}{\aslpo}{\vgtwo}), \vidsone, \actualsone) \evalarrow (\newenv, \vg)
}{
  \assignargs((\env, \vgone), \overname{[\vx] \concat \vidsone}{\vids}, \overname{[\vm] \concat \actualsone}{\actuals}) \evalarrow (\newenv, \vg)
}
\end{mathpar}

\SemanticsRuleDef{MatchFuncRes}
Using the type \RenderType{TContinuingOrReturning}, we define the following relation.

\RenderRelation{match_func_res}
\BackupOriginalRelation{
The relation
\[
    \matchfuncres(\TContinuing \cup \TReturning) \;\aslrel\;
                  \ResultCall((\KleeneStar{(\Identifier\times\nativevalue)}\times\XGraphs)\aslsep\envs)
\]
converts continuing configurations and returning configurations
into corresponding normal configurations that can be returned by a subprogram evaluation.
} % END_OF_BACKUP_RELATION
\ExampleDef{Converting Configurations Upon Subprogram Return}
In \listingref{MatchFuncRes},
the final configuration resulting from evaluating the call \verb|proc()|
is a \Prosecontinuingconfiguration{}, which is converted into
a \Prosenormalconfiguration{} with no return value.
On the other hand, the configuration resulting from evaluating the
call \verb|returns_values()| is a \Prosereturningconfiguration{} with the value
$\nvint(5)$, which is converted into a \Prosenormalconfiguration{}
with the same value and a fresh identifier for it.

\ASLListing{Converting configurations upon subprogram return}{MatchFuncRes}{\semanticstests/SemanticsRule.MatchFuncRes.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{continuing}
  \begin{itemize}
    \item the given configuration is $\Continuing(\vg, \env)$. This happens when,
    for example, the subprogram called is either a setter or a procedure;
    \item the result is $\ResultCall((\emptylist, \vg), \env)$.
  \end{itemize}

  \item \AllApplyCase{returning}
  \begin{itemize}
    \item the given configuration is $\Returning(\xs, \retenv)$, which is the case of a function;
    \item $\xs$ is the list $\vv_i$, for $i=1..k$;
    \item define the list of fresh identifiers $\id_i$, for $i=1..k$;
    \item define $\vvs$ to be $(\vv_i, \id_i)$, for $i=1..k$;
    \item the result is $\ResultCall((\vvs, \emptygraph), \retenv)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[continuing]{}
  {
    \matchfuncres(\Continuing(\vg, \env)) \evalarrow \ResultCall((\emptylist, \vg), \env)
  }
  \and
  \inferrule[returning]{
    \xs \eqname [i=1..k: \vv_i]\\
    i=1..k: \id_i \in \Identifier\text{ is fresh}\\
    \vvs \eqdef [i=1..k: (\vv_i, \id_i)]
  }
  {
    \matchfuncres(\Returning(\xs, \retenv)) \evalarrow \ResultCall((\vvs, \emptygraph), \retenv)
  }
\end{mathpar}
