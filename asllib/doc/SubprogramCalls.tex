\chapter{Subprogram Calls\label{chap:SubprogramCalls}}

This chapter is concerned with subprogram calls, which appear both in expressions
and in statements. Specifically:
\begin{itemize}
\item how subprogram calls are represented in syntax (\secref{SubprogramCallsSyntax});
\item how subprogram calls are represented in abstract syntax (\secref{SubprogramCallsAbstractSyntax});
\item how subprogram calls are typed (\secref{SubprogramCallsTyping}),
      including a discussion on parameter elision (\secref{ParameterElision}); and
\item what is the dynamic semantics of subprogram calls (\secref{SubprogramCallsSemantics}).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax\label{sec:SubprogramCallsSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Nexpr \derives\  & \Tidentifier \parsesep \PlistZero{\Nexpr} &\\
\Nstmt \derives \ & \Tidentifier \parsesep \PlistZero{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Syntax\label{sec:SubprogramCallsAbstractSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\expr \derives\ & \ECall(\call) &\\
\stmt \derives\ & \SCall(\call) &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typing\label{sec:SubprogramCallsTyping}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The rule for typing calls is \TypingRuleRef{AnnotateCall}.

We also define helper functions via respective rules:
\begin{itemize}
  \item \TypingRuleRef{AnnotateCallActualsTyped}
  \item \TypingRuleRef{InsertStdlibParam}
  \item \TypingRuleRef{CheckParamsTypeSat}
  \item \TypingRuleRef{RenameTyEqs}
  \item \TypingRuleRef{SubstExprNormalize}
  \item \TypingRuleRef{SubstExpr}
  \item \TypingRuleRef{SubstConstraint}
  \item \TypingRuleRef{CheckArgsTypeSat}
  \item \TypingRuleRef{AnnotateRetTy}
  \item \TypingRuleRef{SubprogramForName}
  \item \TypingRuleRef{FilterCallCandidates}
  \item \TypingRuleRef{HasArgClash}
  \item \TypingRuleRef{ExpressionList}
\end{itemize}

\TypingRuleDef{AnnotateCall}
\hypertarget{def-annotatecall}{}
The function
\[
  \annotatecall(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\call}{\vcall}
   ) \aslto
  (\overname{\call}{\vcallp} \times
  \overname{\langle \ty \rangle}{\rettyopt} \times
  \overname{\TSideEffectSet}{\vses}
  )
\]
annotates the call $\vcall$ to a subprogram with call type $\calltype$, resulting in the following:
\begin{itemize}
  \item $\vcallp$ --- the updated call, with all arguments/parameters annotated and \\
        $\vcall.\callname$ updated to uniquely identify the call among the set of overloading subprograms declared with the same name;
  \item $\rettyopt$ --- the \optional\ annotated return type;
  \item $\vses$ --- the \sideeffectsetterm\ inferred for $\vcall$.
\end{itemize}
\ProseOtherwiseTypeError

See \ExampleRef{Annotating Calls with Typed Parameters and Typed Arguments}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\annotateexprlist$ to annotate the expression list $\vcall.\callargs$ in $\tenv$ yields \\
        $\args$\ProseOrTypeError;
  \item applying $\annotateexprlist$ to annotate the expression list $\vcall.\callparams$ in $\tenv$ yields \\
        $\params$\ProseOrTypeError;
  \item applying $\annotatecallactualstyped$ to $\vcall.\callname$, $\params$, $\args$, and \\
        $\vcall.\callcalltype$ in $\tenv$ yields $(\vcallp, \retty, \vses)$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexprlist(\tenv, \vcall.\callargs) \typearrow \args \OrTypeError\\\\
  \annotateexprlist(\tenv, \vcall.\callparams) \typearrow \params \OrTypeError\\\\
  {
    \begin{array}{r}
  \annotatecallactualstyped(\tenv, \vcall.\callname, \params, \args, \vcall.\callcalltype) \typearrow \\
   (\vcallp, \retty, \vses) \OrTypeError
    \end{array}
  }
}{
  \annotatecall(\tenv, \vcall) \typearrow
  (\vcallp, \retty)
}
\end{mathpar}
\CodeSubsection{\AnnotateCallBegin}{\AnnotateCallEnd}{../Typing.ml}
\identi{VFDP} \identd{TRFW} \identr{KMDB}
\identi{YMHX} \identr{CCVD} \identr{QYBH} \identr{PFWQ} \identr{ZLWD}
\identi{FLKF} \identd{PMBL} \identr{MWBN} \identr{TZSP} \identr{SBWR}
\identi{CMLP} \identr{BQJG} \identr{RTCF}

\TypingRuleDef{AnnotateCallActualsTyped}
\hypertarget{def-annotatecallactualstyped}{}
The function
\[
  \annotatecallactualstyped\left(
    \begin{array}{c}
      \overname{\staticenvs}{\tenv} \aslsep\\
      \overname{\identifier}{\name} \aslsep\\
      \overname{(\ty \times\expr \times \TSideEffectSet)^*}{\params} \aslsep\\
      \overname{(\ty \times\expr \times \TSideEffectSet)^*}{\typedargs} \aslsep\\
      \overname{\subprogramtype}{\calltype}
    \end{array}
  \right) \aslto
  \begin{array}{c}
  (\overname{\call}{\vcall} \aslsep
  \overname{\langle \ty \rangle}{\rettyopt})\\
  \cup\ \overname{\TTypeError}{\TypeErrorConfig}
  \end{array}
\]
is similar to $\annotatecall$, except that it accepts the annotated versions of
the parameter and argument expressions as inputs,
that is, tuples consisting of types, annotated expressions, and \sideeffectdescriptorsetsterm.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Calls with Typed Parameters and Typed Arguments}
In \listingref{AnnotateCallActualsTyped-bad1}, the call expression \verb|xor_extend{64}(bv1, bv2)|
is ill-typed, since \\
\verb|xor_extend| has two parameters and only one was supplied.
\ASLListing{An ill-typed call expression}{AnnotateCallActualsTyped-bad1}{\typingtests/TypingRule.AnnotateCallActualsTyped.bad1.asl}

In \listingref{AnnotateCallActualsTyped-bad2}, the call expression \verb|xor_extend{64, 32}(bv1)|
is ill-typed, since \\
\verb|xor_extend| has two arguments and only one was supplied.
\ASLListing{An ill-typed call expression}{AnnotateCallActualsTyped-bad2}{\typingtests/TypingRule.AnnotateCallActualsTyped.bad2.asl}

In \listingref{AnnotateCallActualsTyped-bad3}, the call expression \verb|plus{64}(bv1, w)|
is ill-typed, since \\
the type of the argument \verb|w|, which is \verb|integer{0..128}|, does not \typesatisfy{}
the type of the formal argument \verb|z| (\verb|integer{0..N}|), with \verb|N| substituted by \verb|64|.
That is, \\
\verb|integer{0..64}|.
\ASLListing{An ill-typed call expression}{AnnotateCallActualsTyped-bad3}{\typingtests/TypingRule.AnnotateCallActualsTyped.bad3.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\unziplistthree$ to $\typedargs$ yields the corresponding list of types $\argtypes$,
        list of expressions $\args$, and a list of \sideeffectdescriptorsetsterm\ $\vsessargs$;
  \item define $\vsesargs$ as the union of $\vsessargs$;
  \item applying $\subprogramforname$ to match $\name$ and $\argtypes$ in $\tenv$
        yields \\ $(\namep, \funcsig, \vsescall)$\ProseOrTypeError;
  \item define $\vses$ as the union of $\vsesargs$ and $\vsescall$;
  \item checking that either the $\subprogramtype$ of $\funcsig$ equals $\calltype$,
        or the $\subprogramtype$ of $\funcsig$ is $\STGetter$ and $\calltype$ is $\STFunction$ yields $\True$\ProseTerminateAs{\BadCall};
  \item applying $\insertstdlibparam$ to $\funcsig$, $\params$, and $\argtypes$ yields new parameters $\paramsone$;
  \item checking that the lengths of $\funcsig.\funcparameters$ and $\paramsone$ are the same yields $\True$\ProseTerminateAs{\BadCall};
  \item checking that the lengths of $\funcsig.\funcargs$ and $\args$ are the same yields $\True$\ProseTerminateAs{\BadCall};
  \item applying $\checkparamstypesat$ to $\paramsone$
        to check that the actual parameters have correct types with respect to $\funcsig.\funcparameters$
        in $\tenv$ yields $\True$\ProseOrTypeError;
  \item define $\eqs$ as the association of declared parameter names in $\funcsig.\funcparameters$ with actual parameters $\paramsone$;
  \item applying $\checkargstypesat$ to $\argtypes$ and $\eqs$
        to check that the actual arguments have correct types with respect to $\funcsig.\funcargs$
        in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\annotateretty$ to $\eqs$, $\calltype$, and $\funcsig.\funcreturntype$
        to check that the two call types match and to substitute actual parameter arguments in the formal return type
        yields $\rettyopt$ \ProseOrTypeError;
  \item define $\vcall$ as the call with name $\namep$, parameters taken from $\paramsone$, arguments $\vargs$,
        and call type $\funcsig.\funcsubprogramtype$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \unziplistthree(\typedargs) = (\argtypes, \args, \vsessargs)\\
  \vsesargs \eqdef \bigcup \vsessargs \\
  \subprogramforname(\tenv, \name, \argtypes) \typearrow
  (\nameone, \funcsig, \vsescall) \OrTypeError \\
  {
    \checktrans{
    \left(
    \begin{array}{l}
      \funcsig.\funcsubprogramtype = \calltype \; \lor \\
      (\funcsig.\funcsubprogramtype = \STGetter \; \land \\ \quad \calltype = \STFunction)
    \end{array}
    \right)}{\BadCall} \checktransarrow \True \OrTypeError
  }\\\\
  \vses \eqdef \vsesargs \cup \vsescall\\
  \insertstdlibparam(\funcsig, \params, \argtypes) \typearrow \paramsone\\\\
  \equallength(\funcsig.\funcparameters, \paramsone) \typearrow \paramaritymatch \\\\
  \checktrans{\paramaritymatch}{\BadCall} \checktransarrow \True \OrTypeError\\\\
  \equallength(\funcsig.\funcargs, \args) \typearrow \aritymatch\\
  \checktrans{\aritymatch}{\BadCall} \checktransarrow \True \OrTypeError\\\\
  \checkparamstypesat(\tenv, \funcsig.\funcparameters, \paramsone) \typearrow \True \OrTypeError\\\\
  \eqs \eqdef [(\vx_i, \Ignore) \in \funcsig.\funcsigparams_i ,\; (\Ignore, \vv_i, \Ignore) \in \paramsone: (\vx_i, \vv_i) ] \\
  \checkargstypesat(\tenv, \funcsig.\funcargs, \argtypes, \eqs) \typearrow \True \OrTypeError\\\\
  \annotateretty(\tenv, \calltype, \funcsig.\funcreturntype, \eqs) \typearrow \rettyopt \OrTypeError
}{
  {
    \begin{array}{r}
  \annotatecallactualstyped(\tenv, \name, \params, \typedargs, \calltype) \typearrow \\
  \left(\overname{\left\{
      \begin{array}{rcl}
        \callname &:& \namep,\\
        \callparams &:& [(\Ignore, \vv_i, \Ignore) \in \paramsone: \vv_i],\\
        \callargs &:& \args,\\
        \callcalltype &:& \funcsig.\funcsubprogramtype
      \end{array}
  \right\}}{\vcall}
  , \rettyopt, \vses\right)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\AnnotateCallActualsTypedBegin}{\AnnotateCallActualsTypedEnd}{../Typing.ml}

\TypingRuleDef{InsertStdlibParam}
\hypertarget{def-insertstdlibparam}{}
The function
\[
\insertstdlibparam(
  \overname{\func}{\funcsig} \aslsep
  \overname{(\ty\times\expr)^*}{\params} \aslsep
  \overname{\ty^*}{\argtypes}
  ) \aslto \\
  \overname{(\ty\times\expr\times\TSideEffectSet)^*}{\paramsone}
\]
inserts the (optionally) omitted input parameter of a standard library function call.

Note that this function relies on all standard library functions with input parameters having one of two simple forms:
\begin{lstlisting}
  func stdlibA{N}  (arg1: bits(N), ...) => ...
  func stdlibB{M,N}(arg1: bits(N), ...) => bits(...M...)
\end{lstlisting}

\ExampleDef{Inserting Parameters in Calls to Standard Library Subprograms}
The specification in \listingref{InsertStdlibParam}
shows examples of calls to standard library functions with some or all of their
parameters elided, and the equivalent calls with all parameters included.
\ASLListing{Inserting parameters in calls to standard library subprograms}{InsertStdlibParam}{\typingtests/TypingRule.InsertStdlibParam.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \Proseeqdef{$\caninsertstdlibparam$}{the conjunction of the following conditions:
    \begin{itemize}
      \item $\canommitstdlibparam$ holds for $\funcsig$;
      \item the number of parameters $\params$ is less than the number of parameters in $\funcsig$;
      \item $\argtypes$ is not the empty list.
    \end{itemize}
  }
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{can\_insert}
    \begin{itemize}
      \item \Proseeqdef{$\vt$}{the \head{} of $\argtypes$};
      \item applying $\getbitvectorwidth$ to $\tenv$ and $\vt$ yields $\vwidth$\ProseOrTypeError;
      \item \Proseeqdef{$paramtype$}{the \wellconstrainedintegertype{} for the single
            constraint consisting of the \exactconstraintterm{} for $\vwidth$};
      \item \Proseeqdef{$\paramsone$}{the list whose \head{} is $\params$ and \tail{} is
            the tuple consisting of $\paramtype$, $\vwidth$, and the empty list of \sideeffectdescriptorsetsterm}.
    \end{itemize}
  \end{itemize}

  \begin{itemize}
    \item \AllApplyCase{cannot\_insert}
    \begin{itemize}
      \item $\caninsertstdlibparam$ is $\False$;
      \item \Proseeqdef{$\paramsone$}{$\params$}.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[can\_insert]{
  {
    \caninsertstdlibparam \eqdef \left(\begin{array}{ll}
      \canommitstdlibparam(\funcsig) & \land\\
      \listlen{\params} < \listlen{\funcsig.\funcparameters} & \land\\
      \argtypes \neq \emptylist &
    \end{array}\right)
  }\\
  \caninsertstdlibparam = \True\\\\
  \argtypes \eqname [\vt] \concat \Ignore\\
  \getbitvectorwidth(\tenv, \vt) \typearrow \vwidth \OrTypeError\\\\
  \paramtype \eqdef \TInt(\wellconstrained([\AbbrevConstraintExact{\vwidth}]))\\
  \paramsone \eqdef \params \concat [(\paramtype, \vwidth, \emptyset)]
}{
  \insertstdlibparam(\funcsig, \params, \argtypes) \aslto \paramsone
}
\end{mathpar}

\begin{mathpar}
\inferrule[cannot\_insert]{
  {
    \caninsertstdlibparam \eqdef \left(\begin{array}{ll}
      \canommitstdlibparam(\funcsig) & \land\\
      \listlen{\params} < \listlen{\funcsig.\funcparameters} & \land\\
      \argtypes \neq \emptylist &
    \end{array}\right)
  }\\
  \caninsertstdlibparam = \False
}{
  \insertstdlibparam(\funcsig, \params, \argtypes) \aslto \overname{\params}{\paramsone}
}
\end{mathpar}

\TypingRuleDef{CanOmmitStdlibParam}
\hypertarget{def-canommitstdlibparam}{}
The function
\[
  \canommitstdlibparam(\overname{\func}{\funcsig}) \aslto \overname{\Bool}{\vb}
\]
tests whether the first parameter of the subprogram defined by
$\funcsig$ can be omitted (and thus automatically inserted), yielding the result in $\vb$.

\ExampleDef{Determining Whether a Parameter Can be Omitted}
The following are examples of subprogram signatures
where the first parameter can be omitted:
\begin{lstlisting}
func UInt{N: integer{1..128}} (x: bits(N)) => integer{0..2^N-1}
func Len{N}(x: bits(N)) => integer {N}
func ZeroExtend {N,M} (x: bits(M)) => bits(N)
\end{lstlisting}

The following are examples of subprogram signatures
where the first parameter cannot be omitted:
\begin{lstlisting}
func ReplicateBit{N}(isZero: boolean) => bits(N)
func Ones{N}() => bits(N)
\end{lstlisting}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\funcsig$ is in the standard library;
  \item \Proseeqdef{$\declaredparam$}{
    $\Some{\vn}$ if the list of parameters in $\funcsig$ contains a single parameter whose name is $\vn$
    or the list contains two parameters and the second parameter name is $\vn$;
    and $\None$ otherwise
  };
  \item \Proseeqdef{$\vb$}{$\True$ if and only if
        $\declaredparam$ is $\Some{\vn}$ and the first argument of $\funcsig$
        has a \bitvectortypeterm{} where the width is defined as the variable expression for $\vn$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \funcsig.\funcbuiltin\\\\
  {
    \declaredparam \eqdef \begin{cases}
      \Some{\vn} & \text{if }\funcsig.\funcparameters = [(\vn, \Ignore)]\\
      \Some{\vn} & \text{if }\funcsig.\funcparameters = [\Ignore, (\vn, \Ignore)]\\
      \None      & \text{else}
    \end{cases}
  }\\
  \vb \eqdef \declaredparam = \Some{\vn} \land
  \funcsig.\funcargs = (\Ignore, \TBits(\EVar(\vn), \Ignore))
}{
  \canommitstdlibparam(\funcsig) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{CheckParamsTypeSat}
\hypertarget{def-checkparamstypesat}{}
The function
\[
\begin{array}{r}
\checkparamstypesat(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\langle\ty\rangle)^*}{\funcsigparams} \aslsep
  \overname{(\ty\times\expr\times\TSideEffectSet)^*}{\params}
  ) \aslto \\
  \{\True\}\ \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
checks that annotated parameters $\params$ are correct with respect to the declared parameters $\funcsigparams$.
\ProseOtherwiseTypeError\
It assumes that $\funcsigparams$ and $\params$ have the same length.

\ExampleDef{Checking that Expression Types Type-satisfy Parameters}
In \listingref{CheckParamsTypeSat},
annotating the call expression \verb|FlipSlice{FOUR, EIGHT}(bv)|
requires checking that both expression \verb|FOUR| and \verb|EIGHT| are \symbolicallyevaluable{}
and constrained, which they are.
Since the parameter \verb|M| is annotated with the type \\
\verb|integer{0..64}|,
the typechecker checks that the type of \verb|FOUR|, which is \verb|integer{4}| \typesatisfies{}
\verb|integer{0..64}|.
The parameter \verb|N| is not annotated with a type --- its type is
determined to be \\
$\TInt(\parameterized(\texttt{N}))$ --- and there is no need to check that
the type of \verb|EIGHT|, which is \verb|integer{8}|, \typesatisfies{} $\TInt(\parameterized(\texttt{N}))$.

\ASLListing{Checking that expression types type-satisfy parameters}{CheckParamsTypeSat}{\typingtests/TypingRule.CheckParamsTypeSat.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\funcsigparams$ is an empty list;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApply
  \begin{itemize}
    \item $\funcsigparams$ is a non-empty list with \head\ $(\vx, \tydeclopt)$ and \\
          \tail\ $\funcsigparamsone$, and
          $\params$ is a non-empty list with \head\ \\
          $(\tyactual, \eactual, \vsesactual)$ and \tail\ $\paramsone$;
    \item \Prosechecksymbolicallyevaluable{$\vsesactual$};
    \item checking that $\tyactual$ represents a \constrainedinteger{} yields $\True$\ProseOrTypeError;
    \item \OneApplies
    \begin{itemize}
      \item \AllApplyCase{parameterized}
      \begin{itemize}
        \item $\tyactual$ is a \parameterizedintegertype{} for the parameter $\vx$, that is, \\
              $\langle\TInt(\parameterized(\vx))\rangle$.
      \end{itemize}

      \item \AllApplyCase{other}
      \begin{itemize}
        \item $\tydeclopt$ is not $\None$, that is, $\langle\tydecl\rangle$;
        \item $\tydecl$ is not the \parameterizedintegertype{} for the parameter $\vx$;
        \item checking that $\tyactual$ \typesatisfies{} $\tydecl$ in $\tenv$ yields
              $\True$\ProseOrTypeError;
      \end{itemize}
    \end{itemize}
    \item applying $\checkparamstypesat$ to $\funcsigparamsone$ and $\paramsone$ in $\tenv$
          yields \\ $\True$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \checkparamstypesat(\tenv, \overname{\emptylist}{\funcsigparams}, \Ignore) \typearrow \True
}
\and
\inferrule[parameterized]{
  \funcsigparams = [(\vx, \tydeclopt)] \concat \funcsigparamsone\\
  \params = [(\tyactual, \eactual, \vsesactual)] \concat \paramsone\\
  \checksymbolicallyevaluable(\vsesactual) \typearrow \True\OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \tyactual) \typearrow \True\OrTypeError\\\\
  \commonprefixline\\\\
  \tydeclopt = \langle\TInt(\parameterized(\vx))\rangle\\\\
  \checkparamstypesat(\tenv, \funcsigparamsone, \paramsone) \typearrow \True \OrTypeError
}{
  \checkparamstypesat(\tenv, \funcsigparams, \params) \typearrow \True
}
\and
\inferrule[other]{
  \funcsigparams = [(\vx, \tydeclopt)] \concat \funcsigparamsone\\
  \params = [(\tyactual, \eactual, \vsesactual)] \concat \paramsone\\
  \checksymbolicallyevaluable(\vsesactual) \typearrow \True\OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \tyactual) \typearrow \True\OrTypeError\\\\
  \commonprefixline\\\\
  \tydeclopt \eqname \langle\tydecl\rangle\\
  \tydecl \neq \TInt(\parameterized(\vx))\\
  \checktypesat(\tenv, \tyactual, \tydecl) \typearrow \True \OrTypeError\\\\
  \checkparamstypesat(\tenv, \funcsigparamsone, \paramsone) \typearrow \True \OrTypeError
}{
  \checkparamstypesat(\tenv, \funcsigparams, \params) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{RenameTyEqs}
\hypertarget{def-renametyeqs}{}
The function
\[
\renametyeqs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\ty}{\tty}
) \aslto
\overname{\ty}{\newty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
transforms the type $\tty$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, yielding the type $\newty$.
\ProseOtherwiseTypeError

\ExampleDef{Transforming Parameterized Types Based on Actual Arguments}
In \listingref{RenameTyEqs}, annotating the call expression \verb|FlipPrefix{8}(bv, 4)|
requires substituting \verb|8| for \verb|N| in the types
\verb|bits(N)| and \verb|integer{0..N}|, yielding the types
\verb|bits(8)| and \verb|integer{0..8}|.
\ASLListing{Transforming parameterized types based on actual arguments}{RenameTyEqs}{\typingtests/TypingRule.RenameTyEqs.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{t\_bits}
  \begin{itemize}
    \item $\tty$ is a bitvector type with width expression $\ve$ and fields $\fields$, that is, $\TBits(\ve, \fields)$;
    \item applying $\substexprnormalize$ to $\eqs$ and $\ve$ in $\tenv$ yields the expression $\newe$;
    \item define $\newty$ as a bitvector type with expression $\newe$ and fields $\fields$.
  \end{itemize}

  \item \AllApplyCase{t\_int\_wellconstrained}
  \begin{itemize}
    \item $\tty$ is a well-constrained integer type with constraints $\constraints$;
    \item applying $\substconstraint$ to each constraint $\constraints[\vi]$, for $\vi$ in \\
          $\listrange(\constraints)$, yields the constraint $\newc_\vi$;
    \item define $\newconstraints$ as the list of constraints $\newc_\vi$, for $\vi$ in \\
          $\listrange(\constraints)$;
    \item define $\newty$ as the well-constrained integer type with constraints \\
          $\newconstraints$.
  \end{itemize}

  \item \AllApplyCase{t\_int\_parameterized}
  \begin{itemize}
    \item $\tty$ is a \parameterizedintegertype\ for the parameter $\name$;
    \item applying $\substexprnormalize$ to $\eqs$ and the expression $\EVar(\name)$ yields $\ve$;
    \item define $\newty$ as the well-constrained integer type with the single constraint for $\ve$, that is,
          $\TInt(\wellconstrained(\ConstraintExact(\ve)))$.
  \end{itemize}

  \item \AllApplyCase{t\_tuple}
  \begin{itemize}
    \item $\tty$ is the \tupletypeterm{} over the list of tuples $\tys$, that is, $\TTuple(\tys)$;
    \item applying $\renametyeqs$ to $\eqs$ and the type $\tys[\vi]$, for each $\vi$ in \\
          $\listrange(\tys)$, yields the type $\newty_\vi$;
    \item define $\newtys$ as the list of types $\newty_\vi$, for each $\vi$ in $\listrange(\tys)$;
    \item define $\newty$ as the \tupletypeterm{} over $\newtys$, that is, $\TTuple(\newtys)$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\tty$ is not one of the types in the previous cases,
          that is, $\tty$ is not a bitvector type, nor an integer type, nor a \tupletypeterm{};
    \item $\newty$ is $\tty$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[t\_bits]{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}{
  \renametyeqs(\tenv, \eqs, \overname{\TBits(\ve, \fields)}{\tty}) \typearrow \overname{\TBits(\newe, \fields)}{\newty}
}
\and
\inferrule[t\_int\_wellconstrained]{
  \vi\in\listrange(\constraints): \substconstraint(\tenv, \constraints[\vi]) \typearrow \newc_\vi\\
  \newconstraints \eqdef [\vi\in\listrange(\constraints): \newc_\vi]\\
  \newty \eqdef \TInt(\wellconstrained(\newconstraints))
}{
  \renametyeqs(\tenv, \eqs, \overname{\TInt(\wellconstrained(\constraints))}{\tty}) \typearrow
  \newty
}
\and
\inferrule[t\_int\_parameterized]{
  \substexprnormalize(\eqs, \EVar(\name)) \typearrow \ve\\
  \newty \eqdef \TInt(\wellconstrained(\ConstraintExact(\ve)))
}{
  \renametyeqs(\tenv, \eqs, \overname{\TInt(\parameterized(\name))}{\tty}) \typearrow \newty
}
\and
\inferrule[t\_tuple]{
  \vi\in\listrange(\tys): \renametyeqs(\eqs, \tys[\vi]) \typearrow \newty_\vi\\
  \newtys \eqdef [\vi\in\listrange(\tys): \newty_\vi]
}{
  \renametyeqs(\tenv, \eqs, \overname{\TTuple(\tys)}{\tty}) \typearrow
  \overname{\TTuple(\newtys)}{\newty}
}
\and
\inferrule[other]{
  \astlabel(\tty) \not\in \{\TBits, \TInt, \TTuple\}
}{
  \renametyeqs(\tenv, \eqs, \tty) \typearrow \overname{\tty}{\newty}
}
\end{mathpar}

\TypingRuleDef{SubstExprNormalize}
\hypertarget{def-substexprnormalize}{}
The function
\[
\substexprnormalize(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\newe}{\expr}
\]
transforms the expression $\ve$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, and then attempting to symbolically simplify the result, yielding the expression $\newe$.
\ProseOtherwiseTypeError

\ExampleDef{Substituting Parameter Expressions and Normalizing}
In \listingref{SubstExpr},
considering the call expression \verb|plus{z + 22}(bv1, z)|,
the expression \verb|z + 22| is substituted for the parameter \verb|N| in the type
\verb|bits(N + 2)| used for the argument \verb|x| and as the return type of \verb|plus|,
resulting in the expression \verb|(40 + 22) + 2|, which is then normalized into \verb|64|.
\ASLListing{Substituting Parameter Expressions}{SubstExpr}{\typingtests/TypingRule.SubstExpr.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item transforming $\ve$ in the static environment $\tenv$, by substituting the parameter expressions
        $\eqs$, yields $\veone$;
  \item symbolically simplifying $\veone$ in $\tenv$ yields $\newe$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \substexpr(\tenv, \ve) \typearrow \veone\\
  \normalize(\tenv, \veone) \typearrow \newe
}{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}
\end{mathpar}

\TypingRuleDef{SubstExpr}
\hypertarget{def-substexpr}{}
The function
\[
\substexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\substs} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\expr}{\newe}
\]
transforms the expression $\ve$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\substs$, yielding the expression $\newe$.
\ProseOtherwiseTypeError

The function assumes that $\ve$ appears in the declaration of a parameter,
which means it is in the subset allowed by $\extractparameters$.

See \ExampleRef{Substituting Parameter Expressions and Normalizing}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{e\_var\_in\_substs}
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vs$, that is, $\EVar(\vs)$;
    \item applying $\assocopt$ to $\vs$ and $\substs$ yields the expression $\newe$.
          That is, $\vs$ is a parameter with an associated expression;
  \end{itemize}

  \item \AllApplyCase{e\_var\_not\_in\_substs}
  \begin{itemize}
    \item $\ve$ is the variable expression for the identifier $\vs$, that is, $\EVar(\vs)$;
    \item applying $\assocopt$ to $\vs$ and $\substs$ yields $\None$.
          That is, $\vs$ is not a parameter with an associated expression;
    \item define $\newe$ is $\ve$.
  \end{itemize}

  \item \AllApplyCase{e\_unop}
  \begin{itemize}
    \item $\ve$ is the unary operator expression for the operator $\op$ and expression $\ve$, that is, $\EUnop(\op, \veone)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the unary operator expression for the operator $\op$ and expression $\veonep$, that is, $\EUnop(\op, \veonep)$.
  \end{itemize}

  \item \AllApplyCase{e\_binop}
  \begin{itemize}
    \item $\ve$ is the binary operator expression for the operator $\op$ and expressions $\veone$ and $\vetwo$, that is, $\EBinop(\op, \veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the unary operator expression for the operator $\op$ and expression $\veonep$, that is, $\EUnop(\op, \veonep)$.
  \end{itemize}

  \item \AllApplyCase{e\_cond}
  \begin{itemize}
    \item $\ve$ is the conditional expression for expressions $\veone$, $\vetwo$, and $\vethree$, that is, \\
          $\ECond(\veone, \vetwo, \vethree)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item applying $\substexpr$ to $\substs$ and $\vethree$ in $\tenv$ yields $\vethreep$;
    \item define $\newe$ as the conditional expression for expressions $\veonep$, $\vetwop$, and $\vethreep$, that is, $\ECond(\veonep, \vetwop, \vethreep)$.
  \end{itemize}

  \item \AllApplyCase{e\_call}
  \begin{itemize}
    \item $\ve$ is the call expression for subprogram $\vx$ with arguments $\vargs$ and parameter expressions $\paramargs$,
          that is, $\ECall(\vx, \vargs, \paramargs)$;
    \item applying $\substexpr$ to $\substs$ and every argument expression $\vargs[\vi]$, for $\vi$ in
          $\listrange(\vargs)$ yields $\ve_\vi$;
    \item define $\vargsp$ as $\ve_\vi$ for each $\vi$ in $\listrange(\vargs)$;
    \item define $\newe$ as the call expression for subprogram $\vx$ with arguments $\vargsp$ and parameter expressions $\paramargs$,
    that is, $\ECall(\vx, \vargsp, \paramargs)$.
  \end{itemize}

  \item \AllApplyCase{e\_getarray}
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and index expression $\vetwo$,
          that is, $\EGetArray(\veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the \arrayaccess\ expression for base expression $\veonep$ and index expression $\vetwop$,
    that is, $\EGetArray(\veonep, \vetwop)$.
  \end{itemize}

  \item \AllApplyCase{e\_getenumarray}
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and an enumeration-typed index expression $\vetwo$,
          that is, $\EGetEnumArray(\veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the \arrayaccess\ expression for base expression $\veonep$ and \\
          enumeration-typed index expression $\vetwop$,
          that is, $\EGetEnumArray(\veonep, \vetwop)$.
  \end{itemize}

  \item \AllApplyCase{e\_getfield}
  \begin{itemize}
    \item $\ve$ is the field access expression for base expression $\ve$ and field $\vx$,
          that is, $\EGetField(\veone, \vx)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the field access expression for base expression $\ve$ and field $\vx$,
          that is, $\EGetField(\veonep, \vx)$.
  \end{itemize}

  \item \AllApplyCase{e\_getfields}
  \begin{itemize}
    \item $\ve$ is the access to fields $\fields$ with base expression $\veone$, that is, \\
          $\EGetFields(\veone, \fields)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the access to fields $\fields$ with base expression $\veonep$, that is, $\EGetFields(\veonep, \fields)$.
  \end{itemize}

  \item \AllApplyCase{e\_getitem}
  \begin{itemize}
    \item $\ve$ is the access to tuple item $\vi$ of the tuple expression $\veone$, that is, \\
          $\EGetItem(\veone, \vi)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the access to tuple item $\vi$ of the tuple expression $\veonep$, that is, \\
          $\EGetItem(\veonep, \vi)$.
  \end{itemize}

  \item \AllApplyCase{e\_pattern}
  \begin{itemize}
    \item $\ve$ is the pattern expression of expression $\veone$ and patterns $\vps$, that is, \\
          $\EPattern(\veone, \vps)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the pattern expression of expression $\veonep$ and patterns $\vps$, that is, $\EPattern(\veonep, \vps)$.
  \end{itemize}

  \item \AllApplyCase{e\_record}
  \begin{itemize}
    \item $\ve$ is the record expression of record type $\vt$ and list of fields $\fields$;
    \item for every pair $(\vx,\veone)$ in $\fields$, applying $\substexpr$ to $\substs$ $\veone$ in $\tenv$ yields $\veonep_\vx$;
    \item define $\fieldsp$ as the list of pairs $(\vx,\veonep_\vx)$ for every pair $(\vx,\veone)$ in $\fields$;
    \item define $\newe$ as the record expression of record type $\vt$ and list of fields $\fieldsp$.
  \end{itemize}

  \item \AllApplyCase{e\_slice}
  \begin{itemize}
    \item $\ve$ is the slicing expression for subexpression $\veone$ and list of slices $\vslices$, that is, $\ESlice(\veone, \vslices)$;
    \item applying $\substexpr$ to $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as slicing expression for subexpression $\veonep$ and list of slices \\
          $\vslices$, that is, $\ESlice(\veonep, \vslices)$.
  \end{itemize}

  \item \AllApplyCase{e\_tuple}
  \begin{itemize}
    \item $\ve$ is the tuple expression of expressions $\ves$, that is, $\ETuple(\ves)$;
    \item applying $\substexpr$ to $\substs$ and every expression $\ves[\vi]$ in $\tenv$, for every $\vi$ in $\listrange(\ves)$
          yields $\newe_\vi$;
    \item define $\vesp$ as the list of expressions $\newe_\vi$, for every $\vi$ in $\listrange(\ves)$;
    \item define $\newe$ as the tuple expression of expressions $\vesp$, that is, $\ETuple(\vesp)$.
  \end{itemize}

  \item \AllApplyCase{e\_array}
  \begin{itemize}
    \item $\ve$ is an array construction expression with length expression $\length$ and value expression $\vvalue$, that is,
          $\EArray\{\EArrayLength: \length, \EArrayValue: \vvalue\}$;
    \item applying $\substexpr$ to $\substs$ and $\length$ in $\tenv$ yields $\lengthp$;
    \item applying $\substexpr$ to $\substs$ and $\vvalue$ in $\tenv$ yields $\vvaluep$;
    \item define $\newe$ as the array construction expression with length expression \\
          $\lengthp$ and initial element value expression $\vvaluep$, that is, \\
          $\EArray\{\EArrayLength: \lengthp, \EArrayValue: \vvaluep\}$.
  \end{itemize}

  \item \AllApplyCase{e\_enumarray}
  \begin{itemize}
    \item $\ve$ is an array construction expression for an enumeration-typed index
          with list of labels $\vlabels$ and initial element value expression $\vvalue$, that is, \\
          $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \vvalue\}$;
    \item applying $\substexpr$ to $\substs$ and $\vvalue$ in $\tenv$ yields $\vvaluep$;
    \item define $\newe$ as the array construction expression with list of labels $\vlabels$
          and value expression $\vvaluep$, that is,
          $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \vvaluep\}$.
  \end{itemize}

  \item \AllApplyCase{e\_atc}
  \begin{itemize}
    \item $\ve$ is the type assertion of expression $\veone$ and type $\vt$, that is, $\EATC(\veone, \vt)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the type assertion of expression $\veonep$ and type $\vt$, that is, $\EATC(\veonep, \vt)$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\ve$ is either a literal expression or an arbitrary value expression;
    \item define $\newe$ as $\ve$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[e\_var\_in\_substs]{
  \assocopt(\vs, \substs) \typearrow \langle\newe\rangle
}{
  \substexpr(\tenv, \substs, \overname{\EVar(\vs)}{\ve}) \typearrow \newe
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_not\_in\_substs]{
  \assocopt(\vs, \substs) \typearrow \None
}{
  \substexpr(\tenv, \substs, \overname{\EVar(\vs)}{\ve}) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\
}{
  \substexpr(\tenv, \substs, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \overname{\EUnop(\op, \veonep)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \overname{\EBinop(\op, \veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop\\
  \substexpr(\tenv, \substs, \vethreep) \typearrow \vethreep\\
}{
  \substexpr(\tenv, \substs, \overname{\ECond(\veone, \vetwo, \vethree)}{\ve}) \typearrow \overname{\ECond(\veonep, \vetwop, \vethreep)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_call]{
  \vi\in\listrange(\vargs): \substexpr(\tenv, \substs, \vargs[\vi]) \typearrow \ve_\vi\\
  \vargsp \eqdef [\vi\in\listrange(\vargs): \ve_\vi]
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\ECall(\vx, \vargs, \paramargs)}{\ve}) \typearrow \\ \overname{\ECall(\vx, \vargsp, \paramargs)}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getarray]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EGetArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\EGetArray(\veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getenumarray]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EGetEnumArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\EGetEnumArray(\veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfield]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetField(\veone, \vx)}{\ve}) \typearrow \overname{\EGetField(\veonep, \vx)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfields]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetFields(\veone, \fields)}{\ve}) \typearrow \overname{\EGetFields(\veonep, \fields)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getitem]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetItem(\veone, \vi)}{\ve}) \typearrow \overname{\EGetItem(\veonep, \vi)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EPattern(\veone, \vps)}{\ve}) \typearrow \overname{\EPattern(\veonep, \vps)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record]{
  (\vx, \veone)\in\fields: \substexpr(\tenv, \substs, \veone) \typearrow \veone_\vx\\
  \fieldsp \eqdef [(\vx, \veone)\in\fields: (\vx, \veone_\vx)]
}{
  \substexpr(\tenv, \substs, \overname{\ERecord(\vt, \fields)}{\ve}) \typearrow \overname{\ERecord(\vt, \fieldsp)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\ESlice(\veone, \slices)}{\ve}) \typearrow \overname{\ESlice(\veonep, \slices)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_tuple]{
  \vi\in\listrange(\ves): \substexpr(\tenv, \substs, \ves[\vi]) \typearrow \newe_\vi\\
  \vesp \eqdef [\vi\in\listrange(\ves): \newe_\vi]
}{
  \substexpr(\tenv, \substs, \overname{\ETuple(\ves)}{\ve}) \typearrow \overname{\ETuple(\vesp)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_array]{
  \substexpr(\tenv, \substs, \length) \typearrow \lengthp\\
  \substexpr(\tenv, \substs, \vvalue) \typearrow \vvaluep
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\EArray\{\EArrayLength: \length, \EArrayValue: \vvalue\}}{\ve}) \typearrow\\
  \overname{\EArray\{\EArrayLength: \length, \EArrayValue: \vvaluep\}}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_enumarray]{
  \substexpr(\tenv, \substs, \vvalue) \typearrow \vvaluep
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \vvalue\}}{\ve}) \typearrow\\
  \overname{\EEnumArray\{\EArrayLabels: \length, \EArrayValue: \vvaluep\}}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_atc]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EATC(\veone, \vt)}{\ve}) \typearrow \overname{\EATC(\veonep, \vt)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \in \{\ELiteral, \EArbitrary\}\
}{
  \substexpr(\tenv, \substs, \ve) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}

\CodeSubsection{\SubstExprBegin}{\SubstExprEnd}{../ASTUtils.ml}

\TypingRuleDef{SubstConstraint}
\hypertarget{def-substconstraint}{}
The function
\[
\substconstraint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\intconstraint}{\vc}
) \aslto \overname{\newc}{\intconstraint}
\]
transforms the integer constraint $\vc$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, and then attempting to symbolically simplify the result,
yielding the integer constraint $\newc$.
\ProseOtherwiseTypeError

\ExampleDef{Substituting Parameter Expressions in Constraints}
In \listingref{SubstExpr},
considering the call expression \verb|plus{z + 22}(bv1, z)|,
the expression \verb|z + 22| is substituted for the parameter \verb|N| in the type
\verb|integer{0..N}| used for the argument \verb|z|,
resulting in the type \verb|integer{0..64}|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\ve$ yields $\newe$;
    \item define $\newc$ as the exact constraint for the expression $\newe$, that is, \\
          $\ConstraintExact(\newe)$.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\veone$ yields $\veonep$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\vetwo$ yields $\vetwop$;
    \item define $\newc$ as the range constraint for the expressions $\veonep$ and $\vetwop$, that is, $\ConstraintRange(\veonep, \vetwop)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}{
  \substconstraint(\tenv, \eqs, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\ConstraintExact(\newe)}{\newc}
}
\and
\inferrule[range]{
  \substexprnormalize(\tenv, \eqs, \veone) \typearrow \veonep\\
  \substexprnormalize(\tenv, \eqs, \vetwo) \typearrow \vetwop
}{
  \substconstraint(\tenv, \eqs, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\ConstraintRange(\veonep, \vetwop)}{\newc}
}
\end{mathpar}

\TypingRuleDef{CheckArgsTypeSat}
\hypertarget{def-checkargstypesat}{}
The function
\[
\begin{array}{r}
  \checkargstypesat(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\identifier\times\ty)^*}{\funcsigargs} \aslsep
    \overname{\ty^*}{\argtypes} \aslsep
    \overname{(\identifier\times\expr)^*}{\eqs}
  ) \aslto \\
  \{\True\}\ \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
checks that the types $\argtypes$ \typesatisfy\ the types of the corresponding
formal arguments $\funcsigargs$ with the parameters substituted with their corresponding
arguments as per $\eqs$ and results in a \typingerrorterm{} otherwise.

\ExampleDef{Checking that Actual Arguments Type-satisfy the Formal Arguments}
In \listingref{RenameTyEqs}, checking that the call \verb|FlipPrefix{8}(bv, 4)| is well-typed
requires checking that the types of the arguments --- \verb|bits(8)| and \verb|integer{4}| ---
\typesatisfy{} the corresponding types of the formal arguments --- \verb|bits(N)| and \verb|integer{0..N}| ---
once the parameter \verb|N| is substituted for \verb|8|.
That is, that \verb|bits(8)| \typesatisfies{} \verb|bits(8)| and that
\verb|integer{4}| \typesatisfies{} \verb|integer{0..8}|.
Since both these checks hold, the call is indeed well-typed.

In contrast, a call \verb|FlipPrefix{8}(bv, 9)| is ill-typed since
\verb|integer{9}| does not \typesatisfy{} \verb|integer{0..8}|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item both $\funcsigargs$ and $\argtypes$ are empty;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item view $\funcsigargs$ as a list with \head\ $(\Ignore, \tydecl)$ and \tail\ $\funcsigargsone$;
    \item view $\argtypes$ as a list with \head\ $\tyactual$ and \tail\ \\
          $\argtypesone$;
    \item applying $\renametyeqs$ to $\eqs$ and $\tydecl$ in $\tenv$
          to substitute parameter arguments in $\tydecl$ yields $\tydeclp$\ProseOrTypeError;
    \item checking that $\tyactual$ \typesatisfies\ $\tydeclp$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item applying $\checkargstypesat$ to $\funcsigargsone$, $\argtypesone$, \\
          and $\eqs$ in $\tenv$
          yields $\True$\ProseOrTypeError;
    \item the result is $\True$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
We note that \TypingRuleRef{AnnotateCallActualsTyped} guarantees
that $\funcsigargs$ and $\argtypes$ have the same length.

\begin{mathpar}
\inferrule[empty]{}{
  \checkargstypesat(\tenv, \overname{\emptylist}{\funcsigargs}, \overname{\emptylist}{\argtypes}, \eqs)
  \typearrow \True
}
\and
\inferrule[non\_empty]{
  \funcsigargs = [(\Ignore, \tydecl)] \concat \funcsigargsone\\
  \argtypes = [\tyactual] \concat \argtypesone\\
  \renametyeqs(\tenv, \eqs, \tydecl) \typearrow \tydeclp\OrTypeError\\\\
  \checktypesat(\tenv, \tyactual, \tydeclp) \typearrow \True\OrTypeError\\\\
  \checkargstypesat(\tenv, \funcsigargsone, \argtypesone, \eqs) \typearrow \True\OrTypeError
}{
  \checkargstypesat(\tenv, \funcsigargs, \argtypes, \eqs) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{AnnotateRetTy}
\hypertarget{def-annotateretty}{}
The function
\[
\begin{array}{r}
\annotateretty(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\subprogramtype}{\calltype} \aslsep
  \overname{\langle\ty\rangle}{\funcsigrettyopt}
  \overname{(\identifier\times\expr)^*}{\eqsthree}
) \aslto \\
\overname{\langle\ty\rangle}{\rettyopt}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the \optional\ return type $\funcsigrettyopt$ given with the subprogram type
$\calltype$ with respect to the parameter expressions $\eqs$,
yielding the \optional\ annotated type $\rettyopt$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating the Return Type of a Subprogram Call}
In \listingref{AnnotateRetTy}, annotating the return type \verb|bits(N)| of the subprogram \verb|flip|
for call expression \verb|flip{64}(bv)|, yields the annotated type \verb|bits(64)|.

Since \verb|proc| does not have a return type, the call statement \verb|proc()| does not require
annotating a return type (thus $\annotateretty$ yields $\None$ for $\rettyopt$).
\ASLListing{Annotating the Return Type of a Subprogram Call}{AnnotateRetTy}{\typingtests/TypingRule.AnnotateRetTy.asl}

\listingref{AnnotateRetTy-bad} shows an example of an ill-typed call statement \verb|flip{64}(bv);|
and an ill-typed call expression \verb|proc()|, since procedures can only be used in call statements
and functions can only be used in call expressions.
\ASLListing{Ill-typed Subprogram Calls}{AnnotateRetTy-bad}{\typingtests/TypingRule.AnnotateRetTy.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{function\_or\_getter}
  \begin{itemize}
    \item $\calltype$ is one of $\STFunction$ or $\STGetter$;
    \item $\funcsig$ is $\langle\tty\rangle$;
    \item applying $\renametyeqs$ to $\eqs$ and $\tty$ yields $\ttyone$\ProseOrTypeError;
    \item $\rettyopt$ is $\langle\ttyone\rangle$.
  \end{itemize}

  \item \AllApplyCase{procedure\_or\_setter}
  \begin{itemize}
    \item $\calltype$ is one of $\STProcedure$ or $\STSetter$;
    \item $\funcsigrettyopt$ is $\None$;
    \item define $\rettyopt$ as $\None$.
  \end{itemize}

  \item \AllApplyCase{ret\_type\_mismatch}
  \begin{itemize}
    \item the condition that $\calltype$ is one of $\STProcedure$ or $\STSetter$
          if and only if $\funcsigrettyopt$ is $\None$ does not hold;
    \item the result is a \typingerrorterm{} indicating the mismatch.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[function\_or\_getter]{
  \calltype \in \{\STFunction, \STGetter\}\\
  \renametyeqs(\eqs, \tty) \typearrow \ttyone \OrTypeError
}{
  \annotateretty(\tenv, \calltype, \overname{\langle\tty\rangle}{\funcsigrettyopt}, \eqs) \typearrow
  \overname{\langle\ttyone\rangle}{\rettyopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[procedure\_or\_setter]{
  \calltype \in \{\STProcedure, \STSetter\}\\
}{
  \annotateretty(\tenv, \calltype, \overname{\None}{\funcsigrettyopt}, \eqs) \typearrow
  \overname{\None}{\rettyopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ret\_type\_mismatch]{
  {
  \neg\left(
    \begin{array}{c}\calltype \in \{\STProcedure, \STSetter\} \leftrightarrow \\
      \funcsigrettyopt=\None
    \end{array}
  \right)
  }
}{
  \annotateretty(\tenv, \calltype, \funcsigrettyopt, \eqs) \typearrow
  \TypeErrorVal{\BadCall}
}
\end{mathpar}

\TypingRuleDef{SubprogramForName}
\hypertarget{def-subprogramforname}{}
The function
\[
  \begin{array}{rl}
    \subprogramforname(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\ty^*}{\callerargtypes}
    )
    \aslto &
    \begin{array}{l}
      (
      \overname{\Strings}{\namep} \aslsep
      \overname{\func}{\callee} \aslsep
      \overname{\TSideEffectSet}{\vses}
      )\
    \\
    \cup\ \overname{\TTypeError}{\TypeErrorConfig}
    \end{array}
  \end{array}
\]
looks up the static environment $\tenv$ for a subprogram associated with $\name$
and the list of argument types $\calleeargtypes$ and determines which one of the following
cases holds:
\begin{enumerate}
  \item there is no declared subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is exactly one subprogram that matches $\name$ and $\calleeargtypes$;
\end{enumerate}
If more than one subprogram that matches $\name$ and $\calleeargtypes$,
this is detected by the rule \TypingRuleRef{DeclareSubprograms},
which invokes the rule \\ \TypingRuleRef{DeclareOneFunc},
which invokes the rule \TypingRuleRef{AddNewFunc},
which results in a \typingerrorterm{}.

The first case results in a \typingerrorterm{}.
If the second case holds, the function returns a tuple which comprises:
\begin{itemize}
\item $\namep$ --- the string that uniquely identifies this subprogram;
\item $\callee$ --- the AST node defining the called subprogram; and
\item $\vses$ --- the set of \sideeffectdescriptorsterm{} associated with $\name$.
\end{itemize}
\ProseOtherwiseTypeError

\ExampleDef{Matching a Subprogram to an Identifier}

\listingref{SubprogramForName} shows an example where all subprogram calls
match subprogram declarations.
\ASLListing{Successfully matching subprogram names to definitions}{SubprogramForName}{\typingtests/TypingRule.SubprogramForName.asl}

\listingref{SubprogramForName-undefined} shows an example where
the subprogram call \verb|add_10(5)| is illegal, since no subprogram named \verb|add_10|
is declared.
\ASLListing{Subprogram name undefined}{SubprogramForName-undefined}{\typingtests/TypingRule.SubprogramForName.bad.undefined.asl}

\listingref{SubprogramForName} shows an example where
the subprogram call \verb|add_10(5.0)| is illegal, since, although a subprogram named \verb|add_10|
is declared, it does not match the required signature (the type of the first argument is
the \integertypeterm{} rather than the \realtypeterm).
\ASLListing{Subprogram name does not match signature}{SubprogramForName-no-candidates}{\typingtests/TypingRule.SubprogramForName.bad.no_candidates.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{undefined}
  \begin{itemize}
    \item $\tenv$ does not contain a binding for $\name$ in the $\overloadedsubprograms$ map
          ($G^\tenv.\overloadedsubprograms$);
    \item the result is a \typingerrorterm{} indicating that the identifier has not been declared (as a subprogram).
  \end{itemize}

  \item \AllApplyCase{no\_candidates}
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\overloadedsubprograms$ map to $\renamingset$ and $\vses$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \TypingRuleRef{FilterCallCandidates}) yields an empty set\ProseOrTypeError;
    \item the result is a \typingerrorterm{} indicating that the call given by $\name$ and \\ $\callerargtypes$
          does not match any defined subprogram.
  \end{itemize}

  \item \AllApplyCase{one\_candidate}
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\overloadedsubprograms$ map to $\renamingset$ and $\vses$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \TypingRuleRef{FilterCallCandidates}) yields \\
          $\matchingrenamings$\ProseOrTypeError;
    \item $\matchingrenamings$ contains a single element --- $(\namep, \callee)$\ProseOrTypeError;
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[undefined]{
  G^\tenv.\overloadedsubprograms(\name) = \bot
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_candidates]{
  G^\tenv.\overloadedsubprograms(\name) = (\renamingset, \vses)\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \emptyset \OrTypeError
    \end{array}
  }
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\BadCall}
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_candidate]{
  G^\tenv.\overloadedsubprograms(\name) = (\renamingset, \vses)\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \\ \matchingrenamings \OrTypeError
    \end{array}
  }\\\\
  \matchingrenamings = [(\namep, \callee)]
}{
  {
    \begin{array}{r}
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \\ (\namep, \callee, \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SubprogramForNameBegin}{\SubprogramForNameEnd}{../Typing.ml}

\TypingRuleDef{FilterCallCandidates}
\hypertarget{def-filtercandidates}{}
The helper function
\[
  \filtercallcandidates(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty^*}{\formaltypes} \aslsep
    \overname{\pow{\Strings}}{\candidates}
    )
  \aslto \overname{(\Strings\times\func)^*}{\matches}
\]
iterates over the list of unique subprogram names in $\candidates$ and checks whether
their lists of arguments clash with the types in $\formaltypes$ in $\tenv$.
The result is the set of pairs consisting of the names and function definitions of the
subprograms whose arguments clash in $\candidates$.
\ProseOtherwiseTypeError

The names $\candidates$ are assumed to exist in $G^\tenv.\subprograms$.

\ExampleDef{Filtering Subprograms Matching a Call}
In \listingref{SubprogramForName}, filtering the
set of declared subprograms for the call expression \verb|add_10(5)| yields
the (singleton list containing the) subprogram \\
\verb|func add_10(x: integer) => integer|.
In contrast, filtering the set of declared subprograms for the call expression
\verb|add_10(5.0)| in \listingref{SubprogramForName-no-candidates},
yields an empty list.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{no\_candidates}
  \begin{itemize}
    \item $\candidates$ is empty;
    \item $\matches$ is empty.
  \end{itemize}

  \item \AllApplyCase{candidates\_exist}
  \begin{itemize}
    \item $\candidates$ is a list with \head\ $\name$ and \tail\ $\candidatesone$;
    \item the function definition associated with $\name$ in $\tenv$ is $\funcdef$;
    \item determining whether there is an argument clash between $\formaltypes$ and the arguments in $\funcdef$
          (that is, $\funcdef.\funcargs$) yields $\vb$\ProseOrTypeError;
    \item filtering the call candidates in $\candidatesone$ with $\formaltypes$ in $\tenv$ yields $\matchesone$\ProseOrTypeError;
    \item if $\vb$ is $\True$ then $\matches$ is the list with \head\ $(\name,\funcdef)$ and \tail\ $\matchesone$,
          and otherwise it is $\matchesone$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_candidates]
{}{
  \filtercallcandidates(\tenv, \formaltypes, \overname{\emptylist}{\candidates}) \typearrow \overname{\emptylist}{\matches}
}
\end{mathpar}

\begin{mathpar}
\inferrule[candidates\_exist]
{
  \funcdef \eqdef G^\tenv.\subprograms(\name) \\
  \hasargclash(\tenv, \formaltypes, \funcdef.\funcargs) \typearrow \vb \OrTypeError\\\\
  \filtercallcandidates(\tenv, \formaltypes, \candidatesone) \typearrow \matchesone \OrTypeError\\\\
  \matches \eqdef \choice{\vb}{\;[(\name,\funcdef)] \concat \matchesone}{\;\matchesone}
}{
  \filtercallcandidates(\tenv, \formaltypes, \overname{[\name] \concat \candidatesone}{\candidates}) \typearrow \matches
}
\end{mathpar}

\TypingRuleDef{HasArgClash}
\hypertarget{def-hasargclash}{}
The function
\[
  \hasargclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty^*}{\formaltys} \aslsep
    \overname{(\identifier\times\ty)^*}{\vargs}
  )
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether a list of types $\formaltys$ clashes with the list of types appearing
in the list of arguments $\vargs$ in $\tenv$, yielding the result in $\vb$.
\ProseOtherwiseTypeError

\ExampleDef{Argument Clashing}
\listingref{type-clashes} shows examples of types ---
the arguments of procedures -- that do not clash and types that do clash
(shown in comments).
\ASLListing{Examples of Argument clashing}{type-clashes}{\typingtests/TypingRule.TypeClashes.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item equating the list lengths of $\formaltys$ and $\vargs$ either yields $\True$
        or $\False$, which short-circuits the entire rule;
  \item $\argtys$ is the list of types appearing in $\vargs$, in the same order;
  \item for each $\vi$ in the list of indices of $\formaltys$, applying $\typeclashes$ to
        $\formaltys[\vi]$ and $\argtys[\vi]$ in $\tenv$ yields $\True$\ProseTerminateAs{\False, \TypeErrorConfig};
  \item $\vb$ is $\True$ (unless the rule short-circuited with $\False$ or a \typingerrorterm{}).
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \equallength(\formaltypes, \vargs) \typearrow \True \terminateas \False\\\\
  \argtys \eqdef [(\Ignore, \vt) \in \vargs: \vt]\\
  \vi\in\listrange(\formaltys): \typeclashes(\tenv, \formaltys[\vi], \argtys[\vi]) \typearrow \True \terminateas \False,\TypeErrorConfig
}{
  \hasargclash(\tenv, \formaltys, \vargs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}
\CodeSubsection{\HasArgClashBegin}{\HasArgClashEnd}{../Typing.ml}

\TypingRuleDef{TypeClash}
\hypertarget{def-typeclashes}{}
The helper function
\[
  \typeclashes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
determines whether a type $\vt$ \emph{\Prosetypeclashes} with a type $\vs$ in environment $\tenv$,
returning the result $\vb$.
\ProseOtherwiseTypeError

\identd{VPZZ} \identi{PQCT} \identi{WZKM} \identi{WZKM}
Note that \Prosetypeclashing{} is an equivalence relation.
In particular note that if $T$ \Prosetypeclashes{} with $A$ and $B$ then $A$ and
$B$ \Prosetypeclash{}.

See \ExampleRef{Argument Clashing}

\ExampleDef{Ill-typed Subprogram Declarations}
In specification \listingref{TypeClash-bad}, the type \verb|SuperRec| \emph{\Prosetypeclashes} \verb|SubRec|
in the static environment where both types have been annotated,
which is why both declarations of \verb|structured_procedure| clash and thus they are ill-typed.
\ASLListing{Ill-typed Subprogram Declarations}{TypeClash-bad}{\typingtests/TypingRule.TypeClashes.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{subtype}
  \begin{itemize}
    \item either $\vs$ subtypes $\vt$ or $\vt$ subtypes $\vs$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{simple}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields $\vsstruct$\ProseOrTypeError;
    \item both $\vtstruct$ and $\vsstruct$ are one of the following types: \\
          \booleantypesterm{}, \integertypeterm{}, \realtypeterm{}, or \stringtypeterm{};
    \item $\vb$ is $\True$.
  \end{itemize}

  \item \AllApplyCase{t\_enum}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields an \enumerationtypeterm{} with labels $\vlit$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields an \enumerationtypeterm{} with labels $\vlis$;
    \item $\vb$ is $\True$ if and only if $\vlis$ and $\vlit$ are equal.
  \end{itemize}

  \item \AllApplyCase{t\_array}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields an array type with element type $\vtyt$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields an array type with element type $\vtys$;
    \item $\vb$ is $\True$ if and only if $\vtyt$ and $\vtys$ type-clash.
  \end{itemize}

  \item \AllApplyCase{t\_tuple}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a \tupletypeterm{} with element types $\vt_{1..k}$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a \tupletypeterm{} with element types $\vs_{1..n}$;
    \item if $n \neq k$ the rule short-circuits with $\vb=\False$;
    \item $\vb$ is $\True$ if and only if $\vt_i$ type-clashes with $\vs_i$, for all $i=1..k$.
  \end{itemize}

  \item \AllApplyCase{otherwise\_different\_labels}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields $\vsstruct$;
    \item $\vsstruct$ and $\vtstruct$ have different AST labels;
    \item $\vb$ is $\False$;
  \end{itemize}

  \item \AllApplyCase{otherwise\_structured}
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields $\vsstruct$;
    \item $\vsstruct$ and $\vtstruct$ have the same AST label;
    \item $\vtstruct$ (and thus $\vsstruct$) is a \structuredtype;
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[subtype]{
  (\subtypesrel(\tenv, \vs, \vt) \typearrow \True) \lor (\subtypesrel(\tenv, \vt, \vs) \typearrow \True)
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[simple]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \OrTypeError \\
  \astlabel(\vtstruct)=\astlabel(\vsstruct)\\
  \astlabel(\vtstruct) \in \{\TBool, \TInt, \TReal, \TString, \TBits\}
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \TEnum(\Ignore, \vlis) \\
  \tstruct(\tenv, \vs) \typearrow \TEnum(\Ignore, \vlit)
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\vlis = \vlit}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \TArray(\Ignore, \vtyt) \\
  \tstruct(\tenv, \vs) \typearrow \TArray(\Ignore, \vtys) \\
  \typeclashes(\tenv, \vtyt, \vtys) \typearrow \vb
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) \typearrow \TTuple(\vs_{1..n}) \\
  \booltrans{n = k} \booltransarrow \True \terminateas \False\\
  i=1..k: \typeclashes(\tenv, \vt_i, \vs_i) \typearrow \vb_i\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_i
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise\_different\_labels]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \\
  \astlabel(\vtstruct) \neq \astlabel(\vsstruct)
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise\_structured]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \\
  \astlabel(\vtstruct) = \astlabel(\vsstruct)\\
  \astlabel(\vtstruct) \in \{\TRecord, \TException, \TCollection\}
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}
\CodeSubsection{\TypeClashBegin}{\TypeClashEnd}{../types.ml}

\subsubsection{Comment}
Note that if $\vt$ \subtypesatisfies{} $\vs$ then $\vt$ and $\vs$ \Prosetypeclash, but not the other
way around.

\TypingRuleDef{ExpressionList}
\hypertarget{def-annotateexprs}{}
The helper function
\[
  \annotateexprlist(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr^*}{\exprs})
  \aslto \overname{(\ty \times \expr \times \TSideEffectSet)^*}{\typedexprs}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of expressions $\exprs$ from left to right, yielding a list of tuples \\
$\typedexprs$,
each consisting of a type, an annotated expression, and a \sideeffectsetterm.
\ProseOtherwiseTypeError

\ExampleDef{Annotating a List of Expressions}
In \listingref{ExpressionList}, the list of expressions \verb|10, 20.0|
is annotated as
\[
\left[
\begin{array}{lll}
(\TInt(\wellconstrained([\AbbrevConstraintExact{\ELInt{10}}])),& \eliteral{\lint(10)},& \emptyset),\\
(\TReal,& \eliteral{\lreal(20)},& \emptyset)
\end{array}
\right]
\]
\ASLListing{Annotating a list of expressions}{ExpressionList}{\typingtests/TypingRule.ExpressionList.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\exprs$ is empty;
    \item $\typedexprs$ is empty.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\exprs$ has $\ve$ as its \head\ expression and $\exprsone$ as its \tail;
    \item annotating $\ve$ in $\tenv$ yields the pair $\typedexpr$ consisting of a type
          and an expression\ProseOrTypeError;
    \item annotating the expression list $\exprsone$ in $\tenv$ yields
          $\typedexprs$\ProseOrTypeError;
    \item \Proseeqdef{$\typedexprs$}{the \Proselist{$\typedexpr$}{$\typedexprs$}}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \annotateexprlist(\tenv, \overname{\emptylist}{\exprs}) \typearrow \overname{\emptylist}{\typedexprs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \annotateexpr{\tenv, \ve} \typearrow \typedexpr \OrTypeError\\\\
  \annotateexprlist(\tenv, \exprsone) \typearrow \typedexprsone \OrTypeError
}{
  \annotateexprlist(\tenv, \overname{[\ve] \concat \exprsone}{\exprs}) \typearrow \overname{[\typedexpr] \concat \typedexprsone}{\typedexprs}
}
\end{mathpar}

\subsection{Parameter Elision\label{sec:ParameterElision}}

ASL allows dropping a parameter from the parameter list of a subprogram call
in two situations:
\begin{itemize}
  \item During AST building of declaration statements
        (\secref{DeclarationStatementsElidedParameter}).
        In this case, the first parameter expression may be elided when the left-hand side
        expression is explicitly annotated as a bitvector type whose width is taken to be the parameter expression.
        We refer to this as \emph{parameter elision}.
        The call must contain \verb|{...}|, even if they are empty.
  \item During type checking of standard library calls (\TypingRuleRef{InsertStdlibParam}).
        In this case, a parameter expression can be inferred by matching the call expression
        against one of two patterns (see the rule for details and examples).
        If omitting a parameter yields an empty list, the \verb|{...}| must be entirely removed.
        We refer to this as \emph{parameter omission}.
\end{itemize}

These two situations are exemplified in \listingref{ParameterElision}.
\ASLListing{Parameter elision and parameter omission}{ParameterElision}{\definitiontests/ParameterElision.asl}

The specification in \listingref{ParameterElision-bad} is ill-typed,
since the parameter for the call expression \verb|X(data, n)| is inferred based on the left-hand-side
expressions, and therefore an empty list of parameters must be given.
\ASLListing{Erroneous parameter elision}{ParameterElision-bad}{\definitiontests/ParameterElision.bad.asl}

The specification in \listingref{ParameterOmission-bad} is ill-typed,
as an empty parameter list for a standard library function must be entirely omitted.
\ASLListing{Erroneous parameter omission}{ParameterOmission-bad}{\definitiontests/ParameterOmission.bad.asl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantics\label{sec:SubprogramCallsSemantics}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The rule for evaluating subprogram calls is \SemanticsRuleRef{Call}.

We also define the following helper rules:
\begin{itemize}
  \item \SemanticsRuleRef{EvalSubprogram}
  \item \SemanticsRuleRef{ReadValueFrom}
  \item \SemanticsRuleRef{AssignArgs}
  \item \SemanticsRuleRef{MatchFuncRes}
\end{itemize}

\SemanticsRuleDef{Call}
The relation
\hypertarget{def-evalcall}{}
\[
  \begin{array}{c}
    \evalcall(\overname{\envs}{\env} \aslsep
    \overname{\Identifiers}{\name} \aslsep
    \overname{\expr^*}{\params} \aslsep
    \overname{\expr^*}{\args}) \;\aslrel\; \\
    \Normal(\overbracket{(\vals\times\XGraphs)^*}^{\vmstwo}, \overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
  \end{array}
\]
evaluates a call to the subprogram named $\name$ in the environment $\env$,
with the parameter expressions $\params$ and the argument expressions
$\args$.
The evaluation results in either a list of returned values, each one associated
with an execution graph, and a new environment;
or an abnormal configuration.

The evaluation first evaluates the expressions corresponding to the arguments
and parameters and then passes their values in a resulting configuration
to the helper relation $\evalsubprogram$.

\ExampleDef{Calling Subprograms}
In \listingref{Call}, calling \verb|non_throwing_func| terminates normally,
while calling \verb|throwing_func| terminates by throwing an exception.
\ASLListing{Calling subprograms}{Call}{\semanticstests/SemanticsRule.Call.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item evaluating each expression in $\params$ separately in $\env$ as per\\
        \SemanticsRuleRef{EExprListM} is $\Normal(\vvparams, \envone)$\ProseOrAbnormal;
  \item evaluating each expression in $\args$ separately in $\envone$ as per \\
        \SemanticsRuleRef{EExprListM} is $\Normal(\vvargs, \envtwo)$\ProseOrAbnormal;
  \item $\envtwo$ consists of the static environment $\tenv$ and the dynamic environment $\denvtwo$;
  \item applying $\incrstacksize$ to $G^\denvtwo$ and $\name$ yields $\genv$;
  \item the environment $\envtwo'$ is defined as the environment
  consisting of the static environment $\tenv$ and the dynamic environment with the global component
  $\genv$ and an empty local component (intuitively, this is because the called subprogram does not have access
  to the local environment of the caller);
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{normal}
    \begin{itemize}
      \item evaluating the subprogram named $\name$ with parameters $\vvparams$ and arguments $\vvargs$ in
      $\denvtwo'$ is $\Normal(\vms, (\vglobal, \Ignore))$ (that is, we ignore the local environment
      of the callee)\ProseOrError;
      \item applying the helper relation $\readvaluefrom$ to each element of the list $\vms$ yields the list $\vmstwo$;
      \item applying $\decrstacksize$ to $\vglobal$ and $\name$ yields $\genvtwo$;
      \item define $\newenv$ as the environment where the static environment is $\tenv$ and the dynamic environment consists
            of the dynamic global environment $\genvtwo$ and the dynamic local environment is taken from $\denvtwo$
            (that is, we restore the local environment to that of the caller and drop the local environment of the callee).
      \item the entire evaluation results in $\Normal(\vmstwo, \newenv)$.
    \end{itemize}

    \item \AllApplyCase{throwing}
    \begin{itemize}
      \item evaluating the subprogram named $\name$ with arguments $\vvargs$ and parameters $\vvparams$ in
            $\denvtwo'$ is $\Throwing(\vv, \envthrow)$\ProseOrError;
      \item view $\envthrow$ as the environment consisting of the static environment $\tenv$,
            and the dynamic environment whose global component is $\vglobal$;
      \item applying the helper relation $\readvaluefrom$ to $\vms$ yields $\vmstwo$;
      \item applying $\decrstacksize$ to $\vglobal$ and $\name$ yields $\genvtwo$;
      \item define $\newenv$ as the environment where the static environment is $\tenv$ and the dynamic environment consists
            of the dynamic global environment $\genvtwo$ and the dynamic local environment is taken from $\denvtwo$
            (that is, we restore the local environment to that of the caller and drop the local environment of the callee).
      \item the entire evaluation results in $\Normal(\vmstwo, \newenv)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[normal]{
  \evalexprlistm(\env, \params) \evalarrow \Normal(\vvparams, \envone)\OrAbnormal\\
  \evalexprlistm(\envone, \args) \evalarrow \Normal(\vvargs, \envtwo)\OrAbnormal\\
  \envtwo \eqname (\tenv, \denvtwo)\\
  \incrstacksize(G^\denvtwo, \name) \evalarrow \genv\\\\
  \envtwo' \eqdef (\tenv, (\genv, \emptyfunc))\\\\
  \commonprefixline\\\\
  \evalsubprogram(\envtwo', \name, \vvparams, \vvargs) \evalarrow \Normal(\vms, (\vglobal, \Ignore)) \OrDynError\\\\
  \vmstwo \eqdef [\vm \in \vms: \readvaluefrom(\vms)]\\
  \decrstacksize(\vglobal, \name) \evalarrow \genvtwo\\
  \newenv \eqdef (\tenv, (\genvtwo, L^{\denvtwo}))
}{
  \evalcall(\env, \name, \params, \args) \evalarrow \Normal(\vmstwo, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[throwing]{
  \evalexprlistm(\env, \args) \evalarrow \Normal(\vvargs, \envone)\OrAbnormal\\
  \evalexprlistm(\envone, \params) \evalarrow \Normal(\vvparams, \envtwo)\OrAbnormal\\
  \envtwo \eqname (\tenv, \denvtwo)\\
  \incrstacksize(G^\denvtwo, \name) \evalarrow \genv\\\\
  \envtwo' \eqdef (\tenv, (\genv, \emptyfunc))\\\\
  \commonprefixline\\\\
  \evalsubprogram(\envtwo', \name, \vvparams, \vvargs) \evalarrow \Throwing(\vv, \envthrow) \OrDynError\\\\
  \envthrow \eqname (\tenv, (\vglobal, \Ignore))\\
  \decrstacksize(\vglobal, \name) \evalarrow \genvtwo\\
  \newenv \eqdef (\tenv, (\genvtwo, L^{\denvtwo}))
}{
  \evalcall(\env, \name, \params, \args) \evalarrow \Throwing(\vv, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalCallBegin}{\EvalCallEnd}{../Interpreter.ml}

\SemanticsRuleDef{EvalSubprogram}
The relation
\hypertarget{def-evalsubprogram}{}
\[
  \begin{array}{c}
    \evalsubprogram(\overname{\envs}{\env} \aslsep
    \overname{\Identifiers}{\name} \aslsep
    \overname{(\vals \times \XGraphs)^*}{\params} \aslsep
    \overname{(\vals \times \XGraphs)^*}{\args}) \aslrel \\
    \Normal(\overname{(\vals^* \aslsep \XGraphs)}{\vvs}, \overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup
    \overname{\TDynError}{\DynErrorConfig}
  \end{array}
\]
evaluates the subprogram named $\name$ in the environment $\env$, with
$\actualargs$ the list of actual arguments, and $\params$ the
list of arguments deduced by type equality.
The result is either a normal configuration or an abnormal configuration.
In the case of a normal configuration, it consists of a list of pairs
with a value and an identifier, and a new environment $\newenv$.
The values represent values returned by the subprogram call and the
identifiers are used in generating execution graph constraints for the
returned values.

\ExampleDef{Subprogram Calls}
In \listingref{semantics-fcall},
the function \texttt{main} calls the function \texttt{foo} and the procedure \texttt{bar}.
\ASLListing{Evaluating subprogram calls}{semantics-fcall}{\semanticstests/SemanticsRule.FCall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\env$ consists of the static environment $\tenv$ and the dynamic environment with the global
        component $\genv$ and an empty local component;
  \item finding the function named $\name$ in $\tenv$ (via the $\subprograms$ component of the static global environment of $\tenv$)
        gives the AST $\func$ node with body
        $\vbody$, parameters $\paramdecls$, arguments $\argdecls$, and optional recursion limit expression $\vrecurselimit$;
  \item $\envone$ is the environment consisting of the static environment $\tenv$ and the dynamic
        environment consisting of the dynamic component from $\denv$ and an empty local component;
  \item applying $\checkrecurselimit$ to $\name$ and $\vrecurselimit$ in $\envone$ yields $\vgone$\ProseOrError;
  \item \Proseeqdef{$\argnames$}{the identifiers appearing as the first component of each pair in $\argdecls$};
  \item assigning the actual arguments with $((\envone, \emptygraph), \argnames, \args)$
        as per \SemanticsRuleRef{AssignArgs} gives $(\envtwo, \vgtwo)$ and ensures that each
        formal argument in $\argdecls$ is
        locally bound to the corresponding actual value in $\args$;
  \item \Proseeqdef{$\paramnames$}{the identifiers appearing as the first component of each pair in $\params$};
  \item assigning the actual parameters with $((\envtwo, \emptygraph), \paramnames, \paramdecls)$
        as per \SemanticsRuleRef{AssignArgs} gives $(\envthree, \vgthree)$ and ensures that each
        formal parameter in $\paramdecls$ is
        locally bound to the corresponding actual value in $\params$;
  \item evaluating the body of the subprogram $\vbody$ as a statement in $\envthree$
        is $\vres$\ProseOrAbnormal;
  \item matching the result $\vres$ to obtain a normal configuration as per \\
        \SemanticsRuleRef{MatchFuncRes} gives $C$;
  \item $\newg$ is the ordered composition of $\vgone$ with the $\asldata$ and $\vgtwo$ and $\vgthree$ with the $\aslpo$ edge;
  \item the result is $C$ with its graph substituted for $\newg$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqname (\tenv, \denv)\\
  {
    G^\tenv.\subprograms(\name) \eqname \left\{
      \begin{array}{rcl}
      \funcbody &:& \vbody,\\
      \funcargs &:& \argdecls,\\
      \funcparameters &:& \paramdecls,\\
      \funcrecurselimit &:& \vrecurselimit, \\
      &&\ldots
      \end{array}
      \right\}
  }\\
  \envone \eqdef (\tenv, (G^\denv, \emptyfunc))\\
  \checkrecurselimit(\envone, \name, \vrecurselimit) \evalarrow \vgone \OrDynError\\\\
  \argnames \eqdef [(\vx, \Ignore) \in \argdecls: \vx]\\
  \assignargs((\envone, \emptygraph), \argnames, \actualargs) \evalarrow (\envtwo, \vgtwo)\\
  \paramnames \eqdef [(\vx, \Ignore) \in \params: \vx]\\
  \assignargs((\envtwo, \vgtwo), \paramnames, \paramdecls) \evalarrow (\envthree, \vgthree)\\
  \evalstmt{\envthree, \vbody} \evalarrow \vres \OrAbnormal\\
  \matchfuncres(\vres) \evalarrow C\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\ordered{\vgtwo}{\aslpo}{\vgthree}}\\
}{
  \evalsubprogram(\env, \name, \actualargs, \params) \evalarrow \withgraph{C}{\newg}
}
\end{mathpar}
\CodeSubsection{\EvalFCallBegin}{\EvalFCallEnd}{../Interpreter.ml}

\subsubsection{Comments}
\identr{DFWZ}
It is not an error for execution of a procedure or setter to end without a
return statement.

\SemanticsRuleDef{CheckRecurseLimit}
\hypertarget{def-checkrecurselimit}{}
The helper relation
\[
  \checkrecurselimit(\overname{\envs}{\env} \aslsep \overname{\identifier}{\name} \aslsep \overname{\expr?}{\velimitopt}) \aslto
  \overname{\XGraphs}{\vg} \cup \overname{\TDynError}{\DynErrorConfig}
\]
checks whether the value in the optional expression $\velimitopt$ has reached the limit associated with $\name$
in $\env$, yielding the execution graph resulting from evaluating the optional expression in $\vg$.
Otherwise, the result is a dynamic error indicating that the recursion limit has been reached.

\ExampleDef{Checking the Recursion Limit of a Subprogram Call}
In \listingref{CheckRecurseLimit-nolimit}, the function \verb|factorial| is specified without a limit expression,
and evaluating \verb|main| terminates normally.
\ASLListing{A recursive function with no limit expression}{CheckRecurseLimit-nolimit}{\semanticstests/SemanticsRule.CheckRecurseLimit.no_limit.asl}

In \listingref{CheckRecurseLimit}, the function \verb|factorial| specifies the limit expression \verb|11|,
and evaluating \verb|main| terminates normally.
\ASLListing{A recursive function with a limit expression}{CheckRecurseLimit}{\semanticstests/SemanticsRule.CheckRecurseLimit.asl}

In \listingref{CheckRecurseLimit-limitreached}, the function \verb|factorial| specifies the limit expression \verb|10|,
and evaluating \verb|main| terminates with a \dynamicerrorterm{} (\LimitExceeded), since the limit is exceeded.
\ASLListing{A recursive call exceeding the specified limit}{CheckRecurseLimit-limitreached}{\semanticstests/SemanticsRule.CheckRecurseLimit.limit_reached.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item applying $\evallimit$ to $\velimitopt$ in $\env$ yields $(\None, \vg)$\ProseOrError;
    \item define $\vg$ as the empty graph.
  \end{itemize}

  \item \AllApplyCase{some\_ok}
  \begin{itemize}
    \item applying $\evallimit$ to $\velimitopt$ in $\env$ yields $(\langle\vlimit\rangle, \vg)$\ProseOrError;
    \item view $\env$ as $(\tenv, \denv)$;
    \item applying $\getstacksize$ to $\name$ in $\denv$ yields $\vstacksize$;
    \item $\vstacksize$ is less than $\vlimit$.
  \end{itemize}

  \item \AllApplyCase{limit\_exceeded}
  \begin{itemize}
    \item applying $\evallimit$ to $\velimitopt$ in $\env$ yields $(\langle\vlimit\rangle, \vg)$\ProseOrError;
    \item view $\env$ as $(\tenv, \denv)$;
    \item applying $\getstacksize$ to $\name$ in $\denv$ yields $\vstacksize$;
    \item $\vstacksize$ is greater or equal to $\vlimit$;
    \item the result is a \dynamicerrorterm{} (\LimitExceeded).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{
  \evallimit(\env, \velimitopt) \evalarrow (\None, \vg) \OrDynError
}{
  \checkrecurselimit(\env, \name, \velimitopt) \evalarrow \overname{\emptygraph}{\vg}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_ok]{
  \evallimit(\env, \velimitopt) \evalarrow (\langle\vlimit\rangle, \vg) \OrDynError\\\\
  \env \eqname (\tenv, \denv)\\
  \getstacksize(\denv, \name) \evalarrow \vstacksize\\
  \vstacksize < \vlimit
}{
  \checkrecurselimit(\env, \name, \velimitopt) \evalarrow \vg
}
\end{mathpar}

\begin{mathpar}
\inferrule[limit\_exceeded]{
  \evallimit(\env, \velimitopt) \evalarrow (\langle\vlimit\rangle, \vg) \OrDynError\\\\
  \env \eqname (\tenv, \denv)\\
  \getstacksize(\denv, \name) \evalarrow \vstacksize\\
  \vstacksize \geq \vlimit
}{
  \checkrecurselimit(\env, \name, \velimitopt) \evalarrow \DynamicErrorVal{\LimitExceeded}
}
\end{mathpar}

\SemanticsRuleDef{ReadValueFrom}
\hypertarget{def-readvaluefrom}{}
The helper relation
\[
  \readvaluefrom(\vals \aslsep \Identifiers) \;\aslrel\; (\vals \times \XGraphs)
\]
generates an execution graph for reading the given value to a variable given
by the identifier, and pairs it with the given value.

\ProseParagraph
\AllApply
\begin{itemize}
  \item reading the value $\vv$ into the variable named $\id$ gives $\newg$;
  \item the result is $(\vv, \newg)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \readidentifier(\vv, \id) \evalarrow \newg
}{
  \readvaluefrom(\vv, \id) \evalarrow (\vv, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalReadValueFromBegin}{\EvalReadValueFromEnd}{../Interpreter.ml}

\SemanticsRuleDef{AssignArgs}
The relation
\hypertarget{def-assignargs}{}
\[
  \assignargs(
    (\overname{\envs}{\env}\times\overname{\XGraphs}{\vgone})\aslsep
    \overname{\Identifiers^*}{\vids} \aslsep
    \overname{(\vals\times\XGraphs)^*} {\actuals}) \;\aslrel\;
              (\overname{\envs}{\newenv} \times \overname{\XGraphs}{\newg})
\]
updates the pair consisting of the environments $\env$ and \executiongraph\ $\vgone$
by assigning the values given by $\actuals$ to the identifiers given by $\vids$,
yielding the updated pair $(\newenv, \newg)$.

\ExampleDef{Assigning Arguments}
In \listingref{AssignArgs}, the call expression \verb|plus(10, 5)| binds \verb|x| to $\nvint(10)$
and $\verb|y|$ to $\nvint(5)$. The expression \verb|x + y| then accesses
these variable values and evaluates to $\nvint(15)$.
\ASLListing{Assigning arguments}{AssignArgs}{\semanticstests/SemanticsRule.AssignArgs.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item both $\vids$ and $\actuals$ are empty lists;
    \item \Proseeqdef{$\newenv$}{$\env$};
    \item \Proseeqdef{$\newg$}{$\vgone$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vids$ has $\vx$ as its head and $\vidsone$ as its tail,
          and $\actuals$ has $\vm$ as its head and $\actualsone$ as its tail;
    \item declaring the local identifier $\vx$ with $\vm$ in $\env$ as per \SemanticsRuleRef{DeclareLocalIdentifierMM}
    gives \\ $(\envone, \vgtwo)$.
    \item assigning the remaining lists $\vidsone$ and $\actualsone$ with the environment $\envone$ and the ordered
          composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge yields\\
          $(\newenv, \newg)$.
    \item the entire result of the evaluation is $(\newenv, \newg)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \assignargs((\env, \vgone), \overname{\vids}{\emptylist}, \overname{\emptylist}{\actuals}) \evalarrow (\overname{\env}{\newenv}, \overname{\vgone}{\newg})
}
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_empty]{
  \declarelocalidentifiermm(\env, \vx, \vm) \evalarrow (\envone, \vgtwo)\\
  \assignargs((\envone, \ordered{\vgone}{\aslpo}{\vgtwo}), \vidsone, \actualsone) \evalarrow (\newenv, \vg)
}{
  \assignargs((\env, \vgone), \overname{[\vx] \concat \vidsone}{\vids}, \overname{[\vm] \concat \actualsone}{\actuals}) \evalarrow (\newenv, \vg)
}
\end{mathpar}

\SemanticsRuleDef{MatchFuncRes}
The helper relation
\hypertarget{def-matchfuncres}{}
\[
    \matchfuncres(\TContinuing \cup \TReturning) \;\aslrel\;
                  \Normal(((\Identifiers\times\vals)^*\times\XGraphs)\aslsep\envs)
\]
converts continuing configurations and returning configurations
into corresponding normal configurations that can be returned by a subprogram evaluation.

\ExampleDef{Converting Configurations Upon Subprogram Return}
In \listingref{MatchFuncRes},
the final configuration resulting from evaluating the call \verb|proc()|
is a \Prosecontinuingconfiguration{}, which is converted into
a \Prosenormalconfiguration{} with no return value.
On the other hand, the configuration resulting from evaluating the
call \verb|returns_values()| is a \Prosereturningconfiguration{} with the value
$\nvint(5)$, which is converted into a \Prosenormalconfiguration{}
with the same value and a fresh identifier for it.

\ASLListing{Converting configurations upon subprogram return}{MatchFuncRes}{\semanticstests/SemanticsRule.MatchFuncRes.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{continuing}
  \begin{itemize}
    \item the given configuration is $\Continuing(\vg, \env)$. This happens when,
    for example, the subprogram called is either a setter or a procedure;
    \item the result is $\Normal((\emptylist, \vg), \env)$.
  \end{itemize}

  \item \AllApplyCase{returning}
  \begin{itemize}
    \item the given configuration is $\Returning(\xs, \retenv)$, which is the case of a function;
    \item $\xs$ is the list $\vv_i$, for $i=1..k$;
    \item define the list of fresh identifiers $\id_i$, for $i=1..k$;
    \item define $\vvs$ to be $(\vv_i, \id_i)$, for $i=1..k$;
    \item the result is $\Normal((\vvs, \emptygraph), \retenv)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[continuing]{}
  {
    \matchfuncres(\Continuing(\vg, \env)) \evalarrow \Normal((\emptylist, \vg), \env)
  }
  \and
  \inferrule[returning]{
    \xs \eqname [i=1..k: \vv_i]\\
    i=1..k: \id_i \in \Identifiers\text{ is fresh}\\
    \vvs \eqdef [i=1..k: (\vv_i, \id_i)]
  }
  {
    \matchfuncres(\Returning(\xs, \retenv)) \evalarrow \Normal((\vvs, \emptygraph), \retenv)
  }
\end{mathpar}
