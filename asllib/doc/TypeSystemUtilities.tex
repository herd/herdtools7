\chapter{Type System Utility Rules\label{chap:TypeSystemUtilityRules}}

\hypertarget{def-checktrans}{}
\subsection{Checked Transitions}
We define the following rules to allow us asserting that a condition holds,
returning a type error otherwise:
\begin{mathpar}
  \inferrule[check\_trans\_true]{}{ \checktrans{\True}{<message>} \checktransarrow \True }
  \and
  \inferrule[check\_trans\_false]{}{ \checktrans{\False}{<message>} \checktransarrow \TypeErrorVal{\texttt{<message>}} }
\end{mathpar}

\hypertarget{def-pairstomap}{}
\subsection{Converting a List of Pairs to a Map \label{sec:PairsToMap}}
The parametric function
\[
  \pairstomap(\overname{(\identifier\times T)^*}{\pairs}) \aslto \overname{(\identifier\partialto T)}{f} \cup \TTypeError
\]
converts a list of pairs --- $\pairs$ --- where each pair consists of an identifier and a value
of type $T$ into a function mapping each identifier to its respective value in the list.
If a duplicate identifier exists in $\pairs$ then a type error is returned.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\pairs$ is empty;
    \item $f$ is the empty function.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item there exist two different positions in the list where the identifier is the same;
    \item the result is a type error indicating the existence of a duplicate identifier.
  \end{itemize}

  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item all identifiers occurring in the list are unique;
    \item $f$ is a function that associates to each identifier the value appearing with it in $\pairs$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[empty]{}{ \pairstomap(\emptylist) \typearrow \emptyfunc }
\and
\inferrule[error]{
  i,j \in 1..k\\
  i \neq j\\
  \id_i = \id_j
}
{
  \pairstomap([i=1..k: (\id_i,t_i)]) \typearrow \TypeErrorVal{DuplicateIdentifier}
}
\and
\inferrule[okay]{
  \forall i,j \in 1..k. \id_i \neq \id_j\\
  {
  f \eqdef \lambda \id.\ \begin{cases}
    t_i & \text{ if }i\in1..k \land \id = \id_i\\
    \bot & \text{ otherwise}
  \end{cases}
  }
}
{
  \pairstomap([i=1..k: (\id_i,t_i)]) \typearrow f
}
\end{mathpar}

\hypertarget{def-checknoduplicates}{}
\subsubsection{TypingRule.CheckNoDuplicates \label{sec:TypingRule.CheckNoDuplicates}}
The function
\[
  \checknoduplicates(\overname{\identifier^*}{\id_{1..k}}) \aslto \{\True\} \cup \TTypeError
\]
checks whether a non-empty list of identifiers contains a duplicate identifier. If it does not, the result
is $\True$ and otherwise the result is a type error.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item the set containing all identifiers in the list has the same cardinality as the length of the list;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item there exist two different positions in the list where the identifier is the same;
    \item the result is a type error indicating the existence of a duplicate identifier.
  \end{itemize}
\end{itemize}

\begin{mathpar}
  \inferrule[okay]{
    \cardinality{\{\id_{1..k}\}} = k
  }
  {
    \checknoduplicates(\id_{1..k}) \typearrow \True
  }
\and
\inferrule[error]{
  i,j \in 1..k\\
  i \neq j\\
  \id_i = \id_j
}
{
  \checknoduplicates(\id_{1..k}) \typearrow \TypeErrorVal{DuplicateIdentifier}
}
\end{mathpar}

\subsubsection{TypingRule.Sort\label{sec:sortinglists}}
\hypertarget{def-sort}{}
The parametric function
\[
\sort(\overname{T^*}{\vlone}, \overname{(T\times T)\rightarrow \{-1,0,1\}}{\compare}) \typearrow \overname{T^*}{\vltwo}
\]
sorts a list of elements of type $T$ --- $\vlone$ --- using the comparison function $\compare$,
resulting in the sorted list $\vltwo$.
$\compare(a, b)$ returns $1$ to mean that $a$ should be ordered before $b$,
$0$ to mean that $a$ and $b$ can be ordered in any way,
and $-1$ to mean that $b$ should be ordered before $a$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty\_or\_single}):
  \begin{itemize}
    \item $\vlone$ is either empty or contains a single element;
    \item $\vltwo$ is $\vlone$.
  \end{itemize}

  \item All of the following apply (\textsc{two\_or\_more}):
  \begin{itemize}
    \item $\vlone$ contains at least two elements;
    \item $f$ is a permutation of $1..n$;
    \item $\vltwo$ is the application of the permutation $f$ to $\vlone$;
    \item applying $\compare$ to every pair of consecutive elements in $\vltwo$ yields either $0$ or $1$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[empty\_or\_single]{
  \listlen{\vlone} = n\\
  n < 2
}{
  \sort(\vlone, \compare) \typearrow \overname{\vlone}{\vltwo}
}
\and
\inferrule[two\_or\_more]{
  \listlen{\vlone} = n\\
  f : 1..n \rightarrow 1..n \text{ is a bijection}\\
  \vltwo \eqdef [\ i=1..n: \vlone[f(i)]\ ]\\
  i=1..n-1: \compare(\vltwo[i], \vltwo[i+1]) \geq 0
}{
  \sort(\vlone, \compare) \typearrow \vltwo
}
\end{mathpar}

\subsubsection{TypingRule.FindBitfieldOpt}
\hypertarget{def-findbitfieldopt}{}
The function
\[
  \findbitfieldopt(\overname{\identifier}{\name} \aslsep \overname{\bitfield^*}{\bitfields})
  \aslto \overname{\langle\bitfield\rangle}{\vr}
\]
returns the bitfield associated with the name $\name$ in the list of bitfields $\bitfields$,
if there is one. Otherwise, the result is $\None$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{match}):
  \begin{itemize}
    \item $\bitfields$ starts with a bitfield $\vbf$;
    \item obtaining the name associated with $\vbf$ yields $\name$;
    \item the result if $\vbf$.
  \end{itemize}

  \item All of the following apply (\textsc{tail}):
  \begin{itemize}
    \item $\bitfields$ starts with a bitfield $\vbf$ and continues with the tail list $\bitfieldsp$;
    \item obtaining the name associated with $\vbf$ yields $\namep$, which is different than $\name$;
    \item finding the bitfield associated with $\name$ in $\bitfieldsp$ yields the result $\vr$.
  \end{itemize}

  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\bitfields$ is an empty list;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[match]{
  \bitfieldgetname(\vbf) \typearrow \name
}{
  \findbitfieldopt(\name, \overname{\vbf \concat \bitfieldsp}{\bitfields}) \typearrow \overname{\langle\vbf\rangle}{\vr}
}
\and
\inferrule[tail]{
  \bitfieldgetname(\vbf) \typearrow \namep\\
  \name \neq \namep\\
  \findbitfieldopt(\name, \bitfieldsp) \typearrow \vr
}{
  \findbitfieldopt(\name, \overname{\vbf \concat \bitfieldsp}{\bitfields}) \typearrow \vr
}
\and
\inferrule[empty]{}{
  \findbitfieldopt(\name, \overname{\emptylist}{\bitfields}) \typearrow \None
}
\end{mathpar}

\hypertarget{def-typeofarraylength}{}
\subsubsection{TypingRule.TypeOfArrayLength \label{sec:TypingRule.TypeOfArrayLength}}
The function
\[
  \typeofarraylength(\overname{\staticenvs}{\tenv} \aslsep \overname{\arrayindex}{\size}) \aslto
  \overname{\ty}{\vt}
\]
returns the type for the array index $\size$ in the static environment $\tenv$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{enum}):
  \begin{itemize}
    \item $\size$ is an enumeration index over the enumeration $\vs$, that is, \\ $\ArrayLengthEnum(\vs, \Ignore)$;
    \item $\vt$ is the named type for $\vs$, that is, $\TNamed(\vs)$.
  \end{itemize}

  \item All of the following apply (\textsc{expr}):
  \begin{itemize}
    \item $\size$ is an expression index for $\ve$, that is, $\ArrayLengthExpr(\ve)$;
    \item applying $\normalize$ to simplify the expression corresponding to $\ve - 1$ in $\tenv$
          yields the expression $\vm$;
    \item $\vc$ is the range constraint for $0..\vm$, that is, $\ConstraintRange(\eliteral{0}, \vm)$;
    \item $\vt$ is the well-constrained integer with the single constraint $\vc$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\TypeOfArrayLengthBegin}{\TypeOfArrayLengthEnd}{../types.ml}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[enum]{}
{
  \typeofarraylength(\tenv, \ArrayLengthEnum(\vs, \Ignore)) \typearrow \TNamed(\vs)
}
\and
\inferrule[expr]{
  \normalize(\tenv, \EBinop(\MINUS, \ve, \eliteral{1})) \typearrow \vm\\
  \vc \eqdef \ConstraintRange(\eliteral{0}, \vm)
}{
  \typeofarraylength(\tenv, \ArrayLengthExpr(\ve)) \typearrow \TInt(\wellconstrained([\vc]))
}
\end{mathpar}

\hypertarget{def-storageispure}{}
\subsubsection{TypingRule.StorageIsPure \label{sec:TypingRule.StorageIsPure}}
The function
\[
  \storageispure(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vs}) \aslto
  \overname{\Bool}{\vb} \cup \TTypeError
\]
$\vb$ is true if and only if the identifier $\vs$ corresponds to a \pureterm\ storage element
in the static environment $\tenv$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{local}):
  \begin{itemize}
    \item $\vs$ is a locally declared storage element;
    \item $\vb$ is true if and only if $\vs$ is declared as a constant or as an immutable variable (\texttt{let}).
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item $\vs$ is a globally declared storage element;
    \item $\vb$ is true if and only if $\vs$ is declared as a constant, a configuration variable, or an immutable variable.
  \end{itemize}

  \item All of the following apply (\textsc{subprogram\_or\_typename}):
  \begin{itemize}
    \item $\vs$ is not a storage element;
    \item checking whether $\vs$ is the name of a subprogram or the name of a declared type yields $\True$\ProseTerminateAs{\UndefinedIdentifier};
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\StorageIsPureBegin}{\StorageIsPureEnd}{../Typing.ml}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\localstoragetypes(\vs) = (\Ignore, \ldk)\\
  \vb \eqdef \ldk \in \{\LDKConstant, \LDKLet\}
}{
  \storageispure(\tenv, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[global]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = (\Ignore, \gdk)\\
  \vb \eqdef \gdk \in \{\GDKConstant, \GDKConfig, \GDKLet\}
}{
  \storageispure(\tenv, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[subprogram\_or\_typename]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = \bot\\
  \checktrans{G^\tenv.\subprograms \lor G^\tenv.\declaredtypes}{\UndefinedIdentifier} \checktransarrow \True \OrTypeError
}{
  \storageispure(\tenv, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\hypertarget{def-isstaticallyevaluable}{}
\hypertarget{def-staticallyevaluable}{}
\subsubsection{TypingRule.IsStaticallyEvaluable\label{sec:TypingRule.IsStaticallyEvaluable}}
The function
\[
  \isstaticallyevaluable(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\Bool}{\bv}
\]
returns in $\vb$ whether $\ve$ is a \staticallyevaluable\ expression in the static environment $\tenv$.

\subsubsection{Prose}
All of the following applies:
\begin{itemize}
  \item symbolically simplifying $\ve$ in $\tenv$ using $\normalize$ yields $\veone$;
  \item determining the set of used identifiers in $\veone$ yields $\useset$;
  \item $\vb$ is true if and only if every identifier in $\useset$ is pure.
\end{itemize}

\CodeSubsection{\IsStaticallyEvaluableBegin}{\IsStaticallyEvaluableEnd}{../Typing.ml}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \useexpr(\veone) \typearrow \useset\\
  \id\in\useset: \storageispure(\tenv, \id) \typearrow \vb_\id\\
  \vb \eqdef \bigwedge_{\id\in\useset} \vb_\id
}{
  \isstaticallyevaluable(\tenv, \ve) \typearrow \True
}
\end{mathpar}

\hypertarget{def-checkstaticallyevaluable}{}
\subsubsection{TypingRule.CheckStaticallyEvaluable \label{sec:TypingRule.CheckStaticallyEvaluable}}
The function
\[
  \checkstaticallyevaluable(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \{\True\} \cup \TTypeError
\]
returns $\True$ if $\ve$ is a \staticallyevaluable\ expression in the static environment $\tenv$ and a type error otherwise.

\subsubsection{Prose}
All of the following applies:
\begin{itemize}
  \item applying $\isstaticallyevaluable$ to $\ve$ in $\tenv$ yields $\vb$;
  \item the result is $\True$ is $\vb$ is $\True$, otherwise it is a type error indicating that the expression
  is not statically evaluable.
\end{itemize}

\CodeSubsection{\CheckStaticallyEvaluableBegin}{\CheckStaticallyEvaluableEnd}{../Typing.ml}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \isstaticallyevaluable(\tenv, \ve) \typearrow \vb\\
  \checktrans{\vb}{NotStaticallyEvaluable} \checktransarrow \True \OrTypeError
}{
  \checkstaticallyevaluable(\tenv, \ve) \typearrow \True
}
\end{mathpar}

\subsection{AssocOpt}
\hypertarget{def-assocopt}{}
The function
\[
  \assocopt(\overname{(\identifier\times T)^*}{\vli} \aslsep \overname{\identifier}{\id}) \typearrow \langle \overname{T}{\vv} \rangle
\]
returns the value $\vv$ associated with the identifier $\id$ in the list of pairs $\vli$ or $\None$, if no such association exists.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{member}):
  \begin{itemize}
    \item a pair $(\id,\vv)$ exists in the list $\vli$;
    \item the result is $\langle\vv\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_member}):
  \begin{itemize}
    \item every pair $(\vx,\Ignore)$ in the list $\vli$ has $\vx\neq\id$;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[not\_member]{
  (\vx, \vv) \in \vli: \vx \neq \id
}{
  \assocopt(\vli, \id) \typearrow \None
}
\and
\inferrule[member]{
  (\id, \vv) \in \vli
}{
  \assocopt(\vli, \id) \typearrow \langle \vv \rangle
}
\end{mathpar}

\section{Static Environment Utilities}

\hypertarget{def-withemptylocal}{}
\subsubsection{TypingRule.WithEmptyLocal}
The function
\[
  \withemptylocal(\overname{\globalstaticenvs}{\genv})
  \aslto \overname{\staticenvs}{\tenv}
\]
constructs a static environment from the global static environment $\genv$
and the empty local static environment.

\subsubsection{Prose}
The result is a static environment where the global component is $\genv$ and the local component
is the local static environment of $\emptytenv$.
\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \withemptylocal(\genv) \typearrow (\genv, L^{\emptytenv})
}
\end{mathpar}
\CodeSubsection{\WithEmptyLocalBegin}{\WithEmptyLocalEnd}{../types.ml}

\hypertarget{def-checkvarnotinenv}{}
\subsubsection{TypingRule.CheckVarNotInEnv\label{sec:TypingRule.CheckVarNotInEnv}}
The function
\[
  \checkvarnotinenv{\overname{\staticenvs}{\tenv} \aslsep \overname{\Strings}{\id}}
  \aslto \{\True\} \cup \TTypeError
\]
checks whether $\id$ is already declared in $\tenv$. If it is, the result is a type error,
and otherwise the result is $\True$.

\subsubsection{Prose}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\isundefined$ to $\vx$ in $\genv$ yields $\vb$;
  \item checking whether $\vb$ is $\True$ yields $\True$\ProseTerminateAs{\IdentifierAlreadyDeclared}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \isundefined(\tenv, \id) \typearrow \vb\\
  \checktrans{\vb}{\IdentifierAlreadyDeclared} \checktransarrow \True \OrTypeError
}{
  \checkvarnotinenv{\tenv, \id} \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckVarNotInEnvBegin}{\CheckVarNotInEnvEnd}{../types.ml}

\subsubsection{TypingRule.CheckVarNotInGEnv\label{sec:TypingRule.CheckVarNotInGEnv}}
\hypertarget{def-checkvarnotingenv}{}
The function
\[
  \checkvarnotingenv{\overname{\globalstaticenvs}{\genv} \aslsep \overname{\Strings}{\vx}}
  \aslto \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether $\id$ is already declared in the global static environment $\genv$.
If it is, the result is a type error, and otherwise the result is $\True$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\isglobalundefined$ to $\vx$ in $\genv$ yields $\vb$;
  \item checking whether $\vb$ is $\True$ yields $\True$\ProseTerminateAs{\IdentifierAlreadyDeclared}.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \isglobalundefined(\genv, \id) \typearrow \vb\\
  \checktrans{\vb}{\IdentifierAlreadyDeclared} \checktransarrow \True \OrTypeError
}{
  \checkvarnotingenv{\genv, \id} \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckVarNotInGEnvBegin}{\CheckVarNotInGEnvEnd}{../Interpreter.ml}

\hypertarget{def-addlocal}{}
\subsubsection{TypingRule.AddLocal \label{sec:TypingRule.AddLocal}}
The function
\[
  \addlocal(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\id} \aslsep
    \overname{\ty}{\tty} \aslsep
    \overname{\localdeclkeyword}{\ldk})
  \aslto
  \overname{\staticenvs}{\newtenv}
\]
adds the identifier $\id$ as a local storage element with type $\tty$ and local declaration keyword $\ldk$
to the local environment of $\tenv$, resulting in the static environment $\newtenv$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item the map $\newlocalstoragetypes$ is defined by updating the map \\
        $\localstoragetypes$ of $\tenv$
        with the binding $\id$ to the type $\tty$ and local declaration keyword $\ldk$, that is, $(\tty,\ldk)$;
  \item $\newtenv$ is defined by updating the local environment with the binding of \\
        $\localstoragetypes$ to $\newlocalstoragetypes$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \newlocalstoragetypes \eqdef L^\tenv.\localstoragetypes[\id \mapsto (\tty, \ldk)]\\
  \newtenv \eqdef (G^\tenv, L^\tenv[\localstoragetypes \mapsto \newlocalstoragetypes])
}
{
  \addlocal(\tenv, \id, \tty, \ldk) \typearrow \newtenv
}
\end{mathpar}

\subsubsection{TypingRule.IsUndefined\label{sec:TypingRule.IsUndefined}}
\hypertarget{def-isundefined}{}
The function
\[
\isundefined(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vx})
\aslto \overname{\Bool}{\vb}
\]
checks whether the identifier $\vx$ is defined as a storage element in the static environment $\tenv$.

\subsubsection{Prose}
$\vb$ is $\True$ if and only if $\vx$ is both undefined in the global static environment of $\tenv$
(see $\isglobalundefined$) and undefined in the local static environment of $\tenv$ (see $\islocalundefined$).

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \isglobalundefined(G^\tenv, \vx) \typearrow \vbone\\
  \islocalundefined(L^\tenv, \vx) \typearrow \vbtwo\\
}{
  \isundefined(\tenv, \vx) \typearrow \overname{\vbone \land \vbtwo}{\vb}
}
\end{mathpar}
\CodeSubsection{\IsUndefinedBegin}{\IsUndefinedEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.IsGlobalUndefined\label{sec:TypingRule.IsGlobalUndefined}}
\hypertarget{def-isglobalundefined}{}
The function
\[
\isglobalundefined(\overname{\globalstaticenvs}{\genv} \aslsep \overname{\identifier}{\vx}) \aslto \overname{\Bool}{\vb}
\]
checks whether the identifier $\vx$ is defined in the global static environment $\genv$, yielding the result in $\vb$.

\subsubsection{Prose}
Define $\vb$ as $\True$ if and only if $\vx$ is not bound in any of the following maps of $\genv$:
$\globalstoragetypes$, $\subprograms$, and $\declaredtypes$.
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  {
  \begin{array}{llcl}
    \vb \eqdef & \genv.\globalstoragetypes(\vx) &=& \bot\ \land\\
              & \genv.\subprograms(\vx) &=& \bot\ \land\\
              & \genv.\declaredtypes(\vx) &=& \bot
  \end{array}
  }
}{
  \isglobalundefined(\genv, \vx) \typearrow \vb
}
\end{mathpar}
\CodeSubsection{\IsGlobalUndefinedBegin}{\IsGlobalUndefinedEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.IsLocalUndefined\label{sec:TypingRule.IsLocalUndefined}}
\hypertarget{def-islocalundefined}{}
The function
\[
\islocalundefined(\overname{\localstaticenvs}{\lenv} \aslsep \overname{\identifier}{\vx}) \aslto \overname{\Bool}{\vb}
\]
checks whether $\vx$ is declared as a local storage element in the static local environment $\lenv$, yielding the result in $\vb$.

\subsubsection{Prose}
Define $\vb$ as $\True$ if and only if $\vx$ is not bound in the $\localstoragetypes$ of the static local environment $\lenv$.
\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \islocalundefined(\lenv, \vx) \typearrow \overname{L^\tenv.\localstoragetypes = \bot}{\vb}
}
\end{mathpar}
\CodeSubsection{\IsLocalUndefinedBegin}{\IsLocalUndefinedEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.IsSubprogram\label{sec:TypingRule.IsSubprogram}}
\hypertarget{def-issubprogram}{}
The function
\[
\issubprogram(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{vx}) \aslto \overname{\Bool}{\vb}
\]
checks whether the identifier $\vx$ has been declared as a subprogram in the static environment $\tenv$,
yielding an answer in $\vb$.

\subsubsection{Prose}
Define $\vb$ as $\True$ if and only if $\vx$ is bound in the $\subprograms$ map in the global static
environment of $\tenv$.

\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \issubprogram(\tenv, \vx) \typearrow \overname{G^\tenv.\subprograms[\vx] \neq \bot}{\vb}
}
\end{mathpar}
\CodeSubsection{\IsSubprogramBegin}{\IsSubprogramEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.LookupConstant}
\hypertarget{def-lookupconstant}{}
The function
\[
  \lookupconstant(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vs})
  \;\aslto\; \overname{\literal}{\vv}\ \cup\ \{\bot\}
\]
looks up the environment $\tenv$ for a constant $\vv$ associated with an identifier
$\vs$. The result is $\bot$ if $\vs$ is not associated with any constant.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{local}):
  \begin{itemize}
    \item $\vs$ is associated with a constant $\vv$ in the local environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item $\vs$ is not associated with a constant in the local environment of $\tenv$;
    \item $\vs$ is associated with a constant $\vv$ in the global environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{not\_found}):
  \begin{itemize}
    \item $\vs$ is not associated with a constant in the local environment of $\tenv$;
    \item $\vs$ is not associated with a constant in the global environment of $\tenv$;
    \item the result is $\bot$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\constantvalues(\vs) = \vv
}{
  \lookupconstant(\tenv, \vs) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  L^\tenv.\constantvalues(\vs) = \bot\\
  G^\tenv.\constantvalues(\vs) = \vv
}{
  \lookupconstant(\tenv, \vs) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_found]{
  L^\tenv.\constantvalues(\vs) = \bot\\
  G^\tenv.\constantvalues(\vs) = \bot
}{
  \lookupconstant(\tenv, \vs) \typearrow \bot
}
\end{mathpar}
\CodeSubsection{\LookupConstantBegin}{\LookupConstantEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.AddGlobalConstant\label{sec:TypingRule.AddGlobalConstant}}
\hypertarget{def-addglobalconstant}{}
The function
\[
\addglobalconstant(
  \overname{\globalstaticenvs}{\genv} \aslsep
  \overname{\identifier}{\name} \aslsep
  \overname{\literal}{\vv}) \typearrow
  \overname{\globalstaticenvs}{\newgenv}
\]
binds the identifier $\name$ to the literal $\vv$ in the global static environment $\genv$,
yielding the updated global static environment $\newgenv$.

\subsubsection{Prose}
Define $\newgenv$ as $\genv$ with the $\constantvalues$ map updated to bind $\name$ to $\vv$.
\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \addglobalconstant(\genv, \name, \vv) \typearrow \overname{\genv.\constantvalues[\name\mapsto\vv]}{\newgenv}
}
\end{mathpar}
\CodeSubsection{\AddGlobalConstantBegin}{\AddGlobalConstantEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.AddLocalConstant\label{sec:TypingRule.AddLocalConstant}}
\hypertarget{def-addlocalconstant}{}
The function
\[
\addlocalconstant(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\identifier}{\name} \aslsep
  \overname{\literal}{\vv}) \typearrow
  \overname{\staticenvs}{\newtenv}
\]
binds the identifier $\name$ to the literal $\vv$ in the local static environment component of the static environment $\tenv$,
yielding the updated static environment $\newtenv$.

\subsubsection{Prose}
Define $\newtenv$ as $\tenv$ with the global component updated such that its $\constantvalues$ map is updated to bind $\name$ to $\vv$.
\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \addlocalconstant(\tenv, \name, \vv) \typearrow \overname{(G^\tenv.\constantvalues[\name\mapsto\vv], L^\tenv)}{\newtenv}
}
\end{mathpar}
\CodeSubsection{\AddLocalConstantBegin}{\AddLocalConstantEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.LookupImmutableExpr\label{sec:TypingRule.LookupImmutableExpr}}
\hypertarget{def-lookupimmutableexpr}{}
The function
\[
\lookupimmutableexpr(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vx}) \aslto \overname{\expr}{\ve} \cup \{\bot\}
\]
looks up the static environment $\tenv$ for an immutable expression associated with the identifier $\vx$,
returning $\bot$ if there is none.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{local}):
  \begin{itemize}
    \item applying $\exprequiv$ to $\vx$ in the local component of $\tenv$, yields $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item applying $\exprequiv$ to $\vx$ in the local component of $\tenv$, yields $\bot$;
    \item applying $\exprequiv$ to $\vx$ in the global component of $\tenv$, yields $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item applying $\exprequiv$ to $\vx$ in the local component of $\tenv$, yields $\bot$;
    \item applying $\exprequiv$ to $\vx$ in the global component of $\tenv$, yields $\bot$;
    \item $\ve$ is $\bot$.
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\exprequiv(\vx) = \ve
}{
  \lookupimmutableexpr(\tenv, \vx) \typearrow \ve
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  L^\tenv.\exprequiv(\vx) = \bot\\
  G^\tenv.\exprequiv(\vx) = \ve\\
}{
  \lookupimmutableexpr(\tenv, \vx) \typearrow \ve
}
\end{mathpar}

\begin{mathpar}
\inferrule[none]{
  L^\tenv.\exprequiv(\vx) = \bot\\
  G^\tenv.\exprequiv(\vx) = \bot\\
}{
  \lookupimmutableexpr(\tenv, \vx) \typearrow \bot
}
\end{mathpar}
\CodeSubsection{\AddGlobalStorageBegin}{\AddGlobalStorageEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.AddGlobalImmutableExpr\label{sec:TypingRule.AddGlobalImmutableExpr}}
\hypertarget{def-addglobalimmutableexpr}{}
The function
\[
\addglobalimmutableexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\identifier}{\vx}
  \aslsep \overname{\expr}{\ve}) \aslto \overname{\staticenvs}{\newtenv}
\]
binds the identifier $\vx$, which is assumed to name a global storage element,
to the expression $\ve$, which is assumed to be \staticallyevaluable,
in the static environment $\tenv$,
resulting in the updated environment $\newtenv$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item define $\newtenv$ as the static environment with the same local environment as $\tenv$ and a global environment
        where $\exprequiv$ binds $\vx$ to $\ve$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \addglobalimmutableexpr(\tenv, \vx, \ve) \typearrow \overname{(G^\tenv.\exprequiv[\vx \mapsto \ve], L^\tenv)}{\newtenv}
}
\end{mathpar}
\CodeSubsection{\AddGlobalImmutableExprBegin}{\AddGlobalImmutableExprEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.AddLocalImmutableExpr\label{sec:TypingRule.AddLocalImmutableExpr}}
\hypertarget{def-addlocalimmutableexpr}{}
The function
\[
\addlocalimmutableexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\identifier}{\vx}
  \aslsep \overname{\expr}{\ve}) \aslto \overname{\staticenvs}{\newtenv}
\]
binds the identifier $\vx$, which is assumed to name a local storage element,
to the expression $\ve$, which is assumed to be \staticallyevaluable,
in the static environment $\tenv$,
resulting in the updated environment $\newtenv$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item define $\newtenv$ as the static environment with the same global environment as $\tenv$ and a local environment
        where $\exprequiv$ binds $\vx$ to $\ve$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \addlocalimmutableexpr(\tenv, \vx, \ve) \typearrow \overname{(G^\tenv, L^\tenv.\exprequiv[\vx \mapsto \ve])}{\newtenv}
}
\end{mathpar}
\CodeSubsection{\AddLocalImmutableExprBegin}{\AddLocalImmutableExprEnd}{../StaticEnv.ml}

\subsubsection{TypingRule.AddImmutableExpr\label{sec:TypingRule.AddImmutableExpr}}
\hypertarget{def-addimmutableexpression}{}
The function
\[
\addimmutableexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\localdeclkeyword}{\ldk} \aslsep
  \overname{\langle\expr\rangle}{\veopt}
  \overname{\identifier}{\vx}) \aslto
  \overname{\staticenvs}{\newtenv} \cup \TTypeError
\]
conditionally adds the information that the expression in $\veopt$ is statically evaluable
and bound to $\vx$.
More precisely, $\addimmutableexpr(\tenv, \ldk, \veopt, \vx)$
associates an expression with the identifier $\vx$
in the static environment $\tenv$, if one exists in $\veopt$ and it is \staticallyevaluable,
along with the local declaration keyword $\ldk$. The result is the updated static environment $\newtenv$.
\ProseOtherwiseTypeError

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{ok}):
  \begin{itemize}
    \item $\vep$ contains the expression $\ve$;
    \item $\ldk$ is either $\LDKConstant$ or $\LDKLet$;
    \item applying $\isstaticallyevaluable$ to $\ve$ in $\tenv$ yields $\True$;
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields $\vep$\ProseOrTypeError;
    \item applying $\addlocalimmutableexpr$ to $\vx$ and $\ve$ yields $\newtenv$.
  \end{itemize}

  \item All of the following apply (\textsc{fail}):
  \begin{itemize}
    \item One of the following applies:
    \begin{itemize}
      \item $\vep$ is $\None$;
      \item $\ldk$ is neither $\LDKConstant$ nor $\LDKLet$;
      \item applying $\isstaticallyevaluable$ to $\ve$ in $\tenv$ yields $\False$;
    \end{itemize}
    \item define $\newtenv$ as $\tenv$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[ok]{
  \ldk \in \{\LDKConstant, \LDKLet\}\\
  \isstaticallyevaluable(\tenv, \ve) \typearrow \True\\
  \normalize(\tenv, \ve) \typearrow \vep \OrTypeError\\\\
  \addlocalimmutableexpr(\vx, \vep) \typearrow \newtenv
}{
  \addimmutableexpr(\tenv, \ldk, \overname{\langle\ve\rangle}{\veopt}, \vx) \typearrow \newtenv
}
\end{mathpar}

\begin{mathpar}
\inferrule[fail]{
  {
    \begin{array}{ll}
      \ldk \not\in \{\LDKConstant, \LDKLet\} & \lor\\
      \veopt = \None & \lor\\
      \veopt = \langle\ve\rangle \land \isstaticallyevaluable(\tenv, \ve) \typearrow \False
    \end{array}
  }
}{
  \addimmutableexpr(\tenv, \ldk, \veopt, \vx) \typearrow \overname{\tenv}{\newtenv}
}
\end{mathpar}
