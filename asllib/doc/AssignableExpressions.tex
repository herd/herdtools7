\chapter{Assignable Expressions\label{chap:AssignableExpressions}}

\hypertarget{def-assignableexpression}{}
We refer to expressions that may appear on the left hand side of an assignment statement as \assignableexpressions.
An \assignableexpression\ is grammatically derived from $\Nlexpr$ and is represented as an AST
by $\lexpr$.

We show the syntax relevant to \assignableexpressions\ in \secref{AssignableExpressionsSyntax} and
the rules need to build the AST for \assignableexpressions\ in \secref{AssignableExpressionsAbstractSyntaxBuilders}.
These rules rely on three further desugaring relations, defined in \secref{AssignableExpressionsDesugaring}.
We then define the abstract syntax, typing, and semantics of the different kinds of \assignableexpressions:
\begin{itemize}
\item Discarding assignment expressions (see \secref{DiscardingAssignmentExpressions})
\item Variable assignment expressions (see \secref{VariableAssignmentExpressions})
\item Multi-assignment expressions (see \secref{MultiAssignmentExpressions})
\item Array assignment expressions (see \secref{ArrayAssignmentExpressions})
\item Bitvector slice assignment expressions (see \secref{BitvectorSliceAssignmentExpressions})
\item Structured type field assignment expressions (\secref{StructuredTypeFieldAssignmentExpressions})
\item Structured type multi-field assignment expressions (\secref{StructuredTypeMultiFieldAssignmentExpressions})
\item Bitfield assignment expressions (see \secref{BitfieldAssignableExpressions})
\end{itemize}

\hypertarget{def-annotatelexpr}{}
The function
\[
  \annotatelexpr{
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\lexpr}{\vle} \aslsep
    \overname{\ty}{\vte}} \aslto
    (\overname{\lexpr}{\newle} \times \overname{\TSideEffectSet}{\vses}) \cup \TTypeError
\]
annotates a left-hand side expression $\vle$ in an environment $\tenv$, assuming $\vte$
to be the type of the corresponding right-hand-side expression,
resulting in an annotated expression $\newle$ and inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

The relation
\hypertarget{def-evallexpr}{}
\[
  \evallexpr{\overname{\envs}{\env} \aslsep \overname{\lexpr}{\vle} \aslsep (\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg})} \;\aslrel\;
    \Normal(\overname{\XGraphs}{\newg},\overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the assignment of a value $\vv$
to the left-hand-side expression $\vle$ in an environment $\env$,
resulting in either a configuration $\Normal(\newg, \env)$ or an abnormal configuration.

\paragraph{Semantics Rules Naming Convention:}
In this chapter, variables containing $\vm$ range over $\vals\times\XGraphs$
while variables where the $\vm$ is replaced with $\vv$ correspond to their value component.
For example, $\rmarray\eqname(\rvarray,\vgtwo)$ and $\mindex\eqname(\vindex, \vgone)$.

\paragraph{Viewing Assignable Expressions as Right-hand-side Expressions:}
Some of the typing rules and semantics rules require viewing \assignableexpressions\
as \rhsexpressions.
The correspondence is given by the function $\torexpr : \lexpr \rightarrow \expr$., defined in \secref{LeftToRight}.
%
For example, \SemanticsRuleRef{LESetField}
needs to evaluate the record subexpression $\rerecord$, which is an \assignableexpression.
To achieve this, $\torexpr(\record)$ is used to obtain an \rhsexpression, which then allows
using $\texttt{eval\_expr}$ to evaluate it.

\section{Syntax\label{sec:AssignableExpressionsSyntax}}
\begin{flalign*}
\Nlexpr \derives\
   & \Tminus &\\
|\ & \Nbasiclexpr &\\
|\ & \Tlpar \parsesep \Clisttwo{\Ndiscardorbasiclexpr} \parsesep \Trpar &\\
|\ & \Tidentifier \parsesep \Tdot \parsesep \Tlbracket \parsesep \Clisttwo{\Tidentifier} \parsesep \Trbracket &\\
|\ & \Tidentifier \parsesep \Tdot \parsesep \Tlpar \parsesep \Clisttwo{\Ndiscardoridentifier} \parsesep \Trpar &
\end{flalign*}

\begin{flalign*}
\Nbasiclexpr \derives\
   & \Tidentifier \parsesep \Naccess &\\
|\ & \Tidentifier \parsesep \Naccess \parsesep \Nslices &
\end{flalign*}

\begin{flalign*}
\Naccess \derives\
   & \emptysentence  &\\
|\ & \Tdot \parsesep \Tidentifier \parsesep \Naccess &\\
|\ & \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket \parsesep \Naccess &\\
\end{flalign*}

\begin{flalign*}
\Ndiscardorbasiclexpr \derives\ & \Tminus \;|\; \Nbasiclexpr &
\end{flalign*}

\begin{flalign*}
\Ndiscardoridentifier \derives \ & \Tminus \;|\; \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax Builders\label{sec:AssignableExpressionsAbstractSyntaxBuilders}}

We first define $\lhsaccess$, which we use in this section as an intermediate representation between some syntax forms of \assignableexpressions{} and their corresponding abstract syntax.
In particular, rather than directly building the abstract syntax for these \assignableexpressions{}, we first build structures containing $\lhsaccess$, which we then desugar into abstract syntax in \secref{AssignableExpressionsDesugaring}.

\hypertarget{ast-lhsaccess}{}
\begin{flalign*}
\lhsaccess \derives\ &
{
\left\{
  \begin{array}{rcl}
    \lhsaccessaccess &:& \fieldorarrayaccess^{*}, \\
    \lhsaccessslices &:& \slice^{*}
\end{array}
\right\}
} &
\hypertarget{ast-fieldorarrayaccess}{}
\hypertarget{ast-fieldaccess}{}
\hypertarget{ast-arrayaccess}{}
\\
\fieldorarrayaccess \derives\ & \FieldAccess(\identifier)\ |\ \ArrayAccess(\expr)
\end{flalign*}

\ASTRuleDef{LExpr}
\hypertarget{build-lexpr}{}
The function
\[
  \buildlexpr(\overname{\parsenode{\Nlexpr}}{\vparsednode}) \;\aslto\; \overname{\lexpr}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[discard]{}{
  \buildlexpr(\Nlexpr(\Tminus)) \astarrow \overname{\LEDiscard}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[basic\_lexpr]{
  \desugarlhsaccess(\astof{\vbasiclexpr}) \astarrow \vastnode
}{
  \buildlexpr(\Nlexpr(\punnode{\Nbasiclexpr})) \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule[multi\_lexpr]{
  \buildclist[\builddiscardorbasiclexpr](\vlexprs) \astarrow \vlexprasts \\
  \desugarlhstuple(\vlexprasts) \astarrow \vastnode
}{
  {
  \begin{array}{r}
  \buildlexpr(\Nlexpr(\Tlpar, \namednode{\vlexprs}{\Clisttwo{\Ndiscardorbasiclexpr}}, \Trpar)) \\
  \astarrow \vastnode
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[concat\_fields]{
  \buildclist[\buildidentity](\vfields) \astarrow \vfieldasts
}{
  {
  \begin{array}{r}
  \buildlexpr(\Nlexpr(\Tidentifier(\id), \Tdot, \Tlbracket, \namednode{\vfields}{\Clisttwo{\Tidentifier}}, \Trbracket)) \astarrow \\
  \overname{\LESetFields (\LEVar(\id), \vfieldasts)}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple\_fields]{
  \buildclist[\builddiscardoridentifier](\vids) \astarrow \astversion{\vids} \\
  \desugarlhsfieldstuple(\id, \astversion{\vids}) \astarrow \vastnode
}{
  {
  \begin{array}{r}
  \buildlexpr(\Nlexpr(\Tidentifier(\id), \Tdot, \Tlpar, \namednode{\vids}{\Clisttwo{\Ndiscardoridentifier}}, \Trpar))\\ \astarrow
  \vastnode
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{BasicLexpr}
\hypertarget{build-basiclexpr}{}
The function
\[
  \buildbasiclexpr(\overname{\parsenode{\Nbasiclexpr}}{\vparsednode}) \;\aslto\; (\overname{\identifier}{\vbase} \aslsep \overname{\lhsaccess}{\vlhsaccess})
\]
transforms a parse node $\vparsednode$ into a pair of AST nodes, $\vbase$ and $\vlhsaccess$.

\begin{mathpar}
\inferrule[no\_slices]{
  {
  \vlhsaccess \eqdef
    \left\{
      \begin{array}{rcl}
        \lhsaccessaccess &:& \astof{\vaccess},\\
        \lhsaccessslices &:& \emptylist
      \end{array}
    \right\}
  }
}{
  \buildbasiclexpr(\Nbasiclexpr(\Tidentifier(\vbase),\punnode{\Naccess})) \astarrow
  (\vbase, \vlhsaccess)
}
\end{mathpar}

\begin{mathpar}
\inferrule[slices]{
  {
  \vlhsaccess \eqdef
    \left\{
      \begin{array}{rcl}
              \lhsaccessaccess &:& \astof{\vaccess},\\
              \lhsaccessslices &:& \astof{\vslices}
      \end{array}
    \right\}
  }
}{
  \buildbasiclexpr(\Nbasiclexpr(\Tidentifier(\vbase),\punnode{\Naccess}, \punnode{\Nslices})) \astarrow
  (\vbase, \vlhsaccess)
}
\end{mathpar}

\ASTRuleDef{Access}

\hypertarget{build-access}{}
The function
\[
  \buildaccess(\overname{\parsenode{\Naccess}}{\vparsednode}) \;\aslto
  \overname{\fieldorarrayaccess^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildaccess(\Naccess(\emptysentence)) \astarrow \overname{\emptylist}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[field\_access]{}{
  \buildaccess(\Naccess(\Tdot, \Tidentifier(\vfield), \punnode{\Naccess})) \astarrow
  \overname{[\FieldAccess(\vfield)] \concat \astof{\vaccess}}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[array\_access]{}{
  \buildaccess(\Naccess(\Tllbracket, \punnode{\Nexpr}, \Trrbracket, \punnode{\Naccess})) \astarrow
  \overname{[\ArrayAccess(\astof{\vexpr})] \concat \astof{\vaccess}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{DiscardOrBasicLexpr}

\hypertarget{build-discardorbasiclexpr}{}
The function
\[
\begin{array}{r}
  \builddiscardorbasiclexpr(\overname{\parsenode{\Ndiscardorbasiclexpr}}{\vparsednode}) \;\aslto\\
  \overname{\langle\lhsaccess\rangle}{\vastnode}
\end{array}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[discard]{}{
  \builddiscardorbasiclexpr(\Ndiscardorbasiclexpr(\Tminus)) \astarrow \overname{\None}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[basic]{}{
  {
    \begin{array}{r}
      \builddiscardorbasiclexpr(\Ndiscardorbasiclexpr(\punnode{\Nbasiclexpr})) \astarrow \\
      \overname{\langle \astof{\vbasiclexpr} \rangle}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DiscardOrIdentifier}

\hypertarget{build-discardoridentifier}{}
The function
\[
\begin{array}{r}
  \builddiscardoridentifier(\overname{\parsenode{\Ndiscardoridentifier}}{\vparsednode}) \;\aslto
  \overname{\langle\identifier\rangle}{\vastnode}
\end{array}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[none]{}{
  \builddiscardoridentifier(\Ndiscardoridentifier(\Tminus)) \astarrow \overname{\None}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{}{
  {
    \begin{array}{r}
      \builddiscardoridentifier(\Ndiscardoridentifier(\Tidentifier(\id))) \astarrow
      \overname{\langle \id \rangle}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Desugaring Assignable Expressions\label{sec:AssignableExpressionsDesugaring}}

This section defines three desugaring relations which produce assignable expression abstract syntax, that is, $\lexpr$.
They are used in \secref{AssignableExpressionsAbstractSyntaxBuilders} to build $\lexpr$ abstract syntax.
\begin{itemize}
  \item $\desugarlhsaccess$, which desugars a pair consisting of an $\identifier$ and an $\lhsaccess$ into an $\lexpr$.
  \item $\desugarlhstuple$, which desugars a tuple of optional $\lhsaccess$ elements into an $\lexpr$.
    This represents a multi-assignment of a tuple value, where $\None$ means that element of the tuple is discarded.
  \item $\desugarlhsfieldstuple$, which desugars a multi-assignment of a tuple value to multiple fields of an identifier.
\end{itemize}

\ASTRuleDef{DesugarLHSAccess}
\hypertarget{def-desugarlhsaccess}{}
The function
\[
  \desugarlhsaccess(\overname{\identifier}{\name}, \overname{\lhsaccess}{\vlhsaccess}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
transforms an $\lhsaccess$ on an identifier $\name$ into an AST node $\vlexpr$.

\ExampleDef{Desugaring a left-hand side access}
\listingref{DesugarLHSAccess} shows an example of desugaring an $\lhsaccess$.
\ASLListing{Desugaring a left-hand side access}{DesugarLHSAccess}{\syntaxtests/ASTRule.DesugarLHSAccess.asl}

\begin{mathpar}
\inferrule{
  \vlexprs_0 \eqdef \LEVar(\name) \\
  {
  i \in 1..|\vaccess|: \vlexprs_i \eqdef
    \begin{cases}
      \LESetField(\vlexprs_{i-1}, \vfield) \\
        \qquad \text{if } \vaccess_i = \FieldAccess(\vfield) \\
      \LESetArray(\vlexprs_{i-1}, \vexpr) \\
        \qquad \text{if } \vaccess_i = \ArrayAccess(\vexpr) \\
    \end{cases}
  } \\
  \vlexpr \eqdef
  \choice{\vslices = \emptylist}{\vlexprs_{|\vaccess|}}{\LESlice(\vlexprs_{|\vaccess|}, \vslices)}
}{
  \desugarlhsaccess\overname{
    \left\{
      {
        \begin{array}{rcl}
          \lhsaccessaccess &:& \vaccess, \\
          \lhsaccessslices &:& \vslices
        \end{array}
      }
    \right\}
  }{\vlhsaccess} \astarrow \vlexpr
}
\end{mathpar}

\ASTRuleDef{DesugarLHSTuple}
\hypertarget{def-desugarlhstuple}{}
The function
\[
  \desugarlhstuple(\overname{\langle\lhsaccess\rangle^*}{\vlhsaccessopts}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
transforms a list of \optional{} $\lhsaccess$ elements into an AST node $\vlexpr$. \\

\ExampleDef{Desugaring a left-hand side tuple}
\listingref{DesugarLHSTuple} shows an example of desugaring a left-hand side tuple.
\ASLListing{Desugaring a left-hand side tuple}{DesugarLHSTuple}{\syntaxtests/ASTRule.DesugarLHSTuple.asl}

\begin{mathpar}
\inferrule{
  i \in 1..|\vlhsaccessopts|: \desugarlhsaccessopt(\vlhsaccessopt_i) \astarrow \vlexpr_i \\
  \vlexprs \eqdef [i \in 1..|\vlhsaccessopts|: \vlexpr_i]
}{
  \desugarlhstuple(\vlhsaccessopts) \astarrow \overname{\LEDestructuring(\vlexprs)}{\vlexpr}
}
\end{mathpar}

\ASTRuleDef{DesugarLHSAccessOpt}
\hypertarget{def-desugarlhsaccessopt}{}
The helper AST function
\[
    \desugarlhsaccessopt(\overname{\langle\lhsaccess\rangle}{\vlhsaccessopt}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
is defined via the following rules:

\begin{mathpar}
\inferrule[none]{}
{
  \desugarlhsaccessopt(\overname{\None}{\vlhsaccessopt}) \astarrow \overname{\LEDiscard}{\vlexpr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \desugarlhsaccess(\vlhsaccess) \astarrow \vlexpr
}{
  \desugarlhsaccessopt(\overname{\langle\vlhsaccess\rangle}{\vlhsaccessopt}) \astarrow \vlexpr
}
\end{mathpar}

\ASTRuleDef{DesugarLHSFieldsTuple}
\hypertarget{def-desugarlhsfieldstuple}{}
The function
\[
  \desugarlhsfieldstuple(\overname{\identifier}{\id} \aslsep \overname{\langle\identifier\rangle^*}{\fieldopts}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
transforms an assignment to a tuple of fields $\fields$ of variable $\id$ into an AST node $\vlexpr$. \\

\ExampleDef{Desugaring a left-hand side fields tuple}
\listingref{DesugarLHSFieldsTuple} shows an example of desugaring a left-hand side fields tuple.
\ASLListing{Desugaring a left-hand side fields tuple}{DesugarLHSFieldsTuple}{\syntaxtests/ASTRule.DesugarLHSFieldsTuple.asl}

\begin{mathpar}
\inferrule{
  \filteroptionlist(\fieldopts) \aslto \fields\\
  \checknoduplicates(\fields) \typearrow \True \OrTypeError \\
  i \in 1..|\fieldopts|: \desugarlhsfieldopt(\id, \fieldopts[i]) \astarrow \vlexpr_i \\
  \vlexprs \eqdef [i \in 1..|\fieldopts|: \vlexpr_i]
}{
  \desugarlhsfieldstuple(\id, \fieldopts) \astarrow \overname{\LEDestructuring(\vlexprs)}{\vlexpr}
}
\end{mathpar}

\ASTRuleDef{FilterOptionList}
\hypertarget{def-filteroptionlist}{}
The parametric function
\[
  \filteroptionlist(\overname{\langle T \rangle^*}{\vvopts}) \aslto \overname{T^*}{\vvs}
\]
filters a list of \optional{} elements, removing those which are $\None$ and unwrapping those which are $\langle v \rangle$ to $v$.

\ExampleDef{Filtering a List of Optionals}
In \listingref{DesugarLHSFieldsTuple},
the \assignableexpression{} \verb|x.(fld1, -, fld2)|
requires desugaring into a list of \assignableexpressions{} via \ASTRuleRef{DesugarLHSFieldsTuple}.
The list of fields is represented in the \untypedast{} as $[\Some{\fldone}, \None, \Some{\fldtwo}]$.
Before checking the list \verb|fld1, -, fld2| for absence of duplicates, it is filtered as follows:\\
$\filteroptionlist([\Some{\fldone}, \None, \Some{\fldtwo}]) \aslto [\fldone, \fldtwo]$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vvopts$ is the empty list;
    \item $\vvs$ is the empty list.
  \end{itemize}

  \item \AllApplyCase{non\_empty\_none}
  \begin{itemize}
    \item $\vvopts$ is the non-empty list with head $\None$ and tail $\vvoptsp$;
    \item applying $\filteroptionlist$ to $\vvoptsp$ yields $\vvs$.
  \end{itemize}

  \item \AllApplyCase{non\_empty\_some}
  \begin{itemize}
    \item $\vvopts$ is the non-empty list with head $\langle\vv\rangle$ and tail $\vvoptsp$;
    \item applying $\filteroptionlist$ to $\vvoptsp$ yields $\vvsp$;
    \item $\vvs$ is the concatenation of $\vv$ and $\vvsp$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[empty]{}
  {
    \filteroptionlist(\overname{\emptylist}{\vvopts}) \typearrow \overname{\emptylist}{\vvs}
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_empty\_none]{
    \filteroptionlist(\vvoptsp) \typearrow \vvs
  }{
    \filteroptionlist(\overname{[\None] \concat \vvoptsp}{\vvopts}) \typearrow \vvs
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_empty\_some]{
    \filteroptionlist(\vvoptsp) \typearrow \vvsp
  }{
    \filteroptionlist(\overname{[\langle\vv\rangle] \concat \vvoptsp}{\vvopts}) \typearrow \overname{[\vv] \concat \vvsp}{\vvs}
  }
\end{mathpar}

\ASTRuleDef{DesugarLHSFieldOpt}
\hypertarget{def-desugarlhsfieldopt}{}
The helper AST function
\[
    \desugarlhsfieldopt(\overname{\identifier}{\id} \aslsep \overname{\langle\identifier\rangle}{\fieldopt}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
is defined via the following rules:
\begin{mathpar}
\inferrule[none]{}
{
  \desugarlhsfieldopt(\id, \overname{\None}{\fieldopt}) \astarrow \overname{\LEDiscard}{\vlexpr}
}
\end{mathpar}

\begin{mathpar}
\inferrule{}{
  \desugarlhsfieldopt(\id, \overname{\langle\vfield\rangle}{\fieldopt}) \astarrow \overname{\LESetField(\LEVar(\id), \vfield)}{\vlexpr}
}
\end{mathpar}

\hypertarget{def-discardlexprterm}{}
\section{Discarding Assignment Expressions\label{sec:DiscardingAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \overtext{\LEDiscard}{\texttt{"-"}} &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LEDiscard}
\ExampleDef{Well-typed Discarding Assignments}
All discarding assignments in \listingref{typing-lediscard} are well-typed.
\ASLListing{Well-typed discarding assignments}{typing-lediscard}{\typingtests/TypingRule.LEDiscard.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes an expression that can be discarded, that is, $\LEDiscard$;
  \item \Proseeqdef{$\newle$}{$\vle$};
  \item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \annotatelexpr{\tenv, \overname{\LEDiscard}{\vle}, \vte} \typearrow (\overname{\LEDiscard}{\newle}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\LEDiscardBegin}{\LEDiscardEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{LEDiscard}
\ExampleDef{Discarding Assignments}
In \listingref{semantics-lediscard}, the assignment \texttt{- = 42;} does not affect the environment.
\ASLListing{Assignment to \texttt{-}}{semantics-lediscard}{\semanticstests/SemanticsRule.LEDiscard.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ is a discarding expression, $\LEDiscard$;
  \item $\newg$ is $\vg$;
  \item $\newenv$ is $\env$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \newg\eqdef\vg\\
  \newenv\eqdef\env
}{
  \evallexpr{\env, \LEDiscard, (\vv, \vg)} \evalarrow \Normal(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalLEDiscardBegin}{\EvalLEDiscardEnd}{../Interpreter.ml}

\hypertarget{def-varlexprterm}{}
\section{Variable Assignment Expressions\label{sec:VariableAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LEVar(\identifier) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LEVar}
\ExampleDef{Variable Assignments}
In \listingref{typing-levar}, all variable assignments are well-typed.
\ASLListing{Well-typed variable assignments}{typing-levar}{\typingtests/TypingRule.LEVar.asl}

In \listingref{typing-levar-undefined}, the assignment to \verb|x| is ill-typed,
since \verb|x| is not defined as either a local storage element or as a global storage element.
\ASLListing{An ill-typed variable assignment}{typing-levar-undefined}{\typingtests/TypingRule.LEVar.undefined.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item $\vle$ denotes a left-hand-side variable expression for $\vx$, that is, $\LEVar(\vx)$;
  \item \AllApplyCase{local}
  \begin{itemize}
    \item $\vx$ is declared in $\tenv$ as a local storage element with type $\tty$ and local declaration keyword $k$;
    \item checking that $k$ corresponds to a mutable variable, that is, $\LDKVar$, yields $\True$\ProseTerminateAs{\AssignmentToImmutable};
    \item determining whether $\tty$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\newle$ is $\vle$;
    \item \Proseeqdef{$\vses$}{the \WriteLocalTerm\ for $\vx$}.
  \end{itemize}

  \item \AllApplyCase{global}
  \begin{itemize}
    \item $\vx$ is declared in $\tenv$ as a global storage element with type $\tty$ and global declaration keyword $k$;
    \item checking that $k$ corresponds to a mutable variable, that is, $\GDKVar$, yields $\True$\ProseTerminateAs{\AssignmentToImmutable};
    \item determining whether $\tty$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\newle$ is $\vle$;
    \item \Proseeqdef{$\vses$}{the \WriteGlobalTerm\ for $\vx$}.
  \end{itemize}

  \item \AllApplyCase{error\_undefined}
  \begin{itemize}
    \item $\vx$ is not declared in $\tenv$ as a local storage element nor as a global storage element;
    \item the result is a \typingerrorterm{} $\UndefinedIdentifier$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\localstoragetypes(\vx) = (\tty, k)\\
  \checktrans{k = \LDKVar}{\AssignmentToImmutable} \checktransarrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vte, \tty) \typearrow \True \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LEVar(\vx)}{\vle}, \vte} \typearrow
  (\overname{\vle}{\newle}, \{\WriteLocal(\vx)\})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  L^\tenv.\globalstoragetypes(\vx) = (\tty, k)\\
  \checktrans{k = \GDKVar}{AssignToImmutable} \checktransarrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vte, \tty) \typearrow \True \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LEVar(\vx)}{\vle}, \vte} \typearrow
  (\overname{\vle}{\newle}, \{\WriteGlobal(\vx)\})
}
\end{mathpar}

\begin{mathpar}
\inferrule[error\_undefined]{
  L^\tenv.\localstoragetypes(\vx) = \bot\\
  L^\tenv.\globalstoragetypes(\vx) = \bot
}{
  \annotatelexpr{\tenv, \overname{\LEVar(\vx)}{\vle}, \vte} \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}
\identr{WDGQ} \identr{GNTS} \identi{MMKF}
\identi{DGWJ} \identi{KKCC}  \identr{LXQZ}
\CodeSubsection{\LEVarBegin}{\LEVarEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{LEVar}
\ExampleDef{Local Variable}
In \listingref{semantics-levar}, \SemanticsRuleRef{LEVar} is (only) used
to assign the value $42$ to the left-hand-side expression
\texttt{x} within \texttt{x = 42;}.

\ASLListing{Semantics of a left-hand-side variable expression}{semantics-levar}{\semanticstests/SemanticsRule.LELocalVar.asl}

\ExampleDef{Global Variable}
In \listingref{semantics-leglobalvar},
\SemanticsRuleRef{LEVar} is (only) used to assign the value $42$ to the left-hand-side expression
\texttt{x} within \texttt{x = 42;}.
\ASLListing{Assignment to a global variable}{semantics-leglobalvar}{\semanticstests/SemanticsRule.LEGlobalVar.asl}

\ProseParagraph
\AllApply
\begin{itemize}
    \item $\vle$ denotes a variable, $\LEVar(\vx)$;
    \item view $\env$ as an environment where $\tenv$ is the static environment and $\denv$ is the dynamic environment;
    \item \OneApplies
    \begin{itemize}
        \item \AllApplyCase{local}
        \begin{itemize}
            \item $\vx$ is in the local dynamic environment ($L^\denv$);
            \item $\newenv$ is $\env$ where $\vx$ is bound to $\vv$ in the local dynamic environment ($L^\denv$).
        \end{itemize}

        \item \AllApplyCase{global}
        \begin{itemize}
            \item $\vx$ is bound in the global dynamic environment ($G^\denv.\storage$);
            \item $\newenv$ is $\env$ where $\vx$ is bound to $\vv$ in the $\storage$ map of the global dynamic environment $G^\denv$.
        \end{itemize}
    \end{itemize}
    \item $\newg$ is the ordered composition of $\vg$ and a Write Effect for $\vx$ with the $\asldata$ edge;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local]{
  \env \eqname (\tenv, \denv)\\
  \vx \in \dom(L^\denv)\\
  \newenv \eqdef (\tenv, (G^\denv, L^\denv[\vx \mapsto \vv]))\\
  \newg \eqdef \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
}{
  \evallexpr{\env, \LEVar(\vx), (\vv, \vg)} \evalarrow \Normal(\newg,\newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  \env \eqname (\tenv, \denv)\\
  \vx \in \dom(G^\denv.\storage)\\
  \newenv \eqdef(\tenv, (G^\denv.\storage[\vx \mapsto \vv], L^\denv))\\
  \newg \eqdef \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
}{
  \evallexpr{\env, \LEVar(\vx), (\vv, \vg)} \evalarrow \Normal(\newg,\newenv)
}
\end{mathpar}
\CodeSubsection{\EvalLEVarBegin}{\EvalLEVarEnd}{../Interpreter.ml}

\section{Multi-assignment Expressions\label{sec:MultiAssignmentExpressions}}
\hypertarget{def-destructuringlexprterm}{}
\ASLListing{Assignment to multiple left-hand-side expressions}{semantics-ledestructuring}{\semanticstests/SemanticsRule.LEDestructuring.asl}

\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LEDestructuring(\lexpr^*) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LEDestructuring}
\ExampleDef{Well-typed Multi-variable Assignment}
In \listingref{semantics-ledestructuring}, the multi-assignment
\verb|(x, y) = (3, 42)| is well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes a tuple of left-hand-side expressions $\les$, that is, $\LEDestructuring(\les)$;
  \item $\les$ is a list $\ve_{1..k}$;
  \item checking whether $\vte$ is a \tupletypeterm{} yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item $\vte$ is a \tupletypeterm{} over the list of types $\tys$, that is, $\TTuple(\tys)$;
  \item determining whether $\les$ and $\subtys$ have the same length yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item $\subtys$ is the list of types $\vt_{1..k}$;
  \item annotating the left-hand-side expression $\ve_i$ with the type $\vt_i$, for $i=1..k$, yields $(\vep_i, \vxs_i)$\ProseOrTypeError;
  \item the list of expressions $\lesp$ is $\vep_i$, for $i=1..k$;
  \item $\newle$ is the list of left-hand-side expressions $\lesp$, that is, $\LEDestructuring(\lesp)$;
  \item define $\vses$ as the union of all sets $\vxs_i$, for $i=1..k$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \les \eqname [\ve_{1..k}]\\
  \checktrans{\astlabel(\vte) = \TTuple}{\UnexpectedType} \checktransarrow \True \OrTypeError\\\\
  \vte \eqname \TTuple(\tys)\\
  \equallength(\les, \tys) \typearrow \vb\\
  \checktrans{\vb}{\UnexpectedType} \checktransarrow \True \OrTypeError\\\\
  \tys \eqname [\vt_{1..k}]\\
  i=1..k: \annotatelexpr{\tenv, \ve_i,\vt_i} \typearrow (\vep_i, \vxs_i) \OrTypeError\\\\
  \lesp \eqname [i=1..k: \vep_i]\\
  \vses \eqdef \bigcup_{i=1..k}  \vxs_i
}{
  \annotatelexpr{\tenv, \overname{\LEDestructuring(\les)}{\vle}, \vte} \typearrow
  (\overname{\LEDestructuring(\lesp)}{\newle}, \vses)
}
\end{mathpar}
\CodeSubsection{\LEDestructuringBegin}{\LEDestructuringEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{LEDestructuring}
\ExampleDef{Multi-assignments}
In \listingref{semantics-ledestructuring}, the multi-assignment \verb|(x, y) = (3, 42)| binds
\texttt{x} to $\nvint(3)$ and \texttt{y} to
$\nvint(42)$ in the environment where \texttt{x} is bound to $\nvint(42)$ and
\texttt{y} is bound to $\nvint(3)$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes a list of left-hand-side expressions, $\LEDestructuring(\vlelist)$;
  \item $\vlelist$ is the list of expressions $\vle_{1..n}$;
  \item getting the values from the native vector $\vv$ at each index $i=1..n$
  results in $\vv_{i=1..n}$;
  \item $\nmonads$ is the list of pairs consisting of $\vv_i$ and $\vg$ for $i=1..n$;
  \item evaluating the multi-assignment between $\vlelist$ and the list $\nmonads$
  in $\env$ achieves the effects of assigning each value to the respective
  subexpressions, resulting in the output configuration $C$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vlelist \eqname [\vle_{1..n}]\\
  i=1..n: \getindex(i, \vv) \evalarrow \vv_i\\
  \nmonads \eqdef [i=1..n: (\vv_i, \vg)]\\
  \evalmultiassignment(\env, \vlelist, \nmonads) \evalarrow C
}{
  \evallexpr{\env, \LEDestructuring(\vlelist), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLEDestructuringBegin}{\EvalLEDestructuringEnd}{../Interpreter.ml}

\SemanticsRuleDef{LEMultiAssign}
The helper relation
\hypertarget{def-evalmultiassign}{}
\[
  \evalmultiassignment(\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vlelist} \aslsep \overname{(\vals \times \XGraphs)^*}{\vmlist}) \;\aslrel\;
  \Normal(\overname{\XGraphs}{\newg} \aslsep \overname{\envs}{\newenv}) \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates multi-assignments.
That is, the simultaneous assignment of the list of value-execution graph pairs $\vmlist$
to the corresponding list of left-hand side expressions $\vlelist$, in the environment $\env$.
The result is either the execution graph $\vg$ and new environment $\newenv$ or an abnormal configuration.

See \ExampleRef{Multi-assignments}.

\ProseParagraph
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item both $\vlelist$ and $\vmlist$ are empty lists;
    \item \Proseeqdef{$\newg$}{the empty \executiongraph};
    \item \Proseeqdef{$\newenv$}{$\env$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vle$ is a \Proselist{$\vle$}{$\vlelistone$};
    \item $\vmlist$ is a \Proselist{$\vm$}{$\vmlistone$};
    \item \Proseevallexpr{$\env$}{$\vle$}{$\vm$}{$\Normal(\envone, \vgone)$}\ProseOrAbnormal;
    \item applying $\evalmultiassignment$ to $\envone$, $\vlelistone$, and $\vmlistone$
          yields \\
          $\Normal(\newenv, \vgtwo)$\ProseOrAbnormal;
    \item \Proseeqdef{$\newg$}{the ordered composition of $\vgone$ and $\vgtwo$
          with the edge $\aslpo$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \evalmultiassignment(\env, \overname{\emptylist}{\vlelist}, \overname{\emptylist}{\vmlist}) \evalarrow
  \Normal(\overname{\emptygraph}{\newg}, \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vlelist = [\vle] \concat \vlelistone\\
  \vmlist = [\vm] \concat \vmlistone\\
  \evallexpr{\env, \vle, \vm} \evalarrow \Normal(\envone, \vgone) \OrAbnormal\\\\
  \evalmultiassignment(\envone, \vlelistone, \vmlistone) \evalarrow \Normal(\newenv, \vgtwo) \OrAbnormal\\\\
  \newg \eqdef \ordered{\vgone}{\aslpo}{\vgtwo}
}{
  \evalmultiassignment(\env, \vlelist, \vmlist) \evalarrow \Normal(\newg, \newenv)
}
\end{mathpar}
Notice that this rule is only defined when the lists $\vlelist$ and $\vmlist$ have the same length.
To see this, notice that
to form a derivation tree, we must employ the \textsc{nonempty} case, which ensures both lists
have at least one element and shortens the lengths of both lists by one,
until both lists become empty
which is when the \textsc{empty} axiom case is used.

\hypertarget{def-setarraylexprterm}{}
\section{Array Assignment Expressions\label{sec:ArrayAssignmentExpressions}}
This section details the syntax, abstract syntax, semantics, and typing of array write expressions.
In the untyped AST, a write to either an integer-indexed array or an enumeration-indexed array is represented
the same way. The type system infers the kind of array and outputs a typed AST node differentiating
the two kinds of arrays, either a $\LESetArray$ or a $\LESetEnumArray$, via \TypingRuleRef{LESetArray}.
The semantics utilizes a rule matching the corresponding type of array ---
\SemanticsRuleRef{LESetArray} for integer-indexed arrays and
\SemanticsRuleRef{LESetEnumArray} for enumeration-indexed arrays.

\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESetArray(\lexpr, \expr) &\\
|\ & \LESetEnumArray(\overtext{\lexpr}{base}, \overtext{\expr}{index}) &\\
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESetArray}
The assignable expressions in
\listingref{semantics-lesetarray} and \listingref{semantics-lesetenumarray}
are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the array access of a left-hand-side expression $\ebase$ by the index $\eindex$, that is, $\LESetArray(\ebase, \eindex)$;
  \item annotating the right-hand-side expression corresponding to $\ebase$ in $\tenv$ yields \\ $(\tbase, \Ignore, \Ignore)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\tbase$ in $\tenv$ yields $\tanonbase$\ProseOrTypeError;
  \item checking that $\tanonbase$ is an array type yields $\True$\ProseOrTypeError;
  \item view $\tanonbase$ as an array type of size $\size$ and element type $\telem$, that is, $\TArray(\size, \telem)$;
  \item annotating the left-hand-side expression $\ebase$ with type $\tbase$ in $\tenv$ yields $(\ebasep, \vsesbase)$\ProseOrTypeError;
  \item applying $\annotatesetarray$ to $(\size, \telem)$, $\vte$, and \\
        $(\ebasep, \vsesbase, \eindex)$ in $\tenv$ yields $(\newle, \vses)$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\ebase)} \typearrow (\tbase, \Ignore, \Ignore) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tanonbase \OrTypeError\\\\
  \checktrans{\astlabel(\tanonbase) = \TArray}{ExpectedArrayType} \typearrow \True \OrTypeError\\\\
  \tanonbase \eqname \TArray(\size, \telem)\\
  \annotatelexpr{\tenv, \ebase, \tbase} \typearrow (\ebasep, \vsesbase) \OrTypeError\\\\
  {
  \begin{array}{r}
    \annotatesetarray(\tenv, (\size, \telem), \vte, (\ebasep, \vsesbase, \eindex)) \typearrow \\
    (\newle, \vses) \OrTypeError
  \end{array}
  }
}{
  \annotatelexpr{\tenv, \overname{\LESetArray(\ebase, \eindex)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}
\CodeSubsection{\LESetArrayBegin}{\LESetArrayEnd}{../Typing.ml}

\TypingRuleDef{AnnotateSetArray}
\hypertarget{def-annotatesetarray}{}
The helper function
\[
\annotatesetarray\left(
  \begin{array}{c}
    \overname{\staticenvs}{\tenv} \aslsep \\
  (\overname{\arrayindex}{\size} \times \overname{\ty}{\telem}) \aslsep \\
  \overname{\ty}{\rhsty} \aslsep \\
  (\overname{\expr}{\ebase} \times \overname{\TSideEffectSet}{\vsesbase} \times \overname{\expr}{\eindex})
\end{array}
\right)
\aslto
(\overname{\lexpr}{\newle} \times \overname{\TSideEffectSet}{\vses})
\]
annotates an array update in the static environment $\tenv$
where $\size$ is the array index,
$\telem$ is the type of array elements,
$\rhsty$ is the type of the right-hand-side expression,
$\ebase$ is the annotated expression for the array base,
$\vsesbase$ is the \sideeffectsetterm\ inferred for $\ebase$,
and $\eindex$ is the index expression.
The result is the annotated assignable expression $\newle$ and
\sideeffectsetterm\ for the annotated expression $\vses$.
\ProseOrTypeError

See \listingref{semantics-lesetarray} and \listingref{semantics-lesetenumarray}
for examples of well-typed assignable array expressions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item determining that $\telem$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the index expression $\eindex$ in $\tenv$ yields \\
        $(\tindexp, \eindexp, \vsesindex)$\ProseOrTypeError;
  \item determining the array length type of $\size$ (via $\typeofarraylength$) yields \\
        $\wantedtindex$;
  \item determining whether $\tindexp$ \typesatisfies\ $\wantedtindex$ in $\tenv$ yields \\
        $\True$\ProseOrTypeError;
  \item define $\vses$ as the union of $\vsesbase$ and $\vsesindex$;
  \item \Proseeqdef{$\newle$}{
    an integer-based array update for $\ebasep$ at index $\eindexp$, that is, $\LESetArray(\ebasep, \eindexp)$,
    if $\size$ is an integer-typed array index, and
    an enumeration-based array update for $\ebasep$ at index $\eindexp$, that is, \\ $\LESetEnumArray(\ebasep, \eindexp)$,
    if $\size$ is an enumeration-typed array index.
    }
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checktypesat(\tenv, \rhsty, \telem) \typearrow \True \OrTypeError\\\\
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp, \vsesindex) \OrTypeError\\\\
  \typeofarraylength(\tenv, \size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesbase \cup \vsesindex \\
  \newleint \eqdef \LESetArray(\ebasep, \eindexp)\\
  \newleenum \eqdef \LESetEnumArray(\ebasep, \eindexp)\\
  {
  \newle \eqdef \begin{cases}
    \newleint & \text{if }\astlabel(\size) = \ArrayLengthExpr\\
    \newleenum & \text{if }\astlabel(\size) = \ArrayLengthEnum\\
  \end{cases}
  }
}{
  {
  \begin{array}{r}
    \annotatesetarray(\tenv, (\size, \telem), \rhsty, (\ebase, \vsesbase, \eindex)) \typearrow \\
    (\newle, \vses)
  \end{array}
  }
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{LESetArray}
\ExampleDef{Integer-indexed Array Update Assignments}
In \listingref{semantics-lesetarray}, the assignment \verb|my_array[[3]] = 53;| binds the third element
of \\
\texttt{my\_array} to the value \texttt{53}.
\ASLListing{Assignment to an integer-indexed array cell}{semantics-lesetarray}{\semanticstests/SemanticsRule.LESetArray.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes an array update expression, $\LESetArray(\rearray, \eindex)$;
  \item evaluating the right-hand-side expression corresponding to $\rearray$ in $\env$
  is \Normal(\rmarray, \envone)\ProseOrAbnormal;
  \item evaluating $\eindex$ in $\envone$ is \Normal(\mindex, \envtwo)\ProseOrAbnormal;
  \item $\mindex$ consists of the native integer $\vindex$ and the execution graph $\vgone$;
  \item $\vindex$ is the native integer for $\vi$;
  \item $\rmarray$ consists of the native vector $\rvarray$ and the execution graph $\vgtwo$;
  \item setting the value $\vv$ at index $\vi$ of $\rvarray$ is the native vector $\vvone$;
  \item $\vmone$ is the pair consisting of $\vvone$ and the parallel composition of $\vgone$ and $\vgtwo$;
  \item the steps so far computed the updated array, but have not assigned it to the variable
  bound to the array given by $\rearray$, which is achieved next.
  Evaluating the left-hand-side expression $\rearray$ in an environment $\envtwo$ with $\vmone$
  is the output configuration $C$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \torexpr(\rearray)} \evalarrow \Normal(\rmarray, \envone) \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \envtwo) \OrAbnormal\\
  \mindex \eqname (\vindex, \vgone)\\
  \vindex \eqname \nvint(\vi)\\
  \rmarray \eqname (\rvarray, \vgtwo)\\
  \setindex(\vi, \vv, \rvarray) \evalarrow \vvone\\
  \vmone \eqdef (\vvone, \vgone \parallelcomp \vgtwo)\\
  \evallexpr{\envtwo, \rearray, \vmone} \evalarrow C
}{
  \evallexpr{\env, \LESetArray(\rearray, \eindex), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLESetArrayBegin}{\EvalLESetArrayEnd}{../Interpreter.ml}

\subsubsection{Comments}
\identr{WHRS}
If the declared type of the \rhsexpression\ of a setter has the structure of a
bitvector or a type with fields, then if a bitslice or field selection is
applied to a setter invocation, then the assignment to that bitslice is
implemented using the following Read-Modify-Write (RMW) behavior:
\begin{itemize}
\item invoking the getter of the same name as the setter, with the same actual
arguments as the setter invocation
\item performing the assignment to the bitslice or field of the result of the
getter invocation
\item invoking the setter to assign the resulting value
\end{itemize}

We note that the index is guaranteed by the typechecker to be within the array bounds
via \TypingRuleRef{LESetArray}.

\SemanticsRuleDef{LESetEnumArray}
\ExampleDef{Enumeration-indexed Array Update Assignments}
In \listingref{semantics-lesetenumarray}, the assignment \verb|my_array[[RED]] = 53;| binds the \verb|RED|
cell of
\texttt{my\_array} to the value \texttt{53}.
\ASLListing{Assignment to an enumeration-indexed array cell}{semantics-lesetenumarray}{\semanticstests/SemanticsRule.LESetEnumArray.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes an array update expression, $\LESetEnumArray(\rearray, \eindex)$;
  \item evaluating the right-hand-side expression corresponding to $\rearray$ in $\env$
  is \Normal(\rmarray, \envone)\ProseOrAbnormal;
  \item evaluating $\eindex$ in $\envone$ is \Normal(\mindex, \envtwo)\ProseOrAbnormal;
  \item $\mindex$ consists of the native value $\vindex$ and the execution graph $\vgone$;
  \item $\vindex$ is the native label for $\vl$;
  \item $\rmarray$ consists of the native value $\rvarray$ and the execution graph $\vgtwo$;
  \item setting the value $\vv$ of field $\vl$ of $\rvarray$ is the native record $\vvone$;
  \item $\vmone$ is the pair consisting of $\vvone$ and the parallel composition of $\vgone$ and $\vgtwo$;
  \item the steps so far computed the updated array, but have not assigned it to the variable
  bound to the array given by $\rearray$, which is achieved next.
  Evaluating the left-hand-side expression $\rearray$ in an environment $\envtwo$ with $\vmone$
  is the output configuration $C$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \torexpr(\rearray)} \evalarrow \Normal(\rmarray, \envone) \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \envtwo) \OrAbnormal\\
  \mindex \eqname (\vindex, \vgone)\\
  \vindex \eqname \nvlabel(\vl)\\
  \rmarray \eqname (\rvarray, \vgtwo)\\
  \setfield(\vl, \vv, \rvarray) \evalarrow \vvone\\
  \vmone \eqdef (\vvone, \vgone \parallelcomp \vgtwo)\\
  \evallexpr{\envtwo, \rearray, \vmone} \evalarrow C
}{
  \evallexpr{\env, \LESetEnumArray(\rearray, \eindex), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLESetEnumArrayBegin}{\EvalLESetEnumArrayEnd}{../Interpreter.ml}

\hypertarget{def-slicelexprterm}{}
\section{Bitvector Slice Assignment Expressions\label{sec:BitvectorSliceAssignmentExpressions}}
\ASLListing{Assignable slice expressions}{semantics-leslice}{\semanticstests/SemanticsRule.LESlice.asl}

\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESlice(\lexpr, \slice^*) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESlice}
\ExampleDef{Typing Assignable Slice Expression}
In \listingref{semantics-leslice}, the assignable slice expression \verb|x[3:0, 7:6]| is well-typed.

In \listingref{typing-leslice-bad}, the assignable slice expression \verb|x[3:0, 3]| is ill-typed,
since the slice \verb|3:0| overlaps with the slice \verb|3| at position $3$.
The specification is ill-typed, even though both slices assign \verb|0| to the bit at position $3$.
\ASLListing{An ill-typed assignable slice expression}{typing-leslice-bad}{\typingtests/TypingRule.LESlice.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the slicing of a left-hand-side expression $\vleone$ by the slices $\slices$, that is, $\LESlice(\vleone, \slices)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\
        $(\vtleone, \Ignore, \Ignore)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vtleone$ in $\tenv$ yields $\tleoneanon$\ProseOrTypeError;
  \item checking that $\tleoneanon$ is a bitvector type yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $(\vletwo, \vsesone)$\ProseOrTypeError;
  \item annotating $\slices$ in $\tenv$ yields $(\slicesannotated, \sesslices)$\ProseOrTypeError;
  \item obtaining the width of the slices $\slicesannotated$ in $\tenv$ and simplifying them yields $\vwidth$;
  \item $\vt$ is the bitvector type of width $\width$ and empty list of bitfields;
  \item checking whether $\vte$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item checking that the slices $\slicesannotated$ are all disjoint yields $\True$\ProseOrTypeError;
  \item checking that $\slicesannotated$ is not empty yields $\True$\ProseTerminateAs{\BadSlices};
  \item $\newle$ is the slicing of $\vletwo$ by $\slicesannotated$, that is, $\LESlice(\vletwo, \slicesannotated)$;
  \item define $\vses$ as the union of $\vsesone$ and $\sesslices$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtleone) \typearrow \tleoneanon \OrTypeError\\\\
  \checktrans{\astlabel(\tleoneanon) = \TBits}{\UnexpectedType} \typearrow \True \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vsesone) \OrTypeError\\
  \annotateslices(\tenv, \slices) \typearrow (\slicesannotated, \sesslices) \OrTypeError\\\\
  \sliceswidth(\tenv, \slicesannotated) \typearrow \widthp\\
  \normalize(\tenv, \widthp) \typearrow \vwidth\\
  \vt \eqdef \TBits(\vwidth, \emptylist)\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \checkdisjointslices(\tenv, \slicesannotated) \typearrow \True \OrTypeError\\\\
  \checktrans{\slicesannotated \neq \emptylist}{\BadSlices} \typearrow \True \OrTypeError\\\\
  \newle \eqdef \LESlice(\vletwo, \slicesannotated)\\
  \vses \eqdef \vsesone \cup \sesslices \\
}{
  \annotatelexpr{\tenv, \overname{\LESlice(\vleone, \slices)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}
\CodeSubsection{\LESliceBegin}{\LESliceEnd}{../Typing.ml}

\TypingRuleDef{CheckDisjointSlices}
\hypertarget{def-checkdisjointslices}{}
The function
\[
\checkdisjointslices(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slices})
\aslto \True \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the list of slices $\slices$ do not overlap in $\tenv$, yielding $\True$.
\ProseOtherwiseTypeError

See \ExampleRef{Typing Assignable Slice Expression}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\disjointslicestopositions$ to $\tenv$,
  $\False$ (indicating that the expressions comprising $\slices$ need not be \staticallyevaluable), and $\slices$ yields a set of positions\ProseOrTypeError.
  \item the result is $\True$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \disjointslicestopositions(\tenv, \False, \slices) \typearrow \positions \OrTypeError
}{
  \checkdisjointslices(\tenv, \slices) \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckDisjointSlicesBegin}{\CheckDisjointSlicesEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{LESlice}
\ExampleDef{Slice Assignments}
In \listingref{semantics-leslice}, the assignment \texttt{x[3:0, 7:6] = '000000';} binds
\texttt{x} to \\ $\nvbitvector(00110000)$
via the rule \SemanticsRuleRef{LESlice}
in the environment where \texttt{x} is bound to $\nvbitvector(11111111)$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes a left-hand-side slicing expression, $\LESlice(\ebv, \slices)$;
  \item evaluating the right-hand-side expression that corresponds to $\ebv$
  (given by applying $\torexpr$ to $\ebv$) in $\env$
    is $\Normal(\mbv,\envone)$\ProseOrAbnormal;
  \item evaluating $\slices$ in $\envone$ is $\Normal(\msliceranges, \envtwo)$\ProseOrAbnormal;
  \item $\msliceranges$ consists of the execution graph $\vgone$ and the list of indices\\
         $\sliceranges$;
  \item applying $\checknonoverlappingslices$ to $\sliceranges$ yields $\True$\ProseOrError;
  \item $\mbv$ consists of the native bitvector $\vbv$ and the execution graph $\vgtwo$;
  \item writing to the bitvector $\vbv$ at indices $\sliceranges$ using the values from $\vv$
  results in the updated native bitvector $\vvone$\ProseOrError;
  \item $\vgthree$ is the parallel composition of $\vgone$, and $\vgtwo$;
  \item $\newmbv$ is a pair consisting of $\vvone$ and the execution graph $\vgthree$;
  \item the steps so far computed the updated bitvector, but have not assigned it to the
  variable bound to the bitvector given by $\ebv$, which is achieved next.
  Evaluating the left-hand-side expression $\ebv$ with
  $\newmbv$ in an environment $\envtwo$ is the output configuration $C$,
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \torexpr(\ebv)} \evalarrow \Normal(\mbv,\envone) \OrAbnormal\\
  \evalslices(\envone, \slices) \evalarrow \Normal(\msliceranges, \envtwo) \OrAbnormal\\
  \msliceranges \eqname (\sliceranges, \vgone)\\
  \mbv \eqname (\vbv, \vgtwo)\\\\
  \checknonoverlappingslices(\sliceranges) \evalarrow \True \OrDynError\\\\
  \writetobitvector(\sliceranges, \vv, \vbv) \evalarrow \vvone \OrDynError\\\\
  \vgthree \eqdef \vgone \parallelcomp \vgtwo\\
  \newmbv \eqdef (\vvone, \vgthree)\\
  \evallexpr{\envtwo, \ebv, \newmbv} \evalarrow C
}{
  \evallexpr{\envtwo, \LESlice(\ebv, \slices), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLESliceBegin}{\EvalLESliceEnd}{../Interpreter.ml}
\subsubsection{Comments}
\identr{WHRS}

If the declared type of the \rhsexpression\ of a setter has the structure of a
bitvector or a type with fields, then if a bitslice or field selection is
applied to a setter invocation, then the assignment to that bitslice is
implemented using the following Read-Modify-Write (RMW) behavior:
\begin{itemize}
\item invoking the getter of the same name as the setter, with the same actual
arguments as the setter invocation
\item performing the assignment to the bitslice or field of the result of the
getter invocation
\item invoking the setter to assign the resulting value
\end{itemize}

\SemanticsRuleDef{CheckNonOverlappingSlices}
\hypertarget{def-checknonoverlappingslices}{}
The helper function
\[
  \checknonoverlappingslices(
    \overname{(\tint\times\tint)^*}{\valueranges}
  ) \evalarrow \{\True\} \cup \overname{\TDynError}{\DynErrorConfig}
\]
checks whether the sets of integers represented by the list of ranges $\valueranges$
overlap, yielding $\True$.
\ProseOtherwiseDynamicError

\ExampleDef{Checking Slices for Overlaps}
In \listingref{semantics-checknonoverlappingslices},
the slices \verb|N-1:N-2| and \verb|0| do not overlap, and $\checknonoverlappingslices$
yields $\True$.
\ASLListing{Non-overlapping slices}{semantics-checknonoverlappingslices}{\semanticstests/SemanticsRule.CheckNonOverlappingSlices.asl}

In \listingref{semantics-checknonoverlappingslices-bad},
the slices \verb|N-1:N-2| and \verb|0| overlap, and $\checknonoverlappingslices$
yields a \dynamicerrorterm, even though the assignment \verb|y[N-1:N-2, 0] = '111';|
writes \verb|0| to the common position $0$.
\ASLListing{Overlapping slices}{semantics-checknonoverlappingslices-bad}{\semanticstests/SemanticsRule.CheckNonOverlappingSlices.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item view $\valueranges$ as the list $\vrange_{1..k}$;
  \item for every pair of indices $\vi$ and $\vj$ such that $1 \leq \vi < \vj \leq k$,
        applying \\
        $\checktworangesnonoverlapping$ to $\vrange_\vi$ and $\vrange_\vj$
        yields $\True$\ProseOrError;
  \item the result is $\True$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \begin{array}{r}
 1 \leq \vi < \vj \leq k:
 \checktworangesnonoverlapping(\vrange_\vi, \vrange_\vj) \evalarrow \\
 \True \OrDynError
    \end{array}
  }
}{
  \checknonoverlappingslices(\overname{\vrange_{1,,k}}{\valueranges}) \evalarrow \True
}
\end{mathpar}

\SemanticsRuleDef{CheckTwoRangesNonOverlapping}
\hypertarget{def-checktworangesnonoverlapping}{}
The helper function
\[
\begin{array}{r}
  \checktworangesnonoverlapping(
    (\overname{\tint}{\vsone}\times\overname{\tint}{\vlone}) \aslsep
    (\overname{\tint}{\vstwo}\times\overname{\tint}{\vltwo}) \aslsep
  ) \evalarrow \\
  \{\True\} \cup \overname{\TDynError}{\DynErrorConfig}
\end{array}
\]
checks whether two sets of integers represented by the
ranges $(\vsone, \vlone)$ and $(\vstwo, \vltwo)$ do not intersect, yielding $\True$.
\ProseOrError

See \ExampleRef{Checking Slices for Overlaps}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item evaluating $\PLUS$ for $\vsone$ and $\vlone$ via $\binoprel$ yields $\vsonelone$;
  \item evaluating $\LEQ$ for $\vsonelone$ and $\vstwo$ yields $\vsonelonestwo$;
  \item evaluating $\PLUS$ for $\vstwo$ and $\vltwo$ yields $\vstwoltwo$;
  \item evaluating $\LEQ$ for $\vstwoltwo$ and $\vsone$ yields $\vstwoltwosone$;
  \item evaluating $\BOR$ for $\vsonelonestwo$ and $\vstwoltwosone$ yields $\nvbool(\vb)$;
  \item checking whether $\vb$ is $\True$ yields $\True$\ProseTerminateAs{\OverlappingSliceAssignment};
  \item the result is $\True$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \binoprel(\PLUS, \vsone, \vlone) \evalarrow \vsonelone\\
  \binoprel(\LEQ, \vsonelone, \vstwo) \evalarrow \vsonelonestwo\\
  \binoprel(\PLUS, \vstwo, \vltwo) \evalarrow \vstwoltwo\\
  \binoprel(\LEQ, \vstwoltwo, \vsone) \evalarrow \vstwoltwosone\\
  \binoprel(\BOR, \vsonelonestwo, \vstwoltwosone) \evalarrow \nvbool(\vb)\\
  \checktrans{\vb}{\OverlappingSliceAssignment} \checktransarrow \True\OrDynError
}{
  \checktworangesnonoverlapping((\vsone, \vlone), (\vstwo, \vltwo)) \evalarrow \True
}
\end{mathpar}

\hypertarget{def-setfieldlexprterm}{}
\section{Structured Type Field Assignment Expressions\label{sec:StructuredTypeFieldAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESetField(\lexpr, \identifier) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESetBadField}
\ExampleDef{Assigning a Field in an Inappropriate Type}
In \listingref{typing-lesetbadfield}, the statement \verb|x.RED = 42;| is ill-typed,
since \verb|x| is not a \bitvectortypeterm{} nor a \structuredtype.
\ASLListing{Assigning a field in an inappropriate type}{typing-lesetbadfield}{\typingtests/TypingRule.LESetBadField.asl}

See \RequirementRef{TupleImmutability} for an example of assigning to a tuple type.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $(\vletwo, \vses)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vtleone$ in $\tenv$ yields a type $\tleoneanon$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{tuple}
    \begin{itemize}
      \item $\vt$ is a \tupletypeterm;
      \item the result is an error indicating assigning to immutable types is illegal ($\AssignmentToImmutable$).
    \end{itemize}

    \item \AllApplyCase{structured}
    \begin{itemize}
      \item $\vt$ is neither a \tupletypeterm{}, nor a \structuredtype, nor a \bitvectortypeterm;
      \item the result is an error indicating that the type of $\vle$ conflicts with the requirements
            of a field access expression ($\UnexpectedType$).
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[tuple]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtleone) \typearrow \tleoneanon \OrTypeError\\\\
  \commonprefixline\\\\
  \astlabel(\tleoneanon) = \TTuple
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{\AssignmentToImmutable}
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtleone) \typearrow \tleoneanon \OrTypeError\\\\
  \commonprefixline\\\\
  \astlabel(\tleoneanon) \not\in \{\TTuple, \TException, \TRecord, \TCollection, \TBits\}
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\LESetBadFieldBegin}{\LESetBadFieldEnd}{../Typing.ml}

\TypingRuleDef{LESetStructuredField}
\ExampleDef{Typing a Structured Type Field Assignment}
In \listingref{typing-lestructuredfield}, all field assignment statements
are well-typed.
\ASLListing{Typing a structured type field assignment}{typing-lestructuredfield}{\typingtests/TypingRule.LESetStructuredField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the access to the field named \texttt{field} in $\vleone$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression  $\vleone$ with type $\vtleone$ in $\tenv$ yields \\ $(\vletwo, \vses)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vtleone$ in $\tenv$ yields a record
    or exception type with fields $\fields$\ProseOrTypeError;
  \item checking that there exists a type associated with the field $\field$ in $\fields$ $\True$ \ProseTerminateAs{\BadField};
  \item the type associated with the field $\field$ in $\fields$ is $\vt$;
  \item determining whether $\vte$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item $\newle$ is the access to the field $\field$ in $\vletwo$, that is, $\LESetField(\vletwo, \field)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtleone) \typearrow L(\fields) \OrTypeError\\\\
  L \in \{\TException, \TRecord\}\\
  \assocopt(\fields, \field) \typearrow \tyopt\\
  \checktrans{\tyopt \neq \None}{\BadField} \checktransarrow \True \OrTypeError\\\\
  \tyopt \eqname \langle\vt\rangle\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \newle \eqdef \LESetField(\vletwo, \field)
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\CodeSubsection{\LESetStructuredFieldBegin}{\LESetStructuredFieldEnd}{../Typing.ml}

\TypingRuleDef{LESetCollectionField}

\ExampleDef{Typing Collection Field Assignable Expressions}
All of the collection field assignable expressions in
\listingref{typing-lesetcollectionfields} are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the access to the field named \texttt{field} in
    $\vleone$;
  \item annotating the right-hand-side expression corresponding to $\vleone$
    in $\tenv$ yields \\ $(\vtleone, \Ignore, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression  $\vleone$ with type
    $\vtleone$ in $\tenv$ yields \\ $(\vletwo, \vses)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vtleone$ in $\tenv$ yields a
    collection type with fields $\fields$\ProseOrTypeError;
  \item $\vletwo$ denotes a left-hand-side variable expression for $\vbase$,
    that is, $\LEVar(\vbase)$;
  \item checking that there exists a type associated with the field $\field$
    in $\fields$ $\True$ \ProseTerminateAs{\BadField};
  \item the type associated with the field $\field$ in $\fields$ is $\vt$;
  \item determining whether $\vte$ \typesatisfies\ $\vt$ yields
    $\True$\ProseOrTypeError;
  \item $\newle$ is the access to the field $\field$ in $\vletwo$, that is,
    $\LESetCollectionFields(\vbase, [\field])$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtleone) \typearrow \TCollection(\fields) \OrTypeError\\\\
  \assocopt(\fields, \field) \typearrow \tyopt\\
  \checktrans{\tyopt \neq \None}{\BadField} \checktransarrow \True \OrTypeError\\\\
  \tyopt \eqname \langle\vt\rangle\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \newle \eqdef \LESetCollectionFields(\vbase, [\field])
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\CodeSubsection{\LESetStructuredFieldBegin}{\LESetStructuredFieldEnd}{../Typing.ml}

\section{Structured Type Multi-field Assignment Expressions\label{sec:StructuredTypeMultiFieldAssignmentExpressions}}

\ASLListing{Multi-field assignment expression}{lesetfields}{\typingtests/TypingRule.LESetFields.asl}

\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESetFields(\lexpr, \identifier^*) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESetFields}
All multi-field assignment expressions in \listingref{lesetfields} are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ is an assignable expression for assigning the list of fields $\vlefields$ of the base
        expression $\lebase$;
  \item \Proseannotateexpr{$\tenv$}{the right-hand side expression corresponding to \\ $\lebaseannot$}{$(\tbase, \Ignore, \Ignore)$}\ProseOrTypeError;
  \item \Proseannotatelexpr{$\tenv$}{$\lebase$}{$\tbase$}{$(\lebaseannot, \vsesbase)$}\ProseOrTypeError;
  \item \Prosemakeanonymous{$\tenv$}{$\tbase$}{\\ $\tbaseanon$}\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{bits}
    \begin{itemize}
      \item $\tanonbase$ is a bitvector type with list of bitfields $\vbitfields$;
      \item applying $\findbitfieldsslices$ to $\name$ and $\vbitfields$, for every $\name$ in $\vlefields$, yields $\vslices_\name$\ProseOrTypeError;
      \item define $\vleslice$ as the \ProseLESlice\ for the base expression $\lebaseannot$ and list of slices formed by concatenating all
            slice lists $\vslices_\name$, for every $\name$ in $\vlefields$;
      \item \Proseannotatelexpr{$\tenv$}{$\vleslice$}{$\vte$}{$(\newle, \vses)$}\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{record}
    \begin{itemize}
      \item $\tanonbase$ is a record type with list of fields $\vbasefields$;
      \item applying $\foldbitvectorfields$ to $\vlefields$ and $\vbasefields$ in $\tenv$ yields $(\vlength, \vslices)$ \ProseOrTypeError;
      \item \Proseeqdef{$\vtlhs$}{the bitvector type of length $\vlength$ and no bitfields, that is, $\TBits(\ELInt{\vlength}, \emptylist)$};
      \item checking that $\vte$ \typesatisfies\ $\vtlhs$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item define $\newle$ as the assignable expression of the list of fields $\vlefields$ to the base expression $\lebase$, that is,
            $\LESetFields(\lebase, \vlefields)$;
      \item \Proseeqdef{$\vses$}{$\vsesbase$}.
    \end{itemize}

    \item \AllApplyCase{collection}
    \begin{itemize}
      \item $\tanonbase$ is a collection type with list of fields
        $\vbasefields$;
      \item $\lebase$ denotes a left-hand-side variable expression for
        $\vbase$, that is, $\LEVar(\vbase)$;
      \item applying $\foldbitvectorfields$ to $\vlefields$ and $\vbasefields$
        in $\tenv$ yields $(\vlength, \vslices)$ \ProseOrTypeError;
      \item \Proseeqdef{$\vtlhs$}{the bitvector type of length $\vlength$ and
        no bitfields, that is, $\TBits(\ELInt{\vlength}, \emptylist)$};
      \item checking that $\vte$ \typesatisfies\ $\vtlhs$ in $\tenv$ yields
        $\True$\ProseOrTypeError;
      \item define $\newle$ as the assignable expression of the list of fields
        $\vlefields$ to the collection base expression $\vbase$, that is, \\
        $\LESetCollectionFields(\vbase, \vlefields)$;
      \item \Proseeqdef{$\vses$}{$\vsesbase$}.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item $\tanonbase$ is neither a bitvector type nor a record type;
      \item the result is a \typingerrorterm{} indicating that the type of the left-hand-side expression is expected to be
            either a bitvector type or a record type.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[bits]{
  \annotateexpr{\tenv, \torexpr(\lebase)} \typearrow (\tbase, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \lebase, \tbase} \typearrow (\lebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tbaseanon \OrTypeError\\\\
  \commonprefixline\\\\
  \tbaseanon = \TBits(\Ignore, \vbitfields)\\
  \name\in\vlefields: \findbitfieldsslices(\name, \vbitfields) \typearrow \vslices_\name \OrTypeError\\\\
  \vleslice \eqdef \LESlice(\lebaseannot, [\name\in\vlefields: \vslices_\name])\\
  \annotatelexpr{\tenv, \vleslice, \vte} \typearrow (\newle, \vses) \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetFields(\lebase, \vlefields)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\begin{mathpar}
  \inferrule[record]{
  \annotateexpr{\tenv, \torexpr(\lebase)} \typearrow (\tbase, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \lebase, \tbase} \typearrow (\lebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tbaseanon \OrTypeError\\\\
  \commonprefixline\\\\
  \tbaseanon = \TRecord(\vbasefields)\\
  \foldbitvectorfields(\tenv, \vbasefields, \vlefields) \typearrow (\vlength, \vslices) \OrTypeError\\\\
  \vtlhs \eqdef \TBits(\ELInt{\vlength}, \emptylist)\\
  \checktypesat(\tenv, \vte, \vtlhs) \typearrow \True \OrTypeError
}{
  {
   \begin{array}{r}
    \annotatelexpr{\tenv, \overname{\LESetFields(\lebase, \vlefields)}{\vle}, \vte} \typearrow\\
    (\overname{\LESetFields(\lebaseannot, \vlefields, \vslices)}{\newle}, \overname{\vsesbase}{\vses})
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[collection]{
  \annotateexpr{\tenv, \torexpr(\lebase)} \typearrow (\tbase, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \lebase, \tbase} \typearrow (\lebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tbaseanon \OrTypeError\\\\
  \commonprefixline\\\\
  \tbaseanon = \TCollection(\vbasefields)\\
  \lebase = \LEVar(\vbase) \\
  \foldbitvectorfields(\tenv, \vbasefields, \vlefields) \typearrow (\vlength, \vslices) \OrTypeError\\\\
  \vtlhs \eqdef \TBits(\ELInt{\vlength}, \emptylist)\\
  \checktypesat(\tenv, \vte, \vtlhs) \typearrow \True \OrTypeError
}{
  {
   \begin{array}{r}
    \annotatelexpr{\tenv, \overname{\LESetFields(\lebase, \vlefields)}{\vle}, \vte} \typearrow\\
    (\overname{\LESetCollectionFields(\vbase, \vlefields, \vslices)}{\newle}, \overname{\vsesbase}{\vses})
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[error]{
  \annotateexpr{\tenv, \torexpr(\lebase)} \typearrow (\tbase, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \lebase, \tbase} \typearrow (\lebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tbaseanon \OrTypeError\\\\
  \commonprefixline\\\\
  \checktrans{\astlabel(\tbaseanon) \not\in \{\TBits, \TRecord, \TCollection\}}{\UnexpectedType} \typearrow \True \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetFields(\lebase, \vlefields)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}
\CodeSubsection{\LESetFieldsBegin}{\LESetFieldsEnd}{../Typing.ml}

\TypingRuleDef{FoldBitvectorFields}
\hypertarget{def-foldbitvectorfields}{}
The helper function
\[
\foldbitvectorfields(\overname{\staticenvs}{\tenv} \aslsep \overname{\Field^*}{\vbasefields} \aslsep \overname{\bitfield^*}{\vlefields})
\aslto (\overname{\N}\vlength \times \overname{(\N \times N)^*}{\vslices})
\]
accepts a static environment $\tenv$, the list of all fields $\vbasefields$ for a \recordtypeterm{},
and a list of fields $\vlefields$ that are the subset of $\vbasefields$ about to be assigned to,
and yields the total width across $\vlefields$ and the ranges corresponding to $\vlefields$
in terms of pairs where the first component is the start position and the second component is
the width of the field.

\ExampleDef{Obtaining the Total Width and Ranges of Bitvector-typed Fields}
In \listingref{lesetfields}, applying $\foldbitvectorfields$ to the list of fields
[\verb|data, time, status|] in the statement \verb|x.[status, time, data] = '1' :: Zeros{16} :: Ones{8};|,
yields the total width $25$ and ranges
$(17, 8)$ for \verb|data|, $(1, 16)$ for \verb|time|, and $(0, 1)$ for \verb|status|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vlefields$ is empty;
    \item \Proseeqdef{$\vlength$}{$0$};
    \item \Proseeqdef{$\vslices$}{the empty list}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vlefields$ is the list with prefix $\vlefieldsone$ (the elements excluding the last one) and last element $\vfield$;
    \item applying $\foldbitvectorfields$ to $\vbasefields$ and $\vlefieldsone$ in $\tenv$ yields $(\vstart, \vslicesone)$\ProseOrTypeError;
    \item applying $\assocopt$ to $\vbasefields$ and $\vfield$ yields $\tyopt$;
    \item checking that $\tyopt$ is different to $\None$ yields $\True$\ProseTerminateAs{\BadField};
    \item view $\tyopt$ as $\langle\vtfield\rangle$;
    \item applying $\getbitvectorconstwidth$ to $\vtfield$ in $\tenv$ yields $\vfieldwidth$\ProseOrTypeError;
    \item \Proseeqdef{$\vlength$}{$\vstart + \vfieldwidth$};
    \item \Proseeqdef{$\vslices$}{the list with \head\ $(\vstart, \vfieldwidth)$ and \tail\ $\vslicesone$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \foldbitvectorfields(\tenv, \vbasefields, \overname{\emptylist}{\vlefields}) \typearrow (\overname{0}{\vlength}, \overname{\emptylist}{\vslices})
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \foldbitvectorfields(\tenv, \vbasefields, \vlefieldsone) \typearrow (\vstart, \vslicesone)\OrTypeError\\\\
  \assocopt(\vbasefields, \vfield) \typearrow \tyopt\\
  \checktrans{\tyopt \neq \None}{\BadField} \typearrow \True \OrTypeError\\\\
  \tyoptp \eqname \langle\vtfield\rangle\\
  \getbitvectorconstwidth(\tenv, \vtfield) \typearrow \vfieldwidth \OrTypeError\\\\
}{
  {
  \begin{array}{r}
  \foldbitvectorfields(\tenv, \vbasefields, \overname{\vlefieldsone \concat [\vfield]}{\vlefields}) \typearrow\\
  (\overname{\vstart + \vfieldwidth}{\vlength}, \overname{[(\vstart, \vfieldwidth)] \concat \vslicesone}{\vslices})
  \end{array}
  }
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{LESetFields}
The multi-field assignments in \listingref{lesetfields} evaluate without yielding a \dynamicerrorterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ is an expression for assigning each of the fields in $\fields$
    of the record expression $\vlerecord$ with the corresponding slices given
    in $\vslices$ from the bitvector value $\vv$ %
    (the rule \TypingRuleRef{LESetFields} ensures that the length of $\fields$
    and $\vslices$ is the same);
  \item \Proseevalexpr{$\env$}{%
    right-hand-side expression corresponding to $\vlerecord$}{%
    $((\vrecord, \vgone), \envone)$}\ProseOrAbnormal;
  \item applying $\assignbitvectorfields$ to $\vv$, $\vrecord$,
    $\fields$, and $\vslices$, yields \\
    $\vvtwo$\ProseOrError;
  \item \Proseeqdef{\vmtwo}{%
    the pair consisting of $\vvtwo$ and the parallel composition of $\vg$ and
    $\vgone$}
  \item \Proseevallexpr{$\envone$}{$\vlerecord$}{$\vmtwo$}{$C$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \torexpr(\vlerecord), \vrmrecordnew} \evalarrow ((\vrecord, \vgone), \envone) \OrAbnormal\\\\
  \assignbitvectorfields(\vv, \vrecord, \fields, \vslices) \evalarrow \vvtwo \OrDynError\\\\
  \vmtwo \eqdef (\vvtwo, \vg \parallelcomp \vgone) \\
  \evallexpr{\envone, \vlerecord, \vmtwo} \evalarrow C
}{
  \evallexpr{\env, \overname{\LESetFields(\vlerecord, \fields, \vslices)}{\vle}, (\vv,\vg)} \evalarrow C
}
\end{mathpar}

\SemanticsRuleDef{AssignBitvectorFields}
\hypertarget{def-assignbitvectorfields}{}
The helper function
\[
  \assignbitvectorfields(
    \overname{\tbitvector}{\vbitvector} \aslsep
    \overname{\trecord}{\record} \aslsep
    \overname{\identifier^*}{\fields} \aslsep
    \overname{{(\N\times\N)}^*}{\vslices}) \aslto
    \overname{\trecord}{\vres}
\]
updates the list of fields $\fields$ of $\record$ with the slices given by
$\vslices$ of $\vbitvector$, yielding the \nativevalue\ $\vres$.

\ExampleDef{Assignment Bitvector-typed Fields}
The statement \verb|y.[data, time, status] = Ones{8} :: Zeros{16} :: '1';|
in \listingref{lesetfields}
assigns the fields \verb|data|, \verb|time|, and \verb|status|,
yielding \\
$\nvbitvector('11111111 0000000000000000 1')$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\fields$ and $\vslices$ are both empty lists;
    \item \Proseeqdef{$\vres$}{$\record$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\fields$ is a list with \head\ $\fieldname$ and \tail\ $\fieldsone$;
    \item $\vslices$ is a list with \head\ $(\vione, \vitwo)$ and \tail\ $\vslicesone$;
    \item \Proseeqdef{$\vslice$}{the singleton list comprised of the pair of native integer values for $\vione$ and $\vitwo$};
    \item applying $\readfrombitvector$ to $\vbitvector$ and $\vslice$ yields $\recordslices$\ProseOrError;
    \item applying $\setfield$ to $\fieldname$, $\recordslices$, and $\record$ yields \\ $\recordone$;
    \item applying $\assignbitvectorfields$ to $\vbitvector$, $\recordone$, $\fieldsone$, and $\vslicesone$, yields $\vres$\ProseOrError.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \assignbitvectorfields(\vbitvector, \record, \overname{\emptylist}{\fields}, \overname{\emptylist}{\vslices}) \evalarrow
  \overname{\record}{\vres}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vslice \eqdef [(\nvint(\vione), \nvint(\vitwo))]\\
  \readfrombitvector(\vbitvector, \vslice) \evalarrow \recordslices \OrDynError\\\\
  \setfield(\fieldname, \recordslices, \record) \evalarrow \recordone\\
  \assignbitvectorfields(\vbitvector, \recordone, \fieldsone, \vslicesone) \evalarrow \vres \OrDynError
}{
  {
    \begin{array}{r}
  \assignbitvectorfields(
    \vbitvector,
    \record,
    \overname{[\fieldname]\concat\fieldsone}{\fields},
    \overname{[(\vione, \vitwo)]\concat\vslicesone}{\vslices}) \evalarrow \\
    \vres
    \end{array}
  }
}
\end{mathpar}

\SemanticsRuleDef{LESetCollectionFields}

\ExampleDef{Typing Collection Fields Assignable Expressions}
All of the collection field assignable expressions in
\listingref{typing-lesetcollectionfields} are well-typed.
\ASLListing{Typing collection fields assignment expressions}{typing-lesetcollectionfields}{\typingtests/TypingRule.LESetCollectionFields.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ is an expression for assigning each of the fields in $\fields$
    of the collection global storage element $\vbase$ with the corresponding
    slices given in $\vslices$ from the bitvector value $\vv$ (the rule
    \TypingRuleRef{LESetFields} ensures that the length of $\fields$ and
    $\vslices$ is the same);
  \item view $\env$ as an environment where $\tenv$ is the static environment
    and $\denv$ is the dynamic environment;
  \item $\vbase$ is bound in the global dynamic environment ($G^\denv.\storage$);
  \item $\record$ is the value of $\vbase$ in the global component of $\env$ ;
  \item applying $\assignbitvectorfields$ to $\vv$, $\record$,
    $\fields$, and $\vslices$, yields $\recordone$\ProseOrError;
  \item \Proseeqdef{$\vgzero$}{the graph containing a Write Effect for each
    $\fieldname$ in $\fields$};
  \item $\newenv$ is $\env$ where $\vbase$ is bound to $\recordone$ in the $\storage$ map
    of the global dynamic environment $G^\denv$.
  \item $\newg$ is the ordered composition with the $\asldata$ edge of $\vg$
    and $\vgzero$;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqname (\tenv, \denv)\\
  \vbase \in \dom(G^\denv)\\
  \record \eqdef G^\denv[\vbase]\\
  \assignbitvectorfields(\vv, \record, \fields, \vslices) \evalarrow \recordone \OrDynError\\\\
  \vgzero \eqdef \{\fieldname \in \fieldnames: \WriteEffect(\vbase + \ttdotstr + \fieldname)\}\\
  \newenv \eqdef (\tenv, (G^\denv[\vx \mapsto \recordone], L^\denv))\\
  \newg \eqdef \ordered{\vg}{\asldata}{\vgzero} \\
}{
  \evallexpr{\env, \overname{\LESetCollectionFields(\vbase, \fields, \vslices)}{\vle}, (\vv,\vg)} \evalarrow \Normal(\newg,\newenv)
}
\end{mathpar}

\section{Bitfield Assignable Expressions\label{sec:BitfieldAssignableExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESlice(\lexpr, \slice^*) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESetBitField}

\ExampleDef{Typing Bitfield Assignable Expressions}
All of the bitfield assignable expressions in \listingref{typing-lesetfield}
are well-typed.
\ASLListing{Typing bitfield assignment expressions}{typing-lesetfield}{\typingtests/TypingRule.LESetField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $(\vletwo, \vses)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vtleone$ in $\tenv$ yields a bitvector type with bitfields $\bitfields$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{error\_missing\_field}
    \begin{itemize}
      \item applying $\findbitfieldopt$ to $\bitfields$ and $\vfield$ yields $\None$, meaning the field is not declared
            in $\vtleone$;
      \item the result is a \typingerrorterm{} $\BadField$.
    \end{itemize}

    \item \AllApplyCase{field\_simple}
    \begin{itemize}
      \item applying $\findbitfieldopt$ to $\bitfields$ and $\vfield$ yields a bitfield with corresponding slices $\slices$,
            that is, $\BitFieldSimple(\Ignore, \slices)$;
      \item $\vw$ is the width of $\slices$;
      \item $\vt$ is defined as the bitvector type of width $\vw$ and empty list of bitfields, that is, $\TBits(\vw, \emptylist)$;
      \item checking whether$\vte$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item $\vletwo$ is defined as the slicing of $\vleone$ by $\slices$, that is, \\ $\LESlice(\vleone, \slices)$;
      \item annotating the left-hand-side expression $\vletwo$ in $\tenv$ yields \\ $(\newle, \vses)$\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{field\_nested}
    \begin{itemize}
      \item applying $\findbitfieldopt$ to $\bitfields$ and $\vfield$ yields a nested bitfield with corresponding
            slices $\slices$ and list of bitfields $\bitfieldsp$, that is, \\ $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
      \item $\vw$ is the width of $\slices$;
      \item $\vt$ is defined as the bitvector type of width $\vw$ and list of bitfields $\bitfieldsp$, that is, $\TBits(\vw, \bitfieldsp)$;
      \item checking whether$\vte$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item $\vlethree$ is defined as the slicing of $\vleone$ by $\slices$, that is, \\ $\LESlice(\vleone, \slices)$;
      \item annotating the left-hand-side expression $\vlethree$ in $\tenv$ yields \\ $(\newle, \vses)$\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{field\_typed}
    \begin{itemize}
      \item applying $\findbitfieldopt$ to $\bitfields$ and $\vfield$ yields a typed bitfield with corresponding
            slices $\slices$ and a type $\vt$, that is, \\ $\BitFieldType(\Ignore, \vslices, \vt)$;
      \item $\vw$ is the width of $\slices$;
      \item $\vtp$ is defined as the bitvector type of width $\vw$ and an empty list of bitfields, that is, $\TBits(\vw , \emptylist)$;
      \item checking whether $\vtp$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item checking whether $\vte$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item $\vletwo$ is defined as the slicing of $\vleone$ by $\slices$, that is, \\ $\LESlice(\vleone, \slices)$;
      \item annotating the left-hand-side expression $\vletwo$ in $\tenv$ yields \\ $(\newle, \vses)$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[error\_missing\_field]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \commonprefixline\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \None\
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}

\begin{mathpar}
\inferrule[field\_simple]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \commonprefixline\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \langle \BitFieldSimple(\Ignore, \slices) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vt \eqdef \TBits(\vw, \emptylist)\\\\
  \commonsuffixline\\\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow (\newle, \vses) \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[field\_nested]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \commonprefixline\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \langle \BitFieldNested(\Ignore, \slices, \bitfieldsp) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vt \eqdef \TBits(\vw, \bitfieldsp)\\\\
  \commonsuffixline\\\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow (\newle, \vses) \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[field\_typed]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \commonprefixline\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \langle \BitFieldType(\Ignore, \vslices, \vt) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vtp \eqdef \TBits(\vw , \emptylist)\\
  \checktypesat(\tenv, \vtp, \vt) \typearrow \True \OrTypeError\\\\
  \commonsuffixline\\\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow (\newle, \vses) \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\subsection{Semantics}
The semantics for assigning to individual bitvector bitfields is covered by \SemanticsRuleRef{LESlice}
as the type system transforms the \untypedast\ for assigning to an individual bitfield into an $\LESlice$ \typedast.

\SemanticsRuleDef{LESetField}

\ExampleDef{Field Assignment}
In \listingref{semantics-lesetfield}, the assignment
\verb|my_record.a = 42;| binds \verb|my_record| to \verb|{a: 42, b: 100}|
in the environment where \verb|my_record| is bound to \verb|{a: 3, b: 100}|.

\ASLListing{Assignment to a field}{semantics-lesetfield}{\semanticstests/SemanticsRule.LESetField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes a field update expression, $\LESetField(\rerecord, \fieldname)$;
  \item evaluating the right-hand-side expression corresponding to $\rerecord$
  in $\env$ is $\Normal(\rmrecord, \envone)$\ProseOrAbnormal;
  \item $\rmrecord$ is a pair consisting of the native record $\rvrecord$ and
  the execution graph $\vgone$;
  \item setting the field $\fieldname$ in the native record $\rvrecord$ to $\vv$
  is the updated native record $\vvone$;
  \item $\vmone$ is the pair consisting of the native vector $\vvone$ and the
  execution graph that is, the parallel composition of $\vg$ and $\vgone$;
  \item the steps so far computed the updated record, but have not assigned it to
  the variable holding the record given by $\record$, which is achieved next.
  Evaluating the left-hand-side expression $\rerecord$ in an environment $\envone$ with $\vmone$
  is the output configuration $C$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
    \evalexpr{\env, \torexpr(\rerecord)} \evalarrow \Normal(\rmrecord, \envone) \OrAbnormal\\
    \rmrecord \eqname (\rvrecord, \vgone)\\
    \setfield(\fieldname, \vv, \rvrecord) \evalarrow \vvone\\
    \vmone \eqdef (\vvone, \vg \parallelcomp \vgone)\\
    \evallexpr{\env1, \rerecord, \vmone} \evalarrow C
}{
    \evallexpr{\env, \LESetField(\rerecord, \fieldname), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLESetFieldBegin}{\EvalLESetFieldEnd}{../Interpreter.ml}

\subsubsection{Comments}
We note that the typechecker guarantees that $\fieldname$ exists in the record given by $\record$
via \TypingRuleRef{LESetStructuredField}.

\identr{WHRS}
If the declared type of the \rhsexpression\ of a setter has the structure of a
bitvector or a type with fields, then if a bitslice or field selection is
applied to a setter invocation, then the assignment to that bitslice is
implemented using the following Read-Modify-Write (RMW) behavior:
\begin{itemize}
    \item invoking the getter of the same name as the setter, with the same actual
    arguments as the setter invocation
    \item performing the assignment to the bitslice or field of the result of the
    getter invocation
    \item invoking the setter to assign the resulting value
\end{itemize}
