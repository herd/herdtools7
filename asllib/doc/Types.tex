\chapter{Types\label{chap:Types}}

\identi{BYVL}
ASL allows specifying types for storage elements such as variables, constants, function arguments,
and they are used to define the set of their allowed values.
%
The type system infers types for expressions, which are represented by \typedast{} nodes derived
from the non-terminal $\ty$.

\ExampleDef{Types}
\listingref{Types} shows some examples of types.
\ASLListing{Examples of Types}{Types}{\definitiontests/Types.asl}

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Types} defines the formal relations for types;
  \item \AbstractSyntaxRef{Types} defines how the abstract syntax nodes for types
    are generated;
  \item \secref{IntegerTypes} defines the \integertypeterm{};
  \item \secref{RealType} defines the \realtypeterm{};
  \item \secref{StringType} defines the \stringtypeterm{};
  \item \secref{BooleanType} defines the \booleantypeterm{};
  \item \secref{BitvectorTypes} defines the \bitvectortypeterm{};
  \item \secref{TupleTypes} defines \Tupletypesterm{};
  \item \secref{ParenthesizedTypes} defines parenthesized types;
  \item \secref{EnumerationTypes} defines \Enumerationtypesterm{};
  \item \secref{ArrayTypes} defines array types;
  \item \secref{RecordTypes} defines record types;
  \item \secref{ExceptionTypes} defines exception types;
  \item \secref{CollectionTypes} defines collection types;
  \item \secref{NamedTypes} defines named types;
  \item \secref{DeclaredTypes} defines \emph{declared types} and restrictions over them;
  \item \secref{DomainOfValuesForTypes} defines the semantics of types by associating a value to each type;
  \item \secref{BasicTypeAttributes} assigns basic properties to types, which are useful
        in classifying them;
  \item \secref{RelationsOnTypes} defines relations on types that are needed to typecheck
        expressions and statements; and
  \item \secref{BaseValues} defines how to generate a \emph{base value} --- an expression
        to initialize a storage element of a given type for which no initializing
        expression is given.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Types}
\paragraph{Syntax:} \Anonymoustypes{} are grammatically derived from $\Nty$
and types that must be declared and named are grammatically derived from $\Ntydecl$;

\paragraph{Abstract Syntax:} Types are derived in the abstract syntax from $\ty$,
  and generated by $\buildty$, $\buildtydecl$, and $\buildtyorcollection$.

\paragraph{Typing:}
\RenderRelation{annotate_type}
\BackupOriginalRelation{
The function
\[
  \annotatetype(\overname{\Bool}{\vdecl} \aslsep \overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty})
  \aslto (\overname{\ty}{\newty} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\typeerror}{\TypeErrorConfig}
\]
typechecks a type $\tty$ in a \staticenvironmentterm{} $\tenv$,
resulting in a \typedast\ $\newty$ and a \sideeffectsetterm\ $\vses$.
The flag $\decl$ indicates whether $\tty$ is a type currently being declared or not,
and makes a difference only when $\tty$ is an \enumerationtypeterm{} or a \structuredtypeterm.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\paragraph{Semantics:} Types are not evaluated dynamically.
  However, the dynamic semantics of types is given by their \emph{domain of values},
  which is defined in \secref{DomainOfValuesForTypes}.
  In addition, the dynamic semantics of an \atcexpressionterm{}
  checks whether a \nativevalueterm{} belongs to the domain of values of a given type
  (see \SemanticsRuleRef{ATC} and \SemanticsRuleRef{IsValOfType}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\AbstractSyntaxDef{Types}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-ty}{}
The function
\[
  \buildty(\overname{\parsenode{\Nty}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms an anonymous type parse node $\vparsednode$ into the corresponding AST node $\vastnode$.
\ProseOtherwiseBuildError
} % END_OF_IGNORED_RELATION


We define $\buildty$ per type in the following sections.

\MarkedIgnoredRelationDefinition{
\hypertarget{build-tydecl}{}
The function
\[
  \buildtydecl(\overname{\parsenode{\Ntydecl}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms a \namedtype\ parse node $\vparsednode$ into an AST node $\vastnode$.
\ProseOtherwiseBuildError
} % END_OF_IGNORED_RELATION


We define $\buildtydecl$ per the corresponding type in the following sections.

\MarkedIgnoredRelationDefinition{
\hypertarget{build-tyorcollection}{}
The function
\[
  \buildtyorcollection(\overname{\parsenode{\Ntyorcollection}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms a type annotation parse node $\vparsednode$ into a type AST node $\vastnode$.
\ProseOtherwiseBuildError
} % END_OF_IGNORED_RELATION


We define $\buildtyorcollection$ per the corresponding type in the following sections.

\MarkedIgnoredRelationDefinition{
\hypertarget{build-as-ty}{}
The function
\[
  \buildasty(\overname{\parsenode{\Nasty}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms a type annotation parse node $\vparsednode$ into a type AST node $\vastnode$.
\ProseOtherwiseBuildError
} % END_OF_IGNORED_RELATION


Formally:
\begin{mathpar}
\inferrule{
  \buildty(\vt) \astarrow \astversion{\vt}
} {
  \buildasty(\Tcolon, \namednode{\vt}{\Nty}) \astarrow \astversion{\vt}
}
\end{mathpar}

\hypertarget{integertypeterm}{}
\section{Integer Types\label{sec:IntegerTypes}}
The \emph{\integertypesterm{}} represent mathematical integer value.

There are four kinds of integer types, and we
use the term \integertypeterm{} to refer to them collectively:
\emph{\unconstrainedintegertypesterm},
\emph{\wellconstrainedintegertypesterm},
\emph{\pendingconstrainedintegertypesterm},
and \emph{\parameterizedintegertypesterm}.

\subsection{Unconstrained Integer Types}
\hypertarget{def-unconstrainedintegertype}{}
The type \verb|integer| represents all integer values.
\identi{HJBH}%
There is no bound on the minimum and maximum integer value that can be represented.

\ExampleDef{Unconstrained Integer Types}
\listingref{typing-unconstrained} shows examples of unconstrained integer types.
\ASLListing{Well-typed unconstrained integer types}{typing-unconstrained}{\typingtests/TypingRule.TIntUnConstrained.asl}

\subsection{Well-constrained Integer Types}
\identr{GWCP}%
The type \texttt{integer\{$c_1,\ldots,c_n$\}} represents the
union of sets of integers represented by the \emph{integer constraints} $c_1,\ldots,c_n$.
\hypertarget{def-exactconstraintterm}{}
\hypertarget{def-rangeconstraintterm}{}
A constraint can either be an \emph{\exactconstraintterm}, consisting of a single expression like \texttt{4},
or a \emph{\rangeconstraintterm}, consisting of a pair of expressions like \texttt{1..10}.

\ExampleDef{Well-constrained Integer Types}
\hypertarget{def-wellconstrainedintegertype}{}
The well-typed specification in \listingref{constrainedintegers1} shows examples of \wellconstrainedintegertypesterm.
\ASLListing{Well-typed well-constrained integer types}{constrainedintegers1}{\definitiontests/ConstrainedIntegers1.asl}

The well-typed specification in \listingref{constrainedintegers2} shows examples of \wellconstrainedintegertypesterm{}
and \unconstrainedintegertypesterm{} for \verb|config|s.
\ASLListing{Well-constrained integer types and \texttt{config}s}{constrainedintegers2}{\definitiontests/ConstrainedIntegers2.asl}

The specifications in \listingref{constrainedintegers-bad}
and \listingref{constrainedintegers-bad2}
show examples of ill-typed
assignment between two \wellconstrainedintegertypesterm{}.
\ASLListing{Ill-typed well-constrained integer types}{constrainedintegers-bad}{\definitiontests/ConstrainedIntegers.bad.asl}
\ASLListing{Ill-typed well-constrained integer types}{constrainedintegers-bad2}{\definitiontests/ConstrainedIntegers.bad2.asl}

\subsection{Pending-constrained Integer Types}
\hypertarget{def-pendingconstrainedintegertype}{}
The type \verb|integer{}| represents a well-constrained integer type whose
constraints have yet to be determined.
These constraints are inferred by the type system based on the expression used to initialize
the storage element (see \TypingRuleRef{InheritIntegerConstraints}).

\RequirementDef{PendingConstrainedLHS}
Pending-constrained integer types may only appear on the left-hand-side
of local and global storage element declarations.
They may not appear in \texttt{config} declarations.
%
\listingref{config-pending-constrained} shows an ill-typed specification.

\ExampleDef{Well-typed pending-constrained types}
\listingref{typing-pendingconstrained} shows examples of well-typed pending-constrained
integer types.
\ASLListing{Well-typed pending-constrained integer types}{typing-pendingconstrained}{\typingtests/TypingRule.InheritIntegerConstraints.asl}

\subsection{Parameterized Integer Types}
\hypertarget{def-parameterizedintegertype}{}
Subprogram parameters are implicitly \emph{parameterized integer types},
which represent a singleton set for the integer passed to the parameter
at the call site.

\ExampleDef{Parameterized Integer Types}
\listingref{typing-parameterized} shows examples of well-typed parameterized
integer types.
Notice that the type of the parameter \texttt{M} of the function \texttt{bar}
is a parameterized integer type, \underline{not} an unconstrained integer type.
\ASLListing{Well-typed parameterized integer types}{typing-parameterized}{\typingtests/TypingRule.TIntParameterized.asl}

\subsection{Syntax\label{sec:IntegerTypesSyntax}}
\begin{flalign*}
\Nty \derives\ & \Tinteger \parsesep \Nconstraintkindopt &\\
\Nconstraintkindopt \derives \ & \Nconstraintkind \;|\; \emptysentence &\\
\Nconstraintkind \derives \ & \Tlbrace \parsesep \ClistOne{\Nintconstraint} \parsesep \Trbrace &\\
|\ & \Tlbrace \parsesep \Trbrace &\\
\Nintconstraint \derives \ & \Nexpr &\\
|\ & \Nexpr \parsesep \Tslicing \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax\label{sec:IntegerTypesAST}}
\RenderTypes[remove_hypertargets]{ty_int_constraint_and_kind}
\BackupOriginalAST{
  \begin{flalign*}
\ty \derives\ & \TInt(\constraintkind)\\
\constraintkind \derives\ & \unconstrained
& \\
|\ & \wellconstrained(\intconstraint^{+})
& \\
|\ & \pendingconstrained{}
& \\
|\ & \parameterized(\overtext{\identifier}{parameter}) &\\
\intconstraint \derives\ & \ConstraintExact(\expr)
& \\
|\ & \ConstraintRange(\overtext{\expr}{start}, \overtext{\expr}{end})&
\end{flalign*}
}

\ASTRuleDef{Ty.TInt}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tinteger, \punnode{\Nconstraintkindopt})) \astarrow
  \overname{\TInt(\astof{\vconstraintkindopt})}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{IntConstraintsOpt}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-constraintkindopt}{}
The function
\[
  \buildconstraintkindopt(\overname{\parsenode{\Nconstraintkindopt}}{\vparsednode}) \;\aslto\; \overname{\constraintkind}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[constrained]{}{
  {
    \begin{array}{r}
  \buildconstraintkindopt(\Nconstraintkindopt(\punnode{\Nconstraintkind})) \astarrow \\
  \overname{\astof{\vconstraintkind}}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{}{
  \buildconstraintkindopt(\Nconstraintkindopt(\emptysentence)) \astarrow
  \overname{\Unconstrained}{\vastnode}
}
\end{mathpar}

\subsection{ASTRule.IntConstraints\label{sec:ASTRule.IntConstraints}}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-constraintkind}{}
The function
\[
  \buildconstraintkind(\overname{\parsenode{\Nconstraintkind}}{\vparsednode}) \;\aslto\; \overname{\constraintkind}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[well\_constrained]{
  \buildclist[\buildintconstraint](\cs) \astarrow \vcsasts
}{
  {
    \begin{array}{r}
  \buildconstraintkind(\Nconstraintkind(\Tlbrace, \namednode{\cs}{\ClistOne{\Nintconstraint}}, \Trbrace)) \astarrow\\
  \overname{\WellConstrained(\vcsasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pending\_constrained]{}{
  \buildconstraintkind(\Nconstraintkind(\Tlbrace, \Trbrace)) \astarrow
  \overname{\PendingConstrained}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{IntConstraint}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-intconstraint}{}
The function
\[
  \buildintconstraint(\overname{\parsenode{\Nintconstraint}}{\vparsednode}) \;\aslto\; \overname{\intconstraint}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[exact]{}{
  \buildintconstraint(\Nintconstraint(\punnode{\Nexpr})) \astarrow
  \overname{\ConstraintExact(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \buildexpr(\vfromexpr) \astarrow \astversion{\vfromexpr}\\
  \buildexpr(\vtoexpr) \astarrow \astversion{\vtoexpr}\\
}{
  {
    \begin{array}{r}
  \buildintconstraint(\Nintconstraint(\namednode{\vfromexpr}{\Nexpr}, \Tslicing, \namednode{\vtoexpr}{\Nexpr})) \astarrow\\
  \overname{\ConstraintRange(\astversion{\vfromexpr}, \astversion{\vtoexpr})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing Integer Types\label{sec:TypingIntegerTypes}}
\hypertarget{def-isunconstrainedinteger}{}
\hypertarget{def-isparameterizedinteger}{}
\hypertarget{def-iswellconstrainedinteger}{}
We use the following helper predicates to classify integer types:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \isparameterizedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \iswellconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool
  \end{array}
\]
Those are defined as follows:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\Unconstrained\\
  \isparameterizedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\Parameterized\\
  \iswellconstrainedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\WellConstrained\\
\end{array}
\]
\identd{ZTPP} \identr{WJYH} \identr{HJPN} \identr{CZTX} \identr{TPHR}

\hypertarget{def-unconstrainedinteger}{}
We use the shorthand notation $\unconstrainedinteger \triangleq \TInt(\Unconstrained)$
for unconstrained integers.

\RequirementDef{ConstraintSymbolicallyConstrained}
The expressions appearing in integer constraints must be both
\symbolicallyevaluableterm{} and \constrainedintegerterm{} types.
%
In \listingref{annotate-constraint-unconstrained}, the constraint
\verb|x..x+1| is ill-typed, since \texttt{x} is not \symbolicallyevaluableterm{}.
\ASLListing{Ill-typed constraint}{annotate-constraint-unconstrained}{\typingtests/TypingRule.AnnotateConstraint.bad.asl}

\TypingRuleDef{TInt}
\ExampleDef{Ill-typed pending-constrained integer type}
\listingref{config-pending-constrained}
and \listingref{rhs-pending-constrained}
correspond to \CaseName{pending\_constrained}.
\ASLListing{Ill-typed pending-constrained integer type}{config-pending-constrained}
{\typingtests/TypingRule.TInt.config_pending_constrained.bad.asl}

\ASLListing{Ill-typed pending-constrained integer type}{rhs-pending-constrained}
{\typingtests/TypingRule.TInt.rhs_pending_constrained.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{pending\_constrained}
    \begin{itemize}
      \item $\tty$ is a \pendingconstrainedintegertypeterm;
      \item the result is a \typingerrorterm{} (\UnexpectedType).
    \end{itemize}
  \item \AllApplyCase{well\_constrained}
    \begin{itemize}
      \item $\tty$ is the well-constrained integer type constrained by
        constraints $\vc_i$, for $u=1..k$;
      \item annotating each constraint $\vc_i$, for $i=1..k$,
      yields $(\newc_i, \vxs_i)$\ProseOrTypeError;
      \item $\newconstraints$ is the list of annotated constraints $\newc_i$,
      for $i=1..k$;
      \item $\newty$ is the well-constrained integer type constrained
        by $\newconstraints$ with $\PrecisionFull$;
      \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
    \end{itemize}

    \item \AllApplyCase{parameterized}
    \begin{itemize}
      \item $\tty$ is a \parameterizedintegertypeterm\ for $\name$;
      \item define $\vses$ as the \sideeffectsetterm{} containing a $\Pure$ \LocalEffectTerm{} and an \ImmutabilityTerm{} with immutability $\True$.
      \item $\newty$ is the unconstrained integer type.
    \end{itemize}

    \item \AllApplyCase{unconstrained}
    \begin{itemize}
      \item $\tty$ is an \unconstrainedintegertypeterm;
      \item $\newty$ is the unconstrained integer type;
      \item define $\vses$ as the empty set.
    \end{itemize}
  \end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[pending\_constrained]{}{
  {
    \begin{array}{r}
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\TInt(\PendingConstrained)}{\tty}) \typearrow
  \TypeErrorVal{\UnexpectedType}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \constraints \eqname \vc_{1..k}\\
  i=1..k: \annotateconstraint(\vc_i) \typearrow (\newc_i, \vxs_i) \OrTypeError\\\\
  \newconstraints \eqdef \newc_{1..k}\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  {
    \begin{array}{r}
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\TInt(\WellConstrained(\constraints))}{\tty}) \typearrow \\
  (\overname{\TInt(\WellConstrained(\newconstraints, \PrecisionFull))}{\newty}, \vses)
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[parameterized]{
  \tty \eqname \TInt(\Parameterized(\name))\\
  \vses \eqdef \{ \LocalEffect(\Pure), \Immutability(\True) \}
}{
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \tty) \typearrow (\overname{\tty}{\newty}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  \tty \eqname \unconstrainedinteger
}{
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \tty) \typearrow (\overname{\tty}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TIntBegin}{\TIntEnd}{../Typing.ml}

\TypingRuleDef{AnnotateConstraint}
\RenderRelation{annotate_constraint}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\annotateconstraint(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vc})
\aslto (\overname{\intconstraint}{\newc} \times \overname{\TSideEffectSet}{\vses})\ \cup \\
\overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates an integer constraint $\vc$ in the \staticenvironmentterm{} $\tenv$ yielding the annotated
integer constraint $\newc$ and \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\listingref{annotate-constraint} shows examples of \wellconstrainedintegertypesterm{}
and the resulting annotated constraints in comments.
The annotated constraints inline the constant \texttt{N} and the right-hand-side
expressions of \texttt{let} storage elements.
\ASLListing{Annotated constraints}{annotate-constraint}{\typingtests/TypingRule.AnnotateConstraint.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is the exact integer constraint for the expression $\ve$, that is, \\ $\ConstraintExact(\ve)$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\ve$ in $\tenv$ yields \\
          $(\vep, \vses)$\ProseOrTypeError;
    \item define $\newc$ as the exact integer constraint for $\vep$, that is, $\ConstraintExact(\vep)$.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is the range integer constraint for expressions $\veone$ and $\vetwo$, that is, \\ $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\veone$ in $\tenv$ yields\\ $(\veonep, \vsesone)$\ProseOrTypeError;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\vetwo$ in $\tenv$ yields\\ $(\vetwop, \vsestwo)$\ProseOrTypeError;
    \item define $\newc$ as the range integer constraint for expressions $\veonep$ and $\vetwop$, that is, $\ConstraintRange(\veonep, \vetwop)$;
    \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \annotatesymbolicconstrainedinteger(\tenv, \ve) \typearrow (\vep, \vses) \OrTypeError
}{
  \annotateconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow (\overname{\ConstraintExact(\vep)}{\newc}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \annotatesymbolicconstrainedinteger(\tenv, \veone) \typearrow (\veonep, \vsesone) \OrTypeError\\\\
  \annotatesymbolicconstrainedinteger(\tenv, \vetwo) \typearrow (\vetwop, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  {
  \begin{array}{r}
    \annotateconstraint(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \\
    (\overname{\ConstraintRange(\veonep, \vetwop)}{\newc}, \vses)
  \end{array}
  }
}
\end{mathpar}

\section{The Real Type\label{sec:RealType}}
\hypertarget{realtypeterm}{}
The \emph{\realtypeterm{}} represents mathematical rational number values.
There is no bound on the minimum and maximum rational value that can be represented,
and there is no bound on their precision.
%
There is no mechanism in the language to generate an irrational value of \realtypeterm.

Conversions from an \integertypeterm{} value to a \realtypeterm{} value are performed
using the \stdlibfunc{Real}.
%
Conversions from a \realtypeterm{} value an \integertypeterm{} value to are performed
using the \stdlibfunc{RoundDown}, \stdlibfunc{RoundUp}. and \stdlibfunc{RoundTowardsZero}.

\ExampleDef{Well-typed Real Types}
In \listingref{typing-treal}, all the uses of the \realtypeterm{} are well-typed.
\ASLListing{Well-typed real types}{typing-treal}{\typingtests/TypingRule.TReal.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Treal &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_real}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TReal &
\end{flalign*}
}

\ASTRuleDef{TReal}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Treal)) \astarrow
  \overname{\TReal}{\vastnode}
}
\end{mathpar}

\subsection{Typing the Real Type\label{sec:TypingRealType}}
\TypingRuleDef{TReal}
See \ExampleRef{Well-typed Real Types} for examples of well-typed \realtypeterm{}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \realtypeterm{}, $\TReal$.
  \item $\newty$ is the \realtypeterm{}, $\TReal$;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\TReal}{\tty}) \typearrow (\overname{\TReal}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TRealBegin}{\TRealEnd}{../Typing.ml}

\section{The String Type\label{sec:StringType}}
\hypertarget{stringtypeterm}{}
\hypertarget{stringtypesterm}{}
The \emph{\stringtypeterm{}} represents strings of characters.

Strings play relatively little role in specifications and the only operations
on strings are equality and inequality tests.
Strings are useful in \printstatementsterm{} for debugging and diagnostic purposes
on runtimes that support printing.

\ExampleDef{Well-typed String Types}
In \listingref{typing-tstring}, all the uses of the \stringtypeterm{} are well-typed.
\ASLListing{Well-typed string types}{typing-tstring}{\typingtests/TypingRule.TString.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tstring &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_string}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TString&
\end{flalign*}
}

\ASTRuleDef{Ty.String}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tstring)) \astarrow
  \overname{\TString}{\vastnode}
}
\end{mathpar}

\subsection{Typing the String Type\label{sec:TypingStringType}}
\TypingRuleDef{TString}
See \ExampleRef{Well-typed String Types} for examples of well-typed \stringtypesterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \stringtypeterm{}, $\TString$.
  \item $\newty$ is the \stringtypeterm{}, $\TString$.
  \item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\TString}{\tty}) \typearrow (\overname{\TString}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TStringBegin}{\TStringEnd}{../Typing.ml}

\section{The Boolean Type\label{sec:BooleanType}}
\hypertarget{booleantypeterm}{}
The \emph{\booleantypeterm{}} represents Booleans.

\ExampleDef{Well-typed Boolean Types}
In \listingref{typing-tbool}, all the uses of the \booleantypeterm{} are well-typed.
\ASLListing{Well-typed Boolean types}{typing-tbool}{\typingtests/TypingRule.TBool.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tboolean &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_bool}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TBool &
\end{flalign*}
}

\ASTRuleDef{Ty.BoolType}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tboolean)) \astarrow
  \overname{\TBool}{\vastnode}
}
\end{mathpar}

\subsection{Typing the Boolean Type\label{sec:TypingBooleanType}}
\TypingRuleDef{TBool}
See \ExampleRef{Well-typed Boolean Types} for examples of well-typed \booleantypesterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the boolean type, $\TBool$;
  \item $\newty$ is the boolean type, $\TBool$;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\TBool}{\tty}) \typearrow (\overname{\TBool}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TBoolBegin}{\TBoolEnd}{../Typing.ml}

\section{Bitvector Types\label{sec:BitvectorTypes}}
\hypertarget{bitvectortypeterm}{}
\emph{Bitvectors} represent sequences of $0$ and $1$ bits.
%
The \texttt{bits(N)} type represents a bitvector of width \texttt{N},
where \texttt{N} may specify a fixed width or a constrained width.

\identr{RXYN}%
Bitvectors can be converted to unsigned integers and signed integer
via the standard library functions
\verb|UInt| and \verb|SInt|, respectively.
Converting integers into bitvectors can be done via slicing
(see \ExampleRef{Evaluation of Slicing Expressions}).

\identi{KGMC}%
The syntax for \bitvectortypesterm{} has an optional $\Nbitfields$,
which allows specifying \emph{\bitfieldsterm} ---
\bitslicesterm{} of bitvectors --- to be treated as named
fields that can be read or written.
\chapref{Bitfields} defines \bitfieldsterm{}
and \chapref{BitvectorSlicing} defines \bitslicesterm{}.

\SyntacticSugarDef{Bit}
The \Tbit{} type is \syntacticsugar{} for \texttt{bits(1)},
as exemplified by \listingref{Bit}.
It is \desugared{} by \ASTRuleCaseRef{Ty.TBits}{BIT}.

\ASLListing{Syntactic sugar for single bit bitvector types}{Bit}{\definitiontests/Bit.asl}

\RequirementDef{BitvectorsMSB}
In a bitvector literal, the most significant bit (\ProseMSB) is the leftmost value
and the least significant bit (\ProseLSB) is the rightmost value.
% INLINED_EXAMPLE
For example, in \verb|'10'| the \ProseMSB{} is \verb|1| and the \ProseLSB{} is \verb|0|.

\RequirementDef{BitvectorWidthImmutable}
The width of a bitvector cannot be modified.

In \listingref{BitvectorSlices}, slicing expressions such as \verb|bv[5:0]|
and bitvector concatenation expressions such as \verb|bv[5:5] :: bv[4:4]|
create new bitvector values without affecting the widths (or values)
of existing bitvector values.

\RequirementDef{BitvectorWidthBounds}
There is no bound on the maximum bitvector width allowed, although an implementation may specify an upper
limit.
%The minimum bound is zero.
It is recognized that zero-width bitvectors might not be supported in systems
to which ASL might be translated (such as SMT solvers),
and an implementation might need to lower bitvector
expressions to a form where zero-width bitvectors do not exist.

In \listingref{BitvectorWidthBounds}, any number can be used instead of \verb|2^20| for
\verb|large_bitvector|, and \verb|zero_width_bitvector| is an example of a zero-width bitvector.

\ASLListing{Large and small bitvectors}{BitvectorWidthBounds}{\definitiontests/GuideRule.BitvectorWidthBounds.asl}

\RequirementDef{BitvectorWidthKind}
The width of a \bitvectortypeterm{} can be either \staticallyevaluableterm{}
or \emph{constrained}. That is, a \symbolicallyevaluableterm{} \constrainedintegerterm{}.

\ExampleDef{Symbolic and Constrained Bitwidth}
\listingref{symbolic_bitwidth} shows an example of a bitvector whose width
is symbolic --- \verb|2 * N| and a bitvector whose width is determined
by a constrained type \verb|integer{4, 8}|.
\ASLListing{Constrained bitwidth and symbolic bitwidth}{symbolic_bitwidth}{\definitiontests/symbolic_bitwidth.asl}

\listingref{constrained_bitwidth} shows more examples of constrained bitwidths.
\ASLListing{Constrained bitwidths}{constrained_bitwidth}{\definitiontests/constrained_bitwidth.asl}

\ExampleDef{Rotating a Bitvector}
\listingref{bits-rotate} shows a specification where the width of the bitvector type
\texttt{bv} is a literal (\verb|bits(5)|), and bitvector types where the width is
constrained (\verb|bits(N)|, \verb|bits(i)|, and \verb|bits(N-i)|),
and related operations,
followed by the output to the console.
\ASLListing{Rotating a bitvector}{bits-rotate}{\definitiontests/Bitvector_rotate.asl}
% CONSOLE_BEGIN aslref \definitiontests/Bitvector_rotate.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
bv=0x14, rotated twice=0x05
\end{Verbatim}
% CONSOLE_END

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tbit &\\
            |\ & \Tbits \parsesep \Tlpar \parsesep \Nexpr \parsesep \Trpar \parsesep \option{\Nbitfields} &\\
\Nbitfields \derives \ & \Tlbrace \parsesep \TClistZero{\Nbitfield} \parsesep \Trbrace &\\
\Nbitfield \derives \ & \Nslices \parsesep \Tidentifier &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Nbitfields &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Tcolon \parsesep \Nty &\\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_bits}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TBits(\overtext{\expr}{width}, \bitfield^{*}) &
\end{flalign*}
}

\ASTRuleDef{Ty.TBits}
\begin{mathpar}
\inferrule[bit]{}{
  \buildty(\Nty(\Tbit)) \astarrow
  \overname{\TBits(\ELiteral(\LInt(1)), \emptylist)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits]{
  \buildlist[\buildbitfield](\vbitfields) \astarrow \vbitfieldasts
}{
  {
    \begin{array}{r}
  \buildty(\Nty(\Tbits, \Tlpar, \punnode{\Nexpr}, \Trpar, \namednode{\vbitfields}{\maybeemptylist{\Nbitfields}})) \astarrow\\
  \overname{\TBits(\astof{\vexpr}, \vbitfieldasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing Bitvector Types}
\TypingRuleDef{TBits}
\ExampleDef{Well-typed Bitvector Types}
In \listingref{typing-tbits}, all the uses of bitvector types are well-typed.
\ASLListing{Well-typed Bitvector types}{typing-tbits}{\typingtests/TypingRule.TBits.asl}

The specification in \listingref{typing-tbits-bad} is ill-typed, since widths need
to be \constrainedintegersterm.
\ASLListing{An ill-typed Bitvector type}{typing-tbits-bad}{\typingtests/TypingRule.TBits.bad.asl}

\ExampleRef{A bitvector type with bitfields} shows a well-typed \bitvectortypeterm{} with bitfields.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \bitvectortypeterm{} with width given by the expression
    $\ewidth$ and the bitfields given by $\bitfields$, that is, $\TBits(\ewidth, \bitfields)$;
  \item annotating the expression $\ewidth$ yields $(\twidth, \ewidthp, \seswidth)$\ProseOrTypeError;
  \item \Prosechecksymbolicallyevaluable{\seswidth};
  \item \Prosecheckconstrainedinteger{$\tenv$}{$\twidth$};
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{with\_bitfields}
    \begin{itemize}
      \item $\bitfields$ is not empty;
      \item checking that $\seswidth$ is \pureterm{} via $\sesispure$ yields $\True$\ProseTerminateAs{\SideEffectViolation};
      \item annotating the bitfields $\bitfields$ yields \\
            $(\bitfieldsp, \vsesbitfields)$\ProseOrTypeError;
      \item \Prosestaticeval{$\tenv$}{$\ewidthp$}{$\LInt(\vwidth)$};
      \item \Prosecheckcommonbitfieldsalign{$\tenv$}{$\bitfieldsp$}{$\vwidth$}\ProseOrTypeError;
      \item \Proseeqdef{$\newty$}{the \bitvectortypeterm{} with width given by the expression
            $\ewidthp$ and the bitfields given by $\bitfieldsp$, that is, \\
            $\TBits(\ewidthp, \bitfieldsp)$};
      \item \Proseeqdef{$\vses$}{the union of $\seswidth$ and $\vsesbitfields$}.
    \end{itemize}

    \item \AllApplyCase{no\_bitfields}
    \begin{itemize}
      \item $\bitfields$ is empty;
      \item \Proseeqdef{$\newty$}{the \bitvectortypeterm{} with width given by the expression
            $\ewidthp$ and an empty list of bitfields, that is,
            $\TBits(\ewidthp, \emptylist)$};
      \item \Proseeqdef{$\vses$}{$\seswidth$}.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[with\_bitfields]{
  \annotateexpr(\tenv, \ewidth) \typearrow (\twidth, \ewidthp, \seswidth) \OrTypeError\\\\
  \checksymbolicallyevaluable(\seswidth) \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \twidth) \typearrow \True \OrTypeError\\\\
  \commonprefixline\\\\
  \bitfields \neq \emptylist\\\\
  \techeck(\sesispure(\seswidth), \SideEffectViolation) \typearrow \True \OrTypeError\\\\
  {
  \begin{array}{r}
    \annotatebitfields(\tenv, \ewidthp, \bitfields) \typearrow \\
    (\bitfieldsp, \vsesbitfields) \OrTypeError
  \end{array}
  }\\
  \staticeval(\tenv, \ewidthp) \typearrow \LInt(\vwidth) \OrTypeError\\\\
  \checkcommonbitfieldsalign(\tenv, \bitfieldsp, \vwidth) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \seswidth \cup \vsesbitfields
}{
  {
    \begin{array}{r}
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\TBits(\ewidth, \bitfields)}{\tty}) \typearrow \\
  (\overname{\TBits(\ewidthp, \bitfieldsp)}{\newty}, \vses)
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_bitfields]{
  \annotateexpr(\tenv, \ewidth) \typearrow (\twidth, \ewidthp, \seswidth) \OrTypeError\\\\
  \checksymbolicallyevaluable(\seswidth) \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \twidth) \typearrow \True \OrTypeError\\\\
  \commonprefixline\\\\
  \bitfields = \emptylist
}{
  {
    \begin{array}{r}
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\TBits(\ewidth, \bitfields)}{\tty}) \typearrow \\
  (\overname{\TBits(\ewidthp, \bitfieldsp)}{\newty}, \overname{\seswidth}{\seswidth})
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\TBitsBegin}{\TBitsEnd}{../Typing.ml}

\section{Tuple Types\label{sec:TupleTypes}}
\hypertarget{tupletypeterm}{}

Types can be combined into \tupletypesterm{} whose values consist of tuples of values of those types.
For example, the expression \verb|(TRUE, Zeros{32})| has type \verb|(boolean, bits(32))|.

\ExampleDef{Well-typed Tuples}
In \listingref{typing-ttuple}, all the uses of \tupletypesterm{} are well-typed.
\ASLListing{Well-typed tuple types}{typing-ttuple}{\typingtests/TypingRule.TTuple.asl}

\RequirementDef{TupleLength}
A \tupletypeterm{} must contain at least two elements.

In \listingref{TupleLength}, both \verb|x| and \verb|y| have tuple types,
whereas \verb|w| and \verb|z| are of the \integertypeterm, since \verb|(5)|
is considered a parenthesized expression, not a tuple expression.
\ASLListing{Tuples and parenthesized expressions}{TupleLength}{\definitiontests/GuideRule.TupleLength.asl}

In \listingref{EmptyTuple}, \verb|()| produces a parsing error, as tuples cannot be empty.
\ASLListing{Invalid empty tuple}{EmptyTuple}{\definitiontests/EmptyTuple.asl}

\RequirementDef{TupleImmutability}
The value and type of tuple elements cannot be modified.

\listingref{TupleImmutability} demonstrates how variables of a \tupletypeterm{} may be assigned,
but the tuple values they store may not be modified.
\ASLListing{Immutability of tuple values}{TupleImmutability}{\definitiontests/GuideRule.TupleImmutability.asl}

\RequirementDef{TupleElementAccess}
The $k+1$ element of a tuple \verb|t| with $n>1$ elements
can be accessed via the \texttt{t.item$k$} notation,
as long as $0 \leq k < n$.

\listingref{TupleElementAccess} shows examples of accessing the elements
of the tuple stored in \verb|x|.
\ASLListing{Accessing tuple elements}{TupleElementAccess}{\definitiontests/GuideRule.TupleElementAccess.asl}

\listingref{TupleElementAccess-bad} shows an example of an illegal access to a non-existing
element index.
\ASLListing{Invalid access to a tuple element}{TupleElementAccess-bad}{\definitiontests/GuideRule.TupleElementAccess.bad.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Plisttwo{\Nty} &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_tuple}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TTuple(\ty^{*}) &
\end{flalign*}
}

\ASTRuleDef{Ty.TTuple}
\begin{mathpar}
\inferrule{
  \buildplist[\buildty](\vtypes) \astarrow \vtypeasts
}{
  \buildty(\Nty(\namednode{\vtypes}{\Plisttwo{\Nty}})) \astarrow
  \overname{\TTuple(\vtypeasts)}{\vastnode}
}
\end{mathpar}

\subsection{Typing Tuple Types\label{sec:TypingTupleTypes}}
\TypingRuleDef{TTuple}
See \ExampleRef{Well-typed Tuples} for examples of well-typed \tupletypesterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \Prosetupletype{$\tys$}, that is, $\TTuple(\tys)$;
  \item $\tys$ is the list $\tty_i$, for $i=1..k$ and $k>1$;
  \item annotating each type $\tty_i$ in $\tenv$, for $i=1..k$,
        yields $(\ttyp_i, \vxs_i)$\ProseOrTypeError;
  \item $\newty$ is the \Prosetupletype{$\ttyp_i$}, for $i=1..k$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  k \geq 2\\
  \tys \eqname \tty_{1..k}\\
  i=1..k: \annotatetype(\False, \tenv, \tty_i) \typearrow (\ttyp_i, \vxs_i) \OrTypeError\\\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\TTuple(\tys)}{\tty}) \typearrow (\overname{\TTuple(\tysp)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TTupleBegin}{\TTupleEnd}{../Typing.ml}

\section{Parenthesized Types\label{sec:ParenthesizedTypes}}
A single type inside parentheses is not considered to be a tuple, but rather the element
inside the parenthesis.
Parenthesizing a type can be used to improve readability.

In \listingref{ParenthesizedTypes}, \verb|(integer)| is a parenthesized type, equivalent to simply \verb|integer| (without parentheses).
\ASLListing{Parenthesized types}{ParenthesizedTypes}{\definitiontests/ParenthesizedTypes.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\  & \Tlpar \parsesep \Nty \parsesep \Trpar &\\
\end{flalign*}

\subsection{Abstract Syntax}
A parenthesized type produces the abstract syntax of the type itself.
In other words, we ignore the parenthesis.

\ASTRuleDef{ParenType}
\begin{mathpar}
  \inferrule{}{
  \buildexpr(\overname{\Nty(\Tlpar, \punnode{\Nty}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\section{Enumeration Types\label{sec:EnumerationTypes}}
\hypertarget{enumerationtypeterm}{}
The \emph{\enumerationtypeterm} defines a list of enumeration literals,
also referred to as \emph{labels}, that act
as global constants that can be compared for equality and inequality and used
as indices in enumeration-indexed arrays.
%
The type of an enumeration literal is the anonymous \enumerationtypeterm{}
that defined the literal.
\identd{YZBQ} \identr{HJYJ}

\identi{PRPY}%
Unlike many languages, there is no ordering defined for enumeration literals
and therefore enumeration types do not support ordering comparisons such as \verb|<=|.

\ExampleDef{Well-typed Enumeration Types}
\listingref{typing-tenum} and \listingref{typing-tenum-subtypes} show examples of well-typed
enumeration type declarations.

\ASLListing{Well-typed enumeration type}{typing-tenum-subtypes}{\typingtests/TypingRule.TEnumDecl.subtypes.asl}
\ASLListing{Well-typed enumeration type}{typing-tenum}{\typingtests/TypingRule.TEnumDecl.asl}

\identr{DWSP} \identr{QMWT} \identi{MZXL}%
\RequirementDef{LabelNamespace}
Enumeration literals exist in the same namespace as all other declared identifiers except subprograms (see \RequirementRef{GlobalNamespace}),
including storage elements and named types, so no other declared identifier
may have the same name in the same scope.
In particular, this means that an enumeration literal can be declared in
at most one \enumerationtypeterm{} declaration.

See \ExampleRef{Well-typed Enumeration Types} and \ExampleRef{Ill-typed Enumeration Type Declarations}.

\RequirementDef{AnonymousEnumerations}
Enumeration types are only allowed in declarations.

\listingref{AnonymousEnumerations} shows an illegal specification
where an enumeration is used outside of a type definition.
\ASLListing{Anonymous enumerations are illegal}{AnonymousEnumerations}{\definitiontests/GuideRule.AnonymousEnumerations.bad.asl}

\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Tenumeration \parsesep \Tlbrace \parsesep \TClistOne{\Tidentifier} \parsesep \Trbrace &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_enum}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TEnum(\overtext{\Identifier^{*}}{labels}) &
\end{flalign*}
}

\ASTRuleDef{TyDecl.TEnum}
\begin{mathpar}
\inferrule{
  \buildtclist[\buildidentity](\vids) \astarrow \vidasts
}{
  {
    \begin{array}{r}
  \buildtydecl(\Ntydecl(\Tenumeration, \Tlbrace, \namednode{\vids}{\TClistOne{\Tidentifier}}, \Trbrace)) \astarrow\\
  \overname{\TEnum(\vidasts)}{\vastnode}
\end{array}
  }
}
\end{mathpar}

\subsection{Typing Enumeration Types\label{sec:TypingEnumerationTypes}}
\TypingRuleDef{TEnumDecl}
See \ExampleRef{Well-typed Enumeration Types} for examples of well-typed \enumerationtypesterm{}
declarations.

\ExampleDef{Ill-typed Enumeration Type Declarations}
\listingref{typing-tenum-bad},
\listingref{typing-tenum-bad2},
\listingref{typing-tenum-bad3}, and
\listingref{typing-tenum-bad4},
show examples of ill-typed enumeration type declarations.
\ASLListing{Ill-typed enumeration types}{typing-tenum-bad}{\typingtests/TypingRule.TEnumDecl.bad.asl}
\ASLListing{Ill-typed enumeration types}{typing-tenum-bad2}{\typingtests/TypingRule.TEnumDecl.bad2.asl}
\ASLListing{Ill-typed enumeration types}{typing-tenum-bad3}{\typingtests/TypingRule.TEnumDecl.bad3.asl}
\ASLListing{Ill-typed enumeration types}{typing-tenum-bad4}{\typingtests/TypingRule.TEnumDecl.bad4.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \enumerationtypeterm{} with enumeration literals
        $\vli$, that is, $\TEnum(\vli)$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item determining that $\vli$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item determining that none of the labels in $\vli$ is declared in the global environment
  yields $\True$\ProseOrTypeError;
  \item $\newty$ is the \enumerationtypeterm{} $\tty$;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checknoduplicates(\vli) \typearrow \True \OrTypeError\\\\
  \vl \in \vli: \checkvarnotingenv(G^\tenv, \vl) \typearrow \True \OrTypeError
}{
  \annotatetype(\True, \tenv, \overname{\TEnum(\vli)}{\tty}) \typearrow (\overname{\TEnum(\vli)}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TEnumDeclBegin}{\TEnumDeclEnd}{../Typing.ml}

\section{Array Types\label{sec:ArrayTypes}}
\hypertarget{arraytypeterm}{}
\identr{DFXJ}%
Arrays are sequences of values of a single given type.
The syntax \verb|array [[expr]] of ty| declares a single-dimensional array of type \texttt{ty}
with an index type derived from the expression \texttt{expr}.
%
\identr{YHNV}%
ASL offers two kinds of arrays:
\hypertarget{intarraytypeterm}{}
\hypertarget{enumarraytypeterm}{}
\begin{description}
  \item[\Intarraytypeterm] represents a consecutive list of elements at positions $0$ to the size
      specified for the array. The array elements can be accessed via an \integertypeterm{}
      that specifies the $0$-based position of the element to read/update.
  \item[\Enumarraytypeterm] represents a dictionary-like data type where the keys are defined
      by a given \enumerationtypeterm{}. The array elements can be accessed via values of the
      \enumerationtypeterm{} specified for the array type.
\end{description}

\RequirementDef{ArrayLengthImmutable}
The length of an array cannot be modified.
% NO_EXAMPLE

\RequirementDef{ArrayLengthExpression}
The length expression of an \intarraytypeterm{} must be a \symbolicallyevaluableterm{}
expression whose \underlyingtypeterm{} is an \integertypeterm{} .

\ExampleDef{Well-typed Array Types}
In \listingref{typing-tarray}, all the uses of array types are well-typed.
\ASLListing{Well-typed array types}{typing-tarray}{\typingtests/TypingRule.TArray.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tarray \parsesep \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket \parsesep \Tof \parsesep \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_array}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TArray(\arrayindex, \ty) &\\
\end{flalign*}
}

\RenderType[remove_hypertargets]{array_index}

\ASTRuleDef{Ty.TArray}
\begin{mathpar}
\inferrule{}{
  {
  \begin{array}{r}
    \buildty(\Nty(\Tarray, \Tllbracket, \punnode{\Nexpr}, \Trrbracket, \Tof, \punnode{\Nty})) \astarrow\\
    \overname{\TArray(\ArrayLengthExpr(\astof{\vexpr}), \astof{\tty})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}
\subsection{Typing Array Types\label{sec:TypingArrayTypes}}
\TypingRuleDef{TArray}
See \ExampleRef{Well-typed Array Types} for examples of well-typed
array types.

\ExampleDef{Ill-typed Array Types}
In \listingref{typing-tarray-bad}, the array type for \verb|illegal_array1|
is ill-typed, since the expression \verb|non_symbolically_evaluable|
is not \symbolicallyevaluableterm{}.
\ASLListing{Ill-typed array types}{typing-tarray-bad}{\typingtests/TypingRule.TArray.bad.asl}
Similarly in \listingref{typing-tarray-bad2}, the array type for \verb|illegal_array2| is ill-typed, since the expression \verb|non_constrained| is not a \constrainedintegerterm{}.
\ASLListing{Ill-typed array types}{typing-tarray-bad2}{\typingtests/TypingRule.TArray.bad2.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the array type with element type $\vt$;
  \item Annotating the type $\vt$ in $\tenv$ yields $(\vtp, \vsest)$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{expr\_is\_enum}
    \begin{itemize}
      \item the array index is $\ve$ and determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via $\getvariableenum$ yields the enumeration variable
      name $\vs$ of size $\vi$, that is, $\some{ \vs, \vi }$\ProseOrTypeError;
      \item $\newty$ is the array type indexed by an \enumerationtypeterm{}
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$;
      \item define $\vses$ as $\vsest$.
    \end{itemize}

    \item \AllApplyCase{expr\_not\_enum}
    \begin{itemize}
      \item the array index is $\ve$ and determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via $\getvariableenum$ yields $\None$ (meaning it does not
      correspond to an enumeration)\ProseOrTypeError;
      \item annotating the \symbolicallyevaluableterm{} \constrainedintegerterm{} expression $\ve$ yields\\
      $(\vep, \vsesindex)$\ProseOrTypeError;
      \item $\newty$ the array type indexed by integer bounded by
      the expression $\vep$ and of elements of type $\vtp$, that is,
      $\TArray(\ArrayLengthExpr(\vep), \vtp)$;
      \item define $\vses$ as the union of $\vsest$ and $\vsesindex$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[expr\_is\_enum]{
  \annotatetype(\False, \tenv, \vt) \typearrow (\vtp, \vsest) \OrTypeError\\\\
  \commonprefixline\\\\
  \getvariableenum(\tenv, \ve) \typearrow \some{ \vs, \vlabels }
}{
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\AbbrevTArrayLengthExpr{\ve}{\vt}}{\tty}) \typearrow
  (\overname{\AbbrevTArrayLengthEnum{\ve}{\vlabels}{\vtp}}{\newty}, \overname{\emptyset}{\vsest})
}
\end{mathpar}

\begin{mathpar}
\inferrule[expr\_not\_enum]{
  \annotatetype(\False, \tenv, \vt) \typearrow (\vtp, \vsest) \OrTypeError\\\\
  \commonprefixline\\\\
  \getvariableenum(\tenv, \ve) \typearrow \None\\
  \annotatesymbolicconstrainedinteger(\tenv, \ve) \typearrow (\vep, \vsesindex) \OrTypeError\\\\
  \vses \eqdef \vsest \cup \vsesindex
}{
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\AbbrevTArrayLengthExpr{\ve}{\vt}}{\tty}) \typearrow
  (\overname{\AbbrevTArrayLengthExpr{\vep}{\vtp}}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TArrayBegin}{\TArrayEnd}{../Typing.ml}

\TypingRuleDef{GetVariableEnum}
\RenderRelation{get_variable_enum}
\BackupOriginalRelation{
The function
\[
\getvariableenum(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
\Option{ (\overname{\Identifier}{\vx}, \overname{\KleenePlus{\Identifier}}{\vlabels})}
\]
tests whether the expression $\ve$ represents a variable of an \enumerationtypeterm{}.
If so, the result is $\vx$ --- the name of the variable and the list of labels $\vlabels$,
declared for the \enumerationtypeterm{}.
Otherwise, the result is $\None$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Retrieving Enumeration Labels from Variable Expressions}
\listingref{typing-getvariableenum} shows examples of retrieving
enumeration labels from variable expressions.
\ASLListing{Retrieving enumeration labels from expressions}{typing-getvariableenum}{\typingtests/TypingRule.GetVariableEnum.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{not\_evar}
  \begin{itemize}
    \item $\ve$ is not a variable expression;
    \item the result is $\None$.
  \end{itemize}

  \item \AllApplyCase{no\_declared\_type}
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is not associated with a type in the global environment of $\tenv$;
    \item the result is $\None$.
  \end{itemize}

  \item \AllApplyCase{declared\_enum}
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtypeterm\ of $\vt$ in $\tenv$ yields an \enumerationtypeterm{} with labels $\vlabels$;
    \item the result is the pair consisting of $\vx$ and $\vlabels$.
  \end{itemize}

  \item \AllApplyCase{declared\_not\_enum}
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtypeterm\ of $\vt$ in $\tenv$ yields a type that is not an \enumerationtypeterm{};
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_evar]{
  \astlabel(\ve) \neq \EVar
}{
  \getvariableenum(\tenv, \ve) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_declared\_type]{
  G^\tenv.\declaredtypes(\vx) = \bot
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_enum]{
  G^\tenv.\declaredtypes(\vx) = (\vt, \Ignore)\\
  \makeanonymous(\tenv, \vt) \typearrow \TEnum(\vlabels)
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \some{(\vx, \vlabels)}
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_not\_enum]{
  G^\tenv.\declaredtypes(\vx) = (\vt, \Ignore)\\
  \makeanonymous(\tenv, \vt) \typearrow \vtone\\
  \astlabel(\vtone) \neq \TEnum
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\identi{PKXK} \identd{YYDW}%
\RequirementDef{SymbolicallyEvaluable}
An expression is \symbolicallyevaluableterm{} if its evaluation only involves
the use of immutable values.

See \ExampleRef{Annotating Symbolically Evaluable Expressions}.

\TypingRuleDef{AnnotateSymbolicallyEvaluableExpr}
\RenderRelation{annotate_symbolically_evaluable_expr}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
  \annotatesymbolicallyevaluableexpr(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto \\
  (\overname{\ty}{\vt}\times\overname{\expr}{\vep}\times\overname{\TSideEffectSet}{\vses}) \cup \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates the expression $\ve$ in the \staticenvironmentterm{} $\tenv$ and checks that it is \symbolicallyevaluableterm,
yielding the type in $\vt$, the annotated expression $\vep$ and the \sideeffectsetterm{} $\vses$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Symbolically Evaluable Expressions}
\listingref{typing-annotatesymbolicallyevaluableexpr} shows examples of
expressions and classifies them as either \symbolicallyevaluableterm{} or not.
\ASLListing{Annotating symbolically evaluable Expressions}{typing-annotatesymbolicallyevaluableexpr}
{\typingtests/TypingRule.AnnotateSymbolicallyEvaluableExpr.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseannotateexpr{$\tenv$}{$\ve$}{$(\vt, \vep, \vses)$};
  \item \Prosechecksymbolicallyevaluable{$\vses$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ve) \typearrow (\vt, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError
}{
  \annotatesymbolicallyevaluableexpr(\tenv, \ve) \typearrow (\vt, \vep, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateSymbolicallyEvaluableExprBegin}{\AnnotateSymbolicallyEvaluableExprEnd}{../Typing.ml}

\TypingRuleDef{CheckUnderlyingInteger}
\RenderRelation{check_underlying_integer}
\BackupOriginalRelation{
The function
\[
  \checkunderlyinginteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \{\True\} \cup \typeerror
\]
returns $\True$ is $\vt$ is has the \underlyingtypeterm{} of an \integertypeterm{}.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Checking for an Underlying Integer Type}
All of the expressions appearing on the right-hand-side of the assignments in
\listingref{typing-annotatesymbolicallyevaluableexpr}
have an \integertypeterm{} as their \underlyingtypeterm{}.
This includes the expression \verb|i - 3|, since the \underlyingtypeterm{}
of \verb|i| is the \unconstrainedintegertypeterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item determining the \underlyingtypeterm{} of $\vt$ yields $\vtp$\ProseOrTypeError;
  \item checking that $\vtp$ is an \integertypeterm{} yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item the result is $\True$;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \makeanonymous(\tenv, \vt) \typearrow \vtp \OrTypeError\\\\
  \techeck(\astlabel(\vtp) = \TInt, \UnexpectedType) \typearrow \True \OrTypeError
}{
  \checkunderlyinginteger(\tenv, \vt) \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckUnderlyingIntegerBegin}{\CheckUnderlyingIntegerEnd}{../Typing.ml}

\section{Record Types\label{sec:RecordTypes}}
\hypertarget{recordtypeterm}{}
\identd{WGQS}%
A record is a \structuredtypeterm{} consisting of a list of field identifiers which denote individual storage elements.
\identr{DXWN}%
A record type is described by specifying for each field identifier its type.

\ExampleDef{Well-typed Record Types}
In \listingref{typing-trecord}, all the uses of record types are well-typed.
\ASLListing{Well-typed structured types}{typing-trecord}{\typingtests/TypingRule.TRecordDecl.asl}

In \listingref{typing-trecord-bad}, the \recordtypeterm{} \verb|MyRecord|
is ill-typed, since the field \verb|v| repeats.
\ASLListing{A record type with repeated fields}{typing-trecord-bad}{\typingtests/TypingRule.TRecordDecl.bad.asl}

\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Trecord \parsesep \Nfields &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_record}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TRecord(\field^{*}) &
\end{flalign*}
}

\ASTRuleDef{TyDecl.TRecord}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\Trecord, \punnode{\Nfields})) \astarrow
  \overname{\TRecord(\astof{\vfields})}{\vastnode}
}
\end{mathpar}

\subsection{Typing Record Types\label{sec:TypingRecordTypes}}
\TypingRuleDef{TStructuredDecl}
\ExampleRef{Well-typed Record Types} shows examples of well-typed \recordtypesterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is a \structuredtypeterm\ with AST label $L$;
  \item the list of fields of $\tty$ is $\fields$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item $\fields$ is a list of pairs where the first element is an identifier and the second is a type --- $(\vx_i, \vt_i)$, for $i=1..k$;
  \item checking that the list of field identifiers $\vx_{1..k}$ does not contain duplicates
  yields $\True$\ProseOrTypeError;
  \item annotating each field type $\vt_i$, for $i=1..k$, yields $(\vtp_i, \vxs_i)$
        \ProseOrTypeError;
  \item $\fieldsp$ is the list with $(\vx_i, \vtp_i)$, for $i=1..k$;
  \item $\newty$ is the AST node with AST label $L$ (either record type or exception type,
  corresponding to the type $\tty$) and fields $\fieldsp$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  L \in \{\TRecord, \TException\}\\
  \fields \eqname [i=1..k: (\vx_i, \vt_i)]\\
  \checknoduplicates(\vx_{1..k}) \typearrow \True \OrTypeError\\\\
  i=1..k: \annotatetype(\False, \tenv, \vt_i) \typearrow (\vtp_i, \vxs_i) \OrTypeError\\\\
  \fieldsp \eqdef [i=1..k: (\vx_i, \vtp_i)]\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype(\True, \tenv, \overname{L(\fields)}{\tty}) \typearrow (\overname{L(\fieldsp)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TStructuredDeclBegin}{\TStructuredDeclEnd}{../Typing.ml}

\section{Exception Types\label{sec:ExceptionTypes}}
\hypertarget{exceptiontypeterm}{}
An exception is a \structuredtypeterm{} consisting of a list of field identifiers
which denote individual storage elements.

\ExampleDef{Exception Types with and without Values}
\ASLListing{Exception types}{typing-builtinexceptiontype}{\typingtests/TypingRule.BuiltinExceptionType.asl}
\listingref{typing-builtinexceptiontype} defines two exception types:
\begin{itemize}
\item \verb|exception{-}| (for \texttt{Not\_found}), which carries no value; and
\item \verb|exception { message:string }| (for \texttt{SyntaxException}), which carries a message.
\end{itemize}
Notice the similarity with record types.

\ExampleDef{Well-typed Exception Types}
In \listingref{typing-texception}, all the uses of exception types are well-typed.
\ASLListing{Well-typed exception types}{typing-texception}{\typingtests/TypingRule.TExceptionDecl.asl}

\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Texception \parsesep \Nfields &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_exception}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TException(\field^{*}) &
\end{flalign*}
}

\ASTRuleDef{TyDecl.TException}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\Texception, \punnode{\Nfields})) \astarrow
  \overname{\TException(\astof{\vfields})}{\vastnode}
}
\end{mathpar}

\subsection{Typing Exception Types}
The rule for typing exception types is \TypingRuleRef{TStructuredDecl}.

\section{Collection Types\label{sec:CollectionTypes}}
\hypertarget{collectiontypeterm}{}

\ASLListing{Collection types}{TCollection}{\typingtests/TypingRule.TCollection.asl}

A collection is a \structuredtypeterm{} consisting of a list of field identifiers
which denote individual storage elements.

\RequirementDef{CollectionsGlobal}
Collections can only be used for global storage elements.
See \listingref{checkisnotcollection} for an ill-typed specification.

\subsection{Syntax}
\begin{flalign*}
  \Ntyorcollection \derives\ & \Nty \;|\; \Tcollection \parsesep \Nfields & \\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_collection}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TCollection(\field^{*}) &
\end{flalign*}
}

\ASTRuleDef{TyDecl.TCollection}
\begin{mathpar}
\inferrule{}{
{
  \begin{array}{r}
  \buildtyorcollection(\Ntyorcollection(\Tcollection, \punnode{\Nfields})) \astarrow\\
  \overname{\TCollection(\astof{\vfields})}{\vastnode}
  \end{array}
}
}
\and
\inferrule{}{
  \buildtyorcollection(\Ntyorcollection(\Nty)) \astarrow
  \overname{\astof{\Nty}}{\vastnode}
}
\end{mathpar}

\subsection{Typing Collection Types}
\ExampleDef{Typing Collection Types}
\listingref{TCollection} shows examples of well-typed collection types
and ill-typed collection types in comments.
In addition, \listingref{TCollection} shows well-typed storage declarations
utilizing collection types and ill-typed storage declarations utilizing
collection types in comments.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is a \collectiontypeterm{} with the list of fields of $\fields$;
  \item $\decl$ is $\False$, indicating that $\tty$ should not be considered in the context of a declaration;
  \item $\fields$ is a list of pairs where the first element is an identifier and the second is a type --- $(\vx_i, \vt_i)$, for $i=1..k$;
  \item checking that the list of field identifiers $\vx_{1..k}$ does not contain duplicates
  yields $\True$\ProseOrTypeError;
  \item annotating each field type $\vt_i$, for $i=1..k$, yields $(\vtp_i, \vxs_i)$
        \ProseOrTypeError;
  \item $\fieldsp$ is the list with $(\vx_i, \vtp_i)$, for $i=1..k$;
  \item checking that the \structureterm{} of the type $\vtp_i$ in the \staticenvironmentterm{} $\tenv$
        is a \bitvectortypeterm, for every $i$ in $1..k$, yields $\True$\ProseOrTypeError;
  \item $\newty$ is the AST node with AST label $L$ (either record type or exception type,
        corresponding to the type $\tty$) and fields $\fieldsp$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \fields \eqname [i=1..k: (\vx_i, \vt_i)]\\
  \checknoduplicates(\vx_{1..k}) \typearrow \True \OrTypeError\\\\
  i=1..k: \annotatetype(\False, \tenv, \vt_i) \typearrow (\vtp_i, \vxs_i) \OrTypeError\\\\
  \fieldsp \eqdef [i=1..k: (\vx_i, \vtp_i)]\\
  i=1..k: \checkstructurelabel(\tenv, \vtp_i, \TBits) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype(\False, \tenv, \overname{\TCollection(\fields)}{\tty}) \typearrow (\overname{\TCollection(\fieldsp)}{\newty}, \vses)
}
\end{mathpar}

\section{Named Types\label{sec:NamedTypes}}
Named type declarations allow declaring new types names with a given type.
The intent is that, by default, any named type should not be assignable to or from any other named type, even
if they coincidentally have the same \structureterm. Where assignment between named types is desired it is usually
achieved by grouping related types via a common supertype.

The specification in \listingref{named-types2}, declares two unique types with the same
\structureterm. Note that the two types are not related in
any way and are not interchangeable. See also \TypingRuleRef{TypeSatisfaction}.
\ASLListing{Well-typed named types}{named-types2}{\definitiontests/NamedTypes2.asl}

In \listingref{named-types}, \verb|TypeC.f| and \verb|TypeD.f| have the same type: \verb|TypeB| (and not integer).
\ASLListing{Two unique well-typed types}{named-types}{\definitiontests/NamedTypes.asl}

In \listingref{named-types3}, the assignments \verb|addr = physical;|
and \verb|physical = addr;| would be illegal.
\ASLListing{Two unique well-typed types}{named-types3}{\definitiontests/NamedTypes3.asl}

The well-typed specification in \listingref{named-types4}
demonstrates how a constant can be given a named type.
\ASLListing{Naming types for constants}{named-types4}{\definitiontests/NamedTypes4.asl}

The specification in \listingref{named-types-bad} is ill-typed
due to an assignment between two different named types (\verb|Char| and \verb|Byte|).
\ASLListing{Named types and illegal assignments}{named-types-bad}{\definitiontests/NamedTypes.bad.asl}

\hypertarget{namedtypeterm}{}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{ty_named}
\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TNamed(\overtext{\Identifier}{type name}) &
\end{flalign*}
}

\ASTRuleDef{Ty.TNamed}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tidentifier(\id))) \astarrow
  \overname{\TNamed(\id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing Named Types\label{sec:TypingNamedTypes}}
\TypingRuleDef{TNamed}
\ExampleDef{Well-typed Named Types}
In \listingref{typing-tnamed}, all the uses of \texttt{MyType} are well-typed.
\ASLListing{Well-typed named types}{typing-tnamed}{\typingtests/TypingRule.TNamed.asl}

The specifications in \listingref{typing-tnamed-bad1} and \listingref{typing-tnamed-bad2}
show examples of ill-typed named types.
\ASLListing{Ill-typed named types}{typing-tnamed-bad1}{\typingtests/TypingRule.TNamed.bad1.asl}
\ASLListing{Ill-typed named types}{typing-tnamed-bad2}{\typingtests/TypingRule.TNamed.bad2.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the named type $\vx$, that is $\TNamed(\vx)$;
  \item checking whether $\vx$ is bound to any declared type in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\vx$ is bound to a type with associated \purity{} $\vpurity$;
  \item define $\vses$ as the set of the \GlobalEffectTerm\ with purity $\vpurity$ and the \ImmutabilityTerm\ with immutability $\True$;
  \item $\newty$ is $\tty$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \techeck(G^\tenv.\declaredtypes(\vx) \neq \bot, \UndefinedIdentifier) \typearrow \True \OrTypeError\\\\
  G^\tenv.\declaredtypes(\vx) = (\Ignore, \vpurity)\\
  \vses \eqdef \{\ \GlobalEffectTerm(\vpurity), \Immutability(\True) \}
}{
  \annotatetype(\overname{\Ignore}{\vdecl}, \tenv, \overname{\TNamed(\vx)}{\tty}) \typearrow (\overname{\TNamed(\vx)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TNamedBegin}{\TNamedEnd}{../Typing.ml}

\section{Declared Types\label{sec:DeclaredTypes}}
A declared type can be an \enumerationtypeterm{}, a \recordtypeterm, an \exceptiontypeterm, or an \anonymoustype.
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\ASTRuleDef{TyDecl}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\punnode{\Nty})) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\subsection{Typing Declared Types}
\identr{RGRVJ}%
\RequirementDef{RestrictionsOnAnonymousTypes}
A declared type for an enumeration, a record type, or an exception type
are only permitted in named type declarations. This is enforced by \TypingRuleRef{TNonDecl}.
%
See \ExampleRef{Ill-typed pending-constrained integer type}.

\TypingRuleDef{TNonDecl}
\ExampleDef{Ill-typed Type Declarations}
In \listingref{typing-trecorderror}, the use of a record type outside of a declaration is erroneous.
\ASLListing{An erroneous use of a record type}{typing-trecorderror}{\typingtests/TypingRule.TNonDecl.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is a \structuredtypeterm\ or an \enumerationtypeterm{};
  \item $\decl$ is $\False$, indicating that $\tty$ should be considered to be outside the context of a declaration
  of $\tty$;
  \item a \typingerrorterm{} is returned, indicating that the use of anonymous form of enumerations, record,
  and exceptions types is not allowed here.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \astlabel(\tty) \in \{\TEnum, \TRecord, \TException\}
}{
  \annotatetype(\False, \tenv, \tty) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\TNonDeclBegin}{\TNonDeclEnd}{../Typing.ml}

\input{TypeDomains.tex}
\input{TypeAttributes.tex}
\input{RelationsOnTypes.tex}
\input{BaseValues.tex}
