\chapter{Types\label{chap:Types}}

Types describe the allowed values of variables, constants, function arguments, etc.
\lrmcomment{\identi{BYVL}}

This chapter first describes how types are represented formally (see \secref{FormalRepresentationofTypes}).
Next, we introduce each type available in ASL and define
how it is represented in the syntax and AST, and how it is typechecked:
\begin{itemize}
  \item Integer types (see \secref{IntegerTypes})
  \item The real type (see \secref{RealType})
  \item The string type (see \secref{StringType})
  \item The Boolean type (see \secref{BooleanType})
  \item Bitvector types (see \secref{BitvectorTypes})
  \item Tuple types (see \secref{TupleTypes})
  \item Array types (see \secref{ArrayTypes})
  \item Enumeration types (see \secref{EnumerationTypes})
  \item Record types (see \secref{RecordTypes})
  \item Exception types (see \secref{ExceptionTypes})
  \item Named types (see \secref{NamedTypes})
\end{itemize}

The chapter then defines the following aspects of types:
\begin{itemize}
\item \secref{DeclaredTypes} defines \emph{declared types} and restrictions over them;
\item \secref{DomainOfValuesForTypes} defines how values are associated with each type;
\item \secref{BasicTypeAttributes} assigns basic properties to types, which are useful
in classifying them;
\item \secref{RelationsOnTypes} defines relations on types that are needed to typecheck
expressions and statements; and
\item \secref{BaseValues} defines how to produce an expression to initialize storage
      elements of a given type (for which no initializing expression is supplied).
\end{itemize}

\section{Formal Representation of Types\label{sec:FormalRepresentationofTypes}}
\Anonymoustypes\ are grammatically derived from the non-terminal $\Nty$
and types that must be declared and named are grammatically derived from the non-terminal $\Ntydecl$.
The type system represents types by their AST, which is derived from the non-terminal $\ty$.

\subsection{Abstract Syntax}
\hypertarget{build-ty}{}
The function
\[
  \buildty(\overname{\parsenode{\Nty}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms an anonymous type parse node $\vparsednode$ into the corresponding AST node $\vastnode$.
\ProseOtherwiseBuildError

We define $\buildty$ per type in the following sections.

\hypertarget{build-tydecl}{}
The function
\[
  \buildtydecl(\overname{\parsenode{\Ntydecl}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms a \namedtype\ parse node $\vparsednode$ into an AST node $\vastnode$.
\ProseOtherwiseBuildError

We define $\buildtydecl$ per the corresponding type in the following sections.

\hypertarget{build-as-ty}{}
The function
\[
  \buildasty(\overname{\parsenode{\Nasty}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms a type annotation parse node $\vparsednode$ into a type AST node $\vastnode$.
\ProseOtherwiseBuildError

Formally:
\begin{mathpar}
\inferrule{
  \buildty(\vt) \astarrow \astversion{\vt}
} {
  \buildasty(\Tcolon, \namednode{\vt}{\Nty}) \astarrow \astversion{\vt}
}
\end{mathpar}

\subsection{Typing}
\hypertarget{def-annotatetype}{}
The function
\[
  \annotatetype{\overname{\Bool}{\vdecl} \aslsep \overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}}
  \aslto (\overname{\ty}{\newty} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
typechecks a type $\tty$ in a static environment $\tenv$,
resulting in a \typedast\ $\newty$ and a \sideeffectsetterm\ $\vses$.
The flag $\decl$ indicates whether $\tty$ is a type currently being declared or not,
and makes a difference only when $\tty$ is an enumeration type or a \structuredtype.
\ProseOtherwiseTypeError

\subsection{Semantics}
Types are not evaluated dynamically.
However, the dynamic semantics of types is given by their \emph{domain of values},
which is defined in \secref{DomainOfValuesForTypes}.

\hypertarget{integertypeterm}{}
\section{Integer Types\label{sec:IntegerTypes}}
The \texttt{integer} type represents mathematical integer values.

There are four kinds of integer types, which we explain next:
\emph{unconstrained}, \emph{well-constrained},
\emph{pending constrained}, and \emph{parameterized}.

\subsection{Unconstrained Integer Types}
The type \verb|integer| represents all integer values.
\lrmcomment{\identi{HJBH}}
There is no bound on the minimum and maximum integer value that can be represented.

\ExampleDef{Unconstrained Integer Types}
\listingref{typing-unconstrained} shows examples of unconstrained integer types.
\ASLListing{Well-typed unconstrained integer types}{typing-unconstrained}{\typingtests/TypingRule.TIntUnConstrained.asl}

\subsection{Well-constrained Integer Types}
\lrmcomment{\identr{GWCP}}
The type \texttt{integer\{$c_1,\ldots,c_n$\}} represents the
union of sets of integers represented by the \emph{integer constraints} $c_1,\ldots,c_n$.
\hypertarget{def-exactconstraintterm}{}
\hypertarget{def-rangeconstraintterm}{}
A constraint can either be an \emph{\exactconstraintterm}, consisting of a single expression like \texttt{4},
or a \emph{\rangeconstraintterm}, consisting of a pair of expressions like \texttt{1..10}.

\ExampleDef{Well-constrained Integer Types}
\listingref{typing-wellconstrained} shows examples of well-constrained integer types.
\ASLListing{Well-typed well-constrained integer types}{typing-wellconstrained}{\typingtests/TypingRule.TIntWellConstrained.asl}

\subsection{Pending-constrained Integer Types}
The type \verb|integer{-}| represents a well-constrained integer type whose
constraints have yet to be determined.
These constraints are inferred by the type system based on the expression used to initialize
the storage element (see \TypingRuleRef{InheritIntegerConstraints}).

\RequirementDef{PendingConstrainedLocal}
Pending-constrained integer types may only appear on the left-hand-side
of local storage element declarations.
%
\listingref{global-pending-constrained} shows an ill-typed specification.

\ExampleDef{Well-typed pending-constrained types}
\listingref{typing-pendingconstrained} shows examples of well-typed pending-constrained
integer types.
\ASLListing{Well-typed pending-constrained integer types}{typing-pendingconstrained}{\typingtests/TypingRule.InheritIntegerConstraints.asl}

\subsection{Parameterized Integer Types}
Subprogram parameters are implicitly \emph{parameterized integer types},
which represent a singleton set for the integer passed to the parameter
at the call site.

\ExampleDef{Parameterized Integer Types}
\listingref{typing-parameterized} shows examples of well-typed parameterized
integer types.
Notice that the type of the parameter \texttt{M} of the function \texttt{bar}
is a parameterized integer type, \underline{not} an unconstrained integer type.
\ASLListing{Well-typed parameterized integer types}{typing-parameterized}{\typingtests/TypingRule.TIntParameterized.asl}

\subsection{Syntax\label{sec:IntegerTypesSyntax}}
\begin{flalign*}
\Nty \derives\ & \Tinteger \parsesep \Nconstraintkindopt &\\
\Nconstraintkindopt \derives \ & \Nconstraintkind \;|\; \emptysentence &\\
\Nconstraintkind \derives \ & \Tlbrace \parsesep \ClistOne{\Nintconstraint} \parsesep \Trbrace &\\
|\ & \Tlbrace \parsesep \Tminus \parsesep \Trbrace &\\
\Nintconstraint \derives \ & \Nexpr &\\
|\ & \Nexpr \parsesep \Tslicing \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax\label{sec:IntegerTypesAST}}
\begin{flalign*}
\ty \derives\ & \TInt(\constraintkind)\\
\constraintkind \derives\ & \unconstrained
& \\
|\ & \wellconstrained(\intconstraint^{+})
& \\
|\ & \pendingconstrained{}
& \\
|\ & \parameterized(\overtext{\identifier}{parameter}) &\\
\intconstraint \derives\ & \ConstraintExact(\expr)
& \\
|\ & \ConstraintRange(\overtext{\expr}{start}, \overtext{\expr}{end})&
\end{flalign*}

\ASTRuleDef{Ty.TInt}
\begin{mathpar}
\inferrule[integer]{}{
  \buildty(\Nty(\Tinteger, \punnode{\Nconstraintkindopt})) \astarrow
  \overname{\TInt(\astof{\vconstraintkindopt})}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{IntConstraintsOpt}
\hypertarget{build-constraintkindopt}{}
The function
\[
  \buildconstraintkindopt(\overname{\parsenode{\Nconstraintkindopt}}{\vparsednode}) \;\aslto\; \overname{\constraintkind}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[constrained]{}{
  {
    \begin{array}{r}
  \buildconstraintkindopt(\Nconstraintkindopt(\punnode{\Nconstraintkind})) \astarrow \\
  \overname{\astof{\vconstraintkind}}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{}{
  \buildconstraintkindopt(\Nconstraintkindopt(\emptysentence)) \astarrow
  \overname{\unconstrained}{\vastnode}
}
\end{mathpar}

\subsection{ASTRule.IntConstraints\label{sec:ASTRule.IntConstraints}}
\hypertarget{build-constraintkind}{}
The function
\[
  \buildconstraintkind(\overname{\parsenode{\Nconstraintkind}}{\vparsednode}) \;\aslto\; \overname{\constraintkind}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[well\_constrained]{
  \buildclist[\buildintconstraint](\cs) \astarrow \vcsasts
}{
  {
    \begin{array}{r}
  \buildconstraintkind(\Nconstraintkind(\Tlbrace, \namednode{\cs}{\ClistOne{\Nintconstraint}}, \Trbrace)) \astarrow\\
  \overname{\wellconstrained(\vcsasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pending\_constrained]{}{
  \buildconstraintkind(\Nconstraintkind(\Tlbrace, \Tminus, \Trbrace)) \astarrow
  \overname{\pendingconstrained}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{IntConstraint}
\hypertarget{build-intconstraint}{}
The function
\[
  \buildintconstraint(\overname{\parsenode{\Nintconstraint}}{\vparsednode}) \;\aslto\; \overname{\intconstraint}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[exact]{}{
  \buildintconstraint(\Nintconstraint(\punnode{\Nexpr})) \astarrow
  \overname{\ConstraintExact(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \buildexpr(\vfromexpr) \astarrow \astversion{\vfromexpr}\\
  \buildexpr(\vtoexpr) \astarrow \astversion{\vtoexpr}\\
}{
  {
    \begin{array}{r}
  \buildintconstraint(\Nintconstraint(\namednode{\vfromexpr}{\Nexpr}, \Tslicing, \namednode{\vtoexpr}{\Nexpr})) \astarrow\\
  \overname{\ConstraintRange(\astversion{\vfromexpr}, \astversion{\vtoexpr})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing Integer Types\label{sec:TypingIntegerTypes}}
\hypertarget{def-isunconstrainedinteger}{}
\hypertarget{def-isparameterizedinteger}{}
\hypertarget{def-iswellconstrainedinteger}{}
We use the following helper predicates to classify integer types:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \isparameterizedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \iswellconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool
  \end{array}
\]
Those are defined as follows:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\unconstrained\\
  \isparameterizedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\parameterized\\
  \iswellconstrainedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\wellconstrained\\
\end{array}
\]\lrmcomment{This is related to \identd{ZTPP}, \identr{WJYH}, \identr{HJPN}, \identr{CZTX}, \identr{TPHR}.}

\hypertarget{def-unconstrainedinteger}{}
We use the shorthand notation $\unconstrainedinteger \triangleq \TInt(\unconstrained)$
for unconstrained integers.

\TypingRuleDef{TInt}
\ExampleDef{Ill-typed pending-constrained integer type}
\listingref{global-pending-constrained}
and \listingref{rhs-pending-constrained}
correspond to \CaseName{pending\_constrained}.
\ASLListing{Ill-typed pending-constrained integer type}{global-pending-constrained}
{\typingtests/TypingRule.TInt.global_pending_constrained.bad.asl}

\ASLListing{Ill-typed pending-constrained integer type}{rhs-pending-constrained}
{\typingtests/TypingRule.TInt.rhs_pending_constrained.bad.asl}

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{pending\_constrained}):
    \begin{itemize}
      \item $\tty$ is a \pendingconstrainedintegertype;
      \item the result is a type error (\UnexpectedType).
    \end{itemize}
  \item All of the following apply (\textsc{well\_constrained}):
    \begin{itemize}
      \item $\tty$ is the well-constrained integer type constrained by
        constraints $\vc_i$, for $u=1..k$;
      \item annotating each constraint $\vc_i$, for $i=1..k$,
      yields $(\newc_i, \vxs_i)$\ProseOrTypeError;
      \item $\newconstraints$ is the list of annotated constraints $\newc_i$,
      for $i=1..k$;
      \item $\newty$ is the well-constrained integer type constrained
        by $\newconstraints$;
      \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
    \end{itemize}

    \item All of the following apply (\textsc{parameterized}):
    \begin{itemize}
      \item $\tty$ is a \parameterizedintegertype\ for $\name$;
      \item define $\vses$ as the singleton set for the singleton \sideeffectdescriptorterm,
            \ReadLocalTerm\ for $\name$, \timeframeconstant, and $\True$ for immutability.
      \item $\newty$ is the unconstrained integer type.
    \end{itemize}

    \item All of the following apply (\textsc{unconstrained}):
    \begin{itemize}
      \item $\tty$ is an \unconstrainedintegertype;
      \item $\newty$ is the unconstrained integer type;
      \item define $\vses$ as the empty set.
    \end{itemize}
  \end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[pending\_constrained]{}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TInt(\pendingconstrained)}{\tty}} \typearrow
  \TypeErrorVal{\UnexpectedType}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \constraints \eqname \vc_{1..k}\\
  i=1..k: \annotateconstraint(\vc_i) \typearrow (\newc_i, \vxs_i) \OrTypeError\\\\
  \newconstraints \eqdef \newc_{1..k}\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TInt(\wellconstrained(\constraints))}{\tty}} \typearrow \\
  (\overname{\TInt(\wellconstrained(\newconstraints))}{\newty}, \vses)
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[parameterized]{
  \tty \eqname \TInt(\parameterized(\name))\\
  \vses \eqdef \{\ \ReadLocal(\name, \timeframeconstant, \True)\ \}
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \tty} \typearrow (\overname{\tty}{\newty}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  \tty \eqname \unconstrainedinteger
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \tty} \typearrow (\overname{\tty}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\CodeSubsection{\TIntBegin}{\TIntEnd}{../Typing.ml}

\TypingRuleDef{AnnotateConstraint}
\hypertarget{def-annotateconstraint}{}
The function
\[
\begin{array}{r}
\annotateconstraint(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vc})
\aslto (\overname{\intconstraint}{\newc} \times \overname{\TSideEffectSet}{\vses})\ \cup \\
\overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates an integer constraint $\vc$ in the static environment $\tenv$ yielding the annotated
integer constraint $\newc$ and \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\listingref{annotate-constraint} shows examples of \wellconstrainedintegertypes{}
and the resulting annotated constraints in comments.
The annotated constraints inline the constant \texttt{N} and the right-hand-side
expressions of \texttt{let} storage elements.
\ASLListing{Annotated constraints}{annotate-constraint}{\typingtests/TypingRule.AnnotateConstraint.asl}

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is the exact integer constraint for the expression $\ve$, that is, \\ $\ConstraintExact(\ve)$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\ve$ in $\tenv$ yields \\
          $(\vep, \vses)$\ProseOrTypeError;
    \item define $\newc$ as the exact integer constraint for $\vep$, that is, $\ConstraintExact(\vep)$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is the range integer constraint for expressions $\veone$ and $\vetwo$, that is, \\ $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\veone$ in $\tenv$ yields\\ $(\veonep, \vsesone)$\ProseOrTypeError;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\vetwo$ in $\tenv$ yields\\ $(\vetwop, \vsestwo)$\ProseOrTypeError;
    \item define $\newc$ as the range integer constraint for expressions $\veonep$ and $\vetwop$, that is, $\ConstraintRange(\veonep, \vetwop)$;
    \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \annotatesymbolicconstrainedinteger(\tenv, \ve) \typearrow (\vep, \vses) \OrTypeError
}{
  \annotateconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow (\overname{\ConstraintExact(\vep)}{\newc}, \vses)
}
\and
\inferrule[range]{
  \annotatesymbolicconstrainedinteger(\tenv, \veone) \typearrow (\veonep, \vsesone) \OrTypeError\\\\
  \annotatesymbolicconstrainedinteger(\tenv, \vetwo) \typearrow (\vetwop, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateconstraint(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\ConstraintRange(\veonep, \vetwop)}{\newc}
}
\end{mathpar}

\hypertarget{realtypeterm}{}
\section{The Real Type\label{sec:RealType}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Treal &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TReal &
\end{flalign*}

\ASTRuleDef{TReal}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Treal)) \astarrow
  \overname{\TReal}{\vastnode}
}
\end{mathpar}

\subsection{Typing the Real Type\label{sec:TypingRealType}}
\TypingRuleDef{TReal}
\subsubsection{Example}
In \listingref{typing-treal}, all the uses of \texttt{real} are well-typed.
\ASLListing{Well-typed real types}{typing-treal}{\typingtests/TypingRule.TReal.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the real type \TReal.
  \item $\newty$ is the real type \TReal;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TReal}{\tty}} \typearrow (\overname{\TReal}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TRealBegin}{\TRealEnd}{../Typing.ml}

\hypertarget{stringtypeterm}{}
\section{The String Type\label{sec:StringType}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tstring &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TString&
\end{flalign*}

\ASTRuleDef{Ty.String}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tstring)) \astarrow
  \overname{\TString}{\vastnode}
}
\end{mathpar}

\subsection{Typing the String Type\label{sec:TypingStringType}}
\TypingRuleDef{TString}
\subsubsection{Example}
In \listingref{typing-tstring}, all the uses of \texttt{string} are well-typed.
\ASLListing{Well-typed string types}{typing-tstring}{\typingtests/TypingRule.TString.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the string type \TString.
  \item $\newty$ is the string type \TString.
  \item $\vses$ is the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TString}{\tty}} \typearrow (\overname{\TString}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TStringBegin}{\TStringEnd}{../Typing.ml}

\hypertarget{booleantypeterm}{}
\section{The Boolean Type\label{sec:BooleanType}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tboolean &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TBool &
\end{flalign*}

\ASTRuleDef{Ty.BoolType}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tboolean)) \astarrow
  \overname{\TBool}{\vastnode}
}
\end{mathpar}

\subsection{Typing the Boolean Type\label{sec:TypingBooleanType}}
\TypingRuleDef{TBool}
\subsubsection{Example}
In \listingref{typing-tbool}, all the uses of \texttt{boolean} are well-typed.
\ASLListing{Well-typed Boolean types}{typing-tbool}{\typingtests/TypingRule.TBool.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the boolean type, \TBool;
  \item $\newty$ is the boolean type, \TBool;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TBool}{\tty}} \typearrow (\overname{\TBool}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TBoolBegin}{\TBoolEnd}{../Typing.ml}

\hypertarget{bitvectortypeterm}{}
\section{Bitvector Types\label{sec:BitvectorTypes}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tbit &\\
            |\ & \Tbits \parsesep \Tlpar \parsesep \Nexpr \parsesep \Trpar \parsesep \option{\Nbitfields} &\\
\Nbitfields \derives \ & \Tlbrace \parsesep \TClistZero{\Nbitfield} \parsesep \Trbrace &\\
\Nbitfield \derives \ & \Nslices \parsesep \Tidentifier &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Nbitfields &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Tcolon \parsesep \Nty &\\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TBits(\overtext{\expr}{width}, \bitfield^{*}) &
\end{flalign*}

\ASTRuleDef{Ty.TBits}
\begin{mathpar}
\inferrule[bit]{}{
  \buildty(\Nty(\Tbit)) \astarrow
  \overname{\TBits(\ELiteral(\lint(1)), \emptylist)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits]{
  \buildlist[\buildbitfield](\vbitfields) \astarrow \vbitfieldasts
}{
  {
    \begin{array}{r}
  \buildty(\Nty(\Tbits, \Tlpar, \punnode{\Nexpr}, \Trpar, \namednode{\vbitfields}{\maybeemptylist{\Nbitfields}})) \astarrow\\
  \overname{\TBits(\astof{\vexpr}, \vbitfieldasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{TBits}
\subsubsection{Example}
In \listingref{typing-tbits}, all the uses of bitvector types are well-typed.
\ASLListing{Well-typed Bitevector types}{typing-tbits}{\typingtests/TypingRule.TBits.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the bit-vector type with width given by the expression
    $\ewidth$ and the bitfields given by $\bitfields$, that is, $\TBits(\ewidth, \bitfields)$;
  \item annotating the expression $\ewidth$ yields $(\twidth, \ewidthp, \seswidth)$\ProseOrTypeError;
  \item \Prosechecksymbolicallyevaluable{\seswidth};
  \item \Prosecheckconstrainedinteger{$\tenv$}{$\twidth$};
  \item annotating the bitfields $\bitfields$ yields $(\bitfieldsp, \vsesbitfields)$\ProseOrTypeError;
  \item \Prosestaticeval{$\tenv$}{$\ewidthp$}{$\lint(\vwidth)$};
  \item \Prosecheckcommonbitfieldsalign{$\tenv$}{$\bitfieldsp$}{$\vwidth$}\ProseOrTypeError;
  \item $\newty$ is the bit-vector type with width given by the expression
    $\ewidthp$ and the bitfields given by $\bitfieldsp$, that is, $\TBits(\ewidthp, \bitfieldsp)$;
  \item define $\vses$ as the union of $\seswidth$ and $\vsesbitfields$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ewidth} \typearrow (\twidth, \ewidthp, \seswidth) \OrTypeError\\\\
  \checksymbolicallyevaluable(\seswidth) \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \twidth) \typearrow \True \OrTypeError\\\\
  {
  \begin{array}{r}
    \annotatebitfields(\tenv, \ewidthp, \bitfields) \typearrow \\
    (\bitfieldsp, \vsesbitfields) \OrTypeError
  \end{array}
  }\\
  \staticeval(\tenv, \ewidthp) \typearrow \lint(\vwidth)\\
  \checkcommonbitfieldsalign(\tenv, \bitfieldsp, \vwidth) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \seswidth \cup \vsesbitfields
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \TBits(\ewidth, \bitfields)} \typearrow \\
  (\overname{\TBits(\ewidthp, \bitfieldsp)}{\newty}, \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\TBitsBegin}{\TBitsEnd}{../Typing.ml}

\subsubsection{Comments}
The width of a bitvector type $\TBits(\ewidth, \bitfields)$, given by the expression \\
$\ewidth$,
must be non-negative.

\hypertarget{tupletypeterm}{}
\section{Tuple Types\label{sec:TupleTypes}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \PlistZero{\Nty} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TTuple(\ty^{*}) &
\end{flalign*}

\ASTRuleDef{Ty.TTuple}
\begin{mathpar}
\inferrule{
  \buildplist[\buildty](\vtypes) \astarrow \vtypeasts
}{
  \buildty(\Nty(\namednode{\vtypes}{\PlistZero{\Nty}})) \astarrow
  \overname{\TTuple(\vtypeasts)}{\vastnode}
}
\end{mathpar}

\subsection{Typing Tuple Types\label{sec:TypingTupleTypes}}
\subsubsection{Example}
In \listingref{typing-ttuple}, all the uses of tuple types are well-typed.
\ASLListing{Well-typed tuple types}{typing-ttuple}{\typingtests/TypingRule.TTuple.asl}

\TypingRuleDef{TTuple}
\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the tuple type with member types $\tys$, that is, $\TTuple(\tys)$;
  \item $\tys$ is the list $\tty_i$, for $i=1..k$;
  \item annotating each type $\tty_i$ in $\tenv$, for $i=1..k$,
  yields $(\ttyp_i, \vxs_i)$\ProseOrTypeError;
  \item $\newty$ is the tuple type with member types $\ttyp$, for $i=1..k$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  k \geq 2\\
  \tys \eqname \tty_{1..k}\\
  i=1..k: \annotatetype{\False, \tenv, \tty_i} \typearrow (\ttyp_i, \vxs_i) \OrTypeError\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \TTuple(\tys)} \typearrow (\overname{\TTuple(\tysp)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TTupleBegin}{\TTupleEnd}{../Typing.ml}

\hypertarget{arraytypeterm}{}
\section{Array Types\label{sec:ArrayTypes}}
ASL offers two kinds of arrays:
\begin{description}
  \item[Integer-indexed arrays] representing a consecutive list of elements at positions $0$ to the size
      specified for the array. The array elements can be accessed via an \texttt{integer}
      type that specifies the $0$-based position of the element to read/update.
  \item[Enumeration-indexed arrays] representing a dictionary-like data type where the keys are defined
      by a given enumeration type. The array elements can be accessed via values of the \texttt{enumeration}
      type specified for the array type.
\end{description}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tarray \parsesep \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket \parsesep \Tof \parsesep \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TArray(\arrayindex, \ty) &\\
\arrayindex \derives\ &  \ArrayLengthExpr(\overtext{\expr}{array length}) &
\end{flalign*}

\ASTRuleDef{Ty.TArray}
\begin{mathpar}
\inferrule{}{
  {
  \begin{array}{r}
    \buildty(\Nty(\Tarray, \Tllbracket, \punnode{\Nexpr}, \Trrbracket, \Tof, \punnode{\Nty})) \astarrow\\
    \overname{\TArray(\ArrayLengthExpr(\astof{\vexpr}), \astof{\tty})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}
\subsection{Typing Array Types\label{sec:TypingArrayTypes}}
\subsubsection{Example}
In \listingref{typing-tarray}, all the uses of array types are well-typed.
\ASLListing{Well-typed array types}{typing-tarray}{\typingtests/TypingRule.TArray.asl}

\TypingRuleDef{TArray}
\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the array type with element type $\vt$;
  \item Annotating the type $\vt$ in $\tenv$ yields $(\vtp, \vsest)$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{expr\_is\_enum}):
    \begin{itemize}
      \item the array index is $\ve$ and determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via $\getvariableenum$ yields the enumeration variable
      name $\vs$ of size $\vi$, that is, $\langle \vs, \vi \rangle$\ProseOrTypeError;
      \item $\newty$ is the array type indexed by an enumeration type
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$;
      \item define $\vses$ as $\vsest$.
    \end{itemize}

    \item All of the following apply (\textsc{expr\_not\_enum}):
    \begin{itemize}
      \item the array index is $\ve$ and determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via $\getvariableenum$ yields $\None$ (meaning it does not
      correspond to an enumeration)\ProseOrTypeError;
      \item annotating the \symbolicallyevaluable{} integer expression $\ve$ yields\\
      $(\vep, \vsesindex)$\ProseOrTypeError;
      \item $\newty$ the array type indexed by integer bounded by
      the expression $\vep$ and of elements of type $\vtp$, that is,
      $\TArray(\ArrayLengthExpr(\vep), \vtp)$;
      \item define $\vses$ as the union of $\vsest$ and $\vsesindex$.
    \end{itemize}
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[expr\_is\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow (\vtp, \vsest) \OrTypeError\\\\
  \commonprefixline\\\\
  \getvariableenum(\tenv, \ve) \typearrow \langle \vs, \vlabels \rangle\OrTypeError
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\AbbrevTArrayLengthExpr{\ve}{\vt}}{\tty}} \typearrow
  (\overname{\AbbrevTArrayLengthEnum{\ve}{\vlabels}{\vtp}}{\newty}, \overname{\emptyset}{\vsest})
}
\end{mathpar}

\begin{mathpar}
\inferrule[expr\_not\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow (\vtp, \vsest) \OrTypeError\\\\
  \commonprefixline\\\\
  \getvariableenum(\tenv, \ve) \typearrow \None \OrTypeError\\\\
  \annotatesymbolicinteger(\tenv, \ve) \typearrow (\vep, \vsesindex) \OrTypeError\\\\
  \vses \eqdef \vsest \cup \vsesindex
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\AbbrevTArrayLengthExpr{\ve}{\vt}}{\tty}} \typearrow
  (\overname{\AbbrevTArrayLengthExpr{\vep}{\vtp}}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TArrayBegin}{\TArrayEnd}{../Typing.ml}

\TypingRuleDef{GetVariableEnum}
\hypertarget{def-getvariableenum}{}
The function
\[
\getvariableenum(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
\langle (\overname{\identifier}{\vx}, \overname{\identifier^+}{\vlabels})\rangle
\]
tests whether the expression $\ve$ represents a variable of an enumeration type.
If so, the result is $\vx$ --- the name of the variable and the list of labels $\vlabels$,
declared for the enumeration type.
Otherwise, the result is $\None$.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{not\_evar}):
  \begin{itemize}
    \item $\ve$ is not a variable expression;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{no\_declared\_type}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is not associated with a type in the global environment of $\tenv$;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{declared\_enum}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtype\ of $\vt$ in $\tenv$ yields an enumeration type with labels $\vlabels$\ProseOrTypeError;
    \item the result is the pair consisting of $\vx$ and $\vlabels$.
  \end{itemize}

  \item All of the following apply (\textsc{declared\_not\_enum}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtype\ of $\vt$ in $\tenv$ yields a type that is not an enumeration type;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_evar]{
  \astlabel(\ve) \neq \EVar
}{
  \getvariableenum(\tenv, \ve) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_declared\_type]{
  G^\tenv.\declaredtypes(\vx) = \bot
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_enum]{
  G^\tenv.\declaredtypes(\vx) = (\vt, \Ignore)\\
  \makeanonymous(\tenv, \vt) \typearrow \TEnum(\vlabels) \OrTypeError
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \langle(\vx, \vlabels)\rangle
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_not\_enum]{
  G^\tenv.\declaredtypes(\vx) = (\vt, \Ignore)\\
  \makeanonymous(\tenv, \vt) \typearrow \vtone\\
  \astlabel(\vtone) \neq \TEnum
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\TypingRuleDef{AnnotateSymbolicallyEvaluableExpr}
\hypertarget{def-annotatesymbolicallyevaluableexpr}{}
The function
\[
\begin{array}{r}
  \annotatesymbolicallyevaluableexpr(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto \\
  (\overname{\ty}{\vt}\times\overname{\expr}{\vep}\times\overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the expression $\ve$ in the static environment $\tenv$ and checks that it is \symbolicallyevaluable,
yielding the resulting type in $\vt$, the annotated expression in $\vep$ and the \sideeffectsetterm\ in $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item \Proseannotateexpr{$\tenv$}{$\ve$}{$(\vt, \vep, \vses)$};
  \item \Prosechecksymbolicallyevaluable{$\vses$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError
}{
  \annotatesymbolicallyevaluableexpr(\tenv, \ve) \typearrow (\vt, \vep, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateSymbolicallyEvaluableExprBegin}{\AnnotateSymbolicallyEvaluableExprEnd}{../Typing.ml}

\TypingRuleDef{AnnotateSymbolicInteger}
\hypertarget{def-annotatesymbolicinteger}{}
The function
\[
  \annotatesymbolicinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  (\overname{\expr}{\vepp} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a \symbolicallyevaluable\ integer expression $\ve$ in the static environment $\tenv$
and returns the annotated expression $\vepp$ and \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item \Proseannotatesymbolicallyevaluableexpr{$\tenv$}{$\ve$}{$(\vt, \vep, \vses)$\ProseOrTypeError};
  \item determining whether $\vt$ has the structure of an integer yields $\True$\ProseOrTypeError;
  \item determining whether $\vep$ is \symbolicallyevaluable\ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\normalize$ to $\vep$ in $\tenv$ yields $\vepp$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatesymbolicallyevaluableexpr(\tenv, \ve) \typearrow (\vt, \vep, \vses) \OrTypeError\\\\
  \checkstructureinteger(\tenv, \vt) \typearrow \True \OrTypeError\\\\
  \checksymbolicallyevaluable(\tenv, \vep) \typearrow \True \OrTypeError\\\\
  \normalize(\tenv, \vep) \typearrow \vepp
}{
  \annotatesymbolicinteger(\tenv, \ve) \typearrow (\vepp, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateSymbolicIntegerBegin}{\AnnotateSymbolicIntegerEnd}{../Typing.ml}

\hypertarget{def-checkstructureinteger}{}
\TypingRuleDef{CheckStructureInteger}
The function
\[
  \checkstructureinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \{\True\} \cup \TTypeError
\]
returns $\True$ is $\vt$ is has the \structure\ an integer type and a type error otherwise.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ is an integer type;
    \item the result is $\True$;
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ is not an integer type;
    \item the result is a type error indicating that $\vt$ was expected to have the \structure\ of an integer.
  \end{itemize}
\end{itemize}

\CodeSubsection{\CheckStructureIntegerBegin}{\CheckStructureIntegerEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\vt) \typearrow \vtp \OrTypeError\\\\
  \astlabel(\vtp) = \TInt
}
{
  \checkstructureinteger(\tenv, \vt) \typearrow \True
}
\and
\inferrule[error]{
  \tstruct(\vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \TInt
}
{
  \checkstructureinteger(\tenv, \vt) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}

\hypertarget{enumerationtypeterm}{}
\section{Enumeration Types\label{sec:EnumerationTypes}}
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Tenumeration \parsesep \Tlbrace \parsesep \TClistOne{\Tidentifier} \parsesep \Trbrace &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TEnum(\overtext{\identifier^{*}}{labels}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TEnum}
\begin{mathpar}
\inferrule{
  \buildtclist[\buildidentity](\vids) \astarrow \vidasts
}{
  {
    \begin{array}{r}
  \buildtydecl(\Ntydecl(\Tenumeration, \Tlbrace, \namednode{\vids}{\TClistOne{\Tidentifier}}, \Trbrace)) \astarrow\\
  \overname{\TEnum(\vidasts)}{\vastnode}
\end{array}
  }
}
\end{mathpar}

\subsection{Typing Enumeration Types\label{sec:TypingEnumerationTypes}}
\TypingRuleDef{TEnumDecl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the enumeration type with enumeration literals
    $\vli$, that is, $\TEnum(\vli)$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item determining that $\vli$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item determining that none of the labels in $\vli$ is declared in the global environment
  yields $\True$\ProseOrTypeError;
  \item $\newty$ is the enumeration type $\tty$;
  \item define $\vses$ as the empty set.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checknoduplicates(\vli) \typearrow \True \OrTypeError\\\\
  \vl \in \vli: \checkvarnotingenv{G^\tenv, \vl} \typearrow \True \OrTypeError
}{
  \annotatetype{\True, \tenv, \TEnum(\vli)} \typearrow (\overname{\TEnum(\vli)}{\newty}, \overname{\emptyset}{\vses})
}
\CodeSubsection{\TEnumDeclBegin}{\TEnumDeclEnd}{../Typing.ml}

\end{mathpar}
\lrmcomment{This is related to \identd{YZBQ}, \identr{DWSP}, \identi{MZXL}.}
\subsubsection{Example}
\listingref{typing-tenum} shows an example of a well-typed enumeration type declaration.
\ASLListing{Well-typed enumeration type}{typing-tenum}{\typingtests/TypingRule.TEnumDecl.asl}

\hypertarget{recordtypeterm}{}
\section{Record Types\label{sec:RecordTypes}}
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Trecord \parsesep \Nfieldsopt &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TRecord(\Field^{*}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TRecord}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\Trecord, \punnode{\Nfieldsopt})) \astarrow
  \overname{\TRecord(\astof{\vfieldsopt})}{\vastnode}
}
\end{mathpar}

\subsection{Typing Record Types\label{sec:TypingRecordTypes}}
\TypingRuleDef{TStructuredDecl}
\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is a \structuredtype\ with AST label $L$;
  \item the list of fields of $\tty$ is $\fields$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item $\fields$ is a list of pairs where the first element is an identifier and the second is a type --- $(\vx_i, \vt_i)$, for $i=1..k$;
  \item checking that the list of field identifiers $\vx_{1..k}$ does not contain duplicates
  yields $\True$\ProseOrTypeError;
  \item annotating each field type $\vt_i$, for $i=1..k$, yields $(\vtp_i, \vxs_i)$
        \ProseOrTypeError;
  \item $\fieldsp$ is the list with $(\vx_i, \vtp_i)$, for $i=1..k$;
  \item $\newty$ is the AST node with AST label $L$ (either record type or exception type,
  corresponding to the type $\tty$) and fields $\fieldsp$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  L \in \{\TRecord, \TException\}\\
  \fields \eqname [i=1..k: (\vx_i, \vt_i)]\\
  \checknoduplicates(\vx_{1..k}) \typearrow \True \OrTypeError\\\\
  i=1..k: \annotatetype{\False, \tenv, \vt_i} \typearrow (\vtp_i, \vxs_i) \OrTypeError\\\\
  \fieldsp \eqdef [i=1..k: (\vx_i, \vtp_i)]\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype{\True, \tenv, L(\fields)} \typearrow (\overname{L(\fieldsp)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TStructuredDeclBegin}{\TStructuredDeclEnd}{../Typing.ml}

\subsubsection{Example}
In \listingref{typing-trecord}, all the uses of record or exception types are well-typed.
\ASLListing{Well-typed structured types}{typing-trecord}{\typingtests/TypingRule.TRecordExceptionDecl.asl}

\hypertarget{exceptiontypeterm}{}
\section{Exception Types\label{sec:ExceptionTypes}}
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Texception \parsesep \Nfieldsopt &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TException(\Field^{*}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TException}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\Texception, \punnode{\Nfieldsopt})) \astarrow
  \overname{\TException(\astof{\vfieldsopt})}{\vastnode}
}
\end{mathpar}

\subsection{Typing Exception Types}
The rule for typing exception types is \TypingRuleRef{TStructuredDecl}.

\hypertarget{namedtypeterm}{}
\section{Named Types\label{sec:NamedTypes}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TNamed(\overtext{\identifier}{type name}) &
\end{flalign*}

\ASTRuleDef{Ty.TNamed}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tidentifier(\id))) \astarrow
  \overname{\TNamed(\id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing Named Types\label{sec:TypingNamedTypes}}
\TypingRuleDef{TNamed}
\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the named type $\vx$, that is $\TNamed(\vx)$;
  \item checking whether $\vx$ is bound to any declared type in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\vx$ is bound to a type with associated \timeframeterm\ $\vtimeframe$;
  \item define $\vses$ as the singleton set for the \ReadGlobalTerm\ for $\vx$, $\vtimeframe$, and $\True$ for immutability;
  \item $\newty$ is $\tty$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checktrans{G^\tenv.\declaredtypes(\vx) \neq \bot}{\UndefinedIdentifier} \typearrow \True \OrTypeError\\\\
  G^\tenv.\declaredtypes(\vx) = (\Ignore, \vtimeframe)\\
  \vses \eqdef \{\ \ReadGlobal(\vx, \vtimeframe, \True)\ \}
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TNamed(\vx)}{\tty}} \typearrow (\overname{\TNamed(\vx)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TNamedBegin}{\TNamedEnd}{../Typing.ml}

\subsubsection{Example}
In \listingref{typing-tnamed}, all the uses of \texttt{MyType} are well-typed.
\ASLListing{Well-typed named types}{typing-tnamed}{\typingtests/TypingRule.TNamed.asl}

\section{Declared Types\label{sec:DeclaredTypes}}
A declared type can be an enumeration type, a record type, an exception type, or an \anonymoustype.
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\ASTRuleDef{TyDecl}
\begin{mathpar}
\inferrule[ty]{}{
  \buildtydecl(\Ntydecl(\punnode{\Nty})) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\subsection{Typing Declared Types}
\lrmcomment{\identr{RGRVJ}}
\RequirementDef{RestrictionsOnAnonymousTypes}
A declared type for an enumeration, a record type, or an exception type
are only permitted in named type declarations. This is enforced by \TypingRuleRef{TNonDecl}.
%
See \ExampleRef{Ill-typed pending-constrained integer type}.

\TypingRuleDef{TNonDecl}
\subsubsection{Example}
In \listingref{typing-trecorderror}, the use of a record type outside of a declaration is erroneous.
\ASLListing{An erroneous use of a record type}{typing-trecorderror}{\typingtests/TypingRule.TNonDecl.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is a \structuredtype\ or an enumeration type;
  \item $\decl$ is $\False$, indicating that $\tty$ should be considered to be outside the context of a declaration
  of $\tty$;
  \item a type error is returned, indicating that the use of anonymous form of enumerations, record,
  and exceptions types is not allowed here.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \astlabel(\tty) \in \{\TEnum, \TRecord, \TException\}
}{
  \annotatetype{\False, \tenv, \tty} \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\TNonDeclBegin}{\TNonDeclEnd}{../Typing.ml}

\input{TypeDomains.tex}
\input{TypeAttributes.tex}
\input{RelationsOnTypes.tex}
\input{BaseValues.tex}
