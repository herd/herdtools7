\chapter{Types\label{chap:Types}}

Types describe the allowed values of variables, constants, function arguments, etc.
\identi{BYVL}

This chapter first describes how types are represented formally (see \secref{FormalRepresentationofTypes}).
Next, we introduce each type available in ASL and define
how it is represented in the syntax and AST, and how it is typechecked:
\begin{itemize}
  \item The \integertypeterm{} (see \secref{IntegerTypes})
  \item The \realtypeterm{} (see \secref{RealType})
  \item The \stringtypeterm{} (see \secref{StringType})
  \item The \booleantypeterm{} (see \secref{BooleanType})
  \item The \bitvectortypeterm{} (see \secref{BitvectorTypes})
  \item \Tupletypesterm{} (see \secref{TupleTypes})
  \item \Enumerationtypesterm{} (see \secref{EnumerationTypes})
  \item Array types (see \secref{ArrayTypes})
  \item Record types (see \secref{RecordTypes})
  \item Exception types (see \secref{ExceptionTypes})
  \item Collection types (see \secref{CollectionTypes})
  \item Named types (see \secref{NamedTypes})
\end{itemize}

The chapter then defines the following aspects of types:
\begin{itemize}
\item \secref{DeclaredTypes} defines \emph{declared types} and restrictions over them;
\item \secref{DomainOfValuesForTypes} defines how values are associated with each type;
\item \secref{BasicTypeAttributes} assigns basic properties to types, which are useful
in classifying them;
\item \secref{RelationsOnTypes} defines relations on types that are needed to typecheck
expressions and statements; and
\item \secref{BaseValues} defines how to produce an expression to initialize storage
      elements of a given type (for which no initializing expression is supplied).
\end{itemize}

\section{Formal Representation of Types\label{sec:FormalRepresentationofTypes}}
\Anonymoustypes\ are grammatically derived from the non-terminal $\Nty$
and types that must be declared and named are grammatically derived from the non-terminal $\Ntydecl$.
The type system represents types by their AST, which is derived from the non-terminal $\ty$.

\subsection{Abstract Syntax}
\hypertarget{build-ty}{}
The function
\[
  \buildty(\overname{\parsenode{\Nty}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms an anonymous type parse node $\vparsednode$ into the corresponding AST node $\vastnode$.
\ProseOtherwiseBuildError

We define $\buildty$ per type in the following sections.

\hypertarget{build-tydecl}{}
The function
\[
  \buildtydecl(\overname{\parsenode{\Ntydecl}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms a \namedtype\ parse node $\vparsednode$ into an AST node $\vastnode$.
\ProseOtherwiseBuildError

We define $\buildtydecl$ per the corresponding type in the following sections.

\hypertarget{build-as-ty}{}
The function
\[
  \buildasty(\overname{\parsenode{\Nasty}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms a type annotation parse node $\vparsednode$ into a type AST node $\vastnode$.
\ProseOtherwiseBuildError

Formally:
\begin{mathpar}
\inferrule{
  \buildty(\vt) \astarrow \astversion{\vt}
} {
  \buildasty(\Tcolon, \namednode{\vt}{\Nty}) \astarrow \astversion{\vt}
}
\end{mathpar}

\subsection{Typing}
\hypertarget{def-annotatetype}{}
The function
\[
  \annotatetype{\overname{\Bool}{\vdecl} \aslsep \overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}}
  \aslto (\overname{\ty}{\newty} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
typechecks a type $\tty$ in a static environment $\tenv$,
resulting in a \typedast\ $\newty$ and a \sideeffectsetterm\ $\vses$.
The flag $\decl$ indicates whether $\tty$ is a type currently being declared or not,
and makes a difference only when $\tty$ is an \enumerationtypeterm{} or a \structuredtype.
\ProseOtherwiseTypeError

\subsection{Semantics}
Types are not evaluated dynamically.
However, the dynamic semantics of types is given by their \emph{domain of values},
which is defined in \secref{DomainOfValuesForTypes}.

\hypertarget{integertypeterm}{}
\section{Integer Types\label{sec:IntegerTypes}}
The \emph{\integertypesterm{}} represent mathematical integer value.

There are four kinds of integer types, and we
use the term \integertypeterm{} to refer to them collectively:
\emph{unconstrained}, \emph{well-constrained},
\emph{pending constrained}, and \emph{parameterized}.

\subsection{Unconstrained Integer Types}
\hypertarget{def-unconstrainedintegertype}{}
The type \verb|integer| represents all integer values.
\identi{HJBH}%
There is no bound on the minimum and maximum integer value that can be represented.

\ExampleDef{Unconstrained Integer Types}
\listingref{typing-unconstrained} shows examples of unconstrained integer types.
\ASLListing{Well-typed unconstrained integer types}{typing-unconstrained}{\typingtests/TypingRule.TIntUnConstrained.asl}

\subsection{Well-constrained Integer Types}
\identr{GWCP}%
The type \texttt{integer\{$c_1,\ldots,c_n$\}} represents the
union of sets of integers represented by the \emph{integer constraints} $c_1,\ldots,c_n$.
\hypertarget{def-exactconstraintterm}{}
\hypertarget{def-rangeconstraintterm}{}
A constraint can either be an \emph{\exactconstraintterm}, consisting of a single expression like \texttt{4},
or a \emph{\rangeconstraintterm}, consisting of a pair of expressions like \texttt{1..10}.

\ExampleDef{Well-constrained Integer Types}
\hypertarget{def-wellconstrainedintegertype}{}
\listingref{typing-wellconstrained} shows examples of well-constrained integer types.
\ASLListing{Well-typed well-constrained integer types}{typing-wellconstrained}{\typingtests/TypingRule.TIntWellConstrained.asl}

\subsection{Pending-constrained Integer Types}
\hypertarget{def-pendingconstrainedintegertype}{}
The type \verb|integer{-}| represents a well-constrained integer type whose
constraints have yet to be determined.
These constraints are inferred by the type system based on the expression used to initialize
the storage element (see \TypingRuleRef{InheritIntegerConstraints}).

\RequirementDef{PendingConstrainedLHS}
Pending-constrained integer types may only appear on the left-hand-side
of local and global storage element declarations.
They may not appear in \texttt{config} declarations.
%
\listingref{config-pending-constrained} shows an ill-typed specification.

\ExampleDef{Well-typed pending-constrained types}
\listingref{typing-pendingconstrained} shows examples of well-typed pending-constrained
integer types.
\ASLListing{Well-typed pending-constrained integer types}{typing-pendingconstrained}{\typingtests/TypingRule.InheritIntegerConstraints.asl}

\subsection{Parameterized Integer Types}
\hypertarget{def-parameterizedintegertype}{}
Subprogram parameters are implicitly \emph{parameterized integer types},
which represent a singleton set for the integer passed to the parameter
at the call site.

\ExampleDef{Parameterized Integer Types}
\listingref{typing-parameterized} shows examples of well-typed parameterized
integer types.
Notice that the type of the parameter \texttt{M} of the function \texttt{bar}
is a parameterized integer type, \underline{not} an unconstrained integer type.
\ASLListing{Well-typed parameterized integer types}{typing-parameterized}{\typingtests/TypingRule.TIntParameterized.asl}

\subsection{Syntax\label{sec:IntegerTypesSyntax}}
\begin{flalign*}
\Nty \derives\ & \Tinteger \parsesep \Nconstraintkindopt &\\
\Nconstraintkindopt \derives \ & \Nconstraintkind \;|\; \emptysentence &\\
\Nconstraintkind \derives \ & \Tlbrace \parsesep \ClistOne{\Nintconstraint} \parsesep \Trbrace &\\
|\ & \Tlbrace \parsesep \Tminus \parsesep \Trbrace &\\
\Nintconstraint \derives \ & \Nexpr &\\
|\ & \Nexpr \parsesep \Tslicing \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax\label{sec:IntegerTypesAST}}
\begin{flalign*}
\ty \derives\ & \TInt(\constraintkind)\\
\constraintkind \derives\ & \unconstrained
& \\
|\ & \wellconstrained(\intconstraint^{+})
& \\
|\ & \pendingconstrained{}
& \\
|\ & \parameterized(\overtext{\identifier}{parameter}) &\\
\intconstraint \derives\ & \ConstraintExact(\expr)
& \\
|\ & \ConstraintRange(\overtext{\expr}{start}, \overtext{\expr}{end})&
\end{flalign*}

\ASTRuleDef{Ty.TInt}
\begin{mathpar}
\inferrule[integer]{}{
  \buildty(\Nty(\Tinteger, \punnode{\Nconstraintkindopt})) \astarrow
  \overname{\TInt(\astof{\vconstraintkindopt})}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{IntConstraintsOpt}
\hypertarget{build-constraintkindopt}{}
The function
\[
  \buildconstraintkindopt(\overname{\parsenode{\Nconstraintkindopt}}{\vparsednode}) \;\aslto\; \overname{\constraintkind}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[constrained]{}{
  {
    \begin{array}{r}
  \buildconstraintkindopt(\Nconstraintkindopt(\punnode{\Nconstraintkind})) \astarrow \\
  \overname{\astof{\vconstraintkind}}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{}{
  \buildconstraintkindopt(\Nconstraintkindopt(\emptysentence)) \astarrow
  \overname{\unconstrained}{\vastnode}
}
\end{mathpar}

\subsection{ASTRule.IntConstraints\label{sec:ASTRule.IntConstraints}}
\hypertarget{build-constraintkind}{}
The function
\[
  \buildconstraintkind(\overname{\parsenode{\Nconstraintkind}}{\vparsednode}) \;\aslto\; \overname{\constraintkind}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[well\_constrained]{
  \buildclist[\buildintconstraint](\cs) \astarrow \vcsasts
}{
  {
    \begin{array}{r}
  \buildconstraintkind(\Nconstraintkind(\Tlbrace, \namednode{\cs}{\ClistOne{\Nintconstraint}}, \Trbrace)) \astarrow\\
  \overname{\wellconstrained(\vcsasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pending\_constrained]{}{
  \buildconstraintkind(\Nconstraintkind(\Tlbrace, \Tminus, \Trbrace)) \astarrow
  \overname{\pendingconstrained}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{IntConstraint}
\hypertarget{build-intconstraint}{}
The function
\[
  \buildintconstraint(\overname{\parsenode{\Nintconstraint}}{\vparsednode}) \;\aslto\; \overname{\intconstraint}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[exact]{}{
  \buildintconstraint(\Nintconstraint(\punnode{\Nexpr})) \astarrow
  \overname{\ConstraintExact(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \buildexpr(\vfromexpr) \astarrow \astversion{\vfromexpr}\\
  \buildexpr(\vtoexpr) \astarrow \astversion{\vtoexpr}\\
}{
  {
    \begin{array}{r}
  \buildintconstraint(\Nintconstraint(\namednode{\vfromexpr}{\Nexpr}, \Tslicing, \namednode{\vtoexpr}{\Nexpr})) \astarrow\\
  \overname{\ConstraintRange(\astversion{\vfromexpr}, \astversion{\vtoexpr})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing Integer Types\label{sec:TypingIntegerTypes}}
\hypertarget{def-isunconstrainedinteger}{}
\hypertarget{def-isparameterizedinteger}{}
\hypertarget{def-iswellconstrainedinteger}{}
We use the following helper predicates to classify integer types:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \isparameterizedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \iswellconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool
  \end{array}
\]
Those are defined as follows:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\unconstrained\\
  \isparameterizedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\parameterized\\
  \iswellconstrainedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\wellconstrained\\
\end{array}
\]
\identd{ZTPP} \identr{WJYH} \identr{HJPN} \identr{CZTX} \identr{TPHR}

\hypertarget{def-unconstrainedinteger}{}
We use the shorthand notation $\unconstrainedinteger \triangleq \TInt(\unconstrained)$
for unconstrained integers.

\RequirementDef{ConstraintSymbolicallyConstrained}
The expressions appearing in integer constraints must be both
\symbolicallyevaluable{} and \constrainedinteger{} types.
%
In \listingref{annotate-constraint-unconstrained}, the constraint
\verb|x..x+1| is ill-typed, since the type of \texttt{x} is not constrained.
\ASLListing{Ill-typed constraint}{annotate-constraint-unconstrained}{\typingtests/TypingRule.AnnotateConstraint.bad.asl}

\TypingRuleDef{TInt}
\ExampleDef{Ill-typed pending-constrained integer type}
\listingref{config-pending-constrained}
and \listingref{rhs-pending-constrained}
correspond to \CaseName{pending\_constrained}.
\ASLListing{Ill-typed pending-constrained integer type}{config-pending-constrained}
{\typingtests/TypingRule.TInt.config_pending_constrained.bad.asl}

\ASLListing{Ill-typed pending-constrained integer type}{rhs-pending-constrained}
{\typingtests/TypingRule.TInt.rhs_pending_constrained.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{pending\_constrained}
    \begin{itemize}
      \item $\tty$ is a \pendingconstrainedintegertype;
      \item the result is a \typingerrorterm{} (\UnexpectedType).
    \end{itemize}
  \item \AllApplyCase{well\_constrained}
    \begin{itemize}
      \item $\tty$ is the well-constrained integer type constrained by
        constraints $\vc_i$, for $u=1..k$;
      \item annotating each constraint $\vc_i$, for $i=1..k$,
      yields $(\newc_i, \vxs_i)$\ProseOrTypeError;
      \item $\newconstraints$ is the list of annotated constraints $\newc_i$,
      for $i=1..k$;
      \item $\newty$ is the well-constrained integer type constrained
        by $\newconstraints$ with $\PrecisionFull$;
      \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
    \end{itemize}

    \item \AllApplyCase{parameterized}
    \begin{itemize}
      \item $\tty$ is a \parameterizedintegertype\ for $\name$;
      \item define $\vses$ as the singleton set for the singleton \sideeffectdescriptorterm,
            \ReadLocalTerm\ for $\name$, \timeframeconstant, and $\True$ for immutability.
      \item $\newty$ is the unconstrained integer type.
    \end{itemize}

    \item \AllApplyCase{unconstrained}
    \begin{itemize}
      \item $\tty$ is an \unconstrainedintegertype;
      \item $\newty$ is the unconstrained integer type;
      \item define $\vses$ as the empty set.
    \end{itemize}
  \end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[pending\_constrained]{}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TInt(\pendingconstrained)}{\tty}} \typearrow
  \TypeErrorVal{\UnexpectedType}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \constraints \eqname \vc_{1..k}\\
  i=1..k: \annotateconstraint(\vc_i) \typearrow (\newc_i, \vxs_i) \OrTypeError\\\\
  \newconstraints \eqdef \newc_{1..k}\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TInt(\wellconstrained(\constraints))}{\tty}} \typearrow \\
  (\overname{\TInt(\wellconstrained(\newconstraints, \PrecisionFull))}{\newty}, \vses)
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[parameterized]{
  \tty \eqname \TInt(\parameterized(\name))\\
  \vses \eqdef \{\ \ReadLocal(\name, \timeframeconstant, \True)\ \}
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \tty} \typearrow (\overname{\tty}{\newty}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  \tty \eqname \unconstrainedinteger
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \tty} \typearrow (\overname{\tty}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TIntBegin}{\TIntEnd}{../Typing.ml}

\TypingRuleDef{AnnotateConstraint}
\hypertarget{def-annotateconstraint}{}
The function
\[
\begin{array}{r}
\annotateconstraint(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vc})
\aslto (\overname{\intconstraint}{\newc} \times \overname{\TSideEffectSet}{\vses})\ \cup \\
\overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates an integer constraint $\vc$ in the static environment $\tenv$ yielding the annotated
integer constraint $\newc$ and \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\listingref{annotate-constraint} shows examples of \wellconstrainedintegertypes{}
and the resulting annotated constraints in comments.
The annotated constraints inline the constant \texttt{N} and the right-hand-side
expressions of \texttt{let} storage elements.
\ASLListing{Annotated constraints}{annotate-constraint}{\typingtests/TypingRule.AnnotateConstraint.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is the exact integer constraint for the expression $\ve$, that is, \\ $\ConstraintExact(\ve)$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\ve$ in $\tenv$ yields \\
          $(\vep, \vses)$\ProseOrTypeError;
    \item define $\newc$ as the exact integer constraint for $\vep$, that is, $\ConstraintExact(\vep)$.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is the range integer constraint for expressions $\veone$ and $\vetwo$, that is, \\ $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\veone$ in $\tenv$ yields\\ $(\veonep, \vsesone)$\ProseOrTypeError;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\vetwo$ in $\tenv$ yields\\ $(\vetwop, \vsestwo)$\ProseOrTypeError;
    \item define $\newc$ as the range integer constraint for expressions $\veonep$ and $\vetwop$, that is, $\ConstraintRange(\veonep, \vetwop)$;
    \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \annotatesymbolicconstrainedinteger(\tenv, \ve) \typearrow (\vep, \vses) \OrTypeError
}{
  \annotateconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow (\overname{\ConstraintExact(\vep)}{\newc}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \annotatesymbolicconstrainedinteger(\tenv, \veone) \typearrow (\veonep, \vsesone) \OrTypeError\\\\
  \annotatesymbolicconstrainedinteger(\tenv, \vetwo) \typearrow (\vetwop, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  {
  \begin{array}{r}
    \annotateconstraint(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \\
    (\overname{\ConstraintRange(\veonep, \vetwop)}{\newc}, \vses)
  \end{array}
  }
}
\end{mathpar}

\section{The Real Type\label{sec:RealType}}
\hypertarget{realtypeterm}{}
The \emph{\realtypeterm{}} represents mathematical rational number values.
There is no bound on the minimum and maximum rational value that can be represented,
and there is no bound on their precision.
%
There is no mechanism in the language to generate an irrational value of \realtypeterm.

Conversions from an \integertypeterm{} value to a \realtypeterm{} value are performed
using the \stdlibfunc{Real}.
%
Conversions from a \realtypeterm{} value an \integertypeterm{} value to are performed
using the \stdlibfunc{RoundDown}, \stdlibfunc{RoundUp}. and \stdlibfunc{RoundTowardsZero}.

\ExampleDef{Well-typed Real Types}
In \listingref{typing-treal}, all the uses of the \realtypeterm{} are well-typed.
\ASLListing{Well-typed real types}{typing-treal}{\typingtests/TypingRule.TReal.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Treal &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TReal &
\end{flalign*}

\ASTRuleDef{TReal}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Treal)) \astarrow
  \overname{\TReal}{\vastnode}
}
\end{mathpar}

\subsection{Typing the Real Type\label{sec:TypingRealType}}
\TypingRuleDef{TReal}
See \ExampleRef{Well-typed Real Types} for examples of well-typed \realtypeterm{}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \realtypeterm{}, $\TReal$.
  \item $\newty$ is the \realtypeterm{}, $\TReal$;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TReal}{\tty}} \typearrow (\overname{\TReal}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TRealBegin}{\TRealEnd}{../Typing.ml}

\section{The String Type\label{sec:StringType}}
\hypertarget{stringtypeterm}{}
\hypertarget{stringtypesterm}{}
The \emph{\stringtypeterm{}} represents strings of characters.

Strings play relatively little role in specifications and the only operations
on strings are equality and inequality tests.
Strings are useful in \printstatementsterm{} for debugging and diagnostic purposes
on runtimes that support printing.

\ExampleDef{Well-typed String Types}
In \listingref{typing-tstring}, all the uses of the \stringtypeterm{} are well-typed.
\ASLListing{Well-typed string types}{typing-tstring}{\typingtests/TypingRule.TString.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tstring &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TString&
\end{flalign*}

\ASTRuleDef{Ty.String}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tstring)) \astarrow
  \overname{\TString}{\vastnode}
}
\end{mathpar}

\subsection{Typing the String Type\label{sec:TypingStringType}}
\TypingRuleDef{TString}
See \ExampleRef{Well-typed String Types} for examples of well-typed \stringtypesterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \stringtypeterm{}, $\TString$.
  \item $\newty$ is the \stringtypeterm{}, $\TString$.
  \item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TString}{\tty}} \typearrow (\overname{\TString}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TStringBegin}{\TStringEnd}{../Typing.ml}

\section{The Boolean Type\label{sec:BooleanType}}
\hypertarget{booleantypeterm}{}
The \emph{\booleantypeterm{}} represents Booleans.

\ExampleDef{Well-typed Boolean Types}
In \listingref{typing-tbool}, all the uses of the \booleantypeterm{} are well-typed.
\ASLListing{Well-typed Boolean types}{typing-tbool}{\typingtests/TypingRule.TBool.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tboolean &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TBool &
\end{flalign*}

\ASTRuleDef{Ty.BoolType}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tboolean)) \astarrow
  \overname{\TBool}{\vastnode}
}
\end{mathpar}

\subsection{Typing the Boolean Type\label{sec:TypingBooleanType}}
\TypingRuleDef{TBool}
See \ExampleRef{Well-typed Boolean Types} for examples of well-typed \booleantypesterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the boolean type, \TBool;
  \item $\newty$ is the boolean type, \TBool;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TBool}{\tty}} \typearrow (\overname{\TBool}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TBoolBegin}{\TBoolEnd}{../Typing.ml}

\section{Bitvector Types\label{sec:BitvectorTypes}}
\hypertarget{bitvectortypeterm}{}
\emph{Bitvectors} represent sequences of $0$ and $1$ bits.
%
The \texttt{bits(N)} type represents a bitvector of width \texttt{N},
where \texttt{N} may specify a fixed width or a constrained width.
%
The \texttt{bit} type is syntactic sugar for \texttt{bits(1)} (see \ASTRuleRef{Ty.TBits}.\texttt{BIT}).

\identi{KGMC}%
The syntax for \bitvectortypesterm{} has an optional $\Nbitfields$,
which allows specifying \emph{\bitfieldsterm} ---
\bitslicesterm{} of bitvectors --- to be treated as named
fields that can be read or written.
\chapref{Bitfields} defines \bitfieldsterm{}
and \chapref{BitvectorSlicing} defines \bitslicesterm{}.

\RequirementDef{BitvectorWidthImmutable}
The width of a bitvector cannot be modified.

In \listingref{BitvectorSlices}, slicing expressions such as \verb|bv[5:0]|
and bitvector concatenation expressions such as \verb|bv[5:5] :: bv[4:4]|
create new bitvector values without affecting the widths (or values)
of existing bitvector values.

\RequirementDef{BitvectorWidthBounds}
There is no bound on the maximum bitvector width allowed, although an implementation may specify an upper
limit.
%The minimum bound is zero.
It is recognized that zero-width bitvectors might not be supported in systems
to which ASL might be translated (such as SMT solvers),
and an implementation might need to lower bitvector
expressions to a form where zero-width bitvectors do not exist.

In \listingref{BitvectorWidthBounds}, any number can be used instead of \verb|2^20| for
\verb|large_bitvector|, and \verb|zero_width_bitvector| is an example of a zero-width bitvector.

\ASLListing{Large and small bitvectors}{BitvectorWidthBounds}{\definitiontests/GuideRule.BitvectorWidthBounds.asl}

\RequirementDef{BitvectorWidthKind}
The width of a \bitvectortypeterm{} can be either \staticallyevaluable{}
or \emph{constrained}. That is, a \symbolicallyevaluable{} \constrainedinteger{}.

\ExampleDef{Rotating a Bitvector}
\listingref{bits-rotate} shows a specification where the width of the bitvector type
\texttt{bv} is a literal (\verb|bits(5)|), and bitvector types where the width is
constrained (\verb|bits(N)|, \verb|bits(i)|, and \verb|bits(N-i)|),
and related operations,
followed by the output to the console.
\ASLListing{Rotating a bitvector}{bits-rotate}{\definitiontests/Bitvector_rotate.asl}
% CONSOLE_BEGIN aslref \definitiontests/Bitvector_rotate.asl
\begin{Verbatim}[fontsize=\footnotesize, frame=single]
bv=0x14, rotated twice=0x05
\end{Verbatim}
% CONSOLE_END

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tbit &\\
            |\ & \Tbits \parsesep \Tlpar \parsesep \Nexpr \parsesep \Trpar \parsesep \option{\Nbitfields} &\\
\Nbitfields \derives \ & \Tlbrace \parsesep \TClistZero{\Nbitfield} \parsesep \Trbrace &\\
\Nbitfield \derives \ & \Nslices \parsesep \Tidentifier &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Nbitfields &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Tcolon \parsesep \Nty &\\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TBits(\overtext{\expr}{width}, \bitfield^{*}) &
\end{flalign*}

\ASTRuleDef{Ty.TBits}
\begin{mathpar}
\inferrule[bit]{}{
  \buildty(\Nty(\Tbit)) \astarrow
  \overname{\TBits(\ELiteral(\lint(1)), \emptylist)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits]{
  \buildlist[\buildbitfield](\vbitfields) \astarrow \vbitfieldasts
}{
  {
    \begin{array}{r}
  \buildty(\Nty(\Tbits, \Tlpar, \punnode{\Nexpr}, \Trpar, \namednode{\vbitfields}{\maybeemptylist{\Nbitfields}})) \astarrow\\
  \overname{\TBits(\astof{\vexpr}, \vbitfieldasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing Bitvector Types}
\TypingRuleDef{TBits}
\ExampleDef{Well-typed Bitvector Types}
In \listingref{typing-tbits}, all the uses of bitvector types are well-typed.
\ASLListing{Well-typed Bitvector types}{typing-tbits}{\typingtests/TypingRule.TBits.asl}

\ExampleRef{A bitvector type with bitfields} shows a well-typed \bitvectortypeterm{} with bitfields.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \bitvectortypeterm{} with width given by the expression
    $\ewidth$ and the bitfields given by $\bitfields$, that is, $\TBits(\ewidth, \bitfields)$;
  \item annotating the expression $\ewidth$ yields $(\twidth, \ewidthp, \seswidth)$\ProseOrTypeError;
  \item \Prosechecksymbolicallyevaluable{\seswidth};
  \item \Prosecheckconstrainedinteger{$\tenv$}{$\twidth$};
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{with\_bitfields}
    \begin{itemize}
      \item $\bitfields$ is not empty;
      \item checking whether all \timeframesterm{} in $\seswidth$ are less than or equal to $\timeframeconstant$
            yields $\True$\ProseTerminateAs{\SideEffectViolation};
      \item annotating the bitfields $\bitfields$ yields \\
            $(\bitfieldsp, \vsesbitfields)$\ProseOrTypeError;
      \item \Prosestaticeval{$\tenv$}{$\ewidthp$}{$\lint(\vwidth)$};
      \item \Prosecheckcommonbitfieldsalign{$\tenv$}{$\bitfieldsp$}{$\vwidth$}\ProseOrTypeError;
      \item \Proseeqdef{$\newty$}{the \bitvectortypeterm{} with width given by the expression
            $\ewidthp$ and the bitfields given by $\bitfieldsp$, that is, \\
            $\TBits(\ewidthp, \bitfieldsp)$};
      \item \Proseeqdef{$\vses$}{the union of $\seswidth$ and $\vsesbitfields$}.
    \end{itemize}

    \item \AllApplyCase{no\_bitfields}
    \begin{itemize}
      \item $\bitfields$ is empty;
      \item \Proseeqdef{$\newty$}{the \bitvectortypeterm{} with width given by the expression
            $\ewidthp$ and an empty list of bitfields, that is,
            $\TBits(\ewidthp, \emptylist)$};
      \item \Proseeqdef{$\vses$}{$\seswidth$}.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[with\_bitfields]{
  \annotateexpr{\tenv, \ewidth} \typearrow (\twidth, \ewidthp, \seswidth) \OrTypeError\\\\
  \checksymbolicallyevaluable(\seswidth) \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \twidth) \typearrow \True \OrTypeError\\\\
  \commonprefixline\\\\
  \bitfields \neq \emptylist\\\\
  \checktrans{\sesisbefore(\seswidth, \timeframeconstant)}{\SideEffectViolation} \typearrow \True \OrTypeError\\\\
  {
  \begin{array}{r}
    \annotatebitfields(\tenv, \ewidthp, \bitfields) \typearrow \\
    (\bitfieldsp, \vsesbitfields) \OrTypeError
  \end{array}
  }\\
  \staticeval(\tenv, \ewidthp) \typearrow \lint(\vwidth) \OrTypeError\\\\
  \checkcommonbitfieldsalign(\tenv, \bitfieldsp, \vwidth) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \seswidth \cup \vsesbitfields
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \TBits(\ewidth, \bitfields)} \typearrow \\
  (\overname{\TBits(\ewidthp, \bitfieldsp)}{\newty}, \vses)
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_bitfields]{
  \annotateexpr{\tenv, \ewidth} \typearrow (\twidth, \ewidthp, \seswidth) \OrTypeError\\\\
  \checksymbolicallyevaluable(\seswidth) \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \twidth) \typearrow \True \OrTypeError\\\\
  \commonprefixline\\\\
  \bitfields = \emptylist
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \TBits(\ewidth, \bitfields)} \typearrow \\
  (\overname{\TBits(\ewidthp, \bitfieldsp)}{\newty}, \overname{\seswidth}{\seswidth})
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\TBitsBegin}{\TBitsEnd}{../Typing.ml}

\section{Tuple Types\label{sec:TupleTypes}}
\hypertarget{tupletypeterm}{}

Types can be combined into \tupletypesterm{} whose values consist of tuples of values of those types.
For example, the expression \verb|(TRUE, Zeros{32})| has type \verb|(boolean, bits(32))|.

\ExampleDef{Well-typed Tuples}
In \listingref{typing-ttuple}, all the uses of \tupletypesterm{} are well-typed.
\ASLListing{Well-typed tuple types}{typing-ttuple}{\typingtests/TypingRule.TTuple.asl}

\RequirementDef{TupleLength}
A \tupletypeterm{} must contain at least two elements.

In \listingref{TupleLength}, both \verb|x| and \verb|y| have tuple types,
whereas \verb|w| and \verb|z| are of the \integertypeterm, since \verb|(5)|
is considered a parenthesized expressions, not a tuple expression.
\ASLListing{Tuples and parenthesized expressions}{TupleLength}{\definitiontests/GuideRule.TupleLength.asl}

\RequirementDef{TupleImmutability}
The value and type of tuple elements cannot be modified.

\listingref{TupleImmutability} demonstrates how variables of a \tupletypeterm{} may be assigned,
but the tuple values they store may not be modified.
\ASLListing{Immutability of tuple values}{TupleImmutability}{\definitiontests/GuideRule.TupleImmutability.asl}

\RequirementDef{TupleElementAccess}
The $k+1$ element of a tuple \verb|t| with $n>1$ elements
can be accessed via the \texttt{t.item$k$} notation,
as long as $0 \leq k < n$.

\listingref{TupleElementAccess} shows examples of accessing the elements
of the tuple stored in \verb|x|.
\ASLListing{Accessing tuple elements}{TupleElementAccess}{\definitiontests/GuideRule.TupleElementAccess.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \PlistZero{\Nty} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TTuple(\ty^{*}) &
\end{flalign*}

\ASTRuleDef{Ty.TTuple}
\begin{mathpar}
\inferrule{
  \buildplist[\buildty](\vtypes) \astarrow \vtypeasts
}{
  \buildty(\Nty(\namednode{\vtypes}{\PlistZero{\Nty}})) \astarrow
  \overname{\TTuple(\vtypeasts)}{\vastnode}
}
\end{mathpar}

\subsection{Typing Tuple Types\label{sec:TypingTupleTypes}}
\TypingRuleDef{TTuple}
See \ExampleRef{Well-typed Tuples} for examples of well-typed \tupletypesterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \Prosetupletype{$\tys$}, that is, $\TTuple(\tys)$;
  \item $\tys$ is the list $\tty_i$, for $i=1..k$ and $k>1$;
  \item annotating each type $\tty_i$ in $\tenv$, for $i=1..k$,
        yields $(\ttyp_i, \vxs_i)$\ProseOrTypeError;
  \item $\newty$ is the \Prosetupletype{$\ttyp_i$}, for $i=1..k$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  k \geq 2\\
  \tys \eqname \tty_{1..k}\\
  i=1..k: \annotatetype{\False, \tenv, \tty_i} \typearrow (\ttyp_i, \vxs_i) \OrTypeError\\\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \TTuple(\tys)} \typearrow (\overname{\TTuple(\tysp)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TTupleBegin}{\TTupleEnd}{../Typing.ml}

\section{Enumeration Types\label{sec:EnumerationTypes}}
\hypertarget{enumerationtypeterm}{}
The \emph{\enumerationtypeterm} defines a list of enumeration literals,
also referred to as \emph{labels}, that act
as global constants that can be compared for equality and inequality and used
as indices in enumeration-indexed arrays.
%
The type of an enumeration literal is the anonymous \enumerationtypeterm{}
that defined the literal.
\identd{YZBQ} \identr{HJYJ}

\identi{PRPY}%
Unlike many languages, there is no ordering defined for enumeration literals
and therefore enumeration types do not support ordering comparisons such as \verb|<=|.

\ExampleDef{Well-typed Enumeration Types}
\listingref{typing-tenum} shows an example of a well-typed enumeration type declaration.
\ASLListing{Well-typed enumeration type}{typing-tenum}{\typingtests/TypingRule.TEnumDecl.asl}

\identr{DWSP} \identr{QMWT} \identi{MZXL}%
\RequirementDef{LabelNamespace}
Enumeration literals exist in the same namespace as all other declared identifiers except subprograms (see \RequirementRef{GlobalNamespace}),
including storage elements and named types, so no other declared identifier
may have the same name in the same scope.
In particular, this means that an enumeration literal can be declared in
at most one \enumerationtypeterm{} declaration.

See \ExampleRef{Well-typed Enumeration Types} and \ExampleRef{Ill-typed Enumeration Type Declarations}.

\RequirementDef{AnonymousEnumerations}
Enumeration types are only allowed in declarations.

\listingref{AnonymousEnumerations} shows an illegal specification
where an enumeration is used outside of a type definition.
\ASLListing{An illegal enumeration use}{AnonymousEnumerations}{\definitiontests/GuideRule.AnonymousEnumerations.bad.asl}

\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Tenumeration \parsesep \Tlbrace \parsesep \TClistOne{\Tidentifier} \parsesep \Trbrace &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TEnum(\overtext{\identifier^{*}}{labels}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TEnum}
\begin{mathpar}
\inferrule{
  \buildtclist[\buildidentity](\vids) \astarrow \vidasts
}{
  {
    \begin{array}{r}
  \buildtydecl(\Ntydecl(\Tenumeration, \Tlbrace, \namednode{\vids}{\TClistOne{\Tidentifier}}, \Trbrace)) \astarrow\\
  \overname{\TEnum(\vidasts)}{\vastnode}
\end{array}
  }
}
\end{mathpar}

\subsection{Typing Enumeration Types\label{sec:TypingEnumerationTypes}}
\TypingRuleDef{TEnumDecl}
See \ExampleRef{Well-typed Enumeration Types} for examples of well-typed \enumerationtypesterm{}
declarations.

\ExampleDef{Ill-typed Enumeration Type Declarations}
\listingref{typing-tenum-bad} shows examples of ill-typed enumeration type declarations.
\ASLListing{Ill-typed enumeration types}{typing-tenum-bad}{\typingtests/TypingRule.TEnumDecl.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the \enumerationtypeterm{} with enumeration literals
        $\vli$, that is, $\TEnum(\vli)$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item determining that $\vli$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item determining that none of the labels in $\vli$ is declared in the global environment
  yields $\True$\ProseOrTypeError;
  \item $\newty$ is the \enumerationtypeterm{} $\tty$;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checknoduplicates(\vli) \typearrow \True \OrTypeError\\\\
  \vl \in \vli: \checkvarnotingenv{G^\tenv, \vl} \typearrow \True \OrTypeError
}{
  \annotatetype{\True, \tenv, \TEnum(\vli)} \typearrow (\overname{\TEnum(\vli)}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TEnumDeclBegin}{\TEnumDeclEnd}{../Typing.ml}

\section{Array Types\label{sec:ArrayTypes}}
\hypertarget{arraytypeterm}{}
\identr{DFXJ}%
Arrays are sequences of values of a single given type.
The syntax \verb|array [[expr]] of ty| declares a single-dimensional array of type \texttt{ty}
with an index type derived from the expression \texttt{expr}.
%
\identr{YHNV}%
ASL offers two kinds of arrays:
\hypertarget{intarraytypeterm}{}
\hypertarget{enumarraytypeterm}{}
\begin{description}
  \item[\Intarraytypeterm] represents a consecutive list of elements at positions $0$ to the size
      specified for the array. The array elements can be accessed via an \integertypeterm{}
      that specifies the $0$-based position of the element to read/update.
  \item[\Enumarraytypeterm] represents a dictionary-like data type where the keys are defined
      by a given \enumerationtypeterm{}. The array elements can be accessed via values of the
      \enumerationtypeterm{} specified for the array type.
\end{description}

\RequirementDef{ArrayLengthImmutable}
The length of an \intarraytypeterm{} cannot be modified.
% NO_EXAMPLE

\RequirementDef{ArrayLengthExpression}
The length expression of an \intarraytypeterm{} must be a \symbolicallyevaluable{}
expression whose \underlyingtype{} is an \integertypeterm{} .

\ExampleDef{Well-typed Array Types}
In \listingref{typing-tarray}, all the uses of array types are well-typed.
\ASLListing{Well-typed array types}{typing-tarray}{\typingtests/TypingRule.TArray.asl}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tarray \parsesep \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket \parsesep \Tof \parsesep \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TArray(\arrayindex, \ty) &\\
\arrayindex \derives\ &  \ArrayLengthExpr(\overtext{\expr}{array length}) &
\end{flalign*}

\ASTRuleDef{Ty.TArray}
\begin{mathpar}
\inferrule{}{
  {
  \begin{array}{r}
    \buildty(\Nty(\Tarray, \Tllbracket, \punnode{\Nexpr}, \Trrbracket, \Tof, \punnode{\Nty})) \astarrow\\
    \overname{\TArray(\ArrayLengthExpr(\astof{\vexpr}), \astof{\tty})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}
\subsection{Typing Array Types\label{sec:TypingArrayTypes}}
\TypingRuleDef{TArray}
See \ExampleRef{Well-typed Array Types} for examples of well-typed
array types.

\ExampleDef{Ill-typed Array Types}
In \listingref{typing-tarray-bad}, the array type for \verb|illegal_array|
is ill-typed, since the expression \verb|non_symbolically_evaluable|
is not \symbolicallyevaluable{}.
\ASLListing{Ill-typed array types}{typing-tarray-bad}{\typingtests/TypingRule.TArray.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the array type with element type $\vt$;
  \item Annotating the type $\vt$ in $\tenv$ yields $(\vtp, \vsest)$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{expr\_is\_enum}
    \begin{itemize}
      \item the array index is $\ve$ and determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via $\getvariableenum$ yields the enumeration variable
      name $\vs$ of size $\vi$, that is, $\langle \vs, \vi \rangle$\ProseOrTypeError;
      \item $\newty$ is the array type indexed by an \enumerationtypeterm{}
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$;
      \item define $\vses$ as $\vsest$.
    \end{itemize}

    \item \AllApplyCase{expr\_not\_enum}
    \begin{itemize}
      \item the array index is $\ve$ and determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via $\getvariableenum$ yields $\None$ (meaning it does not
      correspond to an enumeration)\ProseOrTypeError;
      \item annotating the \symbolicallyevaluable{} integer expression $\ve$ yields\\
      $(\vep, \vsesindex)$\ProseOrTypeError;
      \item $\newty$ the array type indexed by integer bounded by
      the expression $\vep$ and of elements of type $\vtp$, that is,
      $\TArray(\ArrayLengthExpr(\vep), \vtp)$;
      \item define $\vses$ as the union of $\vsest$ and $\vsesindex$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[expr\_is\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow (\vtp, \vsest) \OrTypeError\\\\
  \commonprefixline\\\\
  \getvariableenum(\tenv, \ve) \typearrow \langle \vs, \vlabels \rangle
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\AbbrevTArrayLengthExpr{\ve}{\vt}}{\tty}} \typearrow
  (\overname{\AbbrevTArrayLengthEnum{\ve}{\vlabels}{\vtp}}{\newty}, \overname{\emptyset}{\vsest})
}
\end{mathpar}

\begin{mathpar}
\inferrule[expr\_not\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow (\vtp, \vsest) \OrTypeError\\\\
  \commonprefixline\\\\
  \getvariableenum(\tenv, \ve) \typearrow \None\\
  \annotatesymbolicinteger(\tenv, \ve) \typearrow (\vep, \vsesindex) \OrTypeError\\\\
  \vses \eqdef \vsest \cup \vsesindex
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\AbbrevTArrayLengthExpr{\ve}{\vt}}{\tty}} \typearrow
  (\overname{\AbbrevTArrayLengthExpr{\vep}{\vtp}}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TArrayBegin}{\TArrayEnd}{../Typing.ml}

\TypingRuleDef{GetVariableEnum}
\hypertarget{def-getvariableenum}{}
The function
\[
\getvariableenum(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
\langle (\overname{\identifier}{\vx}, \overname{\identifier^+}{\vlabels})\rangle
\]
tests whether the expression $\ve$ represents a variable of an \enumerationtypeterm{}.
If so, the result is $\vx$ --- the name of the variable and the list of labels $\vlabels$,
declared for the \enumerationtypeterm{}.
Otherwise, the result is $\None$.

\ExampleDef{Retrieving Enumeration Labels from Variable Expressions}
\listingref{typing-getvariableenum} shows examples of retrieving
enumeration labels from variable expressions.
\ASLListing{Retrieving enumeration labels from expressions}{typing-getvariableenum}{\typingtests/TypingRule.GetVariableEnum.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{not\_evar}
  \begin{itemize}
    \item $\ve$ is not a variable expression;
    \item the result is $\None$.
  \end{itemize}

  \item \AllApplyCase{no\_declared\_type}
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is not associated with a type in the global environment of $\tenv$;
    \item the result is $\None$.
  \end{itemize}

  \item \AllApplyCase{declared\_enum}
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtype\ of $\vt$ in $\tenv$ yields an \enumerationtypeterm{} with labels $\vlabels$;
    \item the result is the pair consisting of $\vx$ and $\vlabels$.
  \end{itemize}

  \item \AllApplyCase{declared\_not\_enum}
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtype\ of $\vt$ in $\tenv$ yields a type that is not an \enumerationtypeterm{};
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_evar]{
  \astlabel(\ve) \neq \EVar
}{
  \getvariableenum(\tenv, \ve) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_declared\_type]{
  G^\tenv.\declaredtypes(\vx) = \bot
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_enum]{
  G^\tenv.\declaredtypes(\vx) = (\vt, \Ignore)\\
  \makeanonymous(\tenv, \vt) \typearrow \TEnum(\vlabels)
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \langle(\vx, \vlabels)\rangle
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_not\_enum]{
  G^\tenv.\declaredtypes(\vx) = (\vt, \Ignore)\\
  \makeanonymous(\tenv, \vt) \typearrow \vtone\\
  \astlabel(\vtone) \neq \TEnum
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\identi{PKXK} \identd{YYDW}%
\RequirementDef{SymbolicallyEvaluable}
An expression is \symbolicallyevaluable{} if its evaluation only involves
the use of immutable values.

See \ExampleRef{Annotating Symbolically Evaluable Expressions}.

\TypingRuleDef{AnnotateSymbolicallyEvaluableExpr}
\hypertarget{def-annotatesymbolicallyevaluableexpr}{}
The function
\[
\begin{array}{r}
  \annotatesymbolicallyevaluableexpr(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto \\
  (\overname{\ty}{\vt}\times\overname{\expr}{\vep}\times\overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the expression $\ve$ in the static environment $\tenv$ and checks that it is \symbolicallyevaluable,
yielding the type in $\vt$, the annotated expression $\vep$ and the \sideeffectsetterm{} $\vses$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Symbolically Evaluable Expressions}
\listingref{typing-annotatesymbolicallyevaluableexpr} shows examples of
expressions and classifies them as either \symbolicallyevaluable{} or not.
\ASLListing{Annotating symbolically evaluable Expressions}{typing-annotatesymbolicallyevaluableexpr}
{\typingtests/TypingRule.AnnotateSymbolicallyEvaluableExpr.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseannotateexpr{$\tenv$}{$\ve$}{$(\vt, \vep, \vses)$};
  \item \Prosechecksymbolicallyevaluable{$\vses$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError
}{
  \annotatesymbolicallyevaluableexpr(\tenv, \ve) \typearrow (\vt, \vep, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateSymbolicallyEvaluableExprBegin}{\AnnotateSymbolicallyEvaluableExprEnd}{../Typing.ml}

\TypingRuleDef{AnnotateSymbolicInteger}
\hypertarget{def-annotatesymbolicinteger}{}
The function
\[
  \annotatesymbolicinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  (\overname{\expr}{\vepp} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a \symbolicallyevaluable\ integer expression $\ve$ in the static environment $\tenv$
and returns the annotated expression $\vepp$ as a \normalizedexpressionterm{} and \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ExampleDef{Annotating Symbolically Evaluable Integer Expressions}
The expression \verb|(pure_func(5, 6) + 9) + I| in \listingref{typing-annotatesymbolicallyevaluableexpr}
is both \symbolicallyevaluable{} and its \underlyingtype{} is an \integertypeterm{},
and annotating and normalizing it yields the same expression.
%
Annotating the expression \verb|(3*I + 9) - 2*I|, which is also \symbolicallyevaluable{} and has an
\underlyingtype{} is an \integertypeterm{}, yields the expression \verb|I + 9| after normalization.
%
Annotating the expression \verb|i - 3|, which is also \symbolicallyevaluable{} and has an
\underlyingtype{} is an \integertypeterm{}, yields the expression \verb|6| after normalization.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseannotatesymbolicallyevaluableexpr{$\tenv$}{$\ve$}{$(\vt, \vep, \vses)$\ProseOrTypeError};
  \item determining whether the \underlyingtype{} of $\vt$ is an \integertypeterm{} yields $\True$\ProseOrTypeError;
  \item applying $\normalize$ to $\vep$ in $\tenv$ yields $\vepp$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatesymbolicallyevaluableexpr(\tenv, \ve) \typearrow (\vt, \vep, \vses) \OrTypeError\\\\
  \checkunderlyinginteger(\tenv, \vt) \typearrow \True \OrTypeError\\\\
  \normalize(\tenv, \vep) \typearrow \vepp
}{
  \annotatesymbolicinteger(\tenv, \ve) \typearrow (\vepp, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateSymbolicIntegerBegin}{\AnnotateSymbolicIntegerEnd}{../Typing.ml}

\hypertarget{def-checkunderlyinginteger}{}
\TypingRuleDef{CheckUnderlyingInteger}
The function
\[
  \checkunderlyinginteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \{\True\} \cup \TTypeError
\]
returns $\True$ is $\vt$ is has the \underlyingtype{} of an \integertypeterm{}.
\ProseOtherwiseTypeError

\ExampleDef{Checking for an Underlying Integer Type}
All of the expressions appearing on the right-hand-side of the assignments in
\listingref{typing-annotatesymbolicallyevaluableexpr}
have an \integertypeterm{} as their \underlyingtype{}.
This includes the expression \verb|i - 3|, since the \underlyingtype{}
of \verb|i| is the \unconstrainedintegertype.

\ProseParagraph
\AllApply
\begin{itemize}
  \item determining the \underlyingtype{} of $\vt$ yields $\vtp$\ProseOrTypeError;
  \item checking that $\vtp$ is an \integertypeterm{} yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item the result is $\True$;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \makeanonymous(\tenv, \vt) \typearrow \vtp \OrTypeError\\\\
  \checktrans{\astlabel(\vtp) = \TInt}{\UnexpectedType} \typearrow \True \OrTypeError
}{
  \checkunderlyinginteger(\tenv, \vt) \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckUnderlyingIntegerBegin}{\CheckUnderlyingIntegerEnd}{../Typing.ml}

\section{Record Types\label{sec:RecordTypes}}
\hypertarget{recordtypeterm}{}
\identd{WGQS}%
A record is a \structuredtype{} consisting of a list of field identifiers which denote individual storage elements.
\identr{DXWN}%
A record type is described by specifying for each field identifier its type.

\identr{WFMF}%
The syntax \verb|record| (with no field list) is syntactic sugar for \verb|record {}|.

\ExampleDef{Well-typed Record Types}
In \listingref{typing-trecord}, all the uses of record types are well-typed.
\ASLListing{Well-typed structured types}{typing-trecord}{\typingtests/TypingRule.TRecordDecl.asl}

In \listingref{typing-trecord-bad}, the \recordtypeterm{} \verb|MyRecord|
is ill-typed, since the field \verb|v| repeats.
\ASLListing{A record type with repeated fields}{typing-trecord-bad}{\typingtests/TypingRule.TRecordDecl.bad.asl}

\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Trecord \parsesep \Nfieldsopt &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TRecord(\Field^{*}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TRecord}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\Trecord, \punnode{\Nfieldsopt})) \astarrow
  \overname{\TRecord(\astof{\vfieldsopt})}{\vastnode}
}
\end{mathpar}

\subsection{Typing Record Types\label{sec:TypingRecordTypes}}
\TypingRuleDef{TStructuredDecl}
\ExampleRef{Well-typed Record Types} shows examples of well-typed \recordtypesterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is a \structuredtype\ with AST label $L$;
  \item the list of fields of $\tty$ is $\fields$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item $\fields$ is a list of pairs where the first element is an identifier and the second is a type --- $(\vx_i, \vt_i)$, for $i=1..k$;
  \item checking that the list of field identifiers $\vx_{1..k}$ does not contain duplicates
  yields $\True$\ProseOrTypeError;
  \item annotating each field type $\vt_i$, for $i=1..k$, yields $(\vtp_i, \vxs_i)$
        \ProseOrTypeError;
  \item $\fieldsp$ is the list with $(\vx_i, \vtp_i)$, for $i=1..k$;
  \item $\newty$ is the AST node with AST label $L$ (either record type or exception type,
  corresponding to the type $\tty$) and fields $\fieldsp$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  L \in \{\TRecord, \TException\}\\
  \fields \eqname [i=1..k: (\vx_i, \vt_i)]\\
  \checknoduplicates(\vx_{1..k}) \typearrow \True \OrTypeError\\\\
  i=1..k: \annotatetype{\False, \tenv, \vt_i} \typearrow (\vtp_i, \vxs_i) \OrTypeError\\\\
  \fieldsp \eqdef [i=1..k: (\vx_i, \vtp_i)]\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype{\True, \tenv, \overname{L(\fields)}{\tty}} \typearrow (\overname{L(\fieldsp)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TStructuredDeclBegin}{\TStructuredDeclEnd}{../Typing.ml}

\section{Exception Types\label{sec:ExceptionTypes}}
\hypertarget{exceptiontypeterm}{}
An exception is a \structuredtype{} consisting of a list of field identifiers
which denote individual storage elements.

\identr{KGXL}
The syntax \verb|exception| (with no field list) is syntactic sugar for \verb|exception {}|.

\ExampleDef{Well-typed Exception Types}
In \listingref{typing-texception}, all the uses of exception types are well-typed.
\ASLListing{Well-typed exception types}{typing-texception}{\typingtests/TypingRule.TExceptionDecl.asl}

\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Texception \parsesep \Nfieldsopt &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TException(\Field^{*}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TException}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\Texception, \punnode{\Nfieldsopt})) \astarrow
  \overname{\TException(\astof{\vfieldsopt})}{\vastnode}
}
\end{mathpar}

\subsection{Typing Exception Types}
The rule for typing exception types is \TypingRuleRef{TStructuredDecl}.

\section{Collection Types\label{sec:CollectionTypes}}
\hypertarget{collectiontypeterm}{}

\ASLListing{Collection types}{TCollection}{\typingtests/TypingRule.TCollection.asl}

A collection is a \structuredtype{} consisting of a list of field identifiers
which denote individual storage elements.

\RequirementDef{CollectionsGlobal}
Collections can only be used for global storage elements.
See \listingref{checkisnotcollection} for an ill-typed specification.

\subsection{Syntax}
\begin{flalign*}
  \Ntydecl \derives\ & \Tcollection \parsesep \Nfieldsopt &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
  \ty \derives\ & \TCollection(\Field^{*}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TCollection}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\Tcollection, \punnode{\Nfieldsopt})) \astarrow
  \overname{\TCollection(\astof{\vfieldsopt})}{\vastnode}
}
\end{mathpar}

\section{Typing Collection Types}
\ExampleDef{Typing Collection Types}
\listingref{TCollection} shows examples of well-typed collection types
and ill-typed collection types in comments.
In addition, \listingref{TCollection} shows well-typed storage declarations
utilizing collection types and ill-typed storage declarations utilizing
collection types in comments.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is a \collectiontypeterm{} with the list of fields of $\fields$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item $\fields$ is a list of pairs where the first element is an identifier and the second is a type --- $(\vx_i, \vt_i)$, for $i=1..k$;
  \item checking that the list of field identifiers $\vx_{1..k}$ does not contain duplicates
  yields $\True$\ProseOrTypeError;
  \item annotating each field type $\vt_i$, for $i=1..k$, yields $(\vtp_i, \vxs_i)$
        \ProseOrTypeError;
  \item $\fieldsp$ is the list with $(\vx_i, \vtp_i)$, for $i=1..k$;
  \item checking that the \structure{} of the type $\vtp_i$ in the static environment $\tenv$
        is a \bitvectortypeterm, for every $i$ in $1..k$, yields $\True$\ProseOrTypeError;
  \item $\newty$ is the AST node with AST label $L$ (either record type or exception type,
        corresponding to the type $\tty$) and fields $\fieldsp$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \fields \eqname [i=1..k: (\vx_i, \vt_i)]\\
  \checknoduplicates(\vx_{1..k}) \typearrow \True \OrTypeError\\\\
  i=1..k: \annotatetype{\False, \tenv, \vt_i} \typearrow (\vtp_i, \vxs_i) \OrTypeError\\\\
  \fieldsp \eqdef [i=1..k: (\vx_i, \vtp_i)]\\
  i=1..k: \checkstructurelabel(\tenv, \vtp_i, \TBits) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype{\True, \tenv, \overname{\TCollection(\fields)}{\tty}} \typearrow (\overname{\TCollection(\fieldsp)}{\newty}, \vses)
}
\end{mathpar}

\section{Named Types\label{sec:NamedTypes}}
\hypertarget{namedtypeterm}{}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TNamed(\overtext{\identifier}{type name}) &
\end{flalign*}

\ASTRuleDef{Ty.TNamed}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tidentifier(\id))) \astarrow
  \overname{\TNamed(\id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing Named Types\label{sec:TypingNamedTypes}}
\TypingRuleDef{TNamed}
\ExampleDef{Well-typed Named Types}
In \listingref{typing-tnamed}, all the uses of \texttt{MyType} are well-typed.
\ASLListing{Well-typed named types}{typing-tnamed}{\typingtests/TypingRule.TNamed.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is the named type $\vx$, that is $\TNamed(\vx)$;
  \item checking whether $\vx$ is bound to any declared type in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\vx$ is bound to a type with associated \timeframeterm\ $\vtimeframe$;
  \item define $\vses$ as the singleton set for the \ReadGlobalTerm\ for $\vx$, $\vtimeframe$, and $\True$ for immutability;
  \item $\newty$ is $\tty$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checktrans{G^\tenv.\declaredtypes(\vx) \neq \bot}{\UndefinedIdentifier} \typearrow \True \OrTypeError\\\\
  G^\tenv.\declaredtypes(\vx) = (\Ignore, \vtimeframe)\\
  \vses \eqdef \{\ \ReadGlobal(\vx, \vtimeframe, \True)\ \}
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TNamed(\vx)}{\tty}} \typearrow (\overname{\TNamed(\vx)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TNamedBegin}{\TNamedEnd}{../Typing.ml}

\section{Declared Types\label{sec:DeclaredTypes}}
A declared type can be an \enumerationtypeterm{}, a \recordtypeterm, an \exceptiontypeterm, or an \anonymoustype.
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\ASTRuleDef{TyDecl}
\begin{mathpar}
\inferrule[ty]{}{
  \buildtydecl(\Ntydecl(\punnode{\Nty})) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\subsection{Typing Declared Types}
\identr{RGRVJ}%
\RequirementDef{RestrictionsOnAnonymousTypes}
A declared type for an enumeration, a record type, or an exception type
are only permitted in named type declarations. This is enforced by \TypingRuleRef{TNonDecl}.
%
See \ExampleRef{Ill-typed pending-constrained integer type}.

\TypingRuleDef{TNonDecl}
\ExampleDef{Ill-typed Type Declarations}
In \listingref{typing-trecorderror}, the use of a record type outside of a declaration is erroneous.
\ASLListing{An erroneous use of a record type}{typing-trecorderror}{\typingtests/TypingRule.TNonDecl.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\tty$ is a \structuredtype\ or an \enumerationtypeterm{};
  \item $\decl$ is $\False$, indicating that $\tty$ should be considered to be outside the context of a declaration
  of $\tty$;
  \item a \typingerrorterm{} is returned, indicating that the use of anonymous form of enumerations, record,
  and exceptions types is not allowed here.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \astlabel(\tty) \in \{\TEnum, \TRecord, \TException\}
}{
  \annotatetype{\False, \tenv, \tty} \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\TNonDeclBegin}{\TNonDeclEnd}{../Typing.ml}

\input{TypeDomains.tex}
\input{TypeAttributes.tex}
\input{RelationsOnTypes.tex}
\input{BaseValues.tex}
