\chapter{Formal System \label{chap:FormalSystem}}

This chapter defines the mathematical concepts and notations used throughout this
reference.

\ChapterOutline
\begin{itemize}
  \item \secref{Mathematical Definitions and Notations} defines general mathematical concepts and notations;
  \item \secref{Inference Rules} defines the concept of \emph{inference rules};
  \item \secref{Transition Judgments} explains how \emph{transition judgments} can be used to represent
        relations and functions;
  \item \secref{Configurations} introduces \emph{configurations} as a way of representing compound data;
  \item \secref{FlavoursOfEqualityInRules} explains the kinds of equality notations that are used to
        convey intention in inference rules;
  \item \secref{ASTNotations} introduces AST-related notations that are used in inference rules;
  \item \secref{How to Parse Inference Rules Efficiently} explains how to efficiently parse inference rules,
  \item \secref{ShortCircuitRuleMacros} defines rule macros, which compactly represent multiple rules;
  \item \secref{ConventionallyUsedJudgments} presents commonly used judgments and notations; and
  \item \secref{Rule Naming} explains the naming scheme for inference rules used in this reference.
\end{itemize}

\section{Mathematical Definitions and Notations\label{sec:Mathematical Definitions and Notations}}
\hypertarget{def-triangleq}{}
We use $\triangleq$ to define mathematical concepts.

We define the following sets:
\begin{itemize}
\item \RenderType{N} is the set of natural numbers, including $0$.

\item \RenderType{N_pos} is the set of positive natural numbers (that is, excluding $0$).

\item \RenderType{Z}
is the set of integers.

\item \RenderType{Q}
is the set of rational numbers.

\hypertarget{constant-False}{}
\hypertarget{constant-True}{}
\item \RenderType{Bool}
is the set of ASL Boolean literals, which consists of $\True$ and $\False$.
We employ these literals to represent the corresponding mathematical truth values,
which are used to denote whether logical assertions hold or not.
\hypertarget{def-land}{}
\hypertarget{def-lor}{}
We also employ the mathematical meaning of logical conjunction $\land$, logical disjunction $\lor$,
and logical negation $\neg$, given next.
For a set of Boolean values $A$:
\[
  \begin{array}{rcl}
  \land A &\triangleq&
  \begin{cases}
    \True & \text{if all values in A are }\True\\
    \False & \text{otherwise}
  \end{cases}\\
  \lor A &\triangleq&
  \begin{cases}
    \False & \text{if all values in A are }\False\\
    \True & \text{otherwise}
  \end{cases}\\
\end{array}
\]
\hypertarget{def-neg}{}
For a pair of Boolean values $a,b\in\Bool$, we define $a \land b \triangleq \land\{a, b\}$
and $a \lor b \triangleq \lor\{a, b\}$.
Finally, $\neg\True\triangleq\False$ and $\neg\False\triangleq\True$.

\item \RenderType{Bit}
is the set $\{0,1\}$. That is, a single bit.

\item \RenderType{Identifier}
is the set of all ASL identifiers.

\item \RenderType{Strings}
is the set of all ASCII strings.

\item \RenderType{ASTLabels}
is the set of all labels of Abstract Syntax Tree (AST) nodes.
\end{itemize}

We utilize the notation $\overname{a}{b}$ to enable us to name the mathematical term $a$ as $b$ so that
we can refer to it in text. We especially use this to name the input arguments and
output results of functions and relations. For example, the input argument of $\sign$,
defined next, is named $q$.

\hypertarget{def-sign}{}
\begin{definition}[Sign of a Rational Number]
\hypertarget{constant-positivesign}{}
\hypertarget{constant-negativesign}{}
\hypertarget{constant-equalsign}{}
\RenderType{Sign}

The function $\sign : \overname{\Q}{q} \rightarrow \Sign$ returns the sign of $\vq$:
\[
\sign(q) \triangleq \begin{cases}
  \positivesign & \text{if }q > 0\\
  \equalsign & \text{if }q = 0\\
  \negativesign & \text{if }q < 0
\end{cases}
\]
\end{definition}

\begin{definition}[Empty Set]
  The \emph{empty set} --- the set that does not contain any element --- is denoted as \RenderConstant{empty_set}.
\end{definition}

\hypertarget{def-cardinality}{}
\begin{definition}[Set Cardinality]
  For a set $S$, the notation $\cardinality{S}$ stands for the number of elements in $S$.
\end{definition}

\hypertarget{def-pow}{}
\begin{definition}[Powerset]
The \emph{powerset} of a set $A$, denoted as $\pow{A}$, is the set of all subsets of $A$, including the empty set and $A$ itself:
\[
    \pow{A} \triangleq \{ B \;|\; B \subseteq A\} \enspace.
\]
\end{definition}

\hypertarget{def-powfin}{}
\begin{definition}[Powerset of Finite Subsets]
  The \emph{powerset of finite subsets} of a set $A$, denoted as $\powfin{A}$, is the set of all finite subsets (including the empty set) of $A$:
  \[
     \powfin{A} \triangleq \{ B \;|\; B \subseteq A, |B| \in \N\} \enspace.
  \]
\end{definition}

\hypertarget{def-cartimes}{}
\begin{definition}[Cartesian Product]
    The \emph{Cartesian product} of sets $A$ and $B$, denoted $A \cartimes B$,
    is $A \cartimes B \triangleq \{(a,b) \;|\; a \in A, b \in B\}$.
\end{definition}

\hypertarget{def-graphtransitive}{}
\hypertarget{def-graphtransitivereflexive}{}
\begin{definition}[Transitive Closure of a Relation]
We denote the transitive closure of a relation $E = V \times V$ by $\graphtransitive{E}$
and the reflexive-transitive closure of $E$ by $\graphtransitivereflexive{E}$.
\end{definition}

\begin{definition}[Bottom Value]
We use the symbol \RenderConstant{bot} to denote an undefined, or missing, value.
\end{definition}

\hypertarget{def-partialfunc}{}
\hypertarget{def-dom}{}
\begin{definition}[Partial Function\label{def:PartialFunction}]
  A \emph{partial function}, denoted $f : A \partialto B$, is a function from a \underline{subset} of $A$ to $B$.
  The \emph{domain} of a partial function $f$, denoted $\dom(f)$, is the subset of $A$ for which it is defined.
  We write $f(x) = \bot$ to denote that $x$ is not in the domain of $f$, that is, $x \not\in \dom(f)$.
\end{definition}

Notice that the domain of a partial function need not be finite, which is what the following definition covers.

\hypertarget{def-finfunction}{}
\begin{definition}[Finite-domain Function]
The notation $\rightarrowfin$ stands for a function \\ whose domain is finite.
\end{definition}

\hypertarget{def-emptyfunc}{}
\begin{definition}[Empty Function\label{def:EmptyFunction}]
The function with an empty domain is denoted as $\emptyfunc$.
\end{definition}

\begin{definition}[Function Update\label{def:FunctionUpdate}]
  The function denoted as $f[x \mapsto v]$ is a function identical to $f$, except that $x$ is bound
  to $v$. That is, if  $g = f[x \mapsto v]$ then
  \[
    g(z) =
  \begin{cases}
    v     & \text{if } z = x\\
    f(z)  & \text{otherwise } \enspace.
  \end{cases}
  \]

  The notation $\{i=1..k: a_i\mapsto b_i\}$ stands for the function formed from the corresponding input-output pairs:
  $\emptyfunc[a_1\mapsto b_1]\ldots[a_k\mapsto b_k]$.
\end{definition}

\begin{definition}[Function Restriction]
\hypertarget{def-restrictfunc}{}
The \emph{restriction} of a function $f : X \rightarrow Y$ to a subset of its domain
$A \subseteq \dom(f)$, denoted as $\restrictfunc{f}{A}$, is defined
in terms of the set of input-output pairs:
\[
  \restrictfunc{f}{A} \triangleq \{ (x, f(x)) \;|\; x \in A \} \enspace.
\]
\end{definition}

\begin{definition}[Function Graph]
\hypertarget{def-funcgraph}{}
The \emph{graph} of a finite-domain function $f : X \rightarrowfin Y$
is the list of input-output pairs for $f$, given in any order:
\[
\funcgraph(f) \triangleq \{ (x, f(x)) \;|\; x \in \dom(f) \} \enspace.
\]
\end{definition}

Throughout this document, we will annotate arguments of relations and functions, wherever it is useful,
by writing a name or an expression above the corresponding argument type.
This makes it convenient to refer to arguments by referring to the corresponding names, and helps identify
the expressions corresponding to the arguments.
For example,
\[
    \choicename : \overname{\Bool}{b} \cartimes \overname{T}{x} \cartimes \overname{T}{y} \rightarrow \overname{T}{z}
\]
defines a function type and lets us refer to the first argument as $b$, the second argument as $x$,
the third argument as $y$, and to the result as $z$.

A \emph{parametric function} is a function whose domain is not a priori fixed but rather
parameterized by the type of its arguments. An example is the $\choicename$ function where the type $T$ of
$x$, $y$, and $z$ is unspecified and inferred from the context where the function is used.

\hypertarget{def-choice}{}
\begin{definition}[Choice]
The parametric function $\choicename : \overname{\Bool}{b} \cartimes \overname{T}{x} \cartimes \overname{T}{y} \rightarrow \overname{T}{z}$,
is defined as follows:
\[
  \choice{\vb}{x}{y} \triangleq
  \begin{cases}
    x & \text{ if }\vb \text{ is }\True\\
    y & \text{ otherwise}\\
  \end{cases}
\]
\end{definition}

\subsection{Lists}
In the remainder of this document, we use the term \emph{list} and \emph{sequence} interchangeably.

A list of elements \hypertarget{constant-emptylist}{is either empty, denoted by $\emptylist$}, or non-empty.
A non-empty list is either denoted by listing the elements in sequence, $v_1 \ldots\ v_k$,
or in bracketed form, $[v_1,\ldots,v_k]$, which is used to aesthetically separate it from surrounding mathematical expressions.
The commas carry no special meaning.

\hypertarget{def-head}{}
\hypertarget{def-tail}{}
For a non-empty list $v_1 \ldots\ v_k$, the \emph{\head} of the list is the first element --- $v_1$ ---
and the \emph{\tail} of the list is the suffix obtained by removing $v_1$ from the list.

We refer to individual elements of a non-empty list $V$ by the index notation $V[i]$ where $i\in\Npos$.

\hypertarget{def-listlen}{}
\begin{definition}[List Length]
The \emph{length} of a list is the number of elements in that list:
$\listlen{\emptylist} \triangleq 0$ and $\listlen{v_1,\ldots,v_k}=k$.
\end{definition}

We use the notation $a..b$, where $a,b\in\Z$ and as a shorthand for the interval $[a\ldots b]$
(counting up when $a \leq b$ and counting down when $a \geq b$).
We write $x_{a..b}$ as a shorthand for the sequence $x_a \ldots x_b$.
%
We write $i=1..k: V(i)$, where $V(i)$ is a mathematical expression parameterized by $i$,
to denote the sequence of expressions $V(1) \ldots V(k)$.
The notation $a \in A: V(a)$, where $A$ is a set and $V$ is an expression parameterized by the free variable $a$,
stands for $V(a_1) \ldots V(a_k)$ where $a_{1..k}$ is an arbitrary ordering of the elements of $A$.

\hypertarget{def-kleenestar}{}
\hypertarget{def-kleeneplus}{}
We write $\KleeneStar{T}$ to denote a the type of a possibly-empty list of elements of type $T$,
and $\KleenePlus{T}$ for a non-empty list of elements of type $T$.

\hypertarget{def-inlist}{}
We slightly abuse notation by employing the notation for set membership to lists.
Formally, the notation $e \inlist L$ where $e \in T$ and $L \in \KleeneStar{T}$ stands for $\exists i\in\N.\ L[i]=e$.

\hypertarget{def-listset}{}
\begin{definition}[Listing a Set]
The parametric relation $\listset : \pow{T} \times \KleeneStar{T}$
lists the elements of a set in an arbitrary order:
\[
\begin{array}{c}
  \listset(X) = x_{1..k}\\
  |X| = k\\
  \forall x\in X.\ \exists 1 \leq i \leq k.\ x = x_i
\end{array}
\]
\end{definition}

\hypertarget{def-concat}{}
\begin{definition}[List Concatenation]
The parametric function $\concat : \KleeneStar{T} \cartimes \KleeneStar{T} \rightarrow \KleeneStar{T}$ concatenates two lists:
\[
    \begin{array}{rcl}
    \emptylist \concat L &\triangleq& L\\
    L \concat \emptylist &\triangleq& L\\
    l_{1..k} \concat m_{1..n} &\triangleq& [l_{1..k}, m_{1..n}]
    \end{array}
\]
\end{definition}

\hypertarget{def-concatlist}{}
\begin{definition}[Concatenation of a List of Lists]
The parametric function\\
$\concatlist : \KleeneStar{\left(\KleeneStar{T}\right)} \rightarrow \KleeneStar{T}$ concatenates a list of lists:
\[
  \begin{array}{rcl}
    \concatlist(\emptylist) &\triangleq& \emptylist\\
    \concatlist(l_{1..k}) &\triangleq& l_1 \concat \ldots \concat l_k \\
  \end{array}
\]
\end{definition}

\hypertarget{def-equallength}{}
\begin{definition}[Equating List Lengths]
The parametric function
\[
  \equallength : \overname{L}{a} \cartimes \overname{L}{b} \rightarrow \Bool
\]
compares the length of two lists:
\[
\equallength(a, b) \triangleq \listlen{a}=\listlen{b} \enspace.
\]
\end{definition}

\hypertarget{def-listprefix}{}
\begin{definition}[List Prefix]
The parametric function $\listprefix : \overname{\KleeneStar{T}}{\vlone} \cartimes \overname{\KleeneStar{T}}{\vltwo} \rightarrow \Bool$ checks whether
the list $\vlone$ is a \emph{prefix} of the list $\vltwo$:
\[
\listprefix(\vlone, \vltwo) \triangleq \exists \vlthree.\ \vltwo = \vlone \concat \vlthree \enspace.
\]
\end{definition}

\hypertarget{def-listrange}{}
\begin{definition}[Indices of a List]
The parametric function $\listrange : \KleeneStar{T} \rightarrow \KleeneStar{\N}$ returns the ($1$-based) list of indices for a given list:
\[
    \begin{array}{rcl}
        \listrange(\emptylist) &\triangleq& \emptylist\\
        \listrange(v_{1..k}) &\triangleq& [1..k] \enspace.
    \end{array}
\]
\end{definition}

\hypertarget{def-unziplist}{}
\begin{definition}[Unzipping a List of Pairs]
The parametric function
\[
\unziplist : \KleeneStar{(T_1 \cartimes T_2)} \rightarrow (\KleeneStar{T_1} \cartimes \KleeneStar{T_2})
\]
transforms a list of pairs into the corresponding pair of lists:
\[
  \unziplist(\pairs) \triangleq \begin{cases}
    (\emptylist, \emptylist)  & \text{if }\pairs = \emptylist\\
    (a_{1..k}, b_{1..k})      & \text{else }\pairs = (a_1,b_1) \ldots (a_k,b_k)  \enspace.
  \end{cases}
\]
\end{definition}

\hypertarget{def-unziplistthree}{}
\begin{definition}[Unzipping a List of Triples]
The parametric function
\[
\unziplistthree : \KleeneStar{(T_1 \cartimes T_2 \cartimes T_3)} \rightarrow (\KleeneStar{T_1} \cartimes \KleeneStar{T_2} \cartimes \KleeneStar{T_3})
\]
transforms a list of triples into the corresponding triple of lists:
\[
  \unziplistthree(\triples) \triangleq \begin{cases}
    (\emptylist, \emptylist, \emptylist)  & \text{if }\triples = \emptylist\\
    (a_{1..k}, b_{1..k}, c_{1..k})      & \text{else }\triples = (a_1,b_1,c_1) \ldots (a_k,b_k,c_k)  \enspace.
  \end{cases}
\]
\end{definition}

\hypertarget{def-uniquelist}{}
\hypertarget{def-uniquep}{}
\begin{definition}[Finding unique elements of a list]
The parametric function
\[
\uniquelist : \overname{\KleeneStar{T}}{l} \rightarrow \KleeneStar{T}
\]
retains only the first occurrence of each element of the list $l$.
It relies on the helper function $\uniquep$:
\[
\begin{array}{rcl}
\uniquelist(l) &\triangleq& \uniquep(l, \emptylist)\\\\
\uniquep(\emptylist, \acc) &\triangleq& \acc\\
\uniquep([h] \concat t, \acc) &\triangleq&
  \begin{cases}
    \uniquep(t, \acc) & \text{if }h \inlist t\\
    \uniquep(t, \acc \concat [h]) & \text{otherwise}\\
  \end{cases}
\end{array}
\]
\end{definition}

\subsection{Strings}
\hypertarget{def-stringconcat}{}
The function $\stringconcat : \Strings \times \Strings \rightarrow \Strings$
concatenates two strings.

\hypertarget{def-stringofnat}{}
The function $\stringofnat : \N \rightarrow \Strings$ converts a natural number
to the corresponding string.

\subsection{OCaml-style Notations}
We use the following notations, which are in the style of the OCaml programming language,
to facilitate correspondence with our
\href{https://github.com/herd/herdtools7/tree/master/asllib}{reference implementation}.

The notation $L(v_{1..k})$ is a compound term where $L$ is a label and $v_{1..k}$ is a (possibly singleton) list of mathematical values.
We also write $L(T_{1..k})$, where $T_{1..k}$ denotes mathematical types of values, to stand for the type
$\{ L(v_{1..k}) \;|\; v_1\in T_1,\ldots,v_k\in T_k \}$.

\hypertarget{def-Option}{}
\begin{definition}[Optional Data Type]
\hypertarget{def-some}{}
The notation $\some{x} \triangleq \{x\}$ stands for a singleton
set containing $x$.
%
The constant \RenderConstant{None} is an alias for the empty
set. It is used in places where either the empty set or a singleton set is expected.
%
The type $\Option{T} \triangleq \{ \None \} \cup \{ \some{x} \;|\; x\in T\}$ denotes
all singleton sets of elements from $T$ as well as the empty set.
%
We refer to $\Option{T}$ as the \emph{optional data type for the parameter
type $T$}, or shortly as an \emph{\optionalterm}.

To avoid having too many parentheses, instead of writing $\Option{(a, b, c)}$
for a singleton set for the tuple $(a, b, c)$, we will write $\Option{a, b, c}$.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Inference Rules\label{sec:Inference Rules}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-inferencerule}{}
An \emph{\inferencerule} (rule, for short) is an implication between a list of judgments,
called the \emph{premises} of the rule,
and a \emph{conclusion} judgment.
The conclusion holds when the \underline{conjunction} of the rule premises holds.

We use the following rule notation, where $P_{1..k}$ are the rule premises and $C$ is the conclusion:
\begin{mathpar}
\inferrule{P_1 \and \ldots \and P_k}{C}
\end{mathpar}

For example, the rule \TypingRuleRef{ELit} has one premise:
\begin{mathpar}
\inferrule{
  \annotateliteral(\tenv, \vv) \typearrow \vt
}{
  \annotateexpr(\tenv, \ELiteral(\vv)) \typearrow (\vt, \ELiteral(\vv), \emptyset)
}
\end{mathpar}

and the rule \TypingRuleRef{EBinop} (somewhat simplified here) has four premises:
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vtone, \veonep, \vsesone)\\
  \annotateexpr(\tenv, \vetwo) \typearrow (\vttwo, \vetwop, \vsestwo)\\
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateexpr(\tenv, \EBinop(\op, \veone, \vetwo)) \typearrow (\vt, \EBinop(\op, \veone', \vetwo'), \vses)
}
\end{mathpar}

The free variables appearing in the premises and conclusion are interpreted \underline{universally}.
That is, the rules apply to any values (of the appropriate types) assigned to their free variables.
%
For example, the rule \TypingRuleRef{EBinop} applies to any choice of values for the free variables
$\tenv$ (a \staticenvironmentterm{}),
$\veone$, $\vetwo$, $\veone'$, $\vetwo'$ (expressions),
$\vt$, $\vtone$, and $\vttwo$ (types).

\begin{definition}[Grounding]
Judgments can be \emph{grounded} by substituting their free variables with values.
A \emph{ground rule} is a rule with all its judgments (premises and conclusion) grounded.
\end{definition}
For example,
the following is a grounding of \TypingRuleRef{EBinop}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{r}
  \annotateexpr(\emptytenv, \ELiteral(\LInt(2))) \typearrow \\
  (\TInt, \ELiteral(\LInt(2)), \emptyset)
    \end{array}
  }\\
  {
    \begin{array}{r}
  \annotateexpr(\emptytenv, \ELiteral(\LInt(3))) \typearrow \\
    (\TInt, \ELiteral(\LInt(3)), \emptyset)
    \end{array}
  }\\
  \applybinoptypes(\emptytenv, \MUL, \TInt, \TInt) \typearrow \TInt
}{
  {
    \begin{array}{r}
  \annotateexpr\left(\emptytenv,
  \EBinop\left(\begin{array}{c}
  \MUL,\\
   \ELiteral(\LInt(2)), \\
   \ELiteral(\LInt(3))
   \end{array}
   \right)\right) \typearrow \\
  \left(\TInt, \EBinop\left(
  \begin{array}{c}
  \MUL,\\
   \ELiteral(\LInt(2)), \\
   \ELiteral(\LInt(3))
  \end{array}
  \right), \emptyset\right)
    \end{array}
  }
}
\end{mathpar}
obtained by the following substitutions:
\begin{tabular}{ll}
  \textbf{free variable} & \textbf{value}\\
  \hline
  $\tenv$   & $\emptytenv$\\
  $\veone$  & $\ELiteral(\LInt(2))$\\
  $\veone'$  & $\ELiteral(\LInt(2))$\\
  $\vetwo$  & $\ELiteral(\LInt(3))$\\
  $\vetwo'$  & $\ELiteral(\LInt(3))$\\
  $\vt$    & $\TInt$\\
  $\vtone$    & $\TInt$\\
  $\vttwo$    & $\TInt$\\
  $\op$       & $\MUL$
\end{tabular}

A set of rules is interpreted \underline{disjunctively}. That is, each rule is used to determine whether its conclusion
holds independently of other rules.

\begin{definition}[Axiom]
An \emph{axiom} is a rule with an empty set of premises.
An axiom is denoted by simply stating its conclusion.
\end{definition}

An example of an axiom in the ASL type system is \TypingRuleRef{SPass}:
\begin{mathpar}
\inferrule{}{\annotatestmt(\tenv, \SPass) \typearrow (\SPass,\tenv,\emptyset)}
\end{mathpar}
\hypertarget{SemanticsRule.PAll-example}{}
An example of an axiom in the ASL dynamic semantics is \SemanticsRuleRef{PAll}:
\begin{mathpar}
\inferrule{}{
  \evalpattern(\env, \Ignore, \PatternAll) \evalarrow \ResultPattern(\nvbool(\True), \emptygraph)
}
\end{mathpar}

To show that a specification is correct, with respect to the set of type system rules,
or to show that a specification evaluates to a certain value, with respect to
the set of dynamic semantic rules, we must apply those rules to form a \emph{\derivationtreeterm}.

\hypertarget{def-derivationtree}{}
\begin{definition}[Derivation Tree]
A \emph{\derivationtreeterm} is a tree whose vertices correspond to ground judgments.
Each non-leaf vertex $c$ with children $p_{1..k}$ correspond to a ground rule
$\inferrule{p_{1..k}}{c}$ and each leaf vertex $c$ corresponds to a ground axiom rule
$c$. There is one root vertex, which intuitively is the goal of the derivation tree.
Derivation trees can be finite or infinite.
Infinite derivation trees are used for defining diverging evaluations
(see \secref{Semantics of Diverging Specifications}).
\end{definition}

\section{Transition Judgments\label{sec:Transition Judgments}}

We use rules as a structured way for defining relations (and therefore functions, as a special case).

To define a relation $R \subseteq X \cartimes Y$, we use judgments of the form $\termx \rulearrow \termy$
where $\termx$ and $\termy$ are logical terms denoting sets of elements from $X$ and $Y$, respectively.
%
We call such judgments \emph{transition judgments}.
A set of rules $M$ with transition judgments defines the relation
\[
    R = \{ (x,y) \;|\; x \rulearrow y \text{ can be derived from rules in } M\} \enspace.
\]

For example, the rule \TypingRuleRef{ELit} defines a relation
between the infinite set of elements of the form
$\annotateexpr(\tenv, \ELiteral(\vv))$ (for the
infinite choice of values for the free variables $\tenv$ and
$\vv$) to the infinite set of tuples of the form $(\vt,
\ELiteral(\vv), \emptyset)$, such that the premise holds.

\paragraph{Mutual Exclusion Principle:}
Our rules follow a mutual exclusion principle, where each rule
defines a relation disjoint from the ones defined by the other
rules. This makes it easy to determine the rule responsible
for a given transition.

\hypertarget{def-configuration}{}
\section{Configurations\label{sec:Configurations}}

\hypertarget{def-configdomain}{}
Our relations range over compound values. That is, values that often nest tuples and lists inside other tuples and lists.
We refer to such values as \emph{configurations}. To make it easier to distinguish between different configurations,
we will sometimes attach labels to tuples using the OCaml-style notation discussed earlier.
We refer to those labels as \emph{configuration domains}.
The domain of a configuration $C=L(\ldots)$, denoted $\configdomain{C}$, is the label $L$.

We refer to configurations at the origin of a transition as \emph{input configurations} and to the
configurations at the destination of a transition as \emph{output configurations}.

For example, the conclusion of the rule \TypingRuleRef{ELit} has \\
$\annotateexpr(\tenv, \ELiteral(\vv))$ as its input configuration
and \\
$(\vt, \ELiteral(\vv), \emptyset)$ as its output configuration.
Further, \\
$\configdomain{\annotateexpr(\tenv, \ELiteral(\vv))} = \annotateexpr$,
while the output configuration does not have a configuration domain, since it is an unlabelled tuple.

Our rules always make use of labelled input configurations. This makes it easier to ensure
the mutual exclusion rule principle.

Our rules always define relations whose sets of input configurations and output configurations are disjoint.

\hypertarget{def-freshvariables}{}
\begin{definition}[Fresh Element]
  Premises of the form \texttt{$x\in T$ is fresh} mean that in any
  instantiation in a derivation tree, the value of $x$ is unique.
  That is, different from all other values instantiated for any other variable.
\end{definition}

\hypertarget{def-ignore}{}
\begin{definition}[Ignore Variable]
To keep rules succinct, we write $\Ignore$ for a mathematical variable whose name is
irrelevant for understanding the rule, and can thus be omitted.
Each \underline{occurrence} of $\Ignore$ represents a variable whose name is
different from any other free variable in the rule.
\end{definition}

For example, the rule \SemanticsRuleRef{PAll}, shown \hyperlink{SemanticsRule.PAll-example}{above},
uses an ignore variable to stand for the value being matched by a \texttt{-} pattern.
Since the rule does not need to refer to the value, we do not name it and use an ignore variable
instead.

\section{Flavors of Equality In Rules\label{sec:FlavoursOfEqualityInRules}}
This section explains the equality notations used in rules, two of which are used in \SemanticsRuleRef{ECond},
shown here:
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\mcond, \envone) \OrAbnormal\\\\
  \mcond \eqname (\nvbool(\vb), \vgone)\\
  \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\\\
  \evalexpr(\envone, \vep) \evalarrow \ResultExpr((\vv, \vgtwo), \newenv)  \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
}{
  \evalexpr(\env, \overname{\ECond(\econd, \veone, \vetwo)}{\ve}) \evalarrow
  \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}

\begin{description}
  \item[Range:] we write $i=1..k$ to allow listing premises parameterized by $i$ or constructing
  lists from expressions parameterized by $i$.
  For example, given two lists $a$ and $b$,
  \[
    i=1..k: a[i] > b[i]
  \]
  is the list of premises
  \[
    \begin{array}{l}
    a[1] > b[1]\\
    \ldots\\
    a[k] > b[k] \enspace.
    \end{array}
  \]

  \item[Predicate:] we write $a = b$ as an assertion of the equality of $a$ and $b$.
  For example, the mathematical identity $x \times (y + z) = x \times y + x \times z$.

  \hypertarget{def-deconstruction}{}
  \item[Deconstruction / ``View as'':] some values, such as tuples, are compound. In order to refer to the structure
  of compound values, we write $v \eqname \textit{f}(u_{1..k})$ where the expression on the right
  hand side exposes the internal structure of $v$ by introducing the variables
  $u_{1..k}$, allowing us to alias internal components of $v$.
  Intuitively, $v$ is re-interpreted as $\textit{f}(u_{1..k})$.
  For example, suppose we know that $v$ is a pair of values.
  Then, $v \eqname (a, b)$ allows us to alias $a$ and $b$.
  In \SemanticsRuleRef{ECond}, we know from the definition of $\evalexpr$ that
  $\mcond$ is a pair datatype.
  Therefore, writing $\mcond \eqname (\nvbool(\vb), \vgone)$ allows us to name each component of this pair
  and then refer to it, while \hyperlink{def-ignore}{ignoring} the \staticenvironmentterm{} component.
  Similarly, if $v$ is a non-empty list, then $v \eqname [h] + t$ deconstructs the list into the
  head of the list $h$ and its tail $t$.
  Given that a variable $v$ represents a list, we write $v \eqname v_{1..k}$ to list its elements and allow
  referring to them by index.

\hypertarget{def-eqdef}{}
\item[Definition / ``Define as'':] the notation $\vx \eqdef \ve$ denotes that $\vx$ is a new name serving as an alias for the expression $\ve$.
For example, in the rule \SemanticsRuleRef{ECond}, we use $\vg$ to name the mathematical expression
$\ordered{\vgone}{\aslctrl}{\vgtwo}$.
Aliases allow us to break down complex expressions, but rules can always be rewritten without them,
by inlining their right-hand sides:
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\mcond, \envone) \OrAbnormal\\\\
  \mcond \eqname (\nvbool(\vb), \vgone)\\
  \evalexpr(\envone, \choice{\vb}{\veone}{\vetwo}) \evalarrow \ResultExpr((\vv, \vgtwo), \newenv) \OrAbnormal
}{
  {
  \begin{array}{r}
  \evalexpr(\env, \overname{\ECond(\econd, \veone, \vetwo)}{\ve}) \evalarrow\\
  \ResultExpr((\vv, \ordered{\vgone}{\aslctrl}{\vgtwo}), \newenv)
  \end{array}
  }
}
\end{mathpar}
\end{description}

\section{AST-related Notations\label{sec:ASTNotations}}

When deconstructing AST record nodes such as $\{f_1:t_1,\ldots,f_k:t_k\}$,
we sometimes only care about a subset of the fields $\{f_{i_1},\ldots,f_{i_m}\} \subset \{f_{1..k}\}$.
In such cases, we write $\{f_{i_1}:t_{i_1},\ldots,f_{i_m}:t_{i_m},\ldots\}$,
where $\ldots$ stands for fields that are irrelevant for the rule.

For example, the \func{} non-terminal is
of a record type and has the following fields:
$\funcname$, $\funcparameters$, $\funcargs$, $\funcbody$, $\funcreturntype$, $\funcsubprogramtype$,
$\funcrecurselimit$, and \\
$\funcbuiltin$.
The notation $\{ \funcbody:\vbody,\ \funcargs:\vargdecls, \ldots \}$
allows us to deconstruct a given \func\ node by matching only the $\funcbody$ and $\funcargs$ fields.

Recall that a subset of AST nodes are either labels or labelled tuples.
\hypertarget{def-astlabel}{}
The partial function $\astlabel$ returns the label $\vl\in\ASTLabels$ of an AST node, when it exists.
For example, $\astlabel(\TBool) = \TBool$ and $\astlabel(\TNamed(\vx)) = \TNamed$.

\section{How to Parse Inference Rules Efficiently\label{sec:How to Parse Inference Rules Efficiently}}
Consider the following examples, which is a simplified version of \SemanticsRuleRef{Binop}
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \evalexpr( \env, \veone) \evalarrow \ResultExpr(\vmone, \envone) \\\\
  \evalexpr( \envone, \vetwo ) \evalarrow \ResultExpr(\vmtwo, \newenv) \\\\
  \vmone \eqname (\vvone, \vgone) \\
  \vmtwo \eqname (\vvtwo, \vgtwo) \\
  \evalbinop(\op, \vvone, \vvtwo) \evalarrow \vv \\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr( \env, \EBinop(\op, \veone, \vetwo) ) \evalarrow
  \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}

To parse a rule, start by examining the conclusion and the variables appearing in the rule.
In this case, the rule describes a transition from an input configuration \\
$\evalexpr( \env, \EBinop(\op, \veone, \vetwo) )$,
whose configuration domain is \texttt{eval\_expr}, to an output configuration $\ResultExpr((\vv, \vg), \newenv)$
whose configuration domain is $\ResultExpr$.
%
A rule uses the free variables appearing in the input configuration of the conclusion
($\env$, $\op$, $\veone$, and $\vetwo$ in our example),
with the goal of assigning values to the free variables in the output configuration
of the conclusion ($\vv$, $\vg$, and $\newenv$, in our example).

Now, scan the premises in order to see where $\env$, $\op$, $\veone$, and $\vetwo$ are used and how
premises assign values to $\vv$, $\vg$, and $\newenv$.
%
In this case, $\vv$ is assigned as the result of the transition judgment
$\evalbinop(\op, \vvone, \vvtwo) \evalarrow \vv$,
$\vg$ is assigned the expression $\vgone \parallelcomp \vgtwo$,
and $\newenv$ is assigned as the result of the transition judgment
$\evalexpr( \envone, \vetwo ) \evalarrow \ResultExpr(\vmtwo, \newenv)$.
%
Notice that to assign values to the variables $\vv$, $\vg$, and $\newenv$,
intermediate values have to be assigned first.
For example, $\evalexpr( \env, \veone) \evalarrow \ResultExpr(\vmone, \envone)$
assigned values to $\envone$, which is then used by the transition \\
$\evalexpr( \envone, \vetwo ) \evalarrow \ResultExpr(\vmtwo, \newenv)$.
Similarly, $\vg$ requires first assigning values to $\vgone$ and $\vgtwo$,
which are components of the previously assigned variables $\vmone$ and $\vmtwo$.

\hypertarget{def-shortcircuitrulemacro}{}
\section{Short-circuit Rule Macros\label{sec:ShortCircuitRuleMacros}}
\emph{\Shortcircuitrulemacros}, or \emph{rule macros}, for short, allow us to succinctly define sets of rules.
Specifically, they allow us to capture situations where
transitions have two alternative output configurations.
If the transition results in the first of the alternative output configurations, the following premises are considered.
However, if the result is the second, short-circuit output configuration, then the following premises are ignored
and the conclusion transitions into the short-circuit output configuration.
These short-circuit output configurations are typically, but not always, due to (type or dynamic) errors.

\hypertarget{def-terminateas}{}
In the following, $\XP$ and $\XQ$ stand for, possibly empty, sequences of premises.
%
A rule macro includes the special premise form $C \rulearrow C'\; \terminateas\; E$,
which introduces the output configuration $C'$ and the short-circuiting alternative $E$:
\begin{mathpar}
  \inferrule{
    \XP\\\\
    C \rulearrow C'\; \terminateas\; E\\\\
    \XQ\\
  }
  {
    V \rulearrow V'
  }
\end{mathpar}
Such a rule macro expands to the following pair of rules:
\begin{mathpar}
  \inferrule[(Option 1)]{
    \XP\\\\
    C \rulearrow C' \\\\
    \XQ\\
  }
  {
    V \rulearrow V'
  }
  \and
  \inferrule[(Option 2:Short-circuited)]{
    \XP\\\\
    C \rulearrow E
  }
  {
    V \rulearrow E
  }
\end{mathpar}
Intuitively, if $C$ transitions to $C'$ then $\terminateas\; E$ can be ignored
and the rule is interpreted as usual (Option 1).
However, if $C$ transitions into $E$ (Option 2) then the premises $\XQ$ are ignored,
thereby short-circuiting the rule, and the input configuration
in the conclusion transitions into $E$.

We allow more than one premise to include short-circuiting alternatives and also
a single premise to include several alternatives.
That is, a rule macro of the form
\begin{mathpar}
  \inferrule{
    \XP\\\\
    C \rulearrow C'\; \terminateas\; E_{1...m}\\\\
    \XQ\\
  }
  {
    V \rulearrow V'
  }
\end{mathpar}
Stands for the set of rule macros
\begin{mathpar}
  \inferrule{
    \XP\\\\
    C \rulearrow C'\; \terminateas\; E_1\\\\
    \XQ\\
  }
  {
    V \rulearrow V'
  }
\and
\inferrule{\ldots}{}
\and
\inferrule{
  \XP\\\\
  C \rulearrow C'\; \terminateas\; E_m\\\\
  \XQ\\
}
{
  V \rulearrow V'
}
\end{mathpar}

Notice that after all rule macros are expanded, in a top-to-bottom and left-to-right order, into normal rules,
they behave like normal rules where the order of premises does
not matter.

\hypertarget{def-proseterminateas}{}
\paragraph{Alternative Outcomes Expressed in English Prose:}
In English prose, we use
\ProseTerminateAs{x, y, \ldots} to mean
``if the outcome is one of $x, y, \ldots$ then the result short-circuits the rule.

As an example, consider the rule \SemanticsRuleRef{Binop}.
This time, not simplified:
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \evalexpr( \env, \veone) \evalarrow \ResultExpr(\vmone, \envone) \OrAbnormal \\\\
  \evalexpr( \envone, \vetwo ) \evalarrow \ResultExpr(\vmtwo, \newenv) \OrAbnormal \\\\
  \vmone \eqname (\vvone, \vgone) \\
  \vmtwo \eqname (\vvtwo, \vgtwo) \\
  \evalbinop(\op, \vvone, \vvtwo) \evalarrow \vv\; \terminateas\; \DynErrorConfig\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr( \env, \EBinop(\op, \veone, \vetwo) ) \evalarrow
  \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}

In this rule, $\ThrowingConfig$ and $\DynErrorConfig$ are just shorthand notations for
actual configurations, which are properly defined in \chapref{Semantics}.
Intuitively, the alternative configurations $\ThrowingConfig$, $\DynErrorConfig$,
and $\DivergingConfig$
represent situations where a transition may result in a raised exception,
a \dynamicerrorterm, and a diverging evaluation, respectively.

One may first read the rule ignoring these alternative configurations, to see how the
goal of transitioning into the output configuration appearing in the conclusion ---
$\ResultExpr((\vv, \vg), \newenv)$ --- is achieved.
Then, re-reading the rule would indicate where exceptions, \dynamicerrorsterm,
and diverging evaluation may result in other output configurations.
%
For example, if the first transition judgment results in a throwing configuration $\ThrowingConfig$
then the output configuration of the conclusion is also $\ThrowingConfig$.
This corresponds to the following rule in the expanded macro:

\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \evalexpr( \env, \veone) \evalarrow \ThrowingConfig
}{
  \evalexpr( \env, \EBinop(\op, \veone, \vetwo) ) \evalarrow
  \ThrowingConfig
}
\end{mathpar}

Similarly, if the first transition judgment results in a \DynamicErrorConfigurationTerm, the output configuration of
the conclusion is \DynamicErrorConfigurationTerm, which corresponds to the following rule in the expansion:
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \evalexpr( \env, \veone) \evalarrow \DynErrorConfig
}{
  \evalexpr( \env, \EBinop(\op, \veone, \vetwo) ) \evalarrow
  \DynErrorConfig
}
\end{mathpar}

Finally, if the first transition judgment results in a diverging configuration, the output configuration of
the conclusion is also a diverging configuration, which corresponds to the following rule in the expansion:
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \evalexpr( \env, \veone) \evalarrow \DivergingConfig
}{
  \evalexpr( \env, \EBinop(\op, \veone, \vetwo) ) \evalarrow
  \DivergingConfig
}
\end{mathpar}

The following rules correspond to the cases where the first transition results in \\
$\ResultExpr(\vmone, \envone)$, but the second transition judgment results in either
$\ThrowingConfig$, $\DynErrorConfig$, or $\DivergingConfig$, respectively:
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \evalexpr( \env, \veone) \evalarrow \ResultExpr(\vmone, \envone) \\\\
  \evalexpr( \envone, \vetwo ) \evalarrow \ThrowingConfig
}{
  \evalexpr( \env, \EBinop(\op, \veone, \vetwo) ) \evalarrow
  \ThrowingConfig
}
\end{mathpar}

\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \evalexpr( \env, \veone) \evalarrow \ResultExpr(\vmone, \envone) \\\\
  \evalexpr( \envone, \vetwo ) \evalarrow \DynErrorConfig
}{
  \evalexpr( \env, \EBinop(\op, \veone, \vetwo) ) \evalarrow
  \DynErrorConfig
}
\end{mathpar}

\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \evalexpr( \env, \veone) \evalarrow \ResultExpr(\vmone, \envone) \\\\
  \evalexpr( \envone, \vetwo ) \evalarrow \DivergingConfig
}{
  \evalexpr( \env, \EBinop(\op, \veone, \vetwo) ) \evalarrow
  \DivergingConfig
}
\end{mathpar}

Expanding the last transition judgment, gives us the case:
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \evalexpr( \env, \veone) \evalarrow \ResultExpr(\vmone, \envone) \\\\
  \evalexpr( \envone, \vetwo ) \evalarrow \ResultExpr(\vmtwo, \newenv) \\\\
  \vmone \eqname (\vvone, \vgone) \\
  \vmtwo \eqname (\vvtwo, \vgtwo) \\
  \evalbinop(\op, \vvone, \vvtwo) \evalarrow \DynErrorConfig
}{
  \evalexpr( \env, \EBinop(\op, \veone, \vetwo) ) \evalarrow
  \DynErrorConfig
}
\end{mathpar}

All these cases are succinctly encoded in a single rule with the alternative output configurations.

\section{Conventionally-used Judgments and Notations\label{sec:ConventionallyUsedJudgments}}
We now present functions used conventionally in this reference.

\subsection{Checked Transitions\label{sec:Checked Transitions}}
\hypertarget{relation-becheck}{}
\hypertarget{type-builderror}{}
The function
\[
\becheck(\overname{\Bool}{\vb}, \overname{\Strings}{\vcode}) \aslto \{\True\}
\cup\ \overname{\TBuildError}{\BuildErrorConfig}
\]
takes a Boolean value $\vb$ and an error code $\vcode$
and returns $\True$ when $\vb$ is $\True$ and a build error configuration for $\vcode$, otherwise.
\begin{mathpar}
\inferrule[be\_check\_true]{}{ \becheck(\True, \vcode) \astarrow \True }
\and
\inferrule[be\_check\_false]{}{ \becheck(\False, \vcode) \astarrow \BuildError(\vcode) }
\end{mathpar}

We define a similar function for type errors.
\RenderRelation{te_check}
\begin{mathpar}
\inferrule[te\_check\_true]{}{ \techeck(\True, \vcode) \typearrow \True }
\and
\inferrule[te\_check\_false]{}{ \techeck(\False, \vcode) \typearrow \TypeErrorVal{\vcode} }
\end{mathpar}

We define a similar function for dynamic errors.
\RenderRelation{de_check}
\begin{mathpar}
\inferrule[de\_check\_true]{}{ \decheck(\True, \vcode) \evalarrow \True }
\and
\inferrule[de\_check\_false]{}{ \decheck(\False, \vcode) \evalarrow \DynamicError(\vcode) }
\end{mathpar}

\BackupOriginalRelation{
The function
\[
\techeckname(\overname{\Bool}{\vb}, \overname{\Strings}{\vcode}) \aslto \{\True\}
\cup\ \overname{\typeerror}{\TypeErrorConfig}\ \cup\ \overname{\TDynError}{\DynErrorConfig}
\]
takes a Boolean value $\vb$ and an error code $\vcode$
and returns $\True$ when $\vb$ is $\True$.
Otherwise, the result is either a \typingerrorterm{} or a \dynamicerrorterm{},
based on the error code (see \chapref{Errors}).
%
This is used to assert that a condition that holds.

\begin{mathpar}
\inferrule[check\_trans\_true]{}{ \techeck{\True}{\vcode} \astarrow \True }
\end{mathpar}

\begin{mathpar}
\inferrule[check\_trans\_false\_type]{
  \vcode\text{ is a \typingerrorterm{} code}
}{ \techeck{\False}{\vcode} \astarrow \TypeErrorVal{\vcode} }
\end{mathpar}

\begin{mathpar}
\inferrule[check\_trans\_false\_dynamic]{
  \vcode\text{ is a \dynamicerrorterm{} code}
}{ \techeck{\False}{\vcode} \checktransarrow \DynamicErrorVal{\vcode} }
\end{mathpar}
}

\subsection{Boolean Transition Judgments}
\RenderRelation{bool_transition}
We define the following rules to allow us to treat Boolean values as transition judgments,
which in turn allow us to employ \shortcircuitrulemacros{}:
\begin{mathpar}
\inferrule[bool\_trans\_true]{}{ \booltrans(\overname{\True}{\cond}) \booltransarrow \overname{\True}{\vresult} }
\and
\inferrule[bool\_trans\_false]{}{ \booltrans(\overname{\False}{\cond}) \booltransarrow \overname{\False}{\vresult} }
\end{mathpar}

\subsection{Judgments Over Optional Data Types}
\hypertarget{def-mapopt}{}
Optional data types are prevalent in the AST.
To facilitate transition judgments over optional data types,
we introduce the following parametric relation,
which accepts a one-argument relation (or function) $f : A \aslrel B$
and applies it to an optional value:
\[
\mapopt{\cdot} : \overname{\Option{A}}{\vvopt} \aslrel \overname{\Option{B}}{\vvoptnew}
\]

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{Some}
  \begin{itemize}
    \item $\vvopt$ consists of the value $v$;
    \item applying $f$ to $v$ yields $v'$;
    \item \Proseeqdef{$\vvoptnew$}{the singleton set consisting of $v'$}.
  \end{itemize}

  \item \AllApplyCase{None}
  \begin{itemize}
    \item $\vvopt$ is $\None$;
    \item \Proseeqdef{$\vvoptnew$}{$\None$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[Some]{
  f(v) \longrightarrow v'
}{
  \mapopt{f}(\overname{\some{v}}{\vvopt}) \longrightarrow \some{v'}
}
\and
\inferrule[None]{}{
  \mapopt{f}(\overname{\None}{\vvopt}) \longrightarrow \None
}
\end{mathpar}

\subsection{Conventional Notations}
\hypertarget{def-wrapline}{}
\begin{itemize}
\item
The notation $\wrappedline$ denotes that a line that is longer than the page width continues on the next line.

\hypertarget{def-commonprefixline}{}
\item The notation $\commonprefixline$ serves as a visual aid to delimit a common prefix of premises shared by rule cases.

\hypertarget{def-commonsuffixline}{}
\item The notation $\commonsuffixline$ serves as a visual aid to delimit a common suffix of premises shared by rule cases.
\end{itemize}

\section{Rule Naming\label{sec:Rule Naming}}
To name a rule, we place it in a section with its name.
However, some relations are defined by a group of rules.
\hypertarget{def-caserules}{}
In such cases, we refer to the individual rules in a group as \emph{case rules},
or simply \emph{cases}. We annotate case rules by names
appearing above and to the left of the rule. The name of these case rules
is the name of the group, given by its section, followed by the name of the case.

For example, the rule \TypingRuleRef{BaseValue} is defined via multiple
cases. Two of these cases are the following ones:
\begin{mathpar}
\inferrule[t\_bool]{}{
    \basevalue(\tenv, \overname{\TBool}{\vt}) \typearrow \overname{\ELiteral(\LBool(\False))}{\veinit}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_real]{}{
    \basevalue(\tenv, \overname{\TReal}{\vt}) \typearrow \overname{\ELiteral(\LReal(0))}{\veinit}
}
\end{mathpar}

The full name of the first case is then \TypingRuleRef{BaseValue}.BOOL
and the full name of the second case is \TypingRuleRef{BaseValue}.REAL.

When explaining rules in English prose, we include the name of the case rules
in parenthesis to make it easier to relate the prose to the corresponding mathematical
definitions (see, for example, the Prose paragraph of \TypingRuleRef{BaseValue}
or that of \TypingRuleRef{ApplyUnopType}).
