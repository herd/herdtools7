\chapter{Type Declarations\label{chap:TypeDeclarations}}

Type declarations introduce new types.

See \ExampleRef{Types} for examples of type declarations.

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Type Declarations} defines the formal relations for type declarations;
  \item \SyntaxRef{Type Declarations} defines the syntax for type declarations;
  \item \AbstractSyntaxRef{Type Declarations} defines the abstract syntax for type declarations;
  \item \TypeRulesRef{Type Declarations} defines the type rules for type declarations.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Type Declarations}
\paragraph{Syntax:} Type declarations are grammatically derived from $\Ndecl$.
\paragraph{Abstract Syntax:} Type declarations are derived in the abstract syntax from $\decl$,
  and generated by $\builddecl$ (see \ASTRuleRef{TypeDecl}).
\paragraph{Typing:} Type declarations are annotated via $\declaretype$ (see \TypingRuleRef{DeclareType}).
\paragraph{Semantics:} Type declarations have no associated dynamic semantics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SyntaxDef{Type Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Ndecl  \derives \ & \Ttype \parsesep \Tidentifier \parsesep \Tof \parsesep \Ntydecl \parsesep \Nsubtypeopt \parsesep \Tsemicolon&\\
|\ & \Ttype \parsesep \Tidentifier \parsesep \Nsubtype \parsesep \Tsemicolon&\\
\Nsubtypeopt           \derives \ & \option{\Nsubtype} &\\
\Nsubtype \derives \ & \Tsubtypes \parsesep \Tidentifier \parsesep \Twith \parsesep \Nfields &\\
            |\              & \Tsubtypes \parsesep \Tidentifier &\\
\Nfields \derives \ & \Tlbrace \parsesep \Tminus \parsesep \Trbrace &\\
                    & \Tlbrace \parsesep \TClistOne{\Ntypedidentifier} \parsesep \Trbrace &\\
\Ntypedidentifier \derives \ & \Tidentifier \parsesep \Nasty &\\
\Nasty \derives \ & \Tcolon \parsesep \Nty &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\AbstractSyntaxDef{Type Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RenderTypes[remove_hypertargets]{decl_type}
\BackupOriginalAST{
\begin{flalign*}
\decl \derives\ & \DTypeDecl(\identifier, \ty, (\identifier, \overtext{\KleeneStar{\Field}}{with fields})?) &\\
\Field \derives\ & (\identifier, \ty) &
\end{flalign*}
}

\ASTRuleDef{TypeDecl}
This rule defines the cases for $\builddecl$ for type declarations.

\begin{mathpar}
\inferrule[type\_decl]{}
{
  {
    \begin{array}{c}
      \builddecl(\overname{\Ndecl(\Ttype, \Tidentifier(\vx), \Tof, \punnode{\Ntydecl}, \Nsubtypeopt, \Tsemicolon)}{\vparsednode})
  \astarrow \\
  \overname{\left[\DTypeDecl(\vx, \astof{\vt}, \astof{\vsubtypeopt})\right]}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[subtype\_decl]{
  \buildsubtype(\vsubtype) \astarrow \vs\\
  \vs \eqname (\name, \vfields)
}{
  {
    \begin{array}{c}
      \builddecl(\overname{\Ndecl(\Ttype, \Tidentifier(\vx), \Tof, \punnode{\Nsubtype}, \Tsemicolon)}{\vparsednode})
  \astarrow \\
  \overname{\left[\DTypeDecl(\vx, \TNamed(\name), \some{(\name, \vfields)})\right]}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{Subtype}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-subtype}{}
The function
\[
  \buildsubtype(\overname{\parsenode{\Nsubtype}}{\vparsednode}) \aslto \overname{(\Identifier \times \KleeneStar{(\Identifier\times \ty)})}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[with\_fields]{}{
  {
    \begin{array}{r}
  \buildsubtype(\overname{\Nsubtype(
    \Tsubtypes, \Tidentifier(\id), \Twith, \punnode{\Nfields}
    )}{\vparsednode})
  \astarrow \\
  \overname{(\id, \astof{\vfields})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[no\_fields]{}{
  \buildsubtype(\overname{\Nsubtype(
    \Tsubtypes, \Tidentifier(\id))}{\vparsednode})
  \astarrow
  \overname{(\id, \emptylist)}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{Subtypeopt}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-subtypeopt}{}
The function
\[
   \buildsubtypeopt(\overname{\parsenode{\Nsubtypeopt}}{\vparsednode}) \aslto
    \overname{\Option{\Identifier \times \Option{\KleeneStar{(\Identifier\times \ty)}}}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[subtype\_opt]{
  \buildoption[\Nsubtype](\vsubtypeopt) \astarrow \vastnode
}{
  \buildsubtypeopt(\overname{\Nsubtypeopt(\namednode{\vsubtypeopt}{\option{\Nsubtype}})}{\vparsednode}) \astarrow \vastnode
}
\end{mathpar}

\ASTRuleDef{Fields}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-fields}{}
The function
\[
  \buildfields(\overname{\parsenode{\Nfields}}{\vparsednode}) \;\aslto\; \overname{\KleeneStar{\field}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[empty]{
}{
  \buildfields(\Nfields(\Tlbrace, \Tminus, \Trbrace)) \astarrow
  \overname{\emptylist}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \buildtclist[\buildtypedidentifier](\vfields) \astarrow \vfieldasts
}{
  \buildfields(\Nfields(\Tlbrace, \namednode{\vfields}{\TClistOne{\Ntypedidentifier}}, \Trbrace)) \astarrow
  \overname{\vfieldasts}{\vastnode}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\TypeRulesDef{Type Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The main rule for annotating type declarations is \TypingRuleRef{AnnotateTypeDecl}.

We also define the following helper rules:
\begin{itemize}
  \item \TypingRuleRef{DeclareType}
  \item \TypingRuleRef{AnnotateTypeOpt}
  \item \TypingRuleRef{AnnotateExprOpt}
  \item \TypingRuleRef{AddGlobalStorage}
  \item \TypingRuleRef{DeclareType}
  \item \TypingRuleRef{AnnotateExtraFields}
  \item \TypingRuleRef{DeclareEnumLabels}
  \item \TypingRuleRef{DeclareConst}
\end{itemize}

\TypingRuleDef{AnnotateTypeDecl}
See \ExampleRef{Types} for examples of well-typed type declarations.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vd$ is a type declaration with identifier $\vx$, type $\tty$,
        and \optionalterm\ field initializers $\vs$, that is, $\DTypeDecl(\vx, \tty, \vs)$;
  \item declaring the type described by $(\vx, \tty, \vs)$ in $\genv$
        as per \\
        \TypingRuleRef{DeclaredType} yields the modified \globalstaticenvironmentterm{} \\
        $\newgenv$, annotated type $\ttyp$, and annotated \optionalterm{} field initializers $\vsp$\ProseOrTypeError;
  \item define $\newd$ as $\vd$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vd = \DTypeDecl(\vx, \tty, \vs)\\
  \declaretype(\genv, \vx, \tty, \vs) \typearrow (\newgenv, \ttyp, \vsp) \OrTypeError \\
  \newd \eqdef \DTypeDecl(\vx, \ttyp, \vsp)
}{
  \typecheckdecl(\genv, \vd) \typearrow (\newd, \newgenv)
}
\end{mathpar}

\TypingRuleDef{DeclareType}
\RenderRelation{declare_type}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\declaretype(\overname{\globalstaticenvs}{\genv} \aslsep
            \overname{\Identifier}{\name} \aslsep
            \overname{\ty}{\tty} \aslsep
            \overname{\Option{\Identifier\times\KleeneStar{\vfield}}}{\vs}
) \aslto \\
(\overname{\globalstaticenvs}{\newgenv} \times
 \overname{\ty}{\vttwo} \times
 \overname{\Option{\Identifier\times\KleeneStar{\vfield}}}{\vsp})
\cup \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
declares a type named $\name$ with type $\tty$ and \optionalterm\ additional fields
over another type $\vs$
in the \globalstaticenvironmentterm{} $\genv$, resulting in the modified \globalstaticenvironmentterm{} $\newgenv$, annotated type $\vttwo$, and annotated \optionalterm{} additional fields $\vsp$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Type Declarations}
\listingref{DeclareType} shows examples of well-typed type declarations
and ill-typed type declarations in comments.

The \sideeffectdescriptorsterm{} for \verb|Record| are
$\GlobalEffect(\SEPure)$ and $\Immutability(\True)$.
\ASLListing{Type declarations}{DeclareType}{\typingtests/TypingRule.DeclareType.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item checking that $\name$ is not already declared in the global environment of $\genv$ yields $\True$\ProseOrTypeError;
  \item define $\tenv$ as the \staticenvironmentterm{} whose global component is $\genv$ and its local component is the empty local
        \staticenvironmentterm{};
  \item annotating the \optionalterm\ extra fields $\vs$ for $\tty$ in $\tenv$ yields via \\ $\annotateextrafields$
        yields the modified environment $\tenvone$, type $\vtone$, and annotated \optionalterm{} extra fields $\vsp$\ProseOrTypeError;
  \item annotating $\vtone$ in $\tenvone$ yields $(\vttwo, \vsest)$\ProseOrTypeError;
  \item applying $\sesispure$ to $\vsest$ yields $\vb$;
  \item \Proseeqdef{$\vpurity$} as $\SEPure$ if $\vb$ is $\True$, otherwise $\SEReadonly$;
  \item applying $\addtype$ to $\name$, $\vttwo$, and $\vpurity$ in $\tenv$ yields $\tenvtwo$;
  \item $\tenvtwo$ is $\tenvone$ with its $\declaredtypes$ component updated by binding $\name$ to $\vttwo$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{enum}
    \begin{itemize}
      \item $\vttwo$ is an \enumerationtypeterm{} with labels $\ids$, that is, $\TEnum(\ids)$;
      \item applying $\declareenumlabels$ to $\vttwo$ in $\tenvtwo$ yields $\newgenv$\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{not\_enum}
    \begin{itemize}
      \item $\vttwo$ is not an \enumerationtypeterm{};
      \item $\newgenv$ is $\tenvtwo$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[enum]{
  \checkvarnotingenv(\genv, \name) \typearrow \True \OrTypeError\\\\
  \withemptylocal(\genv) \typearrow \tenv\\\\
  \annotateextrafields(\tenv, \name, \tty, \vs) \typearrow (\tenvone, \vtone, \vsp)\\
  \annotatetype(\True, \tenvone, \vtone) \typearrow (\vttwo, \vsest) \OrTypeError\\\\
  \sesispure(\vsest) \typearrow \vb\\
  \vpurity \eqdef \choice{\vb}{\SEPure}{\SEReadonly}\\
  \addtype(\tenvone, \name, \vttwo, \vpurity) \typearrow \tenvtwo\\\\
  \commonprefixline\\\\
  \vttwo = \TEnum(\ids)\\
  \declareenumlabels(\tenvtwo, \vttwo) \typearrow \newgenv \OrTypeError
}{
  \declaretype(\genv, \name, \tty, \vs) \typearrow (\newgenv, \vttwo, \vsp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_enum]{
  \checkvarnotingenv(\genv, \name) \typearrow \True \OrTypeError\\\\
  \withemptylocal(\genv) \typearrow \tenv\\\\
  \annotateextrafields(\tenv, \name, \tty, \vs) \typearrow (\tenvone, \vtone, \vsp)\\
  \annotatetype(\True, \tenvone, \vtone) \typearrow (\vttwo, \vsest) \OrTypeError\\\\
  \sesispure(\vsest) \typearrow \vb\\
  \vpurity \eqdef \choice{\vb}{\SEPure}{\SEReadonly}\\
  \addtype(\tenvone, \name, \vttwo, \vpurity) \typearrow \tenvtwo\\\\
  \commonprefixline\\\\
  \astlabel(\vttwo) \neq \TEnum
}{
  \declaretype(\genv, \name, \tty, \vs) \typearrow (\overname{\tenvtwo}{\newgenv}, \vttwo, \vsp)
}
\end{mathpar}
\CodeSubsection{\DeclareTypeBegin}{\DeclareTypeEnd}{../Typing.ml}
\identr{DHRC} \identd{YZBQ} \identr{DWSP} \identi{MZXL} \identr{MDZD} \identr{CHKR}

\TypingRuleDef{AnnotateExtraFields}
\RenderRelation{annotate_extra_fields}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\annotateextrafields(\overname{\staticenvs}{\tenv} \aslsep
  \overname{\Identifier}{\name} \aslsep
  \overname{\ty}{\tty} \aslsep
  \overname{\Option{(\overname{\Identifier}{\vsuper}\times\overname{\KleeneStar{\vfield}}{\extrafields})}}{\vs}
)
\aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newty} \times \overname{\KleeneStar{\vfield}}{\vsp})
\cup \overname{\typeerror}{\TypeErrorConfig}
\end{array}
\]
annotates the type $\tty$ with the \optionalterm\ extra fields $\vs$ in $\tenv$, yielding
the modified environment $\newtenv$, type $\newty$, and \optionalterm{} extra fields $\vsp$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Type Declarations with Fields and Without Fields}
In \listingref{DeclareType} shows type declarations where one type subtypes
another, with and without extra fields.
Specifically, both \verb|SubRecordEmptyExtraFields| and \\
\verb|SubRecordNoExtraFields|
subtype \verb|Record| with no extra fields.

In \listingref{AnnotateExtraFields-bad}, the declaration where \verb|SubRecord| is declared to subtype
\verb|SubRecord| is ill-typed, since \verb|SubRecord| is not defined as a type.
\ASLListing{Subtyping an undefined typed}{AnnotateExtraFields-bad}{\typingtests/TypingRule.AnnotateExtraFields.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\vs$ is $\None$;
    \item $\newtenv$ is $\tenv$;
    \item $\newty$ is $\tty$;
    \item $\vsp$ is $\None$.
  \end{itemize}

  \item \AllApplyCase{empty\_fields}
  \begin{itemize}
    \item $\vs$ is $\some{(\vsuper, \extrafields)}$;
    \item checking that $\tty$ \subtypesatisfiesterm\ the named type $\vsuper$ (that is, \\ $\TNamed(\vsuper)$) yields
          $\True$\ProseOrTypeError;
    \item $\extrafields$ is the empty list;
    \item $\newtenv$ is $\tenv$ with its $\subtypes$ component updated by binding $\name$ to $\vsuper$;
    \item $\newty$ is $\tty$;
    \item $\vsp$ is $\some{\vsuper, \emptylist}$.
  \end{itemize}

  \item \AllApplyCase{no\_super}
  \begin{itemize}
    \item $\vs$ is $\some{(\vsuper, \extrafields)}$;
    \item checking that $\tty$ \subtypesatisfiesterm\ the named type $\vsuper$ (that is, \\ $\TNamed(\vsuper)$) yields
          $\True$\ProseOrTypeError;
    \item $\extrafields$ is not an empty list;
    \item $\vsuper$ is not bound to a type in $\tenv$;
    \item the result is a \typingerrorterm{} indicating that $\vsuper$ is not a declared type.
  \end{itemize}

  \item \AllApplyCase{structured}
  \begin{itemize}
    \item $\vs$ is $\some{(\vsuper, \extrafields)}$;
    \item checking that $\tty$ \subtypesatisfiesterm\ the named type $\vsuper$ (that is,\\ $\TNamed(\vsuper)$) yields
          $\True$\ProseOrTypeError;
    \item $\extrafields$ is not an empty list;
    \item $\vsuper$ is bound to a type $\vt$ in $\tenv$;
    \item checking that $\vt$ is a \structuredtypeterm\ yields $\True$ or a \typingerrorterm{}
          indicating that a \structuredtypeterm\ was expected, thereby short-circuiting the entire rule;
    \item $\vt$ has AST label $L$ and fields $\fields$;
    \item $\newty$ is the type with AST label $L$ and list fields that is the concatenation of $\fields$ and $\extrafields$;
    \item $\newtenv$ is $\tenv$ with its $\subtypes$ component updated by binding $\name$ to $\vsuper$;
    \item $\vsp$ is $\some{(\vsuper, \emptylist)}$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \annotateextrafields(\tenv, \name, \tty, \overname{\None}{\vs}) \typearrow (\overname{\tenv}{\newtenv}, \overname{\tty}{\newty}, \overname{\None}{\vsp})
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty\_fields]{
  \subtypesatisfies(\tty, \TNamed(\vsuper)) \typearrow \vb\\
  \techeck(\vb, \UnexpectedType) \typearrow \True \OrTypeError\\\\
  \extrafields = \emptylist \\
  \newtenv \eqdef (G^\tenv.\subtypes[\name\mapsto\vsuper], L^\tenv) \\
  \vsp \eqdef \some{(\vsuper, \emptylist)}
}{
  \annotateextrafields(\tenv, \name, \tty, \overname{\some{(\vsuper, \extrafields)}}{\vs}) \typearrow (\newtenv, \overname{\tty}{\newty}, \vsp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_super]{
  \subtypesatisfies(\tty, \TNamed(\vsuper)) \typearrow \vb\\
  \techeck(\vb, \UnexpectedType) \typearrow \True \OrTypeError\\\\
  \extrafields \neq \emptylist\\\\
  G^\tenv.\declaredtypes(\vsuper) = \bot
}{
  \annotateextrafields(\tenv, \name, \tty, \overname{\some{(\vsuper, \extrafields)}}{\vs}) \typearrow
  \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  \subtypesatisfies(\tty, \TNamed(\vsuper)) \typearrow \vb\\
  \techeck(\vb, \UnexpectedType) \typearrow \True \OrTypeError\\\\
  \extrafields \neq \emptylist\\\\
  G^\tenv.\declaredtypes(\vsuper) = (\vt, \Ignore)\\
  {
    \begin{array}{r}
  \techeck(\astlabel(\vt) \in \{\TRecord, \TException\}, ExpectedStructuredType) \typearrow \\ \True \OrTypeError
    \end{array}
  }\\
  \vt \eqname L(\fields)\\
  \newty \eqdef L(\fields \concat \extrafields)\\
  \newtenv \eqdef (G^\tenv.\subtypes[\name\mapsto\vsuper], L^\tenv) \\
  \vsp \eqdef \some{(\vsuper, \emptylist)}
}{
  \annotateextrafields(\tenv, \name, \tty, \overname{\some{(\vsuper, \extrafields)}}{\vs}) \typearrow (\newtenv, \newty, \vsp)
}
\end{mathpar}

\TypingRuleDef{AnnotateTypeOpt}
\RenderRelation{annotate_type_opt}
\BackupOriginalRelation{
The function
\[
\annotatetypeopt(\overname{\staticenvs}{\tenv} \aslsep \overname{\Option{\overname{\ty}{\vt}}}{\tyopt})
\typearrow \overname{\Option{\ty}}{\tyoptp}
\cup \overname{\typeerror}{\TypeErrorConfig}
\]
annotates the type $\vt$ inside an \optionalterm\ $\tyopt$, if there is one, and leaves it as is if $\tyopt$ is $\None$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Optional Types}
The following are examples of annotating a type inside an \optionalterm{} with the empty \staticenvironmentterm{}:
\[
\begin{array}{rcl}
\annotatetypeopt(\emptytenv, \None) &\typearrow& \None\\
\annotatetypeopt(\emptytenv, \some{\unconstrainedinteger}) &\typearrow& \some{\unconstrainedinteger}
\end{array}
\]

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\tyopt$ is $\None$;
    \item $\tyoptp$ is $\tyopt$.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\tyopt$ contains the type $\vt$;
    \item annotating $\vt$ in $\tenv$ yields $\vtone$\ProseOrTypeError;
    \item $\tyoptp$ is $\some{\vtone}$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \annotatetypeopt(\tenv, \overname{\None}{\tyopt}) \typearrow \overname{\tyopt}{\tyoptp}
}
\and
\inferrule[some]{
  \annotatetype(\tenv, \vt) \typearrow \vtone \OrTypeError
}{
  \annotatetypeopt(\tenv, \overname{\some{\vt}}{\tyopt}) \typearrow\overname{\some{\vtone}}{\tyoptp}
}
\end{mathpar}

\TypingRuleDef{AnnotateExprOpt}
\RenderRelation{annotate_expr_opt}
\BackupOriginalRelation{
The function
\[
  \annotateexpropt(\overname{\staticenvs}{\tenv} \aslsep \overname{\Option{\expr}}{\expropt})
  \aslto \overname{(\Option{\expr} \times \Option{\ty})}{\vres}
  \cup \overname{\typeerror}{\TypeErrorConfig}
\]
annotates the \optionalterm\ expression $\expropt$ in $\tenv$ and returns a pair of \optionalterm\ expressions
for the type and annotated expression in $\vres$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Annotating Optional Expressions}
The following are examples of annotating an expression inside an \optionalterm{} with the empty \staticenvironmentterm{}:
\[
\annotateexpropt(\emptytenv, \None) \typearrow (\None, \None)\\
\]

\[
\begin{array}{r}
\annotateexpropt(\emptytenv, \some{\LInt(5)}) \typearrow\\
\left(\some{\LInt(5)}, \some{\TInt(\WellConstrained([\AbbrevConstraintExact{\LInt(5)}]))}\right)
\end{array}
\]

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item $\expropt$ is $\None$;
    \item $\vres$ is $(\None, \None)$.
  \end{itemize}

  \item \AllApplyCase{some}
  \begin{itemize}
    \item $\expropt$ contains the expression $\ve$;
    \item annotating $\ve$ in $\tenv$ yields $(\vt, \vep)$\ProseOrTypeError;
    \item $\vres$ is $(\some{\vt}, \some{\vep})$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \annotateexpropt(\tenv, \overname{\None}{\expropt}) \typearrow (\None, \None)
}
\and
\inferrule[some]{
  \annotateexpr(\tenv, \ve) \typearrow (\vt, \vep)\OrTypeError
}{
  \annotateexpropt(\tenv, \overname{\some{\ve}}{\expropt}) \typearrow \overname{(\some{\vt}, \some{\vep})}{\vres}
}
\end{mathpar}

\TypingRuleDef{DeclaredType}
\RenderRelation{declared_type}
\BackupOriginalRelation{
The function
\[
  \declaredtype(\overname{\staticenvs}{\tenv} \aslsep \overname{\Identifier}{\id}) \aslto \overname{\ty}{\vt} \cup \typeerror
\]
retrieves the type associated with the identifier $\id$ in the \staticenvironmentterm{} $\tenv$.
If the identifier is not associated with a declared type, the result is a \typingerrorterm.
} % END_OF_BACKUP_RELATION

\ExampleDef{Retrieving the Type Declared for an Identifier}

In \listingref{DeclaredType}, the expression \verb|(20 * x) as MyInt|
necessitates retrieving the type \\
\verb|integer{0..400}|, which is associated with \verb|MyInt|.
\ASLListing{The type associated with an identifier}{DeclaredType}{\typingtests/TypingRule.DeclaredType.asl}

The specification in \listingref{DeclaredType} is ill-typed,
since the expression \verb|20 as MyInt| refers to the undeclared type \verb|MyInt|.
\ASLListing{Referring to an undeclared type}{DeclaredType-bad}{\typingtests/TypingRule.DeclaredType.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exists}
  \begin{itemize}
    \item $\id$ is bound in the global environment to the type $\vt$.
  \end{itemize}

  \item \AllApplyCase{type\_not\_declared}
  \begin{itemize}
    \item $\id$ is not bound in the global environment to any type;
    \item the result is a \typingerrorterm{} indicating the lack of a type declaration for $\id$ (\UndefinedIdentifier).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exists]{
  G^\tenv.\declaredtypes(\id) = (\vt, \Ignore)
}{
  \declaredtype(\tenv, \id) \typearrow \vt
}
\end{mathpar}

\begin{mathpar}
\inferrule[type\_not\_declared]{
  G^\tenv.\declaredtypes(\id) = \bot
}{
  \declaredtype(\tenv, \id) \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\TypingRuleDef{DeclareEnumLabels}
\RenderRelation{declare_enum_labels}
\BackupOriginalRelation{
The function
\[
\declareenumlabels(\overname{\staticenvs}{\tenv} \aslsep
  \overname{\Identifier}{\name} \aslsep
  \overname{\KleenePlus{\Identifier}}{\ids})
  \aslto \overname{\staticenvs}{\newtenv}
  \cup \overname{\typeerror}{\TypeErrorConfig}
\]
updates the \staticenvironmentterm{} $\tenv$ with the identifiers $\ids$ listed by an \enumerationtypeterm{},
yielding the modified environment $\newtenv$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Declaring Enumeration Labels}

In \listingref{typing-tenum}, the declaration of the \verb|Color| enumeration type
updates the \staticenvironmentterm{} with the following constant variables:

\begin{center}
\begin{tabular}{lll}
\textbf{identifier} & \textbf{associated type} & \textbf{associated constant value}\\
\hline
$\RedLabel$ & $\TNamed(\ColorType)$ & $\LLabel(\RedLabel)$\\
$\GreenLabel$ & $\TNamed(\ColorType)$ & $\LLabel(\GreenLabel)$\\
$\BlueLabel$ & $\TNamed(\ColorType)$ & $\LLabel(\BlueLabel)$\\
\end{tabular}
\end{center}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ids$ is the (non-empty) list of labels $\id_{1..k}$;
  \item $\tenv_0$ is $\tenv$;
  \item declaring the constant $\id_i$ with the type $\TNamed(\name)$ and literal $\LLabel(\id_i)$ in $\tenv_{i-1}$
        via $\declareconst$
        yields $\tenv_i$, for $i=1 $ to $k$ (if $k>1$)\ProseOrTypeError;
  \item $\newtenv$ is $\tenv_k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \ids \eqname \id_{1..k}\\
  \tenv_0 \eqdef \tenv\\
  {
  \begin{array}{r}
    \vi=1..k: \declareconst(\tenv_{\vi-1}, \id_\vi, \TNamed(\name), \LLabel(\id_\vi)) \typearrow \\
    \tenv_{\vi} \OrTypeError
  \end{array}
  }
}{
  \declareenumlabels(\tenv, \name, \ids) \typearrow \overname{\tenv_k}{\newtenv}
}
\end{mathpar}

\TypingRuleDef{DeclareConst}
\RenderRelation{declare_const}
\BackupOriginalRelation{
The function
\[
\declareconst(\overname{\globalstaticenvs}{\genv} \aslsep
              \overname{\Identifier}{\name} \aslsep
              \overname{\ty}{\tty} \aslsep
              \overname{\literal}{vv})
              \aslto
              \overname{\globalstaticenvs}{\newgenv} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
adds a constant given by the identifier $\name$, type $\tty$, and literal $\vv$ to the
\globalstaticenvironmentterm{} $\genv$, yielding the modified environment $\newgenv$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Declaring a Global Constant}
In \listingref{DeclareConst}, declaring the constant \PI{}
in the empty \globalstaticenvironmentterm{} yields the following \globalstaticenvironmentterm:
\[
\begin{array}{l}
  \declareconst(G^{\emptytenv}, \PI, \TReal, \LReal(157 / 50)) \typearrow \\
  G^{\emptytenv}\left[
    \begin{array}{l}
    \globalstoragetypes\mapsto\{\PI\mapsto(\TReal, \GDKConstant)\},\\
    \constantvalues[\PI\mapsto\LReal(157 / 50)]
    \end{array}
  \right]
\end{array}
\]
(that is, all maps other than $\globalstoragetypes$ and $\constantvalues$, remain the same.)

\ASLListing{Declaring a global constant}{DeclareConst}{\typingtests/TypingRule.DeclareConst.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item adding the global storage given by the identifier $\name$, global declaration keyword $\GDKConstant$,
        and type $\tty$ to $\genv$ yields $\genvone$\ProseOrTypeError;
  \item applying $\addglobalconstant$ to $\name$ and $\vv$ in $\genvone$ yields $\newgenv$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \addglobalstorage(\genv, \name, \GDKConstant, \tty) \typearrow \genvone \OrTypeError\\\\
  \addglobalconstant(\genvone, \name, \vv) \typearrow \newgenv
}{
  \declareconst(\genv, \name, \tty, \vv) \typearrow \newgenv
}
\end{mathpar}
