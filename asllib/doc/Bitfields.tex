\chapter{Bitfields\label{chap:Bitfields}}

\hypertarget{bitfieldterm}{}
Bitvector types allow defining named slices, which we refer to as \emph{bitfields}.
Bitfields can be read from and written to. \identi{KGMC}

\ExampleDef{A bitvector type with bitfields}
\listingref{bitfields1} declares a global variable whose type is a bitvector with bitfields.
\ASLListing{A bitvector type with bitfields}{bitfields1}{\definitiontests/Bitfields.asl}
\begin{itemize}
  \item The expression \texttt{myData.flag} evaluates to the same value as \verb|myData[4]|, with type \verb|bits(1)|;
  \item The expression \texttt{myData.data} evaluates to the same value as \\
        \verb|myData[3:0] :: myData[8:5]|, with type \verb|bits(8)|;
  \item There is no bitfield which accesses \verb|myData[15:10]|;
  \item The \verb|value| field overlaps with the other fields;
  \item The slices \verb|3:0| and \verb|8:5| which define \texttt{data} do not overlap each other,
        but they do overlap \verb|value|.
\end{itemize}
Note that in the \texttt{data} bitfield, bits |3:0| come before and are more significant than
bits |8:5|, which is a different order from their occurrence in \texttt{myData}.

\hypertarget{def-singleslice}{}
\hypertarget{def-rangeslice}{}
\hypertarget{def-lengthslice}{}
\hypertarget{def-scaledslice}{}
We refer to a slice of the form \texttt{[$\ve$]} as a \singleslice,
a slice of the form \texttt{[$\veone$:$\vetwo$]} as a \rangeslice,
a slice of the form \texttt{[$\veone$+:$\vetwo$]} as a \lengthslice,
and slice of the form \texttt{[$\veone$*:$\vetwo$]} as a \scaledslice.

\ChapterOutline
\begin{itemize}
  \item \secref{Nested Bitfields} describes nested bitfields;
  \item \FormalRelationsRef{Bitfields} defines the formal relations for bitfields;
  \item \SyntaxRef{Bitfields} defines the syntax of bitfields;
  \item \AbstractSyntaxRef{Bitfields} defines the abstract syntax of bitfields; and
  \item \TypeRulesRef{Bitfields} defines the type system rules for bitfields.
  \item \SemanticsRulesRef{Bitfields} defines the dynamic semantics of bitfields.
\end{itemize}

\section{Nested Bitfields\label{sec:Nested Bitfields}}
Bitfields may have nested bitfields. This can have several uses, one of which being able to define two
different views of a register.

This section defines several properties of bitfields, illustrated by the example below.
These are used to define \RequirementRef{BitfieldAlignment}.

The \hypertarget{def-absolutename}{\absolutename} of a (possibly-nested) bitfield is the list of identifiers starting from the
name of the top-level bitfield containing it and following with the names of the nested bitfields,
until the name of the bitfield at hand. We denote an absolute name by separating the names with a
period, similar to the expression used to refer to it.
%
The \hypertarget{def-absoluteslice}{\absoluteslice} of a bitfield are the slices it defines with respected to its containing
bitvector type.
%
The \hypertarget{def-absolutebitfield}{\absolutebitfield} of a given bitfield consists of bits absolute name and its
\absoluteslices.

Further, the \hypertarget{def-bitfieldscope}{\bitfieldscope} of a bitfield is its \absolutename, with the last
identifier (the bitfield's name) removed.
For example, the \bitfieldscope\ of a bitfield with the absolute name \texttt{fmt0.later1.remainder.moving}
is \texttt{fmt0.later1.remainder} and the \bitfieldscope\ of a bitfield with the absolute name
\texttt{fmt0} is the empty list.

We say that two bitfields exist in the same \bitfieldscope\ if the \bitfieldscope\ of one is a prefix
of the \bitfieldscope\ of the other. For example, consider two bitfields whose corresponding \absolutenames\ are
\texttt{fmt0.later1.remainder} and \\
\texttt{fmt0.later1.remainder.moving}, respectively.
They exist in the same scope, since \texttt{fmt0.later1} is a prefix of
\texttt{fmt0.later1.remainder}.
In contrast, a pair of bitfields with \absolutenames\ \texttt{fmt0.common}
and \texttt{fmt1.common}, since neither of \texttt{fmt0} and \texttt{fmt1} is a prefix of the other.

\RequirementDef{BitfieldAlignment}
For every two bitfields of a given bitvector type,
if they share the same name and exist in the same \bitfieldscope\ then their \absoluteslices\ must be
equal.
This is formalized in \TypingRuleRef{CheckCommonBitfieldsAlign} and exemplified in \listingref{nestedbitfields}.

\ExampleDef{A bitvector type with nested bitfields}
\listingref{nestedbitfields} shows a bitvector type with nested bitfields, along with the absolute bitfield
defined for each bitfield.
\ASLListing{A bitvector type with nested bitfields}{nestedbitfields}{\definitiontests/Bitfields_nested.asl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Bitfields}
\paragraph{Syntax:} Bitfields are grammatically derived from $\Nbitfield$
  and lists of bitfields are grammatically derived from $\Nbitfields$.

\paragraph{Abstract Syntax:} Bitfields are derived in the abstract syntax from
  $\bitfield$ and generated by $\buildbitfield$ (see \ASTRuleRef{Bitfields}).

\paragraph{Typing:} Bitfields are annotated by $\annotatebitfields$.

\paragraph{Semantics:} Bitfields are not directly associated with a dynamic semantics.
  Their semantics is given as part of slicing expressions
  by $\evalexpr$ (see \secref{SlicingExpressions}) and
  $\evallexpr$ (see \secref{BitvectorSliceAssignmentExpressions}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SyntaxDef{Bitfields}
\begin{flalign*}
\Nbitfields \derives \ & \Tlbrace \parsesep \TClistZero{\Nbitfield} \parsesep \Trbrace &\\
\Nbitfield \derives \ & \Nslices \parsesep \Tidentifier &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Nbitfields &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Tcolon \parsesep \Nty &\\
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\AbstractSyntaxDef{Bitfields}
\RenderType[remove_hypertargets]{bitfield}

\ASTRuleDef{Bitfields}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-bitfields}{}
The function
\[
  \buildbitfields(\overname{\parsenode{\Nbitfields}}{\vparsednode}) \;\aslto\; \overname{\KleeneStar{\bitfield}}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{
  \buildtclist[\buildbitfield](\vbitfields) \astarrow \vbitfieldasts
}{
  \buildbitfields(\Nbitfields(\Tlbrace, \namednode{\vbitfields}{\TClistZero{\Nbitfield}}, \Trbrace)) \astarrow
  \overname{\vbitfieldasts}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{Bitfield}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-bitfield}{}
The function
\[
  \buildbitfield(\overname{\parsenode{\Nbitfield}}{\vparsednode}) \;\aslto\; \overname{\bitfield}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[simple]{}{
  \buildbitfields(\Nbitfield(\punnode{\Nslices}, \Tidentifier(\vx))) \astarrow
  \overname{\BitFieldSimple(\vx, \astof{\vslices})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested]{}{
  {
    \begin{array}{r}
      \buildbitfields(\Nbitfield(\punnode{\Nslices}, \Tidentifier(\vx), \punnode{\Nbitfields})) \astarrow\\
      \overname{\BitFieldNested(\vx, \astof{\vslices}, \astof{\vbitfields})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[type]{}{
  {
    \begin{array}{r}
      \buildbitfields(\Nbitfield(\punnode{\Nslices}, \Tidentifier(\vx), \Tcolon, \punnode{\Nty})) \astarrow\\
      \overname{\BitFieldType(\vx, \astof{\vslices}, \astof{\tty})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\TypeRulesDef{Bitfields}
\TypingRuleDef{TBitFields}
\RenderRelation{annotate_bitfields}
\BackupOriginalRelation{
The function
\[
  \annotatebitfields(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ewidth} \aslsep \overname{\KleeneStar{\bitfield}}{\fields})
  \aslto (\overname{\KleeneStar{\bitfield}}{\newfields} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\typeerror}{\TypeErrorConfig}
\]
annotates a list of bitfields --- $\fields$ --- with an expression denoting the overall number of bits in the containing
bitvector type --- $\ewidth$,
in an environment $\tenv$,
resulting in $\newfields$ --- the \typedast\ for $\fields$ and $\ewidth$
as well as a set of \sideeffectdescriptorsterm\ $\vses$. \ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Typing Bitfields}
The bitfields declared in \listingref{bitfields1} are well-typed and their total width
is $16$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item checking that the list of bitfield names in $\bitfields$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item symbolically simplifying $\ewidth$ in $\tenv$ via $\staticeval$ yields the literal integer for $\width$\ProseOrTypeError;
  \item annotating each bitfield $\vf$ in $\fields$ with width $\width$ in $\tenv$ yields the corresponding annotated
  bitfield $\vfp$ and \sideeffectsetterm\ $\vxs_\vf$\ProseOrTypeError;
  \item define $\newfields$ as the list of annotated bitfields;
  \item define $\vses$ as the union of $\vxs_\vf$ for every field $\vf$ in $\fields$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \names \eqdef [\vfield\in\fields: \bitfieldgetname(\vfield)]\\
  \checknoduplicates(\names) \typearrow \True \OrTypeError\\\\
  \staticeval(\tenv, \ewidth) \typearrow \LInt(\width) \OrTypeError\\\\
  \vf\in\fields: \annotatebitfield(\tenv, \width, \vfield) \typearrow (\vfp, \vxs_\vf) \OrTypeError\\\\
  \newfields \eqdef [\vf\in\fields: \vfp]\\
  \vses \eqdef \bigcup_{\vf\in\fields}{\vxs_\vf}
}{
  \annotatebitfields(\tenv, \ewidth, \fields) \typearrow (\newfields, \vses)
}
\end{mathpar}
\CodeSubsection{\TBitFieldsBegin}{\TBitFieldsEnd}{../Typing.ml}

\TypingRuleDef{BitFieldGetName}
\RenderRelation{bitfield_get_name}
\BackupOriginalRelation{
The function
\[
  \bitfieldgetname(\overname{\bitfield}{\vbf}) \aslto \overname{\Identifier}{\name}
\]
returns the name of a bitfield --- $\name$, given a bitfield $\vbf$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Bitfield Names}
In \listingref{nestedbitfields}, the names of bitfields are:
\verb|fmt|, \verb|common|, \verb|layer1|, \verb|remainder|, \verb|moving|,
\verb|extra|, and \verb|fmt1|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{simple}
  \begin{itemize}
    \item $\vbf$ is a simple bitfield with name $\name$, that is, $\BitFieldSimple(\name, \Ignore)$;
  \end{itemize}
  \item \AllApplyCase{nested}
  \begin{itemize}
    \item $\vbf$ is a nested bitfield with name $\name$, that is, $\BitFieldNested(\name, \Ignore, \Ignore)$;
  \end{itemize}
  \item \AllApplyCase{type}
  \begin{itemize}
    \item $\vbf$ is a typed bitfield with name $\name$, that is, $\BitFieldType(\name, \Ignore, \Ignore)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[simple]{}{
    \bitfieldgetname(\overname{\BitFieldSimple(\name, \Ignore)}{\vbf}) \typearrow \name
  }
  \and
  \inferrule[nested]{}{
    \bitfieldgetname(\overname{\BitFieldNested(\name, \Ignore, \Ignore)}{\vbf}) \typearrow \name
  }
  \and
  \inferrule[type]{}{
    \bitfieldgetname(\overname{\BitFieldType(\name, \Ignore, \Ignore)}{\vbf}) \typearrow \name
  }
\end{mathpar}

\TypingRuleDef{BitFieldGetSlices}
\RenderRelation{bitfield_get_slices}
\BackupOriginalRelation{
The function
\[
  \bitfieldgetslices(\overname{\bitfield}{\vbf}) \aslto \overname{\KleeneStar{\slice}}{\vslices}
\]
returns the list of slices $\vslices$ associated with the bitfield $\vbf$.
} % END_OF_BACKUP_RELATION

\ExampleDef{The Slices of a Bitfield}
In \listingref{nestedbitfields},
the slices associated with the bitfield \verb|layer1| are \verb|4:13, 12:2, 1, 0|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{simple}
  \begin{itemize}
    \item $\vbf$ is a simple bitfield with list of slices $\vslices$, that is, \\
    $\BitFieldSimple(\Ignore, \vslices)$;
  \end{itemize}
  \item \AllApplyCase{nested}
  \begin{itemize}
    \item $\vbf$ is a nested bitfield with list of slices $\vslices$, that is, \\
    $\BitFieldNested(\Ignore, \vslices, \Ignore)$;
  \end{itemize}
  \item \AllApplyCase{type}
  \begin{itemize}
    \item $\vbf$ is a typed bitfield with list of slices $\vslices$, that is, \\
    $\BitFieldType(\Ignore, \vslices, \Ignore)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[simple]{}{
  \bitfieldgetslices(\overname{\BitFieldSimple(\Ignore, \vslices)}{\vbf}) \typearrow \vslices
}
\and
\inferrule[nested]{}{
  \bitfieldgetslices(\overname{\BitFieldNested(\Ignore, \vslices, \Ignore)}{\vbf}) \typearrow \vslices
}
\and
\inferrule[type]{}{
  \bitfieldgetslices(\overname{\BitFieldType(\Ignore, \vslices, \Ignore)}{\vbf}) \typearrow \vslices
}
\end{mathpar}

\TypingRuleDef{BitFieldGetNested}
\RenderRelation{bitfield_get_nested}
\BackupOriginalRelation{
The function
\[
  \bitfieldgetnested(\overname{\bitfield}{\vbf}) \aslto \overname{\KleeneStar{\bitfield}}{\vnested}
\]
returns the list of bitfields $\vnested$ nested within the bitfield $\vbf$, if there are any,
and an empty list if there are none.
} % END_OF_BACKUP_RELATION

\ExampleDef{The Bitfields Nested in a Bitfield}
In \listingref{nestedbitfields},
the bitfields nested in the bitfield \verb|layer1| consist in the singleton list \verb|remainder|,
which does not include \verb|moving| and \verb|extra| -- those are nested in \verb|remainder|.
The bitfields nested in the bitfield \verb|fmt| make up an empty list.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{simple\_type}
  \begin{itemize}
    \item $\vbf$ does not have nested bitfields;
    \item $\vnested$ is the empty list.
  \end{itemize}

  \item \AllApplyCase{nested}
  \begin{itemize}
    \item $\vbf$ is bitfields with nested bitfields $\vnested$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[simple\_type]{
  \astlabel(\vbf) \neq \BitFieldNested
}{
  \bitfieldgetname(\vbf) \typearrow \emptylist
}
\and
\inferrule[nested]{}{
  \bitfieldgetname(\overname{\BitFieldNested(\Ignore, \Ignore, \vnested)}{\vbf}) \typearrow \vnested
}
\end{mathpar}

\TypingRuleDef{TBitField}
\RenderRelation{annotate_bitfield}
\BackupOriginalRelation{
The function
\[
  \annotatebitfield(\overname{\staticenvs}{\tenv} \aslsep \overname{\Z}{\width} \aslsep \overname{\bitfield}{\vfield})
  \aslto (\overname{\bitfield}{\newfield} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\typeerror}{\TypeErrorConfig}
\]
annotates a bitfield --- $\vfield$ --- with an integer --- $\width$ --- indicating the number of bits in
the bitvector type that contains $\vfield$,
in an environment $\tenv$, resulting in an
annotated bitfield --- $\newfield$ --- or a \typingerrorterm{}, if one is detected.
} % END_OF_BACKUP_RELATION

\ExampleDef{Well-typed Bitfields}
In \listingref{welltypedbitvectortypes}, all the uses of bitvector types with bitfields are well-typed.
\ASLListing{Well-typed bitfields}{welltypedbitvectortypes}{\typingtests/TypingRule.TBitField.asl}

\ProseParagraph
\begin{itemize}
  \item $\vfield$ is a bitfield with list of slices $\vslices$;
  \item annotating the slices $\vslices$ yields $(\slicesone, \vsesslices)$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{simple}
    \begin{itemize}
      \item checking whether the range of positions in $\slicesone$ fits inside $0..\width-1$ yields $\True$\ProseOrTypeError;
      \item define $\newfield$ as the bitfield named $\name$ with list of slices $\slicesone$, that is, $\BitFieldSimple(\name, \slicesone)$.
    \end{itemize}

    \item \AllApplyCase{nested}
    \begin{itemize}
      \item applying $\disjointslicestopositions$ to $\tenv$,
            $\True$ (indicating that the expressions comprising of $\slicesone$ must be \staticallyevaluableterm), \\
            and $\slicesone$
            yields the list of positions $\positions$\ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields \\
            $\True$\ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item annotating the bitfields $\bitfieldsp$ with $\widthp$ in \staticenvironmentterm{} $\tenv$ yields $ (\bitfieldspp, \vsesbitfields)$\ProseOrTypeError;
      \item define $\newfields$ as the nested bitfield with $\slicesone$ and bitfields \\
            $\bitfieldspp$, that is, $\BitFieldNested(\slicesone, \bitfieldspp)$;
      \item define $\vses$ as the union of $\vsesslices$ and $\vsesbitfields$.
    \end{itemize}

    \item \AllApplyCase{type}
    \begin{itemize}
      \item Annotating the type $\vt$ yields $(\vtp, \vsesty)$\ProseOrTypeError;
      \item checking whether the range of positions in $\slicesone$ fit inside $0..\width$ yields $\True$\ProseOrTypeError;
      \item applying $\disjointslicestopositions$ to $\tenv$,
            $\True$ (indicating that the expressions comprising of $\slicesone$ must be \staticallyevaluableterm), \\
            and $\slicesone$
            yields the list of positions $\positions$\ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields $\True$\ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item checking whether the $\vt$ and the bitvector with $\widthp$ bits have the same width yields $\True$\ProseOrTypeError
      \item define $\newfield$ as the typed bitfield with name $\name$, list of slices \\
            $\slicesone$ and type $\vtp$, that is, $\BitFieldType(\name, \slicesone, \vtp)$;
      \item define $\vses$ as the union of $\vsesslices$ and $\vsesty$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[simple]{
  \annotateslices(\tenv, \vslices) \typearrow (\slicesone, \vsesslices) \OrTypeError\\\\
  \commonprefixline\\\\
  \checkslicesinwidth(\tenv, \width, \slicesone) \typearrow \True \OrTypeError
}{
  \annotatebitfield(\tenv, \width, \BitFieldSimple(\name, \vslices)) \typearrow \\
  (\overname{\BitFieldSimple(\name, \slicesone)}{\newfield}, \overname{\vsesslices}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested]{
  \annotateslices(\tenv, \vslices) \typearrow (\slicesone, \vsesslices) \OrTypeError\\\\
  \commonprefixline\\\\
  \disjointslicestopositions(\tenv, \True, \slicesone) \typearrow \positions \OrTypeError\\\\
  \checkpositionsinwidth(\tenv, \width, \positions) \typearrow \True \OrTypeError\\\\
  \widthp \eqdef \listlen{\positions}\\
  {
  \begin{array}{r}
  \annotatebitfields(\tenv, \widthp, \bitfieldsp) \typearrow \\ (\bitfieldspp, \vsesbitfields) \OrTypeError
  \end{array}
  }\\
  \vses \eqdef \vsesslices \cup \vsesbitfields
}{
  \annotatebitfield(\tenv, \width, \BitFieldNested(\name, \vslices, \bitfieldsp)) \typearrow \\
  (\overname{\BitFieldNested(\slicesone, \bitfieldspp)}{\newfield}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[type]{
  \annotateslices(\tenv, \vslices) \typearrow (\slicesone, \vsesslices) \OrTypeError\\\\
  \commonprefixline\\\\
  \annotatetype(\tenv, \vt) \typearrow (\vtp, \vsesty) \OrTypeError\\\\
  \checkslicesinwidth(\tenv, \width, \slicesone) \typearrow \True \OrTypeError\\\\
  \disjointslicestopositions(\tenv, \True, \slicesone) \typearrow \positions \OrTypeError\\\\
  \checkpositionsinwidth(\tenv, \slicesone, \width, \positions) \typearrow \True \OrTypeError\\\\
  \widthp \eqdef \listlen{\positions}\\
  \checkbitsequalwidth(\TBits(\widthp, \emptylist), \vt) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesslices \cup \vsesty
}{
  \annotatebitfield(\tenv, \width, \BitFieldType(\name, \vslices, \vt)) \typearrow \\
  (\overname{\BitFieldType(\name, \slicesone, \vtp)}{\newfield}, \vses)
}
\end{mathpar}
\CodeSubsection{\TBitFieldBegin}{\TBitFieldEnd}{../Typing.ml}

\TypingRuleDef{CheckSlicesInWidth}
\RenderRelation{check_slices_in_width}
\BackupOriginalRelation{
The function
\[
  \checkslicesinwidth(\overname{\staticenvs}{\tenv} \aslsep \overname{\Z}{\vwidth} \aslsep \overname{\KleeneStar{\slice}}{\vslices})
  \aslto \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether the slices in $\vslices$ fit within the bitvector width given by $\vwidth$ in $\tenv$,
yielding $\True$. \ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

See
\ExampleRef{Converting Disjoint Slices to Positions} and
\ExampleRef{Checking Whether Slice Positions Fit in a Bitvector Width}.

\ProseParagraph
\AllApply
\begin{itemize}
    \item applying $\disjointslicestopositions$ to $\tenv$,
    $\True$ (indicating that the expressions comprising the slices must be \staticallyevaluableterm), and $\vslices$ checks whether the
    slices in $\vslices$ are disjoint and yields the set of their positions\ProseOrTypeError;
    \item applying $\checkpositionsinwidth$ to $\vwidth$ and $\positions$ to check that
    all of the positions fit with the width given by $\vwidth$ yields $\True$\ProseOrError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
    \disjointslicestopositions(\tenv, \True, \vslices) \typearrow \positions \OrTypeError\\\\
    \checkpositionsinwidth(\vwidth, \positions) \typearrow \True \OrTypeError
}{
    \checkslicesinwidth(\tenv, \vwidth, \vslices) \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckSlicesInWidthBegin}{\CheckSlicesInWidthEnd}{../Typing.ml}

\TypingRuleDef{CheckPositionsInWidth}
\RenderRelation{check_positions_in_width}
\BackupOriginalRelation{
The function
\[
  \checkpositionsinwidth(\overname{\Z}{\vwidth} \aslsep \overname{\pow{\Z}}{\positions})
  \aslto \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether the set of positions in $\positions$ fit within the bitvector width given by $\vwidth$,
yielding $\True$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Checking Whether Slice Positions Fit in a Bitvector Width}
In \listingref{bitfieldslicetopositions}, all slices declared for all bitfields
fit in the bitvector width $16$, whereas the positions defined for the bitfield
\verb|value| in \listingref{checkpositionsinwidth} exceed the bitvector width $16$.

\ASLListing{An Out of Width Slice}{checkpositionsinwidth}{\typingtests/TypingRule.CheckPositionsInWidth.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
    \item define $\minpos$ as the minimal position in $\positions$;
    \item define $\maxpos$ as the maximal position in $\positions$;
    \item checking that $\minpos$ is non-negative and that $\maxpos$ is less than $\vwidth$
          yields $\True$\ProseTerminateAs{\BadSlices}.
    \item the result is $\True$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
    \minpos \eqdef \min(\positions)\\
    \maxpos \eqdef \max(\positions)\\
    \checktrans{0 \leq \minpos \land \maxpos < \vwidth}{\BadSlices} \typearrow \True \OrTypeError
}{
    \checkpositionsinwidth(\vwidth, \positions) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{DisjointSlicesToPositions}
\RenderRelation{disjoint_slices_to_positions}
\BackupOriginalRelation{
The function
\[
  \disjointslicestopositions(
    \overname{\staticenvs}{\tenv},
    \overname{\Bool}{\isstatic},
    \overname{\KleeneStar{\slice}}{\vslices}
  )
  \aslto \overname{\powfin{\Z}}{\positions} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
returns the set of integers defined by the list of slices in $\vslices$ in $\positions$.
In particular, this rule checks that the following properties:
\begin{itemize}
  \item bitfield slices do not overlap; and
  \item bitfield slices are not defined in reverse (e.g., \texttt{0:1} rather than \texttt{1:0})
\end{itemize}
Conducting the checks for these properties requires evaluating the expressions comprising the
slices, either via static evaluation of via normalization.
The flag $\isstatic$ determines whether the slice is assumed to consist of \staticallyevaluableterm{}
expressions. If so, the slice expressions are statically evaluated, and otherwise they are
normalized.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Converting Disjoint Slices to Positions}
In \listingref{bitfieldslicetopositions}, the slices \verb|3:0| and \verb|5+:3|, declared for the bitfield \verb|data|
yield the set of positions $\{0, 1, 2, 3, 5, 6, 7\}$.
Whereas the slices \verb|3:0| and \verb|5:3|, declared for the bitfield \verb|data|
in \listingref{disjointslicestopositions} overlap, since they have $3$ in common.

\ASLListing{Overlapping Slices}{disjointslicestopositions}{\typingtests/TypingRule.DisjointSlicesToPositions.bad.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vslices$ is the empty list;
    \item $\positions$ is the empty set.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vslices$ is the list with $\vs$ as its \head\ and $\vslicesone$ as its \tail;
    \item applying $\bitfieldslicetopositions$ to $\tenv$, $\isstatic$, and $\vs$, yields the optional set of positions \\
          $\positionsoneopt$\ProseOrTypeError;
    \item define $\positionsone$ as $\vsone$ if $\positionsoneopt$ is $\some{\vsone}$ and the empty set, otherwise;
    \item applying $\disjointslicestopositions$ to $\tenv$, $\isstatic$, and $\vslicesone$, yields the optional set of positions
          $\positionstwoopt$\ProseOrTypeError;
    \item define $\positionstwo$ as $\vsone$ if $\positionstwoopt$ is $\some{\vstwo}$ and the empty set, otherwise;
    \item checking that $\positionsone$ is disjoint from $\positionstwo$ yields $\True$\ProseTerminateAs{\BadSlices}
    \item $\positions$ is the union of $\positionsone$ and $\positionstwo$.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \disjointslicestopositions(\tenv, \isstatic, \overname{\emptylist}{\vslices}) \typearrow \overname{\emptyset}{\positions}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \bitfieldslicetopositions(\tenv, \isstatic, \vs) \typearrow \positionsoneopt \OrTypeError\\\\
  \positionsone \eqdef \choice{\positionsoneopt = \some{\vsone}}{\vsone}{\emptyset}\\
  \disjointslicestopositions(\tenv, \isstatic, \vslicesone) \typearrow \positionstwoopt \OrTypeError\\\\
  \positionstwo \eqdef \choice{\positionstwoopt = \some{\vstwo}}{\vstwo}{\emptyset}\\
  \checktrans{\positionsone \cap \positionstwo = \emptyset}{\BadSlices} \checktransarrow \True \OrTypeError
}{
  \disjointslicestopositions(\tenv, \isstatic, \overname{\vs \concat \vslicesone}{\vslices}) \typearrow \overname{\positionsone \cup \positionstwo}{\positions}
}
\end{mathpar}

\TypingRuleDef{BitfieldSliceToPositions}
\RenderRelation{bitfield_slice_to_positions}
\BackupOriginalRelation{
The function
\[
  \bitfieldslicetopositions(
    \overname{\staticenvs}{\tenv},
    \overname{\Bool}{\isstatic},
    \overname{\slice}{\vslice}
  )
  \aslto \overname{\Option(\powfin{\Z})}{\positions} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
returns the set of integers defined by the bitfield slice $\vslice$ in $\positions$,
if it can be determined via static evaluation or normalization, depending on $\isstatic$,
and $\None$ if it cannot be determined.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

The function assumes that AST nodes labelled with $\SliceSingle$, $\SliceRange$, and $\SliceStar$ have been reduced
to $\SliceLength$ (via $\annotateslices$).

\ExampleDef{Converting Bitfield Slices to Positions}
\taref{bitfieldslicetopositions} shows the optional set of positions associated with each slice
in \listingref{bitfieldslicetopositions}, followed by examples of erroneous slices.

\begin{table}[h]
\caption{Converting Bitfield Slices to Positions\label{ta:bitfieldslicetopositions}}
\begin{center}
\begin{tabular}{ll}
  \textbf{Slice} & \textbf{Optional Set of Positions}\\
  \hline
  \verb|4|    & $\some{\{4\}}$ \\
  \verb|3:0|  & $\some{\{0, 1, 2, 3\}}$\\
  \verb|5+:3| & $\some{\{5, 6, 7\}}$\\
  \verb|3*:4| & $\some{\{12, 13, 14, 15\}}$\\
  \hline
  \verb|0:3|  & $\BadSlices$\\
  \verb|5+:0| & $\BadSlices$\\
  \verb|4*:0| & $\BadSlices$\\
\end{tabular}
\end{center}
\end{table}

\ASLListing{Converting bitfield slices to positions}{bitfieldslicetopositions}{\typingtests/TypingRule.BitfieldSliceToPositions.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vslice$ is \lengthslice\ defined by expressions $\veone$ and $\vetwo$, that is, \\
        $\SliceLength(\veone, \vetwo)$;
  \item applying $\evalsliceexpr$ to $\tenv$, $\isstatic$, and $\veone$, yields the integer literal for $\offset$\ProseTerminateAs{\TypeErrorConfig, \None};
  \item applying $\evalsliceexpr$ to $\tenv$, $\isstatic$, and $\vetwo$, yields the integer literal for $\length$\ProseTerminateAs{\TypeErrorConfig, \None};
  \item checking that $\offset$ is less than or equal to $\offset + \length - 1$ holds yields $\True$\ProseTerminateAs{\BadSlices};
  \item $\positions$ is the set of integers between $\offset$ and $\offset+\length-1$, inclusive.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalsliceexpr(\tenv, \isstatic, \veone) \typearrow \some{\offset} \terminateas\TypeErrorConfig, \None\\\\
  \evalsliceexpr(\tenv, \isstatic, \vetwo) \typearrow \some{\length} \terminateas\TypeErrorConfig, \None\\\\
  \checktrans{\offset \leq \offset + \length - 1}{\BadSlices} \checktransarrow \True \OrTypeError
}{
  {
  \begin{array}{r}
  \bitfieldslicetopositions(\tenv, \isstatic, \overname{\SliceLength(\veone, \vetwo)}{\vslice}) \typearrow\\
  \overname{\some{\{n \;|\; \offset \leq n \leq \offset+\length-1\}}}{\positions}
  \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{EvalSliceExpr}
\RenderRelation{eval_slice_expr}
\BackupOriginalRelation{
The function
\[
\evalsliceexpr(
  \overname{\staticenvs}{\tenv},
  \overname{\Bool}{\isstatic},
  \overname{\expr}{\ve}
) \aslto \overname{\Option(\Z)}{\vzopt} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
attempts to transform the expression $\ve$ into a constant integer in the \staticenvironmentterm{} $\tenv$,
yielding the result in $\vzopt$, where $\None$ indicates it could not be transformed into a constant integer.
If $\isstatic$ is $\True$, then $\ve$ is known to be \staticallyevaluableterm, and the transformation is
carried out via static evaluation. Otherwise, the transformation is carried out via normalization.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Evaluating Expressions in Slices}
The specifications in \listingref{EvalSliceExpr} shows two kinds of slices:
the slice \\
\verb|static_func{4}(4):0| is used to define a bitfield (\verb|data|)
and therefore must be \staticallyevaluableterm,
whereas the slice \verb|N DIV 2:0| is used in an \assignableexpression, which means
it need not be \staticallyevaluableterm{} (it is indeed not, in this example).
\ASLListing{Expressions in slices}{EvalSliceExpr}{\typingtests/TypingRule.EvalSliceExpr.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{static}
  \begin{itemize}
    \item $\isstatic$ is $\True$;
    \item \Prosestaticeval{$\tenv$}{$\ve$}{$\vz$}\ProseOrTypeError;
    \item \Proseeqdef{$\vzopt$}{the singleton set for $\vz$}.
  \end{itemize}

  \item \AllApplyCase{symbolic}
  \begin{itemize}
    \item $\isstatic$ is $\False$;
    \item applying $\reducetozopt$ to $\tenv$ and $\ve$ yields $\vzopt$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[static]{
  \staticeval(\tenv, \ve) \typearrow \vz \OrTypeError
}{
  \evalsliceexpr(\tenv, \overname{\True}{\isstatic}, \ve) \typearrow \overname{\some{\vz}}{\vzopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[symbolic]{
  \reducetozopt(\tenv, \ve) \typearrow \vzopt
}{
  \evalsliceexpr(\tenv, \overname{\False}{\isstatic}, \ve) \typearrow \vzopt
}
\end{mathpar}

\TypingRuleDef{CheckCommonBitfieldsAlign}
\RenderRelation{check_common_bitfields_align}
\BackupOriginalRelation{
The function
\[
\checkcommonbitfieldsalign(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\KleeneStar{\bitfield}}{\vbitfields} \aslsep
  \overname{\N}{\vwidth}
) \aslto \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks \RequirementRef{BitfieldAlignment}
for every pair of bitfields in $\vbitfields$, contained in a
bitvector type of width $\vwidth$ in the \staticenvironmentterm{} $\tenv$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

We represent \absolutebitfields\ by the type
\RenderType{TAbsField}
where the component $\name$ is a list of identifiers corresponding to the \absolutename,
and the component $\vslice$ corresponds to an \absoluteslice\ by listing the indices
into the containing bitvector type.\footnote{An implementation of the type system may compactly represent the list of indices
via a list of intervals, each represented by its limits.}

Premises in \TypingRuleRef{TBits} guarantee that $\vwidth > 0$ holds.

\ExampleDef{Ill-typed Bitfields}
\listingref{CommonBitfieldsAlignError} shows an example where the two bitfields named \texttt{common}
exist in the same \bitfieldscope, but their \absoluteslices\ are not the same.
Specifically, the \absoluteslice\ for the bitfield \texttt{common} is \texttt{[1:0]}
whereas the \absoluteslice\ for the bitfield \texttt{sub.common} is \texttt{[0, 1]}.
Typechecking this example results in the \typingerrorterm{} \BadSlices.

\ASLListing{An example where two bitfields of the same name (\texttt{common}) exist in the same scope but have different absolute slices}{CommonBitfieldsAlignError}{\typingtests/TypingRule.CheckCommonBitfieldsAlign.Error.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vbitfields$ is the empty list;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vbitfields$ is not the empty list;
    \item define $\vlastindex$ as $\vwidth - 1$;
    \item define $\vtopabsolute$ as an \absolutebitfield\ with the empty list
          for a name and a the interval $\vlastindex..0$ (that is, the entire range
          of indices for the containing bitvector type),
          as an artificial top-level \absolutebitfield\ for the entire bitvector type;
    \item \Prosebitfieldstoabsolute{$\tenv$}{$\vbitfields$}{$\vtopabsolute$}{$\vfs$};
    \item checking that \absolutebitfields\ $\vfone$ and $\vftwo$ align via
          $\absolutebitfieldsalign$ in $\tenv$, for every $\vfone$ and $\vftwo$ in $\vfs$,
          yields $\True$\ProseTerminateAs{\BadSlices};
    \item the result is $\True$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{
  \vbitfields = \emptylist
}{
  \checkcommonbitfieldsalign(\tenv, \vbitfields, \overname{0}{\vwidth}) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vbitfields \neq \emptylist\\
  \vlastindex \eqdef \vwidth - 1\\
  \vtopabsolute \eqdef (\emptylist, \vlastindex..0)\\
  \bitfieldstoabsolute(\tenv, \vbitfields, \vtopabsolute) \typearrow \vfs\\
  \checktrans{\forall \vfone, \vftwo \in \vfs: \absolutebitfieldsalign(\vfone, \vftwo)}{\BadSlices} \typearrow \True \OrTypeError
}{
  \checkcommonbitfieldsalign(\tenv, \vbitfields, \vwidth) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{BitfieldsToAbsolute}
\RenderRelation{bitfields_to_absolute}
\BackupOriginalRelation{
The function
\[
\bitfieldstoabsolute(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\KleenePlus{\bitfield}}{\vbitfields} \aslsep
  \overname{\TAbsField}{\vabsoluteparent}
) \aslto \overname{\pow{\TAbsField}}{\vabsbitfields}
\]
returns the set of \absolutebitfields\ $\vabsbitfields$ that correspond to the list
of bitfields $\vbitfields$, whose \bitfieldscope\ and \absoluteslice\ is given by
$\vabsoluteparent$, in the \staticenvironmentterm{} $\tenv$.
} % END_OF_BACKUP_RELATION

See \ExampleRef{A bitvector type with nested bitfields}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\bitfieldtoabsolute$ to each field $\vf$ in $\vbitfields$ with $\vabsoluteparent$ in $\tenv$,
        yields $\va_\vf$;
  \item define $\vabsbitfields$ as the union of the sets $\va_\vf$, for every $\vf$ in $\vbitfields$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vf\in\vbitfields: \bitfieldtoabsolute(\tenv, \vf, \vabsoluteparent) \typearrow \va_\vf\\
  \vabsbitfields \eqdef \bigcup_{\vf\in\vbitfields} \va_\vf
}{
  \bitfieldstoabsolute(\tenv, \vbitfields, \vabsoluteparent) \typearrow \vabsbitfields
}
\end{mathpar}

\TypingRuleDef{BitfieldToAbsolute}
\RenderRelation{bitfield_to_absolute}
\BackupOriginalRelation{
The function
\[
\bitfieldtoabsolute(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\bitfield}{\vbf} \aslsep
  \overname{\TAbsField}{\vabsoluteparent}
) \aslto \overname{\pow{\TAbsField}}{\vabsbitfields}
\]
returns the set of \absolutebitfields\ $\vabsbitfields$ that correspond to the
bitfields nested in $\vbf$, including itself, where the \bitfieldscope\ and \absoluteslice\
of the bitfield containing $\vbf$ are $\vabsoluteparent$, in the \staticenvironmentterm{} $\tenv$.
} % END_OF_BACKUP_RELATION

See \ExampleRef{A bitvector type with nested bitfields}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item obtaining the name of the bitfield $\vbf$ via $\bitfieldgetname$ yields $\name$;
  \item define the \absolutename\ of $\vbfname$ for $\vbf$ by appending $\name$ to $\vabsname$, the \absolutename{} of $\vabsoluteparent$;
  \item obtaining the list of slices for $\vbf$ via $\bitfieldgetslices$ yields $\vslices$;
  \item \Proseslicetoindices{$\tenv$}{$\vs$}{$\indices_\vs$};
  \item define $\vslicesasindices$ as the concatenation of the sequences $\indices_\vs$,
        for each slice $\vs$ in $\vslices$, in their order of appearance in $\vslices$;
  \item \Proseselectindicesbyslices{$\vabsslices$}{$\vslicesasindices$}{$\vbfindices$}, where $\vabsslices$ are the \absoluteslices{} of $\vabsoluteparent$;
  \item define $\vbfabsolute$ as the \absolutebitfield\ with \absolutename\ $\vbfname$
        and \absoluteslices\ $\vbfindices$;
  \item obtaining the bitfields nested in $\vbf$ via $\bitfieldgetnested$ yields $\vnested$;
  \item \Prosebitfieldstoabsolute{$\tenv$}{$\vnested$}{$\vbfabsolute$}{$\vabsbitfieldsone$};
  \item define $\vabsbitfields$ as the set containing $\vbfabsolute$ and the \absolutebitfields\
        of $\vabsbitfieldsone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \vbfname \eqdef \vabsname \concat [\name]\\
  \bitfieldgetslices(\vbf) \typearrow \vslices\\
  \vs \in \vslices: \slicetoindices(\tenv, \vs) \typearrow \indices_\vs\\
  \vslicesasindices \eqdef [\vs \in \vslices: \indices_\vs]\\
  \selectindicesbyslices(\vabsslices, \vslicesasindices) \typearrow \vbfindices\\
  \vbfabsolute \eqdef (\vbfname, \vbfindices)\\
  \bitfieldgetnested(\vbf) \typearrow \vnested\\
  \bitfieldstoabsolute(\tenv, \vnested, \vbfabsolute) \typearrow \vabsbitfieldsone
}{
  {
    \begin{array}{r}
      \bitfieldtoabsolute(\tenv, \vbf, \overname{(\vabsname, \vabsslices)}{\vabsoluteparent}) \typearrow \\
      \overname{\{\vbfabsolute\} \cup \vabsbitfieldsone}{\vabsbitfields}
    \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{SelectIndicesBySlices}
\RenderRelation{select_indices_by_slices}
\BackupOriginalRelation{
The function
\[
\selectindicesbyslices(\overname{\KleenePlus{\N}}{\indices}, \overname{\KleenePlus{\N}}{\sliceindices})
\aslto \overname{\KleeneStar{\N}}{\vabsslice}
\]
considers the list $\indices$ as a list of indices into a bitvector type (essentially, a slice of it),
and the list $\sliceindices$ as a list of indices into $\indices$ (a slice of a slice),
and returns the sub-list of $\indices$ indicated by the indices in $\sliceindices$.
% The reference abstracts away from the implementation,
% which represents sequence of indices via intervals.
} % END_OF_BACKUP_RELATION

\ExampleDef{Selecting from a List of Indices}
The following are some examples of selecting indices:
\[
\begin{array}{lcl}
\selectindicesbyslices([9,4,6,1,13], [4,3,2,1,0]) &\typearrow& [9,4,6,1,13]\\
\selectindicesbyslices([9,4,6,1,13], [0,1,2,3,4]) &\typearrow& [13,1,6,4,9]\\
\selectindicesbyslices([9,4,6,1,13], [3,2,4,0])   &\typearrow& [4,6,9,13]\\
\end{array}
\]

\ProseParagraph
\AllApply
\begin{itemize}
  \item view $\sliceindices$ as the list $S_{m..0}$;
  \item view $\indices$ as the list $I_{n..0}$;
  \item define $\vabsslice$ as the list $I[S_m] \ldots I[S_0]$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \selectindicesbyslices(\overname{I_{n..0}}{\indices}, \overname{S_{m..0}}{\sliceindices}) \typearrow
    \overname{I[S_m] \ldots I[S_0]}{\vabsslice}
}
\end{mathpar}

\TypingRuleDef{AbsoluteBitfieldsAlign}
\RenderRelation{absolute_bitfields_align}
\BackupOriginalRelation{
The function
\[
\absolutebitfieldsalign(\overname{\TAbsField}{\vf}, \overname{\TAbsField}{\vg})
\aslto \overname{\Bool}{\vb}
\]
tests whether the \absolutebitfields{} $\vfone$ and $\vftwo$ share the same name
and exist in the same scope. If they do, $\vb$ indicates whether their \absoluteslices\
are equal. Otherwise, the result is $\True$.
} % END_OF_BACKUP_RELATION

See \ExampleRef{A bitvector type with nested bitfields} where all \absolutebitfields{} align
and \ExampleRef{Ill-typed Bitfields} where not all \absolutebitfields{} align.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vf$ is an \absolutebitfield\ with \absolutename\ $\vf_{1..k}$ and \absoluteslice\ $\vsliceone$;
  \item $\vg$ is an \absolutebitfield\ with \absolutename\ $\vg_{1..n}$ and \absoluteslice\ $\vslicetwo$;
  \item define $\nameone$ to be the name of the bitfield corresponding to $\vf$, that is, $\vf_k$;
  \item define $\nametwo$ to be the name of the bitfield corresponding to $\vg$, that is, $\vg_n$;
  \item define $\vscopeone$ to be the \bitfieldscope\ of $\vf$, that is, $\vf_{1..k-1}$;
  \item define $\vscopetwo$ to be the \bitfieldscope\ of $\vg$, that is, $\vg_{1..n-1}$;
  \item define $\vsamescope$ as $\True$ if and only if $\vscopeone$ is a \listprefixterm\ of $\vscopetwo$ or vice versa;
  \item define $\vb$ as $\True$ if and only if $\nameone$ and $\nametwo$ are equal and $\vsamescope$ is $\True$ implies
        that $\vsliceone$ is equal to $\vslicetwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \nameone \eqdef \vf_k\\
  \nametwo \eqdef \vg_n\\
  \vscopeone \eqdef \vf_{1..k-1}\\
  \vscopetwo \eqdef \vg_{1..n-1}\\
  \vsamescope \eqdef \listprefix(\vscopeone, \vscopetwo) \lor \listprefix(\vscopetwo, \vscopeone)\\
  \vb \eqdef (\nameone = \nametwo\ \land\ \vsamescope) \Longrightarrow (\vsliceone = \vslicetwo)
}{
  \absolutebitfieldsalign(\overname{(\vf_{1..k}, \vsliceone)}{\vf}, \overname{(\vg_{1..n}, \vslicetwo)}{\vf})
  \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{SliceToIndices}
\RenderRelation{slice_to_indices}
\BackupOriginalRelation{
The function
\[
\slicetoindices(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\vs}) \aslto \overname{\KleeneStar{\N}}{\indices}
\]
returns the list of indices $\indices$ represented by the bitvector slice $\vs$ in the \staticenvironmentterm{} $\tenv$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Converting a Slice to a List of Indices}
The list of indices for the slice \\
$\SliceLength(\AbbrevEBinop{\ADD}{\ELInt{1}}{\ELInt{4}}, \ELInt{3})$ is
$[7, 6, 5]$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \lengthslice\ for the expressions $\vi$ and $\vw$;
  \item \Prosestaticeval{$\tenv$}{$\vi$}{the literal for the integer $\vz_\vi$};
  \item \Prosestaticeval{$\tenv$}{$\vw$}{the literal for the integer $\vz_\vw$};
  \item define $\vstart$ as $\vz_\vi$;
  \item define $\vend$ as $\vz_\vi + \vz_\vw - 1$;
  \item define $\indices$ as the list of integers starting at $\vend$ and counting down to $\vstart$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule{
  \staticeval(\tenv, \vi) \typearrow \LInt(\vz_\vi)\\
  \staticeval(\tenv, \vw) \typearrow \LInt(\vz_\vw)\\
  \vstart \eqdef \vz_\vi\\
  \vend \eqdef \vz_\vi + \vz_\vw - 1\\
}{
  \slicetoindices(\tenv, \overname{\SliceLength(\vi, \vw)}{\vs}) \typearrow \overname{\vend..\vstart}{\indices}
}
\end{mathpar}

\SemanticsRulesDef{Bitfields}
The type system annotates expressions that read from a bitfield into corresponding slicing \rhsexpressions{}.
Therefore, reading from a bitfield is done by evaluating a corresponding slice expression (see \SemanticsRuleRef{ESlice}).

The type system annotates expressions that write to a bitfield into corresponding slicing \assignableexpressions{}.
Therefore, writing to a bitfield is done by evaluating a corresponding assignable slice expression (see \SemanticsRuleRef{LESlice}).
