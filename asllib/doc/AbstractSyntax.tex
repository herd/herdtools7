%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Abstract Syntax\label{chap:AbstractSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
An abstract syntax is a form of context-free grammar over structured trees.
Compilers and interpreters typically start by parsing the text of a program and producing an abstract syntax tree (AST, for short),
and then continue to operate over that tree.
%
The reason for this is that abstract syntax trees abstract away details that are irrelevant to the semantics of the program,
such as punctuation and scoping syntax, which are useful for readability and parsing.

\begin{definition}[Syntactic Sugar]
\hypertarget{def-syntacticsugar}
Some ASL syntax is \emph{\syntacticsugar}. That is, some constructs (statements, expressions, etc.)
have no explicit corresponding AST nodes, and are rather represented by AST for other constructs.
We call the constructing the AST for such constructs \emph{\desugaring}.
\end{definition}

\hypertarget{def-typedast}{}
\hypertarget{def-untypedast}{}
\paragraph{Untyped AST vs. Typed AST:}
Technically, there are two abstract syntaxes:
an \emph{untyped abstract syntax} and a \emph{typed abstract syntax}.
The first syntax results from parsing the text of an ASL specification.
The typechecker checks whether the \untypedast{} satisfies the rules of the
type system. If so, it is considered valid and the type system rules
generate a \typedast.

\ChapterOutline
\begin{itemize}
  \item \secref{AbstractSyntaxTrees} defines the type of Abstract Syntax Trees (ASTs) used by ASL;
  \item \secref{AbstractSyntaxGrammar} defines notations used to define the ASTs of ASL;
  \item \secref{UntypedAbstractGrammar} defines the AST nodes for the \untypedast:
  \begin{itemize}
    \item \secref{Identifiers} defines the AST for identifiers;
    \item \secref{ASTLiterals} defines the AST for literal values;
    \item \secref{Operators} defines the AST for operators;
    \item \secref{Expressions} defines the AST for expressions;
    \item \secref{Patterns} defines the AST for patterns;
    \item \secref{Slices} defines the AST for slices;
    \item \secref{SubprogramCalls} defines the AST for subprogram calls;
    \item \secref{Types} defines the AST for types;
    \item \secref{Constraints} defines the AST for constraints;
    \item \secref{BitFields} defines the AST for bitfields;
    \item \secref{ArrayIndices} defines the AST for array indices;
    \item \secref{FieldsAndTypedIdentifiers} defines the AST for fields and typed identifiers;
    \item \secref{AssignableExoressions} defines the AST for assignable expressions;
    \item \secref{LocalDeclarations} defines the AST for local declarations;
    \item \secref{Statements} defines the AST for statements;
    \item \secref{CaseAlternatives} defines the AST for case alternatives;
    \item \secref{ExceptionCatchers} defines the AST for exception catchers;
    \item \secref{Subprograms} defines the AST for subprograms;
    \item \secref{GlobalDeclarations} defines the AST for global declarations;
    \item \secref{Specifications} defines the AST for specifications;
  \end{itemize}
  \item \secref{UntypedAbstractGrammar} defines the \untypedast;
  \item \secref{TypedAbstractSyntaxGrammar} defines the \typedast;
  \item \secref{BuildingAbstractSyntaxTrees} explains how we use inference rules to transform a parse tree into an \untypedast;
  \item \secref{BuildingParameterizedProductions} presents rules for building ASTs from parameterized productions;
  \item \secref{LeftToRight} maps \assignableexpressions{} to right hand side expressions;
  \item \secref{AbstractSyntaxAbreviations} defines AST abbreviations used by inference rules through this reference.
\end{itemize}

\section{Abstract Syntax Trees\label{sec:AbstractSyntaxTrees}}

In an ASL abstract syntax tree, a node is one the following data types:
\begin{description}
\item[Token Node.] A lexical token, denoted as in the lexical description of ASL;
\item[Label Node.] A label
\item[Unlabelled Tuple Node.] A tuple of children nodes, denoted as $(n_1,\ldots,n_k)$;
\item[Labelled Tuple Node.] A tuple labelled~$L$, denoted as~$L(n_1,\ldots,n_k)$;
\item[List Node.] A list of~$0$ or more children nodes, denoted as~$\emptylist$
      when the list is empty and~$[n_1,\ldots,n_k]$ for non-empty lists;
\item[Optional.] An optional node stands for a set of 0 or 1 occurrences of a sub-node $n$.
      We denote an empty optional by $\None$ and the non-empty optional by $\some{n}$;
\item[Record Node.] A record node, denoted as $\{\text{name}_1 : n_1,\ldots,\text{name}_k : n_k\}$, where \\
      $\text{name}_1 \ldots \text{name}_k$ are names, which associates names with corresponding nodes.
\end{description}

\hypertarget{def-substrecordfield}{}
The function $\substrecordfield(r, f, n)$ takes a record AST node $r$, a field name $f$ and an AST node $n$
and returns an AST record node $r'$ where the $f$ field is bound to $n$.

\section{Abstract Syntax Grammar\label{sec:AbstractSyntaxGrammar}}

An abstract syntax is defined in terms of derivation rules containing variables (also referred to as non-terminals).
%
A \emph{derivation rule} has the form $v \derives \textit{rhs}$ where $v$ is a non-terminal variable and \textit{rhs} is a \emph{node type}. We write $n$, $n_1,\ldots,n_k$ to denote node types.
%
Node types are defined recursively as follows:
\begin{description}
\item[Non-terminal.] A non-terminal variable;
\item[Terminal.] A lexical token $t$ or a label $L$;
\item[Unlabelled Tuple.] A tuple of node types, denoted as~$(n_1,\ldots,n_k)$;
\item[Labelled Tuple.] A tuple labelled~$L$, denoted as~$L(n_1,\ldots,n_k)$;
\item[List.] A list node type, denoted as $\KleeneStar{n}$;
\item[Optional.] An optional node type, denoted as $\Option{n}$;
\item[Record.] A record, denoted as $\{\text{name}_1 : n_1,\ldots,\text{name}_k : n_k\}$ where $\text{name}_i$, which associates names with corresponding node types.
\end{description}

\newpage

An abstract syntax consists of a set of derivation rules and a start non-terminal.

\section{Untyped Abstract Grammar\label{sec:UntypedAbstractGrammar}}

The abstract syntax of ASL is given in terms of the derivation rules below and the start non-terminal $\spec$.
%
Some extra details are given by using the notation $\overtext{\textit{symbol}}{\text{detail}}$.

\subsection{Identifiers \label{sec:Identifiers}}
Identifiers in the AST, denoted $\Identifier$ are simply strings representing ASL identifiers.
Those are obtained directly from the values of identifier tokens, $\Tidentifier(s)$.

\subsection{Literal Values \label{sec:ASTLiterals}}
The following rules correspond to literal values of the following ASL data types:
integers, Booleans, real numbers, bitvectors, and strings.

\RenderType{literal}

\subsection{Operators\label{sec:Operators}}
The following rules correspond to unary operators and binary operators,
which can be used in unary expressions and binary expressions.

\RenderType{unop}

The following table shows the token associated to each unary operator:
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{unary operator} & \textbf{operator token}\\
\hline
\BNOT{} & \Tbnot\\
\NEG{}  & \Tminus\\
\NOT{}  & \Tnot\\
\hline
\end{tabular}
\end{center}

\RenderType{binop}

The following table shows the token associated to each binary operator:
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{binary operator} & \textbf{operator token}\\
\hline
\BAND{}       & \Tband\\
\BOR{}        & \Tbor\\
\IMPL{}       & \Tbimpl\\
\BEQ{}        & \Tbeq\\
\EQ{}         & \Teqop\\
\NE{}        & \Tneq\\
\GT{}         & \Tgt\\
\GE{}        & \Tgeq\\
\LT{}         & \Tlt\\
\LE{}        & \Tleq\\
\ADD{}       & \Tplus\\
\SUB{}      & \Tminus\\
\OR{}         & \Tor\\
\XOR{}        & \Txor\\
\AND{}        & \Tand\\
\MUL{}        & \Tmul\\
\DIV{}        & \Tdiv\\
\DIVRM{}      & \Tdivrm\\
\MOD{}        & \Tmod\\
\SHL{}        & \shiftleftlexeme\\
\SHR{}        & \shiftrightlexeme\\
\RDIV{}       & \Trdiv\\
\POW{}        & \Tpow\\
\BVCONCAT{}   & \Tcoloncolon\\
\STRCONCAT{}  & \Tplusplus\\
\hline
\end{tabular}
\end{center}

\subsection{Expressions \label{sec:Expressions}}
The following rules correspond to various types of expressions:
literal expressions, variable expressions, type assertions, binary operation expressions, unary operation expressions,
call expressions, slicing expressions, conditional expressions, array access expressions, single-field access expressions, multiple-field access expressions,
record and exception construction expressions, tuple expressions, arbitrary-value expressions,
and pattern matching expressions.

\RenderTypes{untyped_expr}

\listingref{expr1} and \listingref{expr2} exemplify the different kinds of expressions,
as indicated by respective comments.
\ASLListing{Examples of expressions}{expr1}{\syntaxtests/expr1.asl}
\ASLListing{More examples of expressions}{expr2}{\syntaxtests/expr2.asl}

\begin{itemize}
  \item $\EVar(\vx)$ represents variables (\texttt{E\_Var}).

  \item $\EATC(\ve, \vt)$ represents type assertions. For example: \texttt{x as integer}.
  Here $\ve$ corresponds to \texttt{x} and $\vt$ corresponds to \texttt{integer}.

  \item $\ESlice(\ve, \vslices)$ represents slices of bitvectors (\texttt{E\_Slice 1}),
  slices of integers \\
  (\texttt{E\_Slice 2}),
  and access to array elements (\texttt{E\_Slice 3}).

  \item $\EGetField(\ve, \id)$ represents an access to a record (\texttt{E\_GetField 1})
        or exception field
        as well as an access to a tuple component (\texttt{E\_GetField 2}).

  \item $\EGetFields(\ve, \ids)$ represents an access to multiple record fields (\texttt{E\_GetFields 1}).
\end{itemize}

\subsection{Patterns \label{sec:Patterns}}
\hypertarget{constant-zerobit}{}
\hypertarget{constant-onebit}{}
\hypertarget{constant-xbit}{}
\RenderType{pattern}

\subsection{Slices \label{sec:Slices}}
\RenderTypes{untyped_slice}
\BackupOriginalAST{
\begin{flalign*}
\slice \derives\ & \SliceSingle(\overtext{\expr}{\vi}) &\\
  |\ & \SliceRange(\overtext{\expr}{\vj}, \overtext{\expr}{\vi}) &\\
  |\ & \SliceLength(\overtext{\expr}{\vi}, \overtext{\expr}{\vn}) &\\
  |\ & \SliceStar(\overtext{\expr}{\vi}, \overtext{\expr}{\vn}) &
\end{flalign*}
}

\subsection{Subprogram calls \label{sec:SubprogramCalls}}
\RenderType{call}
\BackupOriginalAST{
\begin{flalign*}
\call \derives\ &
{
\left\{
  \begin{array}{rcl}
 \callname &:& \Strings, \\
 \callparams &:& \expr, \\
 \callargs &:& \expr, \\
 \callcalltype &:& \subprogramtype
\end{array}
\right\}
} &
\end{flalign*}
}

\subsection{Types \label{sec:Types}}

\RenderType{ty}

\BackupOriginalAST{
\begin{flalign*}
\ty \derives\ & \TInt(\constraintkind)\\
  |\ & \TReal & \\
  |\ & \TString & \\
  |\ & \TBool & \\
  |\ & \TBits(\overtext{\expr}{width}, \bitfield^{*}) & \\
  |\ & \TTuple(\ty^{*}) & \\
  |\ & \TArray(\arrayindex, \ty) & \\
  |\ & \TNamed(\overtext{\Identifier}{type name}) & & \\
  |\ & \TEnum(\overtext{\Identifier^{*}}{labels})\\ & \\
  |\ & \TRecord(\field^{*}) & \\
  |\ & \TException(\field^{*}) & \\
  |\ & \TCollection(\field^{*})
\end{flalign*}
}

\subsection{Constraints \label{sec:Constraints}}
\RenderTypes{untyped_constraint_kind}
\BackupOriginalAST{
\begin{flalign*}
  \constraintkind \derives\ & \Unconstrained & \\
  |\ & \WellConstrained(\intconstraint^{+}) & \\
  |\ & \PendingConstrained{} & \\
  |\ & \Parameterized(\overtext{\Identifier}{parameter}) &
\end{flalign*}
}

\RenderType{int_constraint}
\BackupOriginalAST{
\begin{flalign*}
\intconstraint \derives\ & \ConstraintExact(\expr) & \\
  |\ & \ConstraintRange(\overtext{\expr}{start}, \overtext{\expr}{end})&
\end{flalign*}
}

\subsection{Bit Fields \label{sec:BitFields}}

\RenderType{bitfield}

\BackupOriginalAST{
\begin{flalign*}
\bitfield \derives\ & \BitFieldSimple(\Identifier, \slice^{*}) & \\
  |\ & \BitFieldNested(\Identifier, \slice^{*}, \bitfield^{*}) & \\
  |\ & \BitFieldType(\Identifier, \slice^{*}, \ty) &
\end{flalign*}
}

\subsection{Array Indices \label{sec:ArrayIndices}}
\hypertarget{ast-ArrayLengthEnum}{}
\RenderTypes{untyped_array_index}
\BackupOriginalAST{
The AST type for array indices is given by the following derivation:
\begin{flalign*}
\arrayindex \derives\ &  \ArrayLengthExpr(\overtext{\expr}{array length}) &
\end{flalign*}
}

\subsection{Fields and Typed Identifiers \label{sec:FieldsAndTypedIdentifiers}}

The following rule corresponds to a field of a record-like structure:
\RenderType{field}

\BackupOriginalAST{
\begin{flalign*}
\field \derives\ & (\Identifier, \ty) &
\end{flalign*}
}

The following rule corresponds to an identifier with its associated type:
\RenderType{typed_identifier}

\BackupOriginalAST{
\begin{flalign*}
\typedidentifier \derives\ & (\Identifier, \ty) &
\end{flalign*}
}

\subsection{Assignable Expressions \label{sec:AssignableExoressions}}
The following rules define the types of left-hand side of assignments:
\RenderTypes{untyped_lexpr}

\BackupOriginalAST{
\begin{flalign*}
\lexpr \derives\ & \overtext{\LEDiscard}{\texttt{"-"}} & \\
  |\ & \LEVar(\Identifier) & \\
  |\ & \LESlice(\lexpr, \KleeneStar{\slice}) & \\
  |\ & \LESetArray(\lexpr, \expr) & \\
  |\ & \LESetField(\lexpr, \Identifier) & \\
  |\ & \LESetFields(\lexpr, \KleeneStar{\Identifier}) & \\
  |\ & \LEDestructuring(\KleeneStar{\lexpr}) & \\
\end{flalign*}
}

\subsection{Local Declarations \label{sec:LocalDeclarations}}

\RenderType{local_decl_keyword}

\BackupOriginalAST{
\begin{flalign*}
\localdeclkeyword \derives\ & \LDKVar \;|\; \LDKLet &
\end{flalign*}
}

A local declaration item is the left-hand side of a declaration statements.
In the following example of a declaration statement:
\begin{lstlisting}
let (x, -, z): (integer, integer, integer {0..32}) = (2, 3, 4);
\end{lstlisting}
the local declaration item is
\begin{lstlisting}
(x, -, z): (integer, integer, integer {0..32})
\end{lstlisting}

\RenderType{local_decl_item}
\BackupOriginalAST{
\begin{flalign*}
\localdeclitem \derives\ &
  & \\
  |\ & \LDIVar(\Identifier)
  & \\
  |\ & \LDITuple(\KleeneStar{\Identifier}) &
\end{flalign*}
}
\subsection{Statements \label{sec:Statements}}
\RenderTypes{untyped_stmt}
\RenderType{for_direction}
\BackupOriginalAST{
\begin{flalign*}
\fordirection \derives\ & \UP \;|\; \DOWN &\\
\\
\stmt \derives\ & \SPass &\\
  |\ & \SSeq(\stmt, \stmt) & \\
  |\ & \SDecl(\localdeclkeyword, \localdeclitem, \ty?, \expr?) & \\
  |\ & \SAssign(\lexpr, \expr) & \\
  |\ & \SCall(\call) & \\
  |\ & \SReturn(\expr?) & \\
  |\ & \SCond(\expr, \stmt, \stmt) & \\
  |\ & \SAssert(\expr) & \\
  |\ & \SFor\left\{
    \begin{array}{rcl}
    \Forindexname  &:& \Identifier,\\
    \Forstarte     &:& \expr,\\
    \Fordir        &:& \fordirection,\\
    \Forende       &:& \expr,\\
    \Forbody       &:& \stmt,\\
    \Forlimit      &:& \expr?
    \end{array}
  \right\} & \\
  |\ & \SWhile(\overtext{\expr}{condition}, \overtext{\expr?}{loop limit}, \overtext{\stmt}{loop body}) & \\
  |\ & \SRepeat(\overtext{\stmt}{loop body}, \overtext{\expr}{condition}, \overtext{\expr?}{loop limit}) & \\
  |\ & \SThrow(\expr) &\\ & \\
  |\ & \STry(\stmt, \KleeneStar{\catcher}, \overtext{\stmt?}{otherwise}) & \\
  |\ & \SPrint(\overtext{\KleeneStar{\expr}}{args}, \overtext{\Bool}{newline}) & \\
  |\ & \SPragma(\Tidentifier, \overtext{\KleeneStar{\expr}}{args}) & \\
  |\ & \SUnreachable
\end{flalign*}
}

\subsection{Case Alternatives \label{sec:CaseAlternatives}}

\RenderType{case_alt}

\BackupOriginalAST{
\begin{flalign*}
\casealt \derives\ & \{ \CasePattern : \pattern, \CaseWhere : \expr?, \CaseStmt : \stmt \} &
}

\subsection{Exception Catchers \label{sec:ExceptionCatchers}}
\RenderType{catcher}

\BackupOriginalAST{
\begin{flalign*}
\catcher \derives\ & (\overtext{\Identifier?}{exception to match}, \overtext{\ty}{guard type}, \overtext{\stmt}{statement to execute on match}) &
\end{flalign*}
}

\subsection{Subprograms \label{sec:Subprograms}}
\RenderType{subprogram_type}

\BackupOriginalAST{
\begin{flalign*}
\subprogramtype \derives\ & \STProcedure \;|\; \STFunction &\\
                |\  & \STGetter \;|\; \STSetter &
\end{flalign*}
}

\RenderType{func_qualifier}

\BackupOriginalAST{
\begin{flalign*}
\qualifier \derives\ & \Pure \;|\; \Readonly \;|\; \Noreturn &
\end{flalign*}
}

\RenderType{override_info}

\BackupOriginalAST{
\begin{flalign*}
\overrideinfo \derives\ & \Impdef \;|\; \Implementation &
\end{flalign*}
}

\RenderType{func}

\BackupOriginalAST{
\begin{flalign*}
\func \derives\ &
{
\left\{
  \begin{array}{rcl}
 \funcname &:& \Strings, \\
 \funcparameters &:& \KleeneStar{(\Identifier, \ty?)},\\
 \funcargs &:& \KleeneStar{\typedidentifier},\\
 \funcbody &:& \stmt,\\
 \funcreturntype &:& \ty?,\\
 \funcsubprogramtype &:& \subprogramtype\\
 \funcrecurselimit    &:& \expr?\\
 \funcbuiltin &:& \Bool\\
 \funcqualifierfield &:& \some{\funcqualifier}\\
 \funcoverride &:& \some{\overrideinfo}\\
\end{array}
\right\}
} &
\end{flalign*}
}

\subsection{Global Declarations \label{sec:GlobalDeclarations}}
Declaration keyword for global storage elements:
\RenderType{global_decl_keyword}

\BackupOriginalAST{
\begin{flalign*}
\globaldeclkeyword \derives\ & \GDKConstant \;|\; \GDKConfig \;|\; \GDKLet \;|\; \GDKVar &
\end{flalign*}
}

\RenderType{global_decl}

\BackupOriginalAST{
\begin{flalign*}
\globaldecl \derives\ &
{\left\{
  \begin{array}{rcl}
  \GDkeyword &:& \globaldeclkeyword, \\
  \GDname &:& \Identifier,\\
  \GDty &:& \ty?,\\
  \GDinitialvalue &:& \expr?
  \end{array}
  \right\}
 } &
\end{flalign*}
}

\RenderType{decl}

\BackupOriginalAST{
\begin{flalign*}
\decl \derives\ & \DFunc(\func) & \\
  |\ & \DGlobalStorage(\globaldecl) & \\
  |\ & \DTypeDecl(\Identifier, \ty, (\Identifier, \overtext{\KleeneStar{\field}}{with fields})?) & \\
  |\ & \DPragma(\Tidentifier, \overtext{\KleeneStar{\expr}}{args})
\end{flalign*}
}

\subsection{Specifications \label{sec:Specifications}}
\RenderType{spec}

\BackupOriginalAST{
\begin{flalign*}
\spec \derives\ & \KleeneStar{\decl} &
\end{flalign*}
}

\section{Typed Abstract Syntax Grammar\label{sec:TypedAbstractSyntaxGrammar}}

The derivation rules for the typed abstract syntax are the same as the rules for the untyped abstract syntax,
except for the following differences.

The rules for expressions have the following extra derivation rules:
\RenderTypes[remove_hypertargets]{typed_expr}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EGetItem(\expr, \N) &\\ {}
             |\ & \EArray \{\EArrayLength: \expr, \EArrayValue: \expr\} & \\
             |\ & \EEnumArray \{\EArrayLabels: \identifier^+, \EArrayValue: \expr\} & \\
             |\ & \EGetEnumArray(\overtext{\expr}{base}, \overtext{\expr}{key}) & \\
             |\ & \EGetCollectionFields(\overtext{\identifier}{collection}, \overtext{\identifier^{*}}{field names}) & \\
\end{flalign*}
}

The rules for left-hand-side expressions have the following extra derivation rules:
\hypertarget{ast-LESetCollectionFields}{}
\hypertarget{ast-LESetEnumArray}{}
\hypertarget{ast-EGetCollectionFields}{}
\hypertarget{ast-EGetEnumArray}{}
\hypertarget{ast-EEnumArray}{}
\hypertarget{ast-EArray}{}
\hypertarget{ast-EGetItem}{}
\RenderTypes[remove_hypertargets]{typed_lexpr}
\BackupOriginalAST{
\begin{flalign*}
  \lexpr \derives\ & \LESetEnumArray(\overtext{\lexpr}{base}, \overtext{\expr}{index}) & \\
                |\ & \LESetCollectionFields(\overtext{\Identifier}{collection}, \overtext{\Identifier^{*}}{field names}) &\\
\end{flalign*}
}

The intention for each AST node type above is as follows:
\begin{itemize}
  \item $\EGetItem(\ve, i)$ accesses the $i$th component of the tuple given by
    the expression $\ve$.
  \item $\EArray\{\EArrayLength: \veone, \EArrayValue: \vetwo\}$ is used to
    construct an integer-indexed array value in order to initialize an
    array-typed variable;
  \item $\EEnumArray\{\EArrayLabels: \vl_{1..k}, \EArrayValue: \vetwo\}$ is used
    to construct an enumeration-indexed array value in order to initialize an
    array-typed variable;
  \item $\EGetEnumArray(\ebase, \ekey)$ is used for accessing an enumerated
    array given by $\ebase$ at the entry given by $\ekey$;
  \item $\LESetEnumArray(\ebase, \evalue)$ is used for updating an enumerated
    array left-hand-side expression given by $\ebase$ with the value given by
    $\evalue$;
  \item $\EGetCollectionFields(\ebase, \ekey)$ is used for accessing a
    collection given by $\ebase$ at the entry given by $\ekey$;
  \item $\LESetCollectionFields(\ebase, \ekey)$ is used for updating a
    collection given by $\ebase$ at the entry given by $\ekey$.
\end{itemize}

The rules for statements exclude \texttt{pragma} statements, since those are transformed into
\passstatementsterm\ (see \TypingRuleRef{SPragma}).

The rules for statements refine the throw statement by annotating it with
the type of the thrown exception.
\hypertarget{ast-typedSThrow}{}
\RenderTypes[remove_hypertargets]{typed_stmt}
\BackupOriginalAST{
\begin{flalign*}
\stmt \derives\ & \SThrow(\expr, \overtext{\ty}{exception type}) &
\end{flalign*}
}

The rules for slices is replaced by the following single derivation:
\hypertarget{ast-typedSliceLength}{}
\RenderTypes[remove_hypertargets]{typed_slice}

\BackupOriginalAST{
\begin{flalign*}
\slice \derives\ & \SliceLength(\overtext{\expr}{start index}, \overtext{\expr}{length}) &
\end{flalign*}
}

This reflects the fact that all other slicing constructs are syntactic sugar
for \\
$\SliceLength$.

The following extra rule enables expressing array indices based on enumeration:
\RenderTypes[remove_hypertargets]{typed_array_index}
\BackupOriginalAST{
\begin{flalign*}
\arrayindex \derives\ &  \ArrayLengthEnum(\overtext{\Identifier}{name of enumeration}, \overtext{\Identifier^+}{enumeration labels}) &
\end{flalign*}
}

The rules for constraint kinds refine the well-constrained kind by a precision
indicator, which indicates whether precision has been lost during the typing of
binary operations over well-constrained integer types (see \TypingRuleRef{IntervalTooLarge}).
\hypertarget{ast-typedWellConstrained}{}
\RenderTypes[remove_hypertargets]{typed_constraint_kind}
\RenderType{precision_loss_indicator}
\BackupOriginalAST{
\begin{flalign*}
\precisionlossindicator \derives\ & \PrecisionFull & \\
                                |\ & \PrecisionLost & \\
        \constraintkind \derives\ & \WellConstrained(\intconstraint^{+}, \precisionlossindicator) & \\
\end{flalign*}
}

In the \untypedast, the $\globaldecl$ child node in the abstract syntax nodes of the form $\DGlobalStorage(\globaldecl)$
contains an optional expression field assigned to the $\GDinitialvalue$ field. In the \typedast, this field
always contains an expression (that is, it is never $\None$).

Global pragma declarations $\DPragma$ are removed from the \untypedast\ once their expressions have been typechecked and do not appear in the \typedast.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Abstract Syntax Trees\label{sec:BuildingAbstractSyntaxTrees}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section defines how to transform a parse tree into the corresponding AST
via recursively traversing the parse tree and applying a \emph{builder} function
for each non-terminal node.

(Some of the builders are relations due to non-determinism induced by naming global variables
for assignments whose left-hand-side variable is discarded ($\Tminus$).)

\hypertarget{def-tbuilderror}{}
\hypertarget{def-builderrorconfig}{}
For each non-terminal $N \derives R_1 \;|\; \ldots R_k$, we define a builder function
$\textsf{build\_}N $ which takes a parse tree $\parsenode{N}$ and returns the corresponding
AST or a \emph{build error configuration} $\BuildErrorConfig \in \TBuildError$.
The builder function is defined in terms of one inference rule per alternative $R_i$.
The input for the builder for an alternative $R = S_{1..m}$ is a parse node
$N(S_{1..m})$. To allow the builder to refer to the children nodes of $N$,
we use the notation $\namednode{n_i}{S_i}$, which names the child node $S_i$ as $n_i$.

The set of builder relations is defined in the respective chapters for their constructs
(for example, the builder for expressions is defined in \chapref{Expressions}).

\subsection{Example}
Consider the derivation for while loops:
\[
\Nstmt \derives \Twhile \parsesep \Nexpr \parsesep \Tdo \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon
\]

The parse node for a while statement has the form
\[
\Nstmt(\Twhile, \namednode{\ve}{\Nexpr}, \Tdo, \namednode{\vstmtlist}{\Nstmtlist}, \Tend, \Tsemicolon)
\]
where $\ve$ names the node representing the condition of the loop and $\vstmtlist$ names
the list of statements that form the body of the loop.

To build the corresponding AST, we employ the builder function $\buildstmt$, since
the non-terminal labelling the parse node is $\Nstmt$.

We also employ the following rule:
\begin{mathpar}
\inferrule{
  \buildexpr(\ve) \astarrow \astversion{\ve}\\
  \buildstmtlist(\vstmtlist) \astarrow \astversion{\vstmtlist}
}{
  {
  \begin{array}{r}
    \buildstmt(\Nstmt(\Twhile, \namednode{\ve}{\Nexpr}, \Tdo, \namednode{\vstmtlist}{\Nstmtlist}, \Tend, \Tsemicolon))
    \astarrow\\
    \SWhile(\astversion{\ve}, \None, \astversion{\vstmtlist})
  \end{array}
  }
}
\end{mathpar}
That is, we apply the $\buildexpr$ to transform the condition parse node $\ve$ into the corresponding AST node,
we apply $\buildstmtlist$ to transform the parse node $\vstmtlist$ for the body of the list into the corresponding AST node,
and finally return the AST node for \texttt{while} loops --- $\SWhile$ --- with the two nodes as its children.

We define some builders as relations rather than functions. This is due to the non-determinism
in creating identifiers for auxiliary variables that stand in for instances of \discardvar{} on the left-hand-side
of assignments and declarations.
For example, \texttt{- = 5;} will effectively create some auxiliary variable, which will result in
an AST node such as $\SAssign(\EVar(\texttt{aux-1}), \ELiteral(\LInt(5)))$.
Recall that hyphens are not legal characters in ASL identifiers, which avoids potential clashes with
user-supplied identifiers. An implementation is free however to choose other naming schemes that
avoid name clashes, for example, by employing counters.

\subsection{Abbreviated Rule Notation for AST Builders}
Notice that there is only one instance of $\Nexpr$ and one instance of $\Nstmtlist$ in this production.
This is very common and we therefore use the following shorthand notation for such cases, as explained next.

In a non-terminal $N$ appears only once in the right-hand-side of a derivation,
we use the name $\texttt{N}$ to name the corresponding child parse node.
For example, $\namednode{\vexpr}{\Nexpr}$ and $\namednode{\vstmtlist}{\Nstmtlist}$.
In such cases, we always have the premise $\textsf{build\_}N(\texttt{N}) \astarrow \astversion{N}$
to obtain the corresponding AST node.
We therefore make this premise implicit, by dropping it entirely and using $\astof{N}$ to mean that
the parse node $N$ is named $\texttt{N}$, the premise $\textsf{build\_}N(\texttt{N}) \astarrow \astversion{N}$
is considered part of the rule and $\astversion{N}$ itself stands for $\astversion{N}$.

In our example, this results in the abbreviated rule notation
\begin{mathpar}
\inferrule{}{
{
\begin{array}{r}
  \buildstmt(\Nstmt(\Twhile, \punnode{\Nexpr}, \Tdo, \punnode{\Nstmtlist}, \Tend, \Tsemicolon))
  \astarrow\\
  \SWhile(\astof{\vexpr}, \None, \astof{\vstmtlist})
  \end{array}
}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Parameterized Productions\label{sec:BuildingParameterizedProductions}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section defines builder relations for the
subset of macro productions in \secref{ParametricProductions}
that are not inlined:
\begin{itemize}
  \item \ASTRuleRef{List}
  \item \ASTRuleRef{CList}
  \item \ASTRuleRef{PList}
  \item \ASTRuleRef{NTCList}
  \item \ASTRuleRef{Option}
\end{itemize}

We also define \ASTRuleRef{Identity},
which can be used in conjunction with the rules above in application
to terminals.

\ASTRuleDef{List}
\hypertarget{build-list}{}
The meta relation
\[
\buildlist[b](\overname{N}{\vsyms}) \;\aslrel\; \overname{A}{\vsymasts}
\]
which is parameterized by an AST building relation $b : E \aslrel A$,
takes a parse node that represents a possibly-empty list of $E$ values --- $\vsyms$ --- and returns the result of applying $b$
to each of them --- $\vsymasts$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildlist[b](\overname{\emptysentence}{\vsyms}) \astarrow \overname{\emptylist}{\vsymasts}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  b(\vv) \astarrow \astversion{\vv}\\
  \buildlist[b](\vsymsone) \astarrow \vsymastsone
}{
  \buildlist[b](\overname{
    \maybeemptylist{N}(\namednode{\vv}{E}, \namednode{\vsymsone}{\maybeemptylist{N}})
    }{\vsyms}) \astarrow
  \overname{[\astversion{\vv}] \concat \vsymastsone}{\vsymasts}
}
\end{mathpar}

\ASTRuleDef{CList}
\hypertarget{build-clist}{}
The meta relation
\[
\buildclist[b](\overname{N}{\vsyms}) \;\aslrel\; \overname{A}{\vsymasts}
\]
which is parameterized by an AST building relation $b : E \aslrel A$,
takes a parse node that represents a possibly-empty comma-separated list of $E$ values --- $\vsyms$ --- and returns the result of applying $b$
to each of them --- $\vsymasts$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildclist[b](\overname{\emptysentence}{\vsyms}) \astarrow \overname{\emptylist}{\vsymasts}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  b(\vv) \astarrow \astversion{\vv}\\
  \buildclist[b](\vsymsone) \astarrow \vsymastsone
}{
  \buildclist[b](\overname{
    \ClistZero{N}(\namednode{\vv}{E}, \Tcomma, \namednode{\vsymsone}{\ClistOne{N}})
    }{\vsyms}) \astarrow \overname{[\astversion{\vv}] \concat \vsymastsone}{\vsymasts}
}
\end{mathpar}

\ASTRuleDef{PList}
\hypertarget{build-plist}{}
The meta relation
\[
\buildplist[b](\overname{N}{\vsyms}) \;\aslrel\; \overname{A}{\vsymasts}
\]
which is parameterized by an AST building relation $b : E \aslrel A$,
takes a parse node that represents a parenthesized comma-separated list of $E$ values --- $\vsyms$ --- and returns the result of applying $b$
to each of them --- $\vsymasts$.

\begin{mathpar}
\inferrule{
  \buildclist[b](\vv) \astarrow \astversion{\vv}
}{
  \buildplist[b](\Tlpar, \namednode{\vv}{L}, \Trpar) \astarrow \astversion{\vv}
}
\end{mathpar}

\ASTRuleDef{NTCList}
\hypertarget{build-tclist}{}
The meta relation
\[
\buildtclist[b](\overname{N}{\vsyms}) \;\aslrel\; \overname{A}{\vsymasts}
\]
which is parameterized by an AST building relation $b : E \aslrel A$,
takes a parse node that represents a non-empty comma-separated trailing list of $E$ values --- $\vsyms$ --- and returns the result of applying $b$
to each of them --- $\vsymasts$.

\begin{mathpar}
\inferrule[empty]{
  b(\vv) \astarrow \astversion{\vv}
}{
  \buildtclist[b](\overname{\vv \parsesep \Option{\Tcomma}}{\vsyms}) \astarrow \overname{[\astversion{\vv}]}{\vsymasts}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  b(\vv) \astarrow \astversion{\vv}\\
  \buildtclist[b](\vsymsone) \astarrow \vsymastsone
}{
  \buildtclist[b](\overname{\namednode{\vv}{E}, \Tcomma, \namednode{\vsymsone}{\TClistOne{N}}}{\vsyms}) \astarrow \overname{[\astversion{\vv}] \concat \vsymastsone}{\vsymasts}
}
\end{mathpar}

\ASTRuleDef{Option}
\hypertarget{build-option}{}
The meta relation
\[
\buildoption[b](\overname{N}{\vsym}) \;\aslrel\; \overname{\Option{A}}{\vsymast}
\]
which is parameterized by an AST building relation $b : N \aslrel A$,
takes a parse node that represents an optional $N$ value $\vsym$, and returns the result of applying $b$
to the value if it exists --- $\vsymasts$.

\begin{mathpar}
\inferrule[none]{}{
  \buildoption[b](\overname{\emptysentence}{\vsym}) \astarrow \overname{\None}{\vsymast}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  b(\vv) \astarrow \astversion{\vv}
}{
  \buildoption[b](\overname{\namednode{\vv}{N}}{\vsym}) \astarrow \overname{\Option{\astversion{\vv}}}{\vsymast}
}
\end{mathpar}

When this relation is applied to a sentence consisting of a prefix of terminals $t_{1..k}$, ending with a non-terminal $\vv$,
it ignore the terminals and returns the result for the non-terminal.
\begin{mathpar}
\inferrule[last]{
  \buildoption[b](\vv) \astarrow \vsymast
}{
  \buildoption[b](t_{1..k}, \namednode{\vv}{N}) \astarrow \vsymast
}
\end{mathpar}

\ASTRuleDef{Identity}
\hypertarget{build-identity}{}
The meta function
\[
\buildidentity(\overname{T}{x}) \aslto \overname{T}{x}
\]
is the identity function, which can be used as an argument to meta functions such as $\buildlist$ when they are applied
to terminals.

\begin{mathpar}
\inferrule{}{
  \buildidentity(x) \astarrow x
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transforming Assignable Expressions \\ to Right-hand side Expressions\label{sec:LeftToRight}}
\RenderRelation{rexpr}
This function is utilized by both the type system and the dynamic semantics.
It is defined recursively by the following table:
\[
\begin{array}{lcl}
  \textbf{Assignable expression} & & \textbf{Right-hand side expression}\\
  \hline
  \torexpr(\LEVar(\vx)) &=& \EVar(\vx)\\
  \torexpr(\LESlice(\vle, \vargs)) &=& \ESlice(\torexpr(\vle), \vargs)\\
  \torexpr(\LESetArray(\vle, \ve)) &=& \EGetArray(\torexpr(\vle), \ve)\\
  \torexpr(\LESetEnumArray(\vle, \ve)) &=& \EGetEnumArray(\torexpr(\vle), \ve)\\
  \torexpr(\LESetField(\vle, \vx)) &=& \EGetField(\torexpr(\vle), \vx)\\
  \torexpr(\LESetFields(\vle, \vx)) &=& \EGetFields(\torexpr(\vle), \vx)\\
  \torexpr(\LEDiscard) &=& \EVar(\discardvar)\\
  \torexpr(\LEDestructuring([\vle_{1..k}])) &=& \ETuple([i=1..k: \torexpr(\vle_i)])\\
\end{array}
\]

\section{Abstract Syntax Abbreviations\label{sec:AbstractSyntaxAbreviations}}
We employ the following abbreviations for various AST nodes:
\begin{center}
\begin{tabular}{ll}
\hline
\textbf{Abbreviation} & \textbf{Meaning}
\hypertarget{def-etrue}{}\\
\hline
$\ETrue$ & $\ELiteral(\LBool(\True))$ \hypertarget{def-elint}{}\\
$\ELInt{n}$ & literal integer expression: $\ELiteral(\LInt(n))$
\hypertarget{def-abbrevevar}{}\\
$\AbbrevEVar{\vx}$ & $\EVar(\vx)$
\hypertarget{def-abbrevconstraintexact}{}\\
$\AbbrevConstraintExact{\ve}$ & $\ConstraintExact(\ve)$
\hypertarget{def-abbrevconstraintrange}{}\\
$\AbbrevConstraintRange{\veone}{\vetwo}$ & $\ConstraintRange(\veone, \vetwo)$ \hypertarget{def-abbrevebinop}{}\\
$\AbbrevEBinop{\op}{\veone}{\vetwo}$ & $\EBinop(\op, \veone, \vetwo)$ \hypertarget{def-abbrevtarray}{}\\
$\AbbrevTArray{\vi}{\vt}$ & $\TArray(\ArrayLengthExpr(\vi), \vt)$ \hypertarget{def-abbrevtarraylengthexpr}{}\\
$\AbbrevTArrayLengthExpr{\ve}{\vt}$ & $\TArray(\ArrayLengthExpr(\ve), \vt)$ \hypertarget{def-abbrevtarraylengthenum}{}\\
$\AbbrevTArrayLengthEnum{\ve}{\vs}{\vt}$ & $\TArray(\ArrayLengthEnum(\ve, \vs), \vt)$\\
\hline
\end{tabular}
\end{center}
