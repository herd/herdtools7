%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Abstract Syntax\label{chap:AbstractSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
An abstract syntax is a form of context-free grammar over structured trees.
Compilers and interpreters typically start by parsing the text of a program and producing an abstract syntax tree (AST, for short),
and then continue to operate over that tree.
%
The reason for this is that abstract syntax trees abstract away details that are irrelevant to the semantics of the program,
such as punctuation and scoping syntax, which are useful for readability and parsing.

\hypertarget{def-typedast}{}
\hypertarget{def-untypedast}{}
\paragraph{Untyped AST vs. Typed AST:}
Technically, there are two abstract syntaxes:
an \emph{untyped abstract syntax} and a \emph{typed abstract syntax}.
The first syntax results from parsing the text of an ASL specification.
The typechecker checks whether the untyped AST satisfies the rules of the
type system. If so, it is considered valid and the type system rules
produce a typed AST.

\paragraph{Outline:}
The outline of this chapter is as follows,
We first define the type of Abstract Syntax Trees used by ASL (\secref{AbstractSyntaxTrees}).
We then define the notations for defining the AST grammar used by ASL (\secref{AbstractSyntaxGrammar})
Finally, we define the AST grammar rules for the different ASL constructs along with examples:
\begin{itemize}
  \item Identifiers (\secref{Identifiers})
  \item Literal values (\secref{ASTLiterals})
  \item Basic Operations (\secref{BasicOperations})
  \item Expressions (\secref{Expressions})
  \item Patterns (\secref{Patterns})
  \item Slices (\secref{Slices})
  \item Subprogram calls (\secref{SubprogramCalls})
  \item Types (\secref{Types})
  \item Constraints (\secref{Constraints})
  \item Bit Fields (\secref{BitFields})
  \item Array Indices (\secref{ArrayIndices})
  \item Fields and Typed Identifiers (\secref{FieldsAndTypedIdentifiers})
  \item Left-hand Side Expressions (\secref{LeftHandSideExpressions})
  \item Local Declarations (\secref{LocalDeclarations})
  \item Statements (\secref{Statements})
  \item Case Alternatives (\secref{CaseAlternatives})
  \item Exception Catchers (\secref{ExceptionCatchers})
  \item Subprograms (\secref{Subprograms})
  \item Global Declarations (\secref{GlobalDeclarations})
  \item Specifications (\secref{Specifications})
\end{itemize}
We then define the following:
\begin{itemize}
\item the grammar rules for the \untypedast\ (\secref{UntypedAbstractGrammar})
\item the grammar rules for the \typedast\ (\secref{TypedAbstractSyntaxGrammar})
\item how we use inference rules to define the transformation from a parse tree into an \untypedast\ (\secref{BuildingAbstractSyntaxTrees})
\item rules for building ASTs from parameterized productions (\secref{BuildingParameterizedProductions})
\item how \assignableexpressions\ can be viewed as corresponding right hand side expressions (\secref{LeftToRight})
\item finally, we define some useful abbreviations for denoting abstract syntax trees in rules (\secref{AbstractSyntaxAbreviations})
\end{itemize}

\section{Abstract Syntax Trees\label{sec:AbstractSyntaxTrees}}

In an ASL abstract syntax tree, a node is one the following data types:
\begin{description}
\item[Token Node.] A lexical token, denoted as in the lexical description of ASL;
\item[Label Node.] A label
\item[Unlabelled Tuple Node.] A tuple of children nodes, denoted as $(n_1,\ldots,n_k)$;
\item[Labelled Tuple Node.] A tuple labelled~$L$, denoted as~$L(n_1,\ldots,n_k)$;
\item[List Node.] A list of~$0$ or more children nodes, denoted as~$\emptylist$
      when the list is empty and~$[n_1,\ldots,n_k]$ for non-empty lists;
\item[Optional.] An optional node stands for a list of 0 or 1 occurrences of a sub-node $n$. We denote an empty optional by $\langle\rangle$ and the non-empty optional by $\langle n \rangle$;
\item[Record Node.] A record node, denoted as $\{\text{name}_1 : n_1,\ldots,\text{name}_k : n_k\}$, where \\
      $\text{name}_1 \ldots \text{name}_k$ are names, which associates names with corresponding nodes.
\end{description}

\hypertarget{def-substrecordfield}{}
The function $\substrecordfield(r, f, n)$ takes a record AST node $r$, a field name $f$ and an AST node $n$
and returns an AST record node $r'$ where the $f$ field is bound to $n$.

\section{Abstract Syntax Grammar\label{sec:AbstractSyntaxGrammar}}

An abstract syntax is defined in terms of derivation rules containing variables (also referred to as non-terminals).
%
A \emph{derivation rule} has the form $v \derives \textit{rhs}$ where $v$ is a non-terminal variable and \textit{rhs} is a \emph{node type}. We write $n$, $n_1,\ldots,n_k$ to denote node types.
%
Node types are defined recursively as follows:
\begin{description}
\item[Non-terminal.] A non-terminal variable;
\item[Terminal.] A lexical token $t$ or a label $L$;
\item[Unlabelled Tuple.] A tuple of node types, denoted as~$(n_1,\ldots,n_k)$;
\item[Labelled Tuple.] A tuple labelled~$L$, denoted as~$L(n_1,\ldots,n_k)$;
\item[List.] A list node type, denoted as $n^{*}$;
\item[Optional.] An optional node type, denoted as $n?$;
\item[Record.] A record, denoted as $\{\text{name}_1 : n_1,\ldots,\text{name}_k : n_k\}$ where $\text{name}_i$, which associates names with corresponding node types.
\end{description}

\newpage

An abstract syntax consists of a set of derivation rules and a start non-terminal.

\newcommand\ASTComment[1]{//\quad\textit{#1}\ }

\section{Untyped Abstract Grammar\label{sec:UntypedAbstractGrammar}}

The abstract syntax of ASL is given in terms of the derivation rules below and the start non-terminal $\spec$.
%
Some extra details are given by using the notation $\overname{\textit{symbol}}{\text{detail}}$.

\subsection{Identifiers \label{sec:Identifiers}}
\hypertarget{ast-identifier}{}
Identifiers in the AST, denoted $\identifier$ are simply strings representing ASL identifiers.
Those are obtained directly from the values of identifier tokens, $\Tidentifier(s)$.

\subsection{Literal Values \label{sec:ASTLiterals}}
The following rules correspond to literal values of the following ASL data types:
integers, Booleans, real numbers, bitvectors, and strings.

\hypertarget{ast-literal}{} \hypertarget{ast-lint}{}
\begin{flalign*}
\literal \derives\ & \lint(\overtext{n}{$\Z$})
& \hypertarget{ast-lbool}{}
\\
 |\ & \lbool(\overtext{b}{$\Bool$})
 & \hypertarget{ast-lreal}{}
\\
 |\ & \lreal(\overtext{q}{$\Q$})
 & \hypertarget{ast-lbitvector}{}
\\
 |\ & \lbitvector(\overtext{B}{$B \in \{0, 1\}^*$})
 & \hypertarget{ast-lstring}{}
\\
 |\ & \lstring(\overtext{S}{$S \in \{C \;|\; \texttt{"$C$"}\ \in\ \Strings\}$}) &
 \hypertarget{ast-llabel}{} \\
 |\ & \llabel(\overtext{l}{enumeration label})
 & \\
\end{flalign*}

\subsection{Basic Operations\label{sec:BasicOperations}}
The following rules correspond to unary operations and binary operations that can be applied to expressions.

\hypertarget{ast-unop}{} \hypertarget{ast-bnot}{} \hypertarget{ast-neg}{} \hypertarget{ast-not}{}
\begin{flalign*}
\unop \derives\ & \overtext{\BNOT}{\texttt{"!"}} \;|\; \overtext{\NEG}{\texttt{"-"}} \;|\; \overtext{\NOT}{\texttt{"NOT"}}
& \hypertarget{ast-binop}{} \hypertarget{ast-bor}{} \hypertarget{ast-impl}{} \hypertarget{ast-beq}{} \hypertarget{ast-band}{}
\\
\binop  \derives\ & \overtext{\BAND}{\texttt{"\&\&"}} \;|\; \overtext{\BOR}{\texttt{"||"}} \;|\; \overtext{\IMPL}{\texttt{"-->"}}
              \;|\; \overtext{\BEQ}{\texttt{"<->"}}
              & \hypertarget{ast-eqop}{} \hypertarget{ast-neq}{} \hypertarget{ast-gt}{} \hypertarget{ast-geq}{} \hypertarget{ast-lt}{} \hypertarget{ast-leq}{}
\\
        |\ & \overtext{\EQOP}{\texttt{"=="}} \;|\; \overtext{\NEQ}{\texttt{"!="}} \;|\; \overtext{\GT}{\texttt{">"}}
        \;|\; \overtext{\GEQ}{\texttt{">="}} \;|\; \overtext{\LT}{\texttt{"<"}} \;|\; \overtext{\LEQ}{\texttt{"<="}}
        & \hypertarget{ast-plus}{} \hypertarget{ast-minus}{} \hypertarget{ast-or}{} \hypertarget{ast-xor}{} \hypertarget{ast-and}{}
\\
        |\ & \overtext{\PLUS}{\texttt{"+"}} \;|\; \overtext{\MINUS}{\texttt{"-"}} \;|\; \overtext{\OR}{\texttt{"OR"}}
        \;|\; \overtext{\XOR}{\texttt{"XOR"}} \;|\; \overtext{\AND}{\texttt{"AND"}}
        & \hypertarget{ast-mul}{} \hypertarget{ast-div}{} \hypertarget{ast-divrm}{} \hypertarget{ast-mod}{} \hypertarget{ast-shl}{} \hypertarget{ast-shr}{}
\\
        |\ & \overtext{\MUL}{\texttt{"*"}} \;|\; \overtext{\DIV}{\texttt{"DIV"}} \;|\; \overtext{\DIVRM}{\texttt{"DIVRM"}}
        \;|\; \overtext{\MOD}{\texttt{"MOD"}} \;|\; \overtext{\SHL}{\texttt{"<<"}}  \;|\; \overtext{\SHR}{\texttt{">>"}}
        & \hypertarget{ast-rdiv}{} \hypertarget{ast-pow}{} \hypertarget{ast-concat}{}
\\
        |\ & \overtext{\RDIV}{\texttt{"/"}} \;|\; \overtext{\POW}{\texttt{"\^{}"}} \;|\; \overtext{\CONCAT}{\texttt{"::"}}
        &
\end{flalign*}

\subsection{Expressions \label{sec:Expressions}}
The following rules correspond to various types of expressions:
literal expressions, variable expressions, typing assertions, binary operation expressions, unary operation expressions,
call expressions, slicing expressions, conditional expressions, array access expressions, single-field access expressions, multiple-field access expressions,
record and exception construction expressions, tuple expressions, arbitrary-value expressions,
and pattern matching expressions.

\hypertarget{ast-expr}{} \hypertarget{ast-eliteral}{}
\begin{flalign*}
\expr \derives\ & \ELiteral(\literal)
& \hypertarget{ast-evar}{}\\
	|\ & \EVar(\overtext{\identifier}{variable name})
  &\hypertarget{ast-eatc}{}\\
	|\ & \overtext{\EATC}{Type assertion}(\expr, \overtext{\ty}{asserted type})
  &\hypertarget{ast-ebinop}{}\\
	|\ & \EBinop(\binop, \expr, \expr)
  &\hypertarget{ast-eunop}{}\\
	|\ & \EUnop(\unop, \expr)
  &\hypertarget{ast-ecall}{}\\
	|\ & \ECall(\call)
  &\hypertarget{ast-eslice}{}\\
	|\ & \ESlice(\expr, \slice^{*})
  &\hypertarget{ast-econd}{}\\
	|\ & \ECond(\overtext{\expr}{condition}, \overtext{\expr}{then}, \overtext{\expr}{else})
  &\hypertarget{ast-egetarray}{}\\
  |\ & \EGetArray(\overtext{\expr}{base}, \overtext{\expr}{index})
  &\hypertarget{ast-egetfield}{}\\
	|\ & \EGetField(\overtext{\expr}{record}, \overtext{\identifier}{field name})
  &\hypertarget{ast-egetfields}{}\\
	|\ & \EGetFields(\overtext{\expr}{record}, \overtext{\identifier^{*}}{field names})
  &\hypertarget{ast-erecord}{}\\
	|\ & \ERecord(\overtext{\ty}{record type}, \overtext{(\identifier, \expr)^{*}}{field initializers})
  &\hypertarget{ast-etuple}{}\\
	|\ & \ETuple(\expr^{+})
  &\hypertarget{ast-earbitrary}{}\\
	|\ & \EArbitrary(\ty)
  &\hypertarget{ast-epattern}{}\\
	|\ & \EPattern(\expr, \pattern)
\end{flalign*}

\listingref{expr1} and \listingref{expr2} exemplify the different kinds of expressions,
as indicated by respective comments.
\ASLListing{Examples of expressions}{expr1}{\syntaxtests/expr1.asl}
\ASLListing{More examples of expressions}{expr2}{\syntaxtests/expr2.asl}

\begin{itemize}
  \item $\EVar(\vx)$ represents variables (\texttt{E\_Var}).

  \item $\EATC(\ve, \vt)$ represents typing assertions. For example: \texttt{x as integer}.
  Here $\ve$ corresponds to \texttt{x} and $\vt$ corresponds to \texttt{integer}.

  \item $\ESlice(\ve, \vslices)$ represents slices of bitvectors (\texttt{E\_Slice 1}),
  slices of integers \\
  (\texttt{E\_Slice 2}),
  and access to array elements (\texttt{E\_Slice 3}).

  \item $\EGetField(\ve, \id)$ represents an access to a record (\texttt{E\_GetField 1})
        or exception field
        as well as an access to a tuple component (\texttt{E\_GetField 2}).

  \item $\EGetFields(\ve, \ids)$ represents an access to multiple record fields (\texttt{E\_GetFields 1}).
\end{itemize}

\subsection{Patterns \label{sec:Patterns}}

\hypertarget{ast-pattern}{} \hypertarget{ast-patternall}{}
\begin{flalign*}
\pattern \derives\ & \PatternAll
  & \hypertarget{ast-patternany}{}\\
  |\ & \PatternAny(\pattern^{*})
  & \hypertarget{ast-patterngeq}{}\\
  |\ & \PatternGeq(\expr)
  & \hypertarget{ast-patternleq}{}\\
  |\ & \PatternLeq(\expr)
  & \hypertarget{ast-patternmask}{}\\
  |\ & \PatternMask(\overtext{\{0,1,x\}^*}{mask constant})
  & \hypertarget{ast-patternnot}{}\\
  |\ & \PatternNot(\pattern)
  & \hypertarget{ast-patternrange}{}\\
  |\ & \PatternRange(\overtext{\expr}{lower}, \overtext{\expr}{upper})
  & \hypertarget{ast-patternsingle}{}\\
  |\ & \PatternSingle(\expr)
  & \hypertarget{ast-patterntuple}{}\\
  |\ & \PatternTuple(\pattern^{*}) &
\end{flalign*}

\subsection{Slices \label{sec:Slices}}

\hypertarget{ast-slice}{} \hypertarget{ast-slicesingle}{}
\begin{flalign*}
% &&\ASTComment{Indexes an array or a bitvector.}\\
% &&\ASTComment{All positions mentioned below are inclusive}\\
\slice \derives\ & \SliceSingle(\overname{\expr}{\vi})
  & \hypertarget{ast-slicerange}{}\\
  % & & \ASTComment{the slice of length \texttt{1} at position \vi.}\\
  |\ & \SliceRange(\overname{\expr}{\vj}, \overname{\expr}{\vi})
  & \hypertarget{ast-slicelength}{}\\
  % & & \ASTComment{the slice from \vi\ to \texttt{j - 1}.}\\
  |\ & \SliceLength(\overname{\expr}{\vi}, \overname{\expr}{\vn})
  & \hypertarget{ast-slicestar}{}\\
  % & & \ASTComment{the slice starting at \vi\ of length \vn.}\\
  |\ & \SliceStar(\overname{\expr}{\vi}, \overname{\expr}{\vn}) &
  % & & \ASTComment{the slice starting at \texttt{i*n} of length \vn}
\end{flalign*}

\subsection{Subprogram calls \label{sec:SubprogramCalls}}
\hypertarget{ast-call}{}
\begin{flalign*}
\call \derives\ &
{
\left\{
  \begin{array}{rcl}
 \callname &:& \Strings, \\
 \callparams &:& \expr, \\
 \callargs &:& \expr, \\
 \callcalltype &:& \subprogramtype
\end{array}
\right\}
} &
\end{flalign*}

\subsection{Types \label{sec:Types}}

\hypertarget{ast-ty}{} \hypertarget{ast-tint}{}
\begin{flalign*}
\ty \derives\ & \TInt(\constraintkind)
\hypertarget{ast-treal}{}\\
  |\ & \TReal
  & \hypertarget{ast-tstring}{}\\
  |\ & \TString
  & \hypertarget{ast-tbool}{}\\
  |\ & \TBool
  & \hypertarget{ast-tbits}{}\\
  |\ & \TBits(\overtext{\expr}{width}, \bitfield^{*})
  & \hypertarget{ast-ttuple}{}\\
  |\ & \TTuple(\ty^{*})
  & \hypertarget{ast-tarray}{}\\
  |\ & \TArray(\arrayindex, \ty)
  & \hypertarget{ast-tnamed}{}\\
  |\ & \TNamed(\overtext{\identifier}{type name}) &
  & \hypertarget{ast-tenum}{}\\
  |\ & \TEnum(\overtext{\identifier^{*}}{labels})\\
  & \hypertarget{ast-trecord}{}\\
  |\ & \TRecord(\Field^{*})
  & \hypertarget{ast-texception}{}\\
  |\ & \TException(\Field^{*})
  & \hypertarget{ast-tcollection}{}\\
  |\ & \TCollection(\Field^{*})
% &  & & \ASTComment{This is related to \identi{LDNP}}
\end{flalign*}

\subsection{Constraints \label{sec:Constraints}}

\hypertarget{ast-constraintkind}{} \hypertarget{ast-unconstrained}{}
\begin{flalign*}
  % & & \ASTComment{Constraints that may be assigned to integer types.}  \\
  \constraintkind \derives\ & \unconstrained
  % & & \ASTComment{The unconstrained integer type.}
  & \hypertarget{ast-wellconstrained}{}\\
  |\ & \wellconstrained(\intconstraint^{+})
  % & & \ASTComment{An integer type with explicit constraints.}
  & \hypertarget{ast-pendingconstrained}{}\\
  |\ & \pendingconstrained{}
  & \hypertarget{ast-parameterized}{}\\
  |\ & \parameterized(\overtext{\identifier}{parameter}) &
  % & & \ASTComment{Implicitly constrained integer from function declaration.} \\
  % & & \ASTComment{Attributes are:} \\
  % & & \ASTComment{- a unique integer identifier and the variable} \\
  % & & \ASTComment{- the type was implicitly constructed from.} \\
\end{flalign*}

\hypertarget{ast-intconstraint}{} \hypertarget{ast-constraintexact}{}
\begin{flalign*}
% & & \ASTComment{A constraint on an integer part.}\\
\intconstraint \derives\ & \ConstraintExact(\expr)
  % & & \ASTComment{A single value, given by a symbolically evaluable expression.}
  & \hypertarget{ast-constraintrange}{}\\
  |\ & \ConstraintRange(\overtext{\expr}{start}, \overtext{\expr}{end})&
  % & & \ASTComment{An interval between two symbolically evaluable expression.}\\
\end{flalign*}

\subsection{Bit Fields \label{sec:BitFields}}

\hypertarget{ast-bitfield}{} \hypertarget{ast-bitfieldsimple}{}
\begin{flalign*}
% & & \ASTComment{Represent static slices on a given bitvector type.}\\
\bitfield \derives\ & \BitFieldSimple(\identifier, \slice^{*})
  % & & \ASTComment{A name and its corresponding slice.}
  & \hypertarget{ast-bitfieldnested}{}\\
  |\ & \BitFieldNested(\identifier, \slice^{*}, \bitfield^{*})
  % & & \ASTComment{A name, its corresponding slice and some nested bitfields.}
  & \hypertarget{ast-bitfieldtype}{}\\
  |\ & \BitFieldType(\identifier, \slice^{*}, \ty) &
  % & & \ASTComment{A name, its corresponding slice, and the type of the bitfield.}\\
\end{flalign*}

\subsection{Array Indices \label{sec:ArrayIndices}}

\hypertarget{ast-arrayindex}{} \hypertarget{ast-arraylengthexpr}{}
The type of array indices is given by the following AST type:
\begin{flalign*}
\arrayindex \derives\ &  \ArrayLengthExpr(\overtext{\expr}{array length}) &
\end{flalign*}

\subsection{Fields and Typed Identifiers \label{sec:FieldsAndTypedIdentifiers}}

The following rule corresponds to a field of a record-like structure:
\hypertarget{ast-field}{}
\begin{flalign*}
\Field \derives\ & (\identifier, \ty) &
\end{flalign*}

The following rule corresponds to an identifier with its associated type:
\hypertarget{ast-typedidentifier}{}
\begin{flalign*}
\typedidentifier \derives\ & (\identifier, \ty) &
\end{flalign*}

\subsection{Left-hand Side Expressions \label{sec:LeftHandSideExpressions}}

The following rules define the types of left-hand side of assignments:
\hypertarget{ast-lexpr}{} \hypertarget{ast-lediscard}{}
\begin{flalign*}
\lexpr \derives\ & \overtext{\LEDiscard}{\texttt{"-"}} & \hypertarget{ast-levar}{}\\
  |\ & \LEVar(\identifier) & \hypertarget{ast-leslice}{}\\
  |\ & \LESlice(\lexpr, \slice^*) & \hypertarget{ast-lesetarray}{}\\
  |\ & \LESetArray(\lexpr, \expr) & \hypertarget{ast-lesetfield}{}\\
  |\ & \LESetField(\lexpr, \identifier) & \hypertarget{ast-lesetfields}{}\\
  |\ & \LESetFields(\lexpr, \identifier^*) & \hypertarget{ast-ledestructuring}{}\\
  |\ & \LEDestructuring(\lexpr^*) & \\
\end{flalign*}

\subsection{Local Declarations \label{sec:LocalDeclarations}}

\hypertarget{ast-localdeclkeyword}{} \hypertarget{ast-ldkvar}{} \hypertarget{ast-ldkconstant}{} \hypertarget{ast-ldklet}{}
\begin{flalign*}
\localdeclkeyword \derives\ & \LDKVar \;|\; \LDKConstant \;|\; \LDKLet &
\end{flalign*}

A local declaration item is the left-hand side of a declaration statements.
In the following example of a declaration statement:
\begin{lstlisting}
let (x, -, z): (integer, integer, integer {0..32}) = (2, 3, 4);
\end{lstlisting}
the local declaration item is
\begin{lstlisting}
(x, -, z): (integer, integer, integer {0..32})
\end{lstlisting}

\hypertarget{ast-localdeclitem}{}
\begin{flalign*}
\localdeclitem \derives\ &
  & \hypertarget{ast-ldivar}{}\\
  |\ & \LDIVar(\identifier)
  % & & \ASTComment{\texttt{LDI\_Var x} is the variable declaration of the variable \texttt{x}, used for example in:}\\
  % & & \ASTComment{\texttt{let x = 42;}.}
  & \hypertarget{ast-ldituple}{}\\
  |\ & \LDITuple(\identifier^*) &
  % & & \ASTComment{\texttt{LDI\_Tuple ldis} is the tuple declarations of the items in \texttt{ldis},}\\
  % & & \ASTComment{used for example in: \texttt{let (x, y, -, z) = (1, 2, 3, 4);}}\\
  % & & \ASTComment{Note that a the list here must be at least 2 items long.}
\end{flalign*}

\subsection{Statements \label{sec:Statements}}

\hypertarget{ast-fordirection}{} \hypertarget{ast-up}{} \hypertarget{ast-down}{}
\begin{flalign*}
\fordirection \derives\ & \UP \;|\; \DOWN &\\
\hypertarget{ast-stmt}{} \hypertarget{ast-spass}{}\\
\stmt \derives\ & \SPass
\hypertarget{ast-sseq}{} &\\
  |\ & \SSeq(\stmt, \stmt)
  \hypertarget{ast-sdecl}{} &\\
  |\ & \SDecl(\localdeclkeyword, \localdeclitem, \ty?, \expr?)
  \hypertarget{ast-sassign}{} &\\
  |\ & \SAssign(\lexpr, \expr)
  \hypertarget{ast-scall}{} &\\
  |\ & \SCall(\call)
  \hypertarget{ast-sreturn}{} &\\
  |\ & \SReturn(\expr?)
  \hypertarget{ast-scond}{} &\\
  |\ & \SCond(\expr, \stmt, \stmt)
  \hypertarget{ast-sassert}{} &\\
  |\ & \SAssert(\expr)
  \hypertarget{ast-sfor}{} &\\
  |\ & \SFor\left\{
    \begin{array}{rcl}
    \Forindexname  &:& \identifier,\\
    \Forstarte     &:& \expr,\\
    \Fordir        &:& \fordirection,\\
    \Forende       &:& \expr,\\
    \Forbody       &:& \stmt,\\
    \Forlimit      &:& \expr?
    \end{array}
  \right\}
  \hypertarget{ast-swhile}{} &\\
  |\ & \SWhile(\overtext{\expr}{condition}, \overtext{\expr?}{loop limit}, \overtext{\stmt}{loop body})
  \hypertarget{ast-srepeat}{} &\\
  |\ & \SRepeat(\overtext{\stmt}{loop body}, \overtext{\expr}{condition}, \overtext{\expr?}{loop limit})
  \hypertarget{ast-sthrow}{} &\\
  & \ASTComment{The option represents an implicit throw: \texttt{throw;}.}\\
  |\ & \SThrow(\expr?) &\\
  \hypertarget{ast-stry}{} &\\
  |\ & \STry(\stmt, \catcher^*, \overtext{\stmt?}{otherwise})
  \hypertarget{ast-sprint}{} &\\
  |\ & \SPrint(\overtext{\expr^*}{args}, \overtext{\Bool}{newline})
  \hypertarget{ast-spragma}{} &\\
  |\ & \SPragma(\Tidentifier, \overtext{\expr^*}{args})
  \hypertarget{ast-sunreachable}{} &\\
  |\ & \SUnreachable
\end{flalign*}

\subsection{Case Alternatives \label{sec:CaseAlternatives}}

\hypertarget{ast-casealt}{}
\begin{flalign*}
\casealt \derives\ & \{ \CasePattern : \pattern, \CaseWhere : \expr?, \CaseStmt : \stmt \} &
\end{flalign*}

\subsection{Exception Catchers \label{sec:ExceptionCatchers}}
\hypertarget{ast-catcher}{}
\begin{flalign*}
\catcher \derives\ & (\overtext{\identifier?}{exception to match}, \overtext{\ty}{guard type}, \overtext{\stmt}{statement to execute on match}) &
\end{flalign*}

\subsection{Subprograms \label{sec:Subprograms}}
\hypertarget{ast-subprogramtype}{} \hypertarget{ast-stprocedure}{} \hypertarget{ast-stfunction}{}
\begin{flalign*}
\subprogramtype \derives\ & \STProcedure \;|\; \STFunction
\hypertarget{ast-stgetter}{} \hypertarget{ast-stsetter}{} &\\
                |\  & \STGetter \;|\; \STSetter &
\end{flalign*}

\hypertarget{ast-overrideinfo}{} \hypertarget{ast-impdef}{}
\begin{flalign*}
\overrideinfo \derives\ & \Impdef \hypertarget{ast-implementation}{} \;|\; \Implementation &
\end{flalign*}

\hypertarget{ast-func}{}
\begin{flalign*}
\func \derives\ &
{
\left\{
  \begin{array}{rcl}
 \funcname &:& \Strings, \\
 \funcparameters &:& (\identifier, \ty?)^*,\\
 \funcargs &:& \typedidentifier^*,\\
 \funcbody &:& \stmt,\\
 \funcreturntype &:& \ty?,\\
 \funcsubprogramtype &:& \subprogramtype\\
 \funcrecurselimit    &:& \expr?\\
 \funcbuiltin &:& \Bool\\
 \funcoverride &:& \Some{\overrideinfo}\\
\end{array}
\right\}
} &
\end{flalign*}

\subsection{Global Declarations \label{sec:GlobalDeclarations}}
Declaration keyword for global storage elements:
\hypertarget{ast-globaldeclkeyword}{} \hypertarget{ast-gdkconstant}{} \hypertarget{ast-gdkconfig}{} \hypertarget{ast-gdklet}{} \hypertarget{ast-gdkvar}{}
\begin{flalign*}
\globaldeclkeyword \derives\ & \GDKConstant \;|\; \GDKConfig \;|\; \GDKLet \;|\; \GDKVar &
\end{flalign*}

\hypertarget{ast-globaldecl}{}
\begin{flalign*}
\globaldecl \derives\ &
{\left\{
  \begin{array}{rcl}
  \GDkeyword &:& \globaldeclkeyword, \\
  \GDname &:& \identifier,\\
  \GDty &:& \ty?,\\
  \GDinitialvalue &:& \expr?
  \end{array}
  \right\}
 } &
\end{flalign*}

\hypertarget{ast-decl}{}
\hypertarget{ast-dfunc}{}
\begin{flalign*}
\decl \derives\ & \DFunc(\func) & \hypertarget{ast-dglobalstorage}{}\\
  |\ & \DGlobalStorage(\globaldecl) & \hypertarget{ast-dtypedecl}{}\\
  |\ & \DTypeDecl(\identifier, \ty, (\identifier, \overtext{\Field^*}{with fields})?) & \hypertarget{ast-dpragma}{}\\
  |\ & \DPragma(\Tidentifier, \overtext{\expr^*}{args})
\end{flalign*}

\subsection{Specifications \label{sec:Specifications}}
\hypertarget{ast-spec}{}
\begin{flalign*}
\spec \derives\ & \decl^* &
\end{flalign*}

\section{Typed Abstract Syntax Grammar\label{sec:TypedAbstractSyntaxGrammar}}

The derivation rules for the typed abstract syntax are the same as the rules for the untyped abstract syntax,
except for the following differences.

The rules for expressions have the following extra derivation rules:
\hypertarget{ast-egetitem}{}
\begin{flalign*}
\expr \derives\ & \EGetItem(\expr, \N) &\\ \hypertarget{ast-earray}{}
             |\ & \EArray \{\EArrayLength: \expr, \EArrayValue: \expr\} & \hypertarget{ast-eenumarray}{}\\
             |\ & \EEnumArray \{\EArrayLabels: \identifier^+, \EArrayValue: \expr\} & \hypertarget{ast-egetenumarray}{}\\
             |\ & \EGetEnumArray(\overtext{\expr}{base}, \overtext{\expr}{key}) &\hypertarget{ast-egetcollectionfields}{}\\
             |\ & \EGetCollectionFields(\overtext{\identifier}{collection}, \overtext{\identifier^{*}}{field names}) & \\
\end{flalign*}

The rules for left-hand-side expressions have the following extra derivation rules:
\hypertarget{ast-lesetenumarray}{}%
\begin{flalign*}
  \lexpr \derives\ & \LESetEnumArray(\overtext{\lexpr}{base}, \overtext{\expr}{index}) & \hypertarget{ast-lesetcollectionfields}{}\\
                |\ & \LESetCollectionFields(\overtext{\identifier}{collection}, \overtext{\identifier^{*}}{field names}) &\\
\end{flalign*}

The intention for each AST node type above is as follows:
\begin{itemize}
  \item $\EGetItem(\ve, i)$ accesses the $i$th component of the tuple given by
    the expression $\ve$.
  \item $\EArray\{\EArrayLength: \veone, \EArrayValue: \vetwo\}$ is used to
    construct an integer-indexed array value in order to initialize an
    array-typed variable;
  \item $\EEnumArray\{\EArrayLabels: \vl_{1..k}, \EArrayValue: \vetwo\}$ is used
    to construct an enumeration-indexed array value in order to initialize an
    array-typed variable;
  \item $\EGetEnumArray(\ebase, \ekey)$ is used for accessing an enumerated
    array given by $\ebase$ at the entry given by $\ekey$;
  \item $\LESetEnumArray(\ebase, \evalue)$ is used for updating an enumerated
    array left-hand-side expression given by $\ebase$ with the value given by
    $\evalue$;
  \item $\EGetCollectionFields(\ebase, \ekey)$ is used for accessing a
    collection given by $\ebase$ at the entry given by $\ekey$;
  \item $\LESetCollectionFields(\ebase, \ekey)$ is used for updating a
    collection given by $\ebase$ at the entry given by $\ekey$.
\end{itemize}

The rules for statements exclude \texttt{pragma} statements, since those are transformed into
\passstatementsterm\ (see \TypingRuleRef{SPragma}).

The rules for statements refine the throw statement by annotating it with
the type of the thrown exception.
\begin{flalign*}
\stmt \derives\ & \SThrow((\expr, \overtext{\ty}{exception type})?) &
\end{flalign*}

The rules for slices is replaced by the following:
\begin{flalign*}
\slice \derives\ & \SliceLength(\expr, \expr) &
\end{flalign*}
This reflects the fact that all other slicing constructs are syntactic sugar
for \SliceLength.

The following extra rule enables expressing array indices based on enumeration:
\hypertarget{ast-arraylengthenum}{}
\begin{flalign*}
\arrayindex \derives\ &  \ArrayLengthEnum(\overtext{\identifier}{name of enumeration}, \overtext{\identifier^+}{enumeration labels}) &
\end{flalign*}

The rules for constraint kinds refine the well-constrained kind by a precision
indicator, which indicates whether precision has been lost during the typing of
binary operations over well-constrained integer types (see
\TypingRuleRef{IntervalTooLarge}).
\begin{flalign*}
  \hypertarget{ast-precisionlossindicator}{}%
  \precisionlossindicator \derives\ & \PrecisionFull & \hypertarget{precision-full}{} \\
                                 |\ & \PrecisionLost & \hypertarget{precision-lost}{} \\
          \constraintkind \derives\ & \wellconstrained(\intconstraint^{+}, \precisionlossindicator) & \\
\end{flalign*}

In the \untypedast, the $\globaldecl$ child node in the abstract syntax nodes of the form $\DGlobalStorage(\globaldecl)$
contains an optional expression field assigned to the $\GDinitialvalue$ field. In the \typedast, this field
always contains an expression (that is, it is never $\None$).

Global pragma declarations $\DPragma$ are removed from the \untypedast\ once their expressions have been typechecked and do not appear in the \typedast.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Abstract Syntax Trees\label{sec:BuildingAbstractSyntaxTrees}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section defines how to transform a parse tree into the corresponding AST
via recursively traversing the parse tree and applying a \emph{builder} function
for each non-terminal node.

(Some of the builders are relations due to non-determinism induced by naming global variables
for assignments whose left-hand-side variable is discarded ($\Tminus$).)

\hypertarget{def-tbuilderror}{}
\hypertarget{def-builderrorconfig}{}
For each non-terminal $N \derives R_1 \;|\; \ldots R_k$, we define a builder function
$\textsf{build\_}N $ which takes a parse tree $\parsenode{N}$ and returns the corresponding
AST or a \emph{build error configuration} $\BuildErrorConfig \in \TBuildError$.
The builder function is defined in terms of one inference rule per alternative $R_i$.
The input for the builder for an alternative $R = S_{1..m}$ is a parse node
$N(S_{1..m})$. To allow the builder to refer to the children nodes of $N$,
we use the notation $\namednode{n_i}{S_i}$, which names the child node $S_i$ as $n_i$.

The set of builder relations is defined in the respective chapters for their constructs
(for example, the builder for expressions is defined in \chapref{Expressions}).

\subsection{Example}
Consider the derivation for while loops:
\[
\Nstmt \derives \Twhile \parsesep \Nexpr \parsesep \Tdo \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon
\]

The parse node for a while statement has the form
\[
\Nstmt(\Twhile, \namednode{\ve}{\Nexpr}, \Tdo, \namednode{\vstmtlist}{\Nstmtlist}, \Tend, \Tsemicolon)
\]
where $\ve$ names the node representing the condition of the loop and $\vstmtlist$ names
the list of statements that form the body of the loop.

To build the corresponding AST, we employ the builder function $\buildstmt$, since
the non-terminal labelling the parse node is $\Nstmt$.

We also employ the following rule:
\begin{mathpar}
\inferrule{
  \buildexpr(\ve) \astarrow \astversion{\ve}\\
  \buildstmtlist(\vstmtlist) \astarrow \astversion{\vstmtlist}
}{
  {
  \begin{array}{r}
    \buildstmt(\Nstmt(\Twhile, \namednode{\ve}{\Nexpr}, \Tdo, \namednode{\vstmtlist}{\Nstmtlist}, \Tend, \Tsemicolon))
    \astarrow\\
    \SWhile(\astversion{\ve}, \None, \astversion{\vstmtlist})
  \end{array}
  }
}
\end{mathpar}
That is, we apply the $\buildexpr$ to transform the condition parse node $\ve$ into the corresponding AST node,
we apply $\buildstmtlist$ to transform the parse node $\vstmtlist$ for the body of the list into the corresponding AST node,
and finally return the AST node for \texttt{while} loops --- $\SWhile$ --- with the two nodes as its children.

We define some builders as relations rather than functions. This is due to the non-determinism
in creating identifiers for auxiliary variables that stand in for instances of \discardvar{} on the left-hand-side
of assignments and declarations.
For example, \texttt{- = 5;} will effectively create some auxiliary variable, which will result in
an AST node such as $\SAssign(\EVar(\texttt{aux-1}), \ELiteral(\lint(5)))$.
Recall that hyphens are not legal characters in ASL identifiers, which avoids potential clashes with
user-supplied identifiers. An implementation is free however to choose other naming schemes that
avoid name clashes, for example, by employing counters.

\subsection{Abbreviated Rule Notation for AST Builders}
Notice that there is only one instance of $\Nexpr$ and one instance of $\Nstmtlist$ in this production.
This is very common and we therefore use the following shorthand notation for such cases, as explained next.

In a non-terminal $N$ appears only once in the right-hand-side of a derivation,
we use the name $\texttt{N}$ to name the corresponding child parse node.
For example, $\namednode{\vexpr}{\Nexpr}$ and $\namednode{\vstmtlist}{\Nstmtlist}$.
In such cases, we always have the premise $\textsf{build\_}N(\texttt{N}) \astarrow \astversion{N}$
to obtain the corresponding AST node.
We therefore make this premise implicit, by dropping it entirely and using $\astof{N}$ to mean that
the parse node $N$ is named $\texttt{N}$, the premise $\textsf{build\_}N(\texttt{N}) \astarrow \astversion{N}$
is considered part of the rule and $\astversion{N}$ itself stands for $\astversion{N}$.

In our example, this results in the abbreviated rule notation
\begin{mathpar}
\inferrule{}{
{
\begin{array}{r}
  \buildstmt(\Nstmt(\Twhile, \punnode{\Nexpr}, \Tdo, \punnode{\Nstmtlist}, \Tend, \Tsemicolon))
  \astarrow\\
  \SWhile(\astof{\vexpr}, \None, \astof{\vstmtlist})
  \end{array}
}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Parameterized Productions\label{sec:BuildingParameterizedProductions}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section defines builder relations for the
subset of macro productions in \secref{ParametricProductions}
that are not inlined:
\begin{itemize}
  \item \ASTRuleRef{List}
  \item \ASTRuleRef{CList}
  \item \ASTRuleRef{PList}
  \item \ASTRuleRef{NTCList}
  \item \ASTRuleRef{Option}
\end{itemize}

We also define \ASTRuleRef{Identity},
which can be used in conjunction with the rules above in application
to terminals.

\ASTRuleDef{List}
\hypertarget{build-list}{}
The meta relation
\[
\buildlist[b](\overname{N}{\vsyms}) \;\aslrel\; \overname{A}{\vsymasts}
\]
which is parameterized by an AST building relation $b : E \aslrel A$,
takes a parse node that represents a possibly-empty list of $E$ values --- $\vsyms$ --- and returns the result of applying $b$
to each of them --- $\vsymasts$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildlist[b](\overname{\emptysentence}{\vsyms}) \astarrow \overname{\emptylist}{\vsymasts}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  b(\vv) \astarrow \astversion{\vv}\\
  \buildlist[b](\vsymsone) \astarrow \vsymastsone
}{
  \buildlist[b](\overname{
    \maybeemptylist{N}(\namednode{\vv}{E}, \namednode{\vsymsone}{\maybeemptylist{N}})
    }{\vsyms}) \astarrow
  \overname{[\astversion{\vv}] \concat \vsymastsone}{\vsymasts}
}
\end{mathpar}

\ASTRuleDef{CList}
\hypertarget{build-clist}{}
The meta relation
\[
\buildclist[b](\overname{N}{\vsyms}) \;\aslrel\; \overname{A}{\vsymasts}
\]
which is parameterized by an AST building relation $b : E \aslrel A$,
takes a parse node that represents a possibly-empty comma-separated list of $E$ values --- $\vsyms$ --- and returns the result of applying $b$
to each of them --- $\vsymasts$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildclist[b](\overname{\emptysentence}{\vsyms}) \astarrow \overname{\emptylist}{\vsymasts}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  b(\vv) \astarrow \astversion{\vv}\\
  \buildclist[b](\vsymsone) \astarrow \vsymastsone
}{
  \buildclist[b](\overname{
    \ClistZero{N}(\namednode{\vv}{E}, \Tcomma, \namednode{\vsymsone}{\ClistOne{N}})
    }{\vsyms}) \astarrow \overname{[\astversion{\vv}] \concat \vsymastsone}{\vsymasts}
}
\end{mathpar}

\ASTRuleDef{PList}
\hypertarget{build-plist}{}
The meta relation
\[
\buildplist[b](\overname{N}{\vsyms}) \;\aslrel\; \overname{A}{\vsymasts}
\]
which is parameterized by an AST building relation $b : E \aslrel A$,
takes a parse node that represents a parenthesized comma-separated list of $E$ values --- $\vsyms$ --- and returns the result of applying $b$
to each of them --- $\vsymasts$.

\begin{mathpar}
\inferrule{
  \buildclist[b](\vv) \astarrow \astversion{\vv}
}{
  \buildplist[b](\Tlpar, \namednode{\vv}{L}, \Trpar) \astarrow \astversion{\vv}
}
\end{mathpar}

\ASTRuleDef{NTCList}
\hypertarget{build-tclist}{}
The meta relation
\[
\buildtclist[b](\overname{N}{\vsyms}) \;\aslrel\; \overname{A}{\vsymasts}
\]
which is parameterized by an AST building relation $b : E \aslrel A$,
takes a parse node that represents a non-empty comma-separated trailing list of $E$ values --- $\vsyms$ --- and returns the result of applying $b$
to each of them --- $\vsymasts$.

\begin{mathpar}
\inferrule[empty]{
  b(\vv) \astarrow \astversion{\vv}
}{
  \buildtclist[b](\overname{\vv \parsesep \option{\Tcomma}}{\vsyms}) \astarrow \overname{[\astversion{\vv}]}{\vsymasts}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  b(\vv) \astarrow \astversion{\vv}\\
  \buildtclist[b](\vsymsone) \astarrow \vsymastsone
}{
  \buildtclist[b](\overname{\namednode{\vv}{E}, \Tcomma, \namednode{\vsymsone}{\TClistOne{N}}}{\vsyms}) \astarrow \overname{[\astversion{\vv}] \concat \vsymastsone}{\vsymasts}
}
\end{mathpar}

\ASTRuleDef{Option}
\hypertarget{build-option}{}
The meta relation
\[
\buildoption[b](\overname{N}{\vsym}) \;\aslrel\; \overname{\langle A \rangle}{\vsymast}
\]
which is parameterized by an AST building relation $b : E \aslrel A$,
takes a parse node that represents an optional $E$ value --- $\vsym$ --- and returns the result of applying $b$
to the value if it exists --- $\vsymasts$.

\begin{mathpar}
\inferrule[none]{}{
  \buildoption[b](\overname{\emptysentence}{\vsym}) \astarrow \overname{\None}{\vsymast}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  b(\vv) \astarrow \astversion{\vv}
}{
  \buildoption[b](\overname{\namednode{\vv}{E}}{\vsym}) \astarrow \overname{\langle\astversion{\vv}\rangle}{\vsymast}
}
\end{mathpar}

When this relation is applied to a sentence consisting of a prefix of terminals $t_{1..k}$, ending with a non-terminal $\vv$,
it ignore the terminals and returns the result for the non-terminal.
\begin{mathpar}
\inferrule[last]{
  \buildoption[b](\vv) \astarrow \vsymast
}{
  \buildoption[b](t_{1..k}, \namednode{\vv}{E}) \astarrow \vsymast
}
\end{mathpar}

\ASTRuleDef{Identity}
\hypertarget{build-identity}{}
The meta function
\[
\buildidentity(\overname{T}{x}) \aslto \overname{T}{x}
\]
is the identity function, which can be used as an argument to meta functions such as $\buildlist$ when they are applied
to terminals.

\begin{mathpar}
\inferrule{}{
  \buildidentity(x) \astarrow x
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Correspondence Between Left-hand-side Expressions and Right-hand-side Expressions
\label{sec:LeftToRight}}
\hypertarget{def-rexpr}{}
The recursive function $\torexpr : \lexpr \rightarrow \expr$ transforms
left-hand-side expressions to corresponding right-hand-side expressions,
which is utilized both for the type system and semantics:
\[
\begin{array}{lcl}
  \textbf{Left hand side expression} & & \textbf{Right hand side expression}\\
  \hline
  \torexpr(\LEVar(\vx)) &=& \EVar(\vx)\\
  \torexpr(\LESlice(\vle, \vargs)) &=& \ESlice(\torexpr(\vle), \vargs)\\
  \torexpr(\LESetArray(\vle, \ve)) &=& \EGetArray(\torexpr(\vle), \ve)\\
  \torexpr(\LESetEnumArray(\vle, \ve)) &=& \EGetEnumArray(\torexpr(\vle), \ve)\\
  \torexpr(\LESetField(\vle, \vx)) &=& \EGetField(\torexpr(\vle), \vx)\\
  \torexpr(\LESetFields(\vle, \vx)) &=& \EGetFields(\torexpr(\vle), \vx)\\
  \torexpr(\LEDiscard) &=& \EVar(\discardvar)\\
  \torexpr(\LEDestructuring([\vle_{1..k}])) &=& \ETuple([i=1..k: \torexpr(\vle_i)])\\
\end{array}
\]

\section{Abstract Syntax Abbreviations\label{sec:AbstractSyntaxAbreviations}}
We employ the following abbreviations for various AST nodes:
\begin{center}
\begin{tabular}{ll}
\hline
\textbf{Abbreviation} & \textbf{Meaning}
\hypertarget{def-elint}{}\\
\hline
$\ELInt{n}$ & literal integer expression: $\ELiteral(\lint(n))$
\hypertarget{def-abbrevevar}{}\\
$\AbbrevEVar{\vx}$ & $\EVar(\vx)$
\hypertarget{def-abbrevconstraintexact}{}\\
$\AbbrevConstraintExact{\ve}$ & $\ConstraintExact(\ve)$
\hypertarget{def-abbrevconstraintrange}{}\\
$\AbbrevConstraintRange{\veone}{\vetwo}$ & $\ConstraintRange(\veone, \vetwo)$ \hypertarget{def-abbrevebinop}{}\\
$\AbbrevEBinop{\op}{\veone}{\vetwo}$ & $\EBinop(\op, \veone, \vetwo)$ \hypertarget{def-abbrevtarray}{}\\
$\AbbrevTArray{\vi}{\vt}$ & $\TArray(\ArrayLengthExpr(\vi), \vt)$ \hypertarget{def-abbrevtarraylengthexpr}{}\\
$\AbbrevTArrayLengthExpr{\ve}{\vt}$ & $\TArray(\ArrayLengthExpr(\ve), \vt)$ \hypertarget{def-abbrevtarraylengthenum}{}\\
$\AbbrevTArrayLengthEnum{\ve}{\vs}{\vt}$ & $\TArray(\ArrayLengthEnum(\ve, \vs), \vt)$\\
\hline
\end{tabular}
\end{center}
