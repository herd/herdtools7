\chapter{Local Storage Declarations\label{chap:LocalStorageDeclarations}}

Local storage declarations introduce new variables into the \localstaticenvironmentterm.
A list of mutable (\Tvar) storage elements can be introduced without initializing them.
ASL also supports tuples of (mutable or immutable) local storage declarations.

\ExampleDef{Local Storage Declarations}
\ASLListing{Local storage declarations}{LocalStorageDeclarations}{\definitiontests/LocalStorageDeclarations.asl}

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Local Storage Declarations} defines the formal relations for local storage declarations;
  \item \SyntaxRef{Local Storage Declarations} defines the syntax of local storage declarations;
  \item \AbstractSyntaxRef{Local Storage Declarations} defines the abstract syntax of local storage declarations;
  \item \secref{Typing of Local Variable Declarations} defines the type rules of local variable declarations;
  \item \secref{Semantics of Local Variable Declarations} defines the dynamic semantics of local variable declarations;
  \item \secref{Typing of Tuple Declarations} defines the type rules of tuples of local storage declarations;
  \item \secref{Semantics of Tuple Declarations} defines the dynamic semantics of tuples of local storage declarations.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Local Storage Declarations}
\paragraph{Syntax:} Local storage declarations are grammatically derived from statements ($\Nstmt$)
  via dedicated rules (see \SyntaxRef{Local Storage Declarations}).

\paragraph{Abstract Syntax:} Local storage declarations are derived in abstract syntax by\\
$\localdeclkeyword$ and $\localdeclitem$
and generated by $\buildlocaldeclkeyword$ and $\builddeclitem$
(see \AbstractSyntaxRef{Local Storage Declarations}).

\paragraph{Typing:}
\RenderRelation{annotate_local_decl_item}
\BackupOriginalRelation{
The function
\[
  \begin{array}{c}
  \annotatelocaldeclitem
  \left(
    \begin{array}{c}
    \overname{\staticenvs}{\tenv} \aslsep\\
    \overname{\ty}{\tty} \aslsep\\
    \overname{\localdeclkeyword}{\ldk} \aslsep\\
    \overname{\Option{\expr\times\TSideEffectSet}}{\veopt} \aslsep\\
    \overname{\localdeclitem}{\ldi}
    \end{array}
   \right) \aslto\\
  (\overname{\staticenvs}{\newtenv})
  \cup \overname{\typeerror}{\TypeErrorConfig}
  \end{array}
\]
annotates a \localdeclarationitem\ $\ldi$ with a \localdeclarationkeyword\ $\ldk$, given a type $\tty$,
and optionally $\veopt$ --- an initializing expression and \sideeffectsetterm,
in a \staticenvironmentterm{} $\tenv$ results in $\newenv$, the modified
\staticenvironmentterm{}.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

This is used to annotate both single local storage declarations and tuples of local storage declarations.

\paragraph{Semantics:}
\RenderRelation{eval_local_decl}
That is, the right-hand side of the declaration
has already been evaluated, yielding $\vm$ (see, for example, \SemanticsRuleRef{SDeclSome}).
\BackupOriginalRelation{
The relation
\hypertarget{relation-evallocaldecl}{}
\[
  \evallocaldecl(
    \overname{\envs}{\env} \aslsep
    \overname{\localdeclitem}{\ldi} \aslsep
    \overname{\overname{\nativevalue}{\vv}\times\overname{\XGraphs}{\vgone}}{\vm}
    ) \;\aslrel\;
    \ResultLDI(\overname{\XGraphs}{\newg}, \overname{\envs}{\newenv})
\]
evaluates a \localdeclarationitem\ $\ldi$ in an environment
$\env$ with an initialization value $\vm$.
} % END_OF_BACKUP_RELATION

This is used to evaluate both single local storage declarations and tuples of local storage declarations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SyntaxDef{Local Storage Declarations}
\hypertarget{def-localdeclarationkeyword}{}
\hypertarget{def-localdeclarationitem}{}
A \localdeclarationkeyword\ is either \texttt{var} or \texttt{let}.
A \localdeclarationitem\ is an element derived from $\Ndeclitem$.
\hypertarget{def-localdeclaration}{}
A \localdeclaration\ consists of a \localdeclarationitem\ and a \localdeclarationkeyword.

Declaring a local storage element is done via the following grammar rules:
\begin{flalign*}
\Nstmt \derives \ & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \option{\Nasty} \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Ndeclitem \parsesep \Nasty \parsesep \Tsemicolon &\\
|\ & \Tvar \parsesep \Clisttwo{\Tidentifier} \parsesep \Nasty \parsesep \Tsemicolon &\\
\end{flalign*}

\begin{flalign*}
\Nlocaldeclkeyword \derives \ & \Tlet \;|\; \Tvar &\\
\Ndeclitem \derives\
   & \Tidentifier &\\
|\ & \Plisttwo{\Nignoredoridentifier} &\\
\Nignoredoridentifier \derives \ & \Tminus \;|\; \Tidentifier &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\AbstractSyntaxDef{Local Storage Declarations}
\RenderTypes[remove_hypertargets]{local_decl_keyword_and_item}
\BackupOriginalAST{
\begin{flalign*}
\localdeclkeyword \derives\ & \LDKVar \;|\; \LDKLet &\\
\localdeclitem \derives\
     & \LDIVar(\identifier) & \\
  |\ & \LDITuple(\KleeneStar{\identifier}) &
\end{flalign*}
}

\RequirementDef{DiscardingLocalStorageDeclarations}
Local storage declarations must bind at least one name.
All the local storage declarations in \listingref{local-storage-discards} are illegal, as they discard all declared storage elements.
\ASLListing{Illegal local storage declarations that discard all storage elements}{local-storage-discards}{\syntaxtests/GuideRule.DiscardingLocalStorageDeclarations.asl}

\ASTRuleDef{LocalDeclKeyword}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-localdeclkeyword}{}
The function
\[
\buildlocaldeclkeyword(\overname{\parsenode{\Nlocaldeclkeyword}}{\vparsednode}) \;\aslto\;
  \overname{\localdeclkeyword}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


% Transliteration note: simplify this when `--allow-local-constants' is removed.

\begin{mathpar}
\inferrule[let]{}{
  \buildlocaldeclkeyword(\overname{\Nlocaldeclkeyword(\Tlet)}{\vparsednode}) \astarrow \overname{\LDKLet}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[var]{}{
  \buildlocaldeclkeyword(\overname{\Nlocaldeclkeyword(\Tvar)}{\vparsednode}) \astarrow \overname{\LDKVar}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{DeclItem}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-declitem}{}
The function
\[
  \builddeclitem(\overname{\parsenode{\Ndeclitem}}{\vparsednode}) \;\aslto\; \overname{\localdeclitem}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[var]{}{
  \builddeclitem(\Ndeclitem(\Tidentifier(\name))) \astarrow
  \overname{\name}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \vb \eqdef \bigwedge_{i \in \listrange(\vids)} \vids_i = \Tminus \\
  \becheck(\lnot \vb, \BuildBadDeclaration) \astarrow \True \OrBuildError \\
  \buildclist[\buildignoredoridentifier](\vids) \astarrow \astversion{\vids}
}{
  {
    \begin{array}{r}
  \builddeclitem(\Ndeclitem(\namednode{\vids}{\Plisttwo{\Nignoredoridentifier}})) \astarrow \\
  \overname{\LDITuple(\astversion{\vids})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{IgnoredOrIdentifier}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-ignoredoridentifier}{}
The relation
\[
\buildfuncargs(\overname{\parsenode{\Nignoredoridentifier}}{\vparsednode}) \;\aslrel\;
  \overname{\Identifier}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[discard]{
  \id \in \Identifier \text{ is fresh}
}{
  \buildignoredoridentifier(\overname{\Nignoredoridentifier(\Tminus)}{\vparsednode}) \astarrow
  \overname{\id}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[id]{}{
  \buildignoredoridentifier(\overname{\Nignoredoridentifier(\Tidentifier(\id))}{\vparsednode}) \astarrow
  \overname{\id}{\vastnode}
}
\end{mathpar}

\section{Typing of Local Variable Declarations\label{sec:Typing of Local Variable Declarations}}
\TypingRuleDef{LDVar}
\ExampleDef{Well-typed Local Variable Declarations}
In \listingref{ldvar}, the statement \texttt{let x = 3;} is legal, since
\texttt{x} is not defined elsewhere. It is added to the type environment
with the type inferred type \texttt{integer{3}}.
\ASLListing{A local storage declaration}{ldvar}{\typingtests/TypingRule.LDVar.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ldi$ denotes a variable $\vx$, that is, $\LDIVar(\vx)$;
  \item \Prosecheckisnotcollection{$\tenv$}{$\tty$};
  \item determining whether $\vx$ is not declared in $\tenv$ yields $\True$\ProseOrTypeError;
  \item \Prosenoprecisionloss{$\tty$};
  \item $\tenvtwo$ is $\tenv$ modified so that $\vx$ is locally declared to have type $\tty$;
  \item applying $\addimmutableexpression$ to $\ldk$, $\veopt$, and $\vx$ in $\tenv$ (to conditionally
        update $\tenvtwo$) yields $\newtenv$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checkvarnotinenv(\tenv, \vx) \typearrow \True \OrTypeError\\\\
  \checknoprecisionloss(\tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \vx, \tty, \ldk) \typearrow \tenvtwo\\
  \addimmutableexpression(\tenvtwo, \ldk, \veopt, \vx) \typearrow \newtenv
}{
  \annotatelocaldeclitem(\tenv, \tty, \ldk, \veopt, \overname{\LDIVar(\vx)}{\ldi}) \typearrow \newtenv
}
\end{mathpar}
\CodeSubsection{\LDVarBegin}{\LDVarEnd}{../Typing.ml}
\identr{YSPM} \identd{FXST}

\TypingRuleDef{CheckIsNotCollection}%
\RenderRelation{check_is_not_collection}
\BackupOriginalRelation{
The function
\[
  \checkisnotcollection(\overname{\staticenvs}{\tenv} \aslsep
  \overname{\ty}{\vt})
  \typearrow \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether the type $\vt$ has the structure of a \collectiontypeterm{}, and if so,
raises a \typingerrorterm{}. Otherwise, the result is $\True$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Check is not collection}
In \listingref{checkisnotcollection}, the statement
\verb|var test: MyCollection;| fails with a \typingerrorterm{} because
\TypingRuleRef{LDVar} calls \TypingRuleRef{CheckIsNotCollection}.
\ASLListing{Declaring a local variable with a collection type}{checkisnotcollection}{\typingtests/TypingRule.CheckIsNotCollection.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item
    \AllApplyCase{Not-Collection}
    \begin{itemize}
      \item \Prosemakeanonymous{\tenv}{\vt}{\vtstruct};
      \item $\vtstruct$ is not a \collectiontypeterm{};
      \item the result is $\True$.
    \end{itemize}
  \item \AllApplyCase{Collection}
    \begin{itemize}
      \item \Prosemakeanonymous{\tenv}{\vt}{\vtstruct};
      \item $\vtstruct$ is a \collectiontypeterm{};
      \item the result is a \typingerrorterm{}.
    \end{itemize}
  \item \AllApplyCase{Tuple}
    \begin{itemize}
      \item \Prosemakeanonymous{\tenv}{\vt}{\vtstruct};
      \item $\vtstruct$ is a \tupletypeterm{} with type list $\tys$;
      \item for every $\tty$ in $\tys$, \Prosecheckisnotcollection{\tty}{\tenv}.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[Collection]{
    \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
    \astlabel(\vtstruct) = \TCollection \\
  }{%
    \checkisnotcollection(\tenv, \vt) \typearrow
    \TypeErrorVal{\UnexpectedType}
  }
\end{mathpar}
\begin{mathpar}
  \inferrule[Not-Collection]{
    \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
    \astlabel(\vtstruct) \notin \left\{ \TCollection, \TTuple \right\} \\
  }{%
    \checkisnotcollection(\tenv, \vt) \typearrow \True
  }
\end{mathpar}
\begin{mathpar}
  \inferrule[Tuple]{
    \makeanonymous(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
    \astlabel(\vtstruct) = \TTuple (\tys) \\
    \tty \in \tys: \checkisnotcollection(\tenv, \tty) \typearrow \True
    \OrTypeError
  }{%
    \checkisnotcollection(\tenv, \vt) \typearrow \True
  }
\end{mathpar}

\CodeSubsection{\CheckIsNotCollectionBegin}{\CheckIsNotCollectionEnd}{../Typing.ml}

\section{Semantics of Local Variable Declarations\label{sec:Semantics of Local Variable Declarations}}
\SemanticsRuleDef{LDVar}
\ExampleDef{Evaluation of a Local Variable Declaration}
The statement \texttt{var x = 3;} in \listingref{ldvar} binds \texttt{x}
to the evaluation of \texttt{3} in $\env$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ldi$ is a variable declaration, $\LDIVar(\vx)$;
  \item $\vm$ is a pair consisting of the value $\vv$ and execution graph $\vgone$;
  \item declaring $\vx$ in $\env$ is $(\newenv, \vgtwo)$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vm \eqname (\vv, \vgone)\\
  \declarelocalidentifier(\env, \vx, \vv)\evalarrow(\newenv, \vgtwo)\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evallocaldecl(\env, \LDIVar(\vx), \vm) \evalarrow \ResultLDI(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalLDVarBegin}{\EvalLDVarEnd}{../Interpreter.ml}

\section{Typing of Tuple Declarations\label{sec:Typing of Tuple Declarations}}
\TypingRuleDef{LDTuple}
\ExampleDef{Well-typed Tuple Declarations}
\ASLListing{Declaring a tuple in the local storage}{typing-ldtuple}{\typingtests/TypingRule.LDTuple.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ldi$ denotes a tuple of identifiers $\vids_{1..k}$, that is, $\LDITuple(\vids_{1..k})$;
  \item obtaining the \underlyingtypeterm\ of $\tty$ in $\tenv$ yields $\vtp$\ProseOrTypeError;
  \item determining whether $\vtp$ is a \tupletypeterm{} yields $\True$\ProseOrTypeError;
  \item determining whether the number of elements of $\vtp$ is $k$ yields $\True$\ProseOrTypeError;
  \item declaring the identifiers in $\vids$ in the \staticenvironmentterm{} $\tenv$ from right to left with their corresponding
        (that is, with the same index) types $t_{1..k}$ in $\tenv$,
        propagating static environments from one declaration to the next,
        yields the resulting environment $\newtenv$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \makeanonymous(\tenv, \tty) \typearrow \vtp \OrTypeError\\\\
  \techeck(\astlabel(\vtp) = \TTuple, \UnexpectedType) \typearrow \True \OrTypeError\\\\
  \vtp \eqname \TTuple([\vt_{1..n}])\\\\
  \techeck(k = n, \UnexpectedType) \typearrow \True \OrTypeError\\\\
  \newtenv_k \eqdef \tenv\\\\
  {
    \begin{array}{r}
      i=k..1: \hfill \\
      \quad \checkvarnotinenv(\newtenv_i, \vids_i) \typearrow \True \OrTypeError\\
      \quad \addlocal(\tenv, \vids_i, \vt_i, \ldk) \typearrow \newtenv_{i-1}
    \end{array}
  }\\\\
  \newtenv \eqdef \newtenv_0
}{
  {
  \begin{array}{r}
  \annotatelocaldeclitem(\tenv, \tty, \ldk, \veopt, \overname{\LDITuple(\vids_{1..k})}{\ldi}) \typearrow \\
  \newtenv
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\LDTupleBegin}{\LDTupleEnd}{../Typing.ml}

\section{Semantics of Tuple Declarations\label{sec:Semantics of Tuple Declarations}}
\SemanticsRuleDef{LDTuple}
\ExampleDef{Evaluation of Tuple Declarations}
In \listingref{semantics-ldtuple},
\texttt{var (x,y,z) = (1,2,3);} binds \texttt{x} to the evaluation of
\texttt{1}, \texttt{y} to the evaluation of \texttt{2}, and \texttt{z} to the
evaluation of \texttt{3} in $\env$.
\ASLListing{Evaluating a tuple declaration in the local storage}{semantics-ldtuple}{\semanticstests/SemanticsRule.LDTuple.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ldi$ declares a list of local variables, $\LDITuple(\vids)$;
  \item $\vm$ is a pair consisting of the native vector $\vv$ and execution graph $\vg$;
  \item $\vids$ is a list of identifiers $\id_{1..k}$;
  \item the value at each index of $\vv$ is $\vv_i$, for $i=1..k$;
  \item $\liv$ is the list of pairs $(\vv_i, \vg)$, for $i=1..k$;
  \item the output configuration is obtained by declaring each identifier $\id_i$
  with the corresponding value ($\vm$ component) $(\vv_i, \vg)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vm \eqname (\vv, \vg)\\
  \ldis \eqname \id_{1..k}\\
  i=1..k: \getindex(i, \vv) \evalarrow \vv_i\\
  \liv \eqname [i=1..k: (\vv_i, \vg)]\\
  \declareldituple(\env, \vids, \liv) \evalarrow C
}{
  \evallocaldecl(\env, \LDITuple(\vids), \vm) \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLDTupleBegin}{\EvalLDTupleEnd}{../Interpreter.ml}

\SemanticsRuleDef{DeclareLDITuple}
\RenderRelation{declare_ldi_tuple}
\BackupOriginalRelation{
The helper semantic relation
\[
    \declareldituple(\overname{\envs}{\env} \aslsep \overname{\KleeneStar{\Identifier}}{\vids} \aslsep \overname{\KleeneStar{(\nativevalue \times \XGraphs)}}{\liv}) \;\aslrel\;
     \ResultLDI(\overname{\XGraphs}{\vg} \aslsep \overname{\envs}{\newenv})
\]
is defined as follows.
} % END_OF_BACKUP_RELATION

See \ExampleRef{Evaluation of Tuple Declarations}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item both $\vids$ and $\liv$ are empty lists;
    \item \Proseeqdef{$\vg$}{the empty \executiongraphterm};
    \item \Proseeqdef{$\newenv$}{$\env$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vids$ is a list with \head{} $\id$ and \tail{} $\vids'$;
    \item $\liv$ is a list with \head{} $\vm$ and \tail{} $\liv'$;
    \item applying $\declarelocalidentifier$ to $\id$ and $\vv$ in $\env$ yields $(\envone, \vgtwo)$;
    \item applying $\declareldituple$ to $\vids'$ and $\liv'$ in $\envone$ yields $\ResultLDI(\vgthree, \newenv)$;
    \item \Proseeqdef{$\vg$}{the parallel composition of the ordered composition of $\vgone$ and $\vgtwo$
          with the $\asldata$ edge, and $\vgthree$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \declareldituple(\env, \overname{\emptylist}{\vids}, \overname{\emptylist}{\liv}) \evalarrow \ResultLDI(\emptygraph, \env)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vids = [\id] \concat \vids'\\
  \liv = [\vm] \concat \liv'\\
  \vm \eqname (\vv, \vgone)\\\\
  \declarelocalidentifier(\env, \id, \vv) \evalarrow (\envone, \vgtwo)\\
  \declareldituple(\envone, \vids', \liv') \evalarrow \ResultLDI(\vgthree, \newenv)\\
  \vg \eqdef (\ordered{\vgone}{\asldata}{\vgtwo}) \parallelcomp \vgthree\\
}{
  \declareldituple(\env, \vids, \liv) \evalarrow \ResultLDI(\vg, \newenv)
}
\end{mathpar}
