\documentclass{book}
\input{ASLmacros}

\input{ASLTypingLines}
\input{ASLTypeSatisfactionLines}
\input{ASLASTLines}
\newcommand{\tests}{../tests/ASLTypingReference.t/}

\author{Arm Architecture Technology Group}
\title{ASL Typing Reference}
\begin{document}
\maketitle

\tableofcontents{}

\chapter{Non-Confidential Proprietary Notice}
 
This document is protected by copyright and other related rights and the
practice or implementation of the information contained in this document may be
protected by one or more patents or pending patent applications. No part of
this document may be reproduced in any form by any means without the express
prior written permission of Arm. No license, express or implied, by estoppel or
otherwise to any intellectual property rights is granted by this document
unless specifically stated.
               
Your access to the information in this document is conditional upon your
acceptance that you will not use or permit others to use the information for
the purposes of determining whether implementations infringe any third party
patents.
 
THIS DOCUMENT IS PROVIDED “AS IS”. ARM PROVIDES NO REPRESENTATIONS AND NO
WARRANTIES, EXPRESS, IMPLIED OR STATUTORY, INCLUDING, WITHOUT LIMITATION, THE
IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY QUALITY, NON-INFRINGEMENT
OR FITNESS FOR A PARTICULAR PURPOSE WITH RESPECT TO THE DOCUMENT. For the
avoidance of doubt, Arm makes no representation with respect to, and has
undertaken no analysis to identify or understand the scope and content of, any
patents, copyrights, trade secrets, trademarks, or other rights. 
 
This document may include technical inaccuracies or typographical errors.
 
TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ARM BE LIABLE FOR ANY
DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL,
INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS
OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF
ARM HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 
This document consists solely of commercial items. You shall be responsible for
ensuring that any use, duplication or disclosure of this document complies
fully with any relevant export laws and regulations to assure that this
document or any portion thereof is not exported, directly or indirectly, in
violation of such export laws. Use of the word “partner” in reference to Arm’s
customers is not intended to create or refer to any partnership relationship
with any other company. Arm may make changes to this document at any time and
without notice.
 
This document may be translated into other languages for convenience, and you
agree that if there is any conflict between the English version of this
document and any translation, the terms of the English version of this document
shall prevail.
 
The Arm corporate logo and words marked with ® or ™ are registered trademarks
or trademarks of Arm Limited (or its affiliates) in the US and/or elsewhere.
All rights reserved.  Other brands and names mentioned in this document may be
the trademarks of their respective owners. Please follow Arm’s trademark usage
guidelines at \url{https://www.arm.com/company/policies/trademarks.}

Copyright © [2023,2024] Arm Limited (or its affiliates). All rights reserved. 
 
Arm Limited. Company 02557590 registered in England.  110 Fulbourn Road,
Cambridge, England CB1 9NJ.  (LES-PRE-20349)


\chapter{Disclaimer}

This document is part of the ASLRef material. This material covers both ASLv0
(viz, the existing ASL pseudocode language which appears in the Arm
Architecture Reference Manual) and ASLv1, a new, experimental, and as yet
unreleased version of ASL.

The development version of ASLRef can be found here \url{~/herdtools7/asllib}.

A list of open items being worked on can be found here
\url{~/herdtools7/asllib/doc/ASLRefProgress.tex}.

This material is work in progress, more precisely at Alpha quality as
per Arm’s quality standards. In particular, this means that it would be
premature to base any production tool development on this material.

However, any feedback, question, query and feature request would be most
welcome; those can be sent to Arm’s Architecture Formal Team Lead Jade
Alglave \texttt{(jade.alglave@arm.com)} or by raising issues or PRs to the herdtools7
github repository.

\chapter{Preamble}

\section{Abstract Syntax}
An \emph{abstract syntax tree} (AST, for short) represents an ASL program as a labelled tree.
The ASL Abstract Syntax is given in~\cite{ASLAbstractSyntaxReference}.

\section{Environments}

An environment is what the typing operates over: a structure which amongst
other things associates types to variables. Intuitively, the typing of a
program makes an initial environment evolve, with new types as given by the
variable declarations of the program. Environments map names to variables and
subprograms.

More precisely, a \emph{typing environment} (environment, for short) maps AST
nodes to types.

A \emph{type judgement} associates a node in an abstract syntax tree (which
intuitively corresponds to an ASL construct) with a certain type. We then say
that the node is \emph{annotated} with that type.
%

Defining the type annotation requires inferring various auxiliary attributes
for AST nodes. We consider these auxiliary attributes as part of the
environment as well. Technically, we partition the environment into two
distinct components: the global environment $G$---pertaining to AST nodes
appearing outside of a given subprogram, and the local environment
$L$---pertaining to AST nodes appearing inside a given subprogram.

\section{Type System}
A \emph{typing rule} specifies a conjunction of conditions that must hold in
order to annotate an AST node with a given type. These conditions typically
inspect the label of node and the type annotations on the children of the node
(in a given environment).

Not all conditions are type judgements. Some conditions are expressed in terms
of the auxiliary attributes mentioned above. We define these in the next
chapter.

A \emph{typing system} is a set of typing rules. More than one rule can be
associated with a given node label, but they are exclusive---at most one rule
holds in a given environment.

\section{Annotation}
Typing a program consists of annotating the root of its AST. This is typically
done by traversing the AST bottom-up.  To annotate a node, the typing algorithm
finds a rule that matches the node---that is a rule whose conditions are
satisfied. If one such rule is found, the node is annotated by the  result type
specified by the rule, essentially adding the type judgement to the
environment.  If no such rule is found, it is considered a \emph{typing error}
and the algorithm exits.

Sometimes it is to necessary to define \emph{error rules}---rules that result
in an error and provide extra information to help understand the reason for the
error.

We implement the process described above via a set of
\texttt{annotate\_<label>} functions. Each \texttt{annotate\_<label>}
function describes how to annotate an AST node, given its label, as follows:\begin{itemize}
\item \texttt{annotate\_expr} annotates expressions;
\item \texttt{annotate\_slices} annotates slices;
\item \texttt{annotate\_pattern} annotates pattern;
\item \texttt{annotate\_local\_decl\_item} annotates local declarations;
\item \texttt{annotate\_lexpr} annotates left-hand sides of assignments;
\item \texttt{annotate\_stmt} annotates statements;
\item \texttt{annotate\_block} annotates blocks;
\item \texttt{annotate\_catcher} annotates catchers;
\item \texttt{annotate\_call} annotates functions calls;
\item \texttt{annotate\_func} annotates functions.
\end{itemize}

This aims to encompass LRM 7.4.2. R\_VDPC.

\chapter{Reading guide}

The definition of each \texttt{annotation\_<label>} function is given by a number of
rules, which follow the possible shapes the \texttt{label} can have. For
example, an expression can be a literal, or a binary operator, amongst other
things. Each of those has its own evaluation rule: TypingRule.Lit in
Section~\ref{sec:TypingRule.Lit}, Typing.Binop in
Section~\ref{sec:TypingRule.Binop} respectively.

Each rule is presented using the following template:
\begin{itemize}
\item a Prose paragraph gives the rule in English, and corresponds as much as possible to the code of the reference implementation ASLRef given at \url{~/herdtools7/asllib};
\item one or several Example, which as much as possible are also given as regression tests in \url{~/herdtools7/asllib/tests/ASLTypingReference.t}
\item a Code paragraph which gives a verbatim of the corresponding implementation in the type-checker of ASLRef \url{~/herdtools7/asllib/Typing.ml};
\item Formal paragraphs which give formal definitions of the rule.
\end{itemize}

\chapter{Type Algebra}

\newcommand{\rulespace}{\;\;}

\section{TypingRule.BuiltinSingularType \label{sec:TypingRule.BuiltinSingularType}}

    \subsection{Prose}
    The \emph{builtin singular types} are:
    \begin{itemize}
    \item integer;
    \item real;
    \item string;
    \item boolean;
    \item bits;
    \item enumeration.
    \end{itemize}

    \subsection{Example: TypingRule.BuiltinSingularTypes.asl}
\VerbatimInput[firstline=3,lastline=8]{\tests/TypingRule.BuiltinSingularTypes.asl}
Variables of  buitin types \texttt{integer}, \texttt{real}, \texttt{boolean}, \texttt{bits(4)} and \texttt{bits(2)} are defined.

    \subsection{Example: TypingRule.EnumerationType.asl}
\VerbatimInput{\tests/TypingRule.EnumerationType.asl}
The type \texttt{color} consists in two different constants \texttt{RED} and~\texttt{BLACK}.

    \subsection{Code}
      \VerbatimInput[firstline=\BuiltinSingularBegin, lastline=\BuiltinSingularEnd]{../types.ml}


\begin{formal}
   \subsection{Formally}
\newcommand\isbuiltinsingular[0]{\texttt{is\_builtin\_singular}}
\[
\begin{array}{c}
\inferrule{}{\TReal : \isbuiltinsingular} \\ 
\\
\inferrule{}{\TString : \isbuiltinsingular} \\
\\
\inferrule{}{\TBool : \isbuiltinsingular} \\
\\
\inferrule{fl \in \textsf{bit\_field}^{*}}{\TBits(fl) : \isbuiltinsingular} \\
\\
\inferrule{il \in \textsf{\identifier}^{*}}{\TEnum(il) : \isbuiltinsingular}\\
\\
\inferrule{c \in \intconstraint^{*}}{\TInt(c) : \isbuiltinsingular} \\
\end{array}
\]
\end{formal}

    \subsection{Comments}
    This aims to encompass LRM Section 3.1 D\_PQCK and D\_NZWT.

\section{TypingRule.BuiltinAggregateType \label{sec:TypingRule.BuiltinAggregateType}}

    \subsection{Prose}
    The builtin aggregate types are:
    \begin{itemize}
    \item tuple;
    \item array;
    \item record;
    \item exception.
    \end{itemize}

    \subsection{Example: TypingRule.BuiltinAggregateTypes.asl}
      \VerbatimInput{\tests/TypingRule.BuiltinAggregateTypes.asl}
      Type \texttt{pair} is the type of integer and booleans pairs. Notice that
      the syntax of types and expressions are similar.

Arrays are indexed either by integers from 0 to (array size minus $1$) as specified in type
declaration, as illustrated by the type \texttt{T}, or by the elements of an
enumeration type, as illustrated by type~\texttt{pointCoord}.

The type~\texttt{pointRecord} is defined as a record type with  three fields
\texttt{x}, \texttt{y} and~\texttt{z}.

    \subsection{Example: TypingRule.BuiltinExceptionType.asl}
    \VerbatimInput{\tests/TypingRule.BuiltinExceptionType.asl}
    Two exception types are defined: exceptions \texttt{Not\_found} carry no
values, while exceptions \texttt{Error}  carry a messsage. Notice the
similarity with record types and that the empty field list \texttt{\{\}} can be
omitted in type declarations, as it is the case for \texttt{Not\_found}.

    \subsection{Code}
      \VerbatimInput[firstline=\BuiltinAggregateBegin, lastline=\BuiltinAggregateEnd]{../types.ml}

\begin{formal}
    \subsection{Formally}
\newcommand\isbuiltinaggregate[0]{\texttt{is\_builtin\_aggregate}}
\[
\begin{array}{c}
\inferrule{tl \in \ty^{*}}{\TTuple(tl) : \isbuiltinaggregate} \\
\\
\inferrule{t \in \ty}{\TArray(t) : \isbuiltinaggregate} \\
\\
\inferrule{fl \in \Field^{*}}{\TRecord(fl) : \isbuiltinaggregate}\\
\\
\inferrule{fl \in \Field^{*}}{\TException(fl) : \isbuiltinaggregate}\\
\end{array}
\]
\end{formal}

    \subsection{Comments}
    This aims to encompass LRM Section 3.1 D\_PQCK and D\_KNBD.

\section{TypingRule.BuiltinSingularOrAggregate \label{sec:TypingRule.BuiltinSingularOrAggregate}}

    \subsection{Prose}
    \texttt{t} is a builtin type and one of the following applies:
    \begin{itemize}
    \item \texttt{t} is singular;
    \item \texttt{t} is aggregate.
    \end{itemize}

    \subsection{Example}

    \subsection{Code}
      \VerbatimInput[firstline=\BuiltinSingularOrAggregateBegin, lastline=\BuiltinSingularOrAggregateEnd]{../types.ml}

\begin{formal}
      \subsection{Formally}
\newcommand\isbuiltin[0]{\texttt{is\_builtin}}
\[
\begin{array}{c}
\inferrule{t \in \ty \\ t : \isbuiltinsingular}{t : \isbuiltin}\\
\\
\inferrule{t \in \ty \\ t : \isbuiltinaggregate}{t : \isbuiltin}\\
\end{array}
\]
\end{formal}

\isempty{\subsection{Comments}}

\section{TypingRule.NamedType \label{sec:TypingRule.NamedType} }

    \subsection{Prose}
    A named type is a type which is declared using the \texttt{type} syntax.

    \subsection{Example}

    \subsection{Code}
      \VerbatimInput[firstline=\NamedBegin, lastline=\NamedEnd]{../types.ml}

\begin{formal}
      \subsection{Formally}
\newcommand\isnamed[0]{\texttt{is\_named}}
\[
\begin{array}{c}
\inferrule{i \in \identifier}{\TNamed(i) : \isnamed}
\end{array}
\]
\end{formal}

    \subsection{Comments}
    This aims to encompass LRM Section 7.1.1 D\_VMZX.

\section{TypingRule.AnonymousType \label{sec:TypingRule.AnonymousType}}

    \subsection{Prose}
    An anonymous type is a type which is not declared using the type syntax.

    \subsection{Example}

    \subsection{Code}
      \VerbatimInput[firstline=\AnonymousBegin, lastline=\AnonymousEnd]{../types.ml}

\begin{formal}
      \subsection{Formally}
\newcommand\isanonymous[0]{\texttt{is\_anonymous}}
\[
\begin{array}{c}
\inferrule{t \in \ty \\ \neg t : \isnamed}{t : \isanonymous}
\end{array}
\]
\end{formal}

    \subsection{Comments}
    This aims to encompass LRM Section 7.1.1 D\_VMZX.

\section{TypingRule.SingularType}

    \subsection{Prose}
    A type \texttt{t} is singular if one of the following applies:
    \begin{itemize}
    \item \texttt{t} is a builtin singular type;
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t} is a named type;
      \item \texttt{t\_struct} is the structure of \texttt{t};
      \item \texttt{t\_struct} is a builtin singular.
      \end{itemize}
    \end{itemize}

    \subsection{Example}

    \subsection{Code}
      \VerbatimInput[firstline=\SingularBegin, lastline=\SingularEnd]{../types.ml}

\begin{formal}
      \subsection{Formally}
\newcommand\issingular[0]{\texttt{is\_singular}}
\[
\begin{array}{c}
\inferrule{t \in \ty \\ t : \isbuiltin}{t : \issingular}\\
\\
\inferrule{t \in \ty \\ t : \isnamed \\ t : \isbuiltinaggregate \\
E \vdash \tstruct(t) : \isbuiltinsingular}{
E \vdash t : \issingular}
\end{array}
\]      

\end{formal}

    \subsection{Comments}
    This aims to encompass LRM Section 3.1 R\_GVZK.

\section{TypingRule.AggregateType}

    \subsection{Prose}
    A type \texttt{t} is aggregate if one of the following applies:
    \begin{itemize}
    \item \texttt{t} is a builtin aggregate type;
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t} is a named type;
      \item \texttt{t\_struct} is the structure of \texttt{t};
      \item \texttt{t\_struct} is a builtin aggregate.
      \end{itemize}
    \end{itemize}

    \subsection{Example}

    \subsection{Code}
      \VerbatimInput[firstline=\AggregateBegin, lastline=\AggregateEnd]{../types.ml}

\begin{formal}
      \subsection{Formally}
      
\newcommand\isaggregate[0]{\texttt{is\_aggregate}}
\[
\begin{array}{c}
\inferrule{t \in \ty \\ t : \isbuiltinaggregate}{t : \isaggregate}\\
\\
\inferrule{t \in \ty \\ t : \isnamed \\ E \vdash \tstruct(t) : \isbuiltinaggregate}{E \vdash t : \isaggregate}
\end{array}
\]
\end{formal}

    \subsection{Comments}
    This aims to encompass LRM Section 3.1 R\_GVZK.

\section{TypingRule.NonPrimitiveType}

    \subsection{Prose}
    A type \texttt{t} is non-primitive if one of the following applies:
    \begin{itemize}
    \item \texttt{t} is a named type;
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t} is a tuple \texttt{li};
      \item there exists a non-primitive type in \texttt{li};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t} is an array of type \texttt{ty}
      \item \texttt{ty} is non-primitive;
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t} is a record with fields \texttt{fields};
      \item there exists a non-primitive type in \texttt{fields};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t} is an exception with fields \texttt{fields};
      \item there exists a non-primitive type in \texttt{fields};
      \end{itemize}
    \end{itemize}

    \subsection{Example}

    \subsection{Code}
      \VerbatimInput[firstline=\NonPrimitiveBegin, lastline=\NonPrimitiveEnd]{../types.ml}

\begin{formal}
    \subsection{Formally}
\newcommand\isnonprimitive[0]{\texttt{is\_non\_primitive}}
\[
\begin{array}{c}
\inferrule{\id \in \identifier}{\TNamed(\id) : \isnonprimitive}\\ \\
\inferrule{t_1,\ldots,t_k \in \ty \\ i\in 1..k \\ t_i : \isnonprimitive}{\TTuple(t_1,\ldots,t_k) : \isnonprimitive}\\ \\
\inferrule{e \in \expr \\ t : \isnonprimitive}{\TArray(e, t) : \isnonprimitive}\\ \\
\inferrule{(\id_1,t_1),\ldots,(\id_k,t_k) \in (\identifier, \ty) \\ i\in 1..k \\ t_i : \isnonprimitive}{\TRecord((\id_1,t_1),\ldots,(\id_k,t_k)) : \isnonprimitive}\\ \\
\inferrule{(\id_1,t_1),\ldots,(\id_k,t_k) \in (\identifier, \ty) \\ i\in 1..k \\ t_i \isnonprimitive}{\TException((\id_1,t_1),\ldots,(\id_k,t_k)) : \isnonprimitive}\\ \\
\end{array}
\]


\end{formal}

    \subsection{Comments}
    This aims to encompass LRM Section 7.1.1 D\_GWXK.

\section{TypingRule.PrimitiveType}

    \subsection{Prose}
    A type \texttt{t} is primitive if it is not non-primitive.

    \subsection{Example}

    \subsection{Code}
      \VerbatimInput[firstline=\PrimitiveBegin, lastline=\PrimitiveEnd]{../types.ml}

\begin{formal}
  \subsection{Formally}

\end{formal}

    \subsection{Comments}
    This aims to encompass LRM Section 7.1.1 D\_GWXK.

\section{TypingRule.Structure}

    \subsection{Prose}
    \texttt{ty} is a type and its structure is \tstruct\ and one of the following
    applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{ty} is a named type \texttt{x};
      \item One of the following applies:
        \begin{itemize}
        \item All of the following apply:
          \begin{itemize}
          \item \texttt{x} is not declared in the global environment;
          \item an error ``\texttt{Undefined Identifier}'' is raised;
          \end{itemize}
        \item All of the following apply:
          \begin{itemize}
          \item \texttt{x} is declared in the global environment as some type \texttt{ty'};
          \item \texttt{t\_struct} is the structure of \texttt{ty'};
          \end{itemize}
       \end{itemize}
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t} is a builtin singular type;
      \item \texttt{t\_struct} is \texttt{ty};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{ty} is a tuple type with \texttt{tys};
      \item \texttt{t\_struct} is a tuple type with the structure of each element in \texttt{tys};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
        \item \texttt{ty} is an array type of length \texttt{e} with element type
          \texttt{t};
        \item \texttt{t\_struct} is an array type with of length \texttt{e}
          with element type the structure of \texttt{t};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
        \item \texttt{ty} is a record type with fields \texttt{fields};
        \item \texttt{fields} associates a name $x$ to a type $t_x$;
        \item \texttt{fields'} associates to each name $x$ of \texttt{fields}
          to the structure of $t_x$;
        \item \texttt{t\_struct} is a record type with fields \texttt{fields'}.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
        \item \texttt{ty} is an exception type with fields \texttt{fields};
        \item \texttt{fields} associates a name $x$ to a type $t_x$;
        \item \texttt{fields'} associates to each name $x$ of \texttt{fields}
          to the structure of $t_x$;
        \item \texttt{t\_struct} is an exception type with fields \texttt{fields'}.
      \end{itemize}
    \end{itemize}

    \subsection{Example}
    In this example:
    \texttt{type T1 of integer;} is the named type \texttt{T1}
whose structure is \texttt{integer}.

    In this example:
    \texttt{type T2 of (integer, T1);}
    is the named type \texttt{T2} whose structure is (integer, integer). In this
    example, \texttt{(integer, T1)} is non-primitive since it uses \texttt{T1}, which is builtin aggregate.

    In this example:
    \texttt{var x: T1;}
    the type of \texttt{x} is the named (hence non-primitive) type \texttt{T1}, whose structure
    is \texttt{integer}.

    In this example:
    \texttt{var y: integer;}
    the type of \texttt{y} is the anonymous primitive type \texttt{integer}.

    In this example:
    \texttt{var z: (integer, T1);}
    the type of \texttt{z} is the anonymous non-primitive type
\texttt{(integer, T1)} whose structure is \texttt{(integer, integer)}.

    \subsection{Code}
      \VerbatimInput[firstline=\StructureBegin, lastline=\StructureEnd]{../types.ml}

\begin{emptyformal}
      \subsection{Formally}
\end{emptyformal}
    \subsection{Comments}
    The structure of a type is the primitive type it is equivalent to such that
    it can hold the same values.

    This aims to encompass LRM Section 7.1.2 D\_FXQV.

\section{TypingRule.Domain}

  \subsection{Prose}
  The domain of a type is the set of values which storage elements of that type
may hold.

  \subsection{Example}
  The domain of \texttt{integer} is the infinite set of all integers.

  The domain of \texttt{bits(1)} is the set \texttt{{‘1’, ‘0’}}.

  The domain of \texttt{integer {2,16}} is the set containing the integers \texttt{2} and \texttt{16}.

  \subsection{Code}
      \VerbatimInput[firstline=\DomainBegin, lastline=\DomainEnd]{../types.ml}

\begin{emptyformal}
      \subsection{Formally}
\end{emptyformal}

  \subsection{Comments}
  This aims to encompass LRM Section 7.1.3 D\_BMGM.

\section{Constrained Types}

\subsection{Prose}
  \begin{itemize}
  \item A constrained type is a type whose definition depends on an expression, e.g. certain integers and bitvectors.
  \item A type which is not constrained is unconstrained.
  \item A constrained type with a non-empty constraint is well-constrained.
  \item An under-constrained integer type is an implicit type of a subprogram parameter.
  \end{itemize}

  \subsection{Example}
    Bitvector storage element’s widths are constrained integers.

  \subsection{Code}
    \VerbatimInput[firstline=\ConstrainedBegin, lastline=\ConstrainedEnd]{../AST.mli}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 3.4.1 D\_ZTPP, R\_WJYH, R\_HJPN, R\_CZTX, R\_TPHR

\chapter{Type Satisfaction and Related Notions}

\section{TypingRule.Subtype}

  \subsection{Prose}
  A type \texttt{t1} subtypes a type \texttt{t2} in the environment
  \texttt{env} if and only if one of the following applies:
  \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
        \item \texttt{t1} is a named type;
        \item \texttt{t2} is a named type;
        \item \texttt{t1} and \texttt{t2} are the same type.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
        \item \texttt{t1} is a named type;
        \item \texttt{t2} is a named type;
        \item \texttt{t1} is declared as a subtype of \texttt{t1'} in \texttt{env};
        \item \texttt{t1'} is a subtype of \texttt{t2} in \texttt{env}.
      \end{itemize}
  \end{itemize}
  The subtype relation is a partial order.

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SubtypeBegin, lastline=\SubtypeEnd]{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\newcommand\super[0]{\textit{super}}
	  \newcommand\subtype[0]{\sqsubseteq}

	  To model subtyping, we define the function
	  \[
	  \super : \identifier \rightarrow \identifier \cup {\bot} \enspace,
	  \]
	  which maps an identifier to the name of its super-type or $\bot$ if it does not have one.

	  We define the subtyping relation between two named types in a given environment as follows:
	  \[
	  \begin{array}{rl}
	  a, b \in \identifier & (G,L) \vdash \texttt{T\_Named(a)} \subtype \texttt{T\_Named(a)} \\
	  a, b \in \identifier \rulespace G.\super(a) = b  &
	  (G,L) \vdash \texttt{T\_Named(a)} \subtype \texttt{T\_Named(b)}
	  \end{array}
	  \]

  \subsection{Comments}
  Since the subtype relation is a partial order, it is reflexive, viz,
  every type is also a subtype of itself.

  Since the subtype relation is a partial order, it is transitive, viz, if A is
  a subtype of B and B is a subtype of C then A is a subtype of C.

  As a consequence, there is no need to declare the reflexive and transitive
  subtype relations explicitly. All other subtype relations must be explicitly
  declared.

  Since the subtype relation is a partial order, it is antisymmetric. Therefore
  it is an error if all of the following apply:
  \begin{itemize}
  \item \texttt{id1} is a subtype of \texttt{id2};
  \item \texttt{id2} is a subtype of \texttt{id1}.
  \end{itemize}

  This aims to encompass LRM Section 4.3.1 R\_NXRX, I\_KGKS, I\_MTML, I\_JVRM, I\_CHMP.

\section{TypingRule.Supertype}

  \subsection{Prose}
  \texttt{T} is a supertype of \texttt{S} if and only if \texttt{S} is a subtype of \texttt{T}.

  \subsection{Example}

  \subsection{Code}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  Since the subtype relation is a partial order, it is reflexive. Therefore the
  supertype relation also is reflexive, viz, every type is also a supertype of
  itself.

  This aims to encompass LRM Section 4.3.1 I\_KGKS.

\section{TypingRule.StructuralSubtypeSatisfaction}

\subsection{Prose}
  \texttt{T} structural-subtype-satisfies \texttt{S} if one of the following applies:
  \begin{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of an integer type;
    \item \texttt{T} has the structure of an integer type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of a real type;
    \item \texttt{T} has the structure of a real type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of a string type;
    \item \texttt{T} has the structure of a string type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of a boolean type;
    \item \texttt{T} has the structure of a boolean type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of an enumeration type;
    \item \texttt{T} has the structure of an enumeration type;
    \item \texttt{S} and \texttt{T} have the same enumeration literals.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of a bitvector type with determined width \texttt{w};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{T} has the structure of a bitvector type of determined width \texttt{w};
      \item \texttt{T} has the structure of a bitvector type of undetermined width.
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of a bitvector type with undetermined width;
    \item \texttt{T} has the structure of a bitvector type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of a bitvector type with bitfields \texttt{bitfields} and width \texttt{width};
    \item \texttt{T} has the structure of a bitvector type with width \texttt{width};
    \item for every bitfield \texttt{f} in \texttt{bitfields} there is a bitfield \texttt{f'} in \texttt{T} and
      all of the following apply:
      \begin{itemize}
      \item \texttt{f'} has the same name, width and offset as \texttt{f};
      \item \texttt{f'} type-satisfies \texttt{f}.
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of an array type with elements of type \texttt{E};
    \item \texttt{T} has the structure of an array type with elements of type \texttt{E};
    \item \texttt{T} has the same element indices as \texttt{S}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of a tuple type;
    \item \texttt{T} has the structure of a tuple type;
    \item \texttt{T} has the same number of elements as \texttt{S};
    \item for each element \texttt{e} in \texttt{S} there is an element \texttt{e'} in \texttt{T} and \texttt{e'}
      type-satisfies \texttt{e}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of a record type;
    \item \texttt{T} has the structure of a record type;
    \item for each field \texttt{f} in \texttt{S} there is an element \texttt{f'} in \texttt{T} and \texttt{f'} has
      the same type as \texttt{f}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} has the structure of an exception type;
    \item \texttt{T} has the structure of an exception type;
    \item for each field \texttt{f} in \texttt{S} there is an element \texttt{f'} in \texttt{T} and \texttt{f'} has
      the same type as \texttt{f}.
    \end{itemize}
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\StructuralSubtypeSatisfactionBegin, lastline=\StructuralSubtypeSatisfactionEnd]{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This aims to encompass LRM Section 7.3.1. D\_TRVR.

\section{TypingRule.DomainSubtypeSatisfaction}

\subsection{Prose}
 \texttt{T} domain-subtype-satisfies \texttt{S} if one of the following applies:
 \begin{itemize}
 \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} does not have the structure of an aggregate type or bitvector type;
    \item the domain of \texttt{T} is a subset of the domain of \texttt{S}.
    \end{itemize}

  \item All of the following apply:
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{S} has the structure of a bitvector type with undetermined width;
      \item \texttt{T} has the structure of a bitvector type with undetermined width;
      \end{itemize}
   \item the domain of \texttt{T} is a subset of the domain of \texttt{S}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\DomainSubtypeSatisfactionBegin, lastline=\DomainSubtypeSatisfactionEnd]{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.3.1. D\_TRVR.

\section{TypingRule.SubtypeSatisfaction}

  \subsection{Prose}
    \texttt{T} subtype-satisfies \texttt{S} if all of the following apply:
    \begin{itemize}
    \item \texttt{T} structural-subtype-satisfies \texttt{S};
    \item \texttt{T} domain-subtype-satisfies \texttt{S}.
    \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SubtypeSatisfactionBegin, lastline=\SubtypeSatisfactionEnd]{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.3.1. D\_TRVR.

\section{TypingRule.TypeSatisfaction \label{sec:TypingRule.TypeSatisfaction}}

\subsection{Prose}

\texttt{T} type-satisfies \texttt{S} if one of the following applies:
 \begin{itemize}
 \item \texttt{T} is a subtype of \texttt{S};
 \item All of the following apply:
    \begin{itemize}
    \item \texttt{T} subtype-satisfies \texttt{S};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{S} is an anonymous type;
      \item \texttt{T} is an anonymous type;
      \end{itemize}
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item \texttt{T} is an anonymous bitvector with no bitfields;
    \item \texttt{S} has the structure of a bitvector (with or without bitfields);
    \item \texttt{S} has the same width as \texttt{T}.
    \end{itemize}
  \end{itemize}

\subsection{Example: TypingRule.TypeSatisfaction1.asl}
    In the program:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction1.asl}
    \texttt{var pair: pairT = (1, dataT1)} is legal since the right-hand-side has
    anonymous, non-primitive type \texttt{(integer, T1)}.

\subsection{Example: TypingRule.TypeSatisfaction2.asl}
    In the program:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction2.asl}
    \texttt{pair = (1, dataAsInt);} is legal since the right-hand-side has anonymous,
    primitive type \texttt{(integer, integer)}.

\subsection{Example: TypingRule.TypeSatisfaction3.asl}
    In the program:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction3.asl}
    \texttt{pair = (1, dataT2);} is illegal since the right-hand-side has anonymous,
    non-primitive type \texttt{(integer, T2)} which does not subtype-satisfy named
    type \texttt{pairT}.

  \subsection{Code}
    \VerbatimInput[firstline=\TypeSatisfactionBegin, lastline=\TypeSatisfactionEnd]{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  Since the subtype relation is a partial order, it is reflexive. Therefore
  every type \texttt{T} is a subtype of itself, and as a consequence, every type \texttt{T}
  type-satisfies itself.

  This aims to encompass LRM Section 7.3.2 R\_FMXK and I\_NLFD.

\section{TypingRule.CanAssignTo \label{sec:TypingRule.CanAssignTo}}

  \subsubsection{Prose}
  \texttt{S} can be assigned to \texttt{T} if and only if all of the following apply:
  \begin{itemize}
  \item neither \texttt{S} nor \texttt{T} has the structure of the under-constrained integer type;
  \item \texttt{T} type-satisfies \texttt{S}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\CanAssignToBegin, lastline=\CanAssignToEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This aims to encompass LRM R\_GNTS and R\_LXQZ.

\section{TypingRule.TypeClash}

  \subsection{Prose}
  \texttt{T} type-clashes with \texttt{S} if one of the following applies:
  \begin{itemize}
  \item \texttt{S} and \texttt{T} both have the structure of integers;
  \item \texttt{S} and \texttt{T} both have the structure of reals;
  \item \texttt{S} and \texttt{T} both have the structure of strings;
  \item \texttt{S} and \texttt{T} both have the structure of enumeration types with the same enumeration literals;
  \item \texttt{S} and \texttt{T} both have the structure of bitvectors;
  \item \texttt{S} and \texttt{T} both have the structure of arrays whose element types type-clash;
  \item \texttt{S} and \texttt{T} both have the structure of tuples of the same length whose
    corresponding element types type-clash;
  \item \texttt{S} is a subtype of \texttt{T};
  \item \texttt{S} is a supertype of \texttt{T}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\TypeClashBegin, lastline=\TypeClashEnd]{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  Note that if \texttt{T} subtype-satisfies \texttt{S} then \texttt{T} and \texttt{S} type-clash, but not the other
  way around.

  Note that type-clashing is an equivalence relation. Therefore if \texttt{T}
  type-clashes with \texttt{A} and \texttt{B} then it is also the case that \texttt{A} and \texttt{B} type-clash.

  This aims to encompass LRM Section 7.3.3. D\_VPZZ, I\_PQCT and I\_WZKM.

\section{TypingRule.LowestCommonAncestor \label{sec:TypingRule.LowestCommonAncestor}}

\subsection{Prose}
  The lowest common ancestor of types \texttt{S} and \texttt{T} is \texttt{ty} and one of the following applies:
  \begin{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} and \texttt{T} are the same type;
    \item \texttt{ty} is \texttt{S}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} and \texttt{T} are both named types;
    \item \texttt{ty} is a common supertype of \texttt{S} and \texttt{T};
    \item \texttt{ty} is a subtype of all other common supertypes of \texttt{S} and \texttt{T}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} and \texttt{T} both have the structure of array types with the same index type
      and the same element types;

    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is a named type;
        \item \texttt{T} is an anonymous type;
        \item \texttt{ty} is \texttt{S}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is an anonymous type;
        \item \texttt{T} is a named type;
        \item \texttt{ty} is \texttt{T}.
        \end{itemize}
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} and \texttt{T} both have the structure of tuple types with the same number of elements;
    \item The types of the elements of \texttt{S} type-satisfy the types of the elements of \texttt{T};
    \item The types of the elements of \texttt{T} type-satisfy the types of the elements of \texttt{S};
    \item One of the following applies:

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is a named type;
        \item \texttt{T} is an anonymous type;
        \item \texttt{ty} is \texttt{S}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is an anonymous type;
        \item \texttt{T} is a named type;
        \item \texttt{ty} is \texttt{T}.
        \end{itemize}

     \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is an anonymous type;
        \item \texttt{T} is an anonymous type;
	\item \texttt{ty} is the tuple type where the type of each element is the lowest common
	  ancestor of the types of the corresponding elements of \texttt{S} and \texttt{T}.
        \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{S} and \texttt{T} both have the structure of well-constrained integer types;
    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is a named type;
        \item \texttt{T} is an anonymous type;
        \item \texttt{ty} is \texttt{S}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is an anonymous type;
        \item \texttt{T} is a named type;
        \item \texttt{ty} is \texttt{T}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is an anonymous type;
        \item \texttt{T} is an anonymous type;
	\item \texttt{ty} is the well-constrained integer type whose domain is the union of the
	  domains of \texttt{S} and \texttt{T}.
        \end{itemize}
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item Either \texttt{S} or \texttt{T} have the structure of an unconstrained integer type;
    \item One of the following applies:

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is a named type;
        \item \texttt{S} has the structure of an unconstrained integer type;
        \item \texttt{T} is an anonymous type;
        \item \texttt{ty} is \texttt{S}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item S is an anonymous type;
        \item T is a named type;
        \item T has the structure of an unconstrained integer type;
        \item ty is T.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{S} is an anonymous type;
        \item \texttt{T} is an anonymous type;
	\item \texttt{ty} is the unconstrained integer type.
        \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item Either \texttt{S} or \texttt{T} have the structure of an under-constrained integer type;
    \item \texttt{ty} is the under-constrained integer type.
    \end{itemize}

  \item \texttt{ty} is undefined.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LowestCommonAncestorBegin, lastline=\LowestCommonAncestorEnd]{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.6.1. R\_YZHM.

\section{TypingRule.CheckUnop \label{sec:TypingRule.CheckUnop}}

\subsection{Goal}
  Checking compatibility of an unary operator with the type of its argument.

\subsection{Prose}
  \texttt{t} is the result of checking compatibility of a unary operator \texttt{op} with
  type \texttt{t1} and one of the following applies:
  \begin{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{BNOT};
    \item \texttt{t1} type-satisfies \texttt{boolean};
    \item \texttt{t} is \texttt{boolean};
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{NEG};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{t1} type-satisfies \texttt{integer};
      \item \texttt{t1} type-satisfies \texttt{real};
      \end{itemize}
     \item One of the following applies:
       \begin{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item \texttt{t1} has the structure of an unconstrained integer;
         \item \texttt{t} is an unconstrained integer;
         \end{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item \texttt{t1} has the structure of a constrained integer;
         \item \texttt{t} is a constrained integer whose constraint is ;
         \end{itemize}
       \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{NOT};
    \item \texttt{t1} has the structure of a bitvector;
    \item \texttt{t} is \texttt{t1}.
    \end{itemize}
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\CheckUnopBegin, lastline=\CheckUnopEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.CheckBinop \label{sec:TypingRule.CheckBinop}}

\subsection{Goal}
  Checking compatibility of a binary operator with the types of its arguments.

\subsection{Prose}
  \texttt{t} is the result of checking compatibility of a binary operator \texttt{op} with
  types \texttt{t1} and \texttt{t2} and one of the following applies:
\begin{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{AND}, \texttt{OR}, \texttt{EQ} or \texttt{IMPL};
    \item \texttt{t1} type-satisfies \texttt{boolean};
    \item \texttt{t2} type-satisfies \texttt{boolean};
    \item \texttt{t} is \texttt{boolean}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{AND}, \texttt{OR}, or \texttt{EOR};
    \item \texttt{t1} has the structure of a bitvector;
    \item \texttt{t2} has the structure of a bitvector;
    \item \texttt{t1} and \texttt{t2} have the same bitvector width \texttt{w};
    \item \texttt{t} is the bitvector type of width \texttt{w}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{PLUS} or \texttt{MINUS};
    \item \texttt{t1} has the structure of a bitvector;
    \item \texttt{t2} has the structure of a bitvector;
    \item \texttt{t1} and \texttt{t2} have the same bitvector width \texttt{w};
    \item \texttt{t2} type-satisfies \texttt{integer};
    \item \texttt{t} is the bitvector type of width \texttt{w}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{EQ\_OP} or \texttt{NEQ};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{t1} is equal to \texttt{t2};
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} type-satisfies \texttt{integer};
        \item \texttt{t2} type-satisfies \texttt{integer};
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} has the structure of a bitvector;
        \item \texttt{t2} has the structure of a bitvector;
        \item \texttt{t1} and \texttt{t2} have the same bitvector width;
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} type-satisfies \texttt{boolean};
        \item \texttt{t2} type-satisfies \texttt{boolean};
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} enumerates local declarations \texttt{li1};
        \item \texttt{t2} enumerates local declarations \texttt{li2};
        \item \texttt{li1} equals \texttt{li2};
        \end{itemize}
      \end{itemize}
    \item \texttt{t} is \texttt{boolean}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{LEQ}, \texttt{GEQ}, \texttt{GT} or \texttt{LT};
    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} type-satisfies \texttt{integer};
        \item \texttt{t2} type-satisfies \texttt{integer};
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} type-satisfies \texttt{real};
        \item \texttt{t2} type-satisfies \texttt{real};
        \end{itemize}
      \end{itemize}
    \item \texttt{t} is boolean.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{MUL}, \texttt{DIV}, \texttt{DIVRM}, \texttt{MOD}, \texttt{SHL}, \texttt{SHR}, \texttt{POW}, \texttt{PLUS} or \texttt{MINUS};
    \item \texttt{struct1} is the structure of \texttt{t1};
    \item \texttt{struct2} is the structure of \texttt{t2};
    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} has the structure of an unconstrained integer;
        \item \texttt{t2} has the structure of an integer;
        \item \texttt{t} is an unconstrained integer;
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} has the structure of an integer;
        \item \texttt{t2} has the structure of an unconstrained integer;
        \item \texttt{t} is an unconstrained integer;
        \end{itemize}
      \item One of the following applies:
       \begin{itemize}
       \item All of the following apply:
          \begin{itemize}
          \item \texttt{t1} has the structure of an under-constrained integer;
          \item \texttt{t2} has the structure of a constrained integer;
          \item \texttt{t} is an under-constrained integer;
          \end{itemize}
        \item All of the following apply:
          \begin{itemize}
          \item \texttt{t1} has the structure of a constrained integer;
          \item \texttt{t2} has the structure of an under-constrained integer;
          \item \texttt{t} is an under-constrained integer;
          \end{itemize}
       \end{itemize}
      \item One of the following applies:
         \begin{itemize}
         \item All of the following apply:
           \begin{itemize}
           \item \texttt{t1} has the structure of a well-constrained integer;
           \item \texttt{t2} has the structure of a well-constrained integer;
	   \item \texttt{t} is a constrained integer whose constraint is calculated by
	     applying the operation to all possible value pairs;
           \end{itemize}
         \item All of the following apply:
           \begin{itemize}
           \item \texttt{t1} has the structure of a well-constrained integer;
           \item \texttt{t2} has the structure of an well-constrained integer;
	   \item \texttt{t} is a constrained integer whose constraint is calculated by
	     applying the operation to all possible value pairs;
           \end{itemize}
         \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} has the structure of \texttt{real};
        \item \texttt{t2} has the structure of \texttt{real};
        \item \texttt{op} is \texttt{PLUS}, \texttt{MINUS} or \texttt{MUL};
        \item \texttt{t} is \texttt{real};
        \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t1} has the structure of \texttt{real};
       \item \texttt{t2} has the structure of \texttt{integer};
       \item \texttt{op} is \texttt{POW};
       \item \texttt{t} is \texttt{real};
       \end{itemize}
     \end{itemize}
   \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{RDIV};
    \item \texttt{t1} type-satisfies \texttt{real};
    \item \texttt{t} is \texttt{real}.
    \end{itemize}
\end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\CheckUnopBegin, lastline=\CheckUnopEnd]{../Typing.ml}

\begin{formal}
    \subsection{Formally}
  \[
  \inferrule
  {\textit{op} \in \texttt{binop\_boolean} \\ (G,L) \vdash e_1 : \TBool \\ (G,L) \vdash e_2 : \TBool}
  {(G,L) \vdash \texttt{E\_Binop}(\textit{op}, e_1, e_2) : \TBool1}
  \]
\end{formal}

\subsection{Comments}
  This aims to encompass LRM Section 7.5.3 R\_BKNT, Section 7.5.5 R\_ZYWY, R\_BZKW,
  R\_KFYS, Section 7.5.6 R\_KXMR, Section 7.7 R\_SQXN, R\_MRHT.

\chapter{Typing of Expressions}

\texttt{annotate\_expr} specifies how to annotate an expression \texttt{e} in
an environment \texttt{env}.  Formally, the result of annotating the expression
\texttt{e} in \texttt{env} is \texttt{t,new\_env} where \texttt{t} is a type and
\texttt{new\_env} is an environment, or an error, and one of the following applies:
\begin{itemize}
\item TypingRule.Lit (see Section~\ref{sec:TypingRule.Lit});
\item TypingRule.ELocalVarConstant (see Section~\ref{sec:TypingRule.ELocalVarConstant})
\item TypingRule.ELocalVar (see Section~\ref{sec:TypingRule.ELocalVar})
\item TypingRule.EGlobalVarConstant (see Section~\ref{sec:TypingRule.EGlobalVarConstant})
\item TypingRule.EGlobalVar (see Section~\ref{sec:TypingRule.EGlobalVar})
\item TypingRule.EUndefIdent (see Section~\ref{sec:TypingRule.EUndefIdent})
\item TypingRule.Binop (see Section~\ref{sec:TypingRule.Binop})
\item TypingRule.Unop (see Section~\ref{sec:TypingRule.Unop})
\item TypingRule.ECond (see Section~\ref{sec:TypingRule.ECond})
\item TypingRule.ESlice (see Section~\ref{sec:TypingRule.ESlice})
\item TypingRule.ECall (see Section~\ref{sec:TypingRule.ECall})
\item TypingRule.EGetArray (see Section~\ref{sec:TypingRule.EGetArray})
\item TypingRule.EStructuredNotStructured (see Section~\ref{sec:TypingRule.EStructuredNotStructured})
\item TypingRule.EStructuredMissingField (see Section~\ref{sec:TypingRule.EStructuredMissingField})
\item TypingRule.ERecord (see Section~\ref{sec:TypingRule.ERecord})
\item TypingRule.EGetRecordField (see Section~\ref{sec:TypingRule.EGetRecordField})
\item TypingRule.EGetBadRecordField (see Section~\ref{sec:TypingRule.EGetBadRecordField})
\item TypingRule.EGetBadBitField (see Section~\ref{sec:TypingRule.EGetBadBitField})
\item TypingRule.EGetBadField (see Section~\ref{sec:TypingRule.EGetBadField})
\item TypingRule.EGetBitField (see Section~\ref{sec:TypingRule.EGetBitField})
\item TypingRule.EGetBitFieldNested (see Section~\ref{sec:TypingRule.EGetBitFieldNested})
\item TypingRule.EGetBitFieldTyped (see Section~\ref{sec:TypingRule.EGetBitFieldTyped})
\item TypingRule.EConcatEmpty (see Section~\ref{sec:TypingRule.EConcatEmpty})
\item TypingRule.EConcat (see Section~\ref{sec:TypingRule.EConcat})
\item TypingRule.ETuple (see Section~\ref{sec:TypingRule.ETuple})
\item TypingRule.EUnknown (see Section~\ref{sec:TypingRule.EUnknown})
\item TypingRule.EPattern (see Section~\ref{sec:TypingRule.EPattern})
\item TypingRule.CTC (see Section~\ref{sec:TypingRule.CTC})
\end{itemize}

\section{TypingRule.Lit \label{sec:TypingRule.Lit}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} is a Literal \texttt{v};
  \item \texttt{t} is the type of \texttt{v};
  \item \texttt{new\_env} is \texttt{e}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\LitBegin, lastline=\LitEnd]{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ELocalVarConstant \label{sec:TypingRule.ELocalVarConstant}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a variable \texttt{x};
  \item \texttt{x} is bound to a local constant~\texttt{v} of type \texttt{ty} in the local environment given by \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_env} is the Literal \texttt{v}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\ELocalVarConstantBegin, lastline=\ELocalVarConstantEnd]{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ELocalVar \label{sec:TypingRule.ELocalVar}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a variable \texttt{x};
  \item \texttt{x} is not bound to a local constant;
  \item \texttt{x} has type \texttt{ty} in the local environment given by \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_env} is \texttt{e}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\ELocalVarBegin, lastline=\ELocalVarEnd]{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVarConstantVal \label{sec:TypingRule.EGlobalVarConstant}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a variable \texttt{x};
  \item \texttt{x} is bound to a global constant~\texttt{v} of type \texttt{ty} in the global environment given by \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_env} is the Literal \texttt{v}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\EGlobalVarConstantBegin, lastline=\EGlobalVarConstantEnd]{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVar \label{sec:TypingRule.EGlobalVar}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a variable \texttt{x};
  \item \texttt{x} is not bound to a global constant;
  \item \texttt{x} has type \texttt{ty} in the global environment given by \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_env} is \texttt{e}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\EGlobalVarBegin, lastline=\EGlobalVarEnd]{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EUndefIdent \label{sec:TypingRule.EUndefIdent}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} is a variable \texttt{x};
  \item \texttt{x} is not bound in \texttt{env};
  \item an error ``\texttt{Undefined Identifier}'' is raised.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\EUndefIdentBegin, lastline=\EUndefIdentEnd]{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.Binop \label{sec:TypingRule.Binop}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a binary operation \texttt{op} over two expressions \texttt{e1} and \texttt{e2};
  \item \texttt{t1,e1'} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t2,e2'} is the result of annotating \texttt{e2} in \texttt{env};
  \item \texttt{t} is the result of checking compatibility of \texttt{op} with \texttt{t1} and \texttt{t2} as per Section~\ref{sec:TypingRule.CheckBinop};
  \item \texttt{new\_env} denotes \texttt{op} over \texttt{e1'} and \texttt{e2'}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\BinopBegin, lastline=\BinopEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.Unop \label{sec:TypingRule.Unop}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a unary operation \texttt{op} over an expression \texttt{e'};
  \item \texttt{t'',e''} is the result of annotating \texttt{e'} in \texttt{env};
  \item \texttt{t} is the result of checking compatibility of \texttt{op} with \texttt{t''} as per Section~\ref{sec:TypingRule.CheckUnop};
  \item \texttt{new\_env} denotes \texttt{op} over \texttt{e''}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\UnopBegin, lastline=\UnopEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ECond \label{sec:TypingRule.ECond}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a conditional expression with condition \texttt{e\_cond} with two options \texttt{e\_true} and \texttt{e\_false};
  \item \texttt{t\_cond, e'\_cond} is the result of annotating \texttt{e\_cond} in \texttt{env};
  \item \texttt{t\_true, e'\_true} is the result of annotating \texttt{e\_true} in \texttt{env};
  \item \texttt{t\_false, e'\_false} is the result of annotating \texttt{e\_false} in \texttt{env};
  \item One of the following applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t} is the lowest common ancestor of \texttt{t\_true} and \texttt{t\_false};
      \item \texttt{new\_env} is the condition \texttt{e'\_cond} with two options \texttt{e'\_true} and \texttt{e'\_false}.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item there is no lowest common ancestor of \texttt{t\_true} and \texttt{t\_false};
      \item an error ``\texttt{Unreconciliable Types}'' is raised.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\ECondBegin, lastline=\ECondEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This aims to encompass LRM Section 7.6 R\_XZVT.

\section{TypingRule.ESlice \label{sec:TypingRule.ESlice}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the slicing of expression \texttt{e'} by the slices \texttt{slices};
  \item \texttt{t\_e',e'} is the result of annotating the expression \texttt{e'} in \texttt{env};
  \item an error ``\texttt{Conflicting Types}'' is raised or \texttt{t\_e'} has the structure of an integer or a bitvector and all of the following apply:
  \item \texttt{w} is the width of \texttt{slices};
  \item \texttt{slices'} is the result of annotating \texttt{slices} in \texttt{env};
  \item \texttt{t} is the bitvector type of width \texttt{w};
  \item \texttt{new\_env} is the slicing of expression \texttt{e'} by the slices \texttt{slices'}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\ESliceBegin, lastline=\ESliceEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    The width of \texttt{slices} might be a symbolic expression if one of the
widths references a \texttt{let} identifier with a non-compile-time-constant initialiser
expression.

\section{TypingRule.ECall \label{sec:TypingRule.ECall}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a call to a subprogram named \texttt{name} with arguments \texttt{args} and
    parameters \texttt{eqs};
  \item \texttt{name', args', eqs', ty} is the result of annotating the call of
    that subprogram in \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_env} is the call to the subprogram named \texttt{name'} with arguments \texttt{args'}
    and parameters \texttt{eqs'}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\ECallBegin, lastline=\ECallEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetArray \label{sec:TypingRule.EGetArray}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} or an error and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the slicing of expression \texttt{e'} by the slices \texttt{slices};
  \item \texttt{t\_e',e'} is the result of annotating the expression \texttt{e'} in \texttt{env};
  \item \texttt{t\_e'} has the structure of an array with index type \texttt{wanted\_t\_index} and element type \texttt{t};
  \item an error ``Conflicting Types'' is raised or \texttt{slices} is a single expression \texttt{e\_index} and all of the following apply:
  \item \texttt{t\_index', e\_index'} is the result of annotating \texttt{e\_index} in \texttt{env};
  \item an error ``\texttt{Conflicting Types}'' or \texttt{t\_index'} type-satisfies \texttt{wanted\_t\_index} as per Section~\ref{sec:TypingRule.TypeSatisfaction} and all of the following apply:
  \item \texttt{new\_e} is an access to array \texttt{e'} at index \texttt{e\_index'}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EGetArrayBegin, lastline=\EGetArrayEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EStructuredNotStructured \label{sec:TypingRule.EStructuredNotStructured}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the record expression or an exception expression of type \texttt{ty} with fields \texttt{fields};
  \item \texttt{ty} is neither a record nor an exception type;
  \item an error ``\texttt{Conflicting Types}'' is raised.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EStructuredNotStructuredBegin, lastline=\EStructuredNotStructuredEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

  This aims to encompass LRM Section 5.5 R\_WBCQ.

\section{TypingRule.EStructuredMissingField \label{sec:TypingRule.EStructuredMissingField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the record expression or an exception expression of type \texttt{ty} with fields \texttt{fields};
  \item \texttt{ty} is the name of a record or exception type with fields \texttt{field\_types};
  \item one field in \texttt{field\_types} is not initialised by \texttt{fields};
  \item an error ``\texttt{Missing Field}'' is raised.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EStructuredMissingFieldBegin, lastline=\EStructuredMissingFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This aims to encompass LRM Section 5.5 R\_WBCQ.

\section{TypingRule.ERecord \label{sec:TypingRule.ERecord}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the record expression of type \texttt{ty} with fields \texttt{fields};
  \item \texttt{ty} is the name of a record type with fields \texttt{field\_types};
  \item For each field named \texttt{name} associated with the expression \texttt{e'} in
    \texttt{field\_types}, all of the following apply:
    \begin{itemize}
    \item \texttt{t',e''} is the result of annotating \texttt{e'} in \texttt{env};
    \item \texttt{t\_spec'} is the type associated to \texttt{name} in \texttt{field\_types};
    \item \texttt{t'} type-satisfies \texttt{t\_spec'} as per Section~\ref{sec:TypingRule.TypeSatisfaction};
    \item \texttt{fields'} associates \texttt{name} to \texttt{e''};
    \end{itemize}
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_env} is the record expression of type \texttt{ty} with fields \texttt{fields'}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\ERecordBegin, lastline=\ERecordEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This aims to encompass LRM Section 5.5 R\_WBCQ.


\section{TypingRule.EGetRecordField \label{sec:TypingRule.EGetRecordField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t\_e1} has the structure of an exception or record type with fields \texttt{fields};
  \item \texttt{t\_e2} has the structure of an exception or record type with fields \texttt{fields};
  \item \texttt{field\_name} is declared in \texttt{fields};
  \item \texttt{t} is the type corresponding to \texttt{field\_name} in \texttt{fields};
  \item \texttt{new\_env} is the access of field \texttt{field\_name} on expression \texttt{e2}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EGetRecordFieldBegin, lastline=\EGetRecordFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadRecordField \label{sec:TypingRule.EGetBadRecordField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t\_e1} has the structure of an exception or record type with fields \texttt{fields};
  \item \texttt{t\_e2} has the structure of an exception or record type with fields \texttt{fields};
  \item \texttt{t\_e2} is an Exception or a Record type with fields \texttt{fields};
  \item \texttt{field\_name} is not declared in \texttt{fields};
  \item an error ``\texttt{Bad Field}'' is raised.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EGetBadRecordFieldBegin, lastline=\EGetBadRecordFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadBitField \label{sec:TypingRule.EGetBadBitField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1} has the structure a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{t\_e2} has the structure a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{field\_name} is not declared in \texttt{bitfields};
  \item an error ``\texttt{Bad Field}'' is raised.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EGetBadBitFieldBegin, lastline=\EGetBadBitFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadField \label{sec:TypingRule.EGetBadField}}

 \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
   \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
   \item \texttt{t\_e1} does not have the structure of a record or an exception or a bitvector type;
   \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

 \subsection{Example}

 \subsection{Code}
    \VerbatimInput[firstline=\EGetBadFieldBegin, lastline=\EGetBadFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitField \label{sec:TypingRule.EGetBitField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t\_e1} has the structure of a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{t\_e2} has the structure of a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{field\_name} is declared in \texttt{bitfields};
  \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field\_name}
    in \texttt{bitfields};
  \item \texttt{e3} denotes the slicing of the expression \texttt{e2} by the slices \texttt{slices};
  \item \texttt{t,new\_env} is the result of annotating \texttt{e3}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EGetBitFieldBegin, lastline=\EGetBitFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldNested \label{sec:TypingRule.EGetBitFieldNested}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t\_e1} has the structure of a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{t\_e2} has the structure of a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{field\_name} is declared in \texttt{bitfields};
  \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field\_name} in
    \texttt{bitfields};
  \item \texttt{e3} denotes the slicing of the expression \texttt{e2} by the slices \texttt{slices};
  \item \texttt{t4, e4} is the result of annotating \texttt{e3} in \texttt{env};
  \item \texttt{bitfields'} gives the bitfields corresponding to the bitfield \texttt{field\_name}
    in \texttt{bitfields};
  \item \texttt{t} is the bitvector type with the width of \texttt{t4} and the bitfields \texttt{bitfields'}
  \item \texttt{new\_env} is \texttt{e4}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EGetBitFieldNestedBegin, lastline=\EGetBitFieldNestedEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldTyped \label{sec:TypingRule.EGetBitFieldTyped}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes \texttt{e1, field\_name};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t\_e1} has the structure of a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{t\_e2} has the structure of a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{field\_name} is declared in \texttt{bitfields};
  \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field\_name} in
    \texttt{bitfields};
  \item \texttt{t\_e3,e3} is the result of annotating \texttt{e2,slices} in \texttt{env};
  \item \texttt{t} gives the type corresponding to the bitfield \texttt{field\_name} in \texttt{bitfields};
  \item \texttt{t\_e3} type-satisfies \texttt{t} in \texttt{env};
  \item \texttt{new\_env} is \texttt{e3}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EGetBitFieldTypedBegin, lastline=\EGetBitFieldTypedEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EConcatEmpty \label{sec:TypingRule.EConcatEmpty}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the empty concatenation;
  \item \texttt{t} is \texttt{bits(0)};
  \item \texttt{new\_env} is \texttt{e}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EConcatEmptyBegin, lastline=\EConcatEmptyEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EConcat \label{sec:TypingRule.EConcat}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the concatenation of a non-empty list of expressions \texttt{li};
  \item \texttt{ts, es} is the result of annotating \texttt{li} in \texttt{env};
  \item all elements of \texttt{ts} have the structure of a bitvector type;
  \item \texttt{w} is the sum of the widths of the bitvector types \texttt{ts};
  \item \texttt{t} is \texttt{bits(w)};
  \item \texttt{new\_env} is \texttt{es}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EConcatBegin, lastline=\EConcatEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This aims to encompass LRM Section 7.8 R\_NYNK and R\_KCZS.

  The sum of the widths of the bitvector types~\texttt{ts} might be a symbolic
expression that is unresolvable to an integer. For example:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.EConcatUnresolvableToInteger.asl}


\section{TypingRule.ETuple \label{sec:TypingRule.ETuple}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a tuple \texttt{li};
  \item \texttt{ts, es} is the result of annotating in \texttt{env} each expression in \texttt{li};
  \item \texttt{t} is \texttt{ts};
  \item \texttt{new\_env} is \texttt{es}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\ETupleBegin, lastline=\ETupleEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EUnknown \label{sec:TypingRule.EUnknown}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes an expression \texttt{UNKNOWN} of type \texttt{ty};
  \item \texttt{ty'} is the structure of \texttt{ty} in \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_env} is an expression \texttt{UNKNOWN} of type \texttt{ty'}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EUnknownBegin, lastline=\EUnknownEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EPattern \label{sec:TypingRule.EPattern}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes whether the expression \texttt{e'} matches \texttt{patterns};
  \item \texttt{t\_e', e''} is the result of annotating \texttt{e'} in \texttt{env};
  \item \texttt{patterns'} is the result of annotating \texttt{patterns, t\_e'} in \texttt{env};
  \item \texttt{t} is \texttt{boolean};
  \item \texttt{new\_env} denotes whether the expression \texttt{e''} matches \texttt{patterns'}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\EPatternBegin, lastline=\EPatternEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.CTC \label{sec:TypingRule.CTC}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes an expression \texttt{e'} and a type \texttt{t'};
  \item \texttt{t'',new\_env} is the result of annotating \texttt{e'} in \texttt{env};
  \item One of the following applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t''} is a structural subtype of \texttt{t} in \texttt{env};
      \item \texttt{t''} is a domain subtype of \texttt{t} in \texttt{env};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t''} is a structural subtype of \texttt{t'} in \texttt{env};
      \item \texttt{t''} is not a domain subtype of \texttt{t'} in \texttt{env};
      \item an execution-time check that the expression evaluates to a value in the
        domain of the required type is required.
      \end{itemize}
   \item All of the following apply:
     \begin{itemize}
     \item \texttt{t''} is not a structural subtype of \texttt{t'} in \texttt{env};
     \item a ``\texttt{ConflictingTypes}'' error is raised.
     \end{itemize}
   \end{itemize}
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\CTCBegin, lastline=\CTCEnd]{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}


\chapter{Typing of Left-Hand-Side Expressions}
Annotating~\texttt{le} in an environment~\texttt{env}, assuming \texttt{t\_e}
to be the type of the corresponding right-hand-side (\texttt{annotate\_lexpr
version env le t\_e}), results in \texttt{new\_le} and one of the following
applies:
\begin{itemize}
\item TypingRule.LEDiscard (see Section~\ref{sec:TypingRule.LEDiscard}),
\item TypingRule.LELocalVar (see Section~\ref{sec:TypingRule.LELocalVar}),
\item TypingRule.LEGlobalVar (see Section~\ref{sec:TypingRule.LEGlobalVar}),
\item TypingRule.LEDestructuring (see Section~\ref{sec:TypingRule.LEDestructuring}),
\item TypingRule.LESlice (see Section~\ref{sec:TypingRule.LESlice}),
\item TypingRule.LESetArray (see Section~\ref{sec:TypingRule.LESetArray}),
\item TypingRule.LESetBadStructuredField (see Section~\ref{sec:TypingRule.LESetBadStructuredField}),
\item TypingRule.LESetStructuredField (see Section~\ref{sec:TypingRule.LESetStructuredField}),
\item TypingRule.LESetBadBitField (see Section~\ref{sec:TypingRule.LESetBadBitField}),
\item TypingRule.LESetBitField (see Section~\ref{sec:TypingRule.LESetBitField}),
\item TypingRule.LESetBitFieldNested (see Section~\ref{sec:TypingRule.LESetBitFieldNested}),
\item TypingRule.LESetBitFieldTyped (see Section~\ref{sec:TypingRule.LESetBitFieldTyped}),
\item TypingRule.LESetBadField (see Section~\ref{sec:TypingRule.LESetBadField}),
\item TypingRule.LEConcat (see Section~\ref{sec:TypingRule.LEConcat}).
\end{itemize}

\section{TypingRule.LEDiscard \label{sec:TypingRule.LEDiscard}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes an expression which can be discarded;
   \item \texttt{new\_le} is \texttt{le}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LEDiscardBegin, lastline=\LEDiscardEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LELocalVar \label{sec:TypingRule.LELocalVar}}

   \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes a local variable \texttt{x};
   \item \texttt{x} is locally declared as a variable of type \texttt{ty} in \texttt{env};
   \item \texttt{t\_e} can be assigned to \texttt{ty};
   \item \texttt{new\_le} is \texttt{le}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LELocalVarBegin, lastline=\LELocalVarEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LEGlobalVar \label{sec:TypingRule.LEGlobalVar}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes a local variable \texttt{x};
   \item \texttt{x} is globally declared as a variable of type \texttt{ty} in \texttt{env};
   \item \texttt{t\_e} can be assigned to \texttt{ty};
   \item \texttt{new\_le} is \texttt{le}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LEGlobalVarBegin, lastline=\LEGlobalVarEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LEDestructuring \label{sec:TypingRule.LEDestructuring}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes a tuple \texttt{les};
   \item \texttt{t\_e} has the structure of a tuple type \texttt{sub\_tys};
   \item the elements of \texttt{sub\_tys} can be assigned to the type of the elements of \texttt{les};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{les} and \texttt{sub\_tys} have the same length;
       \item \texttt{new\_le} is the result of annotating \texttt{les} with \texttt{sub\_tys} in \texttt{env}
       \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{les} and \texttt{sub\_tys} do not have the same length;
       \item an error ``\texttt{Bad Arity LEDestructuring}'' is raised.
       \end{itemize}
     \end{itemize}
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LEDestructuringBegin, lastline=\LEDestructuringEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESlice \label{sec:TypingRule.LESlice}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the slicing of a left-hand-side expression \texttt{le1} by the slices \texttt{slices};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector type;
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{width} is the width of the slices \texttt{slices} in \texttt{env};
   \item \texttt{t} is the bitvector type of width \texttt{width};
   \item \texttt{te} can be assigned to \texttt{t};
   \item \texttt{slices2} is the result of annotating \texttt{slices} in \texttt{env};
   \item \texttt{new\_le} is the slicing of \texttt{le2} by \texttt{slices2}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LESliceBegin, lastline=\LESliceEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetArray \label{sec:TypingRule.LESetArray}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the slicing of a left-hand-side expression \texttt{le1} by the slices \texttt{slices};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of an array type of size \texttt{size} and item type \texttt{t};
   \item \texttt{te} can be assigned to \texttt{t};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item One of the following applies:
     \begin{itemize}
     \item \texttt{wanted\_t\_index} is an enumeration type of name \texttt{size};
     \item \texttt{wanted\_t\_index} is the type \texttt{integer {0..size-1}};
     \end{itemize}
   \item \texttt{slices} is a single expression \texttt{e\_index};
   \item \texttt{t\_index', e\_index'} is the result of annotating \texttt{e\_index} in \texttt{env};
   \item \texttt{wanted\_t\_index} can be assigned to \texttt{t\_index'};
   \item \texttt{new\_le} is an access to array \texttt{le2} at index \texttt{e\_index'}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LESetArrayBegin, lastline=\LESetArrayEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadStructuredField \label{sec:TypingRule.LESetBadStructuredField}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of an exception or a record type with fields \texttt{fields};
   \item \texttt{field} is not declared in \texttt{fields};
   \item an error ``\texttt{Bad Field}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LESetBadStructuredFieldBegin, lastline=\LESetBadStructuredFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetStructuredField \label{sec:TypingRule.LESetStructuredField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of an exception or a record type with fields \texttt{fields};
   \item \texttt{field} is bound to type \texttt{t} in \texttt{fields};
   \item \texttt{t} can be assigned to \texttt{t\_e};
   \item \texttt{new\_le} is the access to the field \texttt{field} in \texttt{le2}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LESetStructuredFieldBegin, lastline=\LESetStructuredFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadBitField \label{sec:TypingRule.LESetBadBitField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields \texttt{bitfields};
   \item \texttt{field} is not declared in \texttt{bitfields};
   \item an error ``\texttt{Bad Field}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LESetBadBitFieldBegin, lastline=\LESetBadBitFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitField \label{sec:TypingRule.LESetBitField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields \texttt{bitfields};
   \item \texttt{field} is declared in \texttt{bitfields};
   \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field} in
      \texttt{bitfields};
   \item \texttt{w} is the width of \texttt{slices};
   \item \texttt{t} is the bitvector type of width \texttt{w};
   \item \texttt{t} can be assigned to \texttt{t\_e};
   \item \texttt{le2} is the slicing of \texttt{le1} by \texttt{slices};
   \item \texttt{new\_le} is the result of annotating \texttt{le2} in \texttt{env}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LESetBitFieldBegin, lastline=\LESetBitFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldNested \label{sec:TypingRule.LESetBitFieldNested}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields \texttt{bitfields};
   \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field} in
      \texttt{bitfields};
   \item \texttt{w} is the width of \texttt{slices};
   \item \texttt{bitfields'} gives the bitfields corresponding to \texttt{field} in \texttt{bitfields};
   \item \texttt{t} is the bitvector type of width \texttt{w} and bitfields \texttt{bitfields'};
   \item \texttt{t} can be assigned to \texttt{t\_e};
   \item \texttt{le2} is the slicing of \texttt{le1} by \texttt{slices};
   \item \texttt{new\_le} is the result of annotating \texttt{le2} in \texttt{env}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LESetBitFieldNestedBegin, lastline=\LESetBitFieldNestedEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldTyped \label{sec:TypingRule.LESetBitFieldTyped}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields \texttt{bitfields};
   \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field} in
      \texttt{bitfields};
   \item \texttt{w} is the width of \texttt{slices};
   \item \texttt{t'} is the bitvector type of width \texttt{w};
   \item \texttt{t} gives the type corresponding to the bitfield \texttt{field} in
      \texttt{bitfields};
   \item \texttt{t} can be assigned to \texttt{t'};
   \item \texttt{t} can be assigned to \texttt{t\_e};
   \item \texttt{le2} is the slicing of \texttt{le1} by \texttt{slices};
   \item \texttt{new\_le} is the result of annotating \texttt{le2} in \texttt{env}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LESetBitFieldTypedBegin, lastline=\LESetBitFieldTypedEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadField \label{sec:TypingRule.LESetBadField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} does not have the structure of a record, or an exception or a bitvector type;
   \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LESetBadFieldBegin, lastline=\LESetBadFieldEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LEConcat \label{sec:TypingRule.LEConcat}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LEConcatBegin, lastline=\LEConcatEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}


\chapter{Typing of Slices}
Annotating slices~\texttt{slices} in an environment~\texttt{env}
(\texttt{annotate\_slices env slices}) results in the pair \texttt{(offset,
length)} and one of the following applies:
\begin{itemize}
\item TypingRule.SliceSingle (see Section~\ref{sec:TypingRule.SliceSingle}),
\item TypingRule.SliceLength (see Section~\ref{sec:TypingRule.SliceLength}),
\item TypingRule.SliceRange (see Section~\ref{sec:TypingRule.SliceRange}),
\item TypingRule.SliceStar (see Section~\ref{sec:TypingRule.SliceStar}).
\end{itemize}

\section{TypingRule.SliceSingle \label{sec:TypingRule.SliceSingle}}

  \subsection{Prose}
   Annotating slices~\texttt{slices} in an environment~\texttt{env}
(\texttt{annotate\_slices env slices}) results in the pair \texttt{(offset,
length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slices} gives an index \texttt{i};
   \item \texttt{(offset, length)} is the result of applying TypingRule.SliceLength to \texttt{i, i+:1}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SliceSingleBegin, lastline=\SliceSingleEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    R\_GXKG: The notation b\texttt{i} is syntactic sugar for b\texttt{i +: 1}.

\section{TypingRule.SliceLength \label{sec:TypingRule.SliceLength}}

  \subsection{Prose}
   Annotating slices~\texttt{slices} in an environment~\texttt{env}
(\texttt{annotate\_slices env slices}) results in the pair \texttt{(offset,
length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slices} gives \texttt{offset} and \texttt{length};
   \item \texttt{t\_offset, offset'} is the result of annotating \texttt{offset} in \texttt{env};
   \item \texttt{t\_length, length'} is the result of annotating \texttt{length} in \texttt{env};
   \item \texttt{t\_offset} has the structure of an integer type;
   \item \texttt{t\_length} has the structure of an integer type;
   \item \texttt{length} is statically evaluable.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SliceLengthBegin, lastline=\SliceLengthEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SliceRange \label{sec:TypingRule.SliceRange}}

  \subsection{Prose}
      Annotating slices~\texttt{slices} in an environment~\texttt{env}
(\texttt{annotate\_slices env slices}) results in the pair \texttt{(offset,
length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slices} gives a range \texttt{(j, i)};
   \item \texttt{pre\_length} is \texttt{i +: j-i+1};
   \item \texttt{offset, length} is the result of applying TypingRule.SliceLength to \texttt{i,pre\_length}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SliceRangeBegin, lastline=\SliceRangeEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    R\_GXKG: The notation b\texttt{j:i} is syntactic sugar for b\texttt{i +: j-i+1}.

\section{TypingRule.SliceStar \label{sec:TypingRule.SliceStar}}

  \subsection{Prose}
      Annotating slices~\texttt{slices} in an environment~\texttt{env}
(\texttt{annotate\_slices env slices}) results in the pair \texttt{(offset,
length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slices} gives \texttt{(factor, pre\_length)};
   \item \texttt{pre\_offset} is \texttt{factor * pre\_length};
   \item \texttt{offset, length} is the result of applying TypingRule.SliceLength to \texttt{(pre\_offset, pre\_length)}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SliceStarBegin, lastline=\SliceStarEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    R\_GXQG: The notation b\texttt{i *: n} is syntactic sugar for b\texttt{i*n +: n}

\chapter{Typing of Patterns}
Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and one of the following applies:
\begin{itemize}
\item TypingRule.PAll (see Section~\ref{sec:TypingRule.PAll}),
\item TypingRule.PAny (see Section~\ref{sec:TypingRule.PAny}),
\item TypingRule.PGeq (see Section~\ref{sec:TypingRule.PGeq}),
\item TypingRule.PLeq (see Section~\ref{sec:TypingRule.PLeq}),
\item TypingRule.PNot (see Section~\ref{sec:TypingRule.PNot}),
\item TypingRule.PRange (see Section~\ref{sec:TypingRule.PRange}),
\item TypingRule.PSingle (see Section~\ref{sec:TypingRule.PSingle}),
\item TypingRule.PMask (see Section~\ref{sec:TypingRule.PMask}),
\item TypingRule.PTupleBadArity (see Section~\ref{sec:TypingRule.PTupleBadArity}),
\item TypingRule.PTuple (see Section~\ref{sec:TypingRule.PTuple}),
\item TypingRule.PTupleConflict (see Section~\ref{sec:TypingRule.PTupleConflict}),
\end{itemize}

\section{TypingRule.PAll \label{sec:TypingRule.PAll}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern matching everything;
   \item \texttt{new\_p} is \texttt{p}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PAllBegin, lastline=\PAllEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PAny\label{sec:TypingRule.PAny}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything in a list \texttt{li};
   \item \texttt{new\_li} is the result of mapping the result of annotating \texttt{p} in \texttt{env} onto \texttt{li};
   \item \texttt{new\_p} is the pattern which matches anything in \texttt{new\_li}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PAnyBegin, lastline=\PAnyEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PGeq \label{sec:TypingRule.PGeq}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything greater than or equal to an expression \texttt{e};
   \item \texttt{t\_e, e'} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{e'} is a compile-time constant expression;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t} and \texttt{t\_e} have the structure of an integer;
           \item \texttt{new\_p} is the pattern which matches anything greater than or equal to \texttt{e'}.
           \end{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t} and \texttt{t\_e} have the structure of a real;
           \item \texttt{new\_p} is the pattern which matches anything greater than or equal to \texttt{e'}.
           \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PGeqBegin, lastline=\PGeqEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

 \section{TypingRule.PLeq \label{sec:TypingRule.PLeq}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything lesser than or equal to an expression \texttt{e};
   \item \texttt{t\_e, e'} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{e'} is a compile-time constant expression;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t} and \texttt{t\_e} have the structure of an integer;
           \item \texttt{new\_p} is the pattern which matches anything lesser than or equal to \texttt{e'}.
           \end{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t} and \texttt{t\_e} have the structure of a real;
           \item \texttt{new\_p} is the pattern which matches anything lesser than or equal to \texttt{e'}.
           \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PLeqBegin, lastline=\PLeqEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PNot \label{sec:TypingRule.PNot}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches the negation of a pattern \texttt{q};
   \item \texttt{new\_q} is the result of annotating \texttt{q} in \texttt{env};
   \item \texttt{new\_p} is pattern which matches the negation of \texttt{new\_q}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PNotBegin, lastline=\PNotEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PRange \label{sec:TypingRule.PRange}}

    \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything within the range given by
      expressions \texttt{e1} and \texttt{e2};
   \item \texttt{t\_e1, e1'} is the result of annotating \texttt{e1} in \texttt{env};
   \item \texttt{t\_e2, e2'} is the result of annotating \texttt{e2} in \texttt{env};
   \item e1' and e2' are compile-time constant expressions;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t\_e1} and \texttt{t\_e2} have the structure of an integer;
           \item \texttt{new\_p} is the pattern which matches anything within the range given by
      expressions \texttt{e1'} and \texttt{e2'}.
           \end{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t\_e1} and \texttt{t\_e2} have the structure of a real;
           \item \texttt{new\_p} is the pattern which matches anything within the range given by
      expressions \texttt{e1'} and \texttt{e2'}.
           \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PRangeBegin, lastline=\PRangeEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PSingle \label{sec:TypingRule.PSingle}}

    \subsection{Prose}
      Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
      \begin{itemize}
        \item \texttt{p} is the pattern that matches the expression \texttt{e};
        \item \texttt{t\_e, e'} is the result of annotating the expression \texttt{e} in \texttt{env};
        \item One of the following applies:
          \begin{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of the real type;
                \item \texttt{t} has the structure of the real type;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of the boolean type;
                \item \texttt{t} has the structure of the boolean type;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of an integer type;
                \item \texttt{t} has the structure of an integer type;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of a bitvector type;
                \item \texttt{t} has the structure of a bitvector type;
                \item the bitvector types \texttt{t\_e} and \texttt{t} have the same length;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of an enumeration type;
                \item \texttt{t} has the structure of an enumeration type;
                \item the enumeration types \texttt{t\_e} and \texttt{t} have the same literals;
              \end{itemize}
          \end{itemize}
        \item \texttt{new\_p} is \texttt{p};
      \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PSingleBegin, lastline=\PSingleEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PMask \label{sec:TypingRule.PMask}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a mask \texttt{m};
   \item \texttt{t} has the structure of a bitvector type;
   \item \texttt{n} is the length of mask \texttt{m};
   \item \texttt{t\_m} is the bitvector type of width \texttt{n};
   \item One of the following applies:
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t} type-satisfies \texttt{t\_m};
       \item \texttt{new\_p} is \texttt{p}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PMaskBegin, lastline=\PMaskEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PTupleBadArity \label{sec:TypingRule.PTupleBadArity}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a tuple \texttt{li};
   \item \texttt{t} has the type structure of a tuple type \texttt{ts};
   \item \texttt{ts} is a list of different size to the size of \texttt{li};
   \item an error ``\texttt{Bad Arity}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PTupleBadArityBegin, lastline=\PTupleBadArityEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.PTuple \label{sec:TypingRule.PTuple}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a tuple \texttt{li};
   \item \texttt{t} has the type structure of a tuple type \texttt{ts};
   \item \texttt{ts} is a list of the same size as \texttt{li};
   \item \texttt{new\_li} is the result of annotating \texttt{li} with \texttt{ts};
   \item \texttt{new\_p} is the pattern which matches the tuple \texttt{new\_li}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PTupleBegin, lastline=\PTupleEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.PTupleConflict \label{sec:TypingRule.PTupleConflict}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a tuple \texttt{li};
   \item \texttt{t} has the type structure of a tuple type \texttt{ts};
   \item \texttt{t\_struct} is not a tuple type;
   \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\PTupleConflictBegin, lastline=\PTupleConflictEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Typing of Local Declarations}
Annotating a local declaration~\texttt{ldi}, given a type~\texttt{ty}, in an
environment~\texttt{env} results in \texttt{new\_env, new\_ldi}
(\texttt{annotate\_local\_decl\_item}) and one of the following applies:
\begin{itemize}
\item TypingRule.LDDiscardNone (see Section~\ref{sec:TypingRule.LDDiscardNone}),
\item TypingRule.LDDiscardSome (see Section~\ref{sec:TypingRule.LDDiscardSome}),
\item TypingRule.LDVar (see Section~\ref{sec:TypingRule.LDVar}),
\item TypingRule.LDTuple (see Section~\ref{sec:TypingRule.LDTuple}).
\end{itemize}

This aims to encompass LRM Section 7.4.2 R\_YSPM.

\section{TypingRule.LDDiscardNone \label{sec:TypingRule.LDDiscardNone}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi}, given a type~\texttt{ty}, in
an environment~\texttt{env} results in \texttt{new\_env, new\_ldi} and all of
the following apply:
   \begin{itemize}
   \item \texttt{ldi} is a local declaration which can be discarded;
   \item \texttt{ldi} does not specify a type;
   \item \texttt{new\_env} is \texttt{env};
   \item \texttt{new\_ldi} is \texttt{ldi}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LDDiscardNoneBegin, lastline=\LDDiscardNoneEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LDDiscardSome \label{sec:TypingRule.LDDiscardSome}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi}, given a type~\texttt{ty}, in
an environment~\texttt{env} results in \texttt{new\_env, new\_ldi} and all of
the following apply:
   \begin{itemize}
   \item \texttt{ldi} is a local declaration which can be discarded;
   \item \texttt{ldi} specifies a type \texttt{t};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t} can be initialised with \texttt{ty} in \texttt{env};
       \item \texttt{new\_env} is \texttt{env};
       \item \texttt{new\_ldi} is \texttt{ldi}.
       \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t} cannot be initialised with \texttt{ty} in \texttt{env};
       \item an error ``\texttt{Conflicting Types}'' is raised.
       \end{itemize}
     \end{itemize}
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LDDiscardSomeBegin, lastline=\LDDiscardSomeEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LDVar \label{sec:TypingRule.LDVar}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi}, given a type~\texttt{ty}, in
an environment~\texttt{env} results in \texttt{new\_env, new\_ldi} and all of
the following apply:
   \begin{itemize}
   \item \texttt{ldi} denotes a variable \texttt{x} with an optional type \texttt{ty\_opt};
   \item \texttt{x} is not declared in \texttt{env};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{ty\_opt} is \texttt{None};
       \item \texttt{t} is \texttt{ty}
       \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{ty\_opt} is \texttt{Some t};
       \item \texttt{t} can be initialized with \texttt{ty} in \texttt{env};
       \end{itemize}
     \end{itemize}
   \item \texttt{new\_env} is \texttt{env} modified so that \texttt{x} is locally declared of type \texttt{t};
   \item \texttt{new\_ldi} is the declaration of variable \texttt{x} with type \texttt{t}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LDVarBegin, lastline=\LDVarEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LDTuple \label{sec:TypingRule.LDTuple}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi}, given a type~\texttt{ty}, in
an environment~\texttt{env} results in \texttt{new\_env, new\_ldi} and all of
the following apply:
  \begin{itemize}
  \item \texttt{ldi} denotes a list \texttt{ldis};
  \item \texttt{ldi} does not specify a type;
  \item \texttt{ty} has the structure of a tuple type of the same length as~\texttt{ldis};
  \item \texttt{new\_env} is \texttt{env} modified so that each element in \texttt{ldis} is annotated with the corresponding type in \texttt{ty};
  \item \texttt{new\_ldi} is \texttt{ldis} where each element is declared with
the corresponding type in ~\texttt{ty}.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\LDTupleBegin, lastline=\LDTupleEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Typing of Statements}
Annotating a statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and one of the following applies:
\begin{itemize}
\item TypingRule.SPass (see Section~\ref{sec:TypingRule.SPass}),
\item TypingRule.SAssign (see Section~\ref{sec:TypingRule.SAssign}),
\item TypingRule.SReturnNone (see Section~\ref{sec:TypingRule.SReturnNone}),
\item TypingRule.SReturnOne (see Section~\ref{sec:TypingRule.SReturnOne}),
\item TypingRule.SReturnSome (see Section~\ref{sec:TypingRule.SReturnSome}),
\item TypingRule.SSeq (see Section~\ref{sec:TypingRule.SSeq}),
\item TypingRule.SCall (see Section~\ref{sec:TypingRule.SCall}),
\item TypingRule.SCond (see Section~\ref{sec:TypingRule.SCond}),
\item TypingRule.SCase (see Section~\ref{sec:TypingRule.SCase}),
\item TypingRule.SAssert (see Section~\ref{sec:TypingRule.SAssert}),
\item TypingRule.SWhile (see Section~\ref{sec:TypingRule.SWhile}),
\item TypingRule.SRepeat (see Section~\ref{sec:TypingRule.SRepeat}),
\item TypingRule.SFor (see Section~\ref{sec:TypingRule.SFor}),
\item TypingRule.SThrowNone (see Section~\ref{sec:TypingRule.SThrowNone}),
\item TypingRule.SThrowSome (see Section~\ref{sec:TypingRule.SThrowSome}),
\item TypingRule.STry (see Section~\ref{sec:TypingRule.STry}).
\item TypingRule.SDeclSome (see Section~\ref{sec:TypingRule.SDeclSome}),
\item TypingRule.SDeclNone (see Section~\ref{sec:TypingRule.SDeclNone}),
\end{itemize}

\section{TypingRule.SPass \label{sec:TypingRule.SPass}}

    \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a pass statement;
    \item \texttt{new\_s} is \texttt{s};
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

    \subsection{Example}

    \subsection{Code}
    \VerbatimInput[firstline=\SPassBegin, lastline=\SPassEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SAssign \label{sec:TypingRule.SAssign}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is an assignment \texttt{le = re} under language version \texttt{ver};
   \item \texttt{t\_e, e1} is the result of annotating \texttt{re} in \texttt{env};
   \item \texttt{reduced} is the result of inlining a setter call in \texttt{le};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{reduced} gives a statement \texttt{s};
       \item \texttt{new\_s} is \texttt{s};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}

     \item All of the following apply:
       \begin{itemize}
       \item \texttt{reduced} does not give a statement \texttt{s};
       \item One of the following applies:
         \begin{itemize}
         \item All of the following apply:
           \begin{itemize}
           \item \texttt{ver} is ASLv1;
           \item \texttt{env1} is \texttt{env};
           \end{itemize}
         \item All of the following apply:
           \begin{itemize}
           \item \texttt{ver} is ASLv0;
	   \item \texttt{env1} is the result of annotating undeclared variables by using
	      the first assignments to such variables as declarations;
           \end{itemize}
         \end{itemize}

       \item \texttt{le1} is the result of annotating \texttt{le} with \texttt{t\_e} in \texttt{env1};
       \item \texttt{new\_s} is the assignment \texttt{le1 = e1};
       \item \texttt{new\_env} is \texttt{env1}.
       \end{itemize}
    \end{itemize}
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\SAssignBegin, lastline=\SAssignEnd]{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SReturnNone \label{sec:TypingRule.SReturnNone}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{return} statement with no value and no return type;
   \item \texttt{new\_s} is a \texttt{return} statement with no value;
   \item the enclosing subprogram does not have a \texttt{return} type (it is either a setter
      or a procedure);
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SReturnNoneBegin, lastline=\SReturnNoneEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_FTPK.


\section{TypingRule.SReturnOne \label{sec:TypingRule.SReturnOne}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{s} is a \texttt{return} statement with some value;
       \item the enclosing subprogram does not have a return type;
       \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{s} is a \texttt{return} statement with no value;
       \item the enclosing subprogram has a \texttt{return} type;
       \end{itemize}
     \end{itemize}
   \item an error ``\texttt{Bad Return Statement}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SReturnOneBegin, lastline=\SReturnOneEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_FTPK.

\section{TypingRule.SReturnSome \label{sec:TypingRule.SReturnSome}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{return} statement with some value \texttt{e};
   \item the enclosing subprogram has a return type \texttt{t};
   \item \texttt{t\_e',e'} is the result of annotating \texttt{e} in \texttt{env};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t\_e'} type-satisfies \texttt{t};
       \item \texttt{new\_s} is a \texttt{return} statement with value \texttt{e'};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SReturnSomeBegin, lastline=\SReturnSomeEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SSeq \label{sec:TypingRule.SSeq}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a statement \texttt{s1; s2};
   \item \texttt{new\_s1, env1} is the result of annotating \texttt{s1} in \texttt{env};
   \item \texttt{new\_s2, env2} is the result of annotating \texttt{s2} in \texttt{env1};
   \item \texttt{new\_s} is a then statement over two statements \texttt{new\_s1} and \texttt{new\_s2};
   \item \texttt{new\_env} is \texttt{env2}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SSeqBegin, lastline=\SSeqEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SCall \label{sec:TypingRule.SCall}}

    \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a call to a subprogram named \texttt{name} with arguments \texttt{args} and parameters \texttt{eqs};
   \item \texttt{new\_name, new\_args, new\_eqs} is the result of annotating the call
      to the procedure \texttt{name} with arguments \texttt{args} and parameters
\texttt{eqs};
   \item \texttt{new\_s} is the call to a subprogram named \texttt{new\_name} with arguments
      \texttt{new\_args} and parameters \texttt{new\_eqs};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SCallBegin, lastline=\SCallEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SCond \label{sec:TypingRule.SCond}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a condition \texttt{e} with two statements \texttt{s1} and \texttt{s2};
   \item \texttt{t\_cond, e\_cond} is the result of annotating \texttt{e} in \texttt{env};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t\_cond} type-satisfies \texttt{t\_bool};
       \item \texttt{s1'} is the result of annotating \texttt{s1} in \texttt{env};
       \item \texttt{s2'} is the result of annotating \texttt{s2} in \texttt{env};
       \item \texttt{new\_s} is the condition \texttt{e\_cond} with two statements \texttt{s1'} and \texttt{s2'};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SCondBegin, lastline=\SCondEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_NBDJ.

\section{TypingRule.SCase \label{sec:TypingRule.SCase}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a case statement with expression \texttt{e} and cases \texttt{cases};
   \item \texttt{t\_e, e1} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{cases1, env1} is the result of annotating each case in \texttt{cases} given \texttt{t\_e};
   \item \texttt{new\_s} is a case statement with expression \texttt{e1} and cases \texttt{cases1};
   \item \texttt{new\_env} is \texttt{env1}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SCaseBegin, lastline=\SCaseEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_WGSY.

\section{TypingRule.SAssert \label{sec:TypingRule.SAssert}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is an assert statement with expression \texttt{e};
   \item \texttt{t\_e',e'} is the result of annotating \texttt{e} in \texttt{env};
   \item One of the following applies:
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t\_e'} type-satisfies \texttt{t\_bool};
       \item \texttt{new\_s} is an assert statement with expression \texttt{e'};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SAssertBegin, lastline=\SAssertEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_JQYF


\section{TypingRule.SWhile \label{sec:TypingRule.SWhile}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{while} statement with expression \texttt{e1} and statement block \texttt{s1};
   \item \texttt{t, e2} is the result of annotating \texttt{e1} in \texttt{env};
   \item One of the following applies:
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t} type-satisfies \texttt{t\_bool};
       \item \texttt{s2} is the result of annotating \texttt{s1} in \texttt{env};
       \item \texttt{new\_s} is a \texttt{while} statement with expression \texttt{e2} and statement block \texttt{s2};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SWhileBegin, lastline=\SWhileEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_FTVN.

\section{TypingRule.SRepeat \label{sec:TypingRule.SRepeat}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{repeat} statement with expression \texttt{e1} and statement block \texttt{s1};
   \item \texttt{s2} is the result of annotating \texttt{s1} in \texttt{env};
   \item \texttt{t, e2} is the result of annotating \texttt{e1} in \texttt{env};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t} type-satisfies \texttt{t\_bool};
       \item \texttt{new\_s} is a \texttt{repeat} statement with expression \texttt{e2} and statement block \texttt{s2};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SRepeatBegin, lastline=\SRepeatEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_FTVN.

\section{TypingRule.SFor \label{sec:TypingRule.SFor}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{for} statement with index \texttt{id}, direction \texttt{dir}, two expressions
      \texttt{e1} and \texttt{e2} and a statement block \texttt{s'};
   \item \texttt{t1,e1'} is the result of annotating \texttt{e1} in \texttt{env};
   \item \texttt{t2,e2'} is the result of annotating \texttt{e2} in \texttt{env};
   \item an error is raised: ``\texttt{ASL Typing Error : A subtype of integer was expected, t1 was provided}'' or \texttt{t1} has the structure of an integer type and all of the following apply:
   \item an error is raised: ``\texttt{ASL Typing Error : A subtype of integer was expected, t2 was provided}'' or \texttt{t2} has the structure of an integer type and all of the following apply:
   \item One of the following applies:
     \begin{itemize}
       \item All of the following applies:
         \begin{itemize}
           \item \texttt{t1} has the structure of an unconstrained integer type;
           \item \texttt{ty} is the unconstrained integer type;
         \end{itemize}
       \item All of the following applies:
         \begin{itemize}
           \item \texttt{t2} has the structure of an unconstrained integer type;
           \item \texttt{ty} is the unconstrained integer type;
         \end{itemize}
       \item All of the following applies:
         \begin{itemize}
           \item \texttt{t1} has the structure of a constrained integer type with constraint \texttt{cs1};
           \item \texttt{t2} has the structure of a constrained integer type with constraint \texttt{cs2};
           \item One of the following applies:
             \begin{itemize}
               \item All of the following applies:
                 \begin{itemize}
                   \item \texttt{dir} is \texttt{to};
                   \item \texttt{bot\_cs} is \texttt{cs1};
                   \item \texttt{top\_cs} is \texttt{cs2};
                 \end{itemize}
               \item All of the following applies:
                 \begin{itemize}
                   \item \texttt{dir} is \texttt{down to};
                   \item \texttt{bot\_cs} is \texttt{cs2};
                   \item \texttt{top\_cs} is \texttt{cs1};
                 \end{itemize}
             \end{itemize}
           \item One of the following applies:
             \begin{itemize}
               \item All of the following applies:
                 \begin{itemize}
                   \item \texttt{bot\_cs} contains a an expression that is not evaluable at compile-time;
                   \item \texttt{cs} is the empty constraint;
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{top\_cs} contains a an expression that is not evaluable at compile-time;
                   \item \texttt{cs} is the empty constraint;
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{bot} is the minimum of the constraints \texttt{bot\_cs};
                   \item \texttt{top} is the maximum of the constraints \texttt{top\_cs};
                   \item \texttt{bot} is less or equal than \texttt{top};
                   \item \texttt{cs} is the constraint \texttt{bot .. top};
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{bot} is the minimum of the constraints \texttt{bot\_cs};
                   \item \texttt{top} is the maximum of the constraints \texttt{top\_cs};
                   \item \texttt{top} is strictly less than \texttt{bot}
                   \item \texttt{cs} is \texttt{cs1};
                 \end{itemize}
             \end{itemize}
           \item \texttt{ty} is the constrained integer type with constraint \texttt{cs};
         \end{itemize}
     \end{itemize}
   \item an error is raised ``\texttt{ASL Typing Error: cannot declare already declared element “id”.}'' or \texttt{id} is not bound in \texttt{env} and all of the following apply:
   \item \texttt{env'} is \texttt{env} modified so that \texttt{id} is locally declared of type \texttt{ty};
   \item \texttt{s''} is the result of annotating \texttt{s'} in \texttt{env'};
   \item \texttt{new\_s} is a for statement with index \texttt{id}, direction \texttt{dir}, two expressions \texttt{e1'} and \texttt{e2'} and statement \texttt{s''};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SForBegin, lastline=\SForEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_VTJW.


\section{TypingRule.SThrowNone \label{sec:TypingRule.SThrowNone}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a throw statement with no expression;
   \item \texttt{new\_s} is \texttt{s};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SThrowNoneBegin, lastline=\SThrowNoneEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  Note that LRM R\_BRCJ is done in~\cite[SemanticsRule.TopLevel]{ASLSemanticsReference}.

\section{TypingRule.SThrowSome \label{sec:TypingRule.SThrowSome}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a throw statement with expression \texttt{e};
   \item \texttt{t\_e,e'} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{t\_e} has the structure of an exception type;
   \item \texttt{new\_s} is a throw statement with expression \texttt{e'} and type \texttt{t\_e};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SThrowSomeBegin, lastline=\SThrowSomeEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_NXRC.


\section{TypingRule.STry \label{sec:TypingRule.STry}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a try statement with statement \texttt{s'}, catchers \texttt{catchers} and block \texttt{otherwise};
   \item \texttt{s''} is the result of annotating \texttt{s'} in \texttt{env};
   \item \texttt{otherwise'} is the result of annotating \texttt{otherwise} in \texttt{env};
   \item \texttt{catchers'} is the result of annotating \texttt{catchers} in \texttt{env};
   \item \texttt{new\_s} is a try statement with statement \texttt{s''}, catchers \texttt{catchers'} and block \texttt{otherwise'};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\STryBegin, lastline=\STryEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_WVXS.

\section{TypingRule.SDeclSome \label{sec:TypingRule.SDeclSome}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a declaration with local identifiers \texttt{ldi} and an expression \texttt{e};
   \item \texttt{t\_e,e'} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{env', ldi'} is the result of declaring the local identifiers of \texttt{ldi} in \texttt{env};
   \item \texttt{new\_s} is a declaration with \texttt{ldk}, \texttt{ldi'} and an expression \texttt{e'};
   \item \texttt{new\_env} is \texttt{env'}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SDeclSomeBegin, lastline=\SDeclSomeEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SDeclNone \label{sec:TypingRule.SDeclNone}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a declaration statement with local identifiers \texttt{ldi} and no initial expression;
   \item \texttt{env', s'} is the result of annotating uninitialised local declarations \texttt{ldi} in \texttt{env};
   \item \texttt{new\_s} is \texttt{s'};
   \item \texttt{new\_env} is \texttt{env'}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SDeclNoneBegin, lastline=\SDeclNoneEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Typing of Blocks}

\section{TypingRule.Block \label{sec:TypingRule.Block}}

  \subsection{Prose}
    Annotating a block \texttt{s} in an environment \texttt{env}, given a type
\texttt{return\_type} (\texttt{annotate\_block env return\_type s}, is the
result of annotating the statement \texttt{s} in \texttt{env}.

  \subsection{Example: TypingRule.Block0.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.Block0.asl}

  \subsection{Code}
    \VerbatimInput[firstline=\BlockBegin, lastline=\BlockEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    A local identifier declared with var, let or constant is in scope
from the point immediately after its declaration until the end of the
immediately enclosing block.

    From that follows that we can discard the environment at the end of
an enclosing block.


\chapter{Typing of Catchers}
Annotating catchers \texttt{(name\_opt, ty, stmt)} in an environment
\texttt{env} given a type \texttt{return\_type} (\texttt{annotate\_catchers env
return\_type (name\_opt, ty, stmt)}) results in \texttt{(name\_opt, ty,
new\_stmt)} and one of the following applies:
\begin{itemize}
\item TypingRule.CatcherNone (see Section~\ref{sec:TypingRule.CatcherNone}),
\item TypingRule.CatcherSome (see Section~\ref{sec:TypingRule.CatcherSome}).
\end{itemize}

\section{TypingRule.CatcherNone \label{sec:TypingRule.CatcherNone}}

  \subsection{Prose}
   Annotating catchers \texttt{(name\_opt, ty, stmt)} in an environment
\texttt{env} given a type \texttt{return\_type} (\texttt{annotate\_catchers env
return\_type (name\_opt, ty, stmt)}) results in \texttt{(name\_opt, ty,
new\_stmt)} and all of the following apply:
   \begin{itemize}
   \item \texttt{ty} has the structure of an exception type;
   \item \texttt{name\_opt} gives no name;
   \item \texttt{env'} is \texttt{env};
   \item \texttt{new\_stmt} is the result of annotating \texttt{stmt} in \texttt{env'} with \texttt{return\_type}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\CatcherNoneBegin, lastline=\CatcherNoneEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_SDJK.

\section{TypingRule.CatcherSome \label{sec:TypingRule.CatcherSome}}

  \subsection{Prose}
   Annotating catchers \texttt{(name\_opt, ty, stmt)} in an environment
\texttt{env} given a type \texttt{return\_type} (\texttt{annotate\_catchers env
return\_type (name\_opt, ty, stmt)}) results in \texttt{(name\_opt, ty,
new\_stmt)} and all of the following apply:
   \begin{itemize}
   \item \texttt{ty} has the structure of an exception type;
   \item \texttt{name\_opt} gives a name \texttt{name};
   \item \texttt{name} is not already declared in \texttt{env};
   \item \texttt{name} has type \texttt{ty} in \texttt{env};
   \item \texttt{env'} is \texttt{env} modified to have \texttt{name} locally declared as immutable of type \texttt{ty};
   \item \texttt{new\_stmt} is the result of annotating \texttt{stmt} in \texttt{env'} with \texttt{return\_type}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\CatcherSomeBegin, lastline=\CatcherSomeEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This aims to encompass LRM Section 7.4.3 R\_SDJK.

\chapter{Typing of Subprogram Calls}

Annotating the call to subprogram \texttt{name} with arguments \texttt{args},
parameters \texttt{eqs}, and call type \texttt{call\_type} (\texttt{annotate\_call}) results in \texttt{(name1,
args, eqs2, ret\_ty1)} or an error is raised and one of the following applies:
\begin{itemize}
\item TypingRule.FCallBadArity (see Section~\ref{sec:TypingRule.FCallBadArity}),
\item TypingRule.FCallGetter (see Section~\ref{sec:TypingRule.FCallGetter}),
\item TypingRule.FCallSetter (see Section~\ref{sec:TypingRule.FCallSetter}),
\item TypingRule.FCallMismatch (see Section~\ref{sec:TypingRule.FCallMismatch}).
\end{itemize}

\section{TypingRule.FCallBadArity \label{sec:TypingRule.FCallBadArity}}

  \subsection{Prose}
  Annotating the call to subprogram \texttt{name} with arguments \texttt{args}
and parameters \texttt{eqs} (\texttt{annotate\_call}) results in
\texttt{(name1, args, eqs2, ret\_ty1)} or an error is raised and all of the
following apply:
   \begin{itemize}
   \item \texttt{name} is bound in \texttt{env} to a function with argument types \texttt{callee\_arg\_types};
   \item the lists \texttt{callee\_arg\_types} and \texttt{args} do not have the same length;
   \item an error ``\texttt{Bad Arity}'' is raised.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\FCallBadArityBegin, lastline=\FCallBadArityEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.FCallGetter \label{sec:TypingRule.FCallGetter}}

  \subsection{Prose}
  Annotating the call to subprogram \texttt{name} with arguments \texttt{args},
  parameters \texttt{eqs}, and call-type \texttt{call\_type}
  (\texttt{annotate\_call}) results in \texttt{(name1, args, eqs2, ret\_ty1)}
  or an error is raised and all of the following apply:
   \begin{itemize}
   \item \texttt{caller\_arg\_types, arg1} is the result of annotating \texttt{args} in \texttt{env};
   \item \texttt{name} is bound in \texttt{env} to a subprogram with argument types
      \texttt{callee\_arg\_types};
   \item \texttt{eqs2} is \texttt{eqs1} appended with the equations deduced by
     using the types of the actual arguments \texttt{caller\_arg\_types} to
     defined parameters in \texttt{callee\_arg\_types};
   \item \texttt{call\_type} is either a function or a getter type;
   \item \texttt{ret\_ty1} is the result of renaming \texttt{ty} in \texttt{eqs2}.
   \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\FCallGetterBegin, lastline=\FCallGetterEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.FCallSetter \label{sec:TypingRule.FCallSetter}}

  \subsection{Prose}
  Annotating the call to subprogram \texttt{name} with arguments \texttt{args},
  parameters \texttt{eqs}, and call-type \texttt{call\_type}
  (\texttt{annotate\_call}) results in \texttt{(name1, args, eqs2, ret\_ty1)}
  or an error is raised and all of the following apply:
  \begin{itemize}
    \item \texttt{caller\_arg\_types, arg1} is the result of annotating
      \texttt{args} in \texttt{env};
    \item \texttt{name} is bound in \texttt{env} to a subprogram with a unique
      name \texttt{name1} whose argument types \texttt{callee\_arg\_types}
      type-clash \texttt{caller\_arg\_types} and whose return type is
      \texttt{ret\_ty};
    \item \texttt{eqs1} is the list made of both \texttt{eqs} and
      \texttt{extra\_nargs};
    \item \texttt{eqs2} is \texttt{eqs1} appended with the equations deduced by
      using the types of the actual arguments \texttt{caller\_arg\_types} to
      defined parameters in \texttt{callee\_arg\_types};
    \item \texttt{call\_type} is a setter or procedure type;
    \item \texttt{ret\_ty} is None;
    \item \texttt{ret\_ty1} is None.
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\FCallSetterBegin, lastline=\FCallSetterEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.FCallMismatch \label{sec:TypingRule.FCallMismatch}}

  \subsection{Prose}
  Annotating the call to subprogram \texttt{name} with call type \texttt{call\_type} (\texttt{annotate\_call}) results in an error and
  one of the following apply:
  \begin{itemize}
    \item All of the following apply: \begin{itemize} \item \texttt{call\_type}
          is a function or a getter;
        \item \texttt{name} is bound in \texttt{env} a subprogram without a return-type;
        \item A ``Mismatched return value'' error is raised.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
        \item \texttt{call\_type} is a procedure or a setter;
        \item \texttt{name} is bound in \texttt{env} a subprogram with a return type;
        \item A ``Mismatched return value'' error is raised.
      \end{itemize}
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\FCallMismatchBegin, lastline=\FCallMismatchEnd]{../Typing.ml}

  \subsection{Formally}

  \subsection{Comments}

\chapter{Typing of Subprograms}
Annotating a subprogram \texttt{f} in an environment \texttt{env}
(\texttt{annotate\_func}) results in \texttt{f}, \texttt{new\_body} and
\texttt{name}.

\section{TypingRule.Subprogram \label{sec:TypingRule.Subprogram}}

  \subsection{Prose}
Annotating a subprogram \texttt{f} in an environment \texttt{env}
(\texttt{annotate\_func}) results in \texttt{f}, \texttt{new\_body} and all of
the following apply:
 \begin{itemize}
   \item \texttt{env1} is \texttt{env} modified to have an empty local
     environment and a return type given by \texttt{f};
   \item \texttt{env2} is \texttt{env1} with every formal argument given by
     \texttt{f} declared as immutable with its type;
   \item \texttt{env3} is \texttt{env2} modified to add explicit parameters
     given by \texttt{f};
   \item \texttt{env4} is \texttt{env3} modified to resolve dependently typed
     identifiers in the arguments given by \texttt{f};
   \item \texttt{env5} is \texttt{env4} modified to resolve dependently typed
     identifiers in the result type given by \texttt{f};
   \item \texttt{body} is the body given by \texttt{f};
   \item \texttt{new\_body} is the result of annotating \texttt{body} in
     \texttt{env5}.
 \end{itemize}

  \subsection{Example}

  \subsection{Code}
    \VerbatimInput[firstline=\SubprogramBegin, lastline=\SubprogramEnd]{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Side-effects}

Side-effects can arise due to:
\begin{itemize}
\item Reads and Writes to global variables;
\item Exceptions;
\item Calls to primitives.
\end{itemize}

\bibliographystyle{plain}
\bibliography{ASL}

\end{document}
