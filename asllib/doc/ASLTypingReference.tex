\documentclass{book}
\input{ASLmacros}
\input{ASLTypingLines}
\input{ASLTypeSatisfactionLines}
\input{ASLASTLines}
\newcommand{\tests}{../tests/ASLTypingReference.t/}

\newcommand\todocomment[1]{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\typingrulecasename[2]{TypingRule.{#1}.\textsc{#2}}

% The following macros will be moved to ASLmacros.tex when we unify all reference documents.
\newcommand\ReadEffect[0]{\textsf{ReadEffect}}
\newcommand\Normal[0]{\textsf{Normal}}
\newcommand\ThrowingConfig[0]{\texttt{\#T}}
\newcommand\OrAbnormal[0]{\terminateas \ThrowingConfig, \ErrorConfig}
\newcommand\vg[0]{\texttt{g}}
\newcommand\env[0]{\texttt{env}}
\newcommand\parallelcomp[0]{\parallel}
\newcommand\binoprel[0]{\texttt{binop}}
\newcommand\unoprel[0]{\texttt{unop}}
\newcommand\evalexprsef[1]{\hyperlink{def-evalexprsef}{\texttt{eval\_expr\_sef}}(#1)}
\newcommand\XGraphs[0]{\mathcal{G}}
\newcommand\TError[0]{\textsf{TDynError}}
\newcommand\ErrorConfig[0]{\hyperlink{def-errorconfig}{\texttt{\#DE}}}

\newcommand\dynamicdomain[0]{\hyperlink{def-dyndomain}{\textsf{dyn\_dom}}}

\newcommand\ProseOtherwiseTypeError[0]{Otherwise, the result is a type error.}
\newcommand\OrTypeError[0]{\;\terminateas \TypeErrorConfig}
%\newcommand\ProseOrTypeError[0]{or a type error that short-circuits the entire rule}
\newcommand\ProseOrTypeError[0]{\ProseTerminateAs{\TypeErrorConfig}}

\newcommand\annotaterel[0]{\hyperlink{def-annotaterel}{\textsf{type}}}
\newcommand\typearrow[0]{\xrightarrow{\annotaterel}}
\newcommand\isbuiltinsingular[0]{\hyperlink{def-isbuiltinsingular}{\texttt{is\_builtin\_singular}}}
\newcommand\isbuiltinaggregate[0]{\hyperlink{def-isbuiltinaggregate}{\texttt{is\_builtin\_aggregate}}}
\newcommand\isbuiltin[0]{\hyperlink{def-isbuiltin}{\texttt{is\_builtin}}}
\newcommand\isnamed[0]{\hyperlink{def-isnamed}{\texttt{is\_named}}}
\newcommand\isanonymous[0]{\hyperlink{def-isanonymous}{\texttt{is\_anonymous}}}
\newcommand\issingular[0]{\hyperlink{def-issingular}{\texttt{is\_singular}}}
\newcommand\isaggregate[0]{\hyperlink{def-isaggregate}{\texttt{is\_aggregate}}}
\newcommand\isstructured[0]{\hyperlink{def-isstructured}{\texttt{is\_structured}}}
\newcommand\isnonprimitive[0]{\hyperlink{def-isnonprimitive}{\texttt{is\_non\_primitive}}}
\newcommand\isprimitive[0]{\hyperlink{def-isprimitive}{\texttt{is\_primitive}}}

\newcommand\isunconstrainedinteger[0]{\hyperlink{def-isunconstrainedinteger}{\textsf{is\_unconstrained\_integer}}}
\newcommand\isparameterizedinteger[0]{\hyperlink{def-isparameterizedinteger}{\textsf{is\_parameterized\_integer}}}
\newcommand\iswellconstrainedinteger[0]{\hyperlink{def-iswellconstrainedinteger}{\textsf{is\_well\_constrained\_integer}}}
\newcommand\unconstrainedinteger[0]{\hyperlink{def-unconstrainedinteger}{\textsf{unconstrained\_integer}}}

\newcommand\checkconstrainedinteger[0]{\hyperlink{def-checkconstrainedinteger}{\texttt{check\_constrained\_integer}}}

\newcommand\staticeval[0]{\hyperlink{def-staticeval}{\texttt{static\_eval}}}
\newcommand\isstaticallyevaluable[0]{\texttt{check\_statically\_evaluable}}

\newcommand\makeanonymous[0]{\hyperlink{def-makeanonymous}{\texttt{make\_anonymous}}}
\newcommand\subtypesrel[0]{\hyperlink{def-subtypesrel}{\texttt{is\_subtype}}}
\newcommand\structsubtypesat[0]{\hyperlink{def-structsubtypesat}{\texttt{structural\_subtype\_satisfies}}}
\newcommand\domsubtypesat[0]{\hyperlink{def-domsubtypesat}{\texttt{domain\_subtype\_satisfies}}}
\newcommand\subtypesat[0]{\hyperlink{def-subtypesat}{\texttt{subtype\_satisfies}}}
\newcommand\checktypesat[0]{\hyperlink{def-checktypesat}{\texttt{checked\_typesat}}}
\newcommand\typeclashes[0]{\hyperlink{def-typeclashes}{\texttt{type\_clashes}}}
\newcommand\lca[0]{\hyperlink{def-lowestcommonancestor}{\texttt{lowest\_common\_ancestor}}}
\newcommand\namedlca[0]{\hyperlink{def-namedlowestcommonancestor}{\texttt{named\_lowest\_common\_ancestor}}}
\newcommand\Supers{\textsf{Supers}}
\newcommand\bitfieldsincluded[0]{\hyperlink{def-bitfieldsincluded}{\texttt{bitfields\_included}}}
\newcommand\membfs[0]{\hyperlink{def-membfs}{\texttt{mem\_bfs}}}
\newcommand\instantiate[0]{\texttt{instantiate}}
\newcommand\canbeinitializedwith[0]{\texttt{can\_be\_initialized\_with}}
\newcommand\getbitvectorwidth[0]{\hyperlink{def-getbitvectorwidth}{\texttt{get\_bitvector\_width}}}
\newcommand\checkbitsequalwidth[0]{\hyperlink{def-checkbitsequalwidth}{\texttt{check\_bits\_equal\_width}}}
\newcommand\findsubprogram[0]{\hyperlink{def-findsubprogram}{\texttt{find\_subprogram}}}
\newcommand\subprogramtypeclash[0]{\texttt{subprogram\_type\_clash}}
\newcommand\hassubprogramtypeclash[0]{\texttt{subprogram\_type\_clash}}
\newcommand\subprogramclash[0]{\hyperlink{def-subprogramclash}{\texttt{subprogram\_clash}}}
\newcommand\argsclash[0]{\texttt{args\_clash}}
\newcommand\bitfieldgetname[0]{\hyperlink{def-bitfieldgetname}{\texttt{bitfield\_get\_name}}}
\newcommand\pairstomap[0]{\hyperlink{def-pairstomap}{\texttt{pairs\_to\_map}}}
\newcommand\assocopt[0]{\hyperlink{def-assocopt}{\texttt{assoc\_opt}}}
\newcommand\annotatefieldinit[0]{\hyperlink{def-annotatefieldinit}{\texttt{annotate\_field\_init}}}
\newcommand\annotatestaticinteger[0]{\hyperlink{def-annotatestaticinteger}{\texttt{annotate\_static\_integer}}}
\newcommand\annotatestaticconstrainedinteger[0]{\hyperlink{def-annotatestaticconstrainedinteger}{\texttt{annotate\_static\_constrained\_integer}}}
\newcommand\checkatc[0]{\hyperlink{def-checkatc}{\texttt{check\_atc}}}
\newcommand\checkstructurelabel[0]{\hyperlink{def-checkstructurelabel}{\texttt{check\_structure}}}
\newcommand\checkstructureinteger[0]{\hyperlink{def-checkstructureinteger}{\texttt{check\_structure\_integer}}}
\newcommand\checkstaticallyevaluable[0]{\hyperlink{def-checkstaticallyevaluable}{\texttt{check\_statically\_evaluable}}}
\newcommand\storageispure[0]{\hyperlink{def-storageispure}{\texttt{storage\_is\_pure}}}
\newcommand\negateconstraint[0]{\hyperlink{def-negateconstraint}{\texttt{negate\_constraint}}}
\newcommand\getwellconstrainedstructure[0]{\hyperlink{def-getwellconstrainedstructure}{\texttt{get\_well\_constrained\_structure}}}
\newcommand\towellconstrained[0]{\hyperlink{def-towellconstrained}{\texttt{to\_well\_constrained}}}
\newcommand\annotatelebits[0]{\hyperlink{def-annotatelebits}{\texttt{annotate\_lebits}}}
\newcommand\annotatecase[1]{\hyperlink{def-annotatecase}{\texttt{annotate\_case}}(#1)}
\newcommand\getforconstraints[0]{\hyperlink{def-getforconstraints}{\texttt{for\_constraints}}}
\newcommand\findbitfieldopt[0]{\hyperlink{def-findbitfieldopt}{\texttt{find\_bitfield\_opt}}}
\newcommand\lookupconstant[0]{\hyperlink{def-lookupconstant}{\texttt{lookup\_constant}}}
\newcommand\typeof[0]{\hyperlink{def-typeof}{\texttt{type\_of}}}
\newcommand\typecheckdecl[0]{\hyperlink{def-typecheckdecl}{\texttt{typecheck\_decl}}}
\newcommand\annotateanddeclarefunc[0]{\hyperlink{def-annotateanddeclarefunc}{\texttt{annotate\_and\_declare\_func}}}
\newcommand\declareglobalstorage[0]{\hyperlink{def-declareglobalstorage}{\texttt{declare\_global\_storage}}}
\newcommand\annotatefuncsig[0]{\hyperlink{def-annotatefuncsig}{\texttt{annotate\_func\_sig}}}
\newcommand\declareonefunc[0]{\hyperlink{def-declareonefunc}{\texttt{declare\_one\_func}}}
\newcommand\checksetterhasgetter[0]{\hyperlink{def-checksetterhashgetter}{\texttt{check\_setter\_has\_getter}}}
\newcommand\addnewfunc[0]{\hyperlink{def-addnewfunc}{\texttt{add\_new\_func}}}
\newcommand\addsubprogram[0]{\hyperlink{def-addsubprogram}{\texttt{add\_subprogram}}}
\newcommand\isundefined[0]{\hyperlink{def-isundefined}{\texttt{is\_undedined}}}
\newcommand\scanforparams[0]{\hyperlink{def-scanforparams}{\texttt{scan\_for\_params}}}
\newcommand\annotateparams[0]{\hyperlink{def-annotateparams}{\texttt{annotate\_params}}}
\newcommand\annotateoneparam[0]{\hyperlink{def-annotateoneparam}{\texttt{annotate\_one\_param}}}
\newcommand\argsasparams[0]{\hyperlink{def-argsasparams}{\texttt{args\_as\_params}}}
\newcommand\argasparam[0]{\hyperlink{def-argasparam}{\texttt{arg\_as\_param}}}
\newcommand\annotatetypeopt[0]{\hyperlink{def-annotatetypeopt}{\texttt{annotate\_type\_opt}}}
\newcommand\annotateexpropt[0]{\hyperlink{def-annotateexpropt}{\texttt{annotate\_expr\_opt}}}
\newcommand\annotateinittype[0]{\hyperlink{def-annotateinittype}{\texttt{annotate\_init\_type}}}
\newcommand\addglobalstorage[0]{\hyperlink{def-addglobalstorage}{\texttt{add\_global\_storage}}}
\newcommand\annotateextrafields[0]{\hyperlink{def-annotateextrafields}{\texttt{annotate\_extra\_fields}}}
\newcommand\declareenumlabels[0]{\hyperlink{def-annotateenumlabels}{\texttt{declare\_enum\_labels}}}
\newcommand\declareconst[0]{\hyperlink{def-declareconst}{\texttt{declare\_const}}}
\newcommand\annotateparamtype[0]{\hyperlink{def-annotateparamtype}{\texttt{annotate\_param\_type}}}
\newcommand\annotateargs[0]{\hyperlink{def-annotateargs}{\texttt{annotate\_args}}}
\newcommand\annotateonearg[0]{\hyperlink{def-annotateonearg}{\texttt{annotate\_one\_arg}}}
\newcommand\annotatereturntype[0]{\hyperlink{def-annotatereturntype}{\texttt{annotate\_return\_type}}}
\newcommand\slicestopositions[0]{\hyperlink{def-slicestopositions}{\texttt{slices\_to\_positions}}}
\newcommand\extractslice[0]{\hyperlink{def-extractslice}{\texttt{extract\_slice}}}
\newcommand\slicetopositions[0]{\hyperlink{def-slicetopositions}{\texttt{slice\_to\_positions}}}
\newcommand\evaltoint[0]{\hyperlink{def-evaltoint}{\texttt{eval\_to\_int}}}
\newcommand\sort[0]{\hyperlink{def-sort}{\texttt{sort}}}
\newcommand\comparemonomialbindings[0]{\hyperlink{def-comparemonomialbindings}{\texttt{compare\_monomial\_bindings}}}
\newcommand\annotatecalleeparameters[0]{\hyperlink{def-annotatecalleeparameters}{\texttt{annotate\_callee\_params}}}
\newcommand\checkargstypesat[0]{\hyperlink{def-checkargstypesat}{\texttt{check\_args\_typesat}}}
\newcommand\checkcalleeparams[0]{\hyperlink{def-checkcalleeparams}{\texttt{check\_callee\_params}}}
\newcommand\annotateretty[0]{\hyperlink{def-annotateretty}{\texttt{annotate\_ret\_ty}}}
\newcommand\renametyeqs[0]{\hyperlink{def-renametyeqs}{\texttt{rename\_ty\_eqs}}}
\newcommand\substexpr[0]{\hyperlink{def-substexpr}{\texttt{subst\_expr}}}
\newcommand\substexprnormalize[0]{\hyperlink{def-substexprnormalize}{\texttt{subst\_expr\_normalize}}}
\newcommand\substconstraint[0]{\hyperlink{def-substconstraint}{\texttt{subst\_constraint}}}
\newcommand\typecheckmutuallyrec[0]{\hyperlink{def-typecheckmutuallyrec}{\texttt{type\_check\_mutually\_rec}}}
\newcommand\foldenvandfs[0]{\hyperlink{def-foldenvandfs}{\texttt{fold\_env\_and\_fs}}}
\newcommand\defdecl[0]{\hyperlink{def-defdecl}{\texttt{def\_decl}}}
\newcommand\defenumlabels[0]{\hyperlink{def-defenumlabels}{\texttt{def\_enum\_labels}}}
\newcommand\usedecl[0]{\hyperlink{def-usedecl}{\texttt{use\_decl}}}
\newcommand\usety[0]{\hyperlink{def-usety}{\texttt{use\_ty}}}
\newcommand\usesubtypes[0]{\hyperlink{def-usesubtypes}{\texttt{use\_subtypes}}}
\newcommand\useexpr[0]{\hyperlink{def-useexpr}{\texttt{use\_e}}}
\newcommand\uselexpr[0]{\hyperlink{def-uselexpr}{\texttt{use\_le}}}
\newcommand\usefields[0]{\hyperlink{def-usefields}{\texttt{use\_fields}}}
\newcommand\usepattern[0]{\hyperlink{def-usepattern}{\texttt{use\_pattern}}}
\newcommand\useslice[0]{\hyperlink{def-useslice}{\texttt{use\_slice}}}
\newcommand\usebitfield[0]{\hyperlink{def-usebitfield}{\texttt{use\_bitfield}}}
\newcommand\useconstraint[0]{\hyperlink{def-useconstraint}{\texttt{use\_constraint}}}
\newcommand\usestmt[0]{\hyperlink{def-usestmt}{\texttt{use\_s}}}
\newcommand\useldi[0]{\hyperlink{def-useldi}{\texttt{use\_ldi}}}
\newcommand\usecase[0]{\hyperlink{def-usecase}{\texttt{use\_case}}}
\newcommand\usecatcher[0]{\hyperlink{def-usecatcher}{\texttt{use\_catcher}}}
\newcommand\usefuncsig[0]{\hyperlink{def-usefuncsig}{\texttt{use\_func\_sig}}}
\newcommand\builddependencies[0]{\hyperlink{def-builddependencies}{\texttt{build\_dependencies}}}
\newcommand\decldependencies[0]{\hyperlink{def-decldependencies}{\texttt{decl\_dependencies}}}

% Symbolic equivalence testing macros
\newcommand\normalize[0]{\hyperlink{def-normalize}{\texttt{normalize}}}
\newcommand\typeequal[0]{\hyperlink{def-typeequal}{\texttt{type\_equal}}}
\newcommand\exprequal[0]{\hyperlink{def-exprequal}{\texttt{expr\_equal}}}
\newcommand\bitwidthequal[0]{\hyperlink{def-bitwidthequal}{\texttt{bitwidth\_equal}}}
\newcommand\bitfieldequal[0]{\hyperlink{def-bitfieldequal}{\texttt{bitfield\_equal}}}
\newcommand\bitfieldsequal[0]{\hyperlink{def-bitfieldsequal}{\texttt{bitfields\_equal}}}
\newcommand\reduceir[0]{\hyperlink{def-reduceir}{\texttt{reduce\_ir}}}
\newcommand\polynomialtoexpr[0]{\hyperlink{def-polynomialtoexpr}{\texttt{polynomial\_to\_expr}}}
\newcommand\monomialtoexpr[0]{\hyperlink{def-monomialtoexpr}{\texttt{monomial\_to\_expr}}}
\newcommand\symmulexpr[0]{\hyperlink{def-symmulexpr}{\texttt{sym\_mul\_expr}}}
\newcommand\symaddexpr[0]{\hyperlink{def-symaddexpr}{\texttt{sym\_add\_expr}}}
\newcommand\monomialstoexpr[0]{\hyperlink{def-monomialstoexpr}{\texttt{monomials\_to\_expr}}}
\newcommand\unitarymonomialstoexpr[0]{\hyperlink{def-unitarymonomialstoexpr}{\texttt{unitary\_monomials\_to\_expr}}}
\newcommand\compareidentifier[0]{\hyperlink{def-compareidentifier}{\texttt{compare\_identifier}}}

\newcommand\subsumes[0]{\hyperlink{def-subsumes}{\texttt{subsumes}}}
\newcommand\symsubsumes[0]{\hyperlink{def-symsubsumes}{\texttt{sym\_subsumes}}}

\newcommand\toir[0]{\hyperlink{def-toir}{\texttt{to\_ir}}}
\newcommand\toircase[0]{\hyperlink{def-toircase}{\texttt{to\_ir\_case}}}
\newcommand\Prod[0]{\hyperlink{def-prod}{\textsf{Prod}}}
\newcommand\Sum[0]{\hyperlink{def-sum}{\textsf{Sum}}}
\newcommand\unitarymonomial[0]{\hyperlink{def-unitarymonomial}{\textsf{unitary\_monomial}}}
\newcommand\monomial[0]{\hyperlink{def-monomial}{\textsf{monomial}}}
\newcommand\polynomial[0]{\hyperlink{def-polynomial}{\textsf{polynomial}}}
\newcommand\addpolynomials[0]{\hyperlink{def-addpolynomials}{\texttt{add\_polynomials}}}
\newcommand\mulpolynomials[0]{\hyperlink{def-mulpolynomials}{\texttt{mul\_polynomials}}}
\newcommand\mulmonomials[0]{\hyperlink{def-mulmonomials}{\texttt{mul\_mononimials}}}

\newcommand\declaredtype[0]{\hyperlink{def-declaredtype}{\texttt{declared\_type}}}

\newcommand\fieldnames[0]{\hyperlink{def-fieldnames}{\texttt{field\_names}}}
\newcommand\fieldtype[0]{\hyperlink{def-fieldtype}{\texttt{field\_type}}}

\newcommand\eliteral[1]{\textsf{E\_Literal}(#1)}

% An expression that we do not statically evaluate.
\newcommand\CannotBeTransformed[0]{\hyperlink{def-unsupportedexpression}{\top}}

\newcommand\unopsignatures[0]{\hyperlink{def-unopsignatures}{\texttt{unop\_signatures}}}
\newcommand\binopsignatures[0]{\hyperlink{def-binopsignatures}{\texttt{binop\_signatures}}}

\newcommand\ELInt[1]{\hyperlink{def-elint}{\texttt{ELInt}}(#1)}

% Glossary
\newcommand\parameterizedintegertype[0]{\hyperlink{def-parameterizedintegertype}{parameterized integer type}}
\newcommand\structuredtype[0]{\hyperlink{def-structuredtype}{structured type}}
\newcommand\structure[0]{\hyperlink{def-structure}{structure}}
\newcommand\underlyingtype[0]{\hyperlink{def-underlyingtype}{underlying type}}
\newcommand\symbolicdomain[0]{\hyperlink{def-symbolicdomain}{symbolic domain}}
\newcommand\typesatisfies[0]{\hyperlink{def-typesatisfies}{type-satisfies}}
\newcommand\typesatisfy[0]{\hyperlink{def-typesatisfies}{type-satisfy}}
\newcommand\checkedtypesatisfies[0]{\hyperlink{def-checktypesat}{checked-type-satisfies}}
\newcommand\typesatisft[0]{\hyperlink{def-typesatisfies}{type-satisft}}
\newcommand\subtypesatisfies[0]{\hyperlink{def-subtypesatisfies}{subtype-satisfies}}
\newcommand\subtypesatisfy[0]{\hyperlink{def-subtypesatisfies}{subtype-satisfisfy}}
\newcommand\typeequivalent[0]{\hyperlink{def-typeequal}{type-equivalent}}
\newcommand\bitwidthequivalent[0]{\hyperlink{def-bitwidthequal}{bitwidth-equivalent}}
\newcommand\typeclash[0]{\hyperlink{def-typeclashes}{type-clash}}
\newcommand\constrainedinteger[0]{\hyperlink{def-checkconstrainedinteger}{constrained integer}}
\newcommand\structureofinteger[0]{\hyperlink{def-checkstructureinteger}{structure of an integer}}
\newcommand\staticallyevaluable[0]{\hyperlink{def-staticallyevaluable}{statically evaluable}}
\newcommand\pure[0]{\hyperlink{def-storageispure}{pure}}
\newcommand\wellconstrainedstructure[0]{\hyperlink{def-getwellconstrainedstructure}{well-constrained structure}}
\newcommand\wellconstrainedversion[0]{\hyperlink{def-towellconstrained}{well-constrained version}}
\newcommand\namedlowestcommonancestor[0]{\hyperlink{def-namedlowestcommonancestor}{named lowest common ancestor}}
\newcommand\arrayaccess[0]{\hyperlink{def-arrayaccess}{array access}}
\newcommand\symbolicallysimplifies[0]{\hyperlink{def-symbolicallysimplifies}{symbolically simplifies}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type functions
\newcommand\CheckUnop[0]{\hyperlink{def-checkunop}{\texttt{check\_unop}}}
\newcommand\CheckBinop[0]{\hyperlink{def-checkbinop}{\texttt{check\_binop}}}
\newcommand\constraintsisstrictpositive[0]{\hyperlink{def-constraintsisstrictpositive}{\texttt{constraints\_is\_strict\_positive}}}
\newcommand\exprisstrictpositive[0]{\hyperlink{def-exprisstrictpositive}{\texttt{expr\_is\_strict\_positive}}}
\newcommand\constraintsisnonnegative[0]{\hyperlink{def-constraintsisnonnegative}{\texttt{constraints\_is\_non\_negative}}}
\newcommand\exprisnonnegative[0]{\hyperlink{def-exprisnonnegative}{\texttt{expr\_is\_non\_negative}}}
\newcommand\constraintsbinop[0]{\hyperlink{def-constraintbinops}{\texttt{constraints\_binop}}}
\newcommand\constraintbinop[0]{\hyperlink{def-constraintbinop}{\texttt{constraint\_binop}}}
\newcommand\isrightincreasing[0]{\hyperlink{def-isrightincreasing}{\texttt{is\_right\_increasing}}}
\newcommand\isrightdecreasing[0]{\hyperlink{def-isrightdecreasing}{\texttt{is\_right\_decreasing}}}
\newcommand\isleftincreasing[0]{\hyperlink{def-isleftincreasing}{\texttt{is\_left\_increasing}}}
\newcommand\annotateconstraintbinop[0]{\hyperlink{def-annotateconstraintbinop}{\texttt{annotate\_constraint\_binop}}}
\newcommand\explodeintervals[0]{\tododefine{explode\_intervals}} %{\hyperlink{def-explodeintervals}{\texttt{explode\_intervals}}}
\newcommand\binopisexploding[0]{\tododefine{binop\_is\_exploding}} %{\hyperlink{def-binopisexploding}{\texttt{binop\_is\_exploding}}}
\newcommand\binopfilterright[0]{\tododefine{binop\_filter\_right}}
\newcommand\checkslicesinwidth[0]{\tododefine{check\_slices\_in\_width}}
\newcommand\disjointslicestopositions[0]{\tododefine{disjoint\_slices\_to\_positions}}
\newcommand\checkpositionsinwidth[0]{\tododefine{check\_positions\_in\_width}}
\newcommand\shouldslicesreducetocall[0]{\tododefine{should\_slices\_reduce\_to\_call}}
\newcommand\checkdisjointslices[0]{\tododefine{check\_disjoint\_slices}}
\newcommand\sliceswidth[0]{\texttt{slices\_width}}
\newcommand\annotatetype[1]{\hyperlink{def-annotatetype}{\texttt{annotate\_type}}(#1)}
\newcommand\annotateconstraint[0]{\hyperlink{def-annotateconstraint}{\texttt{annotate\_constraint}}}
\newcommand\getvariableenum[0]{\hyperlink{def-getvariableenum}{\texttt{get\_variable\_enum}}}
\newcommand\annotateexpr[1]{\hyperlink{def-annotateexpr}{\texttt{annotate\_expr}}(#1)}
\newcommand\annotateexprlist[0]{\hyperlink{def-annotateexprs}{\texttt{annotate\_exprs}}}
\newcommand\annotatelooplimit[0]{\hyperlink{def-annotatelooplimit}{\texttt{annotate\_loop\_limit}}}
\newcommand\annotatelexpr[1]{\hyperlink{def-annotatelexpr}{\texttt{annotate\_lexpr}}(#1)}
\newcommand\annotatearrayindex[0]{\texttt{annotate\_array\_index}}
\newcommand\annotateslice[0]{\hyperlink{def-annotateslice}{\texttt{annotate\_slice}}}
\newcommand\annotateslices[0]{\hyperlink{def-annotateslices}{\texttt{annotate\_slices}}}
\newcommand\annotatepattern[0]{\hyperlink{def-annotatepattern}{\texttt{annotate\_pattern}}}
\newcommand\annotatelocaldeclitem[1]{\hyperlink{def-annotatelocaldeclitem}{\texttt{annotate\_local\_decl\_item}}(#1)}
\newcommand\annotatestmt[0]{\hyperlink{def-annotatestmt}{\texttt{annotate\_stmt}}}
\newcommand\annotateblock[1]{\hyperlink{def-annotateblock}{\texttt{annotate\_block}}(#1)}
\newcommand\inlinesetter[1]{\texttt{setter\_should\_reduce\_to\_call\_s}(#1)}
\newcommand\annotatecall[0]{\hyperlink{def-annotatecall}{\texttt{annotate\_call}}}
\newcommand\annotatecallargtyped[0]{\hyperlink{def-annotatecallargtyped}{\texttt{annotate\_call\_arg\_typed}}}
\newcommand\annotateparameterdefining[0]{\hyperlink{def-annotateparameterdefining}{\texttt{annotate\_parameter\_defining}}}
\newcommand\annotatecatcher[1]{\hyperlink{def-annotatecatcher}{\texttt{annotate\_catcher}}(#1)}
\newcommand\reduceconstants[0]{\hyperlink{def-reduceconstants}{\texttt{reduce\_constants}}}
\newcommand\reduceconstraint[0]{\hyperlink{def-reduceconstraint}{\texttt{reduce\_constraint}}}
\newcommand\reduceconstraints[0]{\hyperlink{def-reduceconstraints}{\texttt{reduce\_constraints}}}
\newcommand\declarelocalconstant[1]{\texttt{declare\_local\_constant}(#1)}
\newcommand\annotatelocaldeclitemuninit[1]{\texttt{annotate\_local\_decl\_item\_uninit}(#1)}
\newcommand\checkvarnotinenv[1]{\hyperlink{def-checkvarnotinenv}{\texttt{check\_var\_not\_in\_env}}(#1)}
\newcommand\checkvarnotingenv[1]{\hyperlink{def-checkvarnotingenv}{\texttt{check\_var\_not\_in\_genv}}(#1)}
\newcommand\varinenv[1]{\hyperlink{def-varinenv}{\texttt{var\_in\_env}}(#1)}
\newcommand\annotatesubprogram[1]{\hyperlink{def-annotatesubprogram}{\texttt{annotate\_subprogram}}(#1)}
\newcommand\annotatedecl[1]{\hyperlink{def-annotatedecl}{\texttt{annotate\_decl}}(#1)}
\newcommand\declaredecl[1]{\hyperlink{def-declaredecl}{\texttt{declare\_decl}}(#1)}
\newcommand\typecheckast[0]{\hyperlink{def-typecheckast}{\texttt{type\_check\_ast}}}
\newcommand\SCC[0]{\hyperlink{def-scc}{\texttt{SCC}}}
\newcommand\topologicalordering[0]{\hyperlink{def-topologicalordering}{\texttt{topological\_ordering}}}
\newcommand\declsofcomp[0]{\hyperlink{def-declsofcomp}{\texttt{decls\_of\_comp}}}
\newcommand\sortcomponents[0]{\hyperlink{def-sortcomponents}{\texttt{sort\_components}}}
\newcommand\annotatedeclcomps[0]{\hyperlink{def-annotatedeclcomps}{\texttt{annotate\_decl\_comps}}}
\newcommand\evalexpr[1]{\texttt{eval\_expr}(#1)}
\newcommand\evalconstraint[1]{\texttt{eval\_constraint}(#1)}
\newcommand\annotateliteral[1]{\hyperlink{def-annotateliteral}{\texttt{annotate\_literal}}(#1)}
\newcommand\exprequalcase[0]{\hyperlink{def-exprequalcase}{\texttt{expr\_equal\_case}}}
\newcommand\exprequalnorm[0]{\hyperlink{def-exprequalnorm}{\texttt{expr\_equal\_norm}}}
\newcommand\slicesequal[0]{\hyperlink{def-slicesequal}{\texttt{slices\_equal}}}
\newcommand\sliceequal[0]{\hyperlink{def-sliceequal}{\texttt{slice\_equal}}}
\newcommand\constraintsequal[0]{\hyperlink{def-constraintsequal}{\texttt{constraints\_equal}}}
\newcommand\constraintequal[0]{\hyperlink{def-constraintequal}{\texttt{constraint\_equal}}}
\newcommand\arraylengthequal[0]{\hyperlink{def-arraylengthequal}{\texttt{array\_length\_equal}}}
\newcommand\literalequal[0]{\hyperlink{def-literalequal}{\texttt{literal\_equal}}}
\newcommand\finddeducecheck[0]{\hyperlink{def-finddeducecheck}{\texttt{find\_deduce\_check}}}
\newcommand\annotatebitfield[0]{\hyperlink{def-annotatebitfield}{\texttt{annotate\_bitfield}}}
\newcommand\annotatebitfields[0]{\hyperlink{def-annotatebitfields}{\texttt{annotate\_bitfields}}}
\newcommand\checknoduplicates[0]{\hyperlink{def-checknoduplicates}{\texttt{check\_no\_duplicates}}}
\newcommand\reduceslicestocall[0]{\hyperlink{def-reduceslicestocall}{\texttt{reduce\_slices\_to\_call}}}
\newcommand\typeofarraylength[0]{\hyperlink{def-typeofarraylength}{\texttt{type\_of\_array\_length}}}
\newcommand\addlocal[0]{\hyperlink{def-addlocal}{\texttt{add\_local}}}
\newcommand\declaretype[0]{\hyperlink{def-declaretype}{\texttt{declare\_type}}}
\newcommand\subprogramtypesclash[0]{\hyperlink{def-subprogramtypeclash}{\texttt{subprogram\_types\_clash}}}
\newcommand\subprogramforname[0]{\hyperlink{def-subprogramforname}{\texttt{subprogram\_for\_name}}}
\newcommand\hasargclash[0]{\hyperlink{def-hasargclash}{\texttt{has\_arg\_clash}}}
\newcommand\filtercallcandidates[0]{\hyperlink{def-filtercandidates}{\texttt{filter\_call\_candidates}}}
\newcommand\deduceeqs[0]{\hyperlink{def-deduceeqs}{\texttt{deduce\_eqs}}}
\newcommand\getundeclareddefining[0]{\hyperlink{def-getundeclareddefining}{\texttt{get\_undeclared\_defining}}}
\newcommand\bintounsigned[0]{\hyperlink{def-bintounsigned}{\textsf{binary\_to\_unsigned}}}
\newcommand\inttobits[0]{\hyperlink{def-inttobits}{\texttt{int\_to\_bits}}}

% Symbolic domain subsumption
\newcommand\symdom[0]{\hyperlink{def-symdom}{\textsf{sym\_dom}}}
\newcommand\intset[0]{\hyperlink{def-intset}{\textsf{int\_set}}}
\newcommand\syntax[0]{\hyperlink{def-syntax}{\textsf{syntax}}}

\newcommand\DBool[0]{\hyperlink{def-dbool}{\textsf{D\_Bool}}}
\newcommand\DString[0]{\hyperlink{def-dstring}{\textsf{D\_String}}}
\newcommand\DReal[0]{\hyperlink{def-dreal}{\textsf{D\_Real}}}
\newcommand\DSymbols[0]{\hyperlink{def-dsymbols}{\textsf{D\_Symbols}}}
\newcommand\DInt[0]{\hyperlink{def-dint}{\textsf{D\_Int}}}
\newcommand\DBits[0]{\hyperlink{def-dbits}{\textsf{D\_Bits}}}
\newcommand\DUnknown[0]{\hyperlink{def-dunknown}{\textsf{D\_Unknown}}}

\newcommand\Finite[0]{\hyperlink{def-finite}{\textsf{Finite}}}
\newcommand\Top[0]{\hyperlink{def-top}{\textsf{Top}}}
\newcommand\FromSyntax[0]{\hyperlink{def-fromsymtax}{\textsf{FromSyntax}}}

\newcommand\symdomoftype[0]{\hyperlink{def-symdomoftype}{\texttt{symdom\_of\_type}}}
\newcommand\symdomofexpr[0]{\hyperlink{def-symdomofexpr}{\texttt{symdom\_of\_expr}}}
\newcommand\symdomofliteral[0]{\hyperlink{def-symdomofliteral}{\texttt{symdom\_of\_literal}}}
\newcommand\intsetofintconstraints[0]{\hyperlink{def-intsetofintconstraintse}{\texttt{intset\_of\_intconstraints}}}
\newcommand\symdomissubset[0]{\hyperlink{def-symdomissubset}{\texttt{symdom\_is\_subset}}}
\newcommand\constrainttointset[0]{\hyperlink{def-constrainttointset}{\texttt{constraint\_to\_intset}}}
\newcommand\normalizetoint[0]{\hyperlink{def-normalizetoint}{\texttt{normalize\_to\_int}}}
\newcommand\symintsetsubset[0]{\hyperlink{def-symintsetsubset}{\texttt{sym\_intset\_subset}}}
\newcommand\intsetop[0]{\hyperlink{def-intsetop}{\texttt{intset\_op}}}
\newcommand\intsettointconstraints[0]{\hyperlink{def-intsettointconstraints}{\texttt{int\_set\_to\_int\_constraints}}}

%% Type Error Codes
\newcommand\TypeErrorCode[1]{\texttt{TE\_#1}}
\newcommand\UndefinedIdentifier[0]{\hyperlink{def-undefinedidentifier}{\TypeErrorCode{UI}}}
\newcommand\SetterWithoutGetter[0]{\hyperlink{def-setterwithoutgetter}{\TypeErrorCode{SWG}}}
\newcommand\ExpectedBitvectorType[0]{\hyperlink{def-expectedbitvectortype}{\TypeErrorCode{EBT}}}
\newcommand\SubrogramDeclaredMultipleTimes[0]{\hyperlink{def-subprogramdeclaredmultipletimes}{\TypeErrorCode{SDM}}}
\newcommand\NoCallCandidates[0]{\hyperlink{def-nocallcandidates}{\TypeErrorCode{NCC}}}
\newcommand\TooManyCandidates[0]{\hyperlink{def-toomanycandidates}{\TypeErrorCode{TMC}}}
\newcommand\ParameterWithoutDecl[0]{\hyperlink{def-parameterwithoutdecl}{\TypeErrorCode{PWD}}}
\newcommand\NoLCA[0]{\hyperlink{def-nolca}{\TypeErrorCode{LCA}}}
\newcommand\MismatchedReturnValue[0]{\hyperlink{def-mrv}{\TypeErrorCode{MRV}}}
\newcommand\CallBadArity[0]{\hyperlink{def-cba}{\TypeErrorCode{CBA}}}
\newcommand\BadRecursiveDecls[0]{\hyperlink{def-brd}{\TypeErrorCode{BRA}}}
\newcommand\RequireIntegerForLoopBounds[0]{\hyperlink{def-lbi}{\TypeErrorCode{LBI}}}
\newcommand\RequireStructuredType[0]{\hyperlink{def-rst}{\TypeErrorCode{RST}}}
\newcommand\MissingFieldInitializer[0]{\hyperlink{def-mfi}{\TypeErrorCode{MFI}}}
\newcommand\RequireSameBitwidths[0]{\hyperlink{def-rsb}{\TypeErrorCode{RSB}}}
\newcommand\TypeAsssertionFails[0]{\hyperlink{def-taf}{\TypeErrorCode{TAF}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Typeset variable names
\newcommand\newtenv[0]{\texttt{new\_tenv}}
\newcommand\tenvone[0]{\texttt{tenv1}}
\newcommand\tenvonep[0]{\texttt{tenv1'}}
\newcommand\tenvonepp[0]{\texttt{tenv1''}}
\newcommand\tenvtwo[0]{\texttt{tenv2}}
\newcommand\tenvtwop[0]{\texttt{tenv2'}}
\newcommand\tenvtwopp[0]{\texttt{tenv2''}}
\newcommand\vc[0]{\texttt{c}}
\newcommand\vcone[0]{\texttt{c1}}
\newcommand\vctwo[0]{\texttt{c2}}
\newcommand\vione[0]{\texttt{i1}}
\newcommand\vitwo[0]{\texttt{i2}}
\newcommand\vf[0]{\texttt{f}}
\newcommand\vfone[0]{\texttt{f1}}
\newcommand\vftwo[0]{\texttt{f2}}
\newcommand\vl[0]{\texttt{l}}
\newcommand\vm[0]{\texttt{m}}
\newcommand\vmone[0]{\texttt{m1}}
\newcommand\vmtwo[0]{\texttt{m2}}
\newcommand\vy[0]{\texttt{y}}
\newcommand\vp[0]{\texttt{p}}
\newcommand\vo[0]{\texttt{o}}
\newcommand\vvone[0]{\texttt{v1}}
\newcommand\vvtwo[0]{\texttt{v2}}
\newcommand\vt[0]{\texttt{t}}
\newcommand\vte[0]{\texttt{t\_e}}
\newcommand\veone[0]{\texttt{e1}}
\newcommand\vetwo[0]{\texttt{e2}}
\newcommand\vethree[0]{\texttt{e3}}
\newcommand\vefour[0]{\texttt{e4}}
\newcommand\vefive[0]{\texttt{e5}}
\newcommand\vleone[0]{\texttt{le1}}
\newcommand\vletwo[0]{\texttt{le2}}
\newcommand\vtleone[0]{\texttt{t\_le1}}
\newcommand\vre[0]{\texttt{re}}
\newcommand\vtsone[0]{\texttt{ts1}}
\newcommand\vtstwo[0]{\texttt{ts2}}
\newcommand\vlt[0]{\texttt{l\_t}}
\newcommand\vls[0]{\texttt{l\_s}}
\newcommand\vtt[0]{\texttt{t\_t}}
\newcommand\vts[0]{\texttt{t\_s}}
\newcommand\vz[0]{\texttt{z}}
\newcommand\vw[0]{\texttt{w}}
\newcommand\vwone[0]{\texttt{w1}}
\newcommand\vwtwo[0]{\texttt{w2}}
\newcommand\vwidth[0]{\texttt{width}}
\newcommand\size[0]{\texttt{size}}
\newcommand\vfield[0]{\texttt{field}}
\newcommand\vfieldone[0]{\texttt{field1}}
\newcommand\vfieldtwo[0]{\texttt{field2}}
\newcommand\vfieldsone[0]{\texttt{fields1}}
\newcommand\vfieldstwo[0]{\texttt{fields2}}
\newcommand\bitfields[0]{\texttt{bitfields}}
\newcommand\bfone[0]{\texttt{bf1}}
\newcommand\bftwo[0]{\texttt{bf2}}
\newcommand\bfoneone[0]{\texttt{bf1\_1}}
\newcommand\bftwoone[0]{\texttt{bf2\_1}}
\newcommand\newle[0]{\texttt{new\_le}}
\newcommand\ldi[0]{\texttt{ldi}}
\newcommand\ldk[0]{\texttt{ldk}}
\newcommand\tsy[0]{\texttt{sy}}
\newcommand\tyopt[0]{\texttt{ty\_opt}}
\newcommand\ldis[0]{\texttt{ldis}}
\newcommand\newldi[0]{\texttt{new\_ldi}}
\newcommand\newsone[0]{\texttt{new\_s1}}
\newcommand\newstwo[0]{\texttt{new\_s2}}
\newcommand\newargs[0]{\texttt{new\_args}}
\newcommand\eqs[0]{\texttt{eqs}}
\newcommand\neweqs[0]{\texttt{new\_eqs}}
\newcommand\reduced[0]{\texttt{reduced}}
\newcommand\tcond[0]{\texttt{t\_cond}}
\newcommand\econd[0]{\texttt{e\_cond}}
\newcommand\vcond[0]{\texttt{v\_cond}}
\newcommand\etrue[0]{\texttt{e\_true}}
\newcommand\efalse[0]{\texttt{e\_false}}
\newcommand\ttrue[0]{\texttt{t\_true}}
\newcommand\tfalse[0]{\texttt{t\_false}}
\newcommand\dir[0]{\texttt{dir}}
\newcommand\eindex[0]{\texttt{e\_index}}
\newcommand\wantedtindex[0]{\texttt{wanted\_t\_index}}
\newcommand\tindex[0]{\texttt{t\_index}}
\newcommand\fieldname[0]{\texttt{field\_name}}
\newcommand\fields[0]{\texttt{fields}}
\newcommand\fieldsone[0]{\texttt{fields1}}
\newcommand\fieldstwo[0]{\texttt{fields2}}
\newcommand\slices[0]{\texttt{slices}}
\newcommand\newe[0]{\texttt{new\_e}}
\newcommand\ta[0]{\texttt{ta}}
\newcommand\les[0]{\texttt{les}}
\newcommand\subtys[0]{\texttt{sub\_tys}}
\newcommand\catchers[0]{\texttt{catchers}}
\newcommand\otherwise[0]{\texttt{otherwise}}
\newcommand\csone[0]{\texttt{cs1}}
\newcommand\cstwo[0]{\texttt{cs2}}
\newcommand\irone[0]{\texttt{ir1}}
\newcommand\irtwo[0]{\texttt{ir2}}
\newcommand\vpone[0]{\texttt{p1}}
\newcommand\vptwo[0]{\texttt{p2}}
\newcommand\vps[0]{\texttt{ps}}
\newcommand\opone[0]{\texttt{op1}}
\newcommand\optwo[0]{\texttt{op2}}
\newcommand\vep[0]{\texttt{e'}}
\newcommand\veoneone[0]{\texttt{e1\_1}}
\newcommand\veonetwo[0]{\texttt{e1\_2}}
\newcommand\veonethree[0]{\texttt{e1\_3}}
\newcommand\vetwoone[0]{\texttt{e2\_1}}
\newcommand\vetwotwo[0]{\texttt{e2\_2}}
\newcommand\vetwothree[0]{\texttt{e2\_3}}
\newcommand\vbone[0]{\texttt{b1}}
\newcommand\vbtwo[0]{\texttt{b2}}
\newcommand\vbthree[0]{\texttt{b3}}
\newcommand\nameone[0]{\texttt{name1}}
\newcommand\nametwo[0]{\texttt{name2}}
\newcommand\vargsone[0]{\texttt{args1}}
\newcommand\vargstwo[0]{\texttt{args2}}
\newcommand\vargone[0]{\texttt{arg1}}
\newcommand\vargtwo[0]{\texttt{arg2}}
\newcommand\vlone[0]{\texttt{l1}}
\newcommand\vltwo[0]{\texttt{l2}}
\newcommand\sliceone[0]{\texttt{slice1}}
\newcommand\slicetwo[0]{\texttt{slice2}}
\newcommand\slicesone[0]{\texttt{slices1}}
\newcommand\slicestwo[0]{\texttt{slices2}}
\newcommand\positions[0]{\texttt{positions}}
\newcommand\posmax[0]{\texttt{pos\_max}}
\newcommand\bv[0]{\texttt{bv}}
\newcommand\bvone[0]{\texttt{bv1}}
\newcommand\vtp[0]{\texttt{t'}}
\newcommand\vli[0]{\texttt{li}}
\newcommand\tys[0]{\texttt{tys}}
\newcommand\name[0]{\texttt{name}}
\newcommand\newname[0]{\texttt{new\_name}}
\newcommand\vles[0]{\texttt{les}}
\newcommand\namedargs[0]{\texttt{named\_args}}
\newcommand\ldione[0]{\texttt{ldi1}}
\newcommand\genv[0]{\texttt{genv}}

% Increase indentation of sections in the table of contents
% to allow a space between the section numbers and their titles.
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{2.6em}}
\makeatother
\setcounter{tocdepth}{1}

\author{Arm Architecture Technology Group}
\title{ASL Typing Reference \\
       DDI 0622}
\begin{document}
\maketitle

\tableofcontents{}

\include{notice.tex}

\include{disclaimer.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The purpose of this document is to describe, in a formal and authoritative way,
which ASL specifications are considered \emph{well-typed}.
Whether a specification is well-typed is defined in terms of a \emph{type system}~\cite{TypeSystemsLucaCardelli}.
That is, a set of \emph{typing rules}.

An ASL parser accepts an ASL specification and checks whether it is valid with respect to the syntax of ASL,
which is defined in~\cite{ASLAbstractSyntaxReference}.
If the specification is syntactically valid, the parser returns an \emph{abstract syntax tree} (AST, for short),
which represents the specification as a labelled structured tree. Otherwise, it returns a syntax error.
When an ASL specification is successfully parsed, we refer to the resulting AST as the \emph{parsed AST}.

A \emph{type checker} is an implementation of the ASL type system, which accepts a parsed AST and applies the
rules of the type system to the parsed AST. If it is successful, the specification
is considered \emph{well-typed} and the result is a pair consisting of
a \emph{static environment} and a \emph{typed AST}, which are used in defining the ASL semantics~\cite{ASLSemanticsReference}.
Otherwise, the type checker returns a type error.

\paragraph{Related documents:}
\begin{itemize}
  % \item The ASL Language Reference Manual~\cite{LRM} (LRM, for short) introduces the concrete syntax and intent
  % of all ASL language constructs.
  % Please note that the LRM will be retired in due course. For ease of reviewing, we currently indicate which statement
  % of the LRM the present rules correspond to.
  \item The Abstract Syntax Reference~\cite{ASLAbstractSyntaxReference} defines the abstract syntax, parsed AST, and typed AST.
  \item The ASL Semantics Reference~\cite{ASLSemanticsReference} defines all valid behaviors of a well-typed ASL specification.
\end{itemize}

\paragraph{Understanding the Typing Formalization:}
We assume basic familiarity with the ASL language.
The ASL type system is defined in terms of its AST,
and familiarity with the AST is \underline{required} to understand it.
The mathematical background needed to understand the mathematical formalization
of the ASL semantics appears in \chapref{formal} and \chapref{typesystembuildingblocks}.

\paragraph{Reading guide:}
The typing rules are organized into chapters, which roughly group the rules by their AST node type.
The set of rules in each chapter is further split according to additional syntactic and semantic
predicates over the AST node.
For example, an expression can be a literal, or a binary operator, amongst other
things. Each of those has its own evaluation rule: TypingRule.ELit in
\secref{TypingRule.ELit} and
Typing.Binop in \secref{TypingRule.Binop}, respectively.

Each rule is presented using the following template:
\begin{itemize}
\item a Prose paragraph gives the rule in English, and corresponds as much as possible to the code of the reference implementation ASLRef given at
\href{https://github.com/herd/herdtools7//tree/master/asllib}{/herdtools7/asllib};
\item one or several Example paragraphs, which as much as possible are also given as regression tests in
\href{https://github.com/herd/herdtools7//tree/master/asllib/tests/ASLTypingReference.t}{/herdtools7/asllib/tests/ASLTypingReference.t};
\ifcode
\item a Code paragraph which gives a verbatim of the corresponding OCaml implementation in the type-checker of ASLRef
\href{https://github.com/herd/herdtools7//tree/master/asllib/Typing.ml}{/herdtools7/asllib/Typing.ml};
\fi
\item Formal paragraphs which give formal definitions of the rule.
\item Comments paragraphs, which provide additional details. %refer to one or more rules from the Language Reference Manual~\cite{LRM} and
\end{itemize}

Note that rules use a specific language to define variables, deconstruct mathematical data types,
and assert equality. See \secref{FlavoursOfEqualityInRules} for details.

\include{ASLFormal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Type System Building Blocks}
\label{chap:typesystembuildingblocks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter defines necessary mathematical types and concepts for the ASL system.

Types are represented by ASTs derived from the non-terminal $\ty$ (see \cite{ASLAbstractSyntaxReference}
for the precise definition of $\ty$).

\section{Static Environments}

A \emph{static environment} (also called a \emph{type environment}) is what the typing rules operate over:
a structure, which amongst other things, associates types to variables.
Throughout this document, we will use the term environment for static environment, unless otherwise stated.
Intuitively, the typing of a
specification makes an initial environment evolve, with new types as given by the
variable declarations of the specification.

\begin{definition}
\hypertarget{def-staticenvs}{}
Static environments, denoted as $\staticenvs$, are defined as follows (referring to symbols defined by the abstract syntax):
\[
\begin{array}{rcl}
\staticenvs 	          &\triangleq& \globalstaticenvs \times \localstaticenvs \hypertarget{def-globalstaticenvs}{}\\
\globalstaticenvs 	    &\triangleq& \declaredtypes \times \constantvalues \times \globalstoragetypes\\
  			                &          & \times\ \subtypes \times \subprograms \times \subprogramrenamings \hypertarget{def-localstaticenvs}{}\\
\localstaticenvs 	      &\triangleq& \constantvalues \times \localstoragetypes \times \returntype\\
\hline
\declaredtypes	        &\triangleq& \identifier \partialto \ty\\
\constantvalues         &\triangleq& \identifier \partialto \literal\\
\globalstoragetypes     &\triangleq& \identifier \partialto \ty \times \globaldeclkeyword\\
\localstoragetypes      &\triangleq& \identifier \partialto \ty \times \localdeclkeyword\\
\subtypes		            &\triangleq& \identifier \partialto \identifier\\
\subprograms	          &\triangleq& \identifier \partialto \func\\
\subprogramrenamings	  &\triangleq& \identifier \rightarrow \pow{\Strings}\\
\returntype             &\triangleq& \langle \ty \rangle
\end{array}
\]
\end{definition}

We use $\tenv$ and similar variable names (for example, $\tenvone$ and $\newtenv$) to range over static environments.

A static environment $\tenv=(G^\tenv, L^\tenv)$ consists of two
distinct components: the global environment $G^\tenv \in \globalstoragetypes$ --- pertaining to AST nodes
appearing outside of a given subprogram, and the local environment
$L^\tenv \in \localstaticenvs$ --- pertaining to AST nodes appearing inside a given subprogram.
This separation allows us to type-check subprograms by using an empty local environment.

The intuitive meaning of each component is as follows:
\begin{itemize}
  \hypertarget{def-declaredtypes}{}
  \item $\declaredtypes$ assigns types to their declared names;
  \hypertarget{def-constantvalues}{}
  \item $\constantvalues$ assigns literals to their declaring (constant) names;
  \hypertarget{def-globalstoragetypes}{}
  \item $\globalstoragetypes$ associates names of global storage elements to their inferred type
  and how they were declared --- as constants, configuration variables, \texttt{let} variables,
  or mutable variables;
  \hypertarget{def-localstoragetypes}{}
  \item $\localstoragetypes$ associates names of local storage elements to their inferred type
  and how they were declared --- as variables, constants, or as \texttt{let} variables;
  \hypertarget{def-subtypes}{}
  \item $\subtypes$ associates type names to the names that their type subtypes;
  \hypertarget{def-subprograms}{}
  \item $\subprograms$ associates names of subprograms to the $\func$ AST node they were
  declared with;
  \hypertarget{def-subprogramrenamings}{}
  \item $\subprogramrenamings$ associates names of subprograms to the set of overloading
  subprograms ---  $\func$ AST nodes that share the same name;
  \hypertarget{def-returntype}{}
  \item $\returntype$ contains the name of the type that a subprogram declares, if it is
  a function or a getter.
\end{itemize}

\hypertarget{def-emptytenv}{}
\begin{definition}[Empty Static Environment]
  The \emph{empty static environment}, \\ denoted as $\emptytenv$, is defined as follows:
  \[
    \emptytenv \triangleq \left(
      \begin{array}{c}
        \overname{
      (\overname{\emptyfunc}{\declaredtypes},
      \overname{\emptyfunc}{\constantvalues},
      \overname{\emptyfunc}{\globalstoragetypes},
      \overname{\emptyfunc}{\subtypes},
      \overname{\emptyfunc}{\subprograms},
      \overname{\emptyfunc}{\subprogramrenamings})}{G},\\
      \overname{
      (
        \overname{\emptyfunc}{\constantvalues},
        \overname{\emptyfunc}{\localstoragetypes},
        \overname{\None}{\returntype}
      )}{L}
      \enspace.
    \end{array}
    \right)
  \]
\end{definition}

The global environment and local environment consist of various components.
We use the notation $G^\tenv.m$ and $L^\tenv.m$ to access the $m$ component of a given environment.

To update a function component $f$ (e.g., $\declaredtypes$) of an environment $\tenv$ (either local or global)
with a new mapping $x \mapsto v$, we use the notation $\tenv.f[x \mapsto v]$ to stand for $\tenv[f \mapsto E.f[x \mapsto v]]$.

\lrmcomment{This is related to \identd{JRXM} and \identi{ZTMQ}.}

\section{Constrained Types}
\begin{itemize}
  \item A \emph{constrained type} is a type whose definition relies on an expression, for example, certain integers and bitvectors.
  \item A type which is not constrained is \emph{unconstrained}.
  \item A constrained type with a non-empty constraint is \emph{well-constrained}.
  \hypertarget{def-parameterizedintegertype}
  \item A \emph{\parameterizedintegertype} is an implicit type of a subprogram parameter.
  \end{itemize}
The widths of bitvector storage elements are constrained integers.

\hypertarget{def-isunconstrainedinteger}{}
\hypertarget{def-isparameterizedinteger}{}
\hypertarget{def-iswellconstrainedinteger}{}
We define the following helper predicates to classify integer types:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \isparameterizedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \iswellconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool
  \end{array}
\]

We define the following shorthands for classifying integers:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\unconstrained\\
  \isparameterizedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\parameterized\\
  \iswellconstrainedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\wellconstrained\\
\end{array}
\]

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{ZTPP}, \identr{WJYH}, \identr{HJPN}, \identr{CZTX}, \identr{TPHR}.}

\section{ASL Type System}
\hypertarget{def-annotaterel}{}
The type system of ASL is given by the relation $\annotaterel$, which is defined as the disjoint union
of the functions and relations defined in this document.
The functions and relations in this document are defined, in turn, via type system rules.

The output configurations of type assertions have two flavors:
\begin{description}
  \item[Normal Outputs.] \hypertarget{def-normal-type-outputs}{}
  Configurations are typically tuples with different combinations
  of \emph{static environments}, types, and Boolean values.

  \hypertarget{def-typeerror}{}
  \item[Type Errors.] Configurations in $\TypeError(\Strings)$
  represent type errors, for example, using an integer type as a condition expression, as in \verb|if 5 then 1 else 2|.
  The ASL type system is designed such that when these \emph{type error configurations} appear,
  the typing of the entire specification terminates by outputting them.
\end{description}

We define the mathematical type of type error configurations
(which is needed to define the types of functions in the ASL type system)
as follows:
\hypertarget{def-ttypeerror}{}
\[
  \TTypeError \triangleq \{\TypeErrorVal{\vs} \;|\; \vs \in \Strings \} \enspace.
\]

\hypertarget{def-typeerrorconfig}{}
and the shorthand $\TypeErrorConfig \triangleq \TypeError(\vs)$ for type error configurations.

% \hypertarget{def-proseortypeerror}{}
% Specifically,\ProseOrTypeError\ means: ``or a type error configuration $\TypeErrorConfig$, which short-circuits the rule,
% making it transition into the type error configuration $\TypeErrorConfig$.''.
%
When several \hyperlink{def-caserules}{case rules} for the same function use the same short-circuiting transition assertion,
we do not repeat the\ProseOrTypeError, but rather include it only in the first rule.

% \subsection*{Rule Example}
% The following rule is used to type a sequence of two statements:
% \[
% \inferrule{
%   \annotatestmt{\tenv, \vs1} = (\newsone, \tenvone)\\
%   \annotatestmt{\tenvone, \vs2} = (\newstwo, \tenvtwo)\\
% }
% {
%   \annotatestmt{\tenv, \SSeq(\vsone, \vstwo)} = (\SSeq(\newsone, \newstwo), \tenvtwo)
% }
% \]
% The rule uses the annotation function $\annotatestmt{\cdot}$, which
% accepts an environment $\tenv$ and two statements and returns a new statement and a new environment.
% The function returns a new statement in order to implement certain code transformations, such as
% inlining setter functions.

\section{Annotation}

Typing a specification consists of annotating the root of its AST with the rules defined
in the remainder of this document.

\paragraph{Shorthand Notations:}
\hypertarget{def-elint}{}
We use the shorthand $\ELInt{n}$ for the expression denoting the literal integer value $n$. That is, $\ELiteral(\overname{\lint(n)}{\vr})$.

\hypertarget{def-unconstrainedinteger}{}
We use the shorthand notation $\unconstrainedinteger$ to denote the unconstrained integer type: $\TInt(\unconstrained)$.

Note that throughout this document we use $\tty$ to denote a type variable, which should not be confused with the abstract syntax variable $\ty$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Domain of Values for Types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter formalizes the concept of the set of values for a given type.
The formalism is given in the form of rules.
%
The chapter also defines the concept of checking whether the set of values
for one type is included in the set of values for another type.

\hypertarget{def-vals}{}
\section{Native Values \label{sec:nativevalues}}

Types define sets of values that variables can take when a specification is semantically evaluated.
To formalize this, we define the set of \emph{native values}, denoted $\vals$
(\texttt{NV} stands for Native Value).

\subsection{Prose}
The set of native values $\vals$ is the minimal set satisfying all of the following rules:
\begin{itemize}
  \item \textsc{basis set}: if $\vv$ is a literal then $\nvliteral{\vv}$ is a native value;
  \item \textsc{tuple values and array values}: if $\vl$ is a list of native values then $\nvvector{\vl}$ is a native value;
  \item \textsc{record values}: if $\vr$ is a finite function from identifiers to native values then $\nvrecord{\vr}$ is a native value.
\end{itemize}

\subsection{Formally}
\hypertarget{def-nvliteral}{}
\hypertarget{def-nvvector}{}
\hypertarget{def-nvrecord}{}
\begin{mathpar}
  \inferrule[(Basis Set: Integers, Reals, Booleans, Strings, and Bitvectors)]
  {\vv \in \literal}
  { \nvliteral{\vv} \in \vals }
  \and
  \inferrule[(Tuple Values and Array Values)]{\vvl \in \vals^*}
  { \nvvector{\vvl} \in \vals }
  \and
  \inferrule[(Record Values)]
  {\vr : \Identifiers \rightarrowfin \vals}
  { \nvrecord{\vr} \in \vals }
\end{mathpar}

We define the following shorthands for native value literals:
\hypertarget{def-nvint}{}
\[
\begin{array}{rcl}
\nvint(z)       &\triangleq& \nvliteral{\lint(z)}           \hypertarget{def-nvbool}{}\\
\nvbool(b)      &\triangleq& \nvliteral{\lbool(b)}          \hypertarget{def-nvreal}{}\\
\nvreal(r)      &\triangleq& \nvliteral{\lreal(r)}          \hypertarget{def-nvstring}{}\\
\nvstring(s)    &\triangleq& \nvliteral{\lstring(s)}        \hypertarget{def-nvbitvector}{}\\
\nvbitvector(v) &\triangleq& \nvliteral{\lbitvector(v)}\\
\end{array}
\]

We define the following types of native values:
\hypertarget{def-tint}{}
\[
\begin{array}{rcl}
  \tint       &\triangleq& \{ \nvint(z) \;|\; z \in \Z\}                                        \hypertarget{def-tbool}{}\\
  \tbool      &\triangleq& \{ \nvbool(\True), \nvbool(\False) \}                                \hypertarget{def-treal}{}\\
  \treal      &\triangleq& \{ \nvreal(r) \;|\; r \in \Q\}                                       \hypertarget{def-tstring}{}\\
  \tstring    &\triangleq& \{ \nvstring(s) \;|\; s \in \Strings\}  \hypertarget{def-tbitvector}{}\\
  \tbitvector &\triangleq& \{ \nvbitvector(\textit{bits}) \;|\; \textit{bits} \in \{0,1\}^*\}   \hypertarget{def-tvector}{}\\
  \tvector    &\triangleq& \{ \nvvector{\textit{vals}} \;|\; \textit{vals} \in \vals^*\}        \hypertarget{def-trecord}{}\\
  \trecord  &\triangleq& \{ \nvrecord{\fieldmap} \;|\; \fieldmap \in \Identifiers\rightarrow\vals\}\\
\end{array}
\]

\section{Dynamic Domain of a Type}
\hypertarget{def-dyndomain}{}

We now define the concept of a \emph{dynamic domain} of a type
and the \emph{static domain} of a type.
Intuitively, domains assign potentially infinite sets of native values to types.
Dynamic domains are used by the semantics to evaluate expressions of the form \texttt{UNKNOWN: t}
by choosing a single value from the dynamic domain of $\vt$.
Static domains are used to define (domain) subtype satisfaction in \secref{TypingRule.DomainSubtypeSatisfaction}.

\hypertarget{def-dynamicenvs}{}
The definition of a dynamic domain refers to \emph{dynamic environments}, denoted $\dynamicenvs$,
which assigns native values to identifiers~\cite{ASLSemanticsReference}.

\hypertarget{def-envs}{}
We define \emph{environments} as pairs of static environments and dynamic environments:
$\envs \triangleq \staticenvs \times \dynamicenvs$.

Formally, the partial function
\[
  \dynamicdomain : \overname{\envs}{\env} \times \overname{\ty}{\vt}
  \partialto \overname{\pow{\vals}}{\vd}
\]
assigns the set of values that a type $\vt$ can hold in a given environment $\env$.
%
We say that $\dynamicdomain(\env, \vt)$ is the \emph{dynamic domain} of $\vt$
in the environment $\env$.
%
The \emph{static domain} of a type is the set of values which storage elements of that type may hold
\underline{across all possible dynamic environments}.
%
The reason for this distinction is that the sets of values
of integer types, bitvector types, and array types can depend on the dynamic values of variables.

Types that do not refer to variables whose values are only known dynamically have
a static domain that is equal to any of their dynamic domains.
In those cases, we simply refer to their \emph{domain}.

Associating a set of values to a type is done by evaluating any expression appearing
in the type definitions. Evaluation is defined by the ASL semantics~\cite{ASLSemanticsReference}
via the relation
\hypertarget{def-evalexprsef}{}
\[
  \evalexprsef{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
  \Normal(\overname{\vals}{\vv}\aslsep\overname{\XGraphs}{\vg}) \cup
  \overname{\TError}{\ErrorConfig}
\]
\hypertarget{def-errorconfig}{}
which evaluates side-effect-free expressions and either returns
a configuration of the form $\Normal(\vv,\vg)$ or a dynamic error configuration $\ErrorConfig$.
In the first case, $\vv$ is a native value and $\vg$
is an \emph{execution graph}. Execution graphs are related to the concurrent semantics
and can be ignored in the context of defining dynamic domains.
In the latter case (which can occur if, for example, an expression attempts to divide
\texttt{8} by \texttt{0}), a dynamic error configuration, for which we use the notation
$\ErrorConfig$, is returned.
%
The dynamic domain is empty in cases where evaluating side-effect-free expressions
results in a dynamic error.
%
The dynamic domain is undefined if the type $\vt$ is not well-typed in $\tenv$.
That is, if $\annotatetype{\tenv, \vt} \typearrow \TypeErrorConfig$.

As part of the definition, we also associate dynamic domains to integer constraints
by overloading $\dynamicdomain$:
\[
  \dynamicdomain : \overname{\envs}{\env} \times \overname{\intconstraint}{\vc}
  \partialto \overname{\pow{\vals}}{\vd}
\]

\subsection{Prose}
For an environment $\env \in \envs$ and a type $\vt$, the domain is $\vd$ and one of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{t\_bool}):
  \begin{itemize}
    \item $\vt$ is the Boolean type, $\TBool$;
    \item $\vd$ is the set of native Boolean values, $\tbool$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_string}):
  \begin{itemize}
    \item $\vt$ is the string type, $\TString$;
    \item $\vd$ is the set of all native string values, $\tstring$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_real}):
  \begin{itemize}
    \item $\vt$ is the real type, $\TReal$;
    \item $\vd$ is the set of all native real values, $\treal$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_enumeration}):
  \begin{itemize}
    \item $\vt$ is the enumeration type with labels $\id_{1..k}$, that is $\TEnum(\id_{1..k})$;
    \item $\vd$ is the set of all native integer values for $1..k$.\\
    \textbf{Why represent enumeration domains via integers:}
    Conceptually, enumeration labels carry two pieces of information --- the identifiers themselves
    and their position in the list of identifiers, which are used for accessing arrays.
    For the purpose of type-checking, we use the identifiers, but for the purpose of the semantics
    and the domain of values, only the positions are relevant.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_unconstrained}):
  \begin{itemize}
    \item $\vt$ is the unconstrained integer type, $\unconstrainedinteger$;
    \item $\vd$ is the set of all native integer values, $\tint$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_well\_constrained}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type $\TInt(\wellconstrained(\vc_{1..k}))$;
    \item $\vd$ is the union of the dynamic domains of each of the constraints $vc_{1..k}$ in $\env$.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_exact\_okay}):
  \begin{itemize}
    \item $\vc$ is a constraint consisting of a single side-effect-free expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $n$;
    \item $\vd$ is the set containing the single native integer value for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_exact\_dynamic\_error}):
  \begin{itemize}
    \item $\vc$ is a constraint consisting of a single side-effect-free expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item evaluating $\ve$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_range\_okay}):
  \begin{itemize}
    \item $\vc$ is a range constraint consisting of a two side-effect-free expressions $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item evaluating $\veone$ in $\env$, results in a configuration with the native integer for $a$;
    \item evaluating $\vetwo$ in $\env$, results in a configuration with the native integer for $b$;
    \item $a$ is less than or equal to $b$;
    \item $\vd$ is the set containing all native integer values for integers from $a$ to $b$, inclusive.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_range\_dynamic\_error1}):
  \begin{itemize}
    \item $\vc$ is a range constraint consisting of a two side-effect-free expressions $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item evaluating $\veone$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_range\_dynamic\_error2}):
  \begin{itemize}
    \item $\vc$ is a range constraint consisting of a two side-effect-free expressions $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item evaluating $\veone$ in $\env$, results in a configuration with the native integer for $a$;
    \item evaluating $\vetwo$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_parameterized}):
  \begin{itemize}
    \item $\vt$ is a \parameterizedintegertype\ for parameter $\id$, \\ $\TInt(\parameterized(\id))$;
    \item the native value associated with $\id$ in the local dynamic environment is the native integer value for $n$;
    \item $\vd$ is the set containing the single integer value for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_dynamic\_error}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_negative\_width\_error}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $k$ is negative;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_empty}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $0$;
    \item $\vd$ is the set containing the single native value for an empty bitvector.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_non\_empty}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $k$ is greater than $0$;
    \item $\vd$ is the set containing all native values for bitvectors of size exactly $k$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
    \item $\vt$ is a tuple type over types $\vt_i$, for $i=1..k$, $\TTuple(\vt_{1..k})$;
    \item the domain of each element $\vt_i$ is $D_i$, for $i=1..k$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $\vd$ is the set containing all native vectors of $k$ values, where the value at position $i$
    is from $D_i$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array\_dynamic\_error}):
  \begin{itemize}
    \item $\vt$ is an array type with length expression $\ve$ and element type $\vt_i$, for $i=1..k$, $\TArray(\ve, \vtone)$;
    \item evaluating $\ve$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array\_negative\_length\_error}):
  \begin{itemize}
    \item $\vt$ is an array type with length expression $\ve$ and element type $\vt_i$, for $i=1..k$, $\TArray(\ve, \vtone)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $k$ is negative;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array\_okay}):
  \begin{itemize}
    \item $\vt$ is an array type with length expression $\ve$ and element type $\vt_i$, for $i=1..k$, $\TArray(\ve, \vtone)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $k$ is greater than or equal to $0$;
    \item the domain of $\vtone$ is $D_\vtone$;
    \item $\vd$ is the set containing all native vectors of $k$ values taken from $D_\vtone$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_structured}):
  \begin{itemize}
    \item $\vt$ is a \structuredtype\ with typed fields $(\id_i, \vt_i$, for $i=1..k$, that is $L([i=1..k: (\id_i,\vt_i))]$
    where $L\in\{\TRecord, \TException\}$;
    \item the domain of each type $\vt_i$ is $D_i$, for $i=1..k$;
    \item $\vd$ is the set containing all native records where $\id_i$ is mapped to a value taken from $D_i$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_named}):
  \begin{itemize}
    \item $\vt$ is a named type with name $\id$, $\TNamed(\id)$;
    \item the type associated with $\id$ in $\tenv$ is $\tty$;
    \item $\vd$ is the domain of $\tty$ in $\env$.
  \end{itemize}
\end{itemize}

\subsection{Formally}

\begin{mathpar}
\inferrule[t\_bool]{}{ \dynamicdomain(\env, \overname{\TBool}{\vt}) = \overname{\tbool}{\vd} }
\and
\inferrule[t\_string]{}{ \dynamicdomain(\env, \overname{\TString}{\vt}) = \overname{\tstring}{\vd} }
\and
\inferrule[t\_real]{}{ \dynamicdomain(\env, \overname{\TReal}{\vt}) = \overname{\treal}{\vd} }
\and
\inferrule[t\_enumeration]{}{
  \dynamicdomain(\env, \overname{\TEnum(\id_{1..k})}{\vt}) = \overname{\{\nvint(1),\ldots,\nvint(k)\}}{\vd}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[t\_int\_unconstrained]{}{
  \dynamicdomain(\env, \overname{\unconstrainedinteger}{\vt}) = \overname{\tint}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_int\_well\_constrained]{}{
  \dynamicdomain(\env, \overname{\TInt(\wellconstrained(\vc_{1..k}))}{\vt}) = \overname{\bigcup_{i=1}^k \dynamicdomain(\env, \vc_i)}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constraint\_exact\_okay]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(n), \Ignore)
}{
  \dynamicdomain(\env, \overname{\ConstraintExact(\ve)}{\vc}) = \overname{\{ \nvint(n) \}}{\vd}
}
\and
\inferrule[constraint\_exact\_dynamic\_error]{
  \evalexprsef{\env, \ve} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \overname{\ConstraintExact(\ve)}{\vc}) = \overname{\emptyset}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constraint\_range\_okay]{
  \evalexprsef{\env, \veone} \evalarrow \Normal(\nvint(a), \Ignore)\\
  \evalexprsef{\env, \vetwo} \evalarrow \Normal(\nvint(b), \Ignore)
}{
  \dynamicdomain(\env, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) = \overname{\{ \nvint(n) \;|\;  a \leq n \land n \leq b\}}{\vd}
}
\and
\inferrule[constraint\_range\_dynamic\_error1]{
  \evalexprsef{\env, \veone} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) = \overname{\emptyset}{\vd}
}
\and
\inferrule[constraint\_range\_dynamic\_error2]{
  \evalexprsef{\env, \veone} \evalarrow \Normal(\Ignore, \Ignore)\\
  \evalexprsef{\env, \vetwo} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) = \overname{\emptyset}{\vd}
}
\end{mathpar}

The notation $L^\denv(\id)$ denotes the native value associated with the identifier $\id$
in the \emph{local dynamic environment} of $\denv$.
\begin{mathpar}
  \inferrule[t\_int\_parameterized]{
  L^\denv(\id) = \nvint(n)
}{
  \dynamicdomain(\env, \overname{\TInt(\parameterized(\id))}{\vt}) = \overname{\{ \nvint(n) \}}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits\_dynamic\_error]{
  \evalexprsef{\env, \ve} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \overname{\TBits(\ve, \Ignore)}{\vt}) = \overname{\emptyset}{\vd}
}
\and
\inferrule[t\_bits\_negative\_width\_error]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
  k < 0
}{
  \dynamicdomain(\env, \overname{\TBits(\ve, \Ignore)}{\vt}) = \overname{\emptyset}{\vd}
}
\and
\inferrule[t\_bits\_empty]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(0), \Ignore)
}{
  \dynamicdomain(\env, \overname{\TBits(\ve, \Ignore)}{\vt}) = \overname{\{ \nvbitvector(\emptylist) \}}{\vd}
}
\and
\inferrule[t\_bits\_non\_empty]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
  k > 0
}{
  \dynamicdomain(\env, \overname{\TBits(\ve, \Ignore)}{\vt}) = \overname{\{ \nvbitvector(\vb_{1..k}) \;|\; \vb_1,\ldots,\vb_k \in \{0,1\} \}}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  i=1..k: \dynamicdomain(\env, \vt_i) = D_i
}{
  \dynamicdomain(\env, \overname{\TTuple(\vt_{1..k})}{\vt}) =
  \overname{\{ \nvvector{\vv_{1..k}} \;|\; \vv_i \in D_i \}}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_dynamic\_error]{
  \evalexprsef{\env, \ve} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \overname{\TArray(\ve, \vtone)}{\vt}) = \overname{\emptyset}{\vd}
}
\and
\inferrule[t\_array\_negative\_length\_error]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
  k < 0
}{
  \dynamicdomain(\env, \overname{\TArray(\ve, \vtone)}{\vt}) = \overname{\emptyset}{\vd}
}
\and
\inferrule[t\_array\_okay]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
  k \geq 0\\
  \dynamicdomain(\env, \vtone) = D_\vtone
}{
  \dynamicdomain(\env, \overname{\TArray(\ve, \vtone)}{\vt}) =
  \overname{\{ \nvvector{\vv_{1..k}} \;|\; \vv_{1..k} \in D_{\vtone} \}}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\
  i=1..k: \dynamicdomain(\env, \vt_i) = D_i
}{
  \dynamicdomain(\env, \overname{L([i=1..k: (\id_i,\vt_i))]}{\vt}) = \\
  \overname{\{ \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}} \;|\; \vv_i \in D_i \}}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_named]{
  G^\tenv.\declaredtypes(\id)=\tty
}{
  \dynamicdomain(\env, \overname{\TNamed(\id)}{\vt}) = \overname{\dynamicdomain(\env, \tty)}{\vd}
}
\end{mathpar}

\subsection{Example}
The domain of \texttt{integer} is the infinite set of all integers.

The domain of \verb|integer {2,16}| is the set $\{\nvint(2), \nvint(16)\}$.

The domain of \verb|integer{1..3}| is the set $\{\nvint(1), \nvint(2), \nvint(3)\}$.

The domain of \verb|integer{10..1}| is the empty set as there are no integers that are
both greater than $10$ and smaller than $1$.

The domain of \texttt{bits(2)} is the set $\{\nvbitvector(00)$, $\nvbitvector(01),$
$\nvbitvector(10)$, $\nvbitvector(11)\}$.

The domain of \verb|enumeration {GREEN, ORANGE, RED}| is the set \\
$\{\nvint(1), \nvint(2), \nvint(3)\}$ and so is the domain
of \\
\verb|type TrafficLights of enumeration {GREEN, ORANGE, RED}|.

The domain of \texttt{bits({2,16})} is the set containing native bitvectors of all 2-bit and all 16-bit binary sequences.

The domain of \texttt{(integer, integer)} is the set containing all pairs of native integer values.

The domain of \verb|record {a: integer;  b: boolean}| contains all native records
that map \texttt{a} to a native integer value and \texttt{b} to a native Boolean value.

The dynamic domain of a subprogram parameter \texttt{N: integer} is the (singleton) set containing
the native integer value $c$,
which is assigned to \texttt{N} by a given dynamic environment. The static domain of that parameter
is the infinite set of all native integer values.

\lrmcomment{
This is related to \identd{BMGM}, \identr{PHRL}, \identr{PZNR},
\identr{RLQP}, \identr{LYDS}, \identr{SVDJ}, \identi{WLPJ}, \identr{FWMM},
\identi{WPWL}, \identi{CDVY}, \identi{KFCR}, \identi{BBQR}, \identr{ZWGH},
\identr{DKGQ}, \identr{DHZT}, \identi{HSWR}, \identd{YZBQ}.
}

\section{Subsumption Testing \label{sec:subsumptiontesting}}
Whether an assignment statement is well-typed depends on whether the dynamic domain of the
right hand side type is contained in the dynamic domain of the left hand side type,
for any given dynamic environment
(see \secref{TypingRule.DomainSubtypeSatisfaction} where this is checked).

\begin{definition}[Subsumption]
For any given types $\vt$ and $\vs$ and static environment $\tenv$,
we say that $\vt$ \emph{subsumes} $\vs$ in $\tenv$,
if the following condition holds:
\hypertarget{def-subsumes}{}
\begin{equation}
  \subsumes(\tenv, \vt, \vs) \triangleq \forall \denv\in\dynamicenvs.\ \dynamicdomain((\tenv, \denv), \vt) \supseteq \dynamicdomain((\tenv, \denv), \vs) \enspace.
\end{equation}
\end{definition}

For example, consider the assignment
\begin{center}
\verb|var x : integer{1,2,3} = UNKNOWN : integer{1,2};|
\end{center}

It is legal, since (in any static environment), the domain of \verb|integer{1,2,3}|
is \\
$\{\nvint(1), \nvint(2), \nvint(3)\}$, which subsumes
the domain of \verb|integer{1,2}|, which is \\ $\{\nvint(1), \nvint(2)\}$.

Since dynamic domains are potentially infinite, this requires \emph{symbolic reasoning}.
Furthermore, since any (statically evaluable) expressions may appear inside integer and bitvector
types, testing subsumption is undecidable.
We therefore approximate subsumption testing \emph{conservatively} via the predicate $\symsubsumes(\tenv, \vt, \vs)$.

\hypertarget{def-soundsubsumptiontest}{}
\begin{definition}[Sound Subsumption Test]
A predicate
\[
  \symsubsumes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs}) \aslto \Bool
\]
is \emph{sound} if the following condition holds:
\begin{equation}
  \begin{array}{l}
  \forall \vt,\vs\in\ty.\ \tenv\in\staticenvs. \\
  \;\;\;\; \symsubsumes(\tenv, \vt, \vs) \typearrow \True \;\Longrightarrow\; \subsumes(\tenv, \vt, \vs)  \enspace.
  \end{array}
\end{equation}
\end{definition}

That is, if a sound subsumption test returns a positive answer, it means that
$\vt$ definitely \emph{subsumes} $\vs$ in the static environment $\tenv$.
This is referred to as a \emph{true positive}.
However, a negative answer means one of two things:
\begin{description}
  \item[True Negative:] indeed, $\vt$ does not subsume $\vs$ in the static environment $\tenv$; or
  \item[False Negative:] the symbolic reasoning is unable to decide.
\end{description}

In other words, $\symsubsumes(\tenv, \vt, \vs)$ errs on the \emph{safe side} ---
it never answers $\True$ when the real answer is $\False$, which would (undesirably)
determine the following statement as well-typed:
\begin{center}
  \verb|var x : integer{1,2} = UNKNOWN: integer;|
\end{center}

A sound but trivial subsumption test is one that always returns $\False$.
However, that would make all assignments be considered as not well-typed.
Indeed, it has the maximal set of false negatives.
Reducing the set of false negatives requires stronger symbolic reasoning algorithms,
which inevitably leads to higher computational complexity.
%
The symbolic subsumption test in \chapref{symbolicsubsumptiontesting}
attempts to accept a large enough set of true positives, based on empirical trial and error,
while maintaining the computational complexity of the symbolic reasoning relatively low.
%
In particular, it serves as the definitive subsumption test that must be utilized
by any implementation of the ASL type system.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basic Type Attributes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter defines some basic predicates for classifying types as well as
functions that inspect the structure of types:
\begin{itemize}
  \item Builtin singular types (\secref{TypingRule.BuiltinSingularType})
  \item Builtin aggregate types (\secref{TypingRule.BuiltinAggregateType})
  \item Builtin types (\secref{TypingRule.BuiltinSingularOrAggregate})
  \item Named types (\secref{TypingRule.NamedType})
  \item Anonymous types (\secref{TypingRule.AnonymousType})
  \item Singular types (\secref{TypingRule.SingularType})
  \item Aggregate types (\secref{TypingRule.AggregateType})
  \item Non-primitive types (\secref{TypingRule.NonPrimitiveType})
  \item Primitive types (\secref{TypingRule.PrimitiveType})
  \item The structure of a type (\secref{structure})
  \item The underlying type of a type (\secref{anonymize})
  \item Checked constrained integers (\secref{TypingRule.CheckConstrainedInteger})
\end{itemize}

\section{TypingRule.BuiltinSingularType \label{sec:TypingRule.BuiltinSingularType}}
\hypertarget{def-isbuiltinsingular}{}
The predicate
\[
  \isbuiltinsingular(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{builtin singular type}.

\subsection{Prose}
The \emph{builtin singular types} are:
\begin{itemize}
\item \texttt{integer};
\item \texttt{real};
\item \texttt{string};
\item \texttt{boolean};
\item \texttt{bits} (which also represents \texttt{bit}, as a special case);
\item \texttt{enumeration}.
\end{itemize}

\subsection{Example}
In this example:
\VerbatimInput[firstline=3,lastline=8]{\tests/TypingRule.BuiltinSingularTypes.asl}

Variables of builtin singular types \texttt{integer}, \texttt{real},
\texttt{boolean}, \texttt{bits(4)}, \\ and~\texttt{bits(2)} are defined.

\subsection{Example}
\VerbatimInput{\tests/TypingRule.EnumerationType.asl}
The builtin singular type \texttt{Color} consists in two constants
\texttt{RED}, and~\texttt{BLACK}.

\CodeSubsection{\BuiltinSingularBegin}{\BuiltinSingularEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef \astlabel(\tty) \in \{\TReal, \TString, \TBool, \TBits, \TEnum, \TInt\}
}{
  \isbuiltinsingular(\tty) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{PQCK} and \identd{NZWT}.}

\section{TypingRule.BuiltinAggregateType \label{sec:TypingRule.BuiltinAggregateType}}
\hypertarget{def-isbuiltinaggregate}{}
The predicate
\[
  \isbuiltinaggregate(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{builtin aggregate type}.

\subsection{Prose}
The builtin aggregate types are:
\begin{itemize}
\item tuple;
\item \texttt{array};
\item \texttt{record};
\item \texttt{exception}.
\end{itemize}

\subsection{Example}
\VerbatimInput{\tests/TypingRule.BuiltinAggregateTypes.asl}
Type \texttt{Pair} is the type of integer and boolean pairs.

Arrays are declared with indices that are either integer-typed
or enumeration-typed.  In the example above, \texttt{T} is
declared as an array with an integer-typed index (as indicated
by the used of the integer-typed constant \texttt{3}) whereas
\texttt{PointArray} is declared with the index of
\texttt{Coord}, which is an enumeration type.

Arrays declared with integer-typed indices can be accessed only by integers ranging from $0$ to
the size of the array minus $1$. In the example above, $\texttt{T}$ can be accessed with
one of $0$, $1$, and $2$.

Arrays declared with an enumeration-typed index can only be accessed with labels from the corresponding
enumeration. In the example above, \texttt{PointArray} can only be accessed with one of the labels
\texttt{CX}, \texttt{CY}, and \texttt{CZ}.

The (builtin aggregate) type \verb|{ x : real, y : real, z : real }| is a record type with three fields
\texttt{x}, \texttt{y} and \texttt{z}.

\subsection{Example}
\VerbatimInput{\tests/TypingRule.BuiltinExceptionType.asl}
Two (builtin aggregate) exception types are defined:
\begin{itemize}
\item \verb|exception{}| (for \texttt{Not\_found}), which carries no value; and
\item \verb|exception { message:string }| (for \texttt{SyntaxException}), which carries a message.
\end{itemize}
Notice the similarity with record types and that the empty field list \verb|{}| can be
omitted in type declarations, as is the case for \texttt{Not\_found}.

\CodeSubsection{\BuiltinAggregateBegin}{\BuiltinAggregateEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{ \vb \eqdef \astlabel(\tty) \in \{\TTuple, \TArray, \TRecord, \TException\} }
{ \isbuiltinaggregate(\tty) \typearrow \vb }
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{PQCK} and \identd{KNBD}.}

\section{TypingRule.BuiltinSingularOrAggregate \label{sec:TypingRule.BuiltinSingularOrAggregate}}
\hypertarget{def-isbuiltin}{}
The predicate
\[
  \isbuiltin(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{builtin type}.

\subsection{Prose}
$\tty$ is a builtin type and one of the following applies:
\begin{itemize}
\item $\tty$ is singular;
\item $\tty$ is builtin aggregate.
\end{itemize}

\subsection{Example}
In the specification
\begin{verbatim}
  type ticks of integer;
\end{verbatim}
the type \texttt{integer} is a builtin type but the type of \texttt{ticks} is not.

\CodeSubsection{\BuiltinSingularOrAggregateBegin}{\BuiltinSingularOrAggregateEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \isbuiltinsingular(\tty) \typearrow \vbone\\
    \isbuiltinaggregate(\tty) \typearrow \vbtwo
  }{
    \isbuiltin(\tty) \typearrow \vbone \lor \vbtwo
  }
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.NamedType \label{sec:TypingRule.NamedType} }
\hypertarget{def-isnamed}{}
The predicate
\[
  \isnamed(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{named type}.

\subsection{Prose}
A named type is a type that is declared by using the \texttt{type of} syntax.

\subsection{Example}
In the specification
\begin{verbatim}
  type ticks of integer;
\end{verbatim}
\texttt{ticks} is a named type.

\CodeSubsection{\NamedBegin}{\NamedEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef \astlabel(\tty) = \TNamed
}{
  \isnamed(\tty) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{vmzx}.}

\section{TypingRule.AnonymousType \label{sec:TypingRule.AnonymousType}}
\hypertarget{def-isanonymous}{}
The predicate
\[
  \isanonymous(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is an \emph{anonymous type}.

\subsection{Prose}
An anonymous type is a type that is not declared using the type syntax.

\subsection{Example}
The tuple type \texttt{(integer, integer)} is an anonymous type.

\CodeSubsection{\AnonymousBegin}{\AnonymousEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{ \vb \eqdef \astlabel(\tty) \neq \TNamed
}
{
  \isanonymous(\tty) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{VMZX}.}

\section{TypingRule.SingularType \label{sec:TypingRule.SingularType}}
\hypertarget{def-issingular}{}
The predicate
\[
  \issingular(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \;\aslto\;
  \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the type $\tty$ is a \emph{singular type} in the static environment $\tenv$.

\subsection{Prose}
A type $\tty$ is singular if and only if all of the following apply:
\begin{itemize}
  \item obtaining the \underlyingtype\ of $\tty$ in the environment $\tenv$ yields $\vtone$\ProseOrTypeError;
  \item $\vtone$ is a builtin singular type.
\end{itemize}

\subsection{Example}
In the following example, the types \texttt{A}, \texttt{B}, and \texttt{C} are all singular types:
\begin{verbatim}
type A of integer;
type B of A;
type C of B;
\end{verbatim}

\CodeSubsection{\SingularBegin}{\SingularEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \makeanonymous(\tenv, \tty) \typearrow \vtone \OrTypeError\\\\
  \isbuiltinsingular(\vtone) \typearrow \vb
}{
\issingular(\tenv, \tty) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{GVZK}.}

\section{TypingRule.AggregateType \label{sec:TypingRule.AggregateType}}
\hypertarget{def-isbuiltinaggregate}{}
The predicate
\[
  \isaggregate(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \;\aslto\;
  \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the type $\tty$ is an \emph{aggregate type} in the static environment $\tenv$.

\subsection{Prose}
A type $\tty$ is aggregate in an environment $\tenv$ if and only if all of the following apply:
\begin{itemize}
  \item obtaining the \underlyingtype\ of $\tty$ in the environment $\tenv$ yields $\vtone$\ProseOrTypeError;
  \item $\vtone$ is a builtin aggregate.
\end{itemize}

\subsection{Example}
In the following example, the types \texttt{A}, \texttt{B}, and \texttt{C} are all aggregate types:
\begin{verbatim}
type A of (integer, integer);
type B of A;
type C of B;
\end{verbatim}

\CodeSubsection{\AggregateBegin}{\AggregateEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \makeanonymous(\tenv, \tty) \typearrow \vtone \OrTypeError\\\\
  \isbuiltinaggregate(\vtone) \typearrow \vb
}{
  \isaggregate(\tenv, \tty) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{GVZK}.}

\section{TypingRule.StructuredType \label{sec:TypingRule.StructuredType}}
\hypertarget{def-isstructured}{}
\hypertarget{def-structuredtype}{}
A \emph{\structuredtype} is any type that consists of a list of field identifiers
that denote individual storage elements. In ASL there are two such types --- record types and exception types.

The predicate
\[
  \isstructured(\overname{\ty}{\tty}) \;\aslto\; \overname{\Bool}{\vb}
\]
tests whether the type $\tty$ is a \structuredtype\ and yields the result in $\vb$.

\subsection{Prose}
The result $\vb$ is $\True$ if and only if $\tty$ is either a record type or an exception type,
which is determined via the AST label of $\tty$.

\subsection{Example}
In the following example, the types \texttt{SyntaxException} and \texttt{PointRecord}
are each an example of a \structuredtype:
\begin{verbatim}
type SyntaxException of exception {message: string };
type PointRecord of Record {x : real, y: real, z: real};
\end{verbatim}

\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \isstructured(\tty) \typearrow \overname{\astlabel(\tty) \in \{\TRecord, \TException\}}{\vb}
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{WGQS}, \identd{QXYC}.}

\section{TypingRule.NonPrimitiveType \label{sec:TypingRule.NonPrimitiveType}}
\hypertarget{def-isnonprimitive}{}
The predicate
\[
  \isnonprimitive(\overname{\ty}{\tty}) \;\aslto\; \overname{\Bool}{\vb}
\]
tests whether the type $\tty$ is a \emph{non-primitive type}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{singular}):
  \begin{itemize}
  \item $\tty$ is a builtin singular type;
  \item $\vb$ is $\False$.
  \end{itemize}
  \item All of the following apply (\textsc{named}):
  \begin{itemize}
    \item $\tty$ is a named type;
    \item $\vb$ is $\True$.
  \end{itemize}
  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\tty$ is a tuple type $\vli$;
    \item $\vb$ is $\True$ if and only if there exists a non-primitive type in $\vli$.
  \end{itemize}
  \item All of the following apply (\textsc{array}):
    \begin{itemize}
    \item $\tty$ is an array of type $\tty'$
    \item $\vb$ is $\True$ if and only if $\tty'$ is non-primitive.
    \end{itemize}
  \item All of the following apply (\textsc{structured}):
    \begin{itemize}
    \item $\tty$ is a \structuredtype\ with fields $\fields$;
    \item $\vb$ is $\True$ if and only if there exists a non-primitive type in $\fields$.
    \end{itemize}
\end{itemize}

\subsection{Example}
The following types are non-primitive:

\begin{tabular}{ll}
\textbf{Type definition} & \textbf{Reason for being non-primitive}\\
\hline
\texttt{type A of integer}  & Named types are non-primitive\\
\texttt{(integer, A)}       & The second component, \texttt{A}, has non-primitive type\\
\texttt{array[6] of A}      & Element type \texttt{A} has a non-primitive type\\
\verb|record { a : A }|     & The field \texttt{a} has a non-primitive type
\end{tabular}

\CodeSubsection{\NonPrimitiveBegin}{\NonPrimitiveEnd}{../types.ml}

\subsection{Formally}
The cases \textsc{tuple} and \textsc{structured} below, use the notation $\vb_\vt$ to name
Boolean variables by using the types denoted by $\vt$ as a subscript.
\begin{mathpar}
\inferrule[singular]{
  \astlabel(\tty) \in \{\TReal, \TString, \TBool, \TBits, \TEnum, \TInt\}
}{
  \isnonprimitive(\tty) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[named]{\astlabel(\tty) = \TNamed}{\isnonprimitive(\tty) \typearrow \True}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \vt \in \tys: \isnonprimitive(\vt) \typearrow \vb_{\vt}\\
  \vb \eqdef \bigvee_{\vt \in \tys} \vb_{\vt}
}{
  \isnonprimitive(\overname{\TTuple(\tys)}{\tty}) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[array]{
  \isnonprimitive(\tty') \typearrow \vb
}{
  \isnonprimitive(\overname{\TArray(\Ignore, \tty')}{\tty}) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\
  (\Ignore,\vt) \in \fields : \isnonprimitive(\vt) \typearrow \vb_\vt\\
  \vb \eqdef \bigvee_{\vt \in \vli} \vb_{\vt}
}{
  \isnonprimitive(\overname{L(\fields)}{\tty}) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{GWXK}.}

\section{TypingRule.PrimitiveType \label{sec:TypingRule.PrimitiveType}}
\hypertarget{def-isprimitive}{}
The predicate
\[
  \isprimitive(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{primitive type}.

\subsection{Prose}
A type $\tty$ is primitive if it is not non-primitive.

\subsection{Example}
The following types are primitive:

\begin{tabular}{ll}
\textbf{Type definition} & \textbf{Reason for being primitive}\\
\hline
\texttt{integer} & Integers are primitive\\
\texttt{(integer, integer)} & All tuple elements are primitive\\
\texttt{array[5] of integer} & The array element type is primitive\\
\verb|record {ticks : integer}| & The single field \texttt{ticks} has a primitive type
\end{tabular}

\CodeSubsection{\PrimitiveBegin}{\PrimitiveEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \isnonprimitive(\tty) \typearrow \vb
}{
  \isprimitive(\tty) \typearrow \neg\vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{GWXK}.}

\section{TypingRule.Structure \label{sec:structure}}
\hypertarget{def-structure}{}
The function
\[
  \tstruct(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \aslto \overname{\ty}{\vt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
assigns a type to its \hypertarget{def-tstruct}{\emph{\structure}}, which is the type formed by
recursively replacing named types by their type definition in the static environment $\tenv$.
If a named type is not associated with a declared type in $\tenv$, a type error is returned.

TypingRule.Specification ensures the absence of circular type definitions,
which ensures that TypingRule.Structure terminates\footnote{In mathematical terms,
this ensures that TypingRule.Structure is a proper \emph{structural induction.}}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
\item All of the following apply (\textsc{named}):
  \begin{itemize}
  \item $\tty$ is a named type $\vx$;
  \item obtaining the declared type associated with $\vx$ in the static environment $\tenv$ yields $\vtone$\ProseOrTypeError;
  \item obtaining the structure of $\vtone$ static environment $\tenv$ yields $\vt$\ProseOrTypeError;
  \end{itemize}
\item All of the following apply (\textsc{builtin\_singular}):
  \begin{itemize}
  \item $\tty$ is a builtin singular type;
  \item $\vt$ is $\tty$.
  \end{itemize}
\item All of the following apply (\textsc{tuple}):
  \begin{itemize}
  \item $\tty$ is a tuple type with list of types $\tys$;
  \item the types in $\tys$ are indexed as $\vt_i$, for $i=1..k$;
  \item obtaining the structure of each type $\vt_i$, for $i=1..k$, in $\tys$ in the static environment $\tenv$,
  yields $\vtp_i$\ProseOrTypeError;
  \item $\vt$ is a tuple type with the list of types $\vtp_i$, for $i=1..k$.
  \end{itemize}
\item All of the following apply (\textsc{array}):
  \begin{itemize}
    \item $\tty$ is an array type of length $\ve$ with element type $\vt$;
    \item obtaining the structure of $\vt$ yields $\vtone$\ProseOrTypeError;
    \item $\vt$ is is an array type with of length $\ve$ with element type $\vtone$.
  \end{itemize}
\item All of the following apply (\textsc{structured}):
  \begin{itemize}
  \item $\tty$ is a \structuredtype\ with fields $\fields$;
  \item obtaining the structure for each type $\vt$ associated with field $\id$ yields a type $\vt_\id$\ProseOrTypeError;
  \item $\vt$ is a record or an exception, in correspondence to $\tty$, with the list of pairs $(\id, \vt\_\id)$;
  \end{itemize}
\end{itemize}

\subsection{Example}
In this example:
\texttt{type T1 of integer;} is the named type \texttt{T1}
whose structure is \texttt{integer}.

In this example:
\texttt{type T2 of (integer, T1);}
is the named type \texttt{T2} whose structure is (integer, integer). In this
example, \texttt{(integer, T1)} is non-primitive since it uses \texttt{T1}, which is builtin aggregate.

In this example:
\texttt{var x: T1;}
the type of $\vx$ is the named (hence non-primitive) type \texttt{T1}, whose structure
is \texttt{integer}.

In this example:
\texttt{var y: integer;}
the type of \texttt{y} is the anonymous primitive type \texttt{integer}.

In this example:
\texttt{var z: (integer, T1);}
the type of \texttt{z} is the anonymous non-primitive type
\texttt{(integer, T1)} whose structure is \texttt{(integer, integer)}.

\CodeSubsection{\StructureBegin}{\StructureEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[named]{
  \declaredtype(\tenv, \vx) \typearrow \vtone \OrTypeError\\\\
  \tstruct(\tenv, \vtone)\typearrow\vt \OrTypeError
}{
  \tstruct(\tenv, \TNamed(\vx)) \typearrow \vt
}
\and
\inferrule[builtin\_singular]{
  \isbuiltinsingular(\tty) \typearrow \True
}{
  \tstruct(\tenv, \tty) \typearrow \tty
}
\and
\inferrule[tuple]{
  \tys \eqname \vt_{1..k}\\
  i=1..k: \tstruct(\tenv, \vt_i) \typearrow \vtp_i \OrTypeError
}{
  \tstruct(\tenv, \TTuple(\tys)) \typearrow  \TTuple(i=1..k: \vtp_i)
}
\and
\inferrule[array]{
  \tstruct(\tenv, \vt) \typearrow \vtone \OrTypeError
}{
  \tstruct(\tenv, \TArray(\ve, \vt)) \typearrow \TArray(\ve, \vtone)
}
\and
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\\\
  (\id,\vt) \in \fields : \tstruct(\tenv, \vt) \typearrow \vt_\id \OrTypeError
}{
  \tstruct(\tenv, L(\fields)) \typearrow
 L([ (\id,\vt) \in \fields : (\id,\vt_\id) ])
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{FXQV}.}

\section{TypingRule.Anonymize \label{sec:anonymize}}
\hypertarget{def-makeanonymous}{}
\hypertarget{def-underlyingtype}{}
The function
\[
  \makeanonymous(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \aslto \overname{\ty}{\vt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the \emph{\underlyingtype} --- $\vt$ --- of the type $\tty$ in the static environment $\tenv$ or a type error.
Intuitively, $\tty$ is the first non-named type that is used to define $\tty$. Unlike $\tstruct$,
$\makeanonymous$ replaces named types by their definition until the first non-named type is found but
does not recurse further.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{named}):
  \begin{itemize}
    \item $\tty$ is a named type $\vx$;
    \item obtaining the type declared for $\vx$ yields $\vtone$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vtone$ is $\vt$.
  \end{itemize}

  \item All of the following apply (\textsc{non-named}):
  \begin{itemize}
    \item $\tty$ is not a named type $\vx$;
    \item $\vt$ is $\tty$.
  \end{itemize}
\end{itemize}

\subsection{Example}
Consider the following example:
\begin{verbatim}
type T1 of integer;
type T2 of T1;
type T3 of (integer, T2);
\end{verbatim}

The underlying types of \texttt{integer}, \texttt{T1}, and \texttt{T2} is \texttt{integer}.

The underlying type of \texttt{(integer, T2)} and \texttt{T3} is
\texttt{(integer, T2)}.  Notice how the underlying type does not replace
\texttt{T2} with its own underlying type, in contrast to the structure of
\texttt{T2}, which is \texttt{(integer, integer)}.

\CodeSubsection{\AnonymizeBegin}{\AnonymizeEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[named]{
  \tty \eqname \TNamed(\vx) \\
  \declaredtype(\tenv, \vx) \typearrow \vtone \OrTypeError \\\\
  \makeanonymous(\tenv, \vtone) \typearrow \vt
}{
  \makeanonymous(\tenv, \tty) \typearrow \vt
}
\and
\inferrule[non-named]{
  \astlabel(\tty) \neq \TNamed
}{
  \makeanonymous(\tenv, \tty) \typearrow \tty
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.CheckConstrainedInteger \label{sec:TypingRule.CheckConstrainedInteger}}
\hypertarget{def-checkconstrainedinteger}{}
The function
\[
  \checkconstrainedinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \aslto \True \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the type $\vt$ is a \constrainedinteger. If so, the result is $\True$, otherwise a type error is returned.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{well-constrained}):
  \begin{itemize}
    \item $\vt$ is a well-constrained integer;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{parameterized}):
  \begin{itemize}
    \item $\vt$ is a \parameterizedintegertype;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{unconstrained}):
  \begin{itemize}
    \item $\vt$ is an unconstrained integer;
    \item the result is a type error indicating that a constrained integer type is expected.
  \end{itemize}

  \item All of the following apply (\textsc{conflicting\_type}):
  \begin{itemize}
    \item $\vt$ is not an integer type;
    \item the result is a type error indicating the type conflict.
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\CheckConstrainedIntegerBegin}{\CheckConstrainedIntegerEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[well-constrained]{}
{
  \checkconstrainedinteger(\tenv, \TInt(\wellconstrained(\Ignore))) \typearrow \True
}
\and
\inferrule[parameterized]{}
{
  \checkconstrainedinteger(\tenv, \TInt(\parameterized(\Ignore))) \typearrow \True
}
\and
\inferrule[unconstrained]{}
{
  \checkconstrainedinteger(\tenv, \TInt(\unconstrained(\Ignore))) \typearrow \\
  \TypeErrorVal{ConstrainedIntegerExpected}
}
\and
\inferrule[conflicting\_type]{
  \astlabel(\vt) \neq \TInt
}{
  \checkconstrainedinteger(\tenv, \vt) \typearrow \TypeErrorVal{TypeConflict}
}
\end{mathpar}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Relations Over Types \label{chap:relationsovertypes}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We define the following relations over types and operators:
\begin{itemize}
  \item Subtype (\secref{TypingRule.Subtype})
  \item Structural Subtype Satisfaction (\secref{TypingRule.StructuralSubtypeSatisfaction})
  \item Domain Subtype Satisfaction (\secref{TypingRule.DomainSubtypeSatisfaction})
  \item Subtype Satisfaction (\secref{TypingRule.SubtypeSatisfaction})
  \item Type Satisfaction (\secref{TypingRule.TypeSatisfaction})
  \item Type Clash (\secref{TypingRule.TypeClash})
  \item Lowest Common Ancestor (\secref{TypingRule.LowestCommonAncestor})
  \item Checking adequacy of a unary operator for a type (\secref{TypingRule.CheckUnop})
  \item Checking adequacy of a binary operator for a pair of types (\secref{TypingRule.CheckBinop})
\end{itemize}

Finally, we define the following helper functions:
\begin{itemize}
  \item TypingRule.ConstraintsIsStrictPositive (see \secref{TypingRule.ConstraintsIsStrictPositive})
  \item TypingRule.ExprIsStrictPositive (see \secref{TypingRule.ExprIsStrictPositive})
  \item TypingRule.ConstraintsIsNonNegative (see \secref{TypingRule.ConstraintsIsNonNegative})
  \item TypingRule.ExprIsNonNegative (see \secref{TypingRule.ExprIsNonNegative})
\end{itemize}

We also define the helper rule TypingRule.FindNamedLCA (\secref{TypingRule.FindNamedLCA}).

\section{TypingRule.Subtype\label{sec:TypingRule.Subtype}}
The \emph{subtype} relation is a partial order over \underline{named types}.
The \emph{supertype} is the symmetric relation. That is, \tty\ is a supertype of \tsy\ if and only if \tsy\ is a subtype of \tty.

\hypertarget{def-subtypesrel}{}
The predicate
\[
  \subtypesrel(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\Bool}{\vb}
\]

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item all of the following apply (\textsc{reflexive}):
  \begin{itemize}
    \item $\vtone$ and $\vttwo$ are both the same named type;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item all of the following apply (\textsc{transitive}):
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the global static environment maintains that $\idone$ is a subtype of $\idthree$;
    \item testing whether the type named $\idthree$ is a subtype of $\vttwo$ in the static environment $\tenv$
    gives $\vb$.
  \end{itemize}

  \item all of the following apply (\textsc{no\_supertype}):
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the global static environment maintains that $\idone$ does subtype any named type;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item all of the following apply (\textsc{not\_named}):
  \begin{itemize}
    \item at least one of $\vtone$ and $\vttwo$ is not a named type;
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}
\subsection{Example}
In the following example \texttt{subInt} is a subtype of itself and of \texttt{superInt}:
\begin{verbatim}
type superInt of integer;
type subInt of integer subtypes superInt;
\end{verbatim}

\CodeSubsection{\SubtypeBegin}{\SubtypeEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
  \inferrule[reflexive]{}{
    \subtypesrel(\tenv, \TNamed(\id), \TNamed(\id)) \typearrow \True
  }
  \and
  \inferrule[transitive]{
    \idone \neq \idtwo\\
    G^\tenv.\subtypes(\idone) = \idthree\\
    \subtypesrel(\tenv, \TNamed(\idthree), \vttwo) \typearrow \vb
  }{
    \subtypesrel(\tenv, \TNamed(\idone), \TNamed(\idtwo)) \typearrow \vb
  }
  \and
  \inferrule[no\_supertype]{
    \idone \neq \idtwo\\
    G^\tenv.\subtypes(\idone) = \bot
  }{
    \subtypesrel(\tenv, \TNamed(\idone), \TNamed(\idtwo)) \typearrow \False
  }
  \and
  \inferrule[not\_named]{
    (\astlabel(\vtone) \neq \TNamed \lor \astlabel(\vttwo) \neq \TNamed)
  }{
    \subtypesrel(\tenv, \vtone, \vttwo) \typearrow \False
  }
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{NXRX}, \identi{KGKS}, \identi{MTML}, \identi{JVRM}, \identi{CHMP}.}

\section{TypingRule.StructuralSubtypeSatisfaction\label{sec:TypingRule.StructuralSubtypeSatisfaction}}
\hypertarget{def-structsubtypesat}{}
The predicate
\[
  \structsubtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{structurally-subtype-satisfies} a type $\vs$ in environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.
The function assumes that both $\vt$ and $\vs$ are well-typed according to \chapref{typingoftypes}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
\item All of the following apply (\textsc{error1}):
  \begin{itemize}
  \item obtaining the \underlyingtype\ of $\vt$ gives a type error;
  \item the rule results in a type error.
  \end{itemize}

\item All of the following apply (\textsc{error2}):
  \begin{itemize}
    \item obtaining the \underlyingtype\ of $\vt$ gives a type $\vttwo$;
    \item obtaining the \underlyingtype\ of $\vs$ gives a type error;
    \item the rule results in a type error.
    \end{itemize}

\item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
  \item the underlying types of $\vt$ and $\vs$ have different AST labels
  (for example, \texttt{integer} and \texttt{real});
  \item $\vb$ is $\False$.
  \end{itemize}

\item All of the following apply (\textsc{simple}):
  \begin{itemize}
  \item the \underlyingtype\ of $\vt$, $\vttwo$, is either \texttt{integer} (any kind), \texttt{real}, \texttt{string}, or \texttt{bool};
  \item the \underlyingtype\ of $\vs$, $\vstwo$, is either \texttt{integer} (any kind), \texttt{real}, \texttt{string}, or \texttt{bool};
  \item $\vb$ is $\True$ if and only if both $\vttwo$ and $\vstwo$ have the same ASL label.
  \end{itemize}

\item All of the following apply (\textsc{t\_enum}):
  \begin{itemize}
  \item the \underlyingtype\ of $\vt$ is an enumeration type with list of labels $\vlit$, that is, $\TEnum(\vlit)$;
  \item the \underlyingtype\ of $\vs$ is is an enumeration type with list of labels $\vlis$, that is, $\TEnum(\vlis)$;
  \item $\vb$ is $\True$ if and only if $\vlit$ is equal to $\vlis$.
  \end{itemize}

\item All of the following apply (\textsc{t\_bits}):
  \begin{itemize}
  \item the \underlyingtype\ of $\vs$ is a bitvector type with width $\ws$ and bit fields $\bfss$, that is $\TBits(\ws, \bfss)$;
  \item the \underlyingtype\ of $\vt$ is a bitvector type with width $\wt$ and bit fields $\bfst$, that is $\TBits(\wt, \bfst)$;
  \item determining whether the bitwidth $\ws$ is equivalent to $\wt$ in $\tenv$ either yields $\True$ or yields $\False$,
        which short-circuits the entire rule;
  \item determining whether the bit fields $\bfss$ are included in the bit fields $\bfst$ in $\tenv$ yields $\vb$\ProseOrTypeError
  \end{itemize}

\item All of the following apply (\textsc{t\_array\_expr}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtype\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are equivalent in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array length expression with $\vlengthexprs$, that is \\ $\ArrayLengthExpr(\vlengthexprs)$;
  \item $\vlengtht$ is an array length expression with $\vlengthexprt$, that is \\ $\ArrayLengthExpr(\vlengthexprt)$;
  \item determining whether expressions $\vlengthexprs$ and $\vlengthexprt$ are equivalent gives $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array\_enum}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtype\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are equivalent in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array with indices taken from the enumeration $\vnames$, that is $\ArrayLengthEnum(\vnames, \Ignore)$;
  \item $\vlengtht$ is an array with indices taken from the enumeration $\vnamet$, that is $\ArrayLengthEnum(\vnamet, \Ignore)$;
  \item $\vb$ is $\True$ if and only if $\vnames$ and $\vnamet$ are the same.
  \end{itemize}

\item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of a tuple with type list $\vlis$, that is $\TTuple(\vlis)$;
  \item $\vt$ has the \underlyingtype\ of a tuple with type list $\vlit$, that is $\TTuple(\vlit)$;
  \item equating the lengths of $\vlis$ and $\vlit$ is either $\True$ or $\False$, which short-circuits
  the entire rule with $\vb=\False$;
  \item checking at each index $\vi$ of the list $\vlis$ whether the type $\vlit[\vi]$ \typesatisfies\ the type $\vlis[\vi]$
  yields $\vb_\vi$\ProseOrTypeError;
  \item $\vb$ is $\True$ if and only if all $\vb_\vi$ are $\True$;
  \end{itemize}

\item All of the following apply (\textsc{structured}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ $L(\vfieldss)$, which is a \structuredtype;
  \item $\vt$ has the \underlyingtype\ $L(\vfieldst)$, which is a \structuredtype;
  \item since both underlying types have the same AST label they are either both record types or both exception types;
  \item $\vb$ is $\True$ if and only if for each field in $\vfieldss$ with type $\vtys$
  there exists a field in $\vfieldst$ with type $\vtyt$ such that both $\vtys$ and $\vtyt$
  are determined to be \typeequivalent\ in $\tenv$.
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\StructuralSubtypeSatisfactionBegin}{\StructuralSubtypeSatisfactionEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
  \inferrule[error1]{
    \makeanonymous(\tenv, \vt) \typearrow \TypeErrorConfig
  }
  {
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
  }
  \and
  \inferrule[error2]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \TypeErrorConfig
  }
  {
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
  }
  \and
  \inferrule[different\_labels]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \astlabel(\vttwo) \neq \astlabel(\vstwo)
  }
  {
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \False
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[simple]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \astlabel(\vttwo) \in \{\TInt, \TReal, \TString, \TBool\}\\
    \vb \eqdef \astlabel(\vstwo) = \astlabel(\vttwo)
  }{
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \makeanonymous(\tenv, \vt) \typearrow \TEnum(\vlit)\\
  \makeanonymous(\tenv, \vs) \typearrow \TEnum(\vlis)\\
  \vb \eqdef \vlit = \vlis
}{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \makeanonymous(\tenv, \vs) \typearrow \TBits(\ws, \bfss)\\
  \makeanonymous(\tenv, \vt) \typearrow \TBits(\wt, \bfst)\\
  \bitwidthequal(\tenv, \ws, \wt) \typearrow \True \terminateas \False\\
  \bitfieldsincluded(\tenv, \bfss, \bfst) \typearrow \vb \OrTypeError
}{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_expr]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True \terminateas \False\\
  \booltrans{\astlabel(\vlengths) = \astlabel(\vlengtht)} \booltransarrow \True \terminateas \False\\
  \vlengths \eqname \ArrayLengthExpr(\vlengthexprs)\\
  \vlengtht \eqname \ArrayLengthExpr(\vlengthexprt)\\
  \exprequal(\tenv, \vlengthexprs, \vlengthexprt) \typearrow \vb
}{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\and
\inferrule[t\_array\_enum]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True\\
  \booltrans{\astlabel(\vlengths) = \astlabel(\vlengtht)} \typearrow \True\\
  \vlengths \eqname \ArrayLengthEnum(\vnames, \Ignore)\\
  \vlengtht \eqname \ArrayLengthEnum(\vnamet, \Ignore)\\
  \vb \eqdef \vnames = \vnamet
}{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]
{ \makeanonymous(\tenv, \vs) \typearrow\TTuple(\vlis)\\
  \makeanonymous(\tenv, \vt) \typearrow\TTuple(\vlit)\\
  \equallength(\vlis, \vlit) \typearrow\True \terminateas \False\\
  \vi\in\listrange(\vlis): \typesat(\tenv, \vlit[\vi], \vlis[\vi]) \typearrow \vb_i \terminateas \TTypeError\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_\vi
}{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\hypertarget{def-fieldnames}{}
For a list of typed fields $\fields$, we define the set of its field identifiers as:
\[
  \fieldnames(\fields) \triangleq \{ \id \;|\; (\id, \vt) \in \fields\}
\]
\hypertarget{def-fieldtype}{}
We define the type associated with the field name $\id$ in a list of typed fields $\fields$,
if there is a unique one, as follows:
\[
  \fieldtype(\fields, \id) \triangleq
  \begin{cases}
  \vt  & \text{ if }\{ \vtp \;|\; (\id,\vtp) \in \fields\} = \{\vt\}\\
  \bot & \text{ otherwise}
  \end{cases}
\]

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\
  \makeanonymous(\tenv, \vs)\typearrow L(\vfieldss) \\
  \makeanonymous(\tenv, \vt)\typearrow L(\vfieldst) \\
  \vnamess \eqdef \fieldnames(\vfieldss)\\
  \vnamest \eqdef \fieldnames(\vfieldst)\\
  \booltrans{\vnamess \subseteq \vnamest} \booltransarrow \True \terminateas \False\\
  (\id,\vtys)\in\vfieldss: \typeequal(\tenv, \vtys, \fieldtype(\vfieldst, \id)) \typearrow \vb_\id\\
  \vb \eqdef \bigwedge_{\id \in \vnamess} \vb_\id
}{
  \structsubtypesat(\tenv, \vs, \vt) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{TRVR}, \identi{SJDC}, \identi{MHYB}, \identi{TWTZ}, \identi{GYSK}, \identi{KXSD}.}

\section{TypingRule.DomainSubtypeSatisfaction\label{sec:TypingRule.DomainSubtypeSatisfaction}}
\hypertarget{def-domsubtypesat}{}
The predicate
\[
  \domsubtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{domain-subtype-satisfies} a type $\vs$ in environment $\tenv$,\\
\underline{assuming that $\vt$ structurally-subtype-satisfies $\vs$},
returning the result $\vb$ or a type error, if one is detected.
The function assumes that both $\vt$ and $\vs$ are well-typed according to \chapref{typingoftypes}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{error1}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type error;
    \item the rule gives a type error.
  \end{itemize}

  \item All of the following apply (\textsc{error2}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type $\vsstruct$;
    \item obtaining the \structure\ of $\vt$ results in a type error;
    \item the rule gives a type error.
  \end{itemize}

  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type $\vsstruct$;
    \item the AST label of $\vsstruct$ is either $\TTuple$, $\TArray$, $\TRecord$, or $\TException$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{symbolic}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type $\vsstruct$;
    \item obtaining the \structure\ of $\vt$ results in a type $\vtstruct$;
    \item the AST label of $\vsstruct$ is either $\TReal$, $\TString$, $\TBool$, $\TEnum$, or $\TInt$;
    \item determining whether $\vs$ subsumes $\vt$ in $\tenv$ via symbolic reasoning results in $\vb$.
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\DomainSubtypeSatisfactionBegin}{\DomainSubtypeSatisfactionEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[error1]{
  \tstruct(\tenv, \vs) \typearrow \TypeErrorConfig\\
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\and
\inferrule[error2]{
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \tstruct(\tenv, \vt) \typearrow \TypeErrorConfig\\
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\and
\inferrule[simple]{
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \astlabel(\vsstruct) \in \{\TTuple, \TArray, \TRecord, \TException\}
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[symbolic]{
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct\\
  \astlabel(\vsstruct) \in \{\TReal, \TString, \TBool, \TEnum, \TInt\}\\
  \symsubsumes(\tenv, \vsstruct, \vtstruct) \typearrow \vb
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{TRVR}.}

\section{TypingRule.SubtypeSatisfaction\label{sec:TypingRule.SubtypeSatisfaction}}
\hypertarget{def-subtypesat}{}
The predicate
\[
  \subtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{subtype-satisfies} a type $\vs$ in environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.
The function assumes that both $\vt$ and $\vs$ are well-typed according to \chapref{typingoftypes}.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item determining whether $\vt$ structurally-subtype-satisfies $\vs$ yields $\vbone$\ProseOrTypeError;
  \item determining whether $\vt$ domain-subtype-satisfies $\vs$ yields $\vbtwo$;
  \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SubtypeSatisfactionBegin}{\SubtypeSatisfactionEnd}{../types.ml}

\begin{mathpar}
\inferrule{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vbone \OrTypeError\\\\
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{TRVR}, \identi{KNXJ}.}

\section{TypingRule.TypeSatisfaction \label{sec:TypingRule.TypeSatisfaction}}
\hypertarget{def-typesatisfies}{}
The predicate
\[
  \typesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{\typesatisfies} a type $\vs$ in environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.

\hypertarget{def-checktypesat}{}
We also define
\[
  \checktypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \True \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
which is the same as $\typesat$, but yields a type error when \\ $\typesat(\tenv, \vt, \vs)$ is $\False$.

These functions assume that both $\vt$ and $\vs$ are well-typed according to \chapref{typingoftypes}.

\subsection{Prose}
One of the following applies:
 \begin{itemize}
  \item All of the following apply (\textsc{subtypes}):
    \begin{itemize}
    \item $\vt$ subtypes $\vs$ in $\tenv$ ;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{anonymous}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item at least one of $\vt$ and $\vs$ is an anonymous type in $\tenv$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item $\vt$ is a bitvector type with width $\widtht$ and no bitfields;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a bitvector type with width \\
          $\widths$\ProseOrTypeError;
    \item determining whether $\widtht$ and $\widths$ are \bitwidthequivalent\ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{otherwise1}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a $\vsstruct$\ProseOrTypeError;
    \item at least one of $\vt$ and $\vsstruct$ is not a bitvector type;
  \end{itemize}

  \item All of the following apply (\textsc{otherwise2}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a $\vsstruct$\ProseOrTypeError;
    \item both $\vt$ and $\vsstruct$ are bitvector types;
    \item the bitvector type $\vt$ has a non-empty list of bitfields;
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\subsection{Example}
In the specification:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction1.asl}
\texttt{var pair: pairT = (1, dataT1)} is legal since the right-hand-side has
anonymous, non-primitive type \texttt{(integer, T1)}.

\subsection{Example}
In the specification:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction2.asl}
\texttt{pair = (1, dataAsInt);} is legal since the right-hand-side has anonymous,
primitive type \texttt{(integer, integer)}.

\subsection{Example}
In the specification:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction3.asl}
\texttt{pair = (1, dataT2);} is illegal since the right-hand-side has anonymous,
non-primitive type \texttt{(integer, T2)} which does not subtype-satisfy named
type \texttt{pairT}.

\CodeSubsection{\TypeSatisfactionBegin}{\TypeSatisfactionEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[subtypes]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \True
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[anonymous]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \vbone \lor \vbtwo\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \True
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \vt \eqname \TBits(\widtht, \emptylist)\\
  \tstruct(\tenv, \vs) \typearrow \TBits(\widths, \Ignore) \OrTypeError\\\\
  \bitwidthequal(\tenv, \widtht, \widths) \typearrow \vb
}{
  \typesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise1]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \astlabel(\vt) \neq \TBits \lor \astlabel(\vsstruct) \neq \TBits
}{
  \typesat(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise2]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \astlabel(\vt) = \TBits \land \astlabel(\vsstruct) = \TBits\\
  \vt \eqname \TBits(\widtht, \bitfields)\\
  \bitfields \neq \emptylist
}{
  \typesat(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

The rules for the checked type-satisfy predicate are:
\begin{mathpar}
\inferrule[true]{
  \typesat(\tenv, \vt, \vs) \typearrow \True \OrTypeError\\
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \typesat(\tenv, \vt, \vs) \typearrow \False
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \TypeErrorVal{TypeConflict}
}
\end{mathpar}

\subsection{Comments}
Since the subtype relation is a partial order, it is reflexive. Therefore
every type $\vt$ is a subtype of itself, and as a consequence, every type $\vt$
\typesatisfies\  itself.

\lrmcomment{This is related to \identr{FMXK} and \identi{NLFD}.}

\section{TypingRule.TypeClash\label{sec:TypingRule.TypeClash}}
\hypertarget{def-typeclashes}{}
The predicate
\[
  \typeclashes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{type-clashes} with a type $\vs$ in environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.

\subsection{Prose}
 One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{subtype1}, \textsc{subtype2}):
  \begin{itemize}
    \item either $\vs$ subtypes $\vt$ or $\vt$ subtypes $\vs$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields $\vsstruct$\ProseOrTypeError;
    \item both $\vtstruct$ and $\vsstruct$ are one of the following types: \\ \texttt{integer}, \texttt{real}, \texttt{string};
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_enum}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields an enumeration type with labels $\vlit$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields an enumeration type with labels $\vlis$;
    \item $\vb$ is $\True$ if and only if $\vlis$ and $\vlit$ are equal.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields an array type with element type $\vtyt$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields an array type with element type $\vtys$;
    \item $\vb$ is $\True$ if and only if $\vtyt$ and $\vtys$ type-clash.
  \end{itemize}

  \item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a tuple type with element types $\vt_{1..k}$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a tuple type with element types $\vs_{1..n}$;
    \item if $n \neq k$ the rule short-circuits with $\vb=\False$;
    \item $\vb$ is $\True$ if and only if $\vt_i$ type-clashes with $\vs_i$, for all $i=1..k$.
  \end{itemize}

  \item All of the following apply (\textsc{otherwise\_different\_labels}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields $\vsstruct$;
    \item $\vsstruct$ and $\vtstruct$ have different AST labels;
    \item $\vb$ is $\False$;
  \end{itemize}

  \item All of the following apply (\textsc{otherwise\_structured}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields $\vsstruct$;
    \item $\vsstruct$ and $\vtstruct$ have the same AST label;
    \item $\vtstruct$ (and thus $\vsstruct$) is a \structuredtype;
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\TypeClashBegin}{\TypeClashEnd}{../types.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[subtype1]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \True
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[subtype2]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \True
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[simple]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \OrTypeError \\
  \astlabel(\vtstruct)=\astlabel(\vsstruct)\\
  \astlabel(\vtstruct) \in \{\TInt, \TReal, \TString, \TBits\}
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \TEnum(\Ignore, \vlis) \\
  \tstruct(\tenv, \vs) \typearrow \TEnum(\Ignore, \vlit)
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\vlis = \vlit}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \TArray(\Ignore, \vtyt) \\
  \tstruct(\tenv, \vs) \typearrow \TArray(\Ignore, \vtys) \\
  \typeclashes(\tenv, \vtyt, \vtys) \typearrow \vb
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) \typearrow \TTuple(\vs_{1..n}) \\
  \booltrans{n = k} \booltransarrow \True \terminateas \False\\
  i=1..k: \typeclashes(\tenv, \vt_i, \vs_i) \typearrow \vb_i\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_i
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise\_different\_labels]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \\
  \astlabel(\vtstruct) \neq \astlabel(\vsstruct)
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise\_structured]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \\
  \astlabel(\vtstruct) = \astlabel(\vsstruct)\\
  \vb \eqdef \astlabel(\vtstruct) \in \{\TRecord, \TException\}\\
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\subsection{Comments}
Note that if $\vt$ subtype-satisfies $\vs$ then $\vt$ and $\vs$ type-clash, but not the other
way around.

Note that type-clashing is an equivalence relation. Therefore if $\vt$
type-clashes with \texttt{A} and \texttt{B} then it is also the case that \texttt{A} and \texttt{B} type-clash.

\lrmcomment{This is related to \identd{VPZZ}, \identi{PQCT} and \identi{WZKM}.}

\section{TypingRule.LowestCommonAncestor \label{sec:TypingRule.LowestCommonAncestor}}
\hypertarget{def-lowestcommonancestor}{}
Annotating a conditional expression (see \secref{TypingRule.ECond}),
requires finding a single type that can be used to annotate the results of both subexpressions.
The function
\[
  \lca(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\ty}{\tty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the \emph{lowest common ancestor} of types $\vt$ and $\vs$ in $\tenv$ --- $\tty$.
The result is a type error if a lowest common ancestor does not exist or a type error is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{type\_equal}):
  \begin{itemize}
    \item $\vt$ is \typeequal\ to $\vs$ in $\tenv$;
    \item $\tty$ is $\vs$ (can as well be $\vt$).
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\vt$ is not \typeequal\ to $\vs$ in $\tenv$ and one of the following applies:

    \item All of the following apply (\textsc{named\_subtype1}):
    \begin{itemize}
      \item $\vt$ is a named type with identifier $\namesubt$, that is, $\TNamed(\namesubt)$;
      \item $\vs$ is a named type with identifier $\namesubs$, that is, $\TNamed(\namesubs)$;
      \item there is no \namedlowestcommonancestor\ of $\namesubs$ and $\namesubt$ in $\tenv$;
      \item obtaining the \underlyingtype\ of $\vs$ yields $\vanons$\ProseOrTypeError;
      \item obtaining the \underlyingtype\ of $\vt$ yields $\vanont$\ProseOrTypeError;
      \item obtaining the lowest common ancestor of $\vanons$ and $\vanont$ in $\tenv$ yields $\tty$\ProseOrTypeError.
    \end{itemize}

    \item All of the following apply (\textsc{named\_subtype2}):
    \begin{itemize}
      \item $\vt$ is a named type with identifier $\namesubt$, that is, $\TNamed(\namesubt)$;
      \item $\vs$ is a named type with identifier $\namesubs$, that is, $\TNamed(\namesubs)$;
      \item the \namedlowestcommonancestor\ of $\namesubs$ and $\namesubt$ in $\tenv$ is \\
            $\name$\ProseOrTypeError;
      \item $\tty$ is the named type with identifier $\name$, that is, $\TNamed(\name)$.
    \end{itemize}

    \item All of the following apply (\textsc{one\_named1}):
    \begin{itemize}
      \item only one of $\vt$ or $\vs$ is a named type;
      \item obtaining the \underlyingtype\ of $\vs$ yields $\vanons$\ProseOrTypeError;
      \item obtaining the \underlyingtype\ of $\vt$ yields $\vanont$\ProseOrTypeError;
      \item $\vanont$ is \typeequal\ to $\vanons$;
      \item $\tty$ is $\vt$ if it is a named type (that is, $\astlabel(\vt)=\TNamed$), and $\vs$ otherwise.
    \end{itemize}

    \item All of the following apply (\textsc{one\_named2}):
    \begin{itemize}
      \item only one of $\vt$ or $\vs$ is a named type;
      \item obtaining the \underlyingtype\ of $\vs$ yields $\vanons$\ProseOrTypeError;
      \item obtaining the \underlyingtype\ of $\vt$ yields $\vanont$\ProseOrTypeError;
      \item $\vanont$ is not \typeequal\ to $\vanons$;
      \item the lowest common ancestor of $\vanont$ and $\vanons$ in $\tenv$ is $\tty$\ProseOrTypeError.
    \end{itemize}

    \item All of the following apply (\textsc{t\_int\_unconstrained}):
    \begin{itemize}
      \item at least one of $\vt$ or $\vs$ is an unconstrained integer type;
      \item $\tty$ is the unconstrained integer type.
    \end{itemize}

    \item All of the following apply (\textsc{t\_int\_parameterized}):
    \begin{itemize}
      \item neither $\vt$ nor $\vs$ are the unconstrained integer type;
      \item one of $\vt$ and $\vs$ is a \parameterizedintegertype;
      \item the \wellconstrainedversion\ of $\vt$ is $\vtone$;
      \item the \wellconstrainedversion\ of $\vs$ is $\vsone$;
      \item $\tty$ the lowest common ancestor of $\vtone$ and $\vsone$ in $\tenv$ is $\tty$\ProseOrTypeError.
    \end{itemize}

    \item All of the following apply (\textsc{t\_int\_wellconstrained}):
    \begin{itemize}
      \item $\vt$ is a well-constrained integer type with constraints $\cst$;
      \item $\vs$ is a well-constrained integer type with constraints $\css$;
      \item $\tty$ is the well-constrained integer type with constraints $\cst \concat \css$.
    \end{itemize}

    \item All of the following apply (\textsc{t\_bits\_equal}):
    \begin{itemize}
      \item $\vt$ is a bitvector type with with length expression $\vet$, that is, $\TBits(\vet, \Ignore)$;
      \item $\vs$ is a bitvector type with with length expression $\ves$, that is, $\TBits(\ves, \Ignore)$;
      \item $\vet$ is equivalent to $\ves$ in $\tenv$;
      \item $\tty$ is a bitvector type with length expression $\vet$ and an empty bitfield list, that is, $\TBits(\vet, \emptylist)$.
    \end{itemize}

    \item All of the following apply (\textsc{t\_bits\_not\_equal}):
    \begin{itemize}
      \item $\vt$ is a bitvector type with length expression $\vet$;
      \item $\vs$ is a bitvector type with length expression $\ves$;
      \item $\vet$ is not equivalent to $\ves$ in $\tenv$;
      \item the result is a type error indicating the lack of a lowest common ancestor.
    \end{itemize}

    \item All of the following apply (\textsc{t\_array\_equal}):
    \begin{itemize}
      \item $\vt$ is an array type with width expression $\widtht$ and element type $\vtyt$;
      \item $\vs$ is an array type with width expression $\widths$ and element type $\vtys$;
      \item $\widtht$ is equivalent to $\widths$ in $\tenv$;
      \item the lowest common ancestor of $\vtyt$ and $\vtys$ is $\vtone$\ProseOrTypeError;
      \item $\tty$ is an array type with width expression $\widths$ and element type $\vtone$.
    \end{itemize}

    \item All of the following apply (\textsc{t\_array\_not\_equal}):
    \begin{itemize}
      \item $\vt$ is an array type with width expression $\widtht$ and element type $\vtyt$;
      \item $\vs$ is an array type with width expression $\widths$ and element type $\vtys$;
      \item $\widtht$ is not equivalent to $\widths$ in $\tenv$;
      \item the result is a type error indicating the lack of a lowest common ancestor.
    \end{itemize}

    \item All of the following apply (\textsc{t\_tuple}):
    \begin{itemize}
      \item $\vt$ is a tuple type with type list $\vlit$;
      \item $\vs$ is a tuple type with type list $\vlis$;
      \item checking whether $\vlit$ and $\vlis$ have the same number of elements yields $\True$
            or a type error, which short-circuits the entire rule (indicating that the number of elements in both tuples is expected
            to be the same and thus there is no lowest common ancestor);
      \item $\vli[\vi]$ is the of types lowest common ancestor of $\vlit[\vi]$ and $\vlis[\vi]$, for every position of $\vlit$;
      \item $\tty$ is the tuple type with list of types $\vli$, that is, $\TTuple(\vli)$.
    \end{itemize}

    \item All of the following apply (\textsc{labels}):
    \begin{itemize}
      \item either the AST labels of $\vt$ and $\vs$ are different, or one of them is $\TEnum$, $\TRecord$, or $\TException$;
      \item the result is a type error indicating the lack of a lowest common ancestor.
    \end{itemize}
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LowestCommonAncestorBegin}{\LowestCommonAncestorEnd}{../types.ml}

\subsection{Formally}
Since we do not impose a canonical representation on types (e.g., \verb|integer {1, 2}| is equivalence to \verb|integer {1..2}|),
the lowest common ancestor is not unique.
We define $\lca(\tenv, \vt, \vs)$ to be any type $\vtp$ that is \typeequivalent\ to the lowest common ancestor of $\vt$ and $\vs$.

\begin{mathpar}
\inferrule[type\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \True
}{
  \lca(\tenv, \vt, \vs) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[named\_subtype1]{
  \vt = \TNamed(\namesubs)\\
  \vs = \TNamed(\namesubt)\\
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \namedlca(\tenv, \namesubs, \namesubt) \typearrow \None \OrTypeError\\\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\\\
  \lca(\tenv, \vanont, \vanons) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[named\_subtype2]{
  \vt = \TNamed(\namesubs)\\
  \vs = \TNamed(\namesubt)\\
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \namedlca(\tenv, \namesubs, \namesubt) \typearrow \langle\name\rangle \OrTypeError\\
}{
  \lca(\tenv, \vt, \vs) \typearrow \TNamed(\name)
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_named1]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) = \TNamed \lor \astlabel(\vs) = \TNamed)\\
  \astlabel(\vt) \neq \astlabel(\vs)\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\\\
  \typeequal(\tenv, \vanont, \vanons) \typearrow \True\\
  \tty \eqdef \choice{\astlabel(\vt) = \TNamed}{\vt}{\vs}
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_named2]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) = \TNamed \lor \astlabel(\vs) = \TNamed)\\
  \astlabel(\vt) \neq \astlabel(\vs)\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\\\
  \typeequal(\tenv, \vanont, \vanons) \typearrow \False\\
  \lca(\tenv, \vanont, \vanons) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_int\_unconstrained]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \isunconstrainedinteger(\vt) \lor \isunconstrainedinteger(\vs)
}{
  \lca(\tenv, \vt, \vs) \typearrow \unconstrainedinteger
}
\and
\inferrule[t\_int\_parameterized]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \neg\isunconstrainedinteger(\vt)\\
  \neg\isunconstrainedinteger(\vs)\\
  \isparameterizedinteger(\vt) \lor \isparameterizedinteger(\vs)\\
  \towellconstrained(\tenv, \vt) \typearrow \vtone\\
  \towellconstrained(\tenv, \vs) \typearrow \vsone\\
  \lca(\tenv, \vtone, \vsone) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\and
\inferrule[t\_int\_wellconstrained]
{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \vt \eqname \TInt(\wellconstrained(\cst))\\
  \vs \eqname \TInt(\wellconstrained(\css))
}{
  \lca(\tenv, \vt, \vs) \typearrow \TInt(\wellconstrained(\cst \concat \css))
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TBits(\vet, \Ignore)\\
  \vs \eqname \TBits(\ves, \Ignore)\\
  \exprequal(\tenv, \vet, \ves) \typearrow \True
}{
  \lca(\tenv, \vt, \vs) \typearrow \TBits(\vet, \emptylist)
}
\and
\inferrule[t\_bits\_not\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TBits(\vet, \Ignore)\\
  \vs \eqname \TBits(\ves, \Ignore)\\
  \exprequal(\tenv, \vet, \ves) \typearrow \False
}{
  \lca(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\NoLCA}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TArray(\widtht, \vtyt)\\
  \vs \eqname \TArray(\widths, \vtys)\\
  \arraylengthequal(\tenv, \widtht, \widths) \typearrow \True\\
  \lca(\tenv, \vtyt, \vtys) \typearrow \vtone \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \TArray(\widtht, \vtone)
}
\and
\inferrule[t\_array\_not\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TArray(\widtht, \vtyt)\\
  \vs \eqname \TArray(\widths, \vtys)\\
  \arraylengthequal(\tenv, \widtht, \widths) \typearrow \False
}{
  \lca(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\NoLCA}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TTuple(\vlit)\\
  \vs \eqname \TTuple(\vlis)\\
  \equallength(\vlit, \vlis) \typearrow \vb\\
  \checktrans{\vb}{NoLCA/TuplesHaveDifferentLengths} \typearrow \True \OrTypeError\\\\
  {
    \begin{array}{r}
  \vi\in\listrange(\vlit): \lca(\tenv, \vlit[\vi], \vlis[\vi]) \typearrow \\
   \vli[\vi] \OrTypeError
    \end{array}
  }\\
  \vli \eqdef [\vi\in\listrange(\vlit): \vli[\vi]]
}{
  \lca(\tenv, \vt, \vs) \typearrow \TTuple(\vli)
}
\end{mathpar}

\begin{mathpar}
\inferrule[labels]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) \neq \astlabel(\vs)) \lor
  \astlabel(\vt) \in \{\TEnum, \TRecord, \TException\}
}{
  \lca(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\NoLCA}
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{YZHM}.}

\section{TypingRule.CheckUnop \label{sec:TypingRule.CheckUnop}}
\hypertarget{def-checkunop}{}
The function
\[
  \CheckUnop(\overname{\staticenvs}{\tenv} \aslsep \overname{\unop}{\op} \aslsep \overname{\ty}{\vt})
  \aslto \overname{\ty}{\vs} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
determines the result type of applying a unary operator when the type of its operand is known.
Similarly, we determine the negation of integer constraints.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
\item All of the following apply (\textsc{bnot\_t\_bool}):
  \begin{itemize}
    \item $\op$ is $\BNOT$;
    \item determining whether $\vt$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vs$ is $\TBool$;
  \end{itemize}

\item All of the following apply (\textsc{neg\_error}):
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\TReal$ yields $\False$\ProseOrTypeError;
  \item determining whether $\vt$ \typesatisfies\ $\unconstrainedinteger$ yields $\False$\ProseOrTypeError;
  \item the result is a type error indicating the $\NEG$ is appropriate only for \texttt{real} and \texttt{integer} types;
\end{itemize}

\item All of the following apply (\textsc{neg\_t\_real}):
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\TReal$ yields $\True$;
  \item $\vs$ is $\TReal$;
\end{itemize}

\item All of the following apply (\textsc{neg\_t\_int\_unconstrained}):
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\unconstrainedinteger$ yields $\True$;
  \item obtaining the \wellconstrainedstructure\ of $\vt$ yields $\unconstrainedinteger$\ProseOrTypeError;
  \item $\vs$ is $\unconstrainedinteger$;
\end{itemize}

\item All of the following apply (\textsc{neg\_t\_int\_well\_constrained}):
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\unconstrainedinteger$ yields $\True$\ProseOrTypeError;
  \item obtaining the \wellconstrainedstructure\ of $\vt$ yields the well-constrained integer type with constraints $\vcs$\ProseOrTypeError;
  \item negating the constraints in $\vcs$ (see $\negateconstraint$) yields $\vcsnew$;
  \item $\vs$ is the well-constrained integer type with constraints $\vcsnew$, that is, \\
  $\TInt(\wellconstrained(\vcsnew))$;
\end{itemize}

\item All of the following apply (\textsc{not\_t\_bits}):
  \begin{itemize}
  \item $\op$ is $\NOT$;
  \item $\vt$ has the structure of a bitvector;
  \item $\vs$ is $\vt$.
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\CheckUnopBegin}{\CheckUnopEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[bnot\_t\_bool]{
  \checktypesat(\tenv, \vtone, \TBool) \typearrow \True \OrTypeError\\
}{
  \CheckUnop(\tenv, \BNOT, \vtone) \typearrow \TBool
}
\end{mathpar}

\hypertarget{def-negateconstraint}{}
We now define the helper function
\[
  \negateconstraint(\intconstraint) \aslto \intconstraint
\]
which takes an integer constraint and returns the constraint that corresponds to the negation of all
the values it represents:

\begin{mathpar}
\inferrule{}
{
  \negateconstraint(\ConstraintExact(\ve)) \typearrow \ConstraintExact(\EUnop(\MINUS, \ve))
}
\and
\inferrule{}
{
  \negateconstraint(\ConstraintRange(\vvtop, \vbot)) \typearrow \\
  \ConstraintRange(\EUnop(\MINUS, \vbot), \EUnop(\MINUS, \vvtop))
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_error]{
  \typesat(\tenv, \vt, \unconstrainedinteger) \typearrow \False \OrTypeError\\\\
  \typesat(\tenv, \vt, \TReal) \typearrow \False \OrTypeError\\
}{
  \CheckUnop(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \TypeErrorVal{InappropriateTypeForNeg}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_real]{
  \typesat(\tenv, \vt, \TReal) \typearrow \True
}{
  \CheckUnop(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \overname{\TReal}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_int\_unconstrained]{
  \typesat(\tenv, \vt, \unconstrainedinteger) \typearrow \True\\\\
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \unconstrainedinteger \OrTypeError
}{
  \CheckUnop(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \overname{\unconstrainedinteger}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_int\_well\_constrained]{
  \typesat(\tenv, \vt, \unconstrainedinteger) \typearrow \True\\
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \TInt(\wellconstrained(\vcs))\\
  \vc \in \vcs: \negateconstraint(\vc) \typearrow \vneg_\vc\\
  \vcsnew \eqdef [\vc \in \vcs: \vneg_\vc]
}{
  \CheckUnop(\tenv, \overname{\NEG}{\op}, \vt) \typearrow \overname{\TInt(\wellconstrained(\vcsnew))}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_t\_bits]{
  \checkstructurelabel(\tenv, \vt, \TBits) \typearrow \True \OrTypeError
}{
  \CheckUnop(\tenv, \overname{\NOT}{\op}, \vt) \typearrow \vt
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.CheckBinop \label{sec:TypingRule.CheckBinop}}
\hypertarget{def-checkbinop}{}
The function
\[
  \CheckBinop(\overname{\staticenvs}{\tenv} \aslsep \overname{\binop}{\op} \aslsep \overname{\ty}{\vtone}
  \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\ty}{\vt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
determines the result type $\vt$ of applying the binary operator $\op$
to operands of type $\vtone$ and $\vttwo$ in the static environment $\tenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{boolean}):
  \begin{itemize}
    \item $\op$ is $\AND$, $\OR$, $\EQOP$ or $\IMPL$;
    \item determining whether $\vtone$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item determining whether $\vttwo$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{bits\_bool}):
  \begin{itemize}
    \item $\op$ is $\AND$, $\OR$, or $\EOR$;
    \item checking whether $\vtone$ and $\vttwo$ have the \structure\ of bitvector types
          of the same width in $\tenv$ yields $\True$\ProseOrTypeError;
    \item the bitvector width of $\vtone$ in $\tenv$ is $\vw$;
    \item $\vt$ is the bitvector type of width $\vw$ and empty list of bitfields, that is, \\ $\TBits(\vw, \emptylist)$.
  \end{itemize}

  \item All of the following apply (\textsc{plus\_minus\_error}):
  \begin{itemize}
    \item $\op$ is $\PLUS$ or $\MINUS$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ is $\vtonestruct$\ProseOrTypeError;
    \item $\vtonestruct$ is neither a bitvector type nor an integer type;
    \item the result is a type error indicating that the type of $\vtone$ is inappropriate for $\op$.
  \end{itemize}

  \item All of the following apply (\textsc{plus\_minus\_bits\_int}):
  \begin{itemize}
    \item $\op$ is $\PLUS$ or $\MINUS$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ is $\vtonestruct$\ProseOrTypeError;
    \item $\vtonestruct$ is a bitvector type;
    \item $\vttwo$ \typesatisfies\ the unconstrained integer type in $\tenv$;
    \item obtaining the bitwidth of $\vtone$ in $\tenv$ yields $\vw$.
    \item $\vt$ is the bitvector type of width $\vw$ and empty list of bitfields, that is, \\ $\TBits(\vw, \emptylist)$.
  \end{itemize}

  \item All of the following apply (\textsc{plus\_minus\_bits\_bits}):
  \begin{itemize}
    \item $\op$ is $\PLUS$ or $\MINUS$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ is a bitvector of width $\veone$, that is,\\ $\TBits(\veone, \Ignore)$;
    \item $\vttwo$ does not \typesatisfy\ the unconstrained integer type in $\tenv$
    \item obtaining the \structure\ of $\vttwo$ in $\tenv$ is $\vttwostruct$\ProseOrTypeError;
    \item determining whether $\vttwostruct$ has a bitvector type yields $\True$\ProseOrTypeError;
    \item $\vttwostruct$ is a bitvector of width $\vwtwo$, that is, $\TBits(\vwtwo, \Ignore)$;
    \item determining whether $\vwone$ and $\vwtwo$ are equal bitwidths yields $\vb$;
    \item $\vb$ is $\True$\ProseOrTypeError;
    \item $\vt$ is the bitvector type of width $\vwone$ and empty list of bitfields, that is, \\ $\TBits(\vwone, \emptylist)$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_error}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\vtoneanon$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\vttwoanon$\ProseOrTypeError;
    \item the AST labels of $\vtoneanon$ and $\vttwoanon$ are different or one of them is not in
          $\{\TInt, \TReal, \TBool, \TBits, \TEnum\}$;
    \item the result is a type error indicating that the types of $\vtone$ and $\vttwo$ are inappropriate for $\op$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_bits}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\vtoneanon$\ProseOrTypeError;
    \item $\vtoneanon$ is a bitvector type;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\vttwoanon$\ProseOrTypeError;
    \item $\vttwoanon$ is a bitvector type;
    \item checking whether the bitwidth of $\vtoneanon$ and $\vttwoanon$ is the same yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_bool}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\TBool$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\TBool$\ProseOrTypeError;
    \item checking whether $\vtoneanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item checking whether $\vttwoanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_real}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\TReal$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\TReal$\ProseOrTypeError;
    \item checking whether $\vtoneanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item checking whether $\vttwoanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_string}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\TString$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\TString$\ProseOrTypeError;
    \item checking whether $\vtoneanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item checking whether $\vttwoanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_enum}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\TEnum(\vlione)$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\TEnum(\vlitwo)$\ProseOrTypeError;
    \item checking whether $\vlione$ is equal to $\vlitwo$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{relational}):
  \begin{itemize}
    \item $\op$ is one of $\LT$, $\LEQ$, $\GT$, and $\GEQ$;
    \item determining whether both $\vtone$ and $\vttwo$ \typesatisfy\ the unconstrained integer type in $\tenv$
          or both $\vtone$ and $\vttwo$ \typesatisfy\ the \texttt{real} type in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{arith\_error}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ yields $\vtonestruct$\ProseOrTypeError;
    \item obtaining the \structure\ of $\vttwo$ in $\tenv$ yields $\vttwostruct$\ProseOrTypeError;
    \item the operator and the AST labels of $\vtonestruct$ and $\vttwostruct$ do not match any of the rows in the following table:

    \begin{center}
    \begin{tabular}{lll}
      \op    & $\astlabel(\vtonestruct)$ & $\astlabel(\vttwostruct)$\\
      \hline
      \MUL   & \TInt  & \TInt\\
      \DIV   & \TInt  & \TInt\\
      \DIVRM & \TInt  & \TInt\\
      \MOD   & \TInt  & \TInt\\
      \SHL   & \TInt  & \TInt\\
      \SHR   & \TInt  & \TInt\\
      \POW   & \TInt  & \TInt\\
      \PLUS  & \TInt  & \TInt\\
      \MINUS & \TInt  & \TInt\\
      \PLUS  & \TReal & \TReal\\
      \MINUS & \TReal & \TReal\\
      \MUL   & \TReal & \TReal\\
      \RDIV  & \TReal & \TReal\\
      \POW   & \TReal & \TInt\\
    \end{tabular}
  \end{center}
    \item the result is a type error indicating that the types of $\vtone$ and $\vttwo$ are inappropriate for $\op$.
  \end{itemize}

  \item All of the following apply (\textsc{arith\_t\_int\_unconstrained1}, \\
                                    \textsc{arith\_t\_int\_unconstrained2}):
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}$;
    \item the \wellconstrainedstructure\ of either $\vtone$ or $\vttwo$ in $\tenv$ is that of the unconstrained integer type;
    \item $\vt$ is the unconstrained integer type;
  \end{itemize}

  \item All of the following apply (\textsc{arith\_t\_int\_wellconstrained1}):
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \POW, \PLUS, \MINUS\}$;
    \item the \wellconstrainedstructure\ of either $\vtone$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcsone$;
          \item the \wellconstrainedstructure\ of either $\vttwo$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcstwo$;
    \item applying $\op$ to $\vcsone$ and $\vcstwo$ in $\tenv$ yields $\vcs$;
    \item $\vt$ is the well-constrained integer type with constraints $\vcs$;
  \end{itemize}

  \item All of the following apply (\textsc{arith\_t\_int\_wellconstrained2}):
  \begin{itemize}
    \item $\op$ is one of $\{\DIVRM, \DIV, \MOD\}$;
    \item the \wellconstrainedstructure\ of either $\vtone$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcsone$;
          \item the \wellconstrainedstructure\ of either $\vttwo$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcstwo$;
    \item checking whether $\vcstwo$ represents strictly-positive integers yields $\True$\ProseOrTypeError;
    \item applying $\op$ to $\vcsone$ and $\vcstwo$ in $\tenv$ yields $\vcs$;
    \item $\vt$ is the well-constrained integer type with constraints $\vcs$;
  \end{itemize}

  \item All of the following apply (\textsc{arith\_t\_int\_wellconstrained3}):
  \begin{itemize}
    \item $\op$ is one of $\{\SHL, \SHR\}$;
    \item the \wellconstrainedstructure\ of either $\vtone$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcsone$;
          \item the \wellconstrainedstructure\ of either $\vttwo$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcstwo$;
    \item checking whether $\vcstwo$ represents non-negative integers yields $\True$\ProseOrTypeError;
    \item applying $\op$ to $\vcsone$ and $\vcstwo$ in $\tenv$ yields $\vcs$;
    \item $\vt$ is the well-constrained integer type with constraints $\vcs$;
  \end{itemize}

  \item All of the following apply (\textsc{plus\_minus\_mul\_real}):
  \begin{itemize}
    \item $\op$ is one of $\{\PLUS, \MINUS, \MUL\}$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ yields $\TReal$;
    \item obtaining the \structure\ of $\vttwo$ in $\tenv$ yields $\TReal$;
    \item $\vt$ is $\TReal$.
  \end{itemize}

  \item All of the following apply (\textsc{pow\_real\_int}):
  \begin{itemize}
    \item $\op$ is one of $\{\PLUS, \MINUS, \MUL\}$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ yields $\TReal$;
    \item obtaining the \structure\ of $\vttwo$ in $\tenv$ yields an integer type;
    \item $\vt$ is $\TReal$.
  \end{itemize}

  \item All of the following apply (\textsc{rdiv}):
  \begin{itemize}
    \item $\op$ is one of $\{\RDIV\}$;
    \item determining whether $\vtone$ \typesatisfies\ $\TReal$ yields $\True$\ProseOrTypeError;
    \item determining whether $\vttwo$ \typesatisfies\ $\TReal$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TReal$.
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\CheckBinopBegin}{\CheckBinopEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[boolean]{
  \op \in  \{\BAND, \BOR, \IMPL, \EQOP\}\\
  \checktypesat(\tenv, \vt1, \TBool) \typearrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vttwo, \TBool) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_bool]{
  \op \in  \{\AND, \OR, \EOR\}\\
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError\\\\
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vw
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBits(\vw, \emptylist)
}
\end{mathpar}

\begin{mathpar}
\inferrule[plus\_minus\_error]{
  \op \in  \{\PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \vtonestruct \OrTypeError\\\\
  \astlabel(\vtonestruct) \not\in \{\TBits,\TInt\}\\
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TypeErrorVal{InappropriateTypeForPlusMinus}
}
\and
\inferrule[plus\_minus\_bits\_int]{
  \op \in  \{\PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \vtonestruct \OrTypeError\\\\
  \astlabel(\vtonestruct) = \TBits\\
  \typesat(\tenv, \vttwo, \unconstrainedinteger) \typearrow \True\\
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vw\\
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBits(\vw, \emptylist)
}
\and
\inferrule[plus\_minus\_bits\_bits]{
  \op \in  \{\PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \TBits(\vwone, \Ignore) \\
  \typesat(\tenv, \vttwo, \unconstrainedinteger) \typearrow \False\\
  \tstruct(\tenv, \vttwo) \typearrow \vttwostruct \OrTypeError\\\\
  \checktrans{\astlabel(\vttwostruct)=\TBits}{\ExpectedBitvectorType} \checktransarrow \True \OrTypeError\\\\
  \vttwostruct \eqname \TBits(\vwtwo, \Ignore)\\
  \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vb\\
  \checktrans{\vb}{DifferentBitwidths} \checktransarrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBits(\vwone, \emptylist)
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_neq\_error]
{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \vtoneanon \OrTypeError\\\\
  \makeanonymous(\tenv, \vttwo) \typearrow \vttwoanon \OrTypeError\\\\
  {
    \left(\begin{array}{ll}
  \astlabel(\vtoneanon) \neq \astlabel(\vttwoanon) & \lor \\
  \astlabel(\vtone) \not\in \{\TInt, \TReal, \TBool, \TBits, \TEnum\} &
    \end{array}\right)
  }
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TypeErrorVal{InappropriateTypeForEQ}
}
\and
\inferrule[eq\_neq\_bits]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \vtoneanon \OrTypeError\\\\
  \astlabel(\vtoneanon) = \TBits\\
  \makeanonymous(\tenv, \vttwo) \typearrow \vttwoanon \OrTypeError\\\\
  \astlabel(\vttwoanon) = \TBits\\
  \checkbitsequalwidth(\tenv, \vtoneanon, \vttwoanon) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\and
\inferrule[eq\_neq\_bool]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \TBool\\
  \makeanonymous(\tenv, \vttwo) \typearrow \TBool\\
  \checktypesat(\tenv, \vtoneanon, \TBool) \typearrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vttwoanon, \TBool) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\and
\inferrule[eq\_neq\_real]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \TReal\\
  \makeanonymous(\tenv, \vttwo) \typearrow \TReal\\
  \checktypesat(\tenv, \vtoneanon, \TReal) \typearrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vttwoanon, \TReal) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\and
\inferrule[eq\_neq\_string]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \TString\\
  \makeanonymous(\tenv, \vttwo) \typearrow \TString\\
  \checktypesat(\tenv, \vtoneanon, \TString) \typearrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vttwoanon, \TString) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\and
\inferrule[eq\_neq\_enum]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \TEnum(\vlione)\\
  \makeanonymous(\tenv, \vttwo) \typearrow \TEnum(\vlitwo)\\
  \checktrans{\vlione = \vlitwo}{DifferentEnumLabels} \checktransarrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\end{mathpar}

\begin{mathpar}
\inferrule[relational]{
  \op \in  \{\LT, \LEQ, \GT, \GEQ\}\\
  \typesat(\tenv, \vtone, \unconstrainedinteger) \typearrow \vbone \OrTypeError\\\\
  \typesat(\tenv, \vttwo, \unconstrainedinteger) \typearrow \vbtwo \OrTypeError\\\\
  \typesat(\tenv, \vtone, \TReal) \typearrow \vbthree \OrTypeError\\\\
  \typesat(\tenv, \vttwo, \TReal) \typearrow \vbfour \OrTypeError\\\\
  \checktrans{\vbone \land \vbtwo \lor \vbthree \land \vbfour}{InappropriateTypeForRel} \checktransarrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_error]{
  \tstruct(\tenv, \vtone) \typearrow \vtonestruct \OrTypeError\\\\
  \tstruct(\tenv, \vttwo) \typearrow \vttwostruct \OrTypeError\\\\
  (\op, \astlabel(\vtonestruct), \astlabel(\vttwostruct)) \not\in
  {
    \left\{
    \begin{array}{lclcl}
      (\MUL   &,& \TInt  &,& \TInt)\\
      (\DIV   &,& \TInt  &,& \TInt)\\
      (\DIVRM &,& \TInt  &,& \TInt)\\
      (\MOD   &,& \TInt  &,& \TInt)\\
      (\SHL   &,& \TInt  &,& \TInt)\\
      (\SHR   &,& \TInt  &,& \TInt)\\
      (\POW   &,& \TInt  &,& \TInt)\\
      (\PLUS  &,& \TInt  &,& \TInt)\\
      (\MINUS &,& \TInt  &,& \TInt)\\
      (\PLUS  &,& \TReal &,& \TReal)\\
      (\MINUS &,& \TReal &,& \TReal)\\
      (\MUL   &,& \TReal &,& \TReal)\\
      (\RDIV  &,& \TReal &,& \TReal)\\
      (\POW   &,& \TReal &,& \TInt)\\
    \end{array}
    \right\}
  }
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TypeErrorVal{InappropriateTypeForBinop}
}
\end{mathpar}

The following two rules are not mutually exclusive, but both yield the same result when they are both active.
\begin{mathpar}
\inferrule[arith\_t\_int\_unconstrained1]{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \unconstrainedinteger\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \TInt(\Ignore)\\
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \unconstrainedinteger
}
\and
\inferrule[arith\_t\_int\_unconstrained2]{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \TInt(\Ignore)\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \unconstrainedinteger\\
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \unconstrainedinteger
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_t\_int\_wellconstrained1]{
  \op \in  \{\MUL, \POW, \PLUS, \MINUS\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \TInt(\wellconstrained(\vcsone))\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \TInt(\wellconstrained(\vcstwo))\\
  \annotateconstraintbinop(\tenv, \op, \vcsone, \vcstwo) \typearrow \vcs
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TInt(\wellconstrained(\vcs))
}
\and
\inferrule[arith\_t\_int\_wellconstrained2]{
  \op \in  \{\DIVRM, \DIV, \MOD\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \TInt(\wellconstrained(\vcsone))\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \TInt(\wellconstrained(\vcstwo))\\
  \constraintsisstrictpositive(\vcstwo) \typearrow \vb\\
  \checktrans{\vb}{DenominatorMustBePositive} \checktransarrow \True \OrTypeError\\\\
  \annotateconstraintbinop(\tenv, \op, \vcsone, \vcstwo) \typearrow \vcs
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TInt(\wellconstrained(\vcs))
}
\and
\inferrule[arith\_t\_int\_wellconstrained3]{
  \op \in  \{\SHL, \SHR\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \TInt(\wellconstrained(\vcsone))\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \TInt(\wellconstrained(\vcstwo))\\
  \constraintsisnonnegative(\vcstwo) \typearrow \vb\\
  \checktrans{\vb}{ShifterMustBeNonNegative} \checktransarrow \True \OrTypeError\\\\
  \annotateconstraintbinop(\tenv, \op, \vcsone, \vcstwo) \typearrow \vcs
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TInt(\wellconstrained(\vcs))
}
\end{mathpar}

\begin{mathpar}
\inferrule[plus\_minus\_mul\_real]{
  \op \in  \{\PLUS, \MINUS, \MUL\}\\
  \tstruct(\tenv, \vtone) \typearrow \TReal\\
  \tstruct(\tenv, \vttwo) \typearrow \TReal
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TReal
}
\end{mathpar}

\begin{mathpar}
\inferrule[pow\_real\_int]{
  \tstruct(\tenv, \vtone) \typearrow \TReal\\
  \astlabel(\tstruct(\tenv, \vttwo)) \typearrow \TInt
}{
  \CheckBinop(\tenv, \POW, \vtone, \vttwo) \typearrow \TReal
}
\end{mathpar}

\begin{mathpar}
\inferrule[rdiv]{
  \checktypesat(\tenv, \vtone, \TReal) \typearrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vttwo, \TReal) \typearrow \True \OrTypeError\\
}{
  \CheckBinop(\tenv, \RDIV, \vtone, \vttwo) \typearrow \TReal
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{
  This is related to \identr{BKNT}, \identr{ZYWY}, \identr{BZKW},
  \identr{KFYS}, \identr{KXMR}, \identr{SQXN}, \identr{MRHT}, \identr{JGWF},
  \identr{TTGQ}, \identi{YHML}, \identi{YHRP}, \identi{VMZF}, \identi{YXSY},
  \identi{LGHJ}, \identi{RXLG}.
}

\section{TypingRule.ConstraintsIsStrictPositive \label{sec:TypingRule.ConstraintsIsStrictPositive}}
\hypertarget{def-constraintsisstrictpositive}{}
The function
\[
  \constraintsisstrictpositive(\overname{\intconstraint^*}{\cs}) \aslto \overname{\Bool}{\vb}
\]
conservatively tests whether the list of integer constraints $\cs$ always represent positive integers,
yielding the result in $\vb$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\cs$ is the empty list;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\cs$ is the list with \head\ a constraint for the expression $\ve$ (that is, \\
          $\ConstraintExact(\ve)$) and \tail\ $\csone$;
    \item applying $\exprisstrictpositive$ to $\ve$ yields $\vbone$;
    \item applying $\constraintsisstrictpositive$ to $\csone$ yields $\vbtwo$;
    \item define $\vb$ as $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\cs$ is the list with \head\ a range constraint for the bottom expression $\ve$ (that is, $\ConstraintRange(\ve, \Ignore)$)
          and \tail\ $\csone$;
    \item applying $\exprisstrictpositive$ to $\ve$ yields $\vbone$;
    \item applying $\constraintsisstrictpositive$ to $\csone$ yields $\vbtwo$;
    \item define $\vb$ as $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \constraintsisstrictpositive(\overname{\emptylist}{\cs}) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[exact]{
  \exprisstrictpositive(\ve) \typearrow \vbone\\
  \constraintsisstrictpositive(\csone) \typearrow \vbtwo
}{
  \constraintsisstrictpositive(\overname{[\ConstraintExact(\ve)]\concat \csone}{\cs}) \typearrow \overname{\vbone\land\vbtwo}{\vb}
}
\and
\inferrule[range]{
  \exprisstrictpositive(\ve) \typearrow \vbone\\
  \constraintsisstrictpositive(\csone) \typearrow \vbtwo
}{
  \constraintsisstrictpositive(\overname{[\ConstraintRange(\ve, \Ignore)]\concat \csone}{\cs}) \typearrow \overname{\vbone\land\vbtwo}{\vb}
}
\end{mathpar}

\section{TypingRule.ExprIsStrictPositive \label{sec:TypingRule.ExprIsStrictPositive}}
\hypertarget{def-exprisstrictpositive}{}
The function
\[
\exprisstrictpositive(\overname{\expr}{\ve}) \aslto \overname{\Bool}{vb}
\]
conservatively tests whether the expression $\ve$ is always positive, yielding the result in $\vb$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{true}):
  \begin{itemize}
    \item $\ve$ is a literal expression for the integer literal $\vi$;
    \item define $\vb$ as $\True$ if and only if $\vi$ is greater than $0$.
  \end{itemize}

  \item All of the following apply (\textsc{false}):
  \begin{itemize}
    \item $\ve$ is not a literal expression for an integer literal;
    \item define $\vb$ as $\False$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[true]{}{
  \exprisstrictpositive(\overname{\ELiteral(\lint(\vi))}{\ve}) \typearrow \overname{\vi > 0}{\vb}
}
\and
\inferrule[false]{
  \ve \neq \ELiteral(\lint(\Ignore))
}{
  \exprisstrictpositive(\ve) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\section{TypingRule.ConstraintsIsNonNegative \label{sec:TypingRule.ConstraintsIsNonNegative}}
\hypertarget{def-constraintsisnonnegative}{}
The function
\[
  \constraintsisnonnegative(\overname{\intconstraint^*}{\cs}) \aslto \overname{\Bool}{\vb}
\]
conservatively tests whether the list of integer constraints $\cs$ always represent positive integers,
yielding the result in $\vb$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\cs$ is the empty list;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\cs$ is the list with \head\ a constraint for the expression $\ve$ (that is, \\
          $\ConstraintExact(\ve)$) and \tail\ $\csone$;
    \item applying $\exprisnonnegative$ to $\ve$ yields $\vbone$;
    \item applying $\constraintsisnonnegative$ to $\csone$ yields $\vbtwo$;
    \item define $\vb$ as $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\cs$ is the list with \head\ a range constraint for the bottom expression $\ve$ (that is, $\ConstraintRange(\ve, \Ignore)$)
          and \tail\ $\csone$;
    \item applying $\exprisnonnegative$ to $\ve$ yields $\vbone$;
    \item applying $\constraintsisnonnegative$ to $\csone$ yields $\vbtwo$;
    \item define $\vb$ as $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \constraintsisnonnegative(\overname{\emptylist}{\cs}) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[exact]{
  \exprisnonnegative(\ve) \typearrow \vbone\\
  \constraintsisnonnegative(\csone) \typearrow \vbtwo
}{
  \constraintsisnonnegative(\overname{[\ConstraintExact(\ve)]\concat \csone}{\cs}) \typearrow \overname{\vbone\land\vbtwo}{\vb}
}
\and
\inferrule[range]{
  \exprisnonnegative(\ve) \typearrow \vbone\\
  \constraintsisnonnegative(\csone) \typearrow \vbtwo
}{
  \constraintsisnonnegative(\overname{[\ConstraintRange(\ve, \Ignore)]\concat \csone}{\cs}) \typearrow \overname{\vbone\land\vbtwo}{\vb}
}
\end{mathpar}

\section{TypingRule.ExprIsNonNegative \label{sec:TypingRule.ExprIsNonNegative}}
\hypertarget{def-exprisnonnegative}{}
The function
\[
\exprisnonnegative(\overname{\expr}{\ve}) \aslto \overname{\Bool}{vb}
\]
conservatively tests whether the expression $\ve$ is always non-negative, yielding the result in $\vb$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{true}):
  \begin{itemize}
    \item $\ve$ is a literal expression for the integer literal $\vi$;
    \item define $\vb$ as $\True$ if and only if $\vi$ is greater than $-1$.
  \end{itemize}

  \item All of the following apply (\textsc{false}):
  \begin{itemize}
    \item $\ve$ is not a literal expression for an integer literal;
    \item define $\vb$ as $\False$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[true]{}{
  \exprisnonnegative(\overname{\ELiteral(\lint(\vi))}{\ve}) \typearrow \overname{\vi > -1}{\vb}
}
\and
\inferrule[false]{
  \ve \neq \ELiteral(\lint(\Ignore))
}{
  \exprisnonnegative(\ve) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\section{TypingRule.FindNamedLCA \label{sec:TypingRule.FindNamedLCA}}
\hypertarget{def-namedlowestcommonancestor}{}
The function
\[
  \namedlca(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\ty}{\tty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the lowest common named super type --- $\tty$ --- of the types $\vt$ and $\vs$ in $\tenv$.

\newcommand\supers[0]{\texttt{supers}}
The helper function
\[
  \supers(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt})
  \aslto \pow{\ty}
\]
returns the set of \emph{named supertypes} given via the $\subtypes$ function of the global environment:
\[
  \supers(\tenv, \vt) \triangleq
  \begin{cases}
    \{\vt\} \cup (\vs) & \text{ if }G^\tenv.\subtypes(\vt) = \vs\\
    \{\vt\}  & \text{ otherwise } (G^\tenv.\subtypes(\vt) = \bot)\\
  \end{cases}
\]

\subsection{Prose}
One of the following holds:
\begin{itemize}
  \item $\vtsupers$ is in the set of named supertypes of $\vt$;
  \item All of the following hold (\textsc{found}):
  \begin{itemize}
    \item $\vs$ is in $\vtsupers$;
    \item $\tty$ is $\vs$;
  \end{itemize}

  \item All of the following hold (\textsc{super}):
  \begin{itemize}
    \item $\vs$ is not in $\vtsupers$;
    \item $\vs$ has a named super type in $\tenv$ --- $\vsp$;
    \item $\tty$ is the lowest common named supertype of $\vt$ and $\vsp$ in $\tenv$.
  \end{itemize}

  \item All of the following hold (\textsc{none}):
  \begin{itemize}
    \item $\vs$ is not in $\vtsupers$;
    \item $\vs$ has no named super type in $\tenv$;
    \item $\tty$ is $\None$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[found]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \in \vtsupers
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \vs
}
\and
\inferrule[super]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \not\in \vtsupers\\
  G^\tenv.\subtypes(\vs) = \vsp\\
  \namedlca(\tenv, \vt, \vsp) \typearrow \tty
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \tty
}
\and
\inferrule[none]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \not\in \vtsupers\\
  G^\tenv.\subtypes(\vs) = \None
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \None
}
\end{mathpar}

\section{TypingRule.AnnotateConstraintBinop \label{sec:TypingRule.AnnotateConstraintBinop}}
\hypertarget{def-annotateconstraintbinop}{}
The function
\[
\begin{array}{r}
\annotateconstraintbinop(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint^*}{\csone} \aslsep
  \overname{\intconstraint^*}{\cstwo}
) \aslto \\
\overname{\intconstraints}{\vics}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the application of the binary operation $\op$ to the lists of integer constraints
$\csone$ and $\cstwo$, yielding an integer constraints element $\vics$.
\ProseOtherwiseTypeError

\subsection{Prose}

\CodeSubsection{\AnnotateConstraintBinopBegin}{\AnnotateConstraintBinopEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[exploding]{
  \binopfilterright(\tenv, \op, \cstwo) \typearrow \cstwof\\
  \binopisexploding(\op) \typearrow \True\\
  \explodeintervals(\tenv, \csone) \typearrow \csonee\\
  \explodeintervals(\tenv, \cstwof) \typearrow \cstwoe\\
  \constraintbinop(\op, \csonee, \cstwoe) \typearrow \cs\\
  \reduceconstraints(\tenv, \cs) \typearrow \vics
}{
  \annotateconstraintbinop(\tenv, \op, \csone, \cstwo) \typearrow \vics
}
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_exploding]{
    \binopfilterright(\tenv, \op, \cstwo) \typearrow \cstwof\\
    \binopisexploding(\op) \typearrow \False\\
    \constraintbinop(\op, \csone, \cstwof) \typearrow \cs\\
    \reduceconstraints(\tenv, \cs) \typearrow \vics
  }{
    \annotateconstraintbinop(\tenv, \op, \csone, \cstwo) \typearrow \vics
  }
  \end{mathpar}

% \section{TypingRule.ExplodeIntervals \label{sec:TypingRule.ExplodeIntervals}}
% \hypertarget{def-explodeintervals}{}
% The function
% \[
% \explodeintervals()
% \]

% \section{TypingRule.BinopIsExploding \label{sec:TypingRule.BinopIsExploding}}
% \hypertarget{def-binopisexploding}{}
% The function
% \[
% \binopisexploding()
% \]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Types \label{chap:typingoftypes}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatetype}{}
The function
\[
  \annotatetype{\overname{\Bool}{\vdecl} \aslsep \overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}}
  \aslto \overname{\ty}{\newty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a type $\tty$ in an environment $\tenv$, resulting in a
annotated type $\newty$.
The flag $\decl$ indicates whether $\tty$ is a type currently being declared.
\ProseOtherwiseTypeError

The flag $\decl$ is makes a difference only when $\tty$ is an enumeration type or a \structuredtype.

One of the following applies:
\begin{itemize}
  \item TypingRule.TString (see \secref{TypingRule.TString});
  \item TypingRule.TReal (see \secref{TypingRule.TReal});
  \item TypingRule.TBool (see \secref{TypingRule.TBool});
  \item TypingRule.TNamed (see \secref{TypingRule.TNamed});
  \item TypingRule.TInt (see \secref{TypingRule.TInt});
  \item TypingRule.TBits (see \secref{TypingRule.TBits});
  \item TypingRule.TTuple (see \secref{TypingRule.TTuple});
  \item TypingRule.TArray (see \secref{TypingRule.TArray});
  \item TypingRule.TEnumDecl (see \secref{TypingRule.TEnumDecl});
  \item TypingRule.TRecordExceptionDecl (see \secref{TypingRule.TRecordExceptionDecl});
  \item TypingRule.TNonDecl (see \secref{TypingRule.TNonDecl});
\end{itemize}
\ProseOtherwiseTypeError

We also define the following helper functions:
\begin{itemize}
  \item TypingRule.AnnotateConstraint (see \secref{TypingRule.AnnotateConstraint})
  \item TypingRule.GetVariableEnum (see \secref{TypingRule.GetVariableEnum})
  \item TypingRule.AnnotateStaticInteger (see \secref{TypingRule.AnnotateStaticInteger})
\end{itemize}

\section{TypingRule.TString \label{sec:TypingRule.TString}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the string type \TString.
  \item $\newty$ is the string type \TString.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{string} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TString.asl}

\CodeSubsection{\TStringBegin}{\TStringEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TString}{\tty}} \typearrow \overname{\TString}{\newty}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.TReal \label{sec:TypingRule.TReal}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the real type \TReal.
  \item $\newty$ is the real type \TReal.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{real} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TReal.asl}

\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TReal}{\tty}} \typearrow \overname{\TReal}{\newty}
}
\end{mathpar}

\CodeSubsection{\TRealBegin}{\TRealEnd}{../Typing.ml}

\isempty{\subsection{Comments}}

\section{TypingRule.TBool \label{sec:TypingRule.TBool}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the boolean type, \TBool;
  \item $\newty$ is the boolean type, \TBool.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{boolean} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBool.asl}

\CodeSubsection{\TBoolBegin}{\TBoolEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TBool}{\tty}} \typearrow \overname{\TBool}{\newty}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.TNamed \label{sec:TypingRule.TNamed}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the named type $\vx$, that is $\TNamed(\vx)$;
  \item checking whether $\vx$ is associated with a declared type in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newty$ is $\tty$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{MyType} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TNamed.asl}

\CodeSubsection{\TNamedBegin}{\TNamedEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checktrans{G^\tenv(\vx) \neq \bot}{\UndefinedIdentifier} \typearrow \True \OrTypeError
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TNamed(\vx)}{\tty}} \typearrow \overname{\TNamed(\vx)}{\newty}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.TInt \label{sec:TypingRule.TInt}}

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{not\_well\_constrained}):
    \begin{itemize}
      \item $\tty$ is an integer type that is not well-constrained;
      \item $\newty$ is the unconstrained integer type.
    \end{itemize}
  \item All of the following apply (\textsc{well\_constrained}):
    \begin{itemize}
      \item $\tty$ is the well-constrained integer type constrained by
        constraints $\vc_i$, for $u=1..k$;
      \item annotating each constraint $\vc_i$, for $i=1..k$,
      yields $\newc_i$\ProseOrTypeError;
      \item $\newconstraints$ is the list of annotated constraints $\newc_i$,
      for $i=1..k$;
      \item $\newty$ is the well-constrained integer type constrained
        by $\newconstraints$.
    \end{itemize}
\end{itemize}

\subsection{Example}
In the following examples, all the uses of integer types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntUnConstrained.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntWellConstrained.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntUnderConstrained.asl}

\CodeSubsection{\TIntBegin}{\TIntEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[not\_well\_constrained]{
  \tty \eqname \TInt(\vc)\\
  \astlabel(\vc) \neq \wellconstrained
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \tty} \typearrow \overname{\tty}{\newty}
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \constraints \eqname \vc_{1..k}\\
  i=1..k: \annotateconstraint(\vc_i) \typearrow\newc_i \OrTypeError\\\\
  \newconstraints \eqdef \newc_{1..k}
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TInt(\wellconstrained(\constraints))}{\tty}} \typearrow \\
  \overname{\TInt(\wellconstrained(\newconstraints))}{\newty}
    \end{array}
  }
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.TBits \label{sec:TypingRule.TBits}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the bit-vector type with width given by the expression
    $\ewidth$ and the bitfields given by $\bitfields$, that is, $\TBits(\ewidth, \bitfields)$;
  \item annotating the \staticallyevaluable\  integer expression $\ewidth$ yields $\ewidthp$\ProseOrTypeError;
  \item annotating the bitfields $\bitfields$ yields $\bitfieldsp$\ProseOrTypeError;
  \item $\newty$ is the bit-vector type with width given by the expression
    $\ewidthp$ and the bitfields given by $\bitfieldsp$, that is, $\TBits(\ewidthp, \bitfieldsp)$
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBits.asl}

In the following example, all the uses of bitvector types are valid:
\CodeSubsection{\TBitsBegin}{\TBitsEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatestaticconstrainedinteger(\tenv, \ewidth) \typearrow \ewidthp \OrTypeError\\\\
  \annotatebitfields(\tenv, \ewidthp, \bitfields) \typearrow \bitfieldsp \OrTypeError
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \TBits(\ewidth, \bitfields)} \typearrow \\
  \TBits(\ewidthp, \bitfieldsp)
    \end{array}
  }
}
\end{mathpar}

\subsection{Comments}
The width of a bitvector type $\TBits(\ewidth, \bitfields)$, given by the expression \\
$\ewidth$,
must be non-negative.

\section{TypingRule.TTuple \label{sec:TypingRule.TTuple}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the tuple type with member types $\tys$, that is, $\TTuple(\tys)$;
  \item $\tys$ is the list $\tty_i$, for $i=1..k$;
  \item annotating each type $\tty_i$ in $\tenv$, for $i=1..k$,
  yields $\ttyp_i$\ProseOrTypeError;
  \item $\newty$ is the tuple type with member types $\ttyp$, for $i=1..k$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of tuple types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TTuple.asl}

\CodeSubsection{\TTupleBegin}{\TTupleEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  k \geq 2\\
  \tys \eqname \tty_{1..k}\\
  i=1..k: \annotatetype{\False, \tenv, \tty_i} \typearrow \ttyp_i \OrTypeError
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \TTuple(\tys)} \typearrow \TTuple(\tysp)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.TArray \label{sec:TypingRule.TArray}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the array type indexed by integer bounded by the
    expression $\ve$ and of elements of type $\vt$;
  \item Annotating the type $\vt$ in $\tenv$ yields $\vtp$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{expr\_is\_enum}):
    \begin{itemize}
      \item determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via \\ $\getvariableenum$ yields the enumeration variable
      name $\vs$ of size $\vi$, that is, $\langle \vs, \vi \rangle$\ProseOrTypeError;
      \item $\newty$ is the array type indexed by an enumeration type
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$.
    \end{itemize}

    \item All of the following apply (\textsc{expr\_not\_enum}):
    \begin{itemize}
      \item determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via \\ $\getvariableenum$ yields $\None$ (meaning it does not
      correspond to an enumeration)\ProseOrTypeError;
      \item annotating the statically evaluable integer expression $\ve$ yields
      $\vep$\ProseOrTypeError;
      \item $\newty$ the array type indexed by integer bounded by
      the expression $\vep$ and of elements of type $\vtp$, that is,
      $\TArray(\ArrayLengthExpr(\vep), \vtp)$.
    \end{itemize}

    \item All of the following apply (\textsc{index\_enum}):
    \begin{itemize}
      \item $\ve$ is an enumeration type index with variable $\vs$ and size $\vi$,
      that is, \\ $\ArrayLengthEnum(\vs, \vi)$;
      \item let $\tty$ be the named type defined for $\vs$, that is, $\TNamed(\vs)$;
      \item determining the \underlyingtype\ of $\tty$ yields $\tsanon$\ProseOrTypeError;
      \item checking whether $\tsanon$ is an enumeration type yields $\True$\ProseOrTypeError;
      \item $\vt$ is an enumeration with labels $\vli$;
      \item checking whether $\vli$ has the same length as $\vi$ yields $\True$\ProseOrTypeError;
      \item $\newty$ is the array type indexed by an enumeration type
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following example, all the uses of array types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TArray.asl}

\CodeSubsection{\TArrayBegin}{\TArrayEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[expr\_is\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \getvariableenum(\tenv, \ve) \typearrow \langle \vs, \vi \rangle\OrTypeError
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TArray(\ArrayLengthExpr(\ve), \vt)}{\tty}} \typearrow \\
  \overname{\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)}{\newty}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[expr\_not\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \getvariableenum(\tenv, \ve) \typearrow \None \OrTypeError\\\\
  \annotatestaticinteger(\tenv, \ve) \typearrow \vep \OrTypeError
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TArray(\ArrayLengthExpr(\ve), \vt)}{\tty}} \typearrow \\
  \overname{\TArray(\ArrayLengthExpr(\vep), \vtp)}{\newty}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[index\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \tsubs \eqdef \TNamed(\vs)\\
  \makeanonymous(\tenv, \tsubs) \typearrow \tsanon \OrTypeError\\\\
  \checktrans{\astlabel(\tsanon) = \TEnum}{ExpectedEnumeration} \checktransarrow \True \OrTypeError\\\\
  \vt \eqname \TEnum(\vli)\\
  \checktrans{\equallength(\vli, \vi)}{TypeConflict} \checktransarrow \True \OrTypeError
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TArray(\ArrayLengthEnum(\vs, \vi), \vt)}{\tty}} \typearrow \\
  \overname{\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)}{\newty}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.TEnumDecl \label{sec:TypingRule.TEnumDecl}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the enumeration type with enumeration literals
    $\vli$, that is, $\TEnum(\vli)$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item determining that $\vli$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item determining that none of the labels in $\vli$ is declared in the global environment
  yields $\True$\ProseOrTypeError;
  \item $\newty$ is the enumeration type $\tty$.
\end{itemize}

\subsection{Example}
The following example declares a valid enumeration type:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TEnumDecl.asl}

\CodeSubsection{\TEnumDeclBegin}{\TEnumDeclEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checknoduplicates(\vli) \typearrow \True \OrTypeError\\\\
  \vl \in \vli: \checkvarnotingenv{\tenv, \vl} \typearrow \True \OrTypeError
}{
  \annotatetype{\True, \tenv, \TEnum(\vli)} \typearrow \TEnum(\vli)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{YZBQ}, \identr{DWSP}, \identi{MZXL}.}

\section{TypingRule.TRecordExceptionDecl \label{sec:TypingRule.TRecordExceptionDecl}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is a \structuredtype\ with AST label $L$;
  \item the list of fields of $\tty$ is $\fields$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item $\fields$ is a list of pairs where the first element is an identifier and the second is a type --- $(\vx_i, \vt_i)$, for $i=1..k$;
  \item checking that the list of field identifiers $\vx_{1..k}$ does not contain duplicates
  yields $\True$\ProseOrTypeError;
  \item annotating each field type $\vt_i$, for $i=1..k$, yields an annotated type $\vtp_i$
 \ProseOrTypeError;
  \item $\fieldsp$ is the list with $(\vx_i, \vtp_i)$, for $i=1..k$;
  \item $\newty$ is the AST node with AST label $L$ (either record type or exception type,
  corresponding to the type $\tty$) and fields $\fieldsp$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of record or exception types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TRecordExceptionDecl.asl}

\CodeSubsection{\TRecordExceptionDeclBegin}{\TRecordExceptionDeclEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  L \in \{\TRecord, \TException\}\\
  \fields \eqname [i=1..k: (\vx_i, \vt_i)]\\
  \checknoduplicates(\vx_{1..k}) \typearrow \True \OrTypeError\\\\
  i=1..k: \annotatetype{\False, \tenv, \vt_i} \typearrow \vtp_i \OrTypeError\\\\
  \fieldsp \eqdef [i=1..k: (\vx_i, \vtp_i)]
}{
  \annotatetype{\True, \tenv, L(\fields)} \typearrow L(\fieldsp)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.TNonDecl \label{sec:TypingRule.TNonDecl}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is a \structuredtype\ or an enumeration type;
  \item $\decl$ is $\False$, indicating that $\tty$ should be considered to be outside the context of a declaration
  of $\tty$;
  \item a type error is returned, indicating that the use of anonymous form of enumerations, record,
  and exceptions types is not allowed here.
\end{itemize}

\subsection{Example}
In the following example, the use of a record type outside of a declaration is erroneous:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TNonDecl.asl}

\CodeSubsection{\TNonDeclBegin}{\TNonDeclEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \astlabel(\tty) \in \{\TEnum, \TRecord, \TException\}
}{
  \annotatetype{\False, \tenv, \tty} \typearrow \TypeErrorVal{AnnonymousFormNotAllowedHere}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.AnnotateConstraint \label{sec:TypingRule.AnnotateConstraint}}
\hypertarget{def-annotateconstraint}{}
The function
\[
\annotateconstraint(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vc})
\aslto \overname{\intconstraint}{\newc} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates an integer constraint $\vc$ in the static environment $\tenv$ yielding the annotated
integer constraint $\newc$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is the exact integer constraint for the expression $\ve$, that is, \\ $\ConstraintExact(\ve)$;
    \item applying $\annotatestaticconstrainedinteger$ to $\ve$ in $\tenv$ yields $\vep$\ProseOrTypeError;
    \item define $\newc$ as the exact integer constraint for $\vep$, that is, $\ConstraintExact(\vep)$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is the range integer constraint for expressions $\veone$ and $\vetwo$, that is, \\ $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\annotatestaticconstrainedinteger$ to $\veone$ in $\tenv$ yields $\veonep$\ProseOrTypeError;
    \item applying $\annotatestaticconstrainedinteger$ to $\vetwo$ in $\tenv$ yields $\vetwop$\ProseOrTypeError;
    \item define $\newc$ as the range integer constraint for expressions $\veonep$ and $\vetwop$, that is, $\ConstraintRange(\veonep, \vetwop)$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[exact]{
  \annotatestaticconstrainedinteger(\tenv, \ve) \typearrow \vep \OrTypeError
}{
  \annotateconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\ConstraintExact(\vep)}{\newc}
}
\and
\inferrule[range]{
  \annotatestaticconstrainedinteger(\tenv, \veone) \typearrow \veonep \OrTypeError\\\\
  \annotatestaticconstrainedinteger(\tenv, \vetwo) \typearrow \vetwop \OrTypeError
}{
  \annotateconstraint(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\ConstraintRange(\veonep, \vetwop)}{\newc}
}
\end{mathpar}

\section{TypingRule.GetVariableEnum \label{sec:TypingRule.GetVariableEnum}}
\hypertarget{def-getvariableenum}{}
The function
\[
\getvariableenum(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
\langle (\overname{\identifier}{\vx}, \overname{\N}{n})\rangle
\]
tests whether the expression $\ve$ represents a variable of an enumeration type.
If so, the result is $\vx$ --- the name of the variable and the number of labels defined for the enumeration type.
Otherwise, the result is $\None$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{not\_evar}):
  \begin{itemize}
    \item $\ve$ is not a variable expression;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{no\_declared\_type}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is not associated with a type in the global environment of $\tenv$;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{declared\_enum}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtype\ of $\vt$ in $\tenv$ yields an enumeration type with labels $\vli$\ProseOrTypeError;
    \item the result is the pair consisting of $\vx$ and the length of $\vli$.
  \end{itemize}

  \item All of the following apply (\textsc{declared\_not\_enum}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtype\ of $\vt$ in $\tenv$ yields a type that is not an enumeration type;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[not\_evar]{
  \astlabel(\ve) \neq \EVar
}{
  \getvariableenum(\tenv, \ve) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_declared\_type]{
  G^\tenv.\declaredtypes(\vx) \typearrow \None
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_enum]{
  G^\tenv.\declaredtypes(\vx) \typearrow \langle\vt\rangle\\
  \makeanonymous(\tenv, \vt) \typearrow \TEnum(\vli) \OrTypeError
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \langle(\vx, |\vli|)\rangle
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_not\_enum]{
  G^\tenv.\declaredtypes(\vx) \typearrow \langle\vt\rangle\\
  \makeanonymous(\tenv, \vt) \typearrow \vtone\\
  \astlabel(\vtone) \neq \TEnum
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\section{TypingRule.AnnotateStaticInteger \label{sec:TypingRule.AnnotateStaticInteger}}
\hypertarget{def-annotatestaticinteger}{}
The function
\[
  \annotatestaticinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\expr}{\vepp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a \staticallyevaluable\ integer expression $\ve$ in the static environment $\tenv$
and returns the annotated expression $\vepp$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the expression $\ve$ in $\tenv$ yields $ (\vt, \vep)$\ProseOrTypeError;
  \item determining whether $\vt$ has the structure of an integer yields $\True$\ProseOrTypeError;
  \item determining whether $\vep$ is \staticallyevaluable\  in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\normalize$ to $\vep$ in $\tenv$ yields $\vepp$.
\end{itemize}

\CodeSubsection{\StaticIntegerBegin}{\StaticIntegerEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \vep) \OrTypeError\\\\
  \checkstructureinteger(\tenv, \vt) \typearrow \True \OrTypeError\\\\
  \checkstaticallyevaluable(\tenv, \vep) \typearrow \True \OrTypeError\\\\
  \normalize(\tenv, \vep) \typearrow \vepp
}{
  \annotatestaticinteger(\tenv, \ve) \typearrow \vepp
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Bitfields}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We define rules for annotating a single bitfield and a list of bitfields:
\begin{itemize}
  \item TypingRule.TBitField (see \secref{TypingRule.TBitField});
  \item TypingRule.TBitFields (see \secref{TypingRule.TBitFields});
\end{itemize}

\section{TypingRule.TBitField \label{sec:TypingRule.TBitField}}
\hypertarget{def-annotatebitfield}{}
The function
\[
  \annotatebitfield(\overname{\staticenvs}{\tenv} \aslsep \overname{\Z}{\width} \aslsep \overname{\bitfield}{\field})
  \aslto \overname{\bitfield}{\newfield} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a bitfield --- $\field$ --- with an integer --- $\width$ --- indicating the number of bits in
the bitvector type that contains $\field$,
in an environment $\tenv$, resulting in an
annotated bitfield --- $\newfield$ --- or a type error, if one is detected.

\subsection{Prose}
\begin{itemize}
  \item Annotating the slices $\slices$ yields $\slicesone$\ProseOrTypeError;
  One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{simple}):
    \begin{itemize}
      \item checking whether the range of positions in $\slicesone$ fits inside $0..\width-1$ yields $\True$\ProseOrTypeError;
      \item $\newfield$ is a bitfield named $\name$ with list of slices $\slicesone$, that is, $\BitFieldSimple(\name, \sliceone)$.
    \end{itemize}

    \item All of the following apply (\textsc{nested}):
    \begin{itemize}
      \item converting the $\slicesone$ into a list of positions with $\width$ and static environment $\tenv$
      yields $\positions$\ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields \\
            $\True$\ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item annotating the bitfields $\bitfieldsp$ with $\widthp$ in static environment $\tenv$ yields $\bitfieldspp$\ProseOrTypeError;
      \item $\newfields$ is the nested bitfield with $\slicesone$ and bitfields $\bitfieldspp$, that is, $\BitFieldNested(\slicesone, \bitfieldspp)$.
    \end{itemize}

    \item All of the following apply (\textsc{type}):
    \begin{itemize}
      \item Annotating the type $\vt$ yields $\vtp$\ProseOrTypeError;
      \item checking whether the range of positions in $\slicesone$ fit inside $0..\width$ yields $\True$\ProseOrTypeError;
      \item converting the list of slices $\slicesone$ into a list of positions in $\tenv$ yields $\positions$\ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields $\True$\ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item checking whether the $\vt$ and the bitvector with $\widthp$ bits have the same width yields $\True$\ProseOrTypeError
      \item $\newfield$ is the typed-bitfield with name $\name$, list of slices $\slicesone$ and type $\vtp$, that is, \BitFieldType(\name, \slicesone, \vtp).
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following example, all the uses of bitvector types with bitfields are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBitField.asl}

\CodeSubsection{\TBitFieldBegin}{\TBitFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[simple]{
  \annotateslices(\tenv, \slices) \typearrow \slicesone \OrTypeError\\\\
  \checkslicesinwidth(\tenv, \width, \slicesone) \typearrow \True \OrTypeError
}{
  \annotatebitfield(\tenv, \width, \BitFieldSimple(\name, \slices)) \typearrow \\
  \BitFieldSimple(\name, \sliceone)
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested]{
  \annotateslices(\tenv, \slices) \typearrow \slicesone \OrTypeError\\\\
  \disjointslicestopositions(\tenv, \width, \slicesone) \typearrow \positions \OrTypeError\\\\
  \checkpositionsinwidth(\tenv, \width, \positions) \typearrow \True \OrTypeError\\\\
  \widthp \eqdef \listlen{\positions}\\
  \annotatebitfields(\tenv, \widthp, \bitfieldsp) \typearrow \bitfieldspp \OrTypeError\\
}{
  \annotatebitfield(\tenv, \width, \BitFieldNested(\name, \slices, \bitfieldsp)) \typearrow \\
  \BitFieldNested(\slicesone, \bitfieldspp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[type]{
  \annotateslices(\tenv, \slices) \typearrow \slicesone \OrTypeError\\\\
  \annotatetype{\tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \checkslicesinwidth(\tenv, \width, \slicesone) \typearrow \True \OrTypeError\\\\
  \disjointslicestopositions(\tenv, \slicesone) \typearrow \positions \OrTypeError\\\\
  \checkpositionsinwidth(\tenv, \slicesone, \width, \positions) \typearrow \True \OrTypeError\\\\
  \widthp \eqdef \listlen{\positions}\\
  \checkbitsequalwidth(\TBits(\widthp, \emptylist), \vt) \typearrow \True \OrTypeError
}{
  \annotatebitfield(\tenv, \width, \BitFieldType(\name, \slices, \vt)) \typearrow \\
  \BitFieldType(\name, \slicesone, \vtp)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.TBitFields \label{sec:TypingRule.TBitFields}}
\hypertarget{def-annotatebitfields}{}
The function
\[
  \annotatebitfields(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ewidth} \aslsep \overname{\bitfields}{\fields})
  \aslto \overname{\bitfields}{\newfields} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of bitfields --- $\fields$ --- with an expression denoting the overall number of bits in the containing
bitvector type --- $\ewidth$,
in an environment $\tenv$, resulting in an
annotated list of bitfields --- $\newfields$ or a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that the list of bitfield names in $\bitfields$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item symbolically simplifying $\ewidth$ in $\tenv$ via $\reduceconstants$ yields the literal integer for $\width$\ProseOrTypeError;
  \item annotating each bitfield $\field$ in $\fields$ with width $\width$ in $\tenv$ yields the corresponding annotated
  bitfield $\newfield$\ProseOrTypeError;
  \item $\newfields$ is the list of annotated bitfields.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\TBitFieldsBegin}{\TBitFieldsEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \names \eqdef [\field\in\fields: \bitfieldgetname(\field)]\\
  \checknoduplicates(\names) \typearrow \True \OrTypeError\\\\
  \reduceconstants(\tenv, \ewidth) \typearrow \lint(\width) \OrTypeError\\\\
  \field\in\fields: \annotatebitfield(\tenv, \width, \field) \typearrow \newfield \OrTypeError\\\\
  \newfields \eqdef [\field\in\fields: \newfield]
}{
  \annotatebitfields(\tenv, \ewidth, \fields) \typearrow \newfields
}
\end{mathpar}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotateexpr}{}
The function
\[
  \annotateexpr{\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}}
  \aslto (\overname{\ty}{\vt} \times \overname{\expr}{\newe})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
specifies how to annotate an expression $\ve$ in
an environment \tenv.  Formally, the result of annotating the expression
$\ve$ in \tenv\ is either the pair $(\vt, \newe)$, where $\vt$ is a type and
$\newe$ is an annotated expression, or a type error, and one of the following applies:
\begin{itemize}
\item TypingRule.ELit (see \secref{TypingRule.ELit});
\item TypingRule.ELocalVarConstant (see \secref{TypingRule.ELocalVarConstant})
\item TypingRule.ELocalVar (see \secref{TypingRule.ELocalVar})
\item TypingRule.EGlobalVarConstant (see \secref{TypingRule.EGlobalVarConstant})
\item TypingRule.EGlobalVarConstantNoVal (see \secref{TypingRule.EGlobalVarConstantNoVal})
\item TypingRule.EGlobalVar (see \secref{TypingRule.EGlobalVar})
\item TypingRule.EUndefIdent (see \secref{TypingRule.EUndefIdent})
\item TypingRule.Binop (see \secref{TypingRule.Binop})
\item TypingRule.Unop (see \secref{TypingRule.Unop})
\item TypingRule.ECond (see \secref{TypingRule.ECond})
\item TypingRule.ESlice (see \secref{TypingRule.ESlice})
\item TypingRule.ESetter (see \secref{TypingRule.ESetter})
\item TypingRule.ECall (see \secref{TypingRule.ECall})
\item TypingRule.EGetArray (see \secref{TypingRule.EGetArray})
\item TypingRule.ESliceOrEGetArrayError (see \secref{TypingRule.ESliceOrEGetArrayError})
\item TypingRule.ERecord (see \secref{TypingRule.ERecord})
\item TypingRule.EGetRecordField (see \secref{TypingRule.EGetRecordField})
\item TypingRule.EGetBadRecordField (see \secref{TypingRule.EGetBadRecordField})
\item TypingRule.EGetBadBitField (see \secref{TypingRule.EGetBadBitField})
\item TypingRule.EGetBitField (see \secref{TypingRule.EGetBitField})
\item TypingRule.EGetBitFieldNested (see \secref{TypingRule.EGetBitFieldNested})
\item TypingRule.EGetBitFieldTyped (see \secref{TypingRule.EGetBitFieldTyped})
\item TypingRule.EGetTupleItem (see \secref{TypingRule.EGetTupleItem})
\item TypingRule.EGetBadField (see \secref{TypingRule.EGetBadField})
\item TypingRule.EConcat (see \secref{TypingRule.EConcat})
\item TypingRule.ETuple (see \secref{TypingRule.ETuple})
\item TypingRule.EUnknown (see \secref{TypingRule.EUnknown})
\item TypingRule.EPattern (see \secref{TypingRule.EPattern})
\item TypingRule.ATC (see \secref{TypingRule.ATC})
\end{itemize}

The annotation rewrites the input expression in the following cases, making the annotation of statements simpler:
\begin{itemize}
  \item Variables with constant values are substituted by their constant values.
  \item Slicing expressions that correspond to calling a getter are replaced with respective call expressions.
  \item Slicing expressions that correspond to \arrayaccess\ expressions are replaced by \arrayaccess\ expressions.
\end{itemize}

We also define the following helper rules:
\begin{itemize}
  \item TypingRule.Lit (\secref{TypingRule.Lit})
  \item TypingRule.ExpressionList (\secref{TypingRule.ExpressionList})
  \item TypingRule.TypingRule.ReduceSlicesToCall (\secref{TypingRule.ReduceSlicesToCall})
  \item TypingRule.StaticConstrainedInteger (\secref{TypingRule.StaticConstrainedInteger})
  \item TypingRule.CheckATC (\secref{TypingRule.CheckATC})
\end{itemize}

\section{TypingRule.ELit \label{sec:TypingRule.ELit}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ is the literal expression $\vv$;
\item $\vt$ is the type of the literal $\vv$;
\item $\newe$ is $\ve$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ELitBegin}{\ELitEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{\annotateliteral{\vv} \typearrow \vt}
{\annotateexpr{\tenv, \ELiteral(\vv)} \typearrow (\vt, \ELiteral(\vv))}
\end{mathpar}

\section{TypingRule.ELocalVarConstant \label{sec:TypingRule.ELocalVarConstant}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a local variable $\vx$;
\item $\vx$ is bound to a local constant $\vv$ of type $\tty$ in the local environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is the Literal $\vv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ELocalVarConstantBegin}{\ELocalVarConstantEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\constantvalues(\vx) = \vv\\
  L^\tenv.\localstoragetypes(\vx) = (\tty, \LDKConstant)
}{
  \annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \eliteral{\vv})
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.ELocalVar \label{sec:TypingRule.ELocalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a local variable $\vx$;
\item $\vx$ is not bound to a constant in the local environment given by $\tenv$;
\item $\vx$ has type $\tty$ in the local environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is $\ve$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ELocalVarBegin}{\ELocalVarEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\constantvalues(\vx) = \bot\\
  L^\tenv.\localstoragetypes(\vx) =  (\tty, k) \\
  k \in \{\LDKVar, \LDKLet\}
}{
  \annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \EVar(\vx))
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVarConstantVal \label{sec:TypingRule.EGlobalVarConstant}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a global variable $\vx$;
\item $\vx$ is bound to a constant $\vv$ of type $\tty$ in the global environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is the Literal for $\vv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGlobalVarConstantBegin}{\EGlobalVarConstantEnd}{../Typing.ml}

  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \vv
}{
  \annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \eliteral{\vv})
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVarConstantNoVal \label{sec:TypingRule.EGlobalVarConstantNoVal}}
Our type system does not currently address assignments of non-constant expressions (for example,
function calls) to global constant variables. This section can be seen as a place holder until
the right details are filled in.

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a global variable $\vx$;
\item $\vx$ is not bound to constant in the global environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is $\ve$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGlobalVarConstantNoValBegin}{\EGlobalVarConstantNoValEnd}{../Typing.ml}

  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \bot
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \EVar(\vx))}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVar \label{sec:TypingRule.EGlobalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a global variable $\vx$;
\item $\vx$ is not bound to a global constant;
\item $\vx$ has type $\tty$ in the global environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is $\ve$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGlobalVarBegin}{\EGlobalVarEnd}{../Typing.ml}

  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\constantvalues(\vx) = \bot\\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, k)\\
  k \neq \GDKConstant
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \EVar(\vx))}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EUndefIdent \label{sec:TypingRule.EUndefIdent}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ is a variable $\vx$;
\item $\vx$ is not bound in $\tenv$;
\item the result is a type error indicating that $\vx$ is an undefined identifier.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EUndefIdentBegin}{\EUndefIdentEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\globalstoragetypes(\vx) = \bot\\
  L^\tenv.\globalstoragetypes(\vx) = \bot\\
}{
  \annotateexpr{\tenv, \EVar(\vx)} \typearrow \TypeErrorVal{UndefinedIdentifier}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.Binop \label{sec:TypingRule.Binop}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a binary operation $\op$ over two expressions $\veone$ and $\vetwo$, that is, \\ $\EBinop(\op, \veone, \vetwo)$;
  \item the result of annotating $\veone$ in $\tenv$ is $(\vtone, \veonep)$\ProseOrTypeError;
  \item the result of annotating $\vetwo$ in $\tenv$ is $(\vttwo, \vetwop)$\ProseOrTypeError;
  \item the result of checking compatibility of $\op$ with $\vtone$ and $\vttwo$ as per \secref{TypingRule.CheckBinop}
  is $\vt$\ProseOrTypeError;
  \item $\newenv$ denotes $\op$ over $\veonep$ and $\vetwop$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\BinopBegin}{\BinopEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veone') \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwo') \OrTypeError\\\\
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}} \typearrow (\vt, \overname{\EBinop(\op, \veone', \vetwo')}{\newe})
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.Unop \label{sec:TypingRule.Unop}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a unary operation $\op$ over an expression $\vep$, that is $\EUnop(\op, \vep)$;
  \item annotating $\vep$ in $\tenv$ yields $(\vtpp, \vepp)$\ProseOrTypeError;
  \item checking compatibility of $\op$ with $\vtpp$ as per \secref{TypingRule.CheckUnop} yields $\vt$\ProseOrTypeError;
  \item $\newe$ denotes $\op$ over $\vepp$, that is, $\EUnop(\op, \vepp)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\UnopBegin}{\UnopEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vtpp, \vepp) \OrTypeError\\\\
  \CheckUnop(\tenv, \op, \vtpp) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\tenv, \EUnop(\op, \vep)} \typearrow (\vt, \EUnop(\op, \vepp))
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.ECond \label{sec:TypingRule.ECond}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a conditional expression with condition $\econd$ with two options $\etrue$ and $\efalse$;
  \item annotating $\econd$ in $\tenv$ results in $(\tcond, \econdp)$\ProseOrTypeError;
  \item annotating $\etrue$ in $\tenv$ results in $(\ttrue, \etruep)$\ProseOrTypeError;
  \item annotating $\efalse$ in $\tenv$ results in $(\tfalse, \efalsep)$;
  \item obtaining the lowest common ancestor of $\ttrue$ and $\tfalse$ results in $\vt$\ProseOrTypeError;
  \item $\newe$ is the condition $\econdp$ with two options $\etruep$ and $\efalsep$, that is, $\ECond(\econdp, \etruep, \efalsep)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ECondBegin}{\ECondEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \econd} \typearrow (\tcond, \econd') \OrTypeError\\\\
  \annotateexpr{\tenv, \etrue} \typearrow (\ttrue, \etrue') \OrTypeError\\\\
  \annotateexpr{\tenv, \efalse} \typearrow (\tfalse, \efalse') \OrTypeError\\\\
  \lca(\ttrue, \tfalse) \typearrow \vt \OrTypeError
}{
  {
    \begin{array}{r}
  \annotateexpr{\ECond(\econd, \etrue, \efalse)} \typearrow \\
  (\vt, \ECond(\econdp, \etruep, \efalsep))
    \end{array}
  }
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{XZVT}.}

\section{TypingRule.ESlice \label{sec:TypingRule.ESlice}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
  $\ESlice(\vep, \slices)$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a negative answer --- $\None$\ProseOrTypeError;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\tep,\vepp)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\structtep$\ProseOrTypeError;
  \item $\structtep$ is either a bitvector or an integer;
  \item obtaining the width of $\slices$ in $\tenv$ via $\sliceswidth$ yields $\vw$\ProseOrTypeError;
  \item $\slicesp$ is the result of annotating $\slices$ in $\tenv$;
  \item $\vt$ is the bitvector type of width $\vw$, that is, $\TBits(\vw, \emptylist)$;
  \item $\newe$ is the slicing of expression $\vepp$ by the slices $\slicesp$, that is, \\
  $\ESlice(\vepp, \slicesp)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ESliceBegin}{\ESliceEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \vep} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \structtep \OrTypeError\\\\
  \astlabel(\structtep) \in \{\TInt, \TBits\}\\
  \sliceswidth(\tenv, \slices) \typearrow \vw \OrTypeError\\\\
  \annotateslices(\tenv, \slices) \typearrow \slicesp \OrTypeError
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow (\TBits(\vw, \emptylist), \ESlice(\vepp, \slicesp))
}
\end{mathpar}

\subsection{Comments}
  The width of \slices\ might be a symbolic expression if one of the
  widths references a \texttt{let} identifier with a non-compile-time-constant
  initializer expression.

  \lrmcomment{This is related to \identi{MJWM}.}

\section{TypingRule.ESetter \label{sec:TypingRule.ESetter}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
  $\ESlice(\vep, \slices)$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a positive answer --- $\langle (\name, \vargs)\rangle$\ProseOrTypeError;
  \item annotating a call with $(\tenv, \name, \vargs, \emptylist, \STSetter)$
  (that is, an empty list of parameters) yields $(\nameone, \vargsone, \eqs, \langle\tty\rangle)$\ProseOrTypeError;
  \item $vt$ is $\tty$;
  \item $\newe$ is the call expression $\ECall(\nameone, \vargsone, \eqs)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ESetterBegin}{\ESetterEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \langle(\name, \vargs)\rangle \OrTypeError\\\\
  \annotatecall(\tenv, \name, \vargs, \STSetter) \typearrow (\nameone, \vargsone, \eqs, \langle\tty\rangle) \OrTypeError\\
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow (\tty, \ECall(\nameone, \vargsone, \eqs))
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.ECall \label{sec:TypingRule.ECall}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a call to a subprogram named $\name$ with arguments $\vargs$, that is, \\ $\ECall(\name, \vargs)$;
  \item applying $\annotatecall$ to $\name$, $\vargs$, and $\STFunction$ in $\tenv$
        annotates the call of that subprogram in $\tenv$ as a function (annotating calls is defined in Chapter~\ref{chap:TypingSubprogramCalls})
        and yields $(\namep, \vargsp, \eqsp, \langle \vt \rangle)$\ProseOrTypeError.
        Notice that passing $\STFunction$ to $\annotatecall$ checks that $\name$ is not a procedure and that a value is indeed returned;
  \item $\newe$ is the call to the subprogram named $\namep$ with arguments $\vargsp$
    and parameters $\eqsp$, that is, $\ECall(\name, \vargsp, \eqsp)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ECallBegin}{\ECallEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatecall(\tenv, \name, \vargs, \STFunction) \typearrow (\namep, \vargsp, \eqsp, \langle \vt \rangle) \OrTypeError
}{
  \annotateexpr{\tenv, \ECall(\name, \vargs)} \typearrow (\vt, \ECall(\name, \vargsp, \eqsp))
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{CFYP}, \identr{BQJG}.}

\section{TypingRule.EGetArray \label{sec:TypingRule.EGetArray}}
\hypertarget{def-arrayaccess}{}
\begin{definition}[Array Access]
We refer to a right-hand-side expression of the form $b[i]$,
where $b, i$ are subexpressions, as an \arrayaccess\ expression.
We refer to $b$ and $i$ as the \emph{base}
and the $\emph{index}$ subexpressions, respectively.

In the parsed AST, an \arrayaccess\ expression is represented by
$\ESlice(\vbase, [\vindex])$.
In the typed AST, it is represented by $\EGetArray(\vbase, \vindex)$
\end{definition}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
        in $\tenv$ via $\reduceslicestocall$ yields a negative answer --- $\None$\ProseOrTypeError;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure of an array with index $\size$ and element type $\tty$';
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{okay}):
    \begin{itemize}
      \item $\slices$ consists of a single slice $\SliceSingle(\eindex)$;
      \item annotating the expression $\eindex$ in $\tenv$ yields $(\tindexp, \eindexp)$\ProseOrTypeError;
      \item determining the type of the array index for $\size$ in $\tenv$ via \\ $\typeofarraylength$
            yields $\wantedtindex$;
      \item determining whether $\tindexp$ \typesatisfies\ $\wantedtindex$ yields \\
            $\True$\ProseOrTypeError;
      \item $\vt$ is $\ttyp$;
      \item $\newe$ is the \arrayaccess\ expression for $\vepp$ and index $\eindexp$, that is, $\EGetArray(\vepp, \eindexp)$.
    \end{itemize}

    \item All of the following apply (\textsc{error}):
    \begin{itemize}
      \item $\slices$ consists of a single slice $\SliceSingle(\eindex)$;
      \item the result is a type error indicating that an array must be accessed with a slice corresponding
            to a single index expression.
    \end{itemize}
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGetArrayBegin}{\EGetArrayEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \ve} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \TArray(\size, \ttyp) \OrTypeError\\\\
  \slices = [ \SliceSingle(\eindex) ]\\
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp) \OrTypeError\\\\
  \typeofarraylength(\tenv, \size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow (\ttyp, \EGetArray(\vepp, \eindexp))
}
\and
\inferrule[error]{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \ve} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \TArray(\size, \ttyp) \OrTypeError\\\\
  \slices \neq [ \SliceSingle(\Ignore) ]\\
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow \TypeErrorVal{IllegalArraySlice}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.ESliceOrEGetArrayError \label{sec:TypingRule.ESliceOrEGetArrayError}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a negative answer --- $\None$\ProseOrTypeError;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure $\vtp$;
  \item $\vtp$ is neither an integer type, a bitvector type, or an array type;
  \item the result is an error indicating that the type of $\vep$ is inappropriate for slicing.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ESliceOrEGetArrayErrorBegin}{\ESliceOrEGetArrayErrorEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \ve} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \vtp\\
  \astlabel(\vtp) \not\in \{\TInt, \TBits, \TArray\}
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow \TypeErrorVal{IllegalSliceType}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.ERecord \label{sec:TypingRule.ERecord}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the record construction expression (which is also used for creating exceptions) of type $\tty$ with fields $\fields$,
        that is, $\ERecord(\tty, \vfields)$;
  \item obtaining the \underlyingtype\ of $\tty$ in $\tenv$ yields $\ttyanon$\ProseOrTypeError;
  \item checking that $\ttyanon$ is a \structuredtype\ yields $\True$\ProseOrTypeError;% \ProseTerminateAs{\TypeErrorVal{\RequireStructuredType}};
  \item $\ttyanon$ is a \structuredtype\ with a list of $\field$ elements (consisting of a field name and a field type);
  \item obtaining the list of field names from $\vfields$ yields the list of identifiers \\
        $\initializedfields$;
  \item obtaining the list of field names from $\fieldtypes$ yields the list of identifiers $\names$;
  \item checking whether the set of identifiers in $\names$ is equal to the set of identifiers in $\initializedfields$
        yields $\True$\ProseOrTypeError;
  \item checking that the list $\initializedfields$ does not contain duplicates yields \\
        $\True$\ProseOrTypeError;
  \item applying $\annotatefieldinit$ to annotate each $\field$ element $(\name,\vep)$ of \\
        $\vfields$ in $\tenv$ yields $(\name,\vepp)$\ProseOrTypeError;
  \item define $\fieldsp$ as the list containing $(\name,\vep)$ for each $\field$ element $(\name,\vep)$ of $\vfields$;
  \item $\vt$ is $\tty$;
  \item $\newe$ is the record expression with type $\tty$ and field initializers $\fieldsp$, that is, $\ERecord(\tty, \fieldsp)$;
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ERecordBegin}{\ERecordEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed}{NamedTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \tty) \typearrow \ttyanon \OrTypeError\\\\
  \checktrans{\astlabel(\ttyanon) \in \{\TRecord, \TException\}}{\RequireStructuredType} \typearrow \True\OrTypeError\\\\
  \ttyanon \eqname L(\fieldtypes)\\
  \initializedfields \eqdef \{\name \;|\; (\name, \Ignore)\in\vfields\}\\
  \names \eqdef \fieldnames(\fieldtypes)\\
  \checktrans{\{\names\} = \{\initializedfields\}}{\MissingFieldInitializer} \typearrow \True \OrTypeError\\\\
  \checknoduplicates(\initializedfields) \typearrow \True \OrTypeError\\\\
  {
    \begin{array}{r}
  (\name, \vep) \in \vfields: \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow \\
  (\name, \vepp) \OrTypeError
    \end{array}
  }\\
  \fieldsp \eqdef [(\name, \vep) \in \fields : (\name, \vepp)]
}{
  \annotateexpr{\tenv, \overname{\ERecord(\tty, \vfields)}{\ve}} \typearrow (\overname{\tty}{\vt}, \overname{\ERecord(\tty, \fieldsp)}{\newe})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{WBCQ}.}

\section{TypingRule.EGetRecordField \label{sec:TypingRule.EGetRecordField}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a \structuredtype\ with fields $\fields$;
  \item the field $\fieldname$ is associated with the type $\vt$ in $\fields$
  \item $\newe$ is the access of field $\fieldname$ on the record or exception object $\vetwo$, that is, $\EGetField(\vetwo, \fieldname)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGetRecordFieldBegin}{\EGetRecordFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \langle \vt\rangle
}{
  \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow (\vt, \EGetField(\vetwo, \fieldname))
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadRecordField \label{sec:TypingRule.EGetBadRecordField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a \structuredtype\ with fields $\fields$;
  \item the field $\fieldname$ is not associated with any type in $\fields$
  \item the result is a type error indicating the missing field.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGetBadRecordFieldBegin}{\EGetBadRecordFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow \TypeErrorVal{FieldDoesNotExist}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadBitField \label{sec:TypingRule.EGetBadBitField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item the field $\fieldname$ is not found in $\bitfields$
  \item the result is a type error indicating the missing field.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGetBadBitFieldBegin}{\EGetBadBitFieldEnd}{../Typing.ml}

\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \ve} \typearrow \TypeErrorVal{FieldDoesNotExist}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitField \label{sec:TypingRule.EGetBitField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$, that is, \\ $\BitFieldSimple(\Ignore, \slices)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vt, \newe)$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGetBitFieldBegin}{\EGetBitFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \langle \BitFieldSimple(\Ignore, \slices)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vt, \newe) \OrTypeError
}{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \newe)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldNested \label{sec:TypingRule.EGetBitFieldNested}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and nested bitfields $\bitfieldsp$, that is,
        $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe)$\ProseOrTypeError;
  \item $\vtefour$ is a bitvector type with length expression $\width$, that is, $\TBits(\width, \Ignore)$;
  \item $\vt$ is a bitvector type with length expression $\width$ and bitfields $\bitfieldsp$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGetBitFieldNestedBegin}{\EGetBitFieldNestedEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  {
    \begin{array}{r}
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \\ \langle \BitFieldNested(\Ignore, \slices, \bitfieldsp)\rangle
    \end{array}
  }\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe) \OrTypeError\\\\
  \vtefour \eqname \TBits(\width, \Ignore)\\
  \vt \eqdef \TBits(\width, \bitfieldsp)
}{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \newe)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldTyped \label{sec:TypingRule.EGetBitFieldTyped}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and typed-bitfield with type $vt$ that is,
        $\BitFieldType(\Ignore, \slices, \vt)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe)$\ProseOrTypeError;
  \item determining whether $\vtefour$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGetBitFieldTypedBegin}{\EGetBitFieldTypedEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \langle \BitFieldType(\Ignore, \slices, \vt)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe) \OrTypeError\\\\
  \checktypesat(\tenv, \vtefour, \vt) \typearrow \True \OrTypeError
}{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \newe)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetTupleItem \label{sec:TypingRule.EGetTupleItem}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is tuple type with list of types $\tys$, that is, $\TTuple(\tys)$;
  \item $\fieldname$ is an identifier with the prefix \texttt{item} and the constant $\vindex$;
  \item determining whether $\vindex$ is between $0$ and the number of types in $\tys$, inclusive, yields $\True$\ProseOrTypeError;
  \item $\vt$ is the type at position $\vindex$ of $\tys$;
  \item $\newe$ is the expression for obtaining the item at index $\vindex$ from the expression $\vetwo$, that is, $\EGetItem(\vetwo, \vindex)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGetTupleItemBegin}{\EGetTupleItemEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname \TTuple(\tys)\\
  \fieldname \eqname \texttt{"item<index>"}\\
  \checktrans{0 \leq \vindex \leq \listlen{\tys}}{IndexOutOfRange} \checktransarrow \True \OrTypeError\\\\
  \vt \eqdef \tys[\vindex]\\
  \newe \eqdef \EGetItem(\vetwo, \vindex)
}{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \newe)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadField \label{sec:TypingRule.EGetBadField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is neither one of the following types: record, exception, bitvector, or tuple;
  \item the result is an error indicating that the type of $\veone$ is inappropriate for accessing the field $\fieldname$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EGetBadFieldBegin}{\EGetBadFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \astlabel(\vtetwo) \not\in \{\TRecord, \TException, \TBits, \TTuple\}
}{
  \annotateexpr{\tenv, \ve} \typearrow \TypeErrorVal{ConflictingTypes}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EConcat \label{sec:TypingRule.EConcat}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the concatenation of a non-empty list of expressions $\vli$, that is, \\ $\EConcat(\vli)$;
  \item annotating each expression $\vle[i]$ in $\tenv$, for $i=1..k$, yields $(\vt_i, \ve_i$)\ProseOrTypeError;
  \item $\ves$ is the list of expressions $\ve_i$, for $i=1..k$;
  \item obtaining the bitvector width of $\vt_i$ in $\tenv$ (which also checks that $\vt_i$ is a bitvector type),
        for $i=1..k$, yields $\vw_i$\ProseOrTypeError;
  \item to obtain the (symbolic) width of the resulting bitvector, first define $\widthsum_1$ to be $\vw_1$;
  \item then define $\widthsum_i$, for $i=2..k$, to be obtained by reducing the expression that sums \\ $\widthsum_{i-1}$ with the width $\vw_i$;
  \item $\vt$ is the bitvector of length $\widthsum_k$ and the empty bitfield list, that is, \\ $\TBits(\widthsum_k, \emptylist)$;
  \item $\newe$ is the concatenation expression for $\ves$, that is, $\EConcat(\ves)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EConcatBegin}{\EConcatEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  i=1..k: \annotateexpr{\tenv, \vli[i]} \typearrow (\vt_i, \ve_i) \OrTypeError\\\\
  \vts \eqdef [i=1..k: \vt_i]\\
  \ves \eqdef [i=1..k: \ve_i]\\
  i=1..k: \getbitvectorwidth(\tenv, \vt_i) \typearrow \vw_i \OrTypeError\\\\
  \widthsum_1 \eqdef \vw_1\\
  i=2..k: \normalize(\tenv, \EBinop(\PLUS, \widthsum_{i-1}, \vw_i)) \typearrow \widthsum_i
}{
  \annotateexpr{\tenv, \EConcat(\vli)} \typearrow (\TBits(\widthsum_k, \emptylist), \EConcat(\ves))
}
\end{mathpar}

\subsection{Comments}
The sum of the widths of the bitvector types~\texttt{ts} might be a symbolic
expression that is unresolvable to an integer. For example:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.EConcatUnresolvableToInteger.asl}

\lrmcomment{This is related to \identr{NYNK} and \identr{KCZS}.}

\section{TypingRule.ETuple \label{sec:TypingRule.ETuple}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a tuple expression with list of expressions $\vli$, that is, $ \ETuple(\vli)$;
  \item annotating each expression $\vle[i]$ in $\tenv$, for $i=1..k$, yields $(\vt_i, \ve_i$)\ProseOrTypeError;
  \item $\vt$ is the tuple type with list of types $\vt_i$, for $i=1..k$;
  \item $\newe$ is tuple expression over list of expressions $\ve_i$, for $i=1..k$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ETupleBegin}{\ETupleEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  i=1..k: \annotateexpr{\tenv, \vle[i]} \typearrow (\vt_i, \ve_i) \OrTypeError
}{
  \annotateexpr{\tenv, \ETuple(\vli)} \typearrow (\TTuple(\vt_{1..k}), \ETuple(\ve_{1..k}))
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EUnknown \label{sec:TypingRule.EUnknown}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes an expression \UNKNOWN\ of type $\tty$, that is, $\EUnknown(\tty)$;
  \item annotating the type $\tty$ in $\tenv$ yields $\ttyone$\ProseOrTypeError;
  \item obtaining the \structure\ of $\ttyone$ in $\tenv$ yields $\ttytwo$\ProseOrTypeError;
  \item $\vt$ is $\ttyone$;
  \item $\newe$ is an expression \UNKNOWN\ of type $\ttytwo$, that is, $\EUnknown(\ttytwo)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EUnknownBegin}{\EUnknownEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \tty} \typearrow \ttyone \OrTypeError\\\\
  \tstruct(\tenv, \ttyone) \typearrow \ttytwo \OrTypeError
}{
  \annotateexpr{\tenv, \EUnknown(\tty)} \typearrow (\ttyone, \EUnknown(\ttytwo))
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.EPattern \label{sec:TypingRule.EPattern}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes whether the expression $\veone$ matches the pattern $\vpat$, that is, \\ $\EPattern(\veone, \vpat)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vtetwo, \vetwo)$\ProseOrTypeError;
  \item annotating the pattern $\vttwo$ in $\tenv$ yields $\vpatp$\ProseOrTypeError;
  \item $\vt$ is $\TBool$;
  \item $\newe$ denotes whether the expression $\vetwo$ matches $\vpatp$, that is, $\EPattern(\vetwo, \vpatp)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\EPatternBegin}{\EPatternEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtetwo, \vetwo) \OrTypeError\\\\
  \annotatepattern(\tenv, \vtetwo) \typearrow \vpatp \OrTypeError
}{
  \annotateexpr{\tenv, \EPattern(\veone, \vpat)} \typearrow (\TBool, \EPattern(\vetwo, \vpatp))
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.ATC \label{sec:TypingRule.ATC}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes an asserting type conversion with expression $\vep$ and type $\tty$, that is $\EATC(\vep, \tty)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vt, \vepp)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
  \item annotating the type $\tty$ in $\tenv$ yields $\tty'$\ProseOrTypeError;
  \item obtaining the \structure\ of $\tty'$ in $\tenv$ yields $\vtystruct$\ProseOrTypeError;
  \item applying $\checkatc$ to $\vtstruct$ and $\vtystruct$ in $\tenv$ to check whether the type assertion
        will always fail yields $\True$\ProseOrTypeError;
  \item checking whether $\vt$ \subtypesatisfies\ $\ttyp$ in $\tenv$ yields $\vb$\ProseOrTypeError;
  \item $\newe$ is $\EATC(\ttyp, \vepp)$ if $\vb$ is $\True$ and $\vepp$ otherwise;
  \item $\vt$ is $\ttyp$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\ATCBegin}{\ATCEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[type\_equal]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \annotatetype{\tenv, \tty} \typearrow \ttyp \OrTypeError\\\\
  \tstruct(\tenv, \ttyp) \typearrow \vtystruct \OrTypeError\\\\
  \checkatc(\tenv, \vtstruct, \vtystruct) \typearrow \True \OrTypeError\\\\
  \subtypesat(\tenv, \vt, \ttyp) \typearrow \vb \OrTypeError\\\\
  \newe \eqdef \choice{\vb}{\EATC(\ttyp, \vepp)}{\vepp}
}{
  \annotateexpr{\tenv, \overname{\EATC(\vep, \tty)}{\ve}} \typearrow (\overname{\ttyp}{\vt}, \newe)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{
  This is related to \identr{VBLL}, \identi{KRLL}, \identg{PFRQ}, \identi{XVBG},
  \identr{GYJZ}, \identi{SZVF}, \identr{PZZJ}, \identr{YCPX}, \identi{ZLBW},
  \identi{TCST}, \identi{CGRH}, \identi{YJBB}.
}

\hypertarget{def-annotateliteral}{}
\section{TypingRule.Lit \label{sec:TypingRule.Lit}}

Annotating literals is done via the helper function
\[
  \annotateliteral{\overname{\literal}{\vl}} \aslto \overname{\ty}{\vt}
\]
which we use in this chapter for TypingRule.ELit as well as in subsequent chapters.
\subsection{Prose}
The result of annotating a literal $\vl$ is $\vt$ and one of the following applies:
\begin{itemize}
\item (\texttt{int}): $\vl$ is an integer literal $\vn$ and $\vt$ is the well-constrained integer type, constraining
its set to the single value $\vn$;
\item (\texttt{bool}): $\vl$ is a Boolean literal and $\vt$ is the Boolean type;
\item (\texttt{real}): $\vl$ is a real literal and $\vt$ is the real type;
\item (\texttt{string}): $\vl$ is a string literal and $\vt$ is the string type;
\item (\texttt{bitvector}): $\vl$ is a bitvector literal of length $\vn$ and $\vt$ is the bitvector type of fixed width $\vn$.
\end{itemize}

\subsection{Example}
In the following example, we show several literals and their corresponding types in comments:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.Lit.asl}

\CodeSubsection{\LitBegin}{\LitEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[int]{}{\annotateliteral{\lint(n)}\typearrow \TInt(\langle[\ConstraintExact(\ELInt{n})]\rangle)}
\end{mathpar}

\begin{mathpar}
\inferrule[bool]{}{\annotateliteral{\lbool(\Ignore)}\typearrow \TBool}
\end{mathpar}

\begin{mathpar}
\inferrule[real]{}{\annotateliteral{\lreal(\Ignore)}\typearrow \TReal}
\end{mathpar}

\begin{mathpar}
\inferrule[string]{}{\annotateliteral{\lstring(\Ignore)}\typearrow \TString}
\end{mathpar}

\begin{mathpar}
\inferrule[bitvector]{
  n \eqdef \listlen{\bits}
}{
  \annotateliteral{\lbitvector(\bits)}\typearrow \TBits(\ELInt{n}, \emptylist)
}
\end{mathpar}

\section{TypingRule.ExpressionList \label{sec:TypingRule.ExpressionList}}
\hypertarget{def-annotateexprs}{}
The function
\[
  \annotateexprlist(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr^*}{\exprs})
  \aslto \overname{(\ty \times \expr)^*}{\typedexprs}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of expressions $\exprs$ from left to right, yielding a list of pairs $\typedexprs$,
each consisting of a type and expression.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\exprs$ is empty;
    \item $\typedexprs$ is empty.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\exprs$ has $\ve$ as its \head\ expression and $\exprsone$ as its \tail;
    \item annotating $\ve$ in $\tenv$ yields the pair $\typedexpr$ consisting of a type and an expression
    \ProseOrTypeError;
    \item annotating the expression list $\exprsone$ in $\tenv$ yields
    $\typedexprs$\ProseOrTypeError;
    \item $\typedexprs$ is the list with $\typedexpr$ as its \head\ and $\typedexprs$ as its \tail.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \annotateexprlist(\tenv, \overname{\emptylist}{\exprs}) \typearrow \overname{\emptylist}{\typedexprs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \annotateexpr{\tenv, \ve} \typearrow \typedexpr \OrTypeError\\\\
  \annotateexprlist(\tenv, \exprsone) \typearrow \typedexprsone \OrTypeError
}{
  \annotateexprlist(\tenv, \overname{[\ve] \concat \exprsone}{\exprs}) \typearrow \overname{[\typedexpr] \concat \typedexprsone}{\typedexprs}
}
\end{mathpar}

\section{TypingRule.ReduceSlicesToCall \label{sec:TypingRule.ReduceSlicesToCall}}
\hypertarget{def-reduceslicestocall}{}
The function
\[
  \reduceslicestocall(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve} \aslsep \overname{\slice^*}{\slices})
  \aslto
  \langle (\overname{\identifier}{\name} \times \overname{\expr^*}{\vargs})\rangle
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the expression $\ve$ together with the list of slices $\slices$ constitute
a call to a subprogram in $\tenv$.
If so, it returns a pair consisting of the name of the called subprogram --- $\name$ ---
and the list of actual arguments --- $\vargs$. Otherwise, it returns $\None$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{yes}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is a subprogram name with $\slices$ as its actual arguments
    via $\shouldslicesreducetocall$
    yields a list of actual argument expressions $\vargs$\ProseOrTypeError;
    \item $\name$ is $\vx$;
    \item the result is $\langle (\name, \vle)\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{no}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is a subprogram name with $\slices$ as its actual arguments
    via $\shouldslicesreducetocall$
    yields $\None$;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_var}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\ReduceSlicesToCallBegin}{\ReduceSlicesToCallEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[yes]{
  \shouldslicesreducetocall(\tenv, \vx, \slices) \typearrow \langle \vargs \rangle\\
  \name \eqdef \vx
}
{
  \reduceslicestocall(\tenv, \EVar(\vx), \slices) \typearrow \langle (\name, \vargs)\rangle
}
\and
\inferrule[no]{
  \shouldslicesreducetocall(\tenv, \vx, \slices) \typearrow \None
}
{
  \reduceslicestocall(\tenv, \EVar(\vx), \slices) \typearrow \None
}
\and
\inferrule[non\_var]{
  \astlabel(\ve) \neq \EVar
}
{
  \reduceslicestocall(\tenv, \ve, \slices) \typearrow \None
}
\end{mathpar}

\section{TypingRule.StaticConstrainedInteger \label{sec:TypingRule.StaticConstrainedInteger}}
\hypertarget{def-annotatestaticconstrainedinteger}{}
The function
\[
  \annotatestaticconstrainedinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\expr}{\vepp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a \staticallyevaluable\ integer expression $\ve$ of a constrained integer type in the static environment $\tenv$
and returns the annotated expression $\vepp$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the expression $\ve$ in $\tenv$ yields $ (\vt, \vep)$\ProseOrTypeError;
  \item determining whether $\vt$ is a statically \constrainedinteger\ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item determining whether $\vep$ is \staticallyevaluable\  in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\normalize$ to $\vep$ in $\tenv$ yields $\vepp$.
\end{itemize}

\CodeSubsection{\StaticConstrainedIntegerBegin}{\StaticConstrainedIntegerEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \vep) \OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \vt) \typearrow \True \OrTypeError\\\\
  \checkstaticallyevaluable(\tenv, \vep) \typearrow \True \OrTypeError\\\\
  \normalize(\tenv, \vep) \typearrow \vepp
}{
  \annotatestaticconstrainedinteger(\tenv, \ve) \typearrow \vepp
}
\end{mathpar}

\section{TypingRule.CheckATC \label{sec:TypingRule.CheckATC}}
\hypertarget{def-checkatc}{}
The function
\[
  \checkatc(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo}) \aslto
  \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the types $\vtone$ and $\vttwo$, which are assumed to not be named types,
are compatible for a typing assertion in the static environment $\tenv$, yielding $\True$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{equal}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{different\_labels\_error}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are different;
    \item the result is a type error indicating that the type assertion will always fail.
  \end{itemize}

  \item All of the following apply (\textsc{int\_bits}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is either $\TInt$ or $\TBits$;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item $\vtone$ is a tuple type with list of tuples $\vlone$, that is, $\TTuple(\vlone)$;
    \item $\vtone$ is a tuple type with list of tuples $\vltwo$, that is, $\TTuple(\vltwo)$;
    \item checking whether $\vlone$ and $\vltwo$ have the same length yields $\True$\ProseTerminateAs{\TypeErrorVal{\TypeAsssertionFails}};
    \item applying $\checkatc$ to $\vlone[\vi]$ and $\vltwo[\vi]$ in $\tenv$ for every $\vi\in\listrange(\vlone)$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$;
  \end{itemize}

  \item All of the following apply (\textsc{other\_error}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is neither $\TInt$, nor $\TBits$, nor $\TTuple$;
    \item the result is a type error indicating that the type assertion will always fail.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[equal]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[different\_labels\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) \neq \astlabel(\vttwo)
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\TypeAsssertionFails}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_bits]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \in \{\TInt, \TBits\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \vtone = \TTuple(\vlone)\\
  \vttwo = \TTuple(\vltwo)\\
  \checktrans{|\vlone|=|\vltwo|}{\TypeAsssertionFails} \typearrow \True\OrTypeError\\\\
  \vi\in\listrange(\vlone): \checkatc(\vlone[\vi], \vltwo[\vi]) \typearrow \True\OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[other\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \not\in \{\TInt, \TBits, \TTuple\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Left-Hand-Side Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatelexpr}{}
The function
\[
  \annotatelexpr{
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\lexpr}{\vle} \aslsep
    \overname{\ty}{\vte}} \aslto
    \overname{\lexpr}{\newle} \cup \TTypeError
\]
annotates a left-hand side expression $\vle$ in an environment $\tenv$, assuming $\vle$
to be the type of the corresponding right-hand-side expression,
resulting in an annotated expression $\newle$.
\ProseOtherwiseTypeError
One of the following applies:
\begin{itemize}
\item TypingRule.LEDiscard (see \secref{TypingRule.LEDiscard}),
\item TypingRule.LELocalVar (see \secref{TypingRule.LELocalVar}),
\item TypingRule.LEGlobalVar (see \secref{TypingRule.LEGlobalVar}),
\item TypingRule.LEDestructuring (see \secref{TypingRule.LEDestructuring}),
\item TypingRule.LESlice (see \secref{TypingRule.LESlice}),
\item TypingRule.LESetArray (see \secref{TypingRule.LESetArray}),
\item TypingRule.LESetBadStructuredField (see \secref{TypingRule.LESetBadStructuredField}),
\item TypingRule.LESetStructuredField (see \secref{TypingRule.LESetStructuredField}),
\item TypingRule.LESetBadBitField (see \secref{TypingRule.LESetBadBitField}),
\item TypingRule.LESetBitField (see \secref{TypingRule.LESetBitField}),
\item TypingRule.LESetBitFieldNested (see \secref{TypingRule.LESetBitFieldNested}),
\item TypingRule.LESetBitFieldTyped (see \secref{TypingRule.LESetBitFieldTyped}),
\item TypingRule.LESetBadField (see \secref{TypingRule.LESetBadField}),
\item TypingRule.LEConcat (see \secref{TypingRule.LEConcat}).
\end{itemize}

We also make use of the helper tuple
TypingRule.LEBits (see \secref{TypingRule.LEBits}).

\hypertarget{def-rexpr}{}
Some of the rules require viewing left-hand-side expressions as their corresponding right-hand side expressions.
The correspondence is defined in the ASL Syntax Reference~\cite[Chapter 5]{ASLAbstractSyntaxReference}
and given by the function $\torexpr : \lexpr \rightarrow \expr$.

\section{TypingRule.LEDiscard \label{sec:TypingRule.LEDiscard}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vle$ denotes an expression that can be discarded, that is, $\LEDiscard$;
\item $\newle$ is $\vle$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LEDiscardBegin}{\LEDiscardEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \annotatelexpr{\tenv, \overname{\LEDiscard}{\vlt}, \vte} \typearrow \overname{\LEDiscard}{\newle}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LELocalVar \label{sec:TypingRule.LELocalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes a local variable $\vx$, that is, $\LEVar(\vx)$;
  \item $\vx$ is locally declared as a mutable variable of type $\tty$ in $\tenv$;
  \item determining whether $\tty$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newle$ is $\vle$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LELocalVarBegin}{\LELocalVarEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \LEVar(\vx)\\
  L^\tenv.\localstoragetypes(\id) = (\tty, \LDKVar)\\
  \checktypesat(\tenv, \vte, \tty) \typearrow \True \OrTypeError
}{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \vle
}
\end{mathpar}


\isempty{\subsection{Comments}}
\lrmcomment{
  This is related to \identr{WDGQ}, \identr{GNTS}, \identi{MMKF},
  \identi{DGWJ}, \identi{KKCC} and \identr{LXQZ}.
}

\section{TypingRule.LEGlobalVar \label{sec:TypingRule.LEGlobalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes a local variable $\vx$, that is, $\LEVar(\vx)$;
  \item $\vx$ is globally declared as a mutable variable of type $\tty$ in $\tenv$;
  \item determining whether $\tty$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newle$ is $\vle$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LEGlobalVarBegin}{\LEGlobalVarEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \LEVar(\vx)\\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKVar)\\
  \checktypesat(\tenv, \vte, \tty) \typearrow \True \OrTypeError
 }{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \overname{\vle}{\newle}
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{WDGQ}.}

\section{TypingRule.LEDestructuring \label{sec:TypingRule.LEDestructuring}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes a tuple of left-hand-side expressions $\les$, that is, $\LEDestructuring(\les)$;
  \item $\les$ is a list $\ve_{1..k}$;
  \item $\vte$ is a tuple type $\subtys$;
  \item determining whether $\les$ and $\subtys$ have the same length yields $\True$\ProseOrTypeError;
  \item $\subtys$ is the list of types $\vt_{1..k}$;
  \item annotating the left-hand-side expression $\ve_i$ with the type $\vt_i$, for $i=1..k$, yields $\vep_i$\ProseOrTypeError;
  \item the list of expressions $\lesp$ is $\vep_i$, for $i=1..k$;
  \item $\newle$  is the list of left-hand-side expressions $\lesp$, that is, $\LEDestructuring(\lesp)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LEDestructuringBegin}{\LEDestructuringEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \LEDestructuring(\les)\\
  \les \eqname [\ve_{1..k}]\\
  \checktrans{\astlabel(\vle) = \TTuple}{TupleTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \vte \eqname \TTuple(\subtys)\\
  \equallength(\les, \subtys) \typearrow \vb\\
  \checktrans{\vb}{DifferentLengths} \checktransarrow \True \OrTypeError\\\\
  \subtys \eqname [\vt_{1..k}]\\
  i=1..k: \annotatelexpr{\tenv, \ve_i,\vt_i} \typearrow \vep_i \OrTypeError\\\\
  \lesp \eqname [i=1..k: \vep_i]
}{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \LEDestructuring(\lesp)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LESlice \label{sec:TypingRule.LESlice}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the slicing of a left-hand-side expression $\vleone$ by the slices $\slices$, that is, $\LESlice(\vleone, \slices)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\
        $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item $\vtleone$ is a bitvector type;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the width of the slices $\slices$ in $\tenv$ and simplifying them yields $\vwidth$;
  \item $\vt$ is the bitvector type of width $\width$ and empty list of bitfields;
  \item checking whether $\vte$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item annotating $\slices$ in $\tenv$ yields $\slicestwo$\ProseOrTypeError;
  \item checking that the slices $\slicestwo$ are all disjoint yields $\True$\ProseOrTypeError;
  \item $\newle$ is the slicing of $\vletwo$ by $\slicestwo$, that is, $\LESlice(\vletwo, \slicestwo)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LESliceBegin}{\LESliceEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore)\\
  \tstruct(\tenv, \vtleone) \typearrow \structtleone \OrTypeError\\\\
  \astlabel(\structtleone) = \TBits\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo\\
  \sliceswidth(\tenv, \slices) \typearrow \widthp\\
  \normalize(\tenv, \widthp) \typearrow \vwidth\\
  \vt \eqdef \TBits(\vwidth, \emptylist)\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \annotateslices(\tenv, \slices) \typearrow \slicestwo \OrTypeError\\\\
  \checkdisjointslices(\tenv, \slicestwo) \typearrow \True \OrTypeError\\\\
  \newle \eqdef \LESlice(\vletwo, \slicestwo)
}{
  \annotatelexpr{\tenv, \overname{\LESlice(\vleone, \slices)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetArray \label{sec:TypingRule.LESetArray}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the slicing of a left-hand-side expression $\vleone$ by the slices $\slices$, that is, $\LESlice(\vleone, \slices)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields an array type of size $\size$ and element type $\vt$, that is, $\TArray(\size, \vt)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ with type $\vtleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item determining that $\vte$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item determining whether $\slices$ is a single slice with index expression $\eindex$ yields $\True$\ProseOrTypeError;
  \item annotating the index expression $\eindex$ in $\tenv$ yields $(\tindexp, \eindexp)$\ProseOrTypeError;
  \item determining the array length type of $\size$ in $\tenv$ (via $\typeofarraylength$) yields $\wantedtindex$;
  \item determining whether $\tindexp$ \typesatisfies\ $\wantedtindex$ in $\tenv$ yields \\
        $\True$\ProseOrTypeError;
  \item $\newle$ is an access to array $\vletwo$ at index $\eindexp$, that is, \\ $\LESetArray(\vletwo, \eindexp)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LESetArrayBegin}{\LESetArrayEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TArray(\size, \vt) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \checktrans{\listlen{\slices} = 1}{ArraySliceShouldBeSingleIndex} \checktransarrow \True \OrTypeError\\\\
  \slices \eqname [\vs]\\
  \checktrans{\astlabel(\vs) = \SliceSingle}{ArraySliceShouldBeSingleIndex} \checktransarrow \True \OrTypeError\\\\
  \vs \eqname \SliceSingle(\eindex)\\
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp) \OrTypeError\\\\
  \typeofarraylength(\tenv, \size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\\\
  \newle \eqdef \LESetArray(\vletwo, \eindexp)
}{
  \annotatelexpr{\tenv, \overname{\LESlice(\vleone, \slices)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadStructuredField \label{sec:TypingRule.LESetBadStructuredField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\
        $\vletwo$\ProseOrTypeError;
  \item the \structure\ of $\vtleone$ in $\tenv$ is a \structuredtype\ with list of fields $\fields$\ProseOrTypeError;
  \item $\field$ is not associated with any type in $\fields$;
  \item the result is an error indicating that the field $\field$ is missing from the type of $\vleone$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LESetBadStructuredFieldBegin}{\LESetBadStructuredFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow L(\fields) \OrTypeError\\\\
  L \in \{\TException, \TRecord\}\\
  \assocopt(\fields, \field) \typearrow \None
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{MissingField}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetStructuredField \label{sec:TypingRule.LESetStructuredField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named \texttt{field} in $\vleone$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression  $\vleone$ with type $\vtleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a\structuredtype\ with fields \\
        $\fields$\ProseOrTypeError;
  \item the type associated with the field $\field$ in $\fields$ is $\vt$;
  \item determining whether $\vte$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item $\newle$ is the access to the field $\field$ in $\vletwo$, that is, $\LESetField(\vletwo, \field)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LESetStructuredFieldBegin}{\LESetStructuredFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow L(\fields) \OrTypeError\\\\
  L \in \{\TException, \TRecord\}\\
  \assocopt(\fields, \field) \typearrow \langle\vt\rangle\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \newle \eqdef \LESetField(\vletwo, \field)
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadBitField \label{sec:TypingRule.LESetBadBitField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\
        $\vtleone$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a bitvector type with bitfields \\ $\bitfields$, that is,
        $\TBits(\Ignore, \bitfields)$\ProseOrTypeError;
  \item find whether a bitfield $\field$ exists in $\bitfields$ yields $\None$;
  \item the result is a type error indicating that the field $\field$ is missing from the type of $\vleone$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LESetBadBitFieldBegin}{\LESetBadBitFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \None
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{MissingField}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitField \label{sec:TypingRule.LESetBitField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
\item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
\item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
\item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a bitvector type with with bitfields $\bitfields$\ProseOrTypeError;
\item looking for $\field$ in $\bitfields$ yields a bitfield with corresponding slices $\slices$, that is, $\BitFieldSimple(\Ignore, \slices)$;
\item $\vw$ is the width of $\slices$;
\item $\vt$ is defined as the bitvector type of width $\vw$ and empty list of bitfields, that is, $\TBits(\vw, \emptylist)$;
\item checking whether $\vt$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item $\vletwo$ is defined as the slicing of $\vleone$ by $\slices$, that is, $\LESlice(\vleone, \slices)$;
\item annotating the left-hand-side expression $\vletwo$ in $\tenv$ yields $\newle$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LESetBitFieldBegin}{\LESetBitFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \langle \BitFieldSimple(\Ignore, \slices) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vt \eqdef \TBits(\vw, \emptylist)\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow \newle \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldNested \label{sec:TypingRule.LESetBitFieldNested}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
\item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
\item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
\item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a bitvector type with with bitfields $\bitfields$\ProseOrTypeError;
\item looking for $\field$ in $\bitfields$ yields a nested bitfield with corresponding slices $\slices$ and list of bitfields
      $\bitfieldsp$, that is, \\ $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
\item $\vw$ is the width of $\slices$;
\item $\vt$ is defined as the bitvector type of width $\vw$ and list of bitfields $\bitfieldsp$, that is, $\TBits(\vw, \bitfieldsp)$;
\item checking whether $\vt$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item $\vlethree$ is defined as the slicing of $\vleone$ by $\slices$, that is, $\LESlice(\vleone, \slices)$;
\item annotating the left-hand-side expression $\vlethree$ in $\tenv$ yields $\newle$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LESetBitFieldNestedBegin}{\LESetBitFieldNestedEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \langle \BitFieldNested(\Ignore, \slices, \bitfieldsp) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vt \eqdef \TBits(\vw, \bitfieldsp)\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \vlethree \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vlethree, \vte} \typearrow \newle \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldTyped \label{sec:TypingRule.LESetBitFieldTyped}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a bitvector type with with bitfields $\bitfields$\ProseOrTypeError;
  \item looking for $\field$ in $\bitfields$ yields a typed bitfield with corresponding slices $\slices$ and a type $\vt$,
        that is, \\ $\BitFieldType(\Ignore, \vslices, \vt))$;
  \item $\vw$ is the width of $\slices$;
  \item $\vtp$ is defined as the bitvector type of width $\vw$ and an empty list of bitfields, that is, $\TBits(\vw , \emptylist)$;
  \item checking whether $\vtp$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item checking whether $\vt$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\vletwo$ is defined as the slicing of $\vleone$ by $\slices$, that is, $\LESlice(\vleone, \slices)$;
  \item annotating the left-hand-side expression $\vletwo$ in $\tenv$ yields $\newle$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LESetBitFieldTypedBegin}{\LESetBitFieldTypedEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \langle \BitFieldType(\Ignore, \vslices, \vt) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vtp \eqdef \TBits(\vw , \emptylist)
  \checktypesat(\tenv, \vtp, \vt) \typearrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow \newle \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadField \label{sec:TypingRule.LESetBadField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a type $\vt$\ProseOrTypeError;
  \item $\vt$ is neither a \structuredtype\ nor a bitvector type;
  \item the result is an error indicating that the type of $\vle$ conflicts with the requirements of a field access expression.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LESetBadFieldBegin}{\LESetBadFieldEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \vt \OrTypeError\\\\
  \astlabel(\vt) \not\in \{\TException, \TRecord, \TBits\}
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{TypeConflict}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LEConcat \label{sec:TypingRule.LEConcat}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the concatenation of left-hand-side expressions $\les$, that is, \\ $\LEConcat(\les, \Ignore)$;
  \item annotating the right-hand-side expression corresponding to $\vle$ in $\tenv$ yields \\ $(\vteeq, \Ignore)$\ProseOrTypeError;
  \item checking whether the bitwidth of $\vteeq$ equals the bitwidth of $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\les$ is the list of left-hand-side expressions $\vle_i$, for $i=1..k$;
  \item annotating each left-hand-side expression $\vle_i$ as a bitvector-typed expression (via $\annotatelebits$)
        yields the annotated left-hand-side expression $\vleone_i$ and corresponding bitwidth $\width_i$, for $i=1..k$;
  \item $\lesone$ is defined as the list $\vleone_{1..k}$;
  \item $\widths$ is defined as the list $\width_{1..k}$;
  \item $\newle$ is the concatenation of left-hand-side expressions $\lesone$ with corresponding list of widths $\widths$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\LEConcatBegin}{\LEConcatEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \LEConcat(\les, \Ignore)\\
  \annotateexpr{\tenv, \torexpr(\vle)} \typearrow (\vteeq, \Ignore) \OrTypeError\\\\
  \checkbitsequalwidth(\tenv, \vteeq, \vte) \typearrow \True \OrTypeError\\\\
  \les \eqname \vle_{1..k}\\
  i=1..k: \annotatelebits(\tenv, \vle_i) \typearrow (\vleone_i, \width_i) \OrTypeError\\\\
  \lesone \eqdef \vleone_{1..k}\\
  \widths \eqdef \width_{1..k}
}{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \overname{\LEConcat(\lesone, \widths)}{\newle}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LEBits \label{sec:TypingRule.LEBits}}
\hypertarget{def-annotatelebits}{}
The helper function
\[
  \annotatelebits(\overname{\staticenvs}{\tenv} \aslsep \overname{\lexpr}{\vle})
  \aslto \overname{\lexpr}{\vleone} \times \overname{\N}{\width}
\]
annotates a left-hand-side expression $\vle$, which is checked to be of bitvector type
with width $\width$,
resulting in the annotated expression and $\width$, or a type error, if one is detected.

All of the following apply:
\begin{itemize}
  \item annotating the right-hand-side expression corresponding to $\vle$ in $\tenv$ yields \\ $(\vteone, \Ignore)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vteone$ in $\tenv$ yields $\vteonestruct$\ProseOrTypeError;
  \item checking whether $\vteonestruct$ is a bitvector type yields $\True$\ProseOrTypeError;
  \item $\vteonestruct$ is a bitvector type with width $\ewidth$;
  \item applying $\reduceconstants$ to $\ewidth$ yields the literal $\vl$\ProseOrTypeError;
  \item checking whether $\vl$ is an integer literal yields $\True$\ProseOrTypeError;
  \item $\vl$ is the integer literal for the integer $\width$;
  \item $\vtetwo$ is defined as the bitvector type of width given by $\width$ and an empty list of bitfields, that is,
        $\TBits(\ELInt{\width}, \emptylist)$;
  \item annotating the left-hand-side expression $\vtetwo$ in $\tenv$ yields $\vleone$\ProseOrTypeError.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vteone, \Ignore) \OrTypeError\\\\
  \tstruct(\tenv, \vteone) \typearrow \vteonestruct \OrTypeError\\\\
  \checktrans{\astlabel(\vteonestruct) = \TBits}{BitvectorTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \vteonestruct \eqname \TBits(\ewidth, \Ignore)\\
  \reduceconstants(\tenv, \ewidth) \typearrow \vl\\
  \checktrans{\astlabel(\vl) = \lint}{IntegerLiteralExpected} \checktransarrow \True \OrTypeError\\\\
  \vl \eqname \lint(\width)\\
  \vtetwo \eqdef \TBits(\ELInt{\width}, \emptylist)\\
  \annotatelexpr{\tenv, \vtetwo} \typearrow \vleone \OrTypeError
}{
  \annotatelebits(\tenv, \vle) \typearrow (\vleone, \width)
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Slices \label{chap:typingslices}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotateslice}{}
The function
\[
  \annotateslice(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\vs})
  \aslto
  \overname{\slice}{\vsp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a slices $\vs$ in the static environment $\tenv$,
resulting in an annotated slice $\vsp$.
\ProseOtherwiseTypeError

One of the following applies:
\begin{itemize}
\item TypingRule.SliceSingle (see \secref{TypingRule.SliceSingle}),
\item TypingRule.SliceLength (see \secref{TypingRule.SliceLength}),
\item TypingRule.SliceRange (see \secref{TypingRule.SliceRange}),
\item TypingRule.SliceStar (see \secref{TypingRule.SliceStar}).
\end{itemize}

We also define a rule for typing of a list of slices:
TypingRule.Slices (see \secref{TypingRule.Slices}).

\hypertarget{def-annotateslices}{}
The function
\[
  \annotateslices(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slices})
  \aslto
  \overname{\slice^*}{\slicesp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of slices $\slices$ in the static environment $\tenv$,
resulting in an annotated list of slices $\slicesp$.
\ProseOtherwiseTypeError

The relevant rule is given by:
\begin{itemize}
  \item TypingRule.Slices (see \secref{TypingRule.Slices})
\end{itemize}

\section{TypingRule.SliceSingle \label{sec:TypingRule.SliceSingle}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a slice at index \vi, that is $\SliceSingle(\vi)$;
  \item annotating the slice at offset $\vi$ of length $1$ yields $\vsp$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SliceSingleBegin}{\SliceSingleEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateslice(\SliceLength(\vi, \eliteral{1})) \typearrow \vsp \OrTypeError
}{
  \annotateslice(\tenv, \SliceSingle(\vi)) \typearrow \vsp
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{\identr{GXKG}: The notation \texttt{b[i]} is syntactic sugar for \texttt{b[i +: 1]}.}

\section{TypingRule.SliceLength \label{sec:TypingRule.SliceLength}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a slice of length $\elength$ and offset $\eoffset$, that is, $\SliceLength(\eoffset, \elength)$;
  \item annotating the expression $\eoffset$ in $\tenv$ yields $(\toffset, \eoffsetp)$\ProseOrTypeError;
  \item annotating the \staticallyevaluable\ \constrainedinteger\ expression $\elength$ in $\tenv$ yields
  $\elength$\ProseOrTypeError;
  \item determining whether $\toffset$ has the \structureofinteger\ yields $\True$\ProseOrTypeError;
  \item $\vsp$ is the slice at offset $\eoffsetp$ and length $\elength'$, that is,\\
   $\SliceLength(\eoffsetp, \elength')$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SliceLengthBegin}{\SliceLengthEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \eoffset} \typearrow (\toffset, \eoffsetp) \OrTypeError\\\\
  \annotatestaticconstrainedinteger(\tenv, \elength) \typearrow \elengthp \OrTypeError\\\\
  \checkstructureinteger(\tenv, \eoffsetp, \toffset) \typearrow \True \OrTypeError
}{
  {
    \begin{array}{r}
  \annotateslice(\tenv, \SliceLength(\eoffset, \elength)) \typearrow \\
    \SliceLength(\eoffsetp, \elength')
    \end{array}
  }
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.SliceRange \label{sec:TypingRule.SliceRange}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a slice for the range \texttt{(j, i)}, that is $\SliceRange(\vj, \vi)$;
  \item $\prelength$ is \texttt{i+:(j-i+1)};
  \item annotating the slice at offset $\vi$ of length $\prelength$ yields $\vsp$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SliceRangeBegin}{\SliceRangeEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \binopliterals(\MINUS, \vi, \vi) \typearrow \prelengthp\\
  \binopliterals(\PLUS, \prelengthp, \eliteral{1}) \typearrow \prelength\\
  \annotateslice(\SliceLength(\vi, \prelength)) \typearrow \vsp \OrTypeError
}{
  \annotateslice(\tenv, \SliceRange(\vj, \vi)) \typearrow \vsp
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{\identr{GXKG}: The notation \texttt{b[j:i]} is syntactic sugar for \texttt{b[i+:(j-i+1)]}.}

\section{TypingRule.SliceStar \label{sec:TypingRule.SliceStar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a slice \texttt{[factor *: pre\_length]}, that is, $\SliceStar(\factor, \prelength)$;
  \item $\preoffset$ is $\factor * \prelength$;
  \item annotating the slice at offset $\preoffset$ of length $\prelength$ yields $\vsp$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SliceStarBegin}{\SliceStarEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \binopliterals(\MUL, \factor, \prelength) \typearrow \preoffset\\
  \annotateslice(\SliceLength(\preoffset, \prelength)) \typearrow \vsp \OrTypeError
}{
  \annotateslice(\tenv, \SliceStar(\factor, \prelength)) \typearrow \vsp
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{\identr{GXQG}: The notation \texttt{b[i *: n]} is syntactic sugar for \texttt{b[i*n +: n]}}

\section{TypingRule.Slices \label{sec:TypingRule.Slices}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the slices in $\slices$ from left to right yields the list of annotated slices $\slicesp$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vs\in\slices: \annotateslice(\tenv, \vs) \typearrow \vsp \OrTypeError\\\\
  \slicesp = [\vs\in\slices: \vsp]
}{
  \annotateslices(\tenv, \slices) \typearrow \slicesp
}
\end{mathpar}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Patterns}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatepattern}{}
The function
\[
  \annotatepattern(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\vt} \aslsep
    \overname{\pattern}{\vp}) \aslto \overname{\pattern}{\newp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a pattern $\vp$ in a static environment $\tenv$ given a type $\vt$,
resulting in a pattern $\newp$ or a type error, if one is detected, and one of the following applies:
\begin{itemize}
\item TypingRule.PAll (see \secref{TypingRule.PAll}),
\item TypingRule.PAny (see \secref{TypingRule.PAny}),
\item TypingRule.PGeq (see \secref{TypingRule.PGeq}),
\item TypingRule.PLeq (see \secref{TypingRule.PLeq}),
\item TypingRule.PNot (see \secref{TypingRule.PNot}),
\item TypingRule.PRange (see \secref{TypingRule.PRange}),
\item TypingRule.PSingle (see \secref{TypingRule.PSingle}),
\item TypingRule.PMask (see \secref{TypingRule.PMask}),
\item TypingRule.PTuple (see \secref{TypingRule.PTuple}).
\end{itemize}

\section{TypingRule.PAll \label{sec:TypingRule.PAll}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vp$ is the pattern matching everything, that is, $\PatternAll$;
  \item $\newp$ is $\vp$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\PAllBegin}{\PAllEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatepattern(\tenv, \vt, \PatternAll) \typearrow \PatternAll
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.PAny\label{sec:TypingRule.PAny}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vp$ is the pattern which matches anything in a list $\vli$, that is, $\PatternAny(\vli)$;
\item annotating each pattern in $\vli$ yields the list of annotated pattern $\newli$\ProseOrTypeError;
\item $\newp$ is the pattern which matches anything in $\newli$, that is, \\ $\PatternAny(\newli)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\PAnyBegin}{\PAnyEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vl\in\vli: \annotatepattern(\tenv, \vt, \vl) \typearrow \vlp \OrTypeError\\\\
  \newli \eqdef [\vl\in\vli: \vlp]
}
{
  \annotatepattern(\tenv, \vt, \PatternAny(\vli)) \typearrow \PatternAny(\newli)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.PGeq \label{sec:TypingRule.PGeq}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vp$ is the pattern which matches anything greater than or equal to an expression $\ve$,
that is, $\PatternGeq(\ve)$;
\item annotating the expression $\ve$ in $\tenv$ yields $(\vte, \vep)$\ProseOrTypeError;
\item determining whether $\vep$ is a \staticallyevaluable\ expression yields $\True$\ProseOrTypeError;
\item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
\item obtaining the \structure\ of $\vte$ in $\tenv$ yields $\testruct$\ProseOrTypeError;
\item $\vb$ is true if and only if $\vtstruct$ and $\testruct$ are both integer types or both real types;
\item if $\vb$ is $\False$ a type error is returned (indicating that the types of $\vt$ and $\vte$
      are inappropriate for the $\GEQ$ operator),
which short-circuits the entire rule;
\item $\newp$ is the pattern which matches anything greater than or equal to $\vep$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\PGeqBegin}{\PGeqEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \checkstaticallyevaluable(\tenv, \vep) \typearrow \True \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \tstruct(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  {
    \begin{array}{rl}
      \vb \eqdef& \astlabel(\vtstruct) = \astlabel(\testruct)\ \land\\
                & \astlabel(\vtstruct) \in \{\TInt, \TReal\}
    \end{array}
  }\\
  \checktrans{\vb}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError
}
{
  \annotatepattern(\tenv, \vt, \PatternGeq(\ve)) \typearrow \PatternGeq(\vep)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.PLeq \label{sec:TypingRule.PLeq}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vp$ is the pattern which matches anything less than or equal to an expression $\ve$,
that is, $\PatternLeq(\ve)$;
\item annotating the expression $\ve$ in $\tenv$ yields $(\vte, \vep)$\ProseOrTypeError;
\item determining whether $\vep$ is a \staticallyevaluable\ expression yields $\True$\ProseOrTypeError;
\item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
\item obtaining the \structure\ of $\vte$ in $\tenv$ yields $\testruct$\ProseOrTypeError;
\item $\vb$ is true if and only if $\vtstruct$ and $\testruct$ are both integer types or both real types;
\item if $\vb$ is $\False$ a type error is returned (indicating that the types of $\vt$ and $\vte$
      are inappropriate for the $\LEQ$ operator),
which short-circuits the entire rule;
\item $\newp$ is the pattern which matches anything less than or equal to $\vep$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\PLeqBegin}{\PLeqEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \checkstaticallyevaluable(\tenv, \vep) \typearrow \True \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \tstruct(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  {
    \begin{array}{rl}
      \vb \eqdef& \astlabel(\vtstruct) = \astlabel(\testruct)\ \land\\
                & \astlabel(\vtstruct) \in \{\TInt, \TReal\}
    \end{array}
  }\\
  \checktrans{\vb}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError
}
{
  \annotatepattern(\tenv, \vt, \PatternLeq(\ve)) \typearrow \PatternLeq(\vep)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.PNot \label{sec:TypingRule.PNot}}

\subsection{Prose}
Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern $\newp$ and all of the following apply:
\begin{itemize}
  \item $\vp$ is the pattern which matches the negation of a pattern $\vq$, that is, $\PatternNot(\vq)$;
  \item annotating $\vq$ in $\tenv$ yields $\newq$\ProseOrTypeError;
  \item $\newp$ is pattern which matches the negation of $\newq$, that is, $\PatternLeq(\newq)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\PNotBegin}{\PNotEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatepattern(\tenv, \vq) \typearrow \newq \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \PatternNot(\vq)) \PatternNot \PatternLeq(\newq)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.PRange \label{sec:TypingRule.PRange}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vp$ is the pattern which matches anything within the range given by
  expressions $\veone$ and $\vetwo$, that is, $\PatternRange(\veone, \vetwo)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \veonep)$\ProseOrTypeError;
  \item annotating the expression $\vetwo$ in $\tenv$ yields $(\vtetwo, \vetwop)$\ProseOrTypeError;
  \item determining whether both $\veonep$ and $\vetwop$ are compile-time constant expressions yields $\True$\ProseOrTypeError;
  \item obtaining the \structure\ for $\vt$, $\vteone$, and $\vtetwo$ yields
        $\vtstruct$, $\vteonestruct$, and $\vtetwostruct$, respectively\ProseOrTypeError;
  \item a check the AST labels of $\vtstruct$, $\vteonestruct$, and $\vtetwostruct$ are all the same and are either
        $\TInt$ or $\TReal$ yields $\True$. Otherwise, the result is a type error, which short-circuits the entire rule.
        The type error indicates that the types of
        $\veone$, $\vetwo$ and the type $\vt$ must be either of integer type or of real type.
  \item $\newp$ is a range pattern with bounds $\veonep$ and $\vetwop$, that is, $\PatternRange(\veonep, \vetwop)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\PRangeBegin}{\PRangeEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \veonep) \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vtetwo, \vetwop) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \tstruct(\tenv, \vteone) \typearrow \vteonestruct \OrTypeError\\\\
  \tstruct(\tenv, \vtetwo) \typearrow \vtetwostruct \OrTypeError\\\\
  {
    \begin{array}{rl}
      \vb \eqdef& \astlabel(\vtstruct) = \astlabel(\vteonestruct) = \astlabel(\vtetwostruct)\ \land\\
                & \astlabel(\vtstruct) \in \{\TInt, \TReal\}
    \end{array}
  }\\
  \checktrans{\vb}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \PatternRange(\veone, \vetwo)) \typearrow \PatternRange(\veonep, \vetwop)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.PSingle \label{sec:TypingRule.PSingle}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vp$ is the pattern that matches the expression $\ve$, that is, $\PatternSingle(\ve)$;
  \item annotating the expression $\ve$ in $\tenv$ yields $(\vte, \vep)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ yields $\vtstruct$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vte$ yields $\testruct$\ProseOrTypeError;
  \item One of the following holds:
  \begin{itemize}
    \item All of the following apply (\textsc{t\_bool, t\_real, t\_int}):
    \begin{itemize}
      \item the labels of $\vtstruct$ and $\testruct$ are both either $\TBool$, $\TReal$, or $\TInt$\ProseOrTypeError;
    \end{itemize}

    \item All of the following apply (\textsc{t\_bits}):
    \begin{itemize}
      \item the labels of $\vtstruct$ and $\testruct$ are both $\TBits$\ProseOrTypeError;
      \item determining whether the bitwidths of $\vtstruct$ and $\testruct$ are equal yields $\True$\ProseOrTypeError;
    \end{itemize}

    \item All of the following apply (\textsc{t\_enum}):
    \begin{itemize}
      \item the labels of $\vtstruct$ and $\testruct$ are both $\TEnum$\ProseOrTypeError;
      \item determining whether the lists of enumeration literals of $\vtstruct$ and $\testruct$ are equal yields $\True$\ProseOrTypeError;
    \end{itemize}

    \item All of the following apply (\textsc{error}):
    \begin{itemize}
      \item determining whether the labels of $\vtstruct$ and $\testruct$ are the same yields $\True$\ProseOrTypeError;
      \item the label of $\vtstruct$ is not one of $\TBool$, $\TReal$, $\TInt$, $\TBits$, or $\TEnum$;
      \item the result is a type error indicating that the types $\vt$ and $\vte$ are inappropriate for this pattern.
    \end{itemize}
  \end{itemize}
  \item $\newp$ is the pattern that matches the expression $\vep$, that is, $\PatternSingle(\vep)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\PSingleBegin}{\PSingleEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[t\_bool, t\_real, t\_int]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \tstruct(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  {
    \begin{array}{r}
  \checktrans{\astlabel(\vtstruct) = \astlabel(\testruct)}{InvalidTypesForBinop} \checktransarrow \\ \True \OrTypeError
    \end{array}
  }\\
  \astlabel(\vtstruct) \in \{\TBool, \TReal, \TInt\}
}{
  \annotatepattern(\tenv, \vt, \PatternSingle(\ve)) \typearrow \PatternSingle(\vep)
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \tstruct(\tenv, \vte) \typearrow \vtestruct \OrTypeError\\\\
  \astlabel(\vtstruct) = \astlabel(\testruct) = \TBits\\
  \bitwidthequal(\tenv, \vtstruct, \testruct) \typearrow \vb\\
  \checktrans{\vb}{BitvectorsDifferentWidths} \checktransarrow \True \OrTypeError\\
}{
  \annotatepattern(\tenv, \vt, \PatternSingle(\ve)) \typearrow \PatternSingle(\vep)
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \tstruct(\tenv, \vte) \typearrow \vtestruct \OrTypeError\\\\
  \vtstruct \eqname \TEnum(\vlione)\\
  \vtestruct \eqname \TEnum(\vlitwo)\\
  \checktrans{\vlione = \vlitwo}{EnumDifferentLabels} \checktransarrow \True \OrTypeError\\
}{
  \annotatepattern(\tenv, \vt, \PatternSingle(\ve)) \typearrow \PatternSingle(\vep)
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \tstruct(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  {
    \begin{array}{r}
  \checktrans{\astlabel(\vtstruct) = \astlabel(\testruct)}{InvalidTypesForBinop} \checktransarrow \\ \True \OrTypeError
    \end{array}
  }\\
  \astlabel(\vtstruct) \in \{\TBool, \TReal, \TInt, \TBits, \TEnum\}
}{
  \annotatepattern(\tenv, \vt, \PatternSingle(\ve)) \typearrow \TypeErrorVal{TypeConflict}
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.PMask \label{sec:TypingRule.PMask}}

\subsection{Prose}
All of the following apply:
  \begin{itemize}
  \item $\vp$ is the pattern which matches a mask $\vm$, that is, $\PatternMask(\vm)$;
  \item determining whether $\vt$ has the structure of a bitvector type yields $\True$\ProseOrTypeError;
  \item $\vn$ is the length of mask $\vm$;
  \item determining whether $\vt$ \typesatisfies\ the bitvector type of length $\vn$ \\
        (that is, $\TBits(\vn, \emptylist)$), yields $\True$\ProseOrTypeError;
  \item $\newp$ is $\vp$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\PMaskBegin}{\PMaskEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checkstructurelabel(\tenv, \vt, \TBits) \typearrow \True \OrTypeError\\\\
  \vn \eqdef \listlen{\vm}\\
  \checktypesat(\tenv, \vt, \TBits(\vn, \emptylist)) \typearrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \PatternMask(\vm)) \typearrow \PatternMask(\vm)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identi{VMKF}.}

\section{TypingRule.PTuple \label{sec:TypingRule.PTuple}}

\subsection{Prose}
All of the following apply:
  \begin{itemize}
  \item $\vp$ is the pattern which matches a tuple $\vli$, that is, $\PatternTuple(\vli)$;
  \item obtaining the \structure\ of $\vt$ yields $\vtstruct$\ProseOrTypeError;
  \item determining whether $\vtstruct$ is a tuple type yields $\True$\ProseOrTypeError;
  \item $\vtstruct$ is a tuple type with list of tuple $\vts$;
  \item determining whether $\vts$ is a list of the same size as $\vli$ yields $\True$\ProseOrTypeError;
  \item annotating each pattern in $\vli$ with the corresponding type in $\vts$ at each position $\vi$
        yields a pattern $\vlip[\vi]$\ProseOrTypeError;
  \item $\newli$ is the list of annotated patterns $\vlip[\vi]$ at the same positions those of $\vli$;
  \item $\newp$ is the pattern which matches the tuple $\newli$, that is, $\PatternTuple(\newli)$.
  \end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\PTupleBegin}{\PTupleEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \checktrans{\astlabel(\vtstruct) = \TTuple}{TypeConflict} \checktransarrow \True \OrTypeError\\\\
  \vtstruct \eqname \TTuple(\vts)\\
  \checktrans{\equallength(\vli, \vts)}{InvalidArity} \checktransarrow \True \OrTypeError\\\\
  \vi\in\listrange(\vli): \annotatepattern(\tenv, \vts[\vi], \vli[\vi]) \typearrow \vlip[i] \OrTypeError\\\\
  \newli \eqdef \vi\in\listrange(\vli): \vlip[\vi]
}{
  \annotatepattern(\tenv, \vt, \PatternTuple(\vli)) \typearrow \PatternTuple(\newli)
}
\end{mathpar}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Local Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatelocaldeclitem}{}
The function
\[
  \begin{array}{c}
  \annotatelocaldeclitem{
    \overname{\ty}{\tty} \aslsep
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\localdeclkeyword}{\ldk} \aslsep
    \overname{\localdeclitem}{\ldi}
   } \aslto\\
  (\overname{\staticenvs}{\newtenv} \aslsep \overname{\localdeclitem}{\newldi})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
  \end{array}
\]
annotates a local declaration item $\ldi$ with a local declaration keyword $\ldk$, given a type $\tty$,
in a static environment $\tenv$ results in $(\newenv, \newldi)$ where $\newenv$ is the modified
static environment and $\newldi$ is the annotated local declaration item.
\ProseOtherwiseTypeError

One of the following applies:
\begin{itemize}
\item TypingRule.LDDiscard (see \secref{TypingRule.LDDiscard}),
\item TypingRule.LDVar (see \secref{TypingRule.LDVar}),
\item TypingRule.LDTyped (see \secref{TypingRule.LDTyped}),
\item TypingRule.LDTuple (see \secref{TypingRule.LDTuple}).
\end{itemize}

\lrmcomment{This is related to \identr{YSPM}.}

\section{TypingRule.LDDiscard \label{sec:TypingRule.LDDiscard}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ldi$ is a local declaration which can be discarded, that is, $\LDIDiscard(\None)$;
  \item $\newenv$ is $\tenv$;
  \item $\newldi$ is $\ldi$.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDDiscard.asl}

\CodeSubsection{\LDDiscardBegin}{\LDDiscardEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \annotatelocaldeclitem{\tenv, \tty, \LDIDiscard(\None), \ldk} \typearrow (\tenv, \ldi)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LDVar \label{sec:TypingRule.LDVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ldi$ denotes a variable $\vx$, that is, $\LDIVar(\vx)$;
  \item determining whether $\vx$ is not declared in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newenv$ is $\tenv$ modified so that $\vx$ is locally declared to have type $\tty$;
  \item $\newldi$ is the declaration of variable $\vx$.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDVar.asl}

\CodeSubsection{\LDVarBegin}{\LDVarEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checkvarnotinenv{\tenv, \vx} \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \vx, \tty, \ldk) \typearrow \newtenv
}{
  \annotatelocaldeclitem{\tenv, \tty, \LDIVar(\vx), \ldk} \typearrow (\newtenv, \LDIVar(\vx))
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{YSPM}, \identd{FXST}.}

\section{TypingRule.LDTyped\label{sec:TypingRule.LDTyped}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ldi$ denotes a local declaration item $\ldip$ with local declaration keyword $\ldk$
  and a type $\vt$, that is $\LDITyped(\ldip, \vt)$;
  \item annotating the type $\vt$ in $\tenv$ yields $\vtp$\ProseOrTypeError;
  \item determining whether $\vtp$ can be initialized with $\tty$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the local declaration item $\ldip$ with the local declaration keyword $\ldk$, given
  the type $\vt$, in the environment $\tenv$, yields $(\newtenv,\newldip)$;
  \item $\newldi$ is the local declaration denoting $\newldip$ and the type $\vtp$, that is, \\
  $\LDITyped(\newldip, \vtp)$.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDTyped.asl}

\CodeSubsection{\LDTypedBegin}{\LDTypedEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \canbeinitializedwith(\tenv, \vtp, \tty) \typearrow \True \OrTypeError\\\\
  \annotatelocaldeclitem{\tenv, \vtp, \ldip, \ldk} \typearrow (\newtenv, \newldip) \OrTypeError
}
{
  \annotatelocaldeclitem{\tenv, \tty, \LDITyped(\ldip, \vt), \ldk} \typearrow \\
  (\newtenv, \LDITyped(\newldip, \vtp))
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.LDTuple\label{sec:TypingRule.LDTuple}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ldi$ denotes a tuple of local declaration items $\ldi_{1..k}$, that is, $\LDITuple(\ldi_{1..k})$;
  \item determining the \structure\ of $\tty$ in $\tenv$ yields $\vtp$\ProseOrTypeError;
  \item determining whether $\vtp$ is a tuple type yields $\True$\ProseOrTypeError;
  \item determining whether $\vtp$ the number of elements of $vtp$ is $k$ yields $\True$\ProseOrTypeError;
  \item annotating the local declaration items in $\ldis$ from right to left with their corresponding
        (that is, with the same index) types $t_{1..k}$ in $\tenv$,
        propagating static environments from one annotation to the next,
        yields the local declaration items $\ldip_{1..k}$\ProseOrTypeError;
  \item $\newtenv$ is the static environment yielded by annotating $\ldi_1$;
  \item $\newldi$ is a tuple of local declaration items with $\ldip_{1..k}$, that is, \\
        $\LDITuple(\ldip_{1..k})$.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDTuple.asl}

\CodeSubsection{\LDTupleBegin}{\LDTupleEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \tty) \typearrow \vtp \OrTypeError\\\\
  \checktrans{\astlabel(\vtp) = \TTuple}{TupleTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \vtp \eqname \TTuple([\vt_{1..n}])\\\\
  \checktrans{k = n}{InvalidArity} \checktransarrow \True \OrTypeError\\\\
  \newtenv_k = \tenv\\
  {
    \begin{array}{r}
  i=k..1:
  \annotatelocaldeclitem{\newtenv_{i}, \vt_{i}, \ldi_{i}, \ldk} \typearrow \\
  (\newtenv_{i-1}, \ldip_i) \OrTypeError
    \end{array}
  }\\
  \newtenv = \newtenv_0
}{
  \annotatelocaldeclitem{\tenv, \tty, \LDITuple(\ldi_{1..k}), \ldk} \typearrow \\
  (\newtenv, \LDITuple(\ldip_{1..k}))
}
\end{mathpar}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Statements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatestmt}{}
The function
\[
  \annotatestmt(\overname{\staticenvs}{\tenv} \aslsep \overname{\stmt}{\vs}) \aslto
  (\overname{\stmt}{\news}\aslsep \overname{\staticenvs}{\newenv})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a statement $\vs$ in an environment $\tenv$, resulting in the annotated statement
$\news$ and a modified environment $\newenv$. \ProseOtherwiseTypeError

One of the following applies:
\begin{itemize}
  \item TypingRule.SPass (see \secref{TypingRule.SPass}),
  \item TypingRule.SAssign (see \secref{TypingRule.SAssign}),
  \item TypingRule.SReturnNone (see \secref{TypingRule.SReturnNone}),
  \item TypingRule.SReturnOne (see \secref{TypingRule.SReturnOne}),
  \item TypingRule.SReturnSome (see \secref{TypingRule.SReturnSome}),
  \item TypingRule.SSeq (see \secref{TypingRule.SSeq}),
  \item TypingRule.SCall (see \secref{TypingRule.SCall}),
  \item TypingRule.SCond (see \secref{TypingRule.SCond}),
  \item TypingRule.SCase (see \secref{TypingRule.SCase}),
  \item TypingRule.SAssert (see \secref{TypingRule.SAssert}),
  \item TypingRule.SWhile (see \secref{TypingRule.SWhile}),
  \item TypingRule.SRepeat (see \secref{TypingRule.SRepeat}),
  \item TypingRule.SFor (see \secref{TypingRule.SFor}),
  \item TypingRule.SThrowNone (see \secref{TypingRule.SThrowNone}),
  \item TypingRule.SThrowSome (see \secref{TypingRule.SThrowSome}),
  \item TypingRule.STry (see \secref{TypingRule.STry}).
  \item TypingRule.SDeclSome (see \secref{TypingRule.SDeclSome}),
  \item TypingRule.SDeclNone (see \secref{TypingRule.SDeclNone}).
\end{itemize}

We also define the following helper functions:
\begin{itemize}
  \item TypingRule.CaseAlt (see \secref{TypingRule.CaseAlt}),
  \item TypingRule.SForConstraints (see \secref{TypingRule.SForConstraints})
  \item TypingRule.AnnotateLoopLimit (see \secref{TypingRule.AnnotateLoopLimit})
\end{itemize}

\section{TypingRule.SPass \label{sec:TypingRule.SPass}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a pass statement, that is, $\SPass$;
  \item $\news$ is $\vs$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SPassBegin}{\SPassEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{}{\annotatestmt(\tenv, \SPass) \typearrow (\SPass,\tenv)}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.SAssign \label{sec:TypingRule.SAssign}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is an assignment \texttt{le = re}, that is, $\SAssign(\vle, \vre)$;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{setter}):
    \begin{itemize}
      \item reducing $(\tenv, \vle, \vre)$ to a setter call via \\ $\inlinesetter{}$ yields the statement $\news$
      (indicating that the assignment corresponds to setter)\ProseOrTypeError;
      \item $\newenv$ is $\tenv$.
    \end{itemize}

    \item All of the following apply (\textsc{non\_setter}):
    \begin{itemize}
      \item reducing $(\tenv, \vle, \vre)$ to a setter call via \\ $\inlinesetter{}$ yields $\None$
            (indicating the assignment does not correspond to a setter);
      \item annotating the right-hand-side expression $\vre$ in $\tenv$ yields $(\vtre, \vreone)$\ProseOrTypeError;
      \item annotating the left-hand-side expression $\vle$ with the type $\vtre$ in $\tenv$ yields $\vleone$\ProseOrTypeError;
      \item $\news$ is the assignment \texttt{le1 = re1}, that is, $\SAssign(\vleone, \vreone)$;
      \item $\newenv$ is $\tenv$.
    \end{itemize}

  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SAssignBegin}{\SAssignEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[setter]{
  \inlinesetter{\tenv, \vle, \vre} \typearrow \langle \news \rangle \OrTypeError\\
}{
  \annotatestmt(\tenv, \overname{\SAssign(\vle, \vre)}{\vs}) \typearrow (\news,\overname{\tenv}{\newtenv})
}
\and
\inferrule[non\_setter]{
  \inlinesetter{\tenv, \vle, \vre} \typearrow \langle \rangle \OrTypeError\\\\
  \annotateexpr{\tenv, \vre} \typearrow (\vtre, \vreone) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vle, \vtre} \typearrow \vleone \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SAssign(\vle, \vre)}{\vs}) \typearrow (\overname{\SAssign(\vleone, \vreone)}{\news},\overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.SReturnNone \label{sec:TypingRule.SReturnNone}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
  \item the enclosing subprogram does not have a \texttt{return} type (it is either a setter
        or a procedure);
  \item $\news$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SReturnNoneBegin}{\SReturnNoneEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\returntype = \None
}{
  \annotatestmt(\tenv, \overname{\SReturn(\None)}{\vs}) \typearrow (\overname{\SReturn(\None)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{FTPK}.}

\section{TypingRule.SReturnOne \label{sec:TypingRule.SReturnOne}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{return\_expr\_no\_return\_type}):
    \begin{itemize}
      \item $\vs$ is a \texttt{return} statement with some expression;
      \item the enclosing subprogram does not have a return type;
    \end{itemize}
    \item All of the following apply (\textsc{return\_type\_no\_return\_expr}):
    \begin{itemize}
      \item $\vs$ is a \texttt{return} statement with no expression;
      \item the enclosing subprogram has a returned type;
    \end{itemize}
  \end{itemize}
  \item the result is an error indicating the mismatch between the declared (existence of the) return type
        and the (existence of the) return expression.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SReturnOneBegin}{\SReturnOneEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[return\_expr\_no\_return\_type]{
  L^\tenv.\returntype = \None
}{
  \annotatestmt(\tenv, \overname{\SReturn(\langle\Ignore\rangle)}{\vs}) \typearrow \TypeErrorVal{InvalidReturnStmt}
}
\and
\inferrule[return\_type\_no\_return\_expr]{
  L^\tenv.\returntype = \langle\Ignore\rangle
}{
  \annotatestmt(\tenv, \overname{\SReturn(\None)}{\vs}) \typearrow \TypeErrorVal{InvalidReturnStmt}
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{FTPK}.}

\section{TypingRule.SReturnSome \label{sec:TypingRule.SReturnSome}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{return} statement with an expression $\ve$, that is, $\SReturn(\langle \vep \rangle)$;
  \item the enclosing subprogram has a return type $\vt$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tep,\vep)$\ProseOrTypeError;
  \item checking whether $\vtep$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is a \texttt{return} statement with value $\vep$, that is, $\SReturn(\langle \vep \rangle)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SReturnSomeBegin}{\SReturnSomeEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\returntype = \langle \vt \rangle\\
  \annotateexpr{\tenv, \ve} \typearrow (\vtep, \vep) \OrTypeError\\\\
  \checktypesat(\tenv, \vtep, \vt) \typearrow \True \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SReturn(\langle \ve \rangle)}{\vs}) \typearrow
  (\overname{\SReturn(\langle \vep \rangle)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{FTPK}.}

\section{TypingRule.SSeq \label{sec:TypingRule.SSeq}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is the AST node for the sequence of statements $\vsone$ and $\vstwo$, that is, $\SSeq(\vsone, \vstwo)$;
  \item annotating $\vsone$ in $\tenv$ yields $(\newsone, \tenvone)$\ProseOrTypeError;
  \item annotating $\vstwo$ in $\tenvone$ yields $(\newstwo, \newtenv)$\ProseOrTypeError;
  \item $\news$ is the AST node for the sequence of statements $\newsone$ and $\newstwo$, that is, $\SSeq(\newsone, \newstwo)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SSeqBegin}{\SSeqEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatestmt(\tenv, \vs1) \typearrow (\newsone, \tenvone) \OrTypeError\\\\
  \annotatestmt(\tenvone, \vs2) \typearrow (\newstwo, \newtenv) \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SSeq(\vsone, \vstwo)}{\vs}) \typearrow (\overname{\SSeq(\newsone, \newstwo)}{\news}, \newtenv)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.SCall \label{sec:TypingRule.SCall}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a call to a subprogram named $\name$ with arguments $\vargs$;
  \item annotating the call to $\name$ with arguments $\vargs$, as a procedure (that is, with $\STProcedure$),
        as per \chapref{TypingSubprogramCalls} (which makes sure that the call does not have a return type),
        yields $(\newname, \newargs, \eqs, \None)$\ProseOrTypeError;
  \item $\news$ is the call to a subprogram named $\newname$ with arguments
        $\newargs$ and parameter assignments $\neweqs$;
  \item $\newtenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SCallBegin}{\SCallEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatecall(\tenv, \name, \vargs, \STProcedure) \typearrow (\newname, \newargs, \eqs, \None)
}{
  {
    \begin{array}{r}
  \annotatestmt(\tenv, \overname{\SCall(\name, \vargs)}{\vs}) \typearrow \\
  (\overname{\SCall(\newname, \newargs, \eqs)}{\news}, \tenv)
    \end{array}
  }
}
\end{mathpar}

\subsection{Comments}
Notice that the input statement, which belongs to the parsed AST, has two children nodes ---
$\name$ and $\vargs$, whereas the output statement, which belongs to the typed AST has the additional
node $\neweqs$, which associates expressions with parameters.

\lrmcomment{This is related to \identd{VXKM}.}

\section{TypingRule.SCond \label{sec:TypingRule.SCond}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a condition $\ve$ with the statements $\vsone$ and $\vstwo$, that is, $\SCond(\ve, \vsone, \vstwo)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tcond, \econd)$\ProseOrTypeError;
  \item checking that $\tcond$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
  \item annotating the statement $\vsone$ in $\tenv$ yields $\vsonep$\ProseOrTypeError;
  \item annotating the statement $\vstwo$ in $\tenv$ yields $\vstwop$\ProseOrTypeError;
  \item $\news$ is the condition $\econd$ with the statements $\vsonep$ and $\vstwop$, that is, \\ $\SCond(\econd, \vsonep, \vstwop)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SCondBegin}{\SCondEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\tcond, \econd) \OrTypeError\\\\
  \checktypesat(\tenv, \tcond, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock{\tenv, \vsone} \typearrow \vsonep \OrTypeError\\\\
  \annotateblock{\tenv, \vstwo} \typearrow \vstwop \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \typearrow
  (\overname{\SCond(\econd, \vsonep, \vstwop)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{NBDJ}.}

\section{TypingRule.SCase \label{sec:TypingRule.SCase}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a case statement with expression $\ve$ and case clauses $\vcases$, that is, \\
        $\SCase(\veone, \vcasesone)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte, \veone)$\ProseOrTypeError;
  \item annotating each case clause as per \secref{TypingRule.CaseAlt} in $\vcases$ yields the annotated list of clauses $\vcasesone$\ProseOrTypeError;
  \item $\news$ is a case statement with expression $\veone$ and case clauses $\vcasesone$;
  \item $\newenv$ is $\tenvone$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SCaseBegin}{\SCaseEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \veone) \OrTypeError\\\\
  \vi\in\listrange(\vcases): \annotatecase{\tenv, \vcases[\vi]} \typearrow \vcase_\vi \OrTypeError\\\\
  \vcasesone \eqdef [\vi\in\listrange(\vcases): \vcase_\vi]
}{
  \annotatestmt(\tenv, \overname{\SCase(\ve, \vcases)}{\vs}) \typearrow
  (\overname{\SCase(\veone, \vcasesone)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{WGSY}.}

\section{TypingRule.SAssert \label{sec:TypingRule.SAssert}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is an assert statement with expression $\ve$, that is, $\SAssert(\ve)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tep,\vep)$\ProseOrTypeError;
  \item checking that $\vtep$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is an assert statement with expression $\vep$, that is, $\SAssert(\vep)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SAssertBegin}{\SAssertEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vtep, \vep) \OrTypeError\\\\
  \checktypesat(\tenv, \vtep, \TBool) \typearrow \True \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SAssert(\ve)}{\vs}) \typearrow (\overname{\SAssert(\vep)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{JQYF}.}

\section{TypingRule.SWhile \label{sec:TypingRule.SWhile}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vs$ is a \texttt{while} statement with expression $\veone$, optional limit expression $\vlimitone$,
      and statement block $\vsone$, that is, $\SWhile(\veone, \vsone)$;
\item annotating the right-hand-side expression $\veone$ in $\tenv$ yields $(\vt, \vetwo)$\ProseOrTypeError;
\item annotating the optional limit expression $\vlimitone$ via $\annotatelooplimit$ in $\tenv$ yields $\vlimittwo$\ProseOrTypeError;
\item checking that $\vt$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item $\news$ is a \texttt{while} statement with expression $\vetwo$, optional limit expression $\vlimittwo$,
      and statement block $\vstwo$, that is, $\SWhile(\vetwo, \vstwo)$;
\item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SWhileBegin}{\SWhileEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo) \OrTypeError\\\\
  \annotatelooplimit(\tenv, \vlimitone) \typearrow \vlimittwo \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock{\tenv, \vsone} \typearrow \vstwo \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SWhile(\veone, \vlimitone, \vsone)}{\vs}) \typearrow
  (\overname{\SWhile(\vetwo, \vlimittwo, \vstwo)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{FTVN}.}

\section{TypingRule.SRepeat \label{sec:TypingRule.SRepeat}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement with statement block $\vsone$,
        optional limit expression $\vlimitone$, and expression $\veone$, that is, $\SRepeat(\vsone, \veone, \vlimitone)$;
  \item annotating $\vsone$ as a block statement in $\tenv$ yields $\vstwo$\ProseOrTypeError;
  \item annotating the optional limit expression $\vlimitone$ via $\annotatelooplimit$ in $\tenv$ yields $\vlimittwo$\ProseOrTypeError;
  \item annotating the right-hand-side expression $\veone$ in $\tenv$ yields $(\vt, \vetwo)$\ProseOrTypeError;
  \item checking that $\vt$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is a \texttt{repeat} statement with statement block $\vstwo$, optional limit expression $\vlimittwo$,
        and condition expression $\vetwo$ and , that is, $\SRepeat(\vstwo, \vetwo, \vlimittwo)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SRepeatBegin}{\SRepeatEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateblock{\tenv, \vsone} \typearrow \vstwo \OrTypeError\\\\
  \annotatelooplimit(\tenv, \vlimitone) \typearrow \vlimittwo \OrTypeError\\\\
  \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SRepeat(\veone, \vsone, \vlimitone)}{\vs}) \typearrow
  (\overname{\SRepeat(\vetwo, \vstwo, \vlimittwo)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{FTVN}.}

\section{TypingRule.SFor \label{sec:TypingRule.SFor}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement with index $\vindexname$,
        start expression $\vstarte$,
        direction $\dir$,
        end expression $\vende$,
        body statement (block) $\vbody$,
        and optional limit expression $\vlimit$,
        that is, $\SFor\left\{\begin{array}{rcl}
          \Forindexname &:& \vindexname\\
          \Forstarte &:& \vstarte\\
          \fordirection &:& \vdirection\\
          \Forende &:& \vende\\
          \Forbody &:& \vbody\\
          \Forlimit &:& \vlimit
        \end{array}\right\}$;
  \item annotating the right-hand-side expression $\vstarte$ in $\tenv$ yields \\
        $(\vstartt, \vstartep)$\ProseOrTypeError;
  \item annotating the right-hand-side expression $\vende$ in $\tenv$ yields $(\vendt, \vendep)$\ProseOrTypeError;
  \item annotating the optional loop limit expression $\vlimit$ via $\annotatelooplimit$ in $\tenv$
        yields $\vlimitp$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vstartt$ in $\tenv$ yields $\vstartstruct$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vendt$ in $\tenv$ yields $\vendstruct$\ProseOrTypeError;
  \item applying $\getforconstraints$ to $\vstartstruct$, $\vendstruct$,
        $\vstartep$, $\vendep$, and $\dir$ in $\tenv$,
        to obtain the constraints on the loop index $\vindexname$,
        yields $\cs$\ProseOrTypeError;
  \item $\tty$ is the integer type with constraints $\cs$;
  \item checking that $\vindexname$ is not already declared in $\tenv$ yields $\True$\ProseOrTypeError;
  \item adding $\vindexname$ as a local immutable variable with type $\tty$ to $\tenv$ yields $\tenvp$;
  \item annotating $\vbody$ as a block statement in $\tenvp$ yields $\vbodyp$\ProseOrTypeError;
  \item $\news$ is the \texttt{for} statement with index $\vindexname$,
        start expression $\vstartep$, direction $\dir$,
        end expression $\vendep$,
        body statement (block) $\vbodyp$, and
        optional limit expression $\vlimit$;
  \item $\newtenv$ is $\tenv$ (notice that this means $\vindexname$ is only declared for annotating $\vbodyp$ but then goes
        out of scope).
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SForBegin}{\SForEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vstarte} \typearrow (\vstartt, \vstartep) \OrTypeError\\\\
  \annotateexpr{\tenv, \vende} \typearrow (\vendt, \vendep) \OrTypeError\\\\
  \annotatelooplimit(\tenv, \vlimit) \typearrow \vlimitp \OrTypeError\\\\
  \makeanonymous(\tenv, \vtone) \typearrow \vstartstruct \OrTypeError\\\\
  \makeanonymous(\tenv, \vttwo) \typearrow \vendstruct \OrTypeError\\\\
  {
    \begin{array}{r}
  \getforconstraints(\tenv, \vstartstruct, \vendstruct, \vstartep, \vendep, \dir) \typearrow \\
    \cs \OrTypeError
    \end{array}
  }\\\\
  \tty \eqdef \TInt(\cs)\\
  \checkvarnotinenv{\tenv, \vindexname} \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \tty, \vindexname, \LDKLet) \typearrow \tenvp\\
  \annotateblock{\tenvp, \vbody} \typearrow \vbodyp \OrTypeError
}{
  {
    \begin{array}{r}
  \annotatestmt\left(\tenv, \overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdirection\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \vlimit
  \end{array}\right\}}{\vs}\right) \typearrow \\
  \left(\overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \vindexname\\
    \Forstarte &:& \vstartep\\
    \fordirection &:& \vdirection\\
    \Forende &:& \vendep\\
    \Forbody &:& \vbodyp\\
    \Forlimit &:& \vlimitp
  \end{array}\right\}}{\news}, \overname{\tenv}{\newtenv}\right)
\end{array}
  }
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{SSBD}, \identr{ZSND}, \identr{VTJW}.}

\section{TypingRule.SThrowNone \label{sec:TypingRule.SThrowNone}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a throw statement with no expression, that is, $\SThrow(\None)$;
  \item $\news$ is $\vs$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SThrowNoneBegin}{\SThrowNoneEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \annotatestmt(\tenv, \overname{\SThrow(\None)}{\vs}) \typearrow (\overname{\SThrow(\None)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{Note that \identr{BRCJ} is done in~\cite[SemanticsRule.TopLevel]{ASLSemanticsReference}.}

\section{TypingRule.SThrowSome \label{sec:TypingRule.SThrowSome}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a throw statement with expression $\ve$, that is, $\SThrow(\langle (\ve, \Ignore) \rangle)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte, \vep)$\ProseOrTypeError;
  \item checking that $\vte$ has the structure of an exception type yields $\True$\ProseOrTypeError;
  \item $\news$ is a throw statement with expression $\vep$ and type $\vte$, that is, \\
        $\SThrow(\langle (\vep, \langle\vte\rangle) \rangle)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SThrowSomeBegin}{\SThrowSomeEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \checkstructurelabel(\tenv, \vte, \TException) \typearrow \True \OrTypeError
}{
  \annotatestmt(\tenv, \overname{\SThrow(\langle (\ve, \Ignore) \rangle)}{\vs}) \typearrow
  (\overname{\SThrow(\langle (\vep, \langle\vte\rangle) \rangle)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{NXRC}.}

\section{TypingRule.STry \label{sec:TypingRule.STry}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a try statement with statement $\vsp$, list of catchers $\catchers$ and an \optional\ \texttt{otherwise} block;
  \item annotating the statement $\vsp$ as a block statement yields $\vspp$\ProseOrTypeError;
  \item annotating each catcher $\vc$ in $\catchers$ in $\tenv$ yields $\vcp$\ProseOrTypeError;
  \item $\catchersp$ is the list of annotated catchers $\vcp$ for each $\vc\in\catchers$;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{no\_otherwise}):
    \begin{itemize}
      \item there is no \texttt{otherwise} statement;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and no \texttt{otherwise} statement,
            that is \\
            $\STry(\vspp, \catchersp, \None)$;
    \end{itemize}

    \item All of the following apply (\textsc{otherwise}):
    \begin{itemize}
      \item there is an \texttt{otherwise} statement $\otherwise$;
      \item annotating the statement $\otherwise$ as a block statement in $\tenv$ yields $\otherwisep$\ProseOrTypeError;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and \texttt{otherwise} statement
            $\otherwisep$, that is \\
            $\STry(\vspp, \catchersp, \langle\otherwisep\rangle)$;
    \end{itemize}
  \end{itemize}
  \item $\newenv$ is $\tenv$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\STryBegin}{\STryEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[no\_otherwise]{
  \annotateblock{\tenv, \vsp} \typearrow \vspp \OrTypeError\\\\
  \vc \in \catchers: \annotatecatcher{\tenv, \vc} \typearrow \vcp \OrTypeError\\\\
  \catchersp \eqdef [\vc \in \catchers : \vcp]\\
  \news \eqdef \STry(\vspp, \catchersp, \None)
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \None)}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv})
}
\and
\inferrule[otherwise]{
  \annotateblock{\tenv, \vsp} \typearrow \vspp \OrTypeError\\\\
  \annotateblock{\tenv, \otherwise} \typearrow \otherwisep \OrTypeError\\\\
  \vc \in \catchers: \annotatecatcher{\tenv, \vc} \typearrow \vcp \OrTypeError\\\\
  \catchersp \eqdef [\vc \in \catchers : \vcp]\\
  \news \eqdef \STry(\vspp, \catchersp, \otherwise')
}{
  \annotatestmt(\tenv, \overname{\STry(\vsp, \catchers, \langle\otherwise\rangle)}{\vs}) \typearrow (\news, \overname{\tenv}{\newtenv})
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{WVXS}.}

\section{TypingRule.SDeclSome \label{sec:TypingRule.SDeclSome}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a declaration with local declaration keyword $\ldk$, local identifiers $\ldi$, and an expression $\ve$,
        that is, $\SDecl(\ldk, \ldi, \langle\ve\rangle)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte,\vep)$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{constant}):
    \begin{itemize}
      \item $\ldk$ indicates a local constant declaration, that is, $\LDKConstant$;
      \item symbolically simplifying $\ve$ in $\tenv$ yields the literal $\vv$\ProseOrTypeError;
      \item declaring a local constant of type $\vte$, literal $\vv$ and identifier $\ldi$ in $\tenv$ yields $(\newtenv, \ldip)$;
      \item $\news$ is a declaration with $\ldk$, $\ldip$ and an expression $\vep$.
    \end{itemize}

    \item All of the following apply (\textsc{non\_constant}):
    \begin{itemize}
      \item $\ldk$ indicates that this is not a local constant declaration, that is, $\ldk\neq\LDKConstant$;
      \item declaring the local identifiers $\ldi$ of type $\vte$ with local declaration keyword $\ldk$ in $\tenv$
            yields $(\newtenv, \ldip)$;
      \item $\news$ is a declaration with $\ldk$, $\ldip$ and an expression $\vep$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SDeclSomeBegin}{\SDeclSomeEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[constant]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \ldk =\LDKConstant\\
  \reduceconstants(\tenv, \ve) \typearrow \vv \OrTypeError\\\\
  \declarelocalconstant{\tenv, \vte, \vv, \ldi} \typearrow (\newtenv, \ldip)\\
  \news \eqdef \SDecl(\LDKConstant, \ldip, \langle\vep\rangle)
}{
  \annotatestmt(\tenv, \overname{\SDecl(\ldk, \ldi, \langle\ve\rangle)}{\vs}) \typearrow (\news, \newtenv)
}
\and
\inferrule[non\_constant]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \ldk \neq \LDKConstant\\
  \annotatelocaldeclitem{\tenv, \vte, \ldk, \ldi} \typearrow (\newtenv, \ldip)\\
  \news \eqdef \SDecl(\LDKConstant, \ldip, \langle\vep\rangle)
}{
  \annotatestmt(\tenv, \overname{\SDecl(\ldk, \ldi, \langle\ve\rangle)}{\vs}) \typearrow (\news, \newtenv)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{YSPM}.}

\section{TypingRule.SDeclNone \label{sec:TypingRule.SDeclNone}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vs$ is a local declaration statement with a variable keyword and local identifiers $\ldi$, and no initial expression,
      that is, $\SDecl(\LDKVar, \ldi, \None)$ (local declarations of \texttt{let} variables and constants require
      an initializing expression, otherwise they are rejected by an ASL parser);
\item annotating the uninitialised local declarations $\ldi$ in $\tenv$ yields $(\newtenv, \ldip)$;
\item $\news$ is a local declaration statement with variable keyword, local identifiers $\ldip$, and no initial expression,
      that is, $\SDecl(\LDKVar, \ldip, \None)$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SDeclNoneBegin}{\SDeclNoneEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatelocaldeclitemuninit{\tenv, \ldi} \typearrow (\newtenv, \ldip) \OrTypeError\\\\
  \news \eqdef \SDecl(\LDKVar, \ldip, \None)
}{
  \annotatestmt(\tenv, \overname{\SDecl(\LDKVar, \ldi, \None)}{\vs}) \typearrow (\news, \newtenv)
}
\end{mathpar}

\isempty{\subsection{Comments}}

\section{TypingRule.CaseAlt \label{sec:TypingRule.CaseAlt}}

\hypertarget{def-annotatecase}{}
The helper function
\[
  \annotatecase{
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\vte} \aslsep
    \overname{\casealt}{\vcase}
  } \aslto
  \overname{\casealt}{\vcaseone} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the case clause $\vcase$ for matching an expression of type $\vte$ in $\tenv$,
resulting in the annotated case clause $\vcaseone$, or a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vcase$ is a case clause with pattern $\vpzero$, \optional\ \texttt{where} expression $\vwzero$,
        and \texttt{otherwise} statement $\vszero$, that is,
        $\{ \text{pattern} : \vpzero, \text{where} : \vwzero, \text{stmt} : \vszero \}$;
  \item annotating the pattern $\vpzero$ with type $\vte$ in $\tenv$ yields $\vpone$\ProseOrTypeError;
  \item annotating the statement $\vszero$ as a block statement in $\tenv$ yields $\vsone$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{no\_where}):
    \begin{itemize}
      \item $\vwzero$ is $\None$ (that is, no \texttt{where} expression);
      \item $\vcaseone$ is $\{ \text{pattern} : \vpone, \text{where} : \None, \text{stmt} : \vsone \}$.
    \end{itemize}

    \item All of the following apply (\textsc{where}):
    \begin{itemize}
      \item $\vwzero$ is the expression $\vewzero$;
      \item annotating the expression $\vewzero$ in $\tenv$ yields $(\vtwe, \vewone)$\ProseOrTypeError;
      \item checking whether the structure of $\vtwe$ in $\tenv$ is that of the \texttt{boolean} type yields $\True$\ProseOrTypeError;
      \item $\vcaseone$ is $\{ \text{pattern} : \vpone, \text{where} : \langle\vewone\rangle, \text{stmt} : \vsone \}$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[no\_where]{
  \vcase \eqname \{ \text{pattern} : \vpzero, \text{where} : \None, \text{stmt} : \vszero \}\\
  \annotatepattern(\tenv, \vte, \vpzero) \typearrow \vpone \OrTypeError\\\\
  \annotateblock{\tenv, \vszero} \typearrow \vsone \OrTypeError\\
}{
  \annotatecase{\tenv, \vcase} \typearrow \{ \text{pattern} : \vpone, \text{where} : \None, \text{stmt} : \vsone \}
}
\and
\inferrule[where]{
  \vcase \eqname \{ \text{pattern} : \vpzero, \text{where} : \langle\vewzero\rangle, \text{stmt} : \vszero \}\\
  \annotatepattern(\tenv, \vte, \vpzero) \typearrow \vpone \OrTypeError\\\\
  \annotateblock{\tenv, \vszero} \typearrow \vsone \OrTypeError\\\\
  \annotateexpr{\tenv, \vewzero} \typearrow (\vtwe, \vewone) \OrTypeError\\\\
  \checkstructurelabel(\tenv, \vtwe, \TBool) \typearrow \True \OrTypeError
}{
  \annotatecase{\tenv, \vcase} \typearrow \{ \text{pattern} : \vpone, \text{where} : \langle\vewone\rangle, \text{stmt} : \vsone \}
}
\end{mathpar}

\section{TypingRule.SForConstraints \label{sec:TypingRule.SForConstraints}}
\hypertarget{def-getforconstraints}{}
The function
\[
  \getforconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\structone} \aslsep
    \overname{\ty}{\structtwo} \aslsep
    \overname{\expr}{\veonep} \aslsep
    \overname{\expr}{\vetwop} \aslsep
    \overname{\dir}{\dir}
  ) \aslto
  \overname{\intconstraints}{\vis} \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
infers the integer constraints --- $\vis$ --- for a \texttt{for} loop index variable from the following:
\begin{itemize}
  \item the \wellconstrainedversion\ of the type of the start expression --- $\structone$
  \item the \wellconstrainedversion\ of the type of the end expression --- $\structtwo$
  \item the annotated start expression --- $\veonep$
  \item the annotated end expression --- $\vetwop$
  \item the loop direction --- $\dir$
\end{itemize}
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{not\_integers}):
  \begin{itemize}
    \item at least one of $\structone$ and $\structtwo$ is not an integer type;
    \item the result is a type error indicating that the start expression and end expression of \texttt{for} loops
          must have the \structure\ of integer types.
  \end{itemize}

  \item All of the following apply (\textsc{unconstrained}):
  \begin{itemize}
    \item both of $\structone$ and $\structtwo$ is not an integer type;
    \item at least one of $\structone$ and $\structtwo$ is the unconstrained integer type;
    \item define $\vis$ as $\unconstrained$.
  \end{itemize}

  \item All of the following apply (\textsc{well\_constrained}):
  \begin{itemize}
    \item $\structone$ is the integer type with integer constraints $\csone$;
    \item $\structtwo$ is the integer type with integer constraints $\cstwo$;
    \item symbolically simplifying $\veonep$ in $\tenv$ yields $\eonen$\ProseOrTypeError;
    \item symbolically simplifying $\vetwop$ in $\tenv$ yields $\etwon$\ProseOrTypeError;
    \item define $\icsup$ as the single range constraint with expressions $\eonen$ and $\etwon$;
    \item define $\icsdown$ as the single range constraint with expressions $\etwon$ and $\eonen$;
    \item define $\vis$ as $\icsup$ if $\dir$ is $\UP$ and $\icsdown$ otherwise.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[not\_integers]{
  \astlabel(\structone) \neq \TInt \lor \astlabel(\structtwo) = \TInt
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \TypeErrorVal{\RequireIntegerForLoopBounds}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  {
    \begin{array}{cccl}
    \structone = \unconstrainedinteger &\land& \astlabel(\structtwo) = \TInt & \lor\\
    \astlabel(\structone) = \TInt &\land& \structtwo = \unconstrainedinteger & \\
    \end{array}
  }
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \overname{\unconstrained}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \structone = \TInt(\csone)\\
  \structtwo = \TInt(\cstwo)\\\\
  \normalize(\tenv, \veonep) \typearrow \eonen \OrTypeError\\\\
  \normalize(\tenv, \vetwop) \typearrow \etwon \OrTypeError\\\\
  \icsup \eqdef \wellconstrained([\ConstraintRange(\eonen, \etwon)])\\
  \icsdown \eqdef \wellconstrained([\ConstraintRange(\etwon, \eonen)])\\
  \vis \eqdef \choice{\dir=\UP}{\icsup}{\icsdown}
}{
  \getforconstraints(\tenv, \structone, \structtwo, \veonep, \vetwop, \dir) \typearrow \vis
}
\end{mathpar}

\section{TypingRule.AnnotateLoopLimit \label{sec:TypingRule.AnnotateLoopLimit}}
\hypertarget{def-annotatelooplimit}{}
The function
\[
  \annotatelooplimit(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\langle\expr\rangle}{\ve} \aslsep
  ) \aslto
  \overname{\expr}{\vep} \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates an optional expression $\ve$ serving as the limit of a loop in $\tenv$,
yielding the optional loop expression $\vep$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\ve$ is $\None$;
    \item $\vep$ is $None$.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\ve$ is $\langle\vlimit\rangle$;
    \item annotating $\vlimit$ in $\tenv$ yields $(\vt, \vlimitp)$\ProseOrTypeError;
    \item checking that $\vt$ is a constrained integer in $\tenv$ via \\
          $\checkconstrainedinteger$ yields $\True$\ProseOrTypeError;
    \item $\vep$ is $\langle\vlimitp\rangle$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \annotatelooplimit(\tenv, \overname{\None}{\vlimit}) \typearrow \overname{\None}{\vlimitp}
}
\end{mathpar}

\CodeSubsection{\AnnotateLoopLimitBegin}{\AnnotateLoopLimitEnd}{../Typing.ml}

\begin{mathpar}
\inferrule[some]{
  \annotateexpr{\tenv, \vlimit} \typearrow (\vt, \vlimitp) \OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \vt) \typearrow \True \OrTypeError
}{
  \annotatelooplimit(\tenv, \overname{\langle\vlimit\rangle}{\vlimit}) \typearrow \overname{\langle\vlimitp\rangle}{\vlimitp}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Blocks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotateblock}{}
The function
\[
  \annotateblock{\overname{\staticenvs}{\tenv} \aslsep \overname{\stmt}{\vs}} \aslto
  \overname{\stmt}{\newstmt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a block statement $\vs$ in static environment $\tenv$ and returns the annotated
statement $\newstmt$ or a type error, if one is detected.

\section{TypingRule.Block \label{sec:TypingRule.Block}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the statement $\vs$ in $\tenv$ yields $(\newstmt, \newtenv)$\ProseOrTypeError;
  \item the modified environment $\newtenv$ is dropped.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.Block0.asl}

\CodeSubsection{\BlockBegin}{\BlockEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatestmt(\tenv, \vs) \typearrow (\newstmt, \Ignore) \OrTypeError
}{
  \annotateblock{\tenv, \vs} \typearrow \newstmt
}
\end{mathpar}

\subsection{Comments}
A local identifier declared in a block statement (with \texttt{var}, \texttt{let}, or \texttt{constant})
is in scope from the point immediately after its declaration until the end of the
immediately enclosing block. This means, we can discard the environment at the end of
an enclosing block, which has the effect of dropping bindings of the identifiers declared inside the block.

\lrmcomment{This is related to \identr{JBXQ}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Catchers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatecatcher}{}
The function
\[
\begin{array}{r}
  \annotatecatcher{
    \overname{\staticenvs}{\tenv} \aslsep
    (\overname{\langle\identifier\rangle}{\nameopt} \times \overname{\ty}{\tty} \times \overname{\stmt}{\vstmt})
  } \aslto \\
  (\overname{\langle\identifier\rangle}{\nameopt} \times \overname{\ty}{\ttyp} \times \overname{\stmt}{\newstmt})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates a catcher given by the \optional\ name of the matched exception --- $\nameopt$ ---
the exception type --- $\tty$ --- and the statement to execute upon catching the exception --- $\vstmt$.
The result is the catcher with the same \optional\ name --- $\nameopt$, an annotated type $\ttyp$, and annotated statement $\newstmt$.
\ProseOtherwiseTypeError

One of the following applies:
\begin{itemize}
\item TypingRule.CatcherNone (see \secref{TypingRule.CatcherNone}),
\item TypingRule.CatcherSome (see \secref{TypingRule.CatcherSome}).
\end{itemize}

\section{TypingRule.CatcherNone \label{sec:TypingRule.CatcherNone}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the catcher has no named identifier, that is, $(\None, \tty, \vstmt)$;
  \item annotating the type $\tty$ in $\tenv$ yields $\ttyp$\ProseOrTypeError;
  \item determining whether $\ttyp$ has the \structure\ of an exception type yields $\True$\ProseOrTypeError;
  \item annotating the block $\vstmt$ in $\tenv$ yields $\newstmt$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\CatcherNoneBegin}{\CatcherNoneEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \vt} \typearrow \ttyp \OrTypeError\\\\
  \checkstructurelabel(\tenv, \ttyp, \TException) \typearrow \True \OrTypeError\\\\
  \annotateblock{\tenv, \vstmt} \typearrow \newstmt \OrTypeError
}{
  \annotatecatcher{\tenv, (\overname{\None}{\nameopt}, \tty, \vstmt)} \typearrow (\overname{\None}{\nameopt}, \ttyp, \newstmt)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{SDJK}.}

\section{TypingRule.CatcherSome \label{sec:TypingRule.CatcherSome}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the catcher has a named identifier, that is, $(\langle\name\rangle, \tty, \vstmt)$;
  \item annotating the type $\tty$ in $\tenv$ yields $\ttyp$\ProseOrTypeError;
  \item determining whether $\ttyp$ has the \structure\ of an exception type yields $\True$\ProseOrTypeError;
  \item the identifier $\name$ is not bound in $\tenv$;
  \item binding $\name$ in the local environment of $\tenv$ with the type $\ttyp$ as an immutable variable
        (that is, with the local declaration keyword $\LDKLet$), yields the static environment $\tenvp$;
  \item annotating the block $\vstmt$ in $\tenvp$ yields $\newstmt$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\CatcherSomeBegin}{\CatcherSomeEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \vt} \typearrow \ttyp \OrTypeError\\\\
  \checkstructurelabel(\tenv, \ttyp, \TException) \typearrow \True \OrTypeError\\\\
  \checkvarnotinenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \name, \ttyp, \LDKLet) \typearrow \tenvp\\
  \annotateblock{\tenvp, \vstmt} \typearrow \newstmt \OrTypeError
}{
  \annotatecatcher{\tenv, (\overname{\langle\name\rangle}{\nameopt}, \tty, \vstmt)} \typearrow
  (\overname{\langle\name\rangle}{\nameopt}, \ttyp, \newstmt)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{SDJK}, \identr{WVXS}, \identi{FCGK}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Subprogram Calls \label{chap:TypingSubprogramCalls}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatecall}
The function
\[
  \begin{array}{rl}
  \annotatecall( &
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\expr^*}{\vargs} \aslsep
    \overname{\subprogramtype}{\calltype}
   ) \aslto \\ &
  (\overname{\identifier}{\nameone} \aslsep
  \overname{\expr^*}{\vargsone} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\langle \ty \rangle}{\rettyopt})
\end{array}
\]
annotates the call to subprogram $\name$ with arguments $\vargs$
and call type $\calltype$, resulting in the following:
\begin{itemize}
  \item $\nameone$ --- a string, which uniquely identifies $\name$ among the set of overloading subprograms declared with $\name$;
  \item $\vargsone$ --- the annotated argument expressions;
  \item $\eqs$ --- the expressions providing values to the parameters;
  \item $\rettyopt$ --- the \optional\ annotated return type.
\end{itemize}
\ProseOtherwiseTypeError

The function is defined by the rule TypingRule.AnnotateCall (see \secref{TypingRule.AnnotateCall}).

We also define helper functions via respective rules:
\begin{itemize}
  \item TypingRule.AnnotateCallArgTyped (see \secref{TypingRule.AnnotateCallArgTyped})
  \item TypingRule.CheckCalleeParams (see \secref{TypingRule.CheckCalleeParams})
  \item TypingRule.RenameTyEqs (see \secref{TypingRule.RenameTyEqs})
  \item TypingRule.SubstExprNormalize (see \secref{TypingRule.SubstExprNormalize})
  \item TypingRule.SubstExpr (see \secref{TypingRule.SubstExpr})
  \item TypingRule.SubstConstraint (see \secref{TypingRule.SubstConstraint})
  \item TypingRule.CheckArgsTypeSat (see \secref{TypingRule.CheckArgsTypeSat})
  \item TypingRule.AnnotateParameterDefining (see \secref{TypingRule.AnnotateParameterDefining})
  \item TypingRule.AnnotateRetTy (\secref{TypingRule.AnnotateRetTy})
  \item TypingRule.SubprogramForName (see \secref{TypingRule.SubprogramForName})
  \item TypingRule.DeduceEqs (see \secref{TypingRule.DeduceEqs})
  \item TypingRule.FilterCallCandidates (see \secref{TypingRule.FilterCallCandidates})
  \item TypingRule.HasArgClash (see \secref{TypingRule.HasArgClash})
\end{itemize}

\section{TypingRule.AnnotateCall \label{sec:TypingRule.AnnotateCall}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\annotateexprlist$ to annotate the expression list $\vargs$ in $\tenv$ yields \\
        $\callerargtyped$\ProseOrTypeError;
  \item applying $\annotatecallargtyped$ to $\name$, $\callerargtyped$, $\calltype$ in $\tenv$ yields
        $(\nameone, \vargsone, \eqs, \retty)$\ProseOrTypeError.
\end{itemize}

\CodeSubsection{\AnnotateCallBegin}{\AnnotateCallEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexprlist(\tenv, \vargs) \typearrow \callerargtyped \OrTypeError\\\\
  {
    \begin{array}{r}
  \annotatecallargtyped(\tenv, \name, \callerargtyped, \calltype) \typearrow \\
   (\nameone, \vargsone, \eqs, \retty) \OrTypeError
    \end{array}
  }
}{
  \annotatecall(\tenv, \name, \vargs, \calltype) \typearrow
  (\nameone, \vargsone, \eqs, \retty)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{
  This is related to \identi{VFDP}, \identd{TRFW}, \identr{KMDB},
  \identi{YMHX}, \identr{CCVD}, \identr{QYBH}, \identr{PFWQ}, \identr{ZLWD},
  \identi{FLKF}, \identd{PMBL}, \identr{MWBN}, \identr{TZSP}, \identr{SBWR},
  \identi{CMLP}, \identr{BQJG}, \identr{RTCF}.
}

\section{TypingRule.AnnotateCallArgTyped \label{sec:TypingRule.AnnotateCallArgTyped}}
\hypertarget{def-annotatecallargtyped}{}
The function
\[
  \begin{array}{r}
  \annotatecallargtyped(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{(\ty \times\expr)^*}{\callerargstyped} \aslsep
    \overname{\subprogramtype}{\calltype}
   ) \aslto \\
  (\overname{\identifier}{\nameone} \aslsep
  \overname{\expr^*}{\vargsone} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\langle \ty \rangle}{\rettyopt})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
is similar to $\annotatecall$, except that the argument expressions are replaced by
the annotated expressions. That is, pairs consisting of a type and an expression.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\unziplist$ to $\callerargtyped$ yields the corresponding lists of types
        and expressions $\callerargtypes$ and $\vargsone$;
  \item applying $\subprogramforname$ to match $\name$ and $\callerargtypes$ in $\tenv$
        yields $(\eqsone, \nameone, \callee)$\ProseOrTypeError;
  \item checking that $\subprogramtype$ of $\callee$ equals $\calltype$ yields $\True$\ProseOrTypeError;
  \item checking that the lengths of $\callee.\funcargs$ and $\vargsone$ are the same yields $\True$\ProseOrTypeError;
  \item applying $\annotateparameterdefining$ to $\callee.\funcargs$,
        $\callerargstyped$, and \\
        $\calleeparams$ in $\tenv$ to annotate the implicit parameters
        yields $\eqsthreep$\ProseOrTypeError;
  \item define $\eqsthree$ is the concatenation of $\eqsthreep$ and $\eqsone$;
  \item applying $\checkargstypesat$ to $\calleeargtypes$
        to check that the actual arguments have correct types with respect to $\callerargtypes$
        in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\checkcalleeparams$ to $\calleeparams$ to check they have correct types
        with respect to $\eqsthree$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\annotateretty$ to $\calltype$ and $\callee.\funcreturntype$
        to check that the two call types match and to substitute actual parameter arguments in the formal return type
        yields $\rettyopt$ \ProseOrTypeError;
  \item define $\eqs$ as $\eqsthree$.
\end{itemize}

\CodeSubsection{\AnnotateCallArgTypedBegin}{\AnnotateCallArgTypedEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \unziplist(\callerargstyped) = (\callerargtypes, \vargsone)\\
  {
    \begin{array}{r}
    \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \\
  (\eqsone, \nameone, \callee) \OrTypeError
    \end{array}
  }\\
  \checktrans{\callee.\subprogramtype = \calltype}{\MismatchedReturnValue} \checktransarrow \True\OrTypeError\\\\
  \equallength(\callee.\funcargs, \vargsone) \typearrow \aritymatch\\
  \checktrans{\aritymatch}{\CallBadArity} \checktransarrow \True\\\\
  {
  \annotateparameterdefining\left(
    \begin{array}{l}
      \tenv,\\
      \callee.\funcargs, \\
      \callerargstyped, \\
      \callee.\funcparameters
    \end{array}
    \right)
    \typearrow \eqsthreep \OrTypeError
  }\\
  \eqsthree \eqdef \eqsthreep \concat \eqsone\\
  \checkargstypesat(\tenv, \callee.\funcargs, \callerargtypes, \eqsthree) \typearrow \True \OrTypeError\\\\
  \checkcalleeparams(\tenv, \callee.\funcparameters, \eqsthree) \typearrow \True \OrTypeError\\\\
  \annotateretty(\tenv, \calltype, \callee.\funcreturntype) \typearrow \rettyopt \OrTypeError
}{
  {
    \begin{array}{r}
  \annotatecallargtyped(\tenv, \name, \callerargstyped, \calltype) \typearrow \\
  (\nameone, \vargsone, \overname{\eqsthree}{\eqs}, \rettyopt)
    \end{array}
  }
}
\end{mathpar}

\section{TypingRule.CheckCalleeParams \label{sec:TypingRule.CheckCalleeParams}}
\hypertarget{def-checkcalleeparams}{}
The function
\[
\checkcalleeparams(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\langle\ty\rangle)^*}{\calleeparams}
  \overname{(\identifier\times\expr)^*}{\eqsthree}
  ) \aslto \\
  \True\ \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks that the parameters in $\calleeparams$ are correct with respect
to the parameter expressions $\eqsthree$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\calleeparams$ is an empty list;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\calleeparams$ is a non-empty list with \head\ $\calleeparam$ and \tail\ \\
          $\calleeparamsone$;
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply (\textsc{no\_type}):
      \begin{itemize}
        \item $\calleeparam$ does not have a type annotation, that is, $(\Ignore, \None)$.
      \end{itemize}

      \item All of the following apply (\textsc{parameterized}):
      \begin{itemize}
        \item $\calleeparam$ is a parameter $\vs$ with a type annotation of a
              \parameterizedintegertype\ for the same parameter, that is, \\
              $(\vs, \langle\TInt(\parameterized(\vs))\rangle)$.
      \end{itemize}

      \item All of the following apply (\textsc{other}):
      \begin{itemize}
        \item $\calleeparam$ is a parameter $\vs$ whose type annotation is \\
              $\calleeparamt$, that is, $(\vs, \langle\calleeparamt\rangle)$;
        \item $\calleeparamt$ is not the \parameterizedintegertype\ for the same parameter;
        \item substituting the parameter expressions from $\eqsthree$ in $\calleeparamt$
              yields $\calleeparamtrenamed$\ProseOrTypeError;
        \item applying $\assocopt$ to $\eqsthree$ and $\vs$ the expression $\callerparame$
              (that is, the parameter $\vs$ is associated with the expression \\
              $\callerparame$);
        \item annotating the expression $\callerparame$ in $\tenv$ yields \\
              $(\callerparamt, \Ignore)$\ProseOrTypeError;
        \item checking that $\callerparamt$ \typesatisfies\ $\calleeparamtrenamed$ in $\tenv$ yields
              $\True$\ProseOrTypeError;
      \end{itemize}
    \end{itemize}
    \item applying $\checkcalleeparams$ to $\calleeparamsone$ and $\eqsthree$ in $\tenv$
          yields $\True$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{
}{
  \checkcalleeparams(\tenv, \overname{\emptylist}{\calleeparams}, \eqsthree) \typearrow \True
}
\and
\inferrule[no\_type]{
  \calleeparams \eqname [(\Ignore, \None)] \concat \calleeparamsone\\
  \checkcalleeparams(\tenv, \calleeparamsone, \eqsthree) \typearrow \True \OrTypeError
}{
  \checkcalleeparams(\tenv, \calleeparams, \eqsthree) \typearrow \True
}
\and
\inferrule[parameterized]{
  \calleeparams \eqname [(\vs, \langle\TInt(\parameterized(\vs))\rangle)] \concat \calleeparamsone\\
  \checkcalleeparams(\tenv, \calleeparamsone, \eqsthree) \typearrow \True \OrTypeError
}{
  \checkcalleeparams(\tenv, \calleeparams, \eqsthree) \typearrow \True
}
\and
\inferrule[other]{
  \calleeparams \eqname [(\vs, \langle\calleeparamt\rangle)] \concat \calleeparamsone\\
  \calleeparamt \neq \TInt(\parameterized(\vs))\\
  \renametyeqs(\tenv, \eqsthree, \calleeparamt) \typearrow \calleeparamtrenamed \OrTypeError\\\\
  \assocopt(\eqsthree, \vs) \typearrow \langle \ve \rangle\\
  \annotateexpr{\tenv, \callerparame} \typearrow \callerparamt \OrTypeError\\\\
  \checktypesat(\tenv, \callerparamt, \calleeparamtrenamed) \typearrow \True \OrTypeError\\\\
  \checkcalleeparams(\tenv, \calleeparamsone, \eqsthree) \typearrow \True \OrTypeError
}{
  \checkcalleeparams(\tenv, \calleeparams, \eqsthree) \typearrow \True
}
\end{mathpar}

\section{TypingRule.RenameTyEqs \label{sec:TypingRule.RenameTyEqs}}
\hypertarget{def-renametyeqs}{}
The function
\[
\renametyeqs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\ty}{\tty}
) \aslto
\overname{\ty}{\newty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
transforms the type $\tty$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, yielding the type $\newty$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{t\_bits}):
  \begin{itemize}
    \item $\tty$ is a bitvector type with width expression $\ve$ and fields $\fields$, that is, $\TBits(\ve, \fields)$;
    \item applying $\substexprnormalize$ to $\eqs$ and $\ve$ in $\tenv$ yields the expression $\newe$;
    \item define $\newty$ as a bitvector type with with expression $\newe$ and fields $\fields$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_wellconstrained}):
  \begin{itemize}
    \item $\tty$ is a well-constrained integer type with constraints $\constraints$;
    \item applying $\substconstraint$ to each constraint $\constraints[\vi]$, for $\vi$ in \\
          $\listrange(\constraints)$, yields the constraint $\newc_\vi$;
    \item define $\newconstraints$ as the list of constraints $\newc_\vi$, for $\vi$ in \\
          $\listrange(\constraints)$;
    \item define $\newty$ as the well-constrained integer type with constraints \\
          $\newconstraints$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_parameterized}):
  \begin{itemize}
    \item $\tty$ is a \parameterizedintegertype\ for the parameter $\name$;
    \item applying $\substexprnormalize$ to $\eqs$ and the expression $\EVar(\name)$ yields $\ve$;
    \item define $\newty$ as the well-constrained integer type with the single constraint for $\ve$, that is,
          $\TInt(\wellconstrained(\ConstraintExact(\ve)))$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
    \item $\tty$ is the tuple type over the list of tuples $\tys$, that is, $\TTuple(\tys)$;
    \item applying $\renametyeqs$ to $\eqs$ and the type $\tys[\vi]$, for each $\vi$ in \\
          $\listrange(\tys)$, yields the type $\newty_\vi$;
    \item define $\newtys$ as the list of types $\newty_\vi$, for each $\vi$ in $\listrange(\tys)$;
    \item define $\newty$ as the tuple type over $\newtys$, that is, $\TTuple(\newtys)$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\tty$ is not one of the types in the previous cases,
          that is, $\tty$ is not a bitvector type, nor an integer type, nor a tuple type;
    \item $\newty$ is $\tty$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[t\_bits]{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}{
  \renametyeqs(\tenv, \eqs, \overname{\TBits(\ve, \fields)}{\tty}) \typearrow \overname{\TBits(\newe, \fields)}{\newty}
}
\and
\inferrule[t\_int\_wellconstrained]{
  \vi\in\listrange(\constraints): \substconstraint(\tenv, \constraints[\vi]) \typearrow \newc_\vi\\
  \newconstraints \eqdef [\vi\in\listrange(\constraints): \newc_\vi]\\
  \newty \eqdef \TInt(\wellconstrained(\newconstraints))
}{
  \renametyeqs(\tenv, \eqs, \overname{\TInt(\wellconstrained(\constraints))}{\tty}) \typearrow
  \newty
}
\and
\inferrule[t\_int\_parameterized]{
  \substexprnormalize(\eqs, \EVar(\name)) \typearrow \ve\\
  \newty \eqdef \TInt(\wellconstrained(\ConstraintExact(\ve)))
}{
  \renametyeqs(\tenv, \eqs, \overname{\TInt(\parameterized(\name))}{\tty}) \typearrow \newty
}
\and
\inferrule[t\_tuple]{
  \vi\in\listrange(\tys): \renametyeqs(\eqs, \tys[\vi]) \typearrow \newty_\vi\\
  \newtys \eqdef [\vi\in\listrange(\tys): \newty_\vi]
}{
  \renametyeqs(\tenv, \eqs, \overname{\TTuple(\tys)}{\tty}) \typearrow
  \overname{\TTuple(\newtys)}{\newty}
}
\and
\inferrule[other]{
  \astlabel(\tty) \not\in \{\TBits, \TInt, \TTuple\}
}{
  \renametyeqs(\tenv, \eqs, \tty) \typearrow \overname{\tty}{\newty}
}
\end{mathpar}

\section{TypingRule.SubstExprNormalize \label{sec:TypingRule.SubstExprNormalize}}
\hypertarget{def-substexprnormalize}{}
The function
\[
\substexprnormalize(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\newe}{\expr}
\]
transforms the expression $\ve$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, and then attempting to symbolically simplify the result, yielding the expression $\newe$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item transforming $\ve$ in the static environment $\tenv$, by substituting the parameter expressions
        $\eqs$, yields $\veone$;
  \item symbolically simplifying $\veone$ in $\tenv$ yields $\newe$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \substexpr(\tenv, \ve) \typearrow \veone\\
  \normalize(\tenv, \veone) \typearrow \newe
}{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}
\end{mathpar}

\section{TypingRule.SubstExpr \label{sec:TypingRule.SubstExpr}}
\hypertarget{def-substexpr}{}
The function
\[
\substexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\substs} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\newe}{\expr}
\]
transforms the expression $\ve$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, yielding the expression $\newe$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{e\_var\_in\_substs}):
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vs$, that is, $\EVar(\vs)$;
    \item applying $\assocopt$ to $\vs$ and $\substs$ yields the expression $\newe$.
          That is, $\vs$ is a parameter with an associated expression;
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_not\_in\_substs}):
  \begin{itemize}
    \item $\ve$ is the variable expression for the identifier $\vs$, that is, $\EVar(\vs)$;
    \item applying $\assocopt$ to $\vs$ and $\substs$ yields $\None$.
          That is, $\vs$ is not a parameter with an associated expression;
    \item define $\newe$ is $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop}):
  \begin{itemize}
    \item $\ve$ is the unary operator expression for the operator $\op$ and expression $\ve$, that is, $\EUnop(\op, \veone)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the unary operator expression for the operator $\op$ and expression $\veonep$, that is, $\EUnop(\op, \veonep)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop}):
  \begin{itemize}
    \item $\ve$ is the binary operator expression for the operator $\op$ and expressions $\veone$ and $\vetwo$, that is, $\EBinop(\op, \veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the unary operator expression for the operator $\op$ and expression $\veonep$, that is, $\EUnop(\op, \veonep)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_cond}):
  \begin{itemize}
    \item $\ve$ is the conditional expression for expressions $\veone$, $\vetwo$, and $\vethree$, that is, \\
          $\ECond(\veone, \vetwo, \vethree)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item applying $\substexpr$ to $\substs$ and $\vethree$ in $\tenv$ yields $\vethreep$;
    \item define $\newe$ as the conditional expression for expressions $\veonep$, $\vetwop$, and $\vethreep$, that is, $\ECond(\veonep, \vetwop, \vethreep)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_concat}):
  \begin{itemize}
    \item $\ve$ is the concatenation of expressions $\ves$, that is, $\EConcat(\ves)$;
    \item applying $\substexpr$ to $\substs$ and every expression $\ves[\vi]$, for $\vi$ in \\
          $\listrange(\ves)$ yields $\vep[\vi]$;
    \item define $\vesp$ as the list of expressions $\vep[\vi]$, for $\vi$ in $\listrange(\ves)$;
    \item define $\newe$ as the concatenation of expressions $\vesp$, that is, $\EConcat(\vesp)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_call}):
  \begin{itemize}
    \item $\ve$ is the call expression for subprogram $\vx$ with arguments $\vargs$ and parameter expressions $\paramargs$,
          that is, $\ECall(\vx, \vargs, \paramargs)$;
    \item applying $\substexpr$ to $\substs$ and every argument expression $\vargs[\vi]$, for $\vi$ in \\
          $\listrange(\vargs)$ yields $\ve_\vi$;
    \item define $\vargsp$ as $\ve_\vi$ or $\vi$ in $\listrange(\vargs)$;
    \item define $\newe$ as the call expression for subprogram $\vx$ with arguments $\vargsp$ and parameter expressions $\paramargs$,
    that is, $\ECall(\vx, \vargsp, \paramargs)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getarray}):
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and index expression $\vetwo$,
          that is, $\EGetArray(\veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the \arrayaccess\ expression for base expression $\veonep$ and index expression $\vetwop$,
    that is, $\EGetArray(\veonep, \vetwop)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfield}):
  \begin{itemize}
    \item $\ve$ is the field access expression for base expression $\ve$ and field $\vx$,
          that is, $\EGetField(\veone, \vx)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the field access expression for base expression $\ve$ and field $\vx$,
          that is, $\EGetField(\veonep, \vx)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfields}):
  \begin{itemize}
    \item $\ve$ is the access to fields $\fields$ with base expression $\veone$, that is, \\
          $\EGetFields(\veone, \fields)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the access to fields $\fields$ with base expression $\veonep$, that is, $\EGetFields(\veonep, \fields)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getitem}):
  \begin{itemize}
    \item $\ve$ is the access to tuple item $\vi$ of the tuple expression $\veone$, that is, \\
          $\EGetItem(\veone, \vi)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the access to tuple item $\vi$ of the tuple expression $\veonep$, that is, \\
          $\EGetItem(\veonep, \vi)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_pattern}):
  \begin{itemize}
    \item $\ve$ is the pattern expression of expression $\veone$ and patterns $\vps$, that is, \\
          $\EPattern(\veone, \vps)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the pattern expression of expression $\veonep$ and patterns $\vps$, that is, $\EPattern(\veonep, \vps)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_record}):
  \begin{itemize}
    \item $\ve$ is the record expression of record type $\vt$ and list of fields $\fields$;
    \item for every pair $(\vx,\veone)$ in $\fields$, applying $\substexpr$ to $\substs$ $\veone$ in $\tenv$ yields $\veonep_\vx$;
    \item define $\fieldsp$ as the list of pairs $(\vx,\veonep_\vx)$ for every pair $(\vx,\veone)$ in $\fields$;
    \item define $\newe$ as the record expression of record type $\vt$ and list of fields $\fieldsp$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_tuple}):
  \begin{itemize}
    \item $\ve$ is the tuple expression of expressions $\ves$, that is, $\ETuple(\ves)$;
    \item applying $\substexpr$ to $\substs$ and every expression $\ves[\vi]$ in $\tenv$, for every $\vi$ in $\listrange(\ves)$
          yields $\newe_\vi$;
    \item define $\vesp$ as the list of expressions $\newe_\vi$, for every $\vi$ in $\listrange(\ves)$;
    \item define $\newe$ as the tuple expression of expressions $\vesp$, that is, $\ETuple(\vesp)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_atc}):
  \begin{itemize}
    \item $\ve$ is the type assertion of expression $\veone$ and type $\vt$, that is, $\EATC(\veone, \vt)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the type assertion of expression $\veonep$ and type $\vt$, that is, $\EATC(\veonep, \vt)$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\ve$ is either a literal expression or an unknown value expression;
    \item define $\newe$ as $\ve$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[e\_var\_in\_substs]{
  \assocopt(\vs, \substs) \typearrow \langle\newe\rangle
}{
  \substexpr(\tenv, \substs, \overname{\EVar(\vs)}{\ve}) \typearrow \newe
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_not\_in\_substs]{
  \assocopt(\vs, \substs) \typearrow \None
}{
  \substexpr(\tenv, \substs, \overname{\EVar(\vs)}{\ve}) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\
}{
  \substexpr(\tenv, \substs, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \overname{\EUnop(\op, \veonep)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \overname{\EBinop(\op, \veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop\\
  \substexpr(\tenv, \substs, \vethreep) \typearrow \vethreep\\
}{
  \substexpr(\tenv, \substs, \overname{\ECond(\veone, \vetwo, \vethree)}{\ve}) \typearrow \overname{\ECond(\veonep, \vetwop, \vethreep)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_concat]{
  \vi\in\listrange(\ves): \substexpr(\tenv, \substs, \ves[\vi]) \typearrow \vep[\vi]\\
  \vesp \eqdef [\vi\in\listrange(\ves): \vep[\vi]]
}{
  \substexpr(\tenv, \substs, \overname{\EConcat(\ves)}{\ve}) \typearrow \overname{\EConcat(\vesp)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_call]{
  \vi\in\listrange(\vargs): \substexpr(\tenv, \substs, \vargs[\vi]) \typearrow \ve_\vi\\
  \vargsp \eqdef [\vi\in\listrange(\vargs): \ve_\vi]
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\ECall(\vx, \vargs, \paramargs)}{\ve}) \typearrow \\ \overname{\ECall(\vx, \vargsp, \paramargs)}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getarray]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EGetArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\EGetArray(\veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfield]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetField(\veone, \vx)}{\ve}) \typearrow \overname{\EGetField(\veonep, \vx)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfields]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetFields(\veone, \fields)}{\ve}) \typearrow \overname{\EGetFields(\veonep, \fields)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getitem]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetItem(\veone, \vi)}{\ve}) \typearrow \overname{\EGetItem(\veonep, \vi)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EPattern(\veone, \vps)}{\ve}) \typearrow \overname{\EPattern(\veonep, \vps)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record]{
  (\vx, \veone)\in\fields: \substexpr(\tenv, \substs, \veone) \typearrow \veone_\vx\\
  \fieldsp \eqdef [(\vx, \veone)\in\fields: (\vx, \veone_\vx)]
}{
  \substexpr(\tenv, \substs, \overname{\ERecord(\vt, \fields)}{\ve}) \typearrow \overname{\ERecord(\vt, \fieldsp)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\ESlice(\veone, \slices)}{\ve}) \typearrow \overname{\ESlice(\veonep, \slices)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_tuple]{
  \vi\in\listrange(\ves): \substexpr(\tenv, \substs, \ves[\vi]) \typearrow \newe_\vi\\
  \vesp \eqdef [\vi\in\listrange(\ves): \newe_\vi]
}{
  \substexpr(\tenv, \substs, \overname{\ETuple(\ves)}{\ve}) \typearrow \overname{\ETuple(\vesp)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_atc]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EATC(\veone, \vt)}{\ve}) \typearrow \overname{\EATC(\veonep, \vt)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \in \{\ELiteral, \EUnknown\}\
}{
  \substexpr(\tenv, \substs, \ve) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}

\section{TypingRule.SubstConstraint \label{sec:TypingRule.SubstConstraint}}
\hypertarget{def-substconstraint}{}
The function
\[
\substconstraint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\intconstraint}{\vc}
) \aslto \overname{\newc}{\intconstraint}
\]
transforms the integer constraint $\vc$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, and then attempting to symbolically simplify the result,
yielding the integer constraint $\newc$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\ve$ yields $\newe$;
    \item define $\newc$ as the exact constraint for the expression $\newe$, that is, \\
          $\ConstraintExact(\newe)$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\veone$ yields $\veonep$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\vetwo$ yields $\vetwop$;
    \item define $\newc$ as the range constraint for the expressions $\veonep$ and $\vetwop$, that is, $\ConstraintRange(\veonep, \vetwop)$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[exact]{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}{
  \substconstraint(\tenv, \eqs, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\ConstraintExact(\newe)}{\newc}
}
\and
\inferrule[range]{
  \substexprnormalize(\tenv, \eqs, \veone) \typearrow \veonep\\
  \substexprnormalize(\tenv, \eqs, \vetwo) \typearrow \vetwop
}{
  \substconstraint(\tenv, \eqs, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\ConstraintRange(\veonep, \vetwop)}{\newc}
}
\end{mathpar}

\section{TypingRule.CheckArgsTypeSat \label{sec:TypingRule.CheckArgsTypeSat}}
\hypertarget{def-checkargstypesat}{}
The function
\[
\begin{array}{r}
  \checkargstypesat(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\identifier\times\ty)^*}{\calleeargs} \aslsep
    \overname{\ty^*}{\callerargtypes} \aslsep
    \overname{(\identifier\times\expr)^*}{\eqsthree}
  ) \aslto \\
  \True\ \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
checks that the types $\callerargtypes$ \typesatisfy\ the types of the corresponding
formal arguments $\calleeargs$ with the parameters substituted with their corresponding
arguments as per $\eqsthree$ and results in a type error otherwise.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item both $\calleeargs$ and $\callerargtypes$ are empty;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item view $\calleeargs$ as a list with \head\ $(\calleeargname, \calleearg)$ and \tail\ $\calleeargsone$;
    \item view $\callerargtypes$ as a list with \head\ $\callerarg$ and \tail\ \\
          $\callerargtypesone$;
    \item applying $\renametyeqs$ to $\eqsthree$ and $\calleearg$ in $\tenv$
          to substitute parameter arguments in $\calleearg$ yields $\calleeargone$\ProseOrTypeError;
    \item checking that $\callerarg$ \typesatisfies\ $\calleeargone$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item applying $\checkargstypesat$ to $\calleeargsone$, $\callerargtypesone$, and $\eqsthree$ in $\tenv$
          yields $\True$\ProseOrTypeError;
    \item the result is $\True$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
We note that it is guaranteed by TypingRule.AnnotateCallArgTyped
that $\vargs$ and $\callerargstyped$ have the same length.

\begin{mathpar}
\inferrule[empty]{}{
  \checkargstypesat(\tenv, \overname{\emptylist}{\calleeargs}, \overname{\emptylist}{\callerargtypes}, \eqsthree)
  \typearrow \True
}
\and
\inferrule[non\_empty]{
  \calleeargs \eqname [(\calleeargname, \calleearg)] \concat \calleeargsone\\
  \callerargtypes \eqname [\callerarg] \concat \callerargtypesone\\
  \renametyeqs(\tenv, \eqsthree, \calleearg) \typearrow \calleeargone\OrTypeError\\\\
  \checktypesat(\tenv, \callerarg, \calleeargone) \typearrow \True\OrTypeError\\\\
  \checkargstypesat(\tenv, \calleeargsone, \callerargtypesone, \eqsthree) \typearrow \True
}{
  \checkargstypesat(\tenv, \calleeargs, \callerargtypes, \eqsthree) \typearrow \True
}
\end{mathpar}

\section{TypingRule.AnnotateParameterDefining \label{sec:TypingRule.AnnotateParameterDefining}}
\hypertarget{def-annotateparameterdefining}{}
The function
\[
  \annotateparameterdefining
  \left(
    \begin{array}{c}
      \overname{\staticenvs}{\tenv} \aslsep\\
      \overname{(\identifier\times\expr)^*}{\eqsone} \aslsep\\
      \overname{(\identifier\times\ty)^*}{\vargs} \aslsep\\
      \overname{(\ty\times\expr)^*}{\callerargstyped} \aslsep\\
      \overname{(\identifier\times\langle\ty\rangle)^*}{\calleeparams}
    \end{array}
  \right)
  \aslto
  \begin{array}{c}
  \overname{(\identifier\times\expr)^*}{\eqs} \cup \\
  \overname{\TTypeError}{\TypeErrorConfig}
  \end{array}
\]
checks that all parameter-defining arguments
in $\calleeparams$ are \staticallyevaluable\ constrained integers.
The result --- $\eqs$ --- is the list of parameter identifiers and their corresponding expressions,
added to $\eqsone$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item both $\vargs$ and $\callerargstyped$ are empty;
    \item define $\eqs$ as $\eqsone$.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item view $\vargs$ as a list with \head\ $(\calleex, \Ignore)$ and \tail\ $\vargsone$;
    \item view $\callerargstyped$ as a list with \head\ $(\callerty, \callere)$ and \tail\ $\callerargstypedone$;
    \item define $\calleeargisparam$ as $\True$ if and only if $\calleex$ is listed as a parameter in $\calleeparams$;
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply (\textsc{arg\_is\_param}):
      \begin{itemize}
        \item $\calleeargisparam$ is $\True$;
        \item checking that $\callere$ is \staticallyevaluable\ in $\tenv$ yields $\True$\ProseOrTypeError;
        \item checking that $\callerty$ is a constrained integer in $\tenv$ yields \\
              $\True$\ProseOrTypeError;
        \item applying $\annotateparameterdefining$ to $\vargsone$, \\
              $\callerargstypedone$, $\eqsone$ in $\tenv$ yields $\eqstwo$\ProseOrTypeError;
        \item define $\eqs$ as a list with \head\ $(\calleex, \callere)$ and \tail\ $\eqstwo$.
      \end{itemize}

      \item All of the following apply (\textsc{arg\_is\_not\_param}):
      \begin{itemize}
        \item $\calleeargisparam$ is $\False$;
        \item applying $\annotateparameterdefining$ to $\vargsone$, \\
              $\callerargstypedone$, $\eqsone$ in $\tenv$ yields $\eqs$\ProseOrTypeError.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Formally}
We note that it is guaranteed by TypingRule.AnnotateCallArgTyped
that $\vargs$ and $\callerargstyped$ have the same length.

\begin{mathpar}
\inferrule[empty]{}{
  {
    \begin{array}{r}
  \annotateparameterdefining(\tenv, \eqsone, \overname{\emptylist}{\vargs}, \overname{\emptylist}{\callerargstyped}, \calleeparams)
  \typearrow \\
  \overname{\eqsone}{\eqs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[arg\_is\_param]{
  \vargs \eqname [(\calleex, \Ignore)] \concat \vargsone\\
  \callerargstyped \eqname [(\callerty, \callere)] \concat \callerargstypedone\\
  {
    \begin{array}{rl}
  \calleeargisparam \eqdef  & \exists \vi\in\listrange(\calleeparams). \\
                            & \calleeparams[\vi]=(\calleex, \Ignore)
    \end{array}
  }\\
  \calleeargisparam\ = \True\\
  \checkstaticallyevaluable(\tenv, \callere) \typearrow \True\OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \callerty) \typearrow \True\OrTypeError\\\\
  {
    \begin{array}{r}
  \annotateparameterdefining(\tenv, \vargsone, \callerargstypedone, \eqsone) \typearrow \\ \eqstwo \OrTypeError
    \end{array}
  }\\
  \eqs \eqdef [(\calleex, \callere)] \concat \eqstwo
}{
  {
    \annotateparameterdefining
    \left(
      \begin{array}{c}
      \tenv, \\
      \eqsone, \\
      \vargs, \\
      \callerargstyped, \\
      \calleeparams
      \end{array}
    \right)
    \typearrow \eqs \OrTypeError
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[arg\_is\_not\_param]{
  \vargs \eqname [(\calleex, \Ignore)] \concat \vargsone\\
  \callerargstyped \eqname [(\callerty, \callere)] \concat \callerargstypedone\\
  {
    \begin{array}{rl}
  \calleeargisparam \eqdef & \exists \vi\in\listrange(\calleeparams).\\
                           & \calleeparams[\vi]=(\calleex, \Ignore)
    \end{array}
  }\\
  \calleeargisparam = \False\\
  \annotateparameterdefining(\tenv, \vargsone, \callerargstypedone, \eqsone) \typearrow \eqs\\
}{
  {
    \annotateparameterdefining
    \left(
      \begin{array}{c}
      \tenv, \\
      \eqsone, \\
      \vargs, \\
      \callerargstyped, \\
      \calleeparams
      \end{array}
    \right)
    \typearrow \eqs \OrTypeError
  }
}
\end{mathpar}

\section{TypingRule.AnnotateRetTy \label{sec:TypingRule.AnnotateRetTy}}
\hypertarget{def-annotateretty}{}
The function
\[
\begin{array}{r}
\annotateretty(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\subprogramtype}{\calltype} \aslsep
  \overname{\langle\ty\rangle}{\calleerettyopt}
  \overname{(\identifier\times\expr)^*}{\eqsthree}
) \aslto \\
\overname{\langle\ty\rangle}{\rettyopt}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the \optional\ return type $\calleerettyopt$ given with the subprogram type
$\calltype$ with respect to the parameter expressions $\eqsthree$,
yielding the \optional\ annotated type $\rettyopt$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{function\_or\_getter}):
  \begin{itemize}
    \item $\calltype$ is one of $\STFunction$, $\STGetter$, or $\STEmptyGetter$;
    \item $\calleerettyopt$ is $\langle\tty\rangle$;
    \item define $\rettyopt$ as $\langle\ttyone\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{procedure\_or\_setter}):
  \begin{itemize}
    \item $\calltype$ is one of $\STProcedure$, $\STSetter$, or $\STEmptySetter$;
    \item $\calleerettyopt$ is $\None$;
    \item define $\rettyopt$ as $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{ret\_type\_mismatch}):
  \begin{itemize}
    \item the condition that $\calltype$ is one of $\STProcedure$, $\STSetter$, or \\
          $\STEmptySetter$
          if and only if $\calleerettyopt$ is $\None$ does not hold;
    \item the result is a type error indicating the mismatch.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[function\_or\_getter]{
  \calltype \in \{\STFunction, \STGetter, \STEmptyGetter\}\\
  \renametyeqs(\eqsthree, \tty) \typearrow \ttyone \OrTypeError
}{
  \annotateretty(\tenv, \calltype, \overname{\langle\tty\rangle}{\calleerettyopt}, \eqsthree) \typearrow
  \overname{\langle\ttyone\rangle}{\rettyopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[procedure\_or\_setter]{
  \calltype \in \{\STProcedure, \STSetter, \STEmptySetter\}\\
}{
  \annotateretty(\tenv, \calltype, \overname{\None}{\calleerettyopt}, \eqsthree) \typearrow
  \overname{\None}{\rettyopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ret\_type\_mismatch]{
  {
  \neg\left(
    \begin{array}{c}\calltype \in \{\STProcedure, \STSetter, \STEmptySetter\} \leftrightarrow \\
      \calleerettyopt=\None
    \end{array}
  \right)
  }
}{
  \annotateretty(\tenv, \calltype, \calleerettyopt, \eqsthree) \typearrow
  \TypeErrorVal{\MismatchedReturnValue}
}
\end{mathpar}

\section{TypingRule.SubprogramForName \label{sec:TypingRule.SubprogramForName}}
\hypertarget{def-subprogramforname}{}
The function
\[
  \begin{array}{rl}
    \subprogramforname(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\ty^*}{\callerargtypes}
  )
  \aslto &
    (\overname{(\identifier \times \expr)^*}{\extranargs} \aslsep
    \overname{\Strings}{\namep} \aslsep
    \overname{\func}{\callee}
    )\\
  & \cup\ \overname{\TTypeError}{\TypeErrorConfig}
  \end{array}
\]
looks up the static environment $\tenv$ for a subprogram associated with $\name$
and the list of argument types $\calleeargtypes$ and determines which one of the following
cases holds:
\begin{itemize}
  \item there is no declared subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is exactly one subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is more than one subprogram that matches $\name$ and $\calleeargtypes$;
\end{itemize}
The first and last cases result in a type error.
If the second case holds, the function returns a tuple comprised of:
\begin{itemize}
\item $\extranargs$ --- the list of extra named arguments (parameters);
\item $\namep$ --- the string that uniquely identifies this subprogram;
\item $\callee$ --- the AST node defining the called subprogram.
\end{itemize}
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{undefined}):
  \begin{itemize}
    \item $\tenv$ does not contain a binding for $\name$ in the $\subprogramrenamings$ map
          ($G^\tenv.\subprogramrenamings$);
    \item the result is a type error indicating that the identifier has not been declared (as a subprogram).
  \end{itemize}

  \item All of the following apply (\textsc{no\_candidates}):
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\subprogramrenamings$ map to $\renamingset$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \secref{TypingRule.FilterCallCandidates}) yields an empty set\ProseOrTypeError;
    \item the result is a type error indicating that the call given by $\name$ and \\ $\callerargtypes$
          does not match any defined subprogram.
  \end{itemize}

  \item All of the following apply (\textsc{too\_many\_candidates}):
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\subprogramrenamings$ map to $\renamingset$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \secref{TypingRule.FilterCallCandidates}) yields $\matchingrenamings$\ProseOrTypeError;
    \item $\matchingrenamings$ contains at least two elements;
    \item the result is a type error indicating that the call given by $\name$ and \\
          $\callerargtypes$ matches more than one defined subprogram.
  \end{itemize}

  \item All of the following apply (\textsc{one\_candidate}):
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\subprogramrenamings$ map to $\renamingset$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \secref{TypingRule.FilterCallCandidates}) yields $\matchingrenamings$\ProseOrTypeError;
    \item $\matchingrenamings$ contains a single element --- $(\matchedname, \funcsig)$;
    \item deducing the argument values for the parameters via $\deduceeqs$ with \\
          $\callerargtypes$, $\funcsig.\funcargs$ in $\tenv$ yields \\
          $(\extranargs, \namep, \callee)$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SubprogramForNameBegin}{\SubprogramForNameEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[undefined]{
  G^\tenv.\subprogramrenamings(\name) = \bot
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_candidates]{
  G^\tenv.\subprogramrenamings(\name) = \renamingset\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \emptyset \OrTypeError
    \end{array}
  }
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\NoCallCandidates}
}
\end{mathpar}

\begin{mathpar}
\inferrule[too\_many\_candidates]{
  G^\tenv.\subprogramrenamings(\name) = \renamingset\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \\ \matchingrenamings \OrTypeError
    \end{array}
  }\\\\
  \cardinality{\matchingrenamings} \geq 2
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\TooManyCandidates}
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_candidate]{
  G^\tenv.\subprogramrenamings(\name) = \renamingset\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \\ \matchingrenamings \OrTypeError
    \end{array}
  }\\\\
  \matchingrenamings = [(\matchedname, \funcsig)]\\
  {
    \begin{array}{r}
  \deduceeqs(\tenv, \callerargtypes, \funcsig.\funcargs)
  \typearrow \\ (\extranargs, \namep, \callee) \OrTypeError
    \end{array}
  }
}{
  {
    \begin{array}{r}
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \\ (\extranargs, \namep, \callee)
    \end{array}
  }
}
\end{mathpar}

\section{TypingRule.DeduceEqs \label{sec:TypingRule.DeduceEqs}}
\hypertarget{def-deduceeqs}{}
The function
\[
\deduceeqs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\ty^*}{\callerargtypes} \aslsep
  \overname{(\identifier\times\ty)^*}{\vargs}
) \aslto
\overname{(\identifier\times\expr)^*}{\eqs}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
takes the types of the actual arguments of a call --- $\callerargtypes$,
the list of formal arguments --- $\vargs$ --- which consist of the names of a subprogram arguments
and their associated types, and
infers the expressions associated with parameters that correspond to bitvector widths,
yielding the result in $\eqs$.
\ProseOtherwiseTypeError

It guaranteed that by TypingRule.HasArgClash,
which is used by \\ TypingRule.FilterCallCandidates before calling $\deduceeqs$,
that $\callerargtypes$ and $\vargs$ have the same length.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item both $\callerargtypes$ and $\vargs$ are empty lists;
    \item define $\eqs$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{not\_bits\_parameter}):
  \begin{itemize}
    \item $\callerargtypes$ has \head\ $\caller$ and \tail\ $\callerargtypesone$;
    \item $\vargs$ has \head\ $(\Ignore, \callee)$ and \tail\ $\vargsone$;
    \item $\caller$ is not a bitvector type with a width expression that is a variable expression;
    \item applying $\deduceeqs$ to $\callerargtypesone$ and $\vargsone$ in $\tenv$ yields $\eqs$.
  \end{itemize}

  \item All of the following apply (\textsc{bits\_parameter}):
  \begin{itemize}
    \item $\callerargtypes$ has \head\ $\caller$ and \tail\ $\callerargtypesone$;
    \item $\vargs$ has \head\ $(\Ignore, \callee)$ and \tail\ $\vargsone$;
    \item $\caller$ is bitvector type whose width expression is the variable expression for $\vx$;
    \item obtaining the \structure\ of $\caller$ in $\tenv$ yields the bitvector type with width expression $\ecaller$\ProseOrTypeError;
    \item applying $\deduceeqs$ to $\callerargtypesone$ and $\vargsone$ in $\tenv$ yields $\eqsone$;
    \item define $\eqs$ as the list with \head\ $(\vx, \ecaller)$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \deduceeqs(\tenv, \overname{\emptylist}{\callerargtypes}, \overname{\emptylist}{\vargs}) \typearrow \overname{\emptylist}{\eqs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_bits\_parameter]{
  \caller \neq \TBits(\EVar(\vx))\\
  \deduceeqs(\tenv, \callerargtypesone, \vargsone) \typearrow \eqs
}{
  \deduceeqs(
    \tenv,
    \overname{[\caller] \concat \callerargtypesone}{\callerargtypes},
    \overname{[(\Ignore, \callee)] \concat \vargsone}{\vargs}) \typearrow \eqs
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_parameter]{
  \caller = \TBits(\EVar(\vx))\\
  \tstruct(\tenv, \caller) \typearrow \TBits(\ecaller, \Ignore) \OrTypeError\\\\
  \deduceeqs(\tenv, \callerargtypesone, \vargsone) \typearrow \eqsone\\
  \eqs \eqdef [(\vx, \ecaller)] \concat \eqsone
}{
  \deduceeqs(
    \tenv,
    \overname{[\caller] \concat \callerargtypesone}{\callerargtypes},
    \overname{[(\Ignore, \callee)] \concat \vargsone}{\vargs}) \typearrow \eqs
}
\end{mathpar}

\section{TypingRule.FilterCallCandidates \label{sec:TypingRule.FilterCallCandidates}}
\hypertarget{def-filtercandidates}{}
The helper function
\[
  \filtercallcandidates(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty^*}{\formaltypes} \aslsep
    \overname{\pow{\Strings}}{\candidates}
    )
  \aslto \overname{(\Strings\times\func)^*}{\matches}
\]
iterates over the list of unique subprogram names in $\candidates$ and checks whether
their lists of arguments clash with the types in $\formaltypes$ in $\tenv$.
The result is the set of pairs consisting of the names and function definitions of the
subprograms whose arguments clash in $\candidates$.
\ProseOtherwiseTypeError

The names $\candidates$ are assumed to exist in $G^\tenv.\subprograms$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{no\_candidates}):
  \begin{itemize}
    \item $\candidates$ is empty;
    \item $\matches$ is empty.
  \end{itemize}

  \item All of the following apply (\textsc{candidates\_exist}):
  \begin{itemize}
    \item $\candidates$ is a list with \head\ $\name$ and \tail\ $\candidatesone$;
    \item the function definition associated with $\name$ in $\tenv$ is $\funcdef$;
    \item determining whether there is an argument clash between $\formaltypes$ and the arguments in $\funcdef$
          (that is, $\funcdef.\funcargs$) yields $\vb$\ProseOrTypeError;
    \item filtering the call candidates in $\candidatesone$ with $\formaltypes$ in $\tenv$ yields $\matchesone$\ProseOrTypeError;
    \item if $\vb$ is $\True$ then $\matches$ is the list with \head\ $(\name,\funcdef)$ and \tail\ $\matchesone$,
          and otherwise it is $\matchesone$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[no\_candidates]
{}{
  \filtercallcandidates(\tenv, \formaltypes, \overname{\emptylist}{\candidates}) \typearrow \overname{\emptylist}{\matches}
}
\and
\inferrule[candidates\_exist]
{
  \funcdef \eqdef G^\tenv.\subprograms(\name) \\
  \hasargclash(\tenv, \formaltypes, \funcdef.\funcargs) \typearrow \vb \OrTypeError\\\\
  \filtercallcandidates(\tenv, \formaltypes, \candidatesone) \typearrow \matchesone \OrTypeError\\\\
  \matches \eqdef \choice{\vb}{\;[(\name,\funcdef)] \concat \matchesone}{\;\matchesone}
}{
  \filtercallcandidates(\tenv, \formaltypes, \overname{[\name] \concat \candidatesone}{\candidates}) \typearrow \matches
}
\end{mathpar}

\section{TypingRule.HasArgClash \label{sec:TypingRule.HasArgClash}}
\hypertarget{def-hasargclash}{}
The function
\[
  \hasargclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty^*}{\formaltys} \aslsep
    \overname{(\identifier\times\ty)^*}{\vargs}
  )
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether a list of types $\formaltys$ clashes with the list of types appearing
in the list of arguments $\vargs$ in $\tenv$, yielding the result in $\vb$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item equating the list lengths of $\formaltys$ and $\vargs$ either yields $\True$
        or $\False$, which short-circuits the entire rule;
  \item $\argtys$ is the list of types appearing in $\vargs$, in the same order;
  \item for each $\vi$ in the list of indices of $\formaltys$, applying $\typeclashes$ to
        $\formaltys[\vi]$ and $\argtys[\vi]$ in $\tenv$ yields $\True$\ProseTerminateAs{\False, \TypeErrorConfig};
  \item $\vb$ is $\True$ (unless the rule short-circuited with $\False$ or a type error).
\end{itemize}

\CodeSubsection{\HasArgClashBegin}{\HasArgClashEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \equallength(\formaltypes, \vargs) \typearrow \True \terminateas \False\\
  \argtys \eqdef [(\Ignore, \vt) \in\listrange(\vargs): \vt]\\
  \vi\in\listrange(\formaltys): \typeclashes(\tenv, \formaltys[\vi], \argtys[\vi]) \typearrow \True \terminateas \False,\TypeErrorConfig
}{
  \hasargclash(\tenv, \formaltys, \vargs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Subprograms \label{chap:TypingSubprograms}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatesubprogram}{}
The function
\[
  \annotatesubprogram{\overname{\staticenvs}{\tenv} \aslsep \overname{\func}{\vf}} \aslto \overname{\func}{\vfp}
\]
annotates a subprogram $\vf$ in an environment $\tenv$, resulting in an annotated subprogram $\vfp$,
or a type error, if one is detected.

\section{TypingRule.Subprogram \label{sec:TypingRule.Subprogram}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vf$ is a $\func$ AST node subprogram body $\body$;
  \item annotating the block $\body$ in $\tenv$ as per \secref{TypingRule.Block} yields $\newbody$\ProseOrTypeError;
  \item $\vfp$ is $\vf$ with the subprogram body substituted with $\newbody$.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SubprogramBegin}{\SubprogramEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{rrcl}
  \vf \eqname \{ & \funcname            &:& \id,\\
                 & \funcparameters      &:& \vp,\\
                 & \funcargs            &:& \vargs,\\
                 & \funcbody            &:& \SBASL(\body),\\
                 & \funcreturntype      &:& \vt,\\
                 & \funcsubprogramtype  &:& \subprogramtype \\
              \} &&&
    \end{array}
  }\\
  \annotateblock{\tenv, \body} \typearrow \newbody \OrTypeError\\\\
  {
    \begin{array}{rrcl}
  \vfp \eqdef \{ & \funcname            &:& \id,\\
                 & \funcparameters      &:& \vp,\\
                 & \funcargs            &:& \vargs,\\
                 & \funcbody            &:& \SBASL(\newbody),\\
                 & \funcreturntype      &:& \vt,\\
                 & \funcsubprogramtype  &:& \subprogramtype \\
              \} &&&
    \end{array}
  }\\
}{
  \annotatesubprogram{\tenv, \vf} \typearrow \vfp
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{
This is related to \identi{GHGK}, \identr{HWTV}, \identr{SCHV}, \identr{VDPC},
\identr{TJKQ}, \identi{LFJZ}, \identi{BZVB}, \identi{RQQB}.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Global Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-typecheckdecl}{}
The function
\[
  \typecheckdecl(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\decl}{\vd}
  )
  \aslto (\overname{\decl}{\newd} \times \overname{\staticenvs}{\newtenv})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a global declaration $\vd$ in the static environment $\tenv$,
yielding an annotated global declaration $\newd$ and modified environment $\newtenv$.
\ProseOtherwiseTypeError

One of the following applies:
\begin{itemize}
  \item TypingRule.TypecheckFunc (see \secref{TypingRule.TypecheckFunc})
  \item TypingRule.TypecheckGlobalStorage (see \secref{TypingRule.TypecheckGlobalStorage})
  \item TypingRule.TypecheckTypeDecl (see \secref{TypingRule.TypecheckTypeDecl})
\end{itemize}
We also define the following helper rules:
\begin{itemize}
  \item TypingRule.AnnotateAndDeclareFunc (see \secref{TypingRule.AnnotateAndDeclareFunc})
  \item TypingRule.AnnotateFuncSig (see \secref{TypingRule.AnnotateFuncSig})
  \item TypingRule.UseFuncSig (\secref{TypingRule.UseFuncSig})
  \item TypingRule.GetUndeclaredDefining (see \secref{TypingRule.GetUndeclaredDefining})
  \item TypingRule.ScanForParams (see \secref{TypingRule.ScanForParams})
  \item TypingRule.AnnotateParams (see \secref{TypingRule.AnnotateParams})
  \item TypingRule.AnnotateOneParam (see \secref{TypingRule.AnnotateOneParam})
  \item TypingRule.ArgsAsParams (see \secref{TypingRule.ArgsAsParams})
  \item TypingRule.ArgAsParam (see \secref{TypingRule.ArgAsParam})
  \item TypingRule.AnnotateParamType (see \secref{TypingRule.AnnotateParamType})
  \item TypingRule.AnnotateArgs (see \secref{TypingRule.AnnotateArgs})
  \item TypingRule.AnnotateOneArg (see \secref{TypingRule.AnnotateOneArg})
  \item TypingRule.AnnotateReturnType (see \secref{TypingRule.AnnotateReturnType})
  \item TypingRule.DeclareOneFunc (see \secref{TypingRule.DeclareOneFunc})
  \item TypingRule.SubprogramClash (see \secref{TypingRule.SubprogramClash})
  \item TypingRule.AddNewFunc (see \secref{TypingRule.AddNewFunc})
  \item TypingRule.CheckSetterHasGetter (see \secref{TypingRule.CheckSetterHasGetter})
  \item TypingRule.AddSubprogram (see \secref{TypingRule.AddSubprogram})
  \item TypingRule.DeclareGlobalStorage (see \secref{TypingRule.DeclareGlobalStorage})
  \item TypingRule.AnnotateTypeOpt (see \secref{TypingRule.AnnotateTypeOpt})
  \item TypingRule.AnnotateExprOpt (see \secref{TypingRule.AnnotateExprOpt})
  \item TypingRule.AnnotateInitType (see \secref{TypingRule.AnnotateInitType})
  \item TypingRule.AddGlobalStorage (see \secref{TypingRule.AddGlobalStorage})
  \item TypingRule.DeclareType (see \secref{TypingRule.DeclareType})
  \item TypingRule.AnnotateExtraFields (see \secref{TypingRule.AnnotateExtraFields})
  \item TypingRule.AnnotateEnumLabels (see \secref{TypingRule.AnnotateEnumLabels})
  \item TypingRule.DeclareConst (see \secref{TypingRule.DeclareConst})
\end{itemize}

\section{TypingRule.TypecheckFunc \label{sec:TypingRule.TypecheckFunc}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vd$ is a subprogram AST node with a subprogram definition $\vf$, that is, $\DFunc(\vf)$;
  \item annotating and declaring the subprogram for $\vf$ in $\tenv$ as per \secref{TypingRule.AnnotateAndDeclareFunc}
        yields the new environment $\newtenv$ and a subprogram definition $\vfone$\ProseOrTypeError;
  \item annotating the subprogram definition $\vfone$ in $\tenv$ as per \chapref{TypingSubprograms} yields
        the annotated subprogram definition $\vftwo$\ProseOrTypeError;
  \item define $\newd$ as the subprogram AST node with $\vftwo$, that is, $\DFunc(\vftwo)$.
\end{itemize}

\subsection{Example}
\CodeSubsection{\TypecheckFuncBegin}{\TypecheckFuncEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vf \eqname \{\text{body}: \SBASL, \ldots\}\\
  \annotateanddeclarefunc(\tenv, \vf) \typearrow (\newtenv, \vfone) \OrTypeError\\\\
  \annotatesubprogram{\newtenv, \vfone} \typearrow \vftwo \OrTypeError
}{
  \typecheckdecl(\tenv, \overname{\DFunc(\vf)}{\vd})
  \typearrow (\overname{\DFunc(\vftwo)}{\newd}, \newtenv)
}
\end{mathpar}

\section{TypingRule.TypecheckGlobalStorage \label{sec:TypingRule.TypecheckGlobalStorage}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vd$ is a global storage declaration with description $\gsd$, that is, \\ $\DGlobalStorage(\gsd)$;
  \item declaring the global storage with description $\gsd$ in $\tenv$ yields the new environment
        $\newtenv$ and new global storage description $\gsdp$\ProseOrTypeError;
  \item define $\newd$ as the global storage declaration with description $\gsdp$, that is, \\ $\DGlobalStorage(\gsdp)$.
\end{itemize}
\isempty{\subsection{Example}}

\CodeSubsection{\TypecheckGlobalStorageBegin}{\TypecheckGlobalStorageEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \declareglobalstorage(\tenv, \gsd) \typearrow (\newtenv, \gsdp) \OrTypeError
}{
  {
    \begin{array}{r}
  \typecheckdecl(\tenv, \overname{\DGlobalStorage(\gsd)}{\vd})
  \typearrow \\ (\overname{\DGlobalStorage(\gsdp)}{\newd}, \newtenv)
    \end{array}
  }
}
\end{mathpar}

\section{TypingRule.TypecheckTypeDecl \label{sec:TypingRule.TypecheckTypeDecl}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vd$ is a type declaration with identifier $\vx$, type $\tty$,
        and \optional\ field initializers $\vs$, that is, $\DTypeDecl(\vx, \tty, \vs)$;
  \item declaring the type described by $(\vx, \tty, \vs)$ in $\tenv$
        as per \secref{TypingRule.DeclaredType} yields the modified environment $\newtenv$\ProseOrTypeError;
  \item define $\newd$ as $\vd$.
  \end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\TypecheckTypeDeclBegin}{\TypecheckTypeDeclEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vd = \DTypeDecl(\vx, \tty, \vs)\\
  \declaretype(\tenv, \vx, \tty, \vs) \typearrow \newtenv \OrTypeError
}{
  \typecheckdecl(\tenv, \vd) \typearrow (\overname{\vd}{\newd}, \newtenv)
}
\end{mathpar}

\section{TypingRule.AnnotateAndDeclareFunc \label{sec:TypingRule.AnnotateAndDeclareFunc}}
\hypertarget{def-annotateanddeclarefunc}{}
The function
\[
  \annotateanddeclarefunc(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\tenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a subprogram definition $\funcsig$ in the static environment $\tenv$,
yielding a new subprogram definition $\newfuncsig$ and modified static environment
$\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the signature of $\funcsig$ in $\tenv$ as per
        \secref{TypingRule.AnnotateFuncSig} yields
        the environment $\tenvone$ and subprogram definition $\funcsigone$\ProseOrTypeError;
  \item declaring the subprogram defined by $\funcsigone$ in $\tenvone$
        as per \secref{TypingRule.DeclareOneFunc} yields the environment $\newtenv$
        and new $\func$ node $\newfuncsig$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\AnnotateAndDeclareFuncBegin}{\AnnotateAndDeclareFuncEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatefuncsig(\tenv, \funcsig) \typearrow (\tenvone, \funcsigone) \OrTypeError\\\\
  \declareonefunc(\tenvone, \funcsigone) \typearrow (\newtenv, \newfuncsig) \OrTypeError
}{
  \annotateanddeclarefunc(\tenv, \funcsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}

\section{TypingRule.AnnotateFuncSig \label{sec:TypingRule.AnnotateFuncSig}}
\hypertarget{def-annotatefuncsig}{}
The function
\[
  \annotatefuncsig(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the signature of a function definition $\funcsig$ in the static environment $\tenv$,
yielding a new function definition $\newfuncsig$ and modified static environment
$\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tenvone$ is the static environment comprised of the global environment of $\tenv$ and an empty local environment;
  \item obtaining the variables appearing in the formal types in $\funcsig$ that may be parameter-defining
        in $\tenvone$ via $\getundeclareddefining$ yields \\ $\potentialparams$;
  \item annotating the parameters explicitly listed in $\funcsig$ ($\funcsig.\funcparameters)$ \\
        yields environment $\tenvtwo$, in which the parameters are declared,
        and the function \\
        $\declaredparams$, which binds parameter identifiers to their types\ProseOrTypeError;
  \item annotating arguments from $\funcsig$ that serve as parameters in $\tenvtwo$ yields the list of parameters
        $\argparams$ and modified environment $\tenvthree$\ProseOrTypeError;
  \item $\vparameters$ is the list $\declaredparams$ concatenated with $\argparams$ with each type
        transformed to an \optional\ type;
  \item annotating the arguments listed in $\funcsig$ in $\tenvthree$ with $\tenvtwo$ via \\
        $\annotateargs$ yields the list of annotated
        arguments $\vargs$ and modified environment $\tenvfour$\ProseOrTypeError;
  \item annotating the return type of $\funcsig$ in $\tenvfour$ with $\tenvthree$ via \\ $\annotatereturntype$ yields
        the annotated return type $\vreturntype$ and modified environment $\tenvfive$\ProseOrTypeError;
  \item $\newfuncsig$ is $\funcsig$ with the listed of parameters substituted with \\ $\vparameters$,
        the list of arguments substituted with $\vargs$, and return type substituted with $\vreturntype$;
  \item $\newtenv$ is $\tenvfive$.
\end{itemize}
\isempty{\subsection{Example}}

\CodeSubsection{\AnnotateFuncSigBegin}{\AnnotateFuncSigEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tenvone \eqdef (G^\tenv, L^{\emptytenv})\\
  \getundeclareddefining(\tenvone, \funcsig) \typearrow \potentialparams\\
  {
    \begin{array}{r}
    \annotateparams(\tenvone, \potentialparams, \funcsig.\funcparameters, (\tenvone, \emptyfunc)) \typearrow \\
    (\tenvtwo, \declaredparams) \OrTypeError
    \end{array}
  }\\
  {
    \begin{array}{r}
    \argsasparams(\tenvtwo, \funcsig) \typearrow (\tenvthree, \argparams) \OrTypeError
    \end{array}
  }\\
  {
    \begin{array}{rl}
    \vparameters \eqdef & [(\id,\vt) \in \declaredparams: (\id, \langle\vt\rangle)]\ \concat \\
                     & [(\id,\vt) \in \argparams: (\id, \langle\vt\rangle)]
    \end{array}
  }\\
  \annotateargs(\tenvthree, \tenvtwo, \funcsig, \argparams) \typearrow (\tenvfour, \vargs) \OrTypeError\\\\
  {
    \begin{array}{r}
  \annotatereturntype(\tenvfour, \tenvthree, \funcsig.\funcreturntype) \typearrow \\
    (\tenvfive, \vreturntype) \OrTypeError
    \end{array}
  }\\\\
  {
    \begin{array}{rrcl}
      \newfuncsig \eqdef \{
                      & \funcname            &:& \funcsig.\funcname,\\
                      & \funcparameters      &:& \vparameters,\\
                      & \funcargs            &:& \vargs,\\
                      & \funcbody            &:& \funcsig.\funcbody,\\
                      & \funcreturntype      &:& \vreturntype,\\
                      & \funcsubprogramtype  &:&  \funcsig.\subprogramtype \\
                  \}  &  &&
        \end{array}
  }
}{
  \annotatefuncsig(\tenv, \funcsig) \typearrow (\overname{\tenvfive}{\newtenv}, \newfuncsig, \argparams)
}
\end{mathpar}

\section{TypingRule.UseFuncSig \label{sec:TypingRule.UseFuncSig}}
\hypertarget{def-usefuncsig}{}
The function
\[
\usefuncsig(\overname{\func}{\vf}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the subprogram signature given
by $\vf$ depends on.

\subsection{Prose}
Define $\ids$ as the union of applying $\usety$ to every type of an argument of $\vf$
and applying $\usety$ to the \optional\ return type of $\vf$.

\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \usefuncsig(\vf) \typearrow \overname{\bigcup_{(\Ignore, \vt) \in \vf.\funcargs}\usety(vt) \cup \usety(\vf.\funcreturntype)}{\ids}
}
\end{mathpar}

\section{TypingRule.GetUndeclaredDefining \label{sec:TypingRule.GetUndeclaredDefining}}
\hypertarget{def-getundeclareddefining}{}
The function
\[
\getundeclareddefining(\overname{\staticenvs}{\tenv} \aslsep \overname{\func}{\funcsig})
\aslto \overname{\pow{\identifier}}{\potentialparams}
\]
scans the list of types appearing in $\funcsig.\funcargs$ and in the return type
and returns the set of
identifiers that may be parameter-defining in $\tenv$.

\subsection{Example}
In the following specification, the set of identifiers that may correspond
to parameters of the function \texttt{signature\_example} is $\{\texttt{A}\}$,
since \texttt{A} appears in the type \texttt{bits(A)}
of the argument \texttt{bv}.

\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

\CodeSubsection{\GetUndeclaredDefiningBegin}{\GetUndeclaredDefiningEnd}{../Typing.ml}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item define $\formaltypes$ to consist of the types associated with the list of arguments in $\funcsig$
        and the return type in $\funcsig$, if one exists;
  \item scanning each type $\vt$ in $\formaltypes$ via $\scanforparams$ yields the set $\vparams_\vt$;
  \item $\potentialparams$ is the union of $\vparams_\vt$ for each type $\vt$ in $\formaltypes$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{rcl}
      \formaltypes &\eqdef&
    [(\Ignore, \vt) \in \funcsig.\funcargs: \vt]\ \concat \\
    && \choice{\funcsig.\funcreturntype = \langle\retty\rangle}{[\retty]}{\emptylist}
    \end{array}
  }\\
  \vt\in\formaltypes: \scanforparams(\tenv, \vt) \typearrow \vparams_\vt
}{
  \getundeclareddefining(\tenv, \funcsig) \typearrow \overname{\bigcup_{\vt \in \tys} \vparams_\vt}{\potentialparams}
}
\end{mathpar}

\section{TypingRule.ScanForParams \label{sec:TypingRule.ScanForParams}}
\hypertarget{def-scanforparams}{}
The function
\[
\scanforparams(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty})
\aslto \overname{\pow{\identifier}}{\potentialparams}
\]
scans a single type $\tty$ in $\tenv$ and returns the set of
identifiers that may be parameters in $\tenv$.

\subsection{Example}
Consider the following specification:
\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

Scanning each type in the signature
of the function \texttt{signature\_example} yields the following results:
\begin{center}
\begin{tabular}{lll}
\textbf{Expression} & \textbf{Result} & \textbf{Reason}\\
\hline
\texttt{bits(A)} & $\{\texttt{A}\}$ & \texttt{A} is a variable expression \\
& & and \texttt{A} is not defined in the environment.\\
\texttt{bits(W)} & $\emptyset$ & \texttt{W} is defined in the environment.\\
\texttt{bits(A+B)} & $\emptyset$ & \texttt{A+B} is not a variable expression.\\
\end{tabular}
\end{center}

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{tbits\_evar}):
  \begin{itemize}
    \item $\tty$ is a bitvector type over a variable expression for $\vx$, that is, \\ $\TBits(\EVar(\vx), \Ignore)$;
    \item $\potentialparams$ is the singleton set consisting of $\vx$ if $\vx$ is not defined as a storage type in $\tenv$
          and the empty set, otherwise.
  \end{itemize}

  \item All of the following apply (\textsc{tbits\_other}):
  \begin{itemize}
    \item $\tty$ is a bitvector type where the bitwidth expression is not a variable expression;
    \item $\potentialparams$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{ttuple}):
  \begin{itemize}
    \item $\tty$ is a tuple type over a list of types $\tys$;
    \item obtaining the set of potential parameters for each type $\vt$ of $\tys$ in $\tenv$ yields $\vparams_\vt$;
    \item $\potentialparams$ is the union of sets $\vparams_\vt$, for each type $\vt$ of $\tys$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\tty$ is neither a bitvector type or a tuple type;
    \item $\potentialparams$ is the empty set.
  \end{itemize}
\end{itemize}

\begin{mathpar}
  \inferrule[tbits\_evar]{
    \isundefined(\tenv, \vx) \typearrow \vb\\
    \potentialparams \eqdef \choice{\vb}{\{\vx\}}{\emptyset}
  }{
    \scanforparams(\tenv, \overname{\TBits(\EVar(\vx), \Ignore)}{\tty}) \typearrow \potentialparams
  }
  \and
  \inferrule[tbits\_other]{
    \astlabel(\ve) \neq \EVar
  }{
    \scanforparams(\tenv, \overname{\TBits(\ve, \Ignore)}{\tty}) \typearrow \overname{\emptyset}{\potentialparams}
  }
  \and
  \inferrule[ttuple]{
    \vt \in \tys: \scanforparams(\tenv, \vt) \typearrow \vparams_\vt
  }{
    \scanforparams(\tenv, \overname{\TTuple(\tys)}{\tty}) \typearrow \overname{\bigcup_{\vt \in \tys} \vparams_\vt}{\potentialparams}
  }
  \and
  \inferrule[other]{
    \astlabel(\tty) \not\in \{\TBits, \TTuple\}
  }{
    \scanforparams(\tenv, \tty) \typearrow \overname{\emptyset}{\potentialparams}
  }
  \end{mathpar}

\section{TypingRule.AnnotateParams \label{sec:TypingRule.AnnotateParams}}
\hypertarget{def-annotateparams}{}
The function
\[
\begin{array}{r}
\annotateparams(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\pow{\identifier}}{\potentialparams} \aslsep
  \overname{(\identifier \times \langle\ty\rangle)^*}{\vparameters} \aslsep\
  (\overname{\staticenvs}{\tenvonep} \times \overname{\identifier\rightarrow\ty}{\acc})
) \aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\identifier\rightarrow\ty}{\declaredparams})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
scans the list of explicitly defined parameters $\vparameters$ with respect to the set of potential
parameters $\potentialparams$ in $\tenv$ and then updates a pair
consisting of an updated environment $\tenvonep$, which accumulates local storage declarations
for the parameters, and a function $\acc$, which maps identifiers corresponding to parameters
to their associated types.
The updated pair is given in $\newtenv$ and $\declaredparams$.
\ProseOtherwiseTypeError

\subsection{Example}
In the following specification, the list of explicitly defined parameters
of the function \texttt{signature\_example} is $\{\texttt{A}\}$.
Therefore, $\declaredparams$ binds \texttt{A} to the type \verb|integer{A}|
and $\newtenv$ effectively reflects an added declaration \verb|let A: integer{A}|.

\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\vparameters$ is the empty list;
    \item $\newtenv$ is $\tenvonep$;
    \item $\declaredparams$ is $\acc$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\vparameters$ is a list with $(\vx, \tyopt)$ as its \head\ and $\vparametersone$ as its \tail;
    \item applying $\annotateoneparam$ to the parameter $(\vx, \tyopt)$ in $\tenvone$ with $\potentialparams$ and the pair $(\tenvonep, \acc)$
          yields the pair \\
          $(\tenvonepp, \accp)$\ProseOrTypeError;
    \item annotating the parameter list $\vparametersone$ in $\tenvone$ with $\potentialparams$, starting with the pair
          $(\tenvonepp, \accp)$ yields the pair \\ $(\newtenv, \declaredparams)$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  {
    \begin{array}{r}
  \annotateparams(\tenvone, \potentialparams, \overname{\emptylist}{\vparameters}, (\tenvonep, \acc)) \typearrow \\
  (\overname{\tenvonep}{\newtenv}, \overname{\acc}{\declaredparams})
    \end{array}
  }
}
\and
\inferrule[non\_empty]{
  \vparameters \eqname [(\vx,\tyopt)]\concat\vparametersone\\
  {
    \begin{array}{r}
  \annotateoneparam(\tenvone, \potentialparams, (\vx,\tyopt), (\tenvonep, \acc)) \typearrow \\ (\tenvonepp, \accp) \OrTypeError
    \end{array}
  }\\\\
  {
    \begin{array}{r}
  \annotateparams(\tenvone, \potentialparams, \vparametersone, (\tenvonepp, \accp)) \typearrow \\ (\newtenv, \declaredparams) \OrTypeError
\end{array}
}\\\\
}{
  {
    \begin{array}{r}
  \annotateparams(\tenvone, \potentialparams, \vparameters, (\tenvonep, \acc)) \typearrow \\
  (\newtenv, \declaredparams)
    \end{array}
}
}
\end{mathpar}

\section{TypingRule.AnnotateOneParam \label{sec:TypingRule.AnnotateOneParam}}
The function
\hypertarget{def-annotateoneparam}{}
\[
\begin{array}{r}
\annotateoneparam(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\pow{\identifier}}{\potentialparams} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\langle\ty\rangle}{\tyopt}) \aslsep
  (\overname{\staticenvs}{\tenvonep} \times \overname{\identifier\rightarrow\ty}{\acc})
) \\ \aslto
(\overname{\staticenvs}{\newtenv} \times \overname{\identifier\rightarrow\ty}{\declaredparams})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the explicitly defined parameter given by $\vx$ and the \optional\ type $\tyoptp$
with respect to the set of potential
parameters $\potentialparams$ in $\tenv$ and then updates a pair
consisting of an updated environment $\tenvonep$, which accumulates local storage declarations
for the parameters, and a function $\acc$, which maps identifiers corresponding to parameters
to their associated types.
The updated pair is given in $\newtenv$ and $\declaredparams$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that $\vx$ is not defined as a variable in $\tenvonep$ yields $\True$\ProseOrTypeError;
  \item checking whether $\vx$ is included in the set $\potentialparams$ yields $\True$ or a type error
        indicating that each parameter must have a defining argument, thus short-circuiting the entire rule;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{type\_parameterized}):
    \begin{itemize}
      \item $\tyopt$ is either $\None$ or a \parameterizedintegertype;
      \item $\vt$ is defined as the \parameterizedintegertype\ for the identifier $\vx$.
    \end{itemize}

    \item All of the following apply (\textsc{type\_annotated}):
    \begin{itemize}
      \item $\tyopt$ is the type $\vtone$, which is not the unconstrained integer type;
      \item annotating $\vtone$ in $\tenvone$ yields $\vt$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
  \item checking that $\vt$ is a constrained integer in $\tenvone$ via $\checkconstrainedinteger$
        yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\vt$, and local declaration keyword
        $\LDKLet$ in $\tenvonep$ yields $\newtenv$;
  \item $\declaredparams$ is $\acc$ updated by the binding of $\vx$ to $\vt$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[type\_parameterized]{
  \checkvarnotinenv{\tenvonep, \vx} \typearrow \True \OrTypeError\\\\
  \checktrans{\vx \in \potentialparams}{\ParameterWithoutDecl} \checktransarrow \True \OrTypeError\\\\
  (\tyopt = \None \lor \tyopt = \langle \unconstrainedinteger\rangle) \\
  \vt \eqdef \TInt(\parameterized(\vx))\\
  \checkconstrainedinteger(\tenvone, \vt) \typearrow \True \OrTypeError\\\\
  \addlocal(\tenvonep, \vx, \vt, \LDKLet) \typearrow \newtenv\\
  \declaredparams \eqdef \acc[\vx \mapsto \vt]
}{
  {
    \begin{array}{r}
  \annotateoneparam(\tenvone, \potentialparams, (\vx, \tyopt), (\tenvonep, \acc)) \typearrow \\ (\newtenv, \declaredparams)
    \end{array}
  }
}
\and
\inferrule[type\_annotated]{
  \checkvarnotinenv{\tenvonep, \vx} \typearrow \True \OrTypeError\\\\
  \checktrans{\vx \in \potentialparams}{\ParameterWithoutDecl} \checktransarrow \True \OrTypeError\\\\
  \vtone \neq \unconstrainedinteger\\
  \annotatetype{\False, \tenvone, \vtone} \typearrow \vt \OrTypeError\\\\
  \checkconstrainedinteger(\tenvone, \vt) \typearrow \True \OrTypeError\\\\
  \addlocal(\tenvonep, \vx, \vt, \LDKLet) \typearrow \newtenv\\
  \declaredparams \eqdef \acc[\vx \mapsto \vt]
}{
  {
    \begin{array}{r}
  \annotateoneparam(\tenvone, \potentialparams, (\vx, \overname{\langle\vtone\rangle}{\tyopt}),  (\tenvonep, \acc)) \typearrow \\ (\newtenv, \declaredparams)
    \end{array}
  }
}
  \end{mathpar}

\section{TypingRule.ArgsAsParams \label{sec:TypingRule.ArgsAsParams}}
\hypertarget{def-argsasparams}{}
The function
\[
\begin{array}{r}
\argsasparams(
  \overname{\staticenvs}{\tenvone} \aslsep
  \overname{\staticenvs}{\tenvtwo} \aslsep
  \overname{\func}{\funcsig} \aslsep
  \overname{\identifier\rightarrow\ty}{\declaredparams}
  )
\aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\identifier\rightarrow\ty}{\argparams})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
scans the list of arguments in $\func$ ($\func.\funcargs$) to find the ones that serve as
implicit parameters in $\tenvone$ and are not already included in the domain of $\declaredparams$.
The found parameters are added as local declarations to $\tenvtwo$, resulting in $\newtenv$,
and are used to update $\argparams$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item the subprogram defined by $\funcsig$ has an empty list of arguments;
    \item $\newtenv$ is $\tenvtwo$;
    \item $\argparams$ is the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item the subprogram defined by $\funcsig$ has arguments $\varg_{1..k}$;
    \item obtaining the identifiers that can serve as parameters in the types of the formal arguments of $\funcsig$
          and in its return type yields $\vusedone$;
    \item the set $\vused$ contains all identifiers $\vs$ from $\vusedone$ that are undefined in $\tenvone$ and are not
          bound in $\declaredparams$;
    \item the following premises define the sequences $\argparams_{1..k}$ and $\tenvtwo_{0..k}$ as follows;
    \item $\argparams_1$ is $\declaredparams$;
    \item $\tenvtwo_0$ is $\tenvtwo$;
    \item for $\vi=1..k$, annotating the argument $\varg_\vi$ in $\tenvtwo$ with $\vused$ and the static environment $\tenvtwo_{\vi-1}$
          via $\argasparam$ yields $\tenvtwo_\vi$ and $\argparams_\vi$\ProseOrTypeError;
    \item $\newtenv$ is $\tenvtwo_k$;
    \item $\argparams$ is $\argparams_k$.
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following specification, the argument \texttt{B}
of the function \texttt{signature\_example} is an implicit parameter
as it appears in the type \texttt{bits(A+B)}
(both for the argument \texttt{bv3} and as the return type)
and it is not listed as an explicit parameter.
Therefore, $\newtenv$ will effectively contain the declaration \verb|let B: integer{B}|.

\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{
  \funcsig.\funcargs = \emptylist
}{
  {
    \begin{array}{r}
  \argsasparams(\tenvone, \tenvtwo, \funcsig, \declaredparams) \typearrow \\
  (\overname{\tenvtwo}{\newtenv}, \overname{\emptylist}{\argparams})
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \funcsig.\funcargs \eqname \varg_{1..k}\\
  \usefuncsig(\funcsig) \typearrow \vusedone\\
  \vs\in\vusedone : \isundefined(\tenvone, \vs) \typearrow \vb_\vs\\
  \vused \eqdef \setcomprehension{\vs\in\vusedone \land \vb_\vs \land \declaredparams(\vs) = \bot}{\vs}\\
  \argparams_1 \eqdef \declaredparams\\
  \tenvtwo_0 \eqdef \tenvtwo\\
  {
    \begin{array}{r}
  \vi=1..k: \argasparam(\tenvtwo, \vused, \varg_\vi,\tenvtwo_{\vi-1}) \typearrow \\ (\tenvtwo_\vi, \argparams_\vi) \OrTypeError
    \end{array}
  }
}{
  {
    \begin{array}{r}
  \argsasparams(\tenvone, \tenvtwo, \funcsig, \declaredparams) \typearrow \\
  (\overname{\tenvtwo_k}{\newtenv}, \overname{\argparams_k}{\argparams})
    \end{array}
  }
}
\end{mathpar}

\section{TypingRule.ArgAsParam \label{sec:TypingRule.ArgAsParam}}
\hypertarget{def-argasparam}{}
The function
\[
\argasparam\left(
  \begin{array}{c}
  \overname{\staticenvs}{\tenvtwo} \aslsep\\
  \overname{\pow{\identifier}}{\vused} \aslsep\\
  (\overname{\identifier}{\vx} \times \overname{\ty}{\tty}) \aslsep\\
  (\overname{\staticenvs}{\tenvtwop} \times \overname{\identifier\rightarrow\ty}{\acc})
  \end{array}
  \right)
\aslto
(\overname{\staticenvs}{\newtenv} \times \overname{\identifier\rightarrow\ty}{\accp})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the argument given by $\vx$ and type $\tty$ is an implicit parameter
by checking whether it appears in $\vused$ and not in $\acc$.
If it is identified as an implicit parameter, it is used to update $\tenvtwop$ to yield $\newtenv$
and to update $\acc$ to yield $\accp$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{not\_used}):
  \begin{itemize}
    \item $\vx$ is not a member of $\vused$;
    \item $\newtenv$ is $\tenvtwop$;
    \item $\accp$ is $\acc$.
  \end{itemize}

  \item All of the following apply (\textsc{used}):
  \begin{itemize}
    \item $\vx$ is a member of $\vused$;
    \item checking that $\vx$ is not declared in $\tenvtwop$ yields $\True$\ProseOrTypeError;
    \item annotating $\tty$ with identifier $\vx$ as a potential parameter type in $\tenvtwo$,
          which is an environment to which all explicit parameters have been added but implicit parameters were not added to,
          via $\annotateparamtype$ yields $\vt$\ProseOrTypeError;
    \item checking whether $\vt$ is a constrained integer type in $\tenvtwo$ yields $\True$\ProseOrTypeError;
    \item adding $\vx$ as a local storage element to $\tenvtwop$ with type $\vt$ and local declaration keyword $\LDKLet$ yields
          $\newtenv$;
    \item $\accp$ is $\acc$ updated by binding $\vx$ to $\vt$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[not\_used]{
  \vx \not\in \vused
}{
  \argasparam(\tenvtwo, \vused, (\vx, \tty), (\tenvtwop, \acc))
  \typearrow (\overname{\tenvtwop}{\newtenv}, \overname{\acc}{\accp})
}
\and
\inferrule[used]{
  \vx \in \vused\\
  \checkvarnotinenv{\tenvtwop, \vx} \typearrow \True \OrTypeError\\\\
  \annotateparamtype(\tenvtwo, \tty, \vx) \typearrow \vt \OrTypeError\\\\
  \checkconstrainedinteger(\tenvtwo, \vt) \typearrow \True \OrTypeError\\\\
  \addlocal(\tenvtwop, \vx, \vt, \LDKLet) \typearrow \newtenv\\
  \accp \eqdef \acc[\vx\mapsto\vt]
}{
  \argasparam(\tenvtwo, \vused, (\vx, \tty), (\tenvtwop, \acc))
  \typearrow (\newtenv, \accp)
}
\end{mathpar}

\section{TypingRule.AnnotateParamType \label{sec:TypingRule.AnnotateParamType}}
\hypertarget{def-annotateparamtype}{}
The function
\[
  \annotateparamtype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty} \aslsep \overname{\identifier}{\vx})
  \typearrow \overname{\ty}{\newty}
\]
annotates the type $\tty$ in $\tenv$, considering it as a subprogram parameter with identifier $\vx$,
yielding the type $\newtenv$.
It is assumed that $\tenv$ is an environment to which all explicitly defined parameters of the subprogram
in context were added to, but the implicitly defined parameters were not added to.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{tint\_unconstrained}):
  \begin{itemize}
    \item $\tty$ is the unconstrained integer type;
    \item $\newty$ is the \parameterizedintegertype\ for the identifier $\vx$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\tty$ is not the unconstrained integer type;
    \item annotating the type $\tty$ in $\tenv$ yields $\newty$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[tint\_unconstrained]{}
{
  \annotateparamtype(\tenv, \overname{\unconstrainedinteger}{\tty}) \typearrow \overname{\TInt(\parameterized(\vx))}{\newty}
}
\and
\inferrule[other]{
  \tty \neq \unconstrainedinteger\\
  \annotatetype{\tenv, \tty} \typearrow \newty \OrTypeError
}{
  \annotateparamtype(\tenv, \tty) \typearrow \newty
}
\end{mathpar}

\section{TypingRule.AnnotateArgs \label{sec:TypingRule.AnnotateArgs}}
\hypertarget{def-annotateargs}{}
The function
\[
\begin{array}{r}
\annotateargs(
  \overname{\staticenvs}{\tenvtwo} \aslsep
  \overname{\staticenvs}{\tenvthree} \aslsep
  \overname{\func}{\funcsig} \aslsep
  \overname{\identifier\rightarrow\ty}{\argparams}
)
\aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\vnewargs})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the arguments listed in $\funcsig$ in the context of
of $\argparams$, which binds parameters to their types,
and two static environments:
$\tenvtwo$ --- the environment to which only explicit parameters were added, and
$\tenvthree$ --- the environment to which all parameters (explicit and implicit) were added.
The result is the environment $\newtenv$ where all arguments have been declared and
the annotated list of arguments $\vnewargs$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{no\_args}):
  \begin{itemize}
    \item the function defined by $\funcsig$ has an empty list of arguments;
    \item $\newtenv$ is $\tenvthree$;
    \item $\vnewargs$ is the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{some\_args}):
  \begin{itemize}
    \item the function defined by $\funcsig$ has arguments $\varg_{1..k}$;
    \item the following premises define the sequence of static environments $\tenvthree_{0..k}$ and
          list of typed identifiers $\vnewarg_{1..k}$;
    \item $\tenvthree_0$ is $\tenvthree$;
    \item annotating the argument $\varg_\vi$ in the context of $\tenvtwo$, $\tenvthree$, $\argparams$,
          and $\tenvthree_{\vi-1}$ via $\annotateonearg$ yields $(\tenvthree_\vi, \vnewarg_\vi)$\ProseOrTypeError;
    \item $\newtenv$ is $\tenvthree_k$;
    \item $\vnewargs$ is the list $\vnewarg_{1..k}$.
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following specification, the annotated arguments are
\texttt{bv}, \texttt{bv2}, \texttt{bv3}, and \texttt{C}.
The argument \texttt{B} is not annotated as an argument since it is classified
and annotated as a parameter.

\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

\subsection{Formally}
\begin{mathpar}
\inferrule[no\_args]{
  \funcsig.\funcargs = \emptylist
}{
  \annotateargs(\tenvtwo, \tenvthree, \funcsig, \argparams) \typearrow (\overname{\tenvthree}{\newtenv}, \overname{\emptylist}{\vnewargs})
}
\and
\inferrule[some\_args]{
  \funcsig.\funcargs \eqname \varg_{1..k}\\
  \tenvthree_{0} \eqdef \tenvthree\\
  {
    \begin{array}{r}
  \vi=1..k: \annotateonearg(\tenvtwo, \tenvthree, \argparams, (\tenvthree_{\vi-1}, \varg_{\vi})) \typearrow \\
    (\tenvthree_{\vi}, \vnewarg_\vi) \OrTypeError
    \end{array}
  }\\
  \vnewargs \eqdef [i=1..k: \vnewarg_{\vi}]
}{
  \annotateargs(\tenvtwo, \tenvthree, \funcsig, \argparams) \typearrow
  (\overname{\tenvthree_k}{\newtenv}, \vnewargs)
}
\end{mathpar}

\section{TypingRule.AnnotateOneArg \label{sec:TypingRule.AnnotateOneArg}}
\hypertarget{def-annotateonearg}{}
The function
\[
\begin{array}{r}
\annotateonearg(
  \overname{\staticenvs}{\tenvtwo} \aslsep
  \overname{\staticenvs}{\tenvthree} \aslsep
  \overname{\identifier\rightarrow\ty}{\argparams} \aslsep
  (\overname{\staticenvs}{\tenvthreep} \times (\overname{\vx}{\identifier} \times \overname{\ty}{\tty}))
) \aslto \\
(\overname{\staticenvs}{\newtenv} \times\ (\overname{\vx}{\identifier} \times \overname{\ty}{\ttyp}))
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the argument $\vx$ of type $\tty$ in the context of $\argparams$, which binds parameters to their types,
and the following static environments:
$\tenvtwo$ --- the environment to which only explicit parameters were added,
$\tenvthree$ --- $\tenvtwo$ with the addition of implicit parameters, and
$\tenvthreep$ --- same as $\tenvthree$ but updated with previously annotated arguments.
The result is the updated environment $\newtenv$ with the added declaration for the current argument
and the annotated argument, which has the same identifier $\vx$ and the annotated type $\vtp$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{param}):
  \begin{itemize}
    \item $\vx$ is not bound in $\argparams$;
    \item annotating the type $\tty$ in $\tenvtwo$ yields $\ttyp$;
    \item $\newtenv$ is $\tenvthreep$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_param}):
  \begin{itemize}
    \item $\vx$ is bound in $\argparams$;
    \item checking that $\vx$ is not defined in $\tenvthreep$ yields $\True$\ProseOrTypeError;
    \item annotating the type $\tty$ in $\tenvthree$ yields $\ttyp$;
    \item adding a local storage element $\vx$ with type $\ttyp$ and local declaration keyword $\LDKLet$ yields
          $\newtenv$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[param]{
  \argparams(\vx) \neq \bot\\
  \annotatetype{\tenvtwo, \tty} \typearrow \ttyp \OrTypeError
}{
  \annotateonearg(\tenvtwo, \tenvthree, \argparams, (\tenvthreep, (\vx, \tty)))
  \typearrow (\overname{\tenvthreep}{\newtenv}, (\vx, \ttyp))
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_param]{
  \argparams(\vx) = \bot\\
  \checkvarnotinenv{\tenvthreep, \vx} \typearrow \True \OrTypeError\\\\
  \annotatetype{\tenvthree, \tty} \typearrow \ttyp \OrTypeError\\\\
  \addlocal(\tenvthreep, \vx, \ttyp, \LDKLet) \typearrow \newtenv
}{
  {
    \begin{array}{r}
  \annotateonearg(\tenvtwo, \tenvthree, \argparams, (\tenvthreep, (\vx, \tty)))
  \typearrow \\ (\newtenv, (\vx, \ttyp))
    \end{array}
  }
}
\end{mathpar}

\section{TypingRule.AnnotateReturnType \label{sec:TypingRule.AnnotateReturnType}}
\hypertarget{def-annotatereturntype}{}
The function
\[
\annotatereturntype(
  \overname{\staticenvs}{\tenvthree} \aslsep
  \overname{\staticenvs}{\tenvfour} \aslsep
  \overname{\langle\ty\rangle}{\returntype}
) \aslto
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newreturntype})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the \optional\ return type $\returntype$ in the context of the static environment
$\tenvthree$ where all parameters have been added to, and
$\tenvfour$ where all parameters and arguments have been added to.
The result is the static environment $\newtenv$, which is $\tenvfour$ with the
annotated return type and the \optional\ annotated return type $\newreturntype$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{no\_return\_type}):
  \begin{itemize}
    \item $\returntype$ is $\None$;
    \item $\newtenv$ is $\tenvfour$;
    \item $\newreturntype$ is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{has\_return\_type}):
  \begin{itemize}
    \item $\returntype$ is $\langle\tty\rangle$;
    \item annotating $\tty$ in $\tenvthree$ yields $\ttyp$\ProseOrTypeError;
    \item $\newreturntype$ is $\langle\ttyp\rangle$;
    \item $\newtenv$ is $\tenvfour$ with its local environment updated by binding its \\ $\funcreturntype$ field
          to $\newreturntype$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[no\_return\_type]{}
{
  \annotatereturntype(\tenvthree, \tenvfour, \overname{\None}{\returntype}) \typearrow
  (\overname{\tenvfour}{\newtenv}, \overname{\None}{\newreturntype})
}
\and
\inferrule[has\_return\_type]{
  \annotatetype{\tenvthree, \tty} \typearrow \ttyp \OrTypeError\\\\
  \newreturntype \eqdef \langle\ttyp\rangle\\
  \newtenv \eqdef (G^\tenvfour, L^\tenvfour[\funcreturntype\mapsto\newreturntype])
}{
  \annotatereturntype(\tenvthree, \tenvfour, \overname{\langle\tty\rangle}{\returntype}) \typearrow
  (\newtenv, \newreturntype)
}
\end{mathpar}

\section{TypingRule.DeclareOneFunc \label{sec:TypingRule.DeclareOneFunc}}
\hypertarget{def-declareonefunc}{}
The function
\[
  \declareonefunc(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks that a subprogram defined by $\funcsig$ can be added to the static environment $\tenv$,
resulting in an annotated function definition $\newfuncdef$ and new static environment $\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\funcsig$ has name $\name$, arguments $\vargs$, and type $\subprogramtype$, that is,
  \[
    \begin{array}{rrcl}
      \funcsig \eqdef \{
                      & \funcname            &:& \name,\\
                      & \funcparameters      &:& \vp,\\
                      & \funcargs            &:& \vargs,\\
                      & \funcbody            &:& \SBASL(\bd),\\
                      & \funcreturntype      &:& \vt,\\
                      & \funcsubprogramtype  &:& \subprogramtype \\
                  \}  & ; &&
        \end{array}
  \]
  \item adding a new subprogram with $\name$, $\vargs$, and $\subprogramtype$ to $\tenv$ yields the new
        environment $\tenvone$ and new name $\namep$\ProseOrTypeError;
  \item checking that $\namep$ is not already declared in the global environment of $\tenvone$
        yields $\True$\ProseOrTypeError;
  \item ensuring that each setter has a getter given $\funcsig$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\funcsigone$ is $\funcsig$ with $\name$ substituted by $\nameone$;
  \item adding a subprogram with name $\namep$ and definition $\funcsigone$ to $\tenvone$ yields $\newtenv$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\DeclareOneFuncBegin}{\DeclareOneFuncEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rrcl}
    \funcsig \eqdef \{
                    & \funcname            &:& \name,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype \\
                \} &&&
      \end{array}
    }\\
  \addnewfunc(\tenv, \name, \vargs, \subprogramtype) \typearrow
  (\tenvone, \namep) \OrTypeError\\\\
  \checkvarnotingenv{\tenvone, \namep} \typearrow \True \OrTypeError\\\\
  \checksetterhasgetter(\tenvone, \funcsig) \typearrow \True \OrTypeError\\\\
  {
  \begin{array}{rrcl}
    \newfuncsig \eqdef \{
                    & \funcname            &:& \namep,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype \\
                \} &&&
      \end{array}
    }\\
    \addsubprogram(\tenvone, \namep, \funcsigone) \typearrow \newtenv \OrTypeError
}{
  \declareonefunc(\tenv, \funcsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This relates to \identi{HJRD}, \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}, and \identr{PGFC}.}

\section{TypingRule.SubprogramClash \label{sec:TypingRule.SubprogramClash}}
\hypertarget{def-subprogramclash}{}
The function
\[
  \subprogramclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\subprogramtype}{\subpgmtype} \aslsep
    \overname{\ty^*}{\formaltypes}
  )
  \aslto
  \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the unique subprogram associated with $\name$
clashes with another subprogram
that has subprogram type $\subpgmtype$ and list of formal types $\formaltypes$,
yielding a Boolean value in $\vb$.
\ProseOtherwiseTypeError

The function is only defined when there exists a binding for $\name$ in the
$\subprograms$ map of $\tenv$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the subprogram type associated with the unique subprogram named by $\name$ is $\namesubpgmtype$;
  \item applying $\subprogramtypesclash$ to $\namesubpgmtype$ and $\subpgmtype$ yields $\True$\ProseTerminateAs{\False}
        (that is, if both $\namesubpgmtype$ and $\subpgmtype$ are $\STGetter$ or both are $\STSetter$ then the
        subprogram types are considered to be non-clashing and the entire rule short-circuits to $\False$);
  \item $\nameargs$ is the list of pairs of types and identifiers associated with the function definition
        of $\name$ in $\tenv$;
  \item determining whether there is an argument clash between $\formaltypes$ and \\
        $\nameformals$ in $\tenv$ yields $\vb$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\subsection{Formally}
\hypertarget{def-subprogramtypeclash}{}
We first introduce the helper predicate
\[
  \subprogramtypesclash(
    \overname{\subprogramtype}{\subpgmtypeone} \aslsep
    \overname{\subprogramtype}{\subpgmtypetwo}
  ) \aslto \overname{\Bool}{\vb}
\]
which defines whether two subprogram types are considered to be clashing:
\begin{mathpar}
\inferrule{
  \vbone \eqdef
  {
    \begin{array}{l}
  (\subpgmtypeone=\STGetter \land \subpgmtypetwo=\STSetter)\ \lor\\
  (\subpgmtypeone=\STSetter \land \subpgmtypetwo=\STGetter)
    \end{array}
  }\\\\
  \vb \eqdef \neg\vbone
}{
  \subprogramtypesclash(\subpgmtypeone, \subpgmtypetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \namesubpgmtype \eqdef G^\tenv.\subprograms(\name).\subprogramtype\\
  \subprogramtypesclash(\namesubpgmtype, \subpgmtype) \typearrow \True \terminateas \False\\
  \nameargs \eqdef G^\tenv.\subprograms(\name).\funcargs\\
  \hasargclash(\formaltypes, \nameargs) \typearrow \vb
}{
  \subprogramclash(\tenv, \namep, \subpgmtype, \formaltypes) \typearrow \vb
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}.}

\section{TypingRule.AddNewFunc \label{sec:TypingRule.AddNewFunc}}
\hypertarget{def-addnewfunc}{}
The function
\[
  \begin{array}{rl}
  \addnewfunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\typedidentifier^*}{\formals} \aslsep
    \overname{\subprogramtype}{\subpgmtype})
  & \aslto\\
  (\overname{\staticenvs}{\newtenv} \times \overname{\Strings}{\newname})
  \cup \overname{\TTypeError}{\TypeErrorConfig} &
  \end{array}
\]
ensures that the subprogram given by the identifier $\name$, list of formals $\formals$,
and subprogram type $\subpgmtype$ has a unique name among all the potential subprograms
that overload $\name$.
The result is the unique subprogram identifier $\newname$, which is used to distinguish it in the set
of overloaded subprograms (that is, other subprograms that share the same name)
and the environment $\newtenv$, which is updated with $\newname$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{first\_name}):
  \begin{itemize}
    \item the $\subprogramrenamings$ map in the global environment of $\tenv$ does not have a binding for $\name$;
    \item $\newtenv$ is $\tenv$ with the $\subprogramrenamings$ updated by binding $\name$ to the singleton set containing
          $\name$.
  \end{itemize}

  \item All of the following apply (\textsc{name\_exists}):
  \begin{itemize}
    \item the $\subprogramrenamings$ map in the global environment of $\tenv$ binds $\name$ to the set of strings $\othernames$;
    \item $\newname$ is the unique name that will be associated with the subprogram given by the identifier $\name$, list of formals $\formals$,
          and subprogram type $\subpgmtype$. It is constructed by concatenating a hyphen (\texttt{-}) to $\name$, followed
          by a string corresponding to the number of strings in $\othernames$.
          Notice that this is not an ASL identifier, as ASL identifiers do not contain hyphens, which ensures that this string
          does not occur in any specification;
    \item $\formaltypes$ is the list of types that appear in $\formals$ in the same order;
    \item checking for each $\namep$ in $\othernames$ whether the subprogram associated with $\namep$ clashes
          with the subprogram type $\subpgmtype$ and list of types $\formaltypes$ yields $\True$
          or a type error that indicates there are multiply defined subprograms, which short-circuits the entire rule;
    \item $\newtenv$ is $\tenv$ with the $\subprogramrenamings$ updated by binding $\name$ to the union of $\othernames$ and
          $\{\newname\}$.
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\AddNewFuncBegin}{\AddNewFuncEnd}{../Typing.ml}

\subsection{Formally}
\newcommand\stringconcat[0]{\hyperlink{def-stringconcat}{\texttt{+}}}
\newcommand\stringofint[0]{\hyperlink{def-stringofnat}{\texttt{string\_of\_nat}}}

We use the following functions to construct a unique string for each subprogram:
\begin{itemize}
\hypertarget{def-stringconcat}{}
\item The function $\stringconcat : \Strings \times \Strings \rightarrow \Strings$
concatenates two strings.

\hypertarget{def-stringofnat}{}
\item The function $\stringofint : \N \rightarrow \Strings$ converts a natural number
to the corresponding string.
\end{itemize}

\begin{mathpar}
\inferrule[first\_name]{
  G^\tenv.\subprogramrenamings(\name) = \bot\\
  \newtenv \eqdef (G^\tenv.\subprogramrenamings[\name\mapsto\{\name\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \overname{\name}{\newname})
}
\and
\inferrule[name\_exists]{
  G^\tenv.\subprogramrenamings(\name) \neq \othernames\\
  k \eqdef \cardinality{\othernames}\\
  \newname \eqdef \name\ \stringconcat\ \texttt{"-"}\ \stringconcat\ \stringofint(k)\\
  \formaltypes \eqdef [(\id,\vt) \in \formals : \vt]\\
  {
    \begin{array}{l}
  \namep \in \othernames: \\ \subprogramclash(\tenv, \namep, \subpgmtype, \formaltypes) \typearrow
  \vb_{\namep} \OrTypeError
    \end{array}
  }\\\\
  {
    \begin{array}{l}
      \namep \in \othernames: \\ \checktrans{\neg\vb_{\namep}}{\SubrogramDeclaredMultipleTimes} \typearrow \True \OrTypeError
    \end{array}
    }\\\\
  \newtenv \eqdef (G^\tenv.\subprogramrenamings[\name\mapsto \othernames \cup \{\newname\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \newname)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{PGFC}.}

\section{TypingRule.CheckSetterHasGetter \label{sec:TypingRule.CheckSetterHasGetter}}
\hypertarget{def-checksetterhashgetter}{}
The function
\[
  \checksetterhasgetter(\overname{\staticenvs}{\tenv} \aslsep \overname{\func}{\funcsig})
  \aslto \overname{\True}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the setter procedure given by $\funcsig$ has a corresponding getter,
returning $\True$ if this condition holds and a type error otherwise.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that the subprogram type of $\funcsig$ is one of $\STSetter$ and \\ $\STEmptySetter$
        has one of two outcomes:
        $\False$, which satisfies the premise;
        or $\True$, which short-circuits the entire rule
        (since the subprogram is not any kind of setter and no getter is required);
  \item \view\ the list of arguments of $\funcsig$ (that is, $\funcsig.\funcargs$) as follows:
        the \head\ is an argument that has the type $\rettype$;
        the \tail\ is a list with arguments that have the types $\argtypes$;
  \item applying $\subprogramforname$ to look up $\tenv$ for a subprogram with the name given by $\funcsig$ (that is, $\funcsig.\funcname$)
        yields a subprogram definition AST node $\funcsigp$\ProseOrTypeError;
  \item define $\watendgettertype$ as $\STGetter$ if $\funcsig.\subprogramtype$ is \\ $\STSetter$ and
        $\STEmptyGetter$ otherwise (meaning, $\funcsig.\subprogramtype$ is $\STEmptySetter$);
  \item checking that $\watendgettertype$ is the same as $\funcsigp.\funcsubprogramtype$ \\ yields $\True$\ProseOrTypeError;
  \item define $\argtypesp$ as the list of types appearing in the signature of $\funcsigp$ (that is, in $\funcsigp.\funcargs$);
  \item checking, for each index $\vi$ in the indices for $\argtypes$, that the type at $\argtypes[\vi]$ and the type at $\argtypesp[\vi]$
        are \typeequivalent\ yields $\True$\ProseOrTypeError;
  \item checking that $\rettype$ and $\funcsigp.\funcreturntype$ are \typeequivalent\ yields \\
        $\True$\ProseOrTypeError;
  \item define $\vb$ as $\True$ (that is, unless the rule short-circuited with a type error).
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\CheckSetterHasGetterBegin}{\CheckSetterHasGetterEnd}{../Typing.ml}

\subsection{Formally}
We define the helper function
\newcommand\matchsettertype[0]{\hyperlink{def-matchsettertype}{\texttt{match\_setter\_type}}}
\hypertarget{def-matchsettertype}{}
\[
  \matchsettertype \triangleq [\STSetter \mapsto \STGetter, \STEmptySetter \mapsto \STEmptyGetter] \enspace.
\]

\begin{mathpar}
\inferrule{
  \issetter \eqdef \funcsig.\subprogramtype \in \{ \STSetter, \STEmptySetter\}\\
  \booltrans{\issetter} \booltransarrow \False \terminateas \True\\\\
  \funcsig.\funcargs \eqname (\Ignore, \rettype) \concat \vargs\\
  \argtypes \eqdef [(\Ignore, \vt) \in \vargs: \vt]\\
  \subprogramforname(\tenv, \funcsig.\funcname, \argtypes) \typearrow (\Ignore, \Ignore, \funcsigp) \OrTypeError\\\\
  \matchsettertype(\funcsig.\funcsubprogramtype) \typearrow \watendgettertype\\
  \checktrans{\watendgettertype = \funcsigp.\funcsubprogramtype}{\SetterWithoutGetter} \typearrow \True \OrTypeError\\\\
  \argtypesp \eqdef [(\Ignore, \vt) \in \funcsigp.\funcargs : \vt]\\
  \vi\in\listrange(\argtypes): \typeequal(\argtypes[\vi], \argtypesp[\vi]) \typearrow \vb_\vi \OrTypeError\\\\
  \vi\in\listrange(\argtypes): \checktrans{\vb_\vi}{\SetterWithoutGetter} \typearrow \True \OrTypeError\\\\
  \typeequal(\rettype, \funcsigp.\funcreturntype) \typearrow \vb_\ret \OrTypeError\\\\
  \checktrans{\vb_\ret}{\SetterWithoutGetter} \typearrow \True \OrTypeError
}{
  \checksetterhasgetter(\tenv, \funcsig) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\section{TypingRule.AddSubprogram \label{sec:TypingRule.AddSubprogram}}
\hypertarget{def-addsubprogram}{}
The function
\[
  \addsubprogram(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\func}{\funcdef})
   \aslto
  \overname{\staticenvs}{\newtenv}
\]
updates the global environment of $\tenv$ by mapping the (unique) subprogram identifier $\name$
to the function definition $\funcdef$ in $\tenv$, resulting in a new static environment $\newtenv$.

\subsection{Prose}
$\newtenv$ is $\tenv$ with its $\subprograms$ component updated by binding $\name$ to $\funcdef$.

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \newtenv \eqdef (G^\tenv.\subprograms[\name\mapsto\funcdef], L^\tenv)
}{
  \addsubprogram(\tenv, \name, \funcdef) \typearrow \newtenv
}
\end{mathpar}

\section{TypingRule.DeclareGlobalStorage \label{sec:TypingRule.DeclareGlobalStorage}}
\hypertarget{def-declareglobalstorage}{}
The function
\[
  \declareglobalstorage(\overname{\staticenvs}{\tenv} \aslsep \overname{\globaldecl}{\gsd})
  \aslto
  \overname{\staticenvs}{\newtenv} \aslsep \overname{\globaldecl}{\newgsd}
  \cup
  \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the global storage declaration $\gsd$ in the static environment $\tenv$,
yielding a modified static environment $\newtenv$ and annotated global storage declaration $\newgsd$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\gsd$ is a global storage declaration with keyword $\keyword$, initial value \\ $\initialvalue$,
        \optional\ type $\tyopt$, and name $\name$;
  \item checking that $\name$ is not already declared in the global environment of $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the \optional\ type $\tyoptp$ in $\tenv$ via $\annotatetypeopt$ yields \\
        $\tyoptp$\ProseOrTypeError;
  \item annotating the \optional\ expression $\initialvalue$ in $\tenv$ via $\annotateexpropt$ yields
        $(\initialvaluetype, \initialvaluep)$\ProseOrTypeError;
  \item choosing the correct type between $\initialvaluetype$ and $\tyoptp$ in $tenv$ via $\annotateinittype$ yields
        $\declaredt$;
  \item adding a global storage element with name $\name$, global declaration keyword \\ $\keyword$ and type $\declaredt$
        to $\tenv$ via $\addglobalstorage$ yields $\tenvone$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{constant}):
    \begin{itemize}
      \item $\keyword$ is $\GDKConstant$ and therefore $\initialvalue$ is some expression $\ve$ (the ASL parser guarantees
            that the expression exists);
      \item symbolically simplifying $\ve$ in $\tenvone$ via $\reduceconstants$ yields the literal $\vv$\ProseOrTypeError;
      \item $\tenvtwo$ is $\tenvone$ with its $\constantvalues$ component updated by binding $\name$ to $\vv$;
      \item $\newgsd$ is $\gsd$ with its type component as $\tyoptp$;
      \item $\newtenv$ is $\tenvtwo$.
    \end{itemize}

    \item All of the following apply (\textsc{non\_contant}):
    \begin{itemize}
      \item $\keyword$ is not $\GDKConstant$;
      \item $\newtenv$ is $\tenvone$.
    \end{itemize}
  \end{itemize}
  \item $\newgsd$ is $\gsd$ with its type component as $\tyoptp$ and $\initialvalue$ component as $\initialvaluep$;
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\DeclareGlobalStorageBegin}{\DeclareGlobalStorageEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[constant]{
  \gsd \eqname \{
    \GDkeyword : \keyword,
    \GDinitialvalue : \initialvalue,
    \GDty : \tyopt,
    \GDname: \name
  \}\\
\checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
\annotatetypeopt(\tenv, \tyopt) \typearrow \tyoptp \OrTypeError\\\\
{
  \begin{array}{r}
\annotateexpropt(\tenv, \initialvalue) \typearrow \\ (\initialvaluetype, \initialvaluep) \OrTypeError
  \end{array}
}\\
\annotateinittype(\tenv, \initialvaluetype, \tyoptp) \typearrow \declaredt\\
\addglobalstorage(\tenv, \name, \keyword, \declaredt) \typearrow \tenvone \OrTypeError\\\\
\keyword = \GDKConstant\\
\initialvaluep \eqname \langle \ve \rangle\\
\reduceconstants(\tenvone, \ve) \typearrow \vv \OrTypeError\\\\
\tenvtwo \eqdef (G^\tenvone.\constantvalues[\name\mapsto\vv], L^\tenvone)\\
{
\newgsd \eqdef \left\{
  \begin{array}{rcl}
  \GDkeyword &:& \keyword, \\
  \GDinitialvalue &:& \initialvalue, \\
  \GDty &:& \tyoptp, \\
  \GDname &:& \name
  \end{array}
\right\}
}
}{
  \declareglobalstorage(\tenv, \gsd) \typearrow (\overname{\tenvtwo}{\newtenv}, \newgsd)
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_constant]{
  \gsd \eqname \{
    \GDkeyword : \keyword,
    \GDinitialvalue : \initialvalue,
    \GDty : \tyopt,
    \GDname: \name
  \}\\
\checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
\annotatetypeopt(\tenv, \tyopt) \typearrow \tyoptp \OrTypeError\\\\
{
  \begin{array}{r}
\annotateexpropt(\tenv, \initialvalue) \typearrow \\ (\initialvaluetype, \initialvaluep) \OrTypeError
  \end{array}
}\\
\annotateinittype(\tenv, \initialvaluetype, \tyoptp) \typearrow \declaredt\\
\addglobalstorage(\tenv, \name, \keyword, \declaredt) \typearrow \tenvone \OrTypeError\\\\
\keyword \neq \GDKConstant\\
{
\newgsd \eqdef \left\{
  \begin{array}{rcl}
  \GDkeyword &:& \keyword, \\
  \GDinitialvalue &:& \initialvalue, \\
  \GDty &:& \tyoptp, \\
  \GDname &:& \name
  \end{array}
\right\}
}
}{
  \declareglobalstorage(\tenv, \gsd) \typearrow (\overname{\tenvone}{\newtenv}, \newgsd)
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This relates to \identr{YSPM} and \identr{FWQM}.}

\section{TypingRule.AnnotateTypeOpt \label{sec:TypingRule.AnnotateTypeOpt}}
\hypertarget{def-annotatetypeopt}{}
The function
\[
\annotatetypeopt(\overname{\staticenvs}{\tenv} \aslsep \overname{\langle\overname{\ty}{\vt}\rangle}{\tyopt})
\typearrow \overname{\langle\ty\rangle}{\tyoptp}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the type $\vt$ inside an \optional\ $\tyopt$, if there is one, and leaves it as is if $\tyopt$ is $\None$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\tyoptp$ is $\None$;
    \item $\tyoptp$ is $\tyopt$.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\tyoptp$ contains the type $\vt$;
    \item annotating $\vt$ in $\tenv$ yields $\vtone$\ProseOrTypeError;
    \item $\tyoptp$ is $\langle\vtone\rangle$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \annotatetypeopt(\tenv, \overname{\None}{\tyopt}) \typearrow \overname{\tyopt}{\tyoptp}
}
\and
\inferrule[some]{
  \annotatetype{\tenv, \vt} \typearrow \vtone \OrTypeError
}{
  \annotatetypeopt(\tenv, \overname{\langle\vt\rangle}{\tyopt}) \typearrow\overname{\langle\vtone\rangle}{\tyoptp}
}
\end{mathpar}

\section{TypingRule.AnnotateExprOpt \label{sec:TypingRule.AnnotateExprOpt}}
\hypertarget{def-annotateexpropt}{}
The function
\[
  \annotateexpropt(\overname{\staticenvs}{\tenv} \aslsep \overname{\langle\ve\rangle}{\expropt})
  \aslto \overname{(\langle\expr\rangle \times \langle\ty\rangle)}{\vres}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the \optional\ expression $\expropt$ in $\tenv$ and returns a pair of \optional\ expressions
for the type and annotated expression in $\vres$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\exproptp$ is $\None$;
    \item $\vres$ is $(\None, \None)$.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\exproptp$ contains the expression $\ve$;
    \item annotating $\ve$ in $\tenv$ yields $(\vt, \vep)$\ProseOrTypeError;
    \item $\vres$ is $(\langle\vt\rangle, \langle\vep\rangle)$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \annotateexpropt(\tenv, \overname{\None}{\expropt}) \typearrow (\None, \None)
}
\and
\inferrule[some]{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \vep)\OrTypeError
}{
  \annotateexpropt(\tenv, \overname{\langle\ve\rangle}{\expropt}) \typearrow \overname{(\langle\vt\rangle, \langle\vep\rangle)}{\vres}
}
\end{mathpar}

\section{TypingRule.AnnotateInitType \label{sec:TypingRule.AnnotateInitType}}
\hypertarget{def-annotateinittype}{}
The function
\[
  \annotateinittype(\overname{\staticenvs}{\tenv} \aslsep
  \overname{\langle\ty\rangle}{\initialvaluetype} \aslsep
  \overname{\langle\ty\rangle}{\typeannotation}
  )
  \aslto \overname{\ty}{\declaredtype}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
takes the \optional\ type associated with the initialization value of a global storage declaration --- $\initialvaluetype$ ---
and the \optional\ type annotation for the same global storage declaration --- $\typeannotation$ ---
and chooses the type that should be associated with the declaration --- $\declaredtype$ -- in $\tenv$.
\ProseOtherwiseTypeError

The ASL parser ensures that at least one of $\initialvaluetype$ and \\
$\typeannotation$ should not be $\None$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{both}):
  \begin{itemize}
    \item $\initialvaluetype$ is $\langle\vtone\rangle$ and $\typeannotation$ is $\langle\vttwo\rangle$;
    \item checking that $\vtone$ \typesatisfies\ $\vttwo$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\declaredtype$ is $\vtone$.
  \end{itemize}

  \item All of the following apply (\textsc{annotated}):
  \begin{itemize}
    \item $\initialvaluetype$ is $\None$ and $\typeannotation$ is $\langle\vttwo\rangle$;
    \item $\declaredtype$ is $\vttwo$.
  \end{itemize}

  \item All of the following apply (\textsc{initial}):
  \begin{itemize}
    \item $\initialvaluetype$ is $\langle\vtone\rangle$ and $\typeannotation$ is $\None$;
    \item $\declaredtype$ is $\vtone$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[both]{
  \checktypesat(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError
}{
  \annotateinittype(\tenv, \overname{\langle\vtone\rangle}{\initialvaluetype}, \overname{\langle\vttwo\rangle}{\typeannotation})
  \typearrow \vttwo
}
\and
\inferrule[annotated]{}{
  \annotateinittype(\tenv, \overname{\None}{\initialvaluetype}, \overname{\langle\vttwo\rangle}{\typeannotation})
  \typearrow \vttwo
}
\and
\inferrule[initial]{}{
  \annotateinittype(\tenv, \overname{\langle\vtone\rangle}{\initialvaluetype}, \overname{\None}{\typeannotation})
  \typearrow \vtone
}
\end{mathpar}

\section{TypingRule.AddGlobalStorage \label{sec:TypingRule.AddGlobalStorage}}
\hypertarget{def-addglobalstorage}{}
The function
\[
  \addglobalstorage(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\GDkeyword}{\keyword} \aslsep
    \overname{\ty}{\declaredt}
  )
  \aslto
    \overname{\staticenvs}{\newtenv} \aslsep
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
modifies the static environment $\tenv$ by adding a global storage
for the identifier $\name$ with global storage keyword $\keyword$ and type $\declaredtypes$,
resulting in the environment $\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that $\name$ is not declared in the global environment of $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newtenv$ is $\tenv$ with its $\globalstoragetypes$ component updated by binding $\name$ to
        $(\declaredt, \keyword)$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
  \newtenv \eqdef (G^\tenv.\globalstoragetypes[\name \mapsto (\declaredt, \keyword)], L^\tenv)
}
{
  \addglobalstorage(\tenv, \name, \keyword, \declaredt) \typearrow \newtenv
}
\end{mathpar}

\section{TypingRule.DeclareType \label{sec:TypingRule.DeclareType}}
\hypertarget{def-declaretype}{}
The function
\[
\declaretype(\overname{\staticenvs}{\tenv} \aslsep
            \overname{\identifier}{\name} \aslsep
            \overname{\ty}{\tty} \aslsep
            \overname{\langle(\identifier\times\field^*)\rangle}{\vs}
) \aslto \overname{\staticenvs}{\newtenv}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
declares a type named $\name$ with type $\tty$ and \optional\ additional fields
over another type $\vs$
in the static environment $\tenv$, resulting in the modified environment $\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that $\name$ is not already declared in the global environment of $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the \optional\ extra fields $\vs$ for $\tty$ in $\tenv$ yields via \\ $\annotateextrafields$
        yields the modified environment $\tenvone$ and type $\vtone$\ProseOrTypeError;
  \item annotating $\vtone$ in $\tenvone$ yields $\vttwo$\ProseOrTypeError;
  \item $\tenvtwo$ is $\tenvone$ with its $\declaredtypes$ component updated by binding $\name$ to $\vttwo$;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{enum}):
    \begin{itemize}
      \item $\vttwo$ is an enumeration type with labels $\ids$, that is, $\TEnum(\ids)$;
      \item applying $\declareenumlabels$ to $\vttwo$ in $\tenvtwo$ $\newtenv$\ProseOrTypeError.
    \end{itemize}

    \item All of the following apply (\textsc{not\_enum}):
    \begin{itemize}
      \item $\vttwo$ is not an enumeration type;
      \item $\newtenv$ is $\tenvtwo$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\DeclareTypeBegin}{\DeclareTypeEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[enum]{
  \checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
  \annotateextrafields(\tenv, \tty, \vs) \typearrow (\tenvone, \vtone)\\
  \annotatetype{\True, \tenvone, \vtone} \typearrow \vttwo \OrTypeError\\\\
  \tenvtwo \eqdef (G^\tenvone.\declaredtypes[\name\mapsto\vttwo], L^\tenvone)\\
  \vttwo = \TEnum(\ids)\\
  \declareenumlabels(\tenvtwo, \vttwo) \typearrow \newtenv \OrTypeError
}{
  \declaretype(\tenv, \name, \tty, \vs) \typearrow \newtenv
}
\and
\inferrule[not\_enum]{
  \checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
  \annotateextrafields(\tenv, \tty, \vs) \typearrow (\tenvone, \vtone)\\
  \annotatetype{\True, \tenvone, \vtone} \typearrow \vttwo \OrTypeError\\\\
  \tenvtwo \eqdef (G^\tenvone.\declaredtypes[\name\mapsto\vttwo], L^\tenvone)\\
  \astlabel(\vttwo) \neq \TEnum
}{
  \declaretype(\tenv, \name, \tty, \vs) \typearrow \overname{\tenvtwo}{\newtenv}
}
\end{mathpar}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{DHRC}, \identd{YZBQ}, \identr{DWSP}, \identi{MZXL}, \identr{MDZD}, \identr{CHKR}.}

\section{TypingRule.AnnotateExtraFields \label{sec:TypingRule.AnnotateExtraFields}}
\hypertarget{def-annotateextrafields}{}
The function
\[
\begin{array}{r}
\annotateextrafields(\overname{\staticenvs}{\tenv} \aslsep
  \overname{\ty}{\tty} \aslsep
  \overname{\langle(\overname{\identifier}{\vsuper}\times\overname{\field^*}{\extrafields})\rangle}{\vs}
)
\aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newty})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the type $\tty$ with the \optional\ extra fields $\vs$ in $\tenv$, yielding
the modified environment $\newtenv$ and type $\newty$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vs$ is $\None$;
    \item $\newtenv$ is $\tenv$;
    \item $\newty$ is $\tty$.
  \end{itemize}

  \item All of the following apply (\textsc{empty\_fields}):
  \begin{itemize}
    \item $\vs$ is $(\vsuper, \emptylist)$;
    \item checking that $\tty$ \subtypesatisfies\ the named type $\vsuper$ (that is, \\ $\TNamed(\vsuper)$) yields
          $\True$\ProseOrTypeError;
    \item $\newtenv$ is $\tenv$;
    \item $\newty$ is $\tty$.
  \end{itemize}

  \item All of the following apply (\textsc{no\_super}):
  \begin{itemize}
    \item $\vs$ is $(\vsuper, \emptylist)$;
    \item checking that $\tty$ \subtypesatisfies\ the named type $\vsuper$ (that is, \\ $\TNamed(\vsuper)$) yields
          $\True$\ProseOrTypeError;
    \item $\vsuper$ is not bound to a type in $\tenv$;
    \item the result is a type error indicating that $\vsuper$ is not a declared type.
  \end{itemize}

  \item All of the following apply (\textsc{structured}):
  \begin{itemize}
    \item $\vs$ is $(\vsuper, \emptylist)$;
    \item checking that $\tty$ \subtypesatisfies\ the named type $\vsuper$ (that is,\\ $\TNamed(\vsuper)$) yields
          $\True$\ProseOrTypeError;
    \item $\vsuper$ is bound to a type $\vt$ in $\tenv$;
    \item checking that $\vt$ is a \structuredtype\ yields $\True$ or a type error
          indicating that a \structuredtype\ was expected, thereby short-circuiting the entire rule;
    \item $\vt$ has AST label $L$ and fields $\fields$;
    \item $\newty$ is the type with AST label $L$ and list fields that is the concatenation of $\fields$ and $\extrafields$;
    \item $\newtenv$ is $\tenv$ with its $\subtypes$ component updated by binding $\name$ to $\vsuper$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \annotateextrafields(\tenv, \tty, \overname{\None}{\vs}) \typearrow (\overname{\tenv}{\newtenv}, \overname{\tty}{\newty})
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty\_fields]{
  \vs = \langle(\vsuper, \emptylist)\rangle\\
  \subtypesat(\tty, \TNamed(\vsuper)) \typearrow \vb\\
  \checktrans{\vb}{TypeConflict} \typearrow \True \OrTypeError
}{
  \annotateextrafields(\tenv, \tty, \vs) \typearrow (\overname{\tenv}{\newtenv}, \overname{\tty}{\newty})
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_super]{
  \subtypesat(\tty, \TNamed(\vsuper)) \typearrow \vb\\
  \checktrans{\vb}{TypeConflict} \typearrow \True \OrTypeError\\\\
  G^\tenv.\declaredtypes(\vsuper) = \bot
}{
  \annotateextrafields(\tenv, \tty, \overname{\langle(\vsuper, \extrafields)\rangle}{\vs}) \typearrow
  \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  \subtypesat(\tty, \TNamed(\vsuper)) \typearrow \vb\\
  \checktrans{\vb}{TypeConflict} \typearrow \True \OrTypeError\\\\
  G^\tenv.\declaredtypes(\vsuper) = \vt\\
  {
    \begin{array}{r}
  \checktrans{\astlabel(\vt) \in \{\TRecord, \TException\}}{ExpectedStructuredType} \typearrow \\ \True \OrTypeError
    \end{array}
  }\\
  \vt \eqname L(\fields)\\
  \newty \eqdef L(\fields \concat \extrafields)\\
  \newtenv \eqdef (G^\tenv.\subtypes[\name\mapsto\vsuper], L^\tenv)
}{
  \annotateextrafields(\tenv, \tty, \overname{\langle(\vsuper, \extrafields)\rangle}{\vs}) \typearrow (\newtenv, \newty)
}
\end{mathpar}

\section{TypingRule.AnnotateEnumLabels \label{sec:TypingRule.AnnotateEnumLabels}}
\hypertarget{def-annotateenumlabels}{}
The function
\[
\declareenumlabels(\overname{\staticenvs}{\tenv} \aslsep
  \overname{\identifier}{\name} \aslsep
  \overname{\identifier^+}{\ids} \aslsep
  \aslto \overname{\staticenvs}{\newtenv}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
)
\]
updates the static environment $\tenv$ with the identifiers $\ids$ listed by an enumeration type,
yielding the modified environment $\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ids$ is the (non-empty) list of labels $\id_{1..k}$;
  \item $\tenv_0$ is $\tenv$;
  \item declaring the constant $\id_i$ with the type $\TNamed(\name)$ and literal \lint(i-1) in $\tenv_{i-1}$
        via $\declareconst$
        yields $\tenv_i$, for $i=1 $ to $k$ (if $k>1$)\ProseOrTypeError;
  \item $\newtenv$ is $\tenv_k$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ids \eqname \id_{1..k}\\
  \tenv_0 \eqdef \tenv\\
  \vi=1..k: \declareconst(\tenv_{\vi-1}, \id_\vi, \TNamed(\name), \lint(\vi-1)) \typearrow \tenv_{\vi} \OrTypeError
}{
  \declareenumlabels(\tenv, \name, \ids) \typearrow \overname{\tenv_k}{\newtenv}
}
\end{mathpar}

\section{TypingRule.DeclareConst \label{sec:TypingRule.DeclareConst}}
\hypertarget{def-declareconst}{}
The function
\[
\declareconst(\overname{\staticenvs}{\tenv} \aslsep
              \overname{\identifier}{\name} \aslsep
              \overname{\ty}{\tty} \aslsep
              \overname{\literal}{vv})
              \aslto
              \overname{\staticenvs}{\newtenv} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
adds a constant given by the identifier $\name$, type $\tty$, and literal $\vv$ to the
static environment $\tenv$, yielding the modified environment $\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item adding the global storage given by the identifier $\name$, global declaration keyword $\GDKConstant$,
        and type $\tty$ to $\tenv$ yields $\tenvone$;
  \item $\newtenv$ is $\tenvone$ with its $\constantvalues$ component updated by binding $\name$ to $\vv$.
\end{itemize}

\begin{mathpar}
\inferrule{
  \addglobalstorage(\tenv, \name, \GDKConstant, \tty) \typearrow \tenvone\\
  \newtenv \eqdef (G^\tenvone.\constantvalues[\name, \vv], L^\tenvone)
}{
  \declareconst(\tenv, \name, \tty, \vv) \typearrow \newtenv
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Specifications}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The parsed AST of an ASL specification consists of a list of declarations.
Type-checking the parsed AST succeeds if all declarations can be successfully annotated.
This is achieved via the function $\typecheckast$, which is detailed in
TypingRule.TypeCheckAST (see \secref{TypingRule.TypeCheckAST}).

We define the following helper rules:
\begin{itemize}
  \item TypingRule.AnnotateDeclComps (see \secref{TypingRule.AnnotateDeclComps})
  \item TypingRule.BuildDependencies (see \secref{TypingRule.BuildDependencies})
  \item TypingRule.DeclDependencies (see \secref{TypingRule.DeclDependencies})
  \item TypingRule.TypeCheckMutuallyRec (see \secref{TypingRule.TypeCheckMutuallyRec})
  \item TypingRule.FoldEnvAndFs (see \secref{TypingRule.FoldEnvAndFs})
  \item TypingRule.DefDecl (see \secref{TypingRule.DefDecl})
  \item TypingRule.DefEnumLabels (see \secref{TypingRule.DefEnumLabels})
  \item TypingRule.UseDecl (see \secref{TypingRule.UseDecl})
  \item TypingRule.UseTy (see \secref{TypingRule.UseTy})
  \item TypingRule.UseSubtypes (see \secref{TypingRule.UseSubtypes})
  \item TypingRule.UseExpr (see \secref{TypingRule.UseExpr})
  \item TypingRule.UseLexpr (see \secref{TypingRule.UseLexpr})
  \item TypingRule.UsePattern (see \secref{TypingRule.UsePattern})
  \item TypingRule.UseSlice (see \secref{TypingRule.UseSlice})
  \item TypingRule.UseBitfield (see \secref{TypingRule.UseBitfield})
  \item TypingRule.UseConstraint (see \secref{TypingRule.UseConstraint})
  \item TypingRule.UseStmt (see \secref{TypingRule.UseStmt})
  \item TypingRule.UseLDI (see \secref{TypingRule.UseLDI})
  \item TypingRule.UseCase (see \secref{TypingRule.UseCase})
  \item TypingRule.UseCatcher (see \secref{TypingRule.UseCatcher})
\end{itemize}

\section{TypingRule.TypeCheckAST \label{sec:TypingRule.TypeCheckAST}}
\hypertarget{def-typecheckast}{}
The relation
\[
\typecheckast(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\decl^*}{\decls}
) \aslrel
(\overname{\decl^*}{\newdecls} \times \overname{\staticenvs}{\newtenv})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of declarations $\decls$ in an input static environment $\tenv$,
yielding an output static environment $\newtenv$ and annotated list of declarations $\newdecls$.
\ProseOtherwiseTypeError

\begin{definition}[Strongly Connected Components]
\hypertarget{def-scc}{}
Given a graph $G=(V, E)$, a \\ subset of its nodes $C \subseteq V$ is called
a \emph{strongly connected component} of $G$ if
every pair of nodes $u,v \in C$ reachable from one another.

The \emph{strongly connected components} of a graph $(V, E)$ uniquely partitions its set of
nodes $V$ into a set of strongly connected components:
\[
\SCC(V, E) \triangleq \{ C \subseteq V \;|\; \forall u,v\in C.\ (u,v), (v,u) \in E^* \} \enspace.
\]

We write $E^*$ to denote the reflexive-transitive closure of $E$.
\end{definition}

\begin{definition}[Topological Ordering]
For a graph $G=(V, E)$ and its \\
strongly connected components $\comps \triangleq \SCC(V, E)$,
we say that $C_1\in\comps$ is ordered before $C_2\in\comps$, denoted $C_1 < C_2$,
if the following condition holds:
\[
C_1 < C_2 \Leftrightarrow \exists c_1\in C_1.\ c_2\in C_2.\ (c_1,c_2) \in E^* \enspace.
\]
This ordering is not total. That is, there may exist to strongly connected components
$A,B\in\comps$ such that $A \not< B$ and $B \not< A$.

\hypertarget{def-topologicalordering}{}
We say that a list of subsets of $V$ --- $\compstwo$ --- respects the topological ordering of $\comps$
if each element of $\compstwo$ is a member of $\comps$ and if $C_1,C_2\in\comps$ such that
$C_1 < C_2$ then $C_1$ appears before $C_2$ in $\compstwo$.
We denote this as $\compstwo \in \topologicalordering(V, E, \compsone)$.
\end{definition}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\builddependencies$ to $\decls$ yields the dependency graph \\ $(\defs, \dependencies)$;
  \item partitioning the nodes of the dependency graph $(\defs, \dependencies)$ into strongly connected components
        yields $\comps$;
  \item $\compstwo$ is an ordering of $\comps$ that respects the topological ordering induced by $\dependencies$;
  \item $\compdecls$ applies $\declsofcomp$ to each component $\vc$ in $\compstwo$ to transform it into a list,
        yielding a list of lists where each sublist corresponds to one strongly connected component;
  \item applying $\annotatedeclcomps$ to $\compdecls$ in $\tenv$ yields \\
        $(\newdecls, \newtenv)$\ProseOrTypeError.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\SpecificationBegin}{\SpecificationEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \builddependencies(\decls) \typearrow (\defs, \dependencies)\\
  \SCC(\defs, \dependencies) = \compsone\\
  \compstwo \in \topologicalordering(\compsone, \dependencies)\\
  \compdecls \eqdef [ \vc\in\compstwo: \declsofcomp(\vc, \decls) ]\\
  \annotatedeclcomps(\tenv, \compdecls) \typearrow (\newdecls, \newtenv) \OrTypeError
}{
  \typecheckast(\tenv, \decls) \typearrow (\newdecls, \newtenv)
}
\end{mathpar}

\subsection{Comments}
It is crucial to process the strongly connected components obtained from the dependency graph
according to the topological ordering of the components. Otherwise, the type-system could
falsely result in a type error indicating that some identifier is not defined.
However, a topological ordering is not unique, which is why $\typecheckast$ is a relation rather than
a function.
It is possible to obtain a deterministic ordering by ordering components so as to respect
the order of declarations in $\decls$, that is,
the order in which declarations appear in the specification.
Similarly, any ordering of the declarations within a single strongly connected component is correct,
but it is possible to order the declarations according to their order of appearance in $\decls$,
as demonstrated in TypingRule.DeclsOfComp.

\lrmcomment{This relates to \identi{LWQQ}.}

\section{TypingRule.DeclsOfComp \label{sec:TypingRule.DeclsOfComp}}
\hypertarget{def-declsofcomp}{}
The helper function
\[
\declsofcomp(
  \overname{\pow{\identifier}}{\comp} \aslsep
  \overname{\decl^*}{\decls}
) \aslto \overname{\decl^*}{\compdecls}
\]
lists the sublist of declarations in $\decls$ corresponding to the identifiers in $\comp$
yielding $\compdecls$

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\decls$ is the empty list;
    \item define $\compdecls$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\decls$ is the list with \head\ $\vd$ and \tail\ $declsone$;
    \item define $\declstwo$ as the singleton list for $\vd$ if applying $\defdecl$ to $\vd$ yields an identifier
          that is a member of $\comp$ and the empty list, otherwise;
    \item applying $\declsofcomp$ to $\comp$ and $\declsone$ yields $\declsthree$;
    \item define $\compdecls$ as the concatenation of $\declstwo$ and $\declsthree$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \declsofcomp(\comp, \overname{\emptylist}{\decls}) \typearrow \overname{\emptylist}{\compdecls}
}
\and
\inferrule[non\_empty]{
  \declstwo \eqdef \choice{\defdecl(\vd) \in \comp}{[\vd]}{\emptylist}\\
  \declsofcomp(\comp, \declsone) \typearrow \declsthree
}{
  \declsofcomp(\comp, \overname{[\vd]\concat\declsone}{\decls}) \typearrow \overname{\declstwo\concat\declsthree}{\compdecls}
}
\end{mathpar}

\section{TypingRule.AnnotateDeclComps \label{sec:TypingRule.AnnotateDeclComps}}
\hypertarget{def-annotatedeclcomps}{}
The function
\[
\annotatedeclcomps(\overname{\staticenvs}{\tenv} \aslsep \overname{(\decl^*)^*}{\comps})
\aslto
(\overname{\staticenvs}{\newtenv} \times \overname{\decl^*}{\newdecls})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of declaration components $\comps$
(a list of lists) in the static environment $\tenv$,
yielding the annotated list of declarations $\newdecls$ and modified environment $\newtenv$.
\ProseOtherwiseTypeError

We note that a strongly-connected component containing just a single declaration may contain
any kind of global declaration ---
a type declaration, a global storage declaration, or a subprogram declaration ---
whereas a strongly-connected component containing multiple declarations must be checked
to contain only subprograms. This is because the only type of mutually-recursive declarations
allows in ASL are between subprograms. The rules below handle these cases separately (\textsc{single}
for single declarations and \textsc{mutually\_recursive} for more than one declaration).

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\comps$ is the empty list;
    \item define $\newtenv$ as $\tenv$;
    \item define $\newdecls$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\comps$ is a list with \head\ $\comp$ and \tail\ $\compsone$;
    \item $\comp$ is a single declaration $\vd$;
    \item applying $\typecheckdecl$ to $\vd$ in $\tenv$ yields $(\vdone, \tenvone)$\ProseOrTypeError;
    \item applying $\annotatedeclcomps$ to $\compsone$ in $\tenvone$ yields \\ $(\newtenv, \declsone)$\ProseOrTypeError;
    \item define $\newdecls$ as the list with \head\ $\vdone$ and \tail\ $\declsone$.
  \end{itemize}

  \item All of the following apply (\textsc{mutually\_recursive}):
  \begin{itemize}
    \item $\comps$ is a list with \head\ $\comp$ and \tail\ $\compsone$;
    \item $\comp$ is a list with more than one declaration (which together represent a mutually-recursive
          list of declarations);
    \item applying $\typecheckmutuallyrec$ to $\comp$ in $\tenv$ yields \\ $(\declsone, \tenvone)$\ProseOrTypeError;
    \item applying $\annotatedeclcomps$ to $\compsone$ in $\tenvone$ yields \\ $(\newtenv, \declstwo)$\ProseOrTypeError;
    \item define $\newdecls$ as the concatenation of $\declsone$ and $\declstwo$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \annotatedeclcomps(\tenv, \overname{\emptylist}{\comps}) \aslto (\overname{\tenv}{\newtenv}, \overname{\emptylist}{\newdecls})
}
\and
\inferrule[single]{
  \comp = [\vd]\\
  \typecheckdecl(\tenv, \vd) \typearrow (\vdone, \tenvone) \OrTypeError\\\\
  \annotatedeclcomps(\tenvone, \compsone) \typearrow (\newtenv, \declsone) \OrTypeError
}{
  \annotatedeclcomps(\tenv, \overname{[\comp] \concat \compsone}{\comps}) \aslto
  (\newtenv, \overname{[\vdone] \concat \declsone}{\newdecls})
}
\and
\inferrule[mutually\_recursive]{
  |\comp| > 1\\
  \typecheckmutuallyrec(\tenv, \comp) \typearrow (\declsone, \tenvone) \OrTypeError\\\\
  \annotatedeclcomps(\tenvone, \compsone) \typearrow (\newtenv, \declstwo) \OrTypeError
}{
  \annotatedeclcomps(\tenv, \overname{[\comp] \concat \compsone}{\comps}) \aslto
  (\newtenv, \overname{\declsone \concat \declstwo}{\newdecls})
}
\end{mathpar}

\section{TypingRule.BuildDependencies \label{sec:TypingRule.BuildDependencies}}
\hypertarget{def-builddependencies}{}
The function
\[
\builddependencies(\overname{\decl^*}{\decls})
\aslto
(\overname{\identifier^*}{\defs}, \overname{(\identifier\times\identifier)^*}{\dependencies})
\]
takes a set of declarations $\decls$ and
returns a graph whose set of nodes are the identifiers that are used to name declarations
and whose set of edges $\dependencies$ consists of pairs $(a,b)$
where the declaration of $a$ uses an identifier defined by $b$.
We refer to this graph as the \emph{dependency graph} (of $\decls$).

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item define $\defs$ as the union of two sets:
  \begin{enumerate}
  \item the set of identifiers obtained by applying $\defdecl$ to each declaration in $\decls$;
  \item the union of applying $\defenumlabels$ to each declaration in $\decls$.
  \end{enumerate}
  \item define $\dependencies$ as the union of applying $\decldependencies$ to each declaration in $\decls$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \defs \eqdef \{ \defdecl(\vd) \;|\; \vd \in \decls\} \cup \bigcup_{\vd\in\decls} \defenumlabels(\vd)\\
  \dependencies \eqdef \bigcup_{\vd \in \decls} \decldependencies(\vd)
}{
  \builddependencies(\decls) \typearrow (\ids, \dependencies)
}
\end{mathpar}

\section{TypingRule.DeclDependencies \label{sec:TypingRule.DeclDependencies}}
\hypertarget{def-decldependencies}{}
The function
\[
\decldependencies(\overname{\decl}{\vd}) \aslto \overname{(\identifier\times\identifier)^*}{\dependencies}
\]
returns the set of dependent pairs of identifiers $\dependencies$ induced by the declaration $\vd$.

\subsection{Prose}
Define $\dependencies$ as the union of the following two sets:
\begin{enumerate}
  \item a pair $(\idone, \idtwo)$ where $\idone$ is the result of applying $\defdecl$ to $\vd$
        and $\idtwo$ included in the result of applying $\defenumlabels$ to $\vd$; and
  \item a pair $(\idone, \idtwo)$ where $\idone$ is the result of applying $\defdecl$ to $\vd$
        and $\idtwo$ included in the result of applying $\usedecl$ to $\vd$; and
\end{enumerate}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{rcll}
  \dependencies & \eqdef  & \{ (\idone, \idtwo) \;|\; \idone = \defdecl(\vd), \idtwo \in \defenumlabels(\vd) \} & \cup\\
                &         & \{ (\idone, \idtwo) \;|\; \idone = \defdecl(\vd),\ \idtwo \in \usedecl(\vd) \}  &
    \end{array}
  }
}{
  \decldependencies(\vd) \typearrow \dependencies
}
\end{mathpar}

\section{TypingRule.TypeCheckMutuallyRec \label{sec:TypingRule.TypeCheckMutuallyRec}}
\hypertarget{def-typecheckmutuallyrec}{}
The function
\[
  \typecheckmutuallyrec(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\decl^*}{\decls}
  )
  \aslto
  (
    \overname{\decl^*}{\newdecls} \times
    \overname{\staticenvs}{\newtenv}
  )
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of mutually recursive declarations
$\decls$ in the static environment $\tenv$,
yielding the annotated list of subprogram declarations $\newdecls$
and modified environment $\newtenv$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that each declaration in $\vd$ is a subprogram declaration yields $\True$\ProseOrTypeError;
  \item applying $\annotatefuncsig$ to each node $\vf$ in $\tenv$, where $\DFunc(\vf)$ is a declaration in $\decls$,
        yields $(\tenv_\vf, \vd_\vf)$\ProseOrTypeError;
  \item define $\envandfs$ as the list of pairs, each consisting of the local environment component of $\tenv_\vf$
        and the annotated subprogram $\vd_\vf$, for each subprogram declaration $\DFunc(\vf)$ in $\decls$;
  \item splitting $\envandfs$ into two sublists by testing each pair to check whether the subprogram declaration
        component is that of a setter (or an empty setter) yields $\setters$ and $\others$, respectively;
  \item define $\envandfsone$ as the concatenation of $\others$ and $\setters$;
  \item applying $\foldenvandfs$ to the global component of $\tenv$ and $\envandfsone$ yields $(\genv, \envandfstwo)$\ProseOrTypeError;
  \item for each pair consisting of a local static environment and subprogram declaration $(\lenv, \DFunc(\vf))$,
        applying $\annotatesubprogram$ to the static environment $(\genv, \lenv)$ and $\vf$ yields $\newd_\vf$\ProseOrTypeError;
  \item define $\newdecls$ as the list of subprogram declarations $\DFunc(\newd_\vf)$, for each pair $(\Ignore, \DFunc(\vf))$ in
        $\envandfstwo$;
  \item define $\newtenv$ as the static environment $(\genv, L^\tenv)$.
\end{itemize}

\CodeSubsection{\TypeCheckMutuallyRecBegin}{\TypeCheckMutuallyRecEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vd\in\decls: \checktrans{\astlabel(\vd) = \DFunc}{\BadRecursiveDecls} \typearrow \True\OrTypeError\\\\
  \DFunc(\vf)\in\decls: \annotatefuncsig(\tenv, \vf) \typearrow (\tenv_\vf, \vd_\vf)\OrTypeError\\\\
  \envandfs \eqdef [\DFunc(\vf)\in\decls: (L^{\tenv_\vf}, \vd_\vf)]\\
  \setters \eqdef [ (\lenv,\vd) \;|\; (\lenv, \DFunc(\vf)) \land \astlabel(\vf) \in \{\STSetter, \STEmptySetter\}  ]\\
  \others \eqdef [ (\lenv,\vd) \;|\; (\lenv, \DFunc(\vf)) \land \astlabel(\vf) \not\in \{\STSetter, \STEmptySetter\}  ]\\
  \envandfsone \eqdef \others \concat \setters\\
  \foldenvandfs(G^\tenv, \envandfsone) \typearrow (\genv, \envandfstwo) \OrTypeError\\\\
  (\lenv, \DFunc(\vf))\in\envandfstwo: \annotatesubprogram{(\genv, \lenv), \vf} \typearrow \newd_\vf \OrTypeError\\\\
  \newdecls \eqdef [(\Ignore, \DFunc(\vf))\in\envandfstwo: \DFunc(\newd_\vf)]
}{
  \typecheckmutuallyrec(\tenv, \decls) \typearrow (\newdecls, \overname{(\genv, L^\tenv)}{\newtenv})
}
\end{mathpar}

\section{TypingRule.FoldEnvAndFs \label{sec:TypingRule.FoldEnvAndFs}}
\hypertarget{def-foldenvandfs}{}
The function
\[
  \foldenvandfs(
    \overname{\globalstaticenvs}{\genv} \aslsep
    \overname{(\localstaticenvs\times\func)^*}{\envandfs}
  ) \aslto
  \overname{\globalstaticenvs}{\newgenv} \times
  \overname{(\localstaticenvs\times\func)^*}{\newenvandfs}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
processes a list of pairs, each consisting of a local static environment and a subprogram declaration, $\envandfs$,
in the context of a global static environment $\genv$.
The result is a modified global static environment $\newgenv$ and list of pairs $\newenvandfs$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\envandfs$ is the empty list;
    \item define $\newgenv$ as $\genv$;
    \item define $\newenvandfs$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\envandfs$ is the list with \head\ $(\lenv, \vf)$ and \tail\ $\envandfsone$;
    \item define $\tenv$ as the environment where the global environment component is $\genv$ and the local environment component is $\lenv$;
    \item applying $\declareonefunc$ to $\vf$ in $\tenv$ yields $(\tenvone, \vfone)$\ProseOrTypeError;
    \item applying $\foldenvandfs$ to the global environment of $\tenvone$ and \\
          $\envandfsone$ yields $(\newgenv, \envandfstwo)$\ProseOrTypeError;
    \item define $\newenvandfs$ as the list with \head\ $(\lenv, \vfone)$ and \tail\ $\envandfstwo$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \foldenvandfs(\genv, \overname{\emptylist}{\envandfs}) \typearrow (\overname{\genv}{\newgenv}, \overname{\emptylist}{\newenvandfs})
}
\and
\inferrule[non\_empty]{
  \tenv \eqdef (\genv, \lenv)\\
  \declareonefunc(\tenv, \vf) \typearrow (\tenvone, \vfone) \OrTypeError\\\\
  \foldenvandfs(G^\tenvone, \envandfsone) \typearrow (\newgenv, \envandfstwo) \OrTypeError\\\\
  \newenvandfs \eqdef [(\lenv, \vfone)] \concat \envandfstwo
}{
  \foldenvandfs(\genv, \overname{[(\lenv, \vf)]\concat\envandfsone}{\envandfs}) \typearrow (\overname{\genv}{\newgenv}, \newenvandfs)
}
\end{mathpar}

\section{TypingRule.DefDecl \label{sec:TypingRule.DefDecl}}
\hypertarget{def-defdecl}{}
The function
\[
\defdecl(\overname{\decl}{\vd}) \aslto \overname{\identifier}{\name}
\]
returns the identifier $\name$ being defined by the declaration $\vd$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{d\_func}):
  \begin{itemize}
    \item $\vd$ declares a subprogram for the identifier $\name$.
  \end{itemize}

  \item All of the following apply (\textsc{d\_globalstorage}):
  \begin{itemize}
    \item $\vd$ declares a global storage element for the identifier $\name$.
  \end{itemize}

  \item All of the following apply (\textsc{d\_typedecl}):
  \begin{itemize}
    \item $\vd$ declares a type for the identifier $\name$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[d\_func]{}{
  \defdecl(\overname{\DFunc(\funcname: \name, \ldots)}{\vd}) \typearrow \name
}
\and
\inferrule[d\_globalstorage]{}{
  \defdecl(\overname{\DGlobalStorage(\GDname: \name, \ldots)}{\vd}) \typearrow \name
}
\and
\inferrule[d\_typedecl]{}{
  \defdecl(\overname{\DTypeDecl(\name, \Ignore, \Ignore)}{\vd}) \typearrow \name
}
\end{mathpar}

\section{TypingRule.DefEnumLabels \label{sec:TypingRule.DefEnumLabels}}
\hypertarget{def-defenumlabels}{}
The function
\[
\defenumlabels(\overname{\decl}{\vd}) \aslto \overname{\pow{\identifier}}{\vlabels}
\]
takes a declaration $\vd$ and returns the set of enumeration labels it defines --- $\vlabels$ --
if it defines any.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{decl\_enum}):
  \begin{itemize}
    \item $\vd$ is a declaration of an enumeration type with labels $\vlabels$;
    \item the result is $\vlabels$ as a set (rather than a list).
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\vd$ is not a declaration of an enumeration type;
    \item define $\vlabels$ as the empty set.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[decl\_enum]{
  \vd = \DTypeDecl(\name, \TEnum(\vlabels, \Ignore))
}{
  \defenumlabels(\vd) \typearrow \overname{\{\vlabels\}}{\vlabels}
}
\and
\inferrule[other]{
  \vd \neq \DTypeDecl(\name, \TEnum(\vlabels, \Ignore))
}{
  \defenumlabels(\vd) \typearrow \overname{\emptyset}{\vlabels}
}
\end{mathpar}

\section{TypingRule.UseDecl \label{sec:TypingRule.UseDecl}}
\hypertarget{def-usedecl}{}
The function
\[
\usedecl(\overname{\decl}{\vd}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the declaration $\vd$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{D\_TypeDecl}):
  \begin{itemize}
    \item $\vd$ declares a type $\tty$ and fields $\fields$, that is,
          $\DTypeDecl(\Ignore, \tty, \fields)$ (the first component is the name, which is being defined);
    \item define $\ids$ as the union of applying $\usety$ to $\tty$ and applying $\usesubtypes$ to $\fields$.
  \end{itemize}

  \item All of the following apply (\textsc{D\_GlobalStorage}):
  \begin{itemize}
    \item $\vd$ declares a global storage element with initial value $\initialvalue$ and type $\tty$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\initialvalue$ and applying $\usety$ to $\tty$.
  \end{itemize}

  \item All of the following apply (\textsc{D\_Func}):
  \begin{itemize}
    \item $\vd$ declares a subprogram with arguments $\vargs$, \optional\ return type \\
          $\rettyopt$, parameters $\vparams$, and body statement $\body$;
    \item define $\ids$ as the union of applying $\usety$ to each type of an argument in $\vargs$,
          applying $\usety$ to $\rettyopt$, applying $\usety$ to each type of a parameter in $\vparams$,
          and applying $\useexpr$ to $\body$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[D\_TypeDecl]{}{
  \usedecl(\overname{\DTypeDecl(\Ignore, \tty, \fields)}{\vd}) \typearrow \overname{\usety(\tty) \cup \usesubtypes(\fields)}{\ids}
}
\and
\inferrule[D\_GlobalStorage]{
  \ids \eqdef \useexpr(\initialvalue) \cup \usety(\tty)
}{
  \usedecl(\overname{\DGlobalStorage(\{
    \GDinitialvalue: \initialvalue,
    \GDty: \tty\ldots\})}{\vd})
  \typearrow \ids
}
\and
\inferrule[D\_Func]{
  {
    \begin{array}{rcll}
  \ids &\eqdef& \{ (\Ignore, \vt) \in \usety(\vt) : \id \} &\cup\\
  && \usety(\rettyopt) &\cup\\
  && \{ (\Ignore, \vt) \in \vparams : \usety(\vt) \} &\cup \\
  && \useexpr(\body) &
    \end{array}
  }
}{
  {
  \usedecl\left(\overname{
    \DFunc\left(
  \left\{
    \begin{array}{l}
    \funcbody: \body,\\
    \funcargs: \vargs,\\
    \funcreturntype: \rettyopt,\\
    \funcparameters: \vparams,\\
    \ldots\\
    \end{array}
  \right\}
  \right)}{\vd}
  \right)
  \typearrow \ids
  }
}
\end{mathpar}

\section{TypingRule.UseTy \label{sec:TypingRule.UseTy}}
\hypertarget{def-usety}{}
The function
\[
\usety(\overname{\ty \cup \langle\ty\rangle}{\vt}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the type or \optional\ type $\vt$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vt$ is $\None$;
    \item define $\ids$ as $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\vt$ is $\langle\tty\rangle$;
    \item applying $\usety$ to $\tty$ yields $\ids$.
  \end{itemize}

  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item $\vt$ is one of the following types: enumeration, Boolean, real, or string;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_named}):
  \begin{itemize}
    \item $\vt$ is the named type for $\vs$;
    \item define $\ids$ as the singleton set for $\vs$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_no\_constraints}):
  \begin{itemize}
    \item $\vt$ is either the unconstrained integer type or a \parameterizedintegertype;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{int\_well\_constrained}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type with constraints $\vcs$;
    \item define $\ids$ as the union of applying $\useconstraint$ to each constraint in $\vcs$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
    \item $\vt$ is the tuple type with list of types $\vli$;
    \item define $\ids$ as the union of applying $\useconstraint$ to each constraint in $\vcs$.
  \end{itemize}

  \item All of the following apply (\textsc{structured}):
  \begin{itemize}
    \item $\vt$ is a \structuredtype\ with fields $\fields$;
    \item define $\ids$ as the union of applying $\usety$ to each field type in $\fields$.
  \end{itemize}

  \item All of the following apply (\textsc{array\_expr}):
  \begin{itemize}
    \item $\vt$ is an array expression with length expression $\ve$ and element type $\vtp$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and applying $\usety$ to $\vtp$.
  \end{itemize}

  \item All of the following apply (\textsc{array\_enum}):
  \begin{itemize}
    \item $\vt$ is an array expression with enumeration type $\vs$ and element type $\vtp$;
    \item define $\ids$ as the union of the singleton set for $\vs$ and applying $\usety$ to $\vtp$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with width expression $\ve$ and bitfields $\bitfields$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and applying $\usebitfield$ to each field in $\bitfields$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \usety(\overname{\None}{\vt}) \typearrow \overname{\None}{\ids}
}
\and
\inferrule[some]{
  \usety(\tty) \typearrow \ids
}{
  \usety(\overname{\langle\tty\rangle}{\vt}) \typearrow \ids
}
\and
\inferrule[simple]{
  \astlabel(\vt) \in \{\TEnum, \TBool, \TReal, \TString\}
}{
  \usety(\vt) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[t\_named]{}{
  \usety(\overname{\TNamed(\vs)}{\vt}) \typearrow \overname{\{\vs\}}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_no\_constraints]{
  \astlabel(\vc) \in \{\unconstrained, \parameterized\}
}{
  \usety(\overname{\TInt(\vc)}{\vt}) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained]{}{
  \usety(\overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\bigcup_{\vc \in \vcs} \useconstraint(\vc)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{}{
  \usety(\overname{\TTuple(\vli)}{\vt}) \typearrow \overname{\bigcup_{\vt \in \vli} \usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}}{
  \usety(\overname{L(\fields)}{\vt}) \typearrow \overname{\bigcup_{(\Ignore, \vt) \in \fields} \usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[array\_expr]{}{
  \usety(\overname{\TArray(\ArrayLengthExpr(\ve), \vtp)}{\vt}) \typearrow \overname{\useexpr(\ve) \cup \usety(\vtp)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[array\_enum]{}{
  \usety(\overname{\TArray(\ArrayLengthEnum(\vs, \Ignore), \vtp)}{\vt}) \typearrow \overname{\{\vs\} \cup \usety(\vtp)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{}{
  \usety(\overname{\TBits(\ve, \bitfields)}{\vt}) \typearrow \overname{\useexpr(\ve) \cup \bigcup_{\vf \in\bitfields}\usebitfield(\vf)}{\ids}
}
\end{mathpar}

\section{TypingRule.UseSubtypes \label{sec:TypingRule.UseSubtypes}}
\hypertarget{def-usesubtypes}{}
The function
\[
\usesubtypes(\overname{\langle(\overname{\identifier}{\vx}\times\overname{\field^*}{\subfields})\rangle}{\fields}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the \optional\ pair consisting of
identifier $\vx$ (the type being subtyped) and fields $\subfields$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\fields$ is $\None$;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\fields$ is $\langle(\vx, \subfields)\rangle$;
    \item define $\ids$ as the union of the singleton set for $\vx$ and the union of applying $\usety$
          to each field type in $\subfields$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \usesubtypes(\None) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[some]{
  \ids \eqdef \{\vx\} \cup \bigcup_{(\Ignore, \vt) \usety(\vt)}
}{
  \usesubtypes(\langle(\vx, \subfields)\rangle) \typearrow \ids
}
\end{mathpar}

\section{TypingRule.UseExpr \label{sec:TypingRule.UseExpr}}
\hypertarget{def-useexpr}{}
The function
\[
\useexpr(\overname{\expr}{\ve} \cup \langle\overname{\expr}{\ve}\rangle) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the expression or \optional\ expression $\ve$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\ve$ is $\None$;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\ve$ is $\langle\veone\rangle$;
    \item applying $\useexpr$ to $\veone$ yields $\ids$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_literal}):
  \begin{itemize}
    \item $\ve$ is a literal expression;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{e\_atc}):
  \begin{itemize}
    \item $\ve$ is the typing assertion for expression $\ve$ and type $\tty$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\usety$ to $\tty$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var}):
  \begin{itemize}
    \item $\ve$ is the variable expression for identifier $\vx$;
    \item define $\ids$ as the singleton set for $\vx$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getarray}):
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop}):
  \begin{itemize}
    \item $\ve$ is the binary operation expression over expressions $\veone$ and $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop}):
  \begin{itemize}
    \item $\ve$ is the unary operation expression over any unary operation and an expression $\veone$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_call}):
  \begin{itemize}
    \item $\ve$ is the call expression of the subprogram named $\vx$ with argument expressions $\vargs$ and parameter expressions $\namedargs$;
    \item define $\ids$ as the union of the singleton set for $\vx$, applying $\useexpr$ to each expression in $\vargs$ and each expression
          in $\namedargs$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice}):
  \begin{itemize}
    \item $\ve$ is the slicing expression over expression $\veone$ and slices $\slices$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useslice$ to each slice in $\slices$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_cond}):
  \begin{itemize}
    \item $\ve$ is the conditional expression over expressions $\veone$, $\vetwo$, and $\vethree$;
    \item define $\ids$ as the union of applying $\useexpr$ to each of $\veone$, $\vetwo$, and $\vethree$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getitem}):
  \begin{itemize}
    \item $\ve$ is the tuple access expression over expression $\veone$;
    \item define $\ids$ as the application of $\useexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfield}):
  \begin{itemize}
    \item $\ve$ is the field access expression over expression $\veone$;
    \item define $\ids$ as the application of $\useexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfields}):
  \begin{itemize}
    \item $\ve$ is the multiple field access expression over expression $\veone$;
    \item define $\ids$ as the application of $\useexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_record}):
  \begin{itemize}
    \item $\ve$ is the record construction expression of type $\tty$ and field initializations $\vli$;
    \item define $\ids$ as the union of applying of $\usety$ to $\tty$ and applying $\usety$ to each field type in $\vli$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_concat}):
  \begin{itemize}
    \item $\ve$ is the concatenation of expression $\ves$;
    \item define $\ids$ as the union of applying of $\useexpr$ to each expression in $\ves$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_tuple}):
  \begin{itemize}
    \item $\ve$ is the tuple construction expression for the expressions $\ves$;
    \item define $\ids$ as the union of applying of $\useexpr$ to each expression in $\ves$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unknown}):
  \begin{itemize}
    \item $\ve$ is the unknown expression with type $\vt$;
    \item define $\ids$ as the application of $\usety$ to $\vt$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_pattern}):
  \begin{itemize}
    \item $\ve$ is the pattern testing expression for subexpression $\veone$ and pattern $\vp$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\usepattern$ to $\vp$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \useexpr(\overname{\None}{\ve}) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[some]{
  \useexpr(\veone) \typearrow \ids
}{
  \useexpr(\overname{\langle\veone\rangle}{\ve}) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[e\_literal]{}{
  \useexpr(\overname{\ELiteral(\Ignore)}{\ve}) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[e\_atc]{}{
  \useexpr(\overname{\EATC(\veone, \tty)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \usety(\tty)}{\ids}
}
\and
\inferrule[e\_var]{}{
  \useexpr(\overname{\EVar(\vx)}{\ve}) \typearrow \overname{\{\vx\}}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getarray]{}{
  \useexpr(\overname{\EGetArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{}{
  \useexpr(\overname{\EBinop(\Ignore, \veone, \vetwo)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{}{
  \useexpr(\overname{\EUnop(\Ignore, \veone)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_call]{
  \ids \eqdef \{\vx\} \cup  \bigcup_{\veone}\useexpr(\veone\in\vargs) \cup \bigcup_{(\Ignore, \vt)\in\namedargs}\usety(\vt)
}{
  \useexpr(\overname{\ECall(\vx, \vargs, \namedargs)}{\ve}) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice]{}{
  \useexpr(\overname{\ESlice(\veone, \slices)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \bigcup_{\vs\in\slices}\useslice(\vs)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{}{
  \useexpr(\overname{\ECond(\veone, \vetwo, \vethree)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo) \cup \useexpr(\vethree)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getitem]{}{
  \useexpr(\overname{\EGetItem(\veone, \Ignore)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\and
\inferrule[e\_getfield]{}{
  \useexpr(\overname{\EGetField(\veone, \Ignore)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfields]{}{
  \useexpr(\overname{\EGetFields(\veone, \Ignore)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record]{}{
  \useexpr(\overname{\ERecord(\tty, \vli)}{\ve}) \typearrow \overname{\usety(\tty) \cup \bigcup_{(\Ignore, \vt)\in\usety(\vt)}}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_concat]{}{
  \useexpr(\overname{\EConcat(\ves)}{\ve}) \typearrow \overname{\bigcup_{\veone\in\ves}\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_tuple]{}{
  \useexpr(\overname{\EConcat(\ves)}{\ve}) \typearrow \overname{\bigcup_{\veone\in\ves}\useexpr(\veone)}{\ids}
}
\and
\inferrule[e\_unknown]{}{
  \useexpr(\overname{\EUnknown(\vt)}{\ve}) \typearrow \overname{\usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern]{}{
  \useexpr(\overname{\EPattern(\veone, \vp)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \usepattern(\vp)}{\ids}
}
\end{mathpar}

\section{TypingRule.UseLexpr \label{sec:TypingRule.UseLexpr}}
\hypertarget{def-uselexpr}{}
The function
\[
\uselexpr(\overname{\lexpr}{\vle}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the left-hand-side expression $\vle$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{le\_var}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side variable expression for $\vx$;
    \item define $\ids$ as the singleton set for $\vx$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_destructuring}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side expression for assigning to a list of expressions $\vles$,
          that is $\LEDestructuring(\vles)$;
    \item define $\ids$ as the union of applying $\uselexpr$ to each expression in $\vles$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_concat}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side concatenation of the list of expressions $\vles$;
    \item define $\ids$ as the union of applying $\uselexpr$ to each expression in $\vles$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_discard}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side discard expression;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{le\_setarray}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side array update of the array given by the expression $\veone$ and index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_setfield}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side field update of the record given by the expression $\veone$;
    \item define $\ids$ as the application of $\uselexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_setfields}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side multiple field updates of the record given by the expression $\veone$;
    \item define $\ids$ as the application of $\uselexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_slice}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side slicing of the expression $\veone$ by slices $\slices$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\veone$ and applying $\useslice$ to each slice in $\slices$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[le\_var]{}{
  \uselexpr(\overname{\LEVar(\vx)}{\vle}) \typearrow \overname{\vx}{\ids}
}
\and
\inferrule[le\_destructuring]{}{
  \uselexpr(\overname{\LEDestructuring(\vles)}{\vle}) \typearrow \overname{\bigcup_{\ve\in\vles}\uselexpr(\ve)}{\ids}
}
\and
\inferrule[le\_concat]{}{
  \uselexpr(\overname{\LEConcat(\vles)}{\vle}) \typearrow \overname{\bigcup_{\ve\in\vles}\uselexpr(\ve)}{\ids}
}
\and
\inferrule[le\_discard]{}{
  \uselexpr(\overname{\LEDiscard}{\vle}) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setarray]{}{
  \uselexpr(\overname{\LESetArray(\veone, \vetwo)}{\vle}) \typearrow \overname{\uselexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setfield]{}{
  \uselexpr(\overname{\LESetField(\veone, \Ignore)}{\vle}) \typearrow \overname{\uselexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setfields]{}{
  \uselexpr(\overname{\LESetFields(\veone, \Ignore)}{\vle}) \typearrow \overname{\uselexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_slice]{}{
  \uselexpr(\overname{\LESlice(\veone, \slices)}{\vle}) \typearrow \overname{\uselexpr(\veone) \cup \bigcup_{\vs\in\slices}\useslice(\vs)}{\ids}
}
\end{mathpar}

\section{TypingRule.UsePattern \label{sec:TypingRule.UsePattern}}
\hypertarget{def-usepattern}{}
The function
\[
\usepattern(\overname{\pattern}{\vp}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the declaration $\vd$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{mask\_all}):
  \begin{itemize}
    \item $\vp$ is either a mask pattern ($\PatternMask$) or a match-all pattern ($\PatternAll$);
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\vp$ is a tuple pattern list of patterns $\vli$;
    \item define $\ids$ as the union of the application of $\usepattern$ for each pattern in $\vli$.
  \end{itemize}

  \item All of the following apply (\textsc{any}):
  \begin{itemize}
    \item $\vp$ is a pattern for matching any of the patterns in the list of patterns $\vli$;
    \item define $\ids$ as the union of the application of $\usepattern$ for each pattern in $\vli$.
  \end{itemize}

  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\vp$ is a pattern for matching the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{geq}):
  \begin{itemize}
    \item $\vp$ is a pattern for testing greater-or-equal with respect to the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{leq}):
  \begin{itemize}
    \item $\vp$ is a pattern for testing less-than-or-equal with respect to the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{not}):
  \begin{itemize}
    \item $\vp$ is a pattern negating the pattern $\vpone$;
    \item define $\ids$ as the application of $\usepattern$ to $\vpone$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vp$ is a pattern for testing the range of expressions from $\veone$ to $\vetwo$;
    \item define $\ids$ as the union of the application of $\useexpr$ to both $\veone$ and $\vetwo$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[mask\_all]{
  \astlabel(\vp) \in \{\PatternMask, \PatternAll\}
}{
  \usepattern(\vp) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{}{
  \usepattern(\overname{\PatternTuple(\vli)}{\vp}) \typearrow \overname{\bigcup_{\vpone\in\vli}\usepattern(\vpone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[any]{}{
  \usepattern(\overname{\PatternAny(\vli)}{\vp}) \typearrow \overname{\bigcup_{\vpone\in\vli}\usepattern(\vpone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[single]{}{
  \usepattern(\overname{\PatternSingle(\ve)}{\vp}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[geq]{}{
  \usepattern(\overname{\PatternGeq(\ve)}{\vp}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[leq]{}{
  \usepattern(\overname{\PatternLeq(\ve)}{\vp}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[not]{}{
  \usepattern(\overname{\PatternNot(\vpone)}{\vp}) \typearrow \overname{\usepattern(\vpone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{}{
  \usepattern(\overname{\PatternRange(\veone, \vetwo)}{\vp}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\section{TypingRule.UseSlice \label{sec:TypingRule.UseSlice}}
\hypertarget{def-useslice}{}
The function
\[
\useslice(\overname{\slice}{\vs}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the slice $\vs$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\vs$ is the slice at the position given by the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{start\_length\_rang}):
  \begin{itemize}
    \item $\vs$ is a slice given by the pair of expressions $\veone$ and $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to both $\veone$ and $\vetwo$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[single]{}{
  \useslice(\overname{\SliceSingle(\ve)}{\vs}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\and
\inferrule[star\_length\_range]{
  L \in \{\SliceStar, \SliceLength, \SliceRange\}
}{
  \useslice(\overname{L(\veone, \vetwo)}{\vs}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\section{TypingRule.UseBitfield \label{sec:TypingRule.UseBitfield}}
\hypertarget{def-usebitfield}{}
The function
\[
\usebitfield(\overname{\decl}{\vbf}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the bitfield $\vbf$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item $\vbf$ is the single field with slices $\slices$;
    \item define $\ids$ as the union of applying $\useslice$ to each slice in $\slices$.
  \end{itemize}

  \item All of the following apply (\textsc{nested}):
  \begin{itemize}
    \item $\vbf$ is the nested bitfield with slices $\slices$ and bitfields $\bitfields$;
    \item define $\ids$ as the union of applying $\useslice$ to each slice in $\slices$ and applying
          $\usebitfield$ to each bitfield in $\bitfields$.
  \end{itemize}

  \item All of the following apply (\textsc{type}):
  \begin{itemize}
    \item $\vbf$ is the typed bitfield with slices $\slices$ and type $\tty$;
    \item define $\ids$ as the union of applying $\useslice$ to each slice in $\slices$ and applying
          $\usety$ to $\tty$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[simple]{}{
  \usebitfield(\overname{\BitFieldSimple(\Ignore, \slices)}{\vbf}) \typearrow \overname{\bigcup_{\vs\in\slices}\useslice(\vs)}{\ids}
}
\and
\inferrule[nested]{
  \ids \eqdef \bigcup_{\bfone\in\bitfields}\usebitfield(\vs) \cup \bigcup_{\vs\in\slices}\useslice(\vs)
}{
  \usebitfield(\overname{\BitFieldNested(\Ignore, \slices, \bitfields)}{\vbf}) \typearrow \ids
}
\and
\inferrule[type]{
  \ids \eqdef \bigcup_{\vs\in\slices}\useslice(\vs) \cup \usety(\tty)
}{
  \usebitfield(\overname{\BitFieldType(\Ignore, \slices, \tty)}{\vbf}) \typearrow \ids
}
\end{mathpar}

\section{TypingRule.UseConstraint \label{sec:TypingRule.UseConstraint}}
\hypertarget{def-useconstraint}{}
The function
\[
\useconstraint(\overname{\intconstraint}{\vc}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the integer constraint $\vc$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is the single-value expression constraint with expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is the range constraint with expressions $\veone$ and $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to both $\veone$ and $\vetwo$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[exact]{}{
  \useconstraint(\overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\and
\inferrule[range]{}{
  \useconstraint(\overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\section{TypingRule.UseStmt \label{sec:TypingRule.UseStmt}}
\hypertarget{def-usestmt}{}
The function
\[
\usestmt(\overname{\stmt}{\vs}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the statement $\vs$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{pass\_return\_none\_throw\_none}):
  \begin{itemize}
    \item $\vs$ is either a pass statement $\SPass$, a return-nothing statement $\SReturn(\None)$,
          or a throw-nothing statement ($\SThrow(\None)$);
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{s\_seq}):
  \begin{itemize}
    \item $\vs$ is a sequencing statement for $\vsone$ and $\vstwo$;
    \item define $\ids$ as the union of applying $\usestmt$ to both $\vsone$ and $\vstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{assert\_return\_some}):
  \begin{itemize}
    \item $\vs$ is either an assertion with expression $\ve$ or a return statement with expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_assign}):
  \begin{itemize}
    \item $\vs$ is an assignment statement with left-hand-side $\vle$ and right-hand-side $\ve$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\vle$ and $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_call}):
  \begin{itemize}
    \item $\vs$ is a call statement for the subprogram with name $\vx$, arguments $\vargs$, and list of
          pairs consisting of a parameter identifier and associated expression $\namedargs$;
    \item define $\ids$ as the union of the singleton set for $\vx$, applying $\useexpr$ to
          every expression in $\vargs$ and applying $\useexpr$ to every expression associated with
          a parameter in $\namedargs$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_cond}):
  \begin{itemize}
    \item $\vs$ is the conditional statement with expression $\ve$ and statements $\vsone$ and $\vstwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and $\usestmt$ to both of $\vsone$ and $\vstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_case}):
  \begin{itemize}
    \item $\vs$ is the case statement with expression $\ve$ and case list $\vcases$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and $\usecase$ to every case in $\vcases$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_for}):
  \begin{itemize}
    \item $\vs$ is the for statement $\SFor\left\{\begin{array}{rcl}
      \Forindexname &:& \Ignore\\
      \Forstarte &:& \vstarte\\
      \fordirection &:& \vdirection\\
      \Forende &:& \vende\\
      \Forbody &:& \vbody\\
      \Forlimit &:& \vlimit
    \end{array}\right\}$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\vlimit$, $\vstarte$, and $\vende$ and applying $\usestmt$ to $\vsone$.
  \end{itemize}

  \item All of the following apply (\textsc{while\_repeat}):
  \begin{itemize}
    \item $\vs$ is either a while statement or repeat statement, each with expression $\ve$, body statement $\vsone$,
          and optional limit expression $\vlimit$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\vlimit$ and to $\ve$, and applying $\usestmt$ to $\vsone$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_decl}):
  \begin{itemize}
    \item $\vs$ is a declaration statement with local declaration item $\ldi$ and \optional\ initialization expression $\ve$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and $\useldi$ to $\ldi$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_try}):
  \begin{itemize}
    \item $\vs$ is a try statement with statement $\vsone$, catcher list $\catchers$, and otherwise statement $\vstwo$;
    \item define $\ids$ as the union of applying $\usestmt$ to both $\vsone$ and $\vstwo$ and $\usecatcher$ to
          every catcher in $\catchers$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_print}):
  \begin{itemize}
    \item $\vs$ is a print statement with list of expressions $\vargs$;
    \item define $\ids$ as the union of applying $\useexpr$ to each expression in $\vargs$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[pass\_return\_none\_throw\_none]{
  \vs = \SPass \lor \vs = \SReturn(\None) \lor \vs = \SThrow(\None)
}{
  \usestmt(\vs) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_seq]{}{
  \usestmt(\overname{\SSeq(\vsone, \vstwo)}{\vs}) \typearrow \overname{\usestmt(\vsone)\cup\usestmt(\vstwo)}{\ids}
}
\and
\inferrule[assert\_return\_some]{
  \vs = \SAssert(\ve) \lor \SReturn(\langle\ve\rangle)
}{
  \usestmt(\vs) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}

\inferrule[s\_assign]{}{
  \usestmt(\overname{\SAssign(\vle, \ve)}{\vs}) \typearrow \overname{\uselexpr(\vle) \cup \useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_call]{
  \ids \eqdef \{\vx\} \cup \bigcup_{\ve\in\vargs}\useexpr(\ve) \cup \bigcup_{(\Ignore, \ve)\in\namedargs} \useexpr(\ve)
}{
  \usestmt(\overname{\SCall(\vx, \vargs, \namedargs)}{\vs}) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_cond]{}{
  \usestmt(\overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \typearrow \overname{\useexpr(\ve) \cup \usestmt(\vsone) \cup \usestmt(\vstwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_case]{}{
  \usestmt(\overname{\SCase(\ve, \vcases)}{\vs}) \typearrow \overname{\useexpr(\ve) \cup \bigcup_{\vc\in\vcases}\usecase(\vc)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_for]{
  \ids \eqdef \useexpr(\vlimit) \cup \useexpr(\vstarte) \cup \useexpr(\vende) \cup \usestmt(\vbody)
}{
  {
  \usestmt\left(\overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \Ignore\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdirection\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \vlimit
  \end{array}\right\}}{\vs}\right) \typearrow \ids
  }
}
\and
\inferrule[while\_repeat]{
  \vs = \SWhile(\ve, \vlimit, \vs) \lor \vs = \SRepeat(\vs, \ve, \vlimit)
}{
  \usestmt(\vs) \typearrow \overname{\useexpr(\vlimit) \cup \useexpr(\ve) \cup \usestmt(\vsone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_decl]{}{
  \usestmt(\overname{\SDecl(\Ignore, \ldi, \ve)}\vs) \typearrow \overname{\useexpr(\ve) \cup \useldi(\ldi)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_throw\_some]{}{
  \usestmt(\overname{\SThrow(\langle(\ve, \Ignore)\rangle)}\vs) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_try]{
  \ids \eqdef \usestmt(\vsone) \cup \bigcup_{\vc\in\catchers}\usecatcher(\vc) \cup \usestmt(\vstwo)
}{
  \usestmt(\overname{\STry(\vsone, \catchers, \vstwo)}{\vs}) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_print]{}{
  \usestmt(\overname{\SPrint(\vargs)}{\vs}) \typearrow \overname{\bigcup_{\ve\in\vargs}\useexpr(\ve)}{\ids}
}
\end{mathpar}

\section{TypingRule.UseLDI \label{sec:TypingRule.UseLDI}}
\hypertarget{def-useldi}{}
The function
\[
\useldi(\overname{\localdeclitem}{\ldi}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the local declaration item $\ldi$ depends on.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{discard}):
  \begin{itemize}
    \item $\ldi$ is a discarding declaration;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{typed}):
  \begin{itemize}
    \item $\ldi$ is a typed declaration for the local declaration item $\ldione$ and type $\vt$;
    \item define $\ids$ as the union of applying $\useldi$ to $\ldione$ and $\usety$ to $\vt$.
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\ldi$ is a multi-variable declaration for the list of local declarations $\ldis$;
    \item define $\ids$ as the union of applying $\useldi$ to each local declaration item in $\ldis$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[discard]{}{
  \useldi(\overname{\LDIDiscard}{\ldi}) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[typed]{}{
  \useldi(\overname{\LDITyped(\ldione, \vt)}{\ldi}) \typearrow \overname{\useldi(\ldione) \cup \usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{}{
  \useldi(\overname{\LDITuple(\ldis)}{\ldi}) \typearrow \overname{\bigcup_{\ldione\in\ldis}\useldi(\ldione)}{\ids}
}
\end{mathpar}

\section{TypingRule.UseCase \label{sec:TypingRule.UseCase}}
\hypertarget{def-usecase}{}
The function
\[
\usecase(\overname{\casealt}{\vc}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the case alternative $\vc$ depends on.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vc$ is the case alternative for the pattern $\pattern$, \optional\ \texttt{where} expression
        $\veopt$ and \texttt{otherwise} statement $\vs$;
  \item define $\ids$ as the union of applying $\usepattern$ to $\pattern$, applying $\useexpr$ to $\veopt$,
        and applying $\usestmt$ to $\vs$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ids \eqdef \usepattern(\pattern) \cup \useexpr(\veopt) \cup \usestmt(\vs)
}{
  \usecase(\overname{\{ \CasePattern : \pattern, \CaseWhere : \veopt, \CaseStmt : \vs \}}{\vc}) \typearrow \ids
}
\end{mathpar}

\section{TypingRule.UseCatcher \label{sec:TypingRule.UseCatcher}}
\hypertarget{def-usecatcher}{}
The function
\[
\usecatcher(\overname{\catcher}{\vc}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the try statement catcher $\vc$ depends on.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vc$ is a case alternative with type $\tty$ and statement $\vs$;
  \item define $\ids$ as the union of applying $\usety$ to $\ty$ and applying $\usestmt$ to $\vs$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \usecatcher(\overname{(\Ignore, \tty, \vs)}{\vc}) \typearrow \overname{\usety(\tty) \cup \usestmt(\vs)}{\ids}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Static Evaluation \label{chap:staticevaluation}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we define how to statically evaluate a subset of expressions
and how to apply basic operators to literals via the following rules:
\begin{itemize}
  \item TypingRule.StaticEval (see \secref{TypingRule.StaticEval})
  \item TypingRule.UnopLiterals (see \secref{TypingRule.UnopLiterals})
  \item TypingRule.BinopLiterals (see \secref{TypingRule.BinopLiterals})
\end{itemize}
We also define the following helper rules:
\begin{itemize}
  \item TypingRule.SlicesToPositions (see \secref{TypingRule.SlicesToPositions})
  \item TypingRule.SliceToPositions (see \secref{TypingRule.SliceToPositions})
  \item TypingRule.EvalToInt (see \secref{TypingRule.EvalToInt})
  \item TypingRule.ExtractSlice (see \secref{TypingRule.ExtractSlice})
\end{itemize}

\hypertarget{def-unsupportedexpression}
In this chapter and the following ones, we use the special value $\CannotBeTransformed$
to represent a failure in transforming an expression into a desired form (the specific
desired form varies according to the functions utilizing this value).

\hypertarget{def-staticeval}{}
\section{TypingRule.StaticEval \label{sec:TypingRule.StaticEval}}
The function
\[
  \staticeval(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \;\aslto\;
  \overname{\literals}{\vv} \cup
  \{\CannotBeTransformed\}
  \overname{\TTypeError}{\TypeErrorConfig}
\]
evaluates an expression $\ve$, from a restricted subset of all expressions,
in the static environment $\tenv$, returning a literal $\vv$.
If $\ve$ is not in the restricted set of expressions or cannot be statically evaluated to a compile-time
constant, the result is $\CannotBeTransformed$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{e\_literal}):
  \begin{itemize}
    \item $\ve$ is the literal expression for the literal $\vv$, that is, $\ELiteral(\vv)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression with the identifier $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is bound to a constant in $\tenv$ via $\lookupconstant$ yields the literal $\vv$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_non\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression with the identifier $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is bound to a constant in $\tenv$ via $\lookupconstant$ yields $\bot$
          (that is, $\vx$ is not bound to a constant);
    \item checking whether $\vx$ is defined in $\tenv$ yields $\True$\ProseOrTypeError;
    \item the result is $\CannotBeTransformed$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop}):
  \begin{itemize}
    \item $\ve$ is a binary operation expression with operator $\op$ and operand expressions $\veone$ and $\vetwo$,
          that is, $\EBinop(\op, \veone, \vetwo)$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the literal $\vvone$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item applying $\staticeval$ to $\vetwo$ in $\tenv$ yields the literal $\vvtwo$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item applying $\op$ to $\vvone$ and $\vvtwo$ via $\binopliterals$ yields $\vv$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop}):
  \begin{itemize}
    \item $\ve$ is a unary operation expression with operator $\op$ and operand expression $\veone$,
          that is, $\EUnop(\op, \veone)$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the literal $\vvone$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item applying $\op$ to $\vvone$ via $\unopliterals$ yields $\vv$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice\_int}):
  \begin{itemize}
    \item $\ve$ is a slicing expression of the integer literal for $\vi$ and slice list $\vslices$, that is,
          $\ESlice(\lint(\vi), \vslices)$;
    \item obtaining the indices of the slice list $\vslices$ in $\tenv$ via $\slicestopositions$
          yields $\positions$\ProseOrTypeError;
    \item $\posmax$ is the maximum index in $\positions$;
    \item converting the first $\posmax+1$ digits of the binary representation of $\vi$ into a bitvector
          via $\inttobits$ yields $\bvone$;
    \item extracting the slice of $\bvone$ given by $\positions$ yields $\bvtwo$\ProseOrTypeError;
    \item $\vv$ is the bitvector literal for $\bvtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice\_bitvector}):
  \begin{itemize}
    \item $\ve$ is a slicing expression of the bitvector literal for $\bv$ and slice list $\vslices$, that is,
          $\ESlice(\lbitvector(\bv), \vslices)$;
    \item obtaining the indices of the slice list $\vslices$ in $\tenv$ via $\slicestopositions$
          yields $\positions$\ProseOrTypeError;
    \item $\posmax$ is the maximum index in $\positions$;
    \item checking that the length of $\bv$ is greater than $\posmax$ (which is $0$-based) yields $\True$\ProseOrTypeError;
    \item extracting the slice of $\bv$ given by $\positions$ yields $\bvtwo$\ProseOrTypeError;
    \item $\vv$ is the bitvector literal for $\bvtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice\_type\_error}):
  \begin{itemize}
    \item $\ve$ is a slicing expression of subexpression $\veone$ and slice list $\vslices$, that is, $\ESlice(\veone, \vslices)$;
    \item $\veone$ is neither an integer literal nor a bitvector literal;
    \item the result is a type error indicating that either an integer literal or a bitvector literal were expected.
  \end{itemize}

  \item All of the following apply (\textsc{e\_cond}):
  \begin{itemize}
    \item $\ve$ is a conditional expression with condition subexpression $\econd$ and subexpressions $\veone$ (true case)
          and $\vetwo$ (false case), that is, $\ECond(\econd, \veone, \vetwo)$;
    \item evaluating $\econd$ in $\tenv$ either yields a Boolean literal $\vb$ or a type error or $\CannotBeTransformed$,
          either of which short-circuits the rule;
    \item $\vep$ is $\veone$ if $\vb$ is $\True$ and $\vetwo$ otherwise;
    \item the result is given by applying $\staticeval$ to $\vep$ in $\tenv$.
  \end{itemize}

  \item All of the following apply (\textsc{unsupported}):
  \begin{itemize}
    \item $\ve$ is an expression that is not one of the following: a literal, a variable, a binary operation expression,
          a unary operation expression, a slice expression, and a conditional expression;
    \item the result is a type error indicating that $\ve$ is not an expression that is supported
          for static evaluation.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[e\_literal]{}
{
  \staticeval(\tenv, \overname{\ELiteral(\vv)}{\ve}) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_constant]{
  \lookupconstant(\tenv, \vx) \typearrow \vv
}{
  \staticeval(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vv
}
\and
\inferrule[e\_var\_non\_constant]{
  \lookupconstant(\tenv, \vx) \typearrow \bot\\
  \isundefined(\tenv, \vx) \typearrow \vb\\
  \checktrans{\neg\vb}{\UndefinedIdentifier} \typearrow \True \OrTypeError
}{
  \staticeval(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \CannotBeTransformed
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{
  \staticeval(\tenv, \veone) \typearrow \vvone \terminateas \TypeErrorConfig, \CannotBeTransformed\\\\
  \staticeval(\tenv, \vetwo) \typearrow \vvtwo \terminateas \TypeErrorConfig, \CannotBeTransformed\\\\
  \binopliterals(\op, \vvone, \vvtwo) \typearrow \vv \OrTypeError
}{
  \staticeval(\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{
  \staticeval(\tenv, \veone) \typearrow \vvone \terminateas \TypeErrorConfig, \CannotBeTransformed\\\\
  \unopliterals(\op, \vvone) \typearrow \vv \OrTypeError
}{
  \staticeval(\tenv, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice\_int]{
  \slicestopositions(\tenv, \slices) \typearrow \positions \OrTypeError\\\\
  \posmax \eqdef \max(\positions)\\
  \bvone \eqdef \inttobits(\vi, \posmax + 1)\\
  \extractslice(\bvone, \positions) \typearrow \bvtwo \OrTypeError
}{
  \staticeval(\tenv, \overname{\ESlice(\lint(\vi), \slices)}{\ve}) \typearrow \overname{\lbitvector(\bvtwo)}{\vv}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice\_bitvector]{
  \slicestopositions(\tenv, \slices) \typearrow \positions \OrTypeError\\\\
  \posmax \eqdef \max(\positions)\\
  \checktrans{\listlen{\bv} > \posmax}{SliceOutOfRange} \checktransarrow \True \OrTypeError\\\\
  \extractslice(\bv, \positions) \typearrow \bvtwo \OrTypeError
}{
  \staticeval(\tenv, \overname{\ESlice(\lbitvector(\bv), \slices)}{\ve}) \typearrow \overname{\lbitvector(\bvtwo)}{\vv}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice\_type\_error]{
  \astlabel(\veone) \not\in \{\lint, \lbitvector\}
}{
  \staticeval(\tenv, \overname{\ESlice(\veone, \slices)}{\ve}) \typearrow \TypeErrorVal{TypeMismatch}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{
  \staticeval(\tenv, \econd) \typearrow \vcond \terminateas \TypeErrorConfig, \CannotBeTransformed\\\\
  \vcond \eqname \lbool(\vb)\\
  \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\
  \staticeval(\tenv, \vep) \typearrow \vv \terminateas \TypeErrorConfig, \CannotBeTransformed
}{
  \staticeval(\tenv, \overname{\ECond(\econd, \veone, \vetwo)}{\ve}) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[unsupported]{
  \astlabel(\ve) \not\in \{ \ELiteral, \EVar, \EBinop, \EUnop, \ESlice, \ECond\}
}{
  \staticeval(\tenv, \ve) \typearrow \TypeErrorVal{UnsupportedExpression}
}
\end{mathpar}

\section{TypingRule.UnopLiterals \label{sec:TypingRule.UnopLiterals}}
\hypertarget{def-unopliterals}{}
The function
\[
  \unopliterals(\overname{\unop}{\op} \aslsep \overname{\literals}{\vl}) \aslto
  \overname{\literals}{\vr} \cup \TTypeError
\]
statically evaluates a unary operator $\op$ (a terminal derived from the AST non-terminal for unary operators)
over a literal $\vl$ and returns the resulting literal $\vr$.
\ProseOtherwiseTypeError

\hypertarget{def-unopsignatures}{}
The following set of unary operator types and argument types defines the correct argument type
for a given unary operator:
\[
\unopsignatures \triangleq
\left\{
\begin{array}{lcll}
  (\NEG   &,& \lint)        &,\\
  (\NEG   &,& \lreal)       &,\\
  (\BNOT  &,& \lbool)       &,\\
  (\NOT   &,& \lbitvector)  &\\
\end{array}
\right\}
\]

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $(\op, \astlabel(\vl))$ is not in $\unopsignatures$;
    \item the result is a type error indicating that the combination of $\op$ and $\astlabel(\vl)$
          is not legal.
  \end{itemize}

  \item All of the following apply (\textsc{negate\_int}):
  \begin{itemize}
    \item $\op$ is $\NEG$ and $\vl$ is an integer literal for $\vn$;
    \item define $\vr$ as the integer literal for $- \vn$.
  \end{itemize}

  \item All of the following apply (\textsc{negate\_real}):
  \begin{itemize}
    \item $\op$ is $\NEG$ and $\vl$ is a real literal for $\vq$;
    \item define $\vr$ as the real literal for $- \vq$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_bool}):
  \begin{itemize}
    \item $\op$ is $\BNOT$ and $\vl$ is a Boolean literal for $\vb$;
    \item define $\vr$ as the Boolean literal for $\neg\vq$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_bits\_empty}, \textsc{not\_bits\_empty}):
  \begin{itemize}
    \item $\op$ is $\NOT$ and $\vl$ is a bitvector literal for the sequence of bits $\bits$;
    \item $\vc$ is the sequence of bits of the same length as $\bits$ where in each position
          the bit in $\vr$ is defined as the negation of the bit of $\bits$ in the same position;
    \item define $\vr$ as the bitvector literal for $\vc$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[error]{
  (\op, \vl) \not\in \unopsignatures
}{
  \unopliterals(\op, \astlabel(\vl)) \typearrow \TypeErrorVal{TypeMismatch}
}
\and
\inferrule[negate\_int]{}{
  \unopliterals(\overname{\NEG}{\op}, \overname{\lint(n)}{\vl}) \typearrow \overname{\lint(- n)}{\vr}
}
\and
\inferrule[negate\_real]{}{
  \unopliterals(\overname{\NEG}{\op}, \overname{\lreal(q)}{\vl}) \typearrow \overname{\lreal(- q)}{\vr}
}
\and
\inferrule[not\_bool]{}{
  \unopliterals(\overname{\BNOT}{\op}, \overname{\lbool(b)}{\vl}) \typearrow \overname{\lbool(\neg b)}{\vr}
}
\and
\inferrule[not\_bits\_empty]{
  \bits \eqname \emptylist\\
  c \eqdef \emptylist
}{
  \unopliterals(\overname{\NOT}{\op}, \overname{\lbitvector(\bits)}{\vl}) \typearrow\overname{\lbitvector(c)}{\vr}
}
\and
\inferrule[not\_bits\_not\_empty]{
  \bits \eqname \vb_{1..k}\\
  c \eqdef [i=1..k: (1-\vb_\vi)]
}{
  \unopliterals(\overname{\NOT}{\op}, \overname{\lbitvector(\bits)}{\vl}) \typearrow\overname{\lbitvector(c)}{\vr}
}
\end{mathpar}

\section{TypingRule.BinopLiterals \label{sec:TypingRule.BinopLiterals}}
\hypertarget{def-binopliterals}{}
The function
\[
  \binopliterals(\overname{\binop}{\op} \aslsep \overname{\literals}{\vvone} \aslsep \overname{\literals}{\vvtwo}) \aslto
  \overname{\literals}{\vr} \cup \TTypeError
\]
statically evaluates a binary operator $\op$ (a terminal derived from the AST non-terminal for binary operators)
over a pair of literals $\vlone$ and $\vltwo$
and returns the resulting literal $\vr$.
The result is a type error, if it is illegal to apply the operator
to the given values, or a different kind of type error is detected.

\hypertarget{def-binopsignatures}{}
The following set of binary operator types and argument types defines the correct
argument types for a given binary operator:
\[
\binopsignatures \triangleq
\left\{
\begin{array}{lclcll}
  (\PLUS      &,& \lint &,& \lint)&,\\
  (\MINUS     &,& \lint &,& \lint)&,\\
  (\MUL       &,& \lint &,& \lint)&,\\
  (\DIV       &,& \lint &,& \lint)&,\\
  (\DIVRM     &,& \lint &,& \lint)&,\\
  (\MOD       &,& \lint &,& \lint)&,\\
  (\POW       &,& \lint &,& \lint)&,\\
  (\SHL       &,& \lint &,& \lint)&,\\
  (\SHR       &,& \lint &,& \lint)&,\\
  (\EQOP      &,& \lint &,& \lint)&,\\
  (\NEQ       &,& \lint &,& \lint)&,\\
  (\LEQ       &,& \lint &,& \lint)&,\\
  (\LT        &,& \lint &,& \lint)&,\\
  (\GEQ       &,& \lint &,& \lint)&,\\
  (\GT        &,& \lint &,& \lint)&,\\
  (\BAND      &,& \lbool &,& \lbool)&,\\
  (\BOR       &,& \lbool &,& \lbool)&,\\
  (\IMPL      &,& \lbool &,& \lbool)&,\\
  (\EQOP      &,& \lbool &,& \lbool)&,\\
  (\NEQ       &,& \lbool &,& \lbool)&,\\
  (\PLUS      &,& \lreal &,& \lreal)&,\\
  (\MINUS     &,& \lreal &,& \lreal)&,\\
  (\MUL       &,& \lreal &,& \lreal)&,\\
  (\RDIV      &,& \lreal &,& \lreal)&,\\
  (\POW       &,& \lreal &,& \lint)&,\\
  (\EQOP      &,& \lreal &,& \lreal)&,\\
  (\NEQ       &,& \lreal &,& \lreal)&,\\
  (\LEQ       &,& \lreal &,& \lreal)&,\\
  (\LT        &,& \lreal &,& \lreal)&,\\
  (\GEQ       &,& \lreal &,& \lreal)&,\\
  (\GT        &,& \lreal &,& \lreal)&,\\
  (\EQOP      &,& \lbitvector &,& \lbitvector)&,\\
  (\NEQ       &,& \lbitvector &,& \lbitvector)&,\\
  (\OR        &,& \lbitvector &,& \lbitvector)&,\\
  (\AND       &,& \lbitvector &,& \lbitvector)&,\\
  (\EOR       &,& \lbitvector &,& \lbitvector)&,\\
  (\MINUS     &,& \lbitvector &,& \lbitvector)&,\\
  (\PLUS      &,& \lbitvector &,& \lbitvector)&,\\
  (\MINUS     &,& \lbitvector &,& \lint)&,\\
  (\PLUS      &,& \lbitvector &,& \lint)&\\
\end{array}
\right\}
\]

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $(\op, \astlabel(\vlone), \astlabel(\vltwo))$ is not included in $\binopsignatures$;
    \item the result is a type error indicating the $\op$ cannot be applied to the arguments
          with the types given by $\astlabel(\vlone)$ and $\astlabel(\vltwo)$.
  \end{itemize}

  \item All of the following apply (\textsc{add\_int}):
  \begin{itemize}
    \item $\op$ is $\PLUS$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal integer for $a+b$.
  \end{itemize}

  \item All of the following apply (\textsc{sub\_int}):
  \begin{itemize}
    \item $\op$ is $\MINUS$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal integer for $a-b$.
  \end{itemize}

  \item All of the following apply (\textsc{mul\_int}):
  \begin{itemize}
    \item $\op$ is $\MUL$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal integer for $a\times b$.
  \end{itemize}

  \item All of the following apply (\textsc{div\_int}):
  \begin{itemize}
    \item $\op$ is $\DIV$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is positive yields $\True$\ProseOrTypeError;
    \item define $n$ as $a$ divided by $b$ (note that $n$ is potentially a fraction);
    \item checking that $n$ is an integer yields $\True$\ProseOrTypeError;
    \item define $\vr$ as the literal integer for $a\div b$.
  \end{itemize}

  \item All of the following apply (\textsc{fdiv\_int}):
  \begin{itemize}
    \item $\op$ is $\DIVRM$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is positive yields $\True$\ProseOrTypeError;
    \item define $n$ as $a$ divided by $b$, rounded down (if $a$ is negative, $n$ is rounded down towards infinity);
    \item define $\vr$ as the literal integer for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{frem\_int}):
  \begin{itemize}
    \item $\op$ is $\MOD$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item applying $\binopliterals$ to $\DIVRM$ with $\vlone$ and $\vltwo$ yields $c$\ProseOrTypeError;
    \item define $n$ as $a-c$;
    \item define $\vr$ as the literal integer for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_int}):
  \begin{itemize}
    \item $\op$ is $\POW$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item define $n$ as $a^b$;
    \item define $\vr$ as the literal integer for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{shl}):
  \begin{itemize}
    \item $\op$ is $\SHL$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item applying $\binopliterals$ to $\POW$ with $2$ and $\vltwo$ yields the literal integer for $e$;
    \item applying $\binopliterals$ to $\MUL$ with $2$ and the literal integer for $e$ yields $\vr$.
  \end{itemize}

  \item All of the following apply (\textsc{shr}):
  \begin{itemize}
    \item $\op$ is $\SHR$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item applying $\binopliterals$ to $\POW$ with $2$ and $\vltwo$ yields the literal integer for $e$;
    \item applying $\binopliterals$ to $\DIVRM$ with $2$ and the literal integer for $e$ yields $\vr$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_int}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{ne\_int}):
  \begin{itemize}
    \item $\op$ is $\NEQ$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is different from $b$ holds.
  \end{itemize}

  \item All of the following apply (\textsc{le\_int}):
  \begin{itemize}
    \item $\op$ is $\LEQ$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than or equal to $b$s.
  \end{itemize}

  \item All of the following apply (\textsc{lt\_int}):
  \begin{itemize}
    \item $\op$ is $\LT$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than $b$s.
  \end{itemize}

  \item All of the following apply (\textsc{ge\_int}):
  \begin{itemize}
    \item $\op$ is $\GEQ$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater or equal than $b$s.
  \end{itemize}

  \item All of the following apply (\textsc{gt\_int}):
  \begin{itemize}
    \item $\op$ is $\GT$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater than $b$s.
  \end{itemize}

  \item All of the following apply (\textsc{and\_bool}):
  \begin{itemize}
    \item $\op$ is $\BAND$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if both $a$ and $b$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{or\_bool}):
  \begin{itemize}
    \item $\op$ is $\BOR$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if one of $a$ and $b$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{implies\_bool}):
  \begin{itemize}
    \item $\op$ is $\IMPL$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if one of $a$ is $\False$ or $b$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_bool}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if one of $a$ is equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{ne\_bool}):
  \begin{itemize}
    \item $\op$ is $\NEQ$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if one of $a$ is different from $b$.
  \end{itemize}

  \item All of the following apply (\textsc{add\_real}):
  \begin{itemize}
    \item $\op$ is $\PLUS$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the real literal for $a + b$.
  \end{itemize}

  \item All of the following apply (\textsc{sub\_real}):
  \begin{itemize}
    \item $\op$ is $\MINUS$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the real literal for $a - b$.
  \end{itemize}

  \item All of the following apply (\textsc{mul\_real}):
  \begin{itemize}
    \item $\op$ is $\MUL$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the real literal for $a \times b$.
  \end{itemize}

  \item All of the following apply (\textsc{div\_real}):
  \begin{itemize}
    \item $\op$ is $\RDIV$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item checking whether $b$ is different from $0$ yields $\True$\ProseOrTypeError;
    \item define $\vr$ as the real literal for $a \div b$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_real}):
  \begin{itemize}
    \item $\op$ is $\POW$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the real literal for $a^b$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_real}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{ne\_real}):
  \begin{itemize}
    \item $\op$ is $\NEQ$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is different from $b$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_real}):
  \begin{itemize}
    \item $\op$ is $\LEQ$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than or equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{lt\_real}):
  \begin{itemize}
    \item $\op$ is $\LT$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than $b$.
  \end{itemize}

  \item All of the following apply (\textsc{ge\_real}):
  \begin{itemize}
    \item $\op$ is $\GEQ$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater than or equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{gt\_real}):
  \begin{itemize}
    \item $\op$ is $\GT$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater than $b$.
  \end{itemize}

  \item All of the following apply (\textsc{bitwise\_different\_bitwidths}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is a bitvector literal for $b$;
    \item the lengths of $a$ and $b$ are different;
    \item the result is a type error indicating that the bitvectors must be of the same width.
  \end{itemize}

  \item All of the following apply (\textsc{bitwise\_empty}):
  \begin{itemize}
    \item $\vvone$ is the empty bitvector literal;
    \item $\vvtwo$ is the empty bitvector literal;
    \item $\op$ is one of $\OR$, $\AND$, $\EOR$, $\PLUS$, or $\MINUS$;
    \item define $\vr$ as the empty bitvector literal.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_bits\_empty}):
  \begin{itemize}
    \item $\vvone$ is the empty bitvector literal;
    \item $\vvtwo$ is the empty bitvector literal;
    \item $\op$ is $\EQOP$;
    \item define $\vr$ as the Boolean literal for $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_bits\_not\_empty}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\EQOP$;
    \item define $\vb$ as $\True$ if and only if $a_i$ is equal to $b_i$, for $i=1..k$;
    \item define $\vr$ as the Boolean literal for $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{ne\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is a bitvector literal for $b$;
    \item $\op$ is $\EQOP$;
    \item applying $\binopliterals$ to $\NEQ$ for $\vvone$ and $\vvtwo$ yields the Boolean literal for $\vb$\ProseOrTypeError;
    \item define $\vr$ as the Boolean literal for $\neg\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{or\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\OR$;
    \item define $c_i$ as the maximum of $a_i$ and $b_i$ for $i=1..k$;
    \item define $\vr$ as the bitvector literal for $c_{1..k}$.
  \end{itemize}

  \item All of the following apply (\textsc{and\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\OR$;
    \item define $c_i$ as the minimum of $a_i$ and $b_i$ for $i=1..k$;
    \item define $\vr$ as the bitvector literal for $c_{1..k}$.
  \end{itemize}

  \item All of the following apply (\textsc{xor\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\OR$;
    \item define $c_i$ as $1$ if $a_i$ is different from $b_i$ and $0$ otherwise, for $i=1..k$;
    \item define $\vr$ as the bitvector literal for $c_{1..k}$.
  \end{itemize}

  \item All of the following apply (\textsc{add\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\PLUS$;
    \item define $a$ as the natural number represented by $a_{1..k}$;
    \item define $b$ as the natural number represented by $b_{1..k}$;
    \item define $c$ as the two's complement little endian representation of $a+b$ in $k$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item All of the following apply (\textsc{sub\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\PLUS$;
    \item define $a$ as the natural number represented by $a_{1..k}$;
    \item define $b$ as the natural number represented by $b_{1..k}$;
    \item define $c$ as the two's complement little endian representation of $a-b$ in $k$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item All of the following apply (\textsc{add\_bits\_int}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is an integer literal for $b$;
    \item $\op$ is $\PLUS$;
    \item define $y$ as the natural number represented by $a$;
    \item define $c$ as the two's complement little endian representation of $y+b$ in $\listlen{a}$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item All of the following apply (\textsc{sub\_bits\_int}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is an integer literal for $b$;
    \item $\op$ is $\MINUS$;
    \item define $y$ as the natural number represented by $a$;
    \item define $c$ as the two's complement little endian representation of $y-b$ in $\listlen{a}$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}
\end{itemize}

\subsection{Formally}

\begin{mathpar}
\inferrule[error]{
  (\op, \astlabel(\vlone), \astlabel(\vltwo)) \not\in \binopsignatures
}{
  \binopliterals(\op, \overname{\vlone}{\vvone}, \overname{\vltwo}{\vvtwo}) \typearrow \TypeErrorVal{TypeMismatch}
}
\end{mathpar}

\subsubsection{Arithmetic Operators Over Integer Values \label{sec:AthimeticOverInt}}
\begin{mathpar}
\inferrule[add\_int]{}{
  \binopliterals(\overname{\PLUS}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a + b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_int]{}{
  \binopliterals(\overname{\MINUS}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a - b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul\_int]{}{
  \binopliterals(\overname{\MUL}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a \times b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_int]{
  \checktrans{b > 0}{DIV\_DenominatorNegative} \checktransarrow \True \OrTypeError\\\\
  n \eqdef a \div b \\\\
  \checktrans{n \in \Z}{DIVInt\_Indivisibile} \checktransarrow \True \OrTypeError
}{
  \binopliterals(\overname{\DIV}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(n)}{\vr}
}
\and
\inferrule[fdiv\_int]{
  \checktrans{b > 0}{FDIV\_DenominatorNegative} \checktransarrow \True \OrTypeError\\\\
  n \eqdef \choice{a \geq 0}{\lfloor a \div b \rfloor}{-(\lceil (-a) \div b \rceil)}
}{
  \binopliterals(\overname{\DIVRM}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(n)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[frem\_int]{
  \binopliterals(\DIVRM, \lint(a), \lint(b)) \typearrow \lint(c) \OrTypeError
}{
  \binopliterals(\overname{\MOD}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a - (c \times b))}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_int]{
  \checktrans{b \geq 0}{ExponentNegative} \checktransarrow \True \OrTypeError
}{
  \binopliterals(\overname{\POW}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a^b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[shl]{
  \checktrans{b \geq 0}{ShifterNegative} \checktransarrow \True \OrTypeError\\\\
  \binopliterals(\POW, \lint(2), \lint(b)) \typearrow \lint(e)\\
  \binopliterals(\MUL, \lint(a), \lint(e)) \typearrow \vr
}{
  \binopliterals(\overname{\SHL}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \vr
}
\end{mathpar}

\begin{mathpar}
\inferrule[shr]{
  \checktrans{b \geq 0}{ShifterNegative} \checktransarrow \True \OrTypeError\\\\
  \binopliterals(\POW, \lint(2), \lint(b)) \typearrow \lint(e)\\
  \binopliterals(\DIVRM, \lint(a), \lint(e)) \typearrow \vr
}{
  \binopliterals(\overname{\SHR}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \vr
}
\end{mathpar}

\subsubsection{Relational Operators Over Integer Values \label{sec:RelationalOverInt}}
\begin{mathpar}
\inferrule[eq\_int]{}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_int]{}{
  \binopliterals(\overname{\NEQ}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a \neq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_int]{}{
  \binopliterals(\overname{\LEQ}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a \leq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[lt\_int]{}{
  \binopliterals(\overname{\LT}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a < b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ge\_int]{}{
  \binopliterals(\overname{\GEQ}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a \geq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[gt\_int]{}{
  \binopliterals(\overname{\GT}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a > b)}{\vr}
}
\end{mathpar}

\subsubsection{Boolean Operators Over Boolean Values \label{sec:BooleanOverBoolean}}
\begin{mathpar}
\inferrule[and\_bool]{}{
  \binopliterals(\overname{\BAND}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(a \wedge b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[or\_bool]{}{
  \binopliterals(\overname{\BOR}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(a \vee b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[implies\_bool]{}{
  \binopliterals(\overname{\IMPL}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(\neg a \vee b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_bool]{}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_bool]{}{
  \binopliterals(\overname{\NEQ}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(a \neq b)}{\vr}
}
\end{mathpar}

\subsubsection{Arithmetic Operators Over Real Values \label{sec:AthimeticOverReal}}
\begin{mathpar}
\inferrule[add\_real]{}{
  \binopliterals(\overname{\PLUS}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lreal(a+b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_real]{}{
  \binopliterals(\overname{\MINUS}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lreal(a-b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul\_real]{}{
  \binopliterals(\overname{\MUL}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lreal(a\times b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_real]{
  \checktrans{b \neq 0}{RDIV\_DenominatorZero} \checktransarrow \True \OrTypeError
}{
  \binopliterals(\overname{\RDIV}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lreal(a\div b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_real]{}{
  \binopliterals(\overname{\POW}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lreal(a^b)}{\vr}
}
\end{mathpar}

\subsubsection{Relational Operators Over Real Values \label{sec:RealtionalOverReal}}
\begin{mathpar}
\inferrule[eq\_real]{}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_real]{}{
  \binopliterals(\overname{\NEQ}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a \neq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_real]{}{
  \binopliterals(\overname{\LEQ}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a \leq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[lt\_real]{}{
  \binopliterals(\overname{\LT}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a < b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ge\_real]{}{
  \binopliterals(\overname{\GEQ}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a \geq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[gt\_real]{}{
  \binopliterals(\overname{\GT}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a > b)}{\vr}
}
\end{mathpar}

\subsection{Operators Over Bitvectors \label{sec:BitvectorOperations}}
\hypertarget{def-bintounsigned}{}
The function $\bintounsigned : \{0,1\}^* \rightarrow \N$ converts a non-empty sequence of bits
into a natural number:
\[
  \bintounsigned(a_{n..1}) \triangleq \sum_{i=1}^n a_i \cdot 2^{a_i}
\]
and an empty sequence of bits into $0$:
\[
  \bintounsigned(\emptylist) \triangleq 0 \enspace.
\]

\hypertarget{def-inttobits}{}
The function $\inttobits : \overname{\Z}{\texttt{val}} \times \overname{\Z}{\texttt{width}} \rightarrow \{0,1\}^*$
converts an integer \texttt{val} to its two's complement little endian representation
of \texttt{width} bits.

\begin{mathpar}
\inferrule[bitwise\_different\_bitwidths]{
  \listlen{a} \neq \listlen{b}
}{
  \binopliterals(\op, \overname{\lbitvector(a)}{\vvone}, \overname{\lbitvector(b)}{\vvtwo}) \typearrow
  \TypeErrorVal{\RequireSameBitwidths}
}
\and
\inferrule[bitwise\_empty]{
  \op \in \{\OR, \AND, \EOR, \PLUS, \MINUS\}
}{
  \binopliterals(\op, \overname{\lbitvector(\emptylist)}{\vvone}, \overname{\lbitvector(\emptylist)}{\vvtwo}) \typearrow
  \overname{\lbitvector(\emptylist)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_bits\_empty]{}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lbitvector(\emptylist)}{\vvone}, \overname{\lbitvector(\emptylist)}{\vvtwo}) \typearrow
  \overname{\lbool(\True)}{\vr}
}
\and
\inferrule[eq\_bits\_not\_empty]{
  \vb \eqdef \bigwedge_{i=1}^k a_i = b_i
}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow
  \overname{\lbool(\vb)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_bits]{
  \binopliterals(\EQOP, \lbitvector(a), \lbitvector(b)) \typearrow \lbool(\vb) \OrTypeError
}{
  \binopliterals(\overname{\NEQ}{\op}, \overname{\lbitvector(a)}{\vvone}, \overname{\lbitvector(b)}{\vvtwo}) \typearrow \lbool(\neg\vb)
}
\end{mathpar}

\begin{mathpar}
\inferrule[or\_bits]{
  i=1..k: c_i = \max(a_i, b_i)
}{
  \binopliterals(\overname{\OR}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \lbitvector(c_{1..k})
}
\end{mathpar}

\begin{mathpar}
\inferrule[and\_bits]{
  i=1..k: c_i = \min(a_i, b_i)
}{
  \binopliterals(\overname{\AND}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \lbitvector(c_{1..k})
}
\end{mathpar}

\begin{mathpar}
\inferrule[xor\_bits]{
  {
    \textit{xor\_bit} = \lambda a,b\in\{0,1\}.\ \left\{
      \begin{array}{ll}
        0 & \text{ if } a = b\\
        1 & \text{ otherwise}
      \end{array}
    \right.
  }\\
  i=1..k: c_i=\textit{xor\_bit}(a_i, b_i)
}{
  \binopliterals(\overname{\EOR}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \lbitvector(c_{1..k})
}
\end{mathpar}

\begin{mathpar}
\inferrule[add\_bits]{
  a \eqdef \bintounsigned(a_{1..k})\\
  b \eqdef \bintounsigned(b_{1..k})\\
  c \eqdef \inttobits(a + b, k)
}{
  \binopliterals(\overname{\PLUS}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \overname{\lbitvector(c)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_bits]{
  a \eqdef \bintounsigned(a_{1..k})\\
  b \eqdef \bintounsigned(b_{1..k})\\
  c \eqdef \inttobits(a - b, k)
}{
  \binopliterals(\overname{\MINUS}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \overname{\lbitvector(c)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[add\_bits\_int]{
  y \eqdef \bintounsigned(a)\\
  c \eqdef \inttobits(y + b, \listlen{a})
}{
  \binopliterals(\overname{\PLUS}{\op}, \overname{\lbitvector(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbitvector(c)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_bits\_int]{
  y \eqdef \bintounsigned(a)\\
  c \eqdef \inttobits(y - b, \listlen{a})
}{
  \binopliterals(\overname{\MINUS}{\op}, \overname{\lbitvector(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbitvector(c)}{\vr}
}
\end{mathpar}

\section{TypingRule.SlicesToPositions \label{sec:TypingRule.SlicesToPositions}}
\hypertarget{def-slicestopositions}{}
The function
\[
  \slicestopositions(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slices}) \aslto
  \overname{\Z^*}{\positions} \cup \{\CannotBeTransformed\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
transforms the list of slices $\slices$ in $\tenv$ into a list of indices $\positions$.
The result is $\CannotBeTransformed$ if $\slices$ cannot be statically evaluated to
a list of positions.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\slices$ is the empty list;
    \item $\positions$ is the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item \view\ $\slices$ as the list with $\vs$ as its \head\ and $\slicesone$ as its \tail;
    \item applying $\slicetopositions$ to $\vs$ in $\tenv$ yields the list of positions \\
          $\positionsone$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item transforming $\slicesone$ to a list of positions in $\tenv$ via $\slicestopositions$ yields
          $\positionstwo$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item $\positions$ is the concatenation of $\positionsone$ and $\positionstwo$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \slicestopositions(\tenv, \overname{\emptylist}{\slices}) \typearrow \overname{\emptylist}{\positions}
}
\and
\inferrule[non\_empty]{
  \slicetopositions(\tenv, \vs) \typearrow \positionsone \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \slicestopositions(\tenv, \slicesone) \typearrow \positionstwo \terminateas \CannotBeTransformed,\TypeErrorConfig
}{
  \slicestopositions(\tenv, \overname{[\vs] \concat \slicesone}{\slices}) \typearrow \overname{\positionsone \concat \positionstwo}{\positions}
}
\end{mathpar}

\section{TypingRule.SliceToPositions \label{sec:TypingRule.SliceToPositions}}
\hypertarget{def-slicetopositions}{}
The function
\[
  \slicetopositions(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\vs}) \aslto
  \overname{\Z^+}{\positions} \cup \{\CannotBeTransformed\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
transforms a slice $\vs$ in $\tenv$ into a list of indices $\positions$.
The result is $\CannotBeTransformed$ if $\slices$ cannot be statically evaluated to
a list of positions.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\vs$ is a slice for a single position given by the expression $\ve$, that is, \\ $\SliceSingle(\ve)$;
    \item applying $\evaltoint$ to $\ve$ in $\tenv$ yields the integer $n$\ProseOrTypeError;
    \item checking that $n$ is non-negative yields $\True$\ProseOrTypeError;
    \item $\positions$ is the list containing the single element $n$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vs$ is a slice for a range given by the expression $\etop$
          for the top position and $\ebot$ for the bottom position, that is, \\ $\SliceRange(\etop, \ebot)$;
    \item applying $\evaltoint$ to $\ebot$ in $\tenv$ yields the integer $b$\ProseOrTypeError;
    \item applying $\evaltoint$ to $\etop$ in $\tenv$ yields the integer $t$\ProseOrTypeError;
    \item checking that $t$ is greater or equal to $b$ and that $b$ is greater or equal to $0$ yields $\True$\ProseOrTypeError;
    \item $\positions$ is the list of integers from $t$ down to $b$, inclusive.
  \end{itemize}

  \item All of the following apply (\textsc{length}):
  \begin{itemize}
    \item $\vs$ is a slice for a length slice given by the expression $\ebot$
          for the bottom position and $\elength$ for the length of the slice, that is, \\ $\SliceLength(\ebot, \elength)$;
    \item applying $\evaltoint$ to $\ebot$ in $\tenv$ to an integer yields the integer $b$\ProseOrTypeError;
    \item applying $\evaltoint$ to $\elength$ in $\tenv$ to an integer yields the integer $l$\ProseOrTypeError;
    \item $t$ is $b + l - 1$;
    \item checking that $t$ is greater or equal to $b$ and that $b$ is greater or equal to $0$ yields $\True$\ProseOrTypeError;
    \item $\positions$ is the list of integers from $t$ down to $b$, inclusive.
  \end{itemize}

  \item All of the following apply (\textsc{star}):
  \begin{itemize}
    \item $\vs$ is a slice for a scaled slice given by the expression $\efactor$
          for the factor and $\elength$ for the length of the slice (\texttt{$\elength$*:$\efactor$}),
          that is, \\ $\SliceStar(\efactor, \elength)$;
    \item applying $\evaltoint$ to $\efactor$ in $\tenv$ to an integer yields the integer $f$\ProseOrTypeError;
    \item applying $\evaltoint$ to $\elength$ in $\tenv$ to an integer yields the integer $l$\ProseOrTypeError;
    \item $t$ is $(f \times l) + l - 1$;
    \item $b$ is $t - l + 1$;
    \item checking that $t$ is greater or equal to $b$ and that $b$ is greater or equal to $0$ yields $\True$\ProseOrTypeError;
    \item $\positions$ is the list of integers from $t$ down to $b$, inclusive.
  \end{itemize}
\end{itemize}

\subsection{Formally}

\begin{mathpar}
\inferrule[single]{
  \evaltoint(\tenv, \ve) \typearrow n \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \checktrans{n \geq 0}{BadSlice} \checktransarrow \True \OrTypeError
}{
  \slicetopositions(\tenv, \overname{\SliceSingle(\ve)}{\vs}) \typearrow [ n ]
}
\and
\inferrule[range]{
  \evaltoint(\tenv, \ebot) \typearrow b \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \evaltoint(\tenv, \etop) \typearrow t \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \checktrans{t \geq b \geq 0}{BadSlice} \checktransarrow \True \OrTypeError
}{
  \slicetopositions(\tenv, \overname{\SliceRange(\etop, \ebot)}{\vs}) \typearrow [ t..b ]
}
\and
\inferrule[length]{
  \evaltoint(\tenv, \ebot) \typearrow b \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \evaltoint(\tenv, \elength) \typearrow l \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  t \eqdef b + l - 1
  \checktrans{t \geq b \geq 0}{BadSlice} \checktransarrow \True \OrTypeError
}{
  \slicetopositions(\tenv, \overname{\SliceLength(\ebot, \elength)}{\vs}) \typearrow [ t..b ]
}
\and
\inferrule[star]{
  \evaltoint(\tenv, \efactor) \typearrow f \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \evaltoint(\tenv, \elength) \typearrow l \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  t \eqdef (f \times l) + l - 1\\
  b \eqdef t - l\\
  \checktrans{t \geq b \geq 0}{BadSlice} \checktransarrow \True \OrTypeError
}{
  \slicetopositions(\tenv, \overname{\SliceStar(\efactor, \elength)}{\vs}) \typearrow [ t..b ]
}
\end{mathpar}

\section{TypingRule.EvalToInt \label{sec:TypingRule.EvalToInt}}
\hypertarget{def-evaltoint}{}
The function
\[
\evaltoint(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve})
\aslto \overname{\Z}{n} \cup \{\CannotBeTransformed\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
statically evaluates the expression $\ve$ to the integer $n$.
The result is $\CannotBeTransformed$ if $\ve$ cannot be statically evaluated
to an integer.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\staticeval$ to $\ve$ in $\tenv$ has one of three outcomes:
  \begin{itemize}
  \item a literal $\vl$, which satisfies the premise;
  \item $\CannotBeTransformed$ (which means the expression could not be evaluated to a literal),
  which short-circuits the entire rule;
  or
  \item $\TypeErrorConfig$ (indicating a type error was detected), which short-circuits the entire rule;
  \end{itemize}
  \item checking that $\vl$ is an integer literal yields $\True$\ProseOrTypeError;
  \item define $\vl$ as the literal integer for $n$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \staticeval(\tenv, \ve) \typearrow \vl \terminateas \CannotBeTransformed, \TypeErrorConfig\\\\
  \checktrans{\astlabel(\vl) = \lint}{ExpectedIntegerType} \checktransarrow \True \OrTypeError\\\\
  \vl \eqname \lint(n)
}{
  \evaltoint(\tenv, \ve) \typearrow n
}
\end{mathpar}

\section{TypingRule.ExtractSlice \label{sec:TypingRule.ExtractSlice}}
\hypertarget{def-extractslice}{}
The function
\[
  \extractslice(\overname{\{0,1\}^*}{\bits} \aslsep \overname{\Z^*}{\positions}) \aslto
  \overname{\{0,1\}^*}{\vr} \cup\ \TTypeError
\]
extracts from the list of bits $\bits$ the sublist $\vr$ of bits appearing at the positions given by $\positions$.
\ProseOtherwiseTypeError

\subsection{Prose}
Define $\vr$ the sublist of $\bits$ given by taking $\bits[\vi]$, for every value given in $\positions$ (in the order they appear).

\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \extractslice(\tenv, \bits, \positions) \typearrow \overname{[ \vi\in\positions: \bits[\vi] ]}{\vr}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Symbolic Subsumption Testing \label{chap:symbolicsubsumptiontesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter is concerned with implementing a \hyperlink{def-soundsubsumptiontest}{sound subsumption test},
as defined in \secref{subsumptiontesting} and employed by
TypingRule.DomainSubtypeSatisfaction (see \secref{TypingRule.DomainSubtypeSatisfaction}).

\hypertarget{def-symbolicdomain}{}
The symbolic reasoning operates by first transforming types into expressions in a \emph{symbolic domain} AST
(defined next, reusing $\intconstraint$ from the parsed AST) over which it then operates:
\hypertarget{def-symdom}{}
\hypertarget{def-dbool}{}
\[
  \begin{array}{rcl}
    \symdom &::=& \DBool                    \hypertarget{def-dstring}{}\\
            &|  & \DString                  \hypertarget{def-dreal}{}\\
            &|  & \DReal                    \hypertarget{def-dsymbols}{}\\
            &|  & \DSymbols(\identifier^+)  \hypertarget{def-dint}{}\\
            &|  & \DInt(\intset)            \hypertarget{def-dbits}{}\\
            &|  & \DBits(\intset)           \hypertarget{def-intset}{} \hypertarget{def-dunknown}{}\\
            &|  & \DUnknown                 \hypertarget{def-intset}{} \hypertarget{def-finite}{}\\
    \intset &::=& \Finite(\powfin{\Z} \setminus \emptyset) \hypertarget{def-top}{}\\
            &|  & \Top                      \hypertarget{def-fromsymtax}{}\\
            &|  & \FromSyntax(\syntax)      \hypertarget{def-syntax}{}\\
    \syntax &::=& \intconstraint^*
  \end{array}
\]

\begin{itemize}
  \item $\DBool$, $\DString$, and $\DReal$ denote the symbolic domains of the Boolean type, the string type,
        and the real type, respectively;
  \item $\DSymbols$ denotes the symbolic domain of an enumeration type with a specific set of labels;
  \item $\DInt$ denotes the symbolic domain of integer types.
        More specifically:
        \begin{itemize}
          \item We refer to an element of the form $\DInt(\Finite(S))$ as a \emph{symbolic finite set integer domain},
                which represents the set of integers $S$;
          \item We refer to an element of the form $\DInt(\FromSyntax(\vcs))$ as a \emph{symbolic constrained integer domain},
                which represents the set of integers given by the list of constraints $\vcs$; and
          \item We refer to an element of the form $\DInt(\Top)$ as a \emph{symbolic unconstrained integer domain},
                which represents the set of all integers.
        \end{itemize}
  \item $\DBits$ denotes the symbolic domain of bitvector types.
        More specifically:
        \begin{itemize}
        \item We refer to an element of the form $\DBits(\Finite(S))$ as a \emph{symbolic finite set width bitvector domain},
              which represents all bitvectors whose width is given by one of the integers in $S$;
        \item We refer to an element of the form $\DBits(\FromSyntax(\vcs))$ as a
              \emph{symbolic constrained width bitvector domain}, which represents all bitvectors whose width
              is given by the list of constraints $\vcs$ ; and
        \item We refer to an element of the form $\DBits(\Top)$ as a \emph{symbolic unconstrained width bitvector domain},
              which represents all bitvectors whose width is unknown.
        \end{itemize}
  \item $\DUnknown$ is assigned to types that are not treated precisely by the symbolic subsumption testing,
        such as array types, record types, and tuple types.
\end{itemize}

The main rule is of this chapter is TypingRule.SymSubsumes (see \secref{TypingRule.SymSubsumes}), which defines the function
$\symsubsumes$.

Other helper rules are as follows:
\begin{itemize}
  \item TypingRule.SymDomOfType (see \secref{TypingRule.SymDomOfType})
  \item TypingRule.SymDomOfExpr (see \secref{TypingRule.SymDomOfExpr})
  \item TypingRule.IntSetOp (see \secref{TypingRule.IntSetOp})
  \item TypingRule.IntSetToIntConstraints (see \secref{TypingRule.IntSetToIntConstraints})
  \item TypingRule.SymDomOfLiteral (see \secref{TypingRule.SymDomOfLiteral})
  \item TypingRule.SymIntSetOfConstraints (see \secref{TypingRule.SymIntSetOfConstraints})
  \item TypingRule.ConstraintToIntSet (see \secref{TypingRule.ConstraintToIntSet})
  \item TypingRule.NormalizeToInt (see \secref{TypingRule.NormalizeToInt})
  \item TypingRule.SymDomIsSubset (see \secref{TypingRule.SymDomIsSubset})
  \item TypingRule.SymIntSetSubset (see \secref{TypingRule.SymIntSetSubset})
  \item TypingRule.ConstraintsBinop (see \secref{TypingRule.ConstraintsBinop})
  \item TypingRule.ConstraintBinop (see \secref{TypingRule.ConstraintBinop})
  \item TypingRule.IsRightIncreasing (see \secref{TypingRule.IsRightIncreasing})
  \item TypingRule.IsRightDecreasing (see \secref{TypingRule.IsRightDecreasing})
  \item TypingRule.IsLeftIncreasing (see \secref{TypingRule.IsLeftIncreasing})
\end{itemize}

\section{TypingRule.SymSubsumes \label{sec:TypingRule.SymSubsumes}}
\hypertarget{def-symsubsumes}{}
The predicate
\[
  \symsubsumes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb}
\]
soundly approximates $\subsumes(\tenv, \vt, \vs)$.
\ProseOtherwiseTypeError

We assume that both $\vt$ and $\vs$ have been successfully annotated as per \chapref{typingoftypes}
(otherwise a typing error prevents us from applying this function).

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\symdomoftype$ to $\vt$ in $\tenv$ yields $\dt$;
  \item applying $\symdomoftype$ to $\vs$ in $\tenv$ yields $\ds$;
  \item applying $\symdomissubset$ to $\dt$ and $\ds$ in $\tenv$ yields $\vb$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \symdomoftype(\tenv, \vt) \typearrow \dt\\
  \symdomoftype(\tenv, \vs) \typearrow \ds\\
  \symdomissubset(\tenv, \dt, \ds) \typearrow \vb
}{
  \symsubsumes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.SymDomOfType \label{sec:TypingRule.SymDomOfType}}
\hypertarget{def-symdomoftype}{}
The function
\[
  \symdomoftype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto \overname{\symdom}{\vd}
\]
transforms a type $\vt$ in a static environment $\tenv$ into a symbolic domain $\vd$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{t\_bool}):
  \begin{itemize}
    \item $\vt$ is the Boolean type;
    \item define $\vd$ as $\DBool$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_string}):
  \begin{itemize}
    \item $\vt$ is the string type;
    \item define $\vd$ as $\DString$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_real}):
  \begin{itemize}
    \item $\vt$ is the real type;
    \item define $\vd$ as $\DReal$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_enum}):
  \begin{itemize}
    \item $\vt$ is the enumeration type with list of labels $\vli$;
    \item define $\vd$ as the symbolic list of symbolic for $\vli$, that is, $\DSymbols(\vli)$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_unconstrained}):
  \begin{itemize}
    \item $\vt$ is the unconstrained integer type;
    \item define $\vd$ as $\DInt(\Top)$, which intuitively represents the entire set of integers.
  \end{itemize}

  \item All of the following apply (\textsc{int\_parameterized}):
  \begin{itemize}
    \item $\vt$ is the \parameterizedintegertype\ for the identifier $\id$;
    \item define $\vd$ as the symbolic constrained integer domain with a single constraint for the variable expression for $\id$,
          that is, \\ $\DInt(\FromSyntax([\ConstraintExact(\EVar(\id))]))$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_well\_constrained\_finite}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\intsetofintconstraints$ to $\vcs$ in $\tenv$ yields $\vis$;
    \item $\vis$ is a set of integers, that is, $\astlabel(\vis)$ if $\Finite$;
    \item define $\vd$ as the symbolic finite set integer domain for $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_well\_constrained\_symbolic}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\intsetofintconstraints$ to $\vcs$ in $\tenv$ yields $\vis$;
    \item $\vis$ is not a set of integers, that is, $\astlabel(\vis)$ is not $\Finite$;
    \item define $\vd$ as the symbolic constrained integer domain for the list of constraints $\vcs$, that is, $\DInt(\FromSyntax(\vcs))$.
  \end{itemize}

  \item All of the following apply (\textsc{bits\_finite\_single}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with width expression $\width$;
    \item applying $\symdomofexpr$ to $\width$ in $\tenv$ yields a symbolic integer domain for the integer $n$;
    \item define $\vd$ as the symbolic finite set width bitvector domain for the integer $n$, that is, \\
          $\DBits(\Finite(\{n\}))$.
  \end{itemize}

  \item All of the following apply (\textsc{bits\_finite\_set}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with width expression $\width$;
    \item applying $\symdomofexpr$ to $\width$ in $\tenv$ yields a list of at least two integers;
    \item define $\vd$ as the symbolic constrained width bitvector domain for the expression $\width$, that is, $\DBits(\FromSyntax([\ConstraintExact(\width)]))$.
  \end{itemize}

  \item All of the following apply (\textsc{bits\_constraint\_exact}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with width expression $\width$;
    \item applying $\symdomofexpr$ to $\width$ in $\tenv$ yields a symbolic integer domain for the single expression constraint $\vv$,
          that is \\
          $\DInt(\FromSyntax([\ConstraintExact(\vv)]))$;
    \item define $\vd$ as the symbolic constrained width bitvector domain for the single-value constraint $\vv$, that is,
          $\DBits(\FromSyntax([\ConstraintExact(\vv)]))$.
  \end{itemize}

  \item All of the following apply (\textsc{bits\_symbolic}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with width expression $\width$;
    \item applying $\symdomofexpr$ to $\width$ in $\tenv$ yields a symbolic integer domain for the symbolic constraint $\vc$,
          that is, $\DInt(\FromSyntax(\vc))$, and $\vc$ is not a single expression constraint;
    \item define $\vd$ as the symbolic constrained width bitvector domain for the expression $\width$, that is,
          $\DBits(\FromSyntax([\ConstraintExact(\width)]))$.
  \end{itemize}

  \item All of the following apply (\textsc{bits\_top}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with width expression $\width$;
    \item applying $\symdomofexpr$ to $\width$ in $\tenv$ yields a symbolic integer domain for the unconstrained integer,
          that is, $\DInt(\Top)$;
    \item define $\vd$ as the symbolic constrained width bitvector domain for the expression $\width$, that is,
          $\DBits(\FromSyntax([\ConstraintExact(\width)]))$.
  \end{itemize}

  \item All of the following apply (\textsc{unsupported}):
  \begin{itemize}
    \item $\vt$ is one of the following types: an array type, an exception type, a record type, a tuple type;
    \item define $\vs$ as $\DUnknown$, meaning that the symbolic reasoning does not currently reason about them precisely.
  \end{itemize}

  \item All of the following apply (\textsc{t\_named}):
  \begin{itemize}
    \item $\vt$ is the named type for identifier $\id$;
    \item applying $\makeanonymous$ to $\vt$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ in $\tenv$ yields $\vd$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[t\_bool]{}{ \symdomoftype(\tenv, \overname{\TBool}{\vt}) \typearrow \overname{\DBool}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[t\_string]{}{ \symdomoftype(\tenv, \overname{\TString}{\vt}) \typearrow \overname{\DString}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[t\_real]{}{ \symdomoftype(\tenv, \overname{\TReal}{\vt}) \typearrow \overname{\DReal}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{}{ \symdomoftype(\tenv, \overname{\TEnum(\vli)}{\vt}) \typearrow \overname{\DSymbols(\vli)}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[int\_unconstrained]{}{ \symdomoftype(\tenv, \overname{\unconstrainedinteger}{\vt}) \typearrow \overname{\DInt(\Top)}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[int\_parameterized]{}{
  \symdomoftype(\tenv, \overname{\TInt(\parameterized(\id))}{\vt}) \typearrow \\
  \overname{\DInt(\FromSyntax([\ConstraintExact(\EVar(\id))]))}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained\_finite]{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \vis\\
  \astlabel(\vis) = \Finite
}{
  \symdomoftype(\tenv, \overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\DInt(\vis)}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained\_symbolic]{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \vis\\
  \astlabel(\vis) \neq \Finite
}{
  \symdomoftype(\tenv, \overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\DInt(\FromSyntax(\vcs))}{\vd}
}
\end{mathpar}

Notice that a bitvector type given by $\TBits(\width)$ guarantees that
$\width$ is an integer type via TypingRule.TBits (see \secref{TypingRule.TBits}),
which is why $\symdomofexpr(\tenv, \width)$ is guaranteed to return
a symbolic domain of the form $\DInt(i)$.

\begin{mathpar}
\inferrule[bits\_finite\_single]{
  \symdomofexpr(\tenv, \width) \typearrow \DInt(\Finite(\{n\}))
}{
  \symdomoftype(\tenv, \overname{\TBits(\width)}{\vt}) \typearrow \overname{\DBits(\Finite(\{n\}))}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_finite\_set]{
  \symdomofexpr(\tenv, \width) \typearrow \DInt(\Finite(N))\\
  |N| > 1
}{
  \symdomoftype(\tenv, \overname{\TBits(\width)}{\vt}) \typearrow \\ \overname{\DBits(\FromSyntax([\ConstraintExact(\width)]))}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_constraint\_exact]{
  \symdomofexpr(\tenv, \width) \typearrow \DInt(\FromSyntax([\ConstraintExact(\vv)]))
}{
  \symdomoftype(\tenv, \overname{\TBits(\width)}{\vt}) \typearrow \\ \overname{\DBits(\FromSyntax([\ConstraintExact(\vv)]))}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_symbolic]{
  \symdomofexpr(\tenv, \width) \typearrow \DInt(\FromSyntax(\vc))\\
  \vc \neq [\ConstraintExact(\vv)]
}{
  \symdomoftype(\tenv, \overname{\TBits(\width)}{\vt}) \typearrow \\ \overname{\DBits(\FromSyntax([\ConstraintExact(\width)]))}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_top]{
  \symdomofexpr(\tenv, \width) \typearrow \DInt(\Top)
}{
  \symdomoftype(\tenv, \overname{\TBits(\width)}{\vt}) \typearrow \\ \overname{\DBits(\FromSyntax([\ConstraintExact(\width)]))}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unsupported]{
  \astlabel(\vt) \in \{\TArray, \TException, \TRecord, \TTuple\}
}{
  \symdomoftype(\tenv, \vt) \typearrow \DUnknown
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_named]{
  \vt = \TNamed(\id)\\
  \makeanonymous(\vt) \typearrow \vtone\\
  \symdomoftype(\tenv, \vtone) \typearrow \vd
}{
  \symdomoftype(\tenv, \vt) \typearrow \vd
}
\end{mathpar}

\section{TypingRule.SymDomOfExpr \label{sec:TypingRule.SymDomOfExpr}}
\hypertarget{def-symdomofexpr}{}
The function
\[
\symdomofexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto
\overname{\symdom}{\vd}
\]
assigns a symbolic domain $\vd$ to an \underline{integer typed} expression $\ve$ in the static environment $\tenv$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{e\_literal}):
  \begin{itemize}
    \item $\ve$ is a literal expression for the literal $\vv$;
    \item applying $\symdomofliteral$ to $\vv$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vx$;
    \item applying $\lookupconstant$ to $\vx$ in $\tenv$ yields the literal $\vv$;
    \item applying $\symdomofliteral$ to $\vv$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_type}):
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vx$;
    \item applying $\lookupconstant$ to $\vx$ in $\tenv$ yields $\bot$;
    \item applying $\typeof$ to $\vx$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop\_minus}):
  \begin{itemize}
    \item $\ve$ is a unary operation expression for the operation $\MINUS$ and subexpression $\veone$;
    \item applying $symdomofexpr$ to the binary operation expression with the operation $\MINUS$
          and the literal expression for $0$ and $\veone$ in $\tenv$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop\_unknown}):
  \begin{itemize}
    \item $\ve$ is a unary operation expression for an operation that is not $\MINUS$;
    \item define $\vd$ as $\DUnknown$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop\_supported}):
  \begin{itemize}
    \item $\ve$ is a binary operation expression for an operation that is one of $\PLUS$, $\MINUS$, or $\MUL$
          and subexpressions $\veone$ and $\vetwo$;
    \item applying $\symdomofexpr$ to $\veone$ in $\tenv$ yields a symbolic constrained integer domain with constraint $\visone$,
          that is, $\DInt(\visone)$;
    \item applying $\symdomofexpr$ to $\vetwo$ in $\tenv$ yields a symbolic constrained integer domain with constraint $\vistwo$,
          that is, $\DInt(\vistwo)$;
    \item applying $\intsetop$ to $\op$ and $\visone$ and $\vistwo$ yields $\vis$;
    \item define $\vs$ as the symbolic finite set integer domain over $\vis$, that is, $\DInt(\vis)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop\_sunupported}):
  \begin{itemize}
    \item $\ve$ is a binary operation expression for an operation that is not one of $\PLUS$, $\MINUS$, or $\MUL$;
    \item define $\vs$ as $\DUnknown$.
  \end{itemize}

  \item All of the following apply (\textsc{unsupported}):
  \begin{itemize}
    \item $\ve$ is not one of the following expression types a literal expression, a variable expression, a unary operation
          expression, or a binary operation expression;
    \item define $\vs$ as $\DUnknown$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[e\_literal]{
  \symdomofliteral(\vv) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\ELiteral(\vv)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_constant]{
  \lookupconstant(\tenv, \vx) \typearrow \vv\\
  \symdomofliteral(\vv) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_type]{
  \lookupconstant(\tenv, \vx) \typearrow \bot\\
  \typeof(\tenv, \vx) \typearrow \vtone\\
  \symdomoftype(\vtone) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop\_minus]{
  \symdomofexpr(\EBinop(\MINUS, \ELiteral(\lint(0)), \veone)) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EUnop(\NEG, \veone)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop\_unknown]{
  \op \neq \MINUS
}{
  \symdomofexpr(\tenv, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \overname{\DUnknown}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop\_supported]{
  \op \in \{\PLUS, \MINUS, \MUL\}\\
  \symdomofexpr(\tenv, \veone) \typearrow \DInt(\visone)\\
  \symdomofexpr(\tenv, \vetwo) \typearrow \DInt(\vistwo)\\
  \intsetop(\op, \visone, \vistwo) \typearrow \vis
}{
  \symdomofexpr(\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \overname{\DInt(\vis)}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop\_unsupported]{
  \op \not\in \{\PLUS, \MINUS, \MUL\}\\
}{
  \symdomofexpr(\tenv, \overname{\EBinop(\op, \Ignore, \Ignore)}{\ve}) \typearrow \overname{\DUnknown}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unsupported]{
  \astlabel(\ve) \not\in \{\ELiteral, \EVar, \EUnop, \EBinop\}
}{
  \symdomofexpr(\tenv, \ve) \typearrow \overname{\DUnknown}{\vd}
}
\end{mathpar}

\section{TypingRule.IntSetOp \label{sec:TypingRule.IntSetOp}}
\hypertarget{def-intsetop}{}
The function
\[
\intsetop(\overname{\binop}{\op} \aslsep \overname{\intset}{\visone} \aslsep \overname{\intset}{\vistwo})
\aslto \overname{\intset}{\vis}
\]
applies the binary operation $\op$ to the symbolic integer sets $\visone$ and $\vistwo$,
yielding the symbolic integer set $\vis$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{top}):
  \begin{itemize}
    \item at least one of $\visone$ and $\vistwo$ is $\Top$;
    \item define $\vis$ as $\Top$.
  \end{itemize}

  \item All of the following apply (\textsc{finite\_finite}):
  \begin{itemize}
    \item $\visone$ is the symbolic finite set integer domain for $\vsone$;
    \item $\vistwo$ is the symbolic finite set integer domain for $\vstwo$;
    \item define $\vis$ as the symbolic finite set domain for the set obtained
          by applying $\op$ to each element of $\vsone$ and each element of $\vstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{finite\_syntax}):
  \begin{itemize}
    \item $\visone$ is the symbolic finite set integer domain for $\vsone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\vstwo$;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item applying $\intsetop$ to $\op$, the symbolic constrained integer domain for $\csone$,
          and $\vistwo$ yields $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{syntax\_finite}):
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic finite set integer domain for $\vstwo$;
    \item applying $\intsettointconstraints$ to $\vstwo$ yields the list of constraints $\cstwo$;
    \item applying $\intsetop$ to $\op$, $\visone$, and the symbolic constrained integer domain
          for $\cstwo$, yields $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{syntax\_syntax\_well\_constrained}):
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\cstwo$;
    \item applying $\constraintbinop$ to $\op$, $\csone$, and $\cstwo$ yields
          a list of constraints $\vcs$;
    \item define $\vis$ as the symbolic constrained integer domain for $\vcs$.
  \end{itemize}

  \item All of the following apply (\textsc{syntax\_syntax\_top}):
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\cstwo$;
    \item applying $\constraintbinop$ to $\op$, $\csone$, and $\cstwo$ yields $\top$;
    \item define $\vis$ as $\Top$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[top]{
  \visone = \Top \lor \vistwo = \Top
}{
  \intsetop(\op, \visone, \vistwo) \typearrow \overname{\Top}{\vis}
}
\and
\inferrule[finite\_finite]{
  \vis \eqdef \Finite(\{ \op(a, b) \;|\; a \in \vsone, b \in \vstwo \})
}{
  \intsetop(\op, \overname{\Finite(\vsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_syntax]{
  \intsettointconstraints(\vsone) \typearrow \vcsone\\
  \intsetop(\op, \FromSyntax(\vcsone), \FromSyntax(\vcstwo)) \typearrow \vis
}{
  \intsetop(\op, \overname{\Finite(\vsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_finite]{
  \intsettointconstraints(\vstwo) \typearrow \vcstwo\\
  \intsetop(\op, \FromSyntax(\vcsone), \FromSyntax(\vcstwo)) \typearrow \vis
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_syntax\_well\_constrained]{
  \constraintbinop(\op, \vcsone, \vcstwo) \typearrow \wellconstrained(\vcs)
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \overname{\FromSyntax(\vcs)}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_syntax\_top]{
  \constraintbinop(\op, \vcsone, \vcstwo) \typearrow \top
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \overname{\Top}{\vis}
}
\end{mathpar}

\section{TypingRule.IntSetToIntConstraints \label{sec:TypingRule.IntSetToIntConstraints}}
\hypertarget{def-intsettointconstraints}{}
The function
\[
\intsettointconstraints(\overname{\powfin{\Z}}{\vs})
\aslto \overname{\intconstraint^*}{\cs}
\]
transforms a finite set of integers into the equivalent list of integer constraints.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\vs$ is the empty set;
    \item define $\cs$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{singleton}):
  \begin{itemize}
    \item $\vs$ is the singleton set for $a$;
    \item define $\cs$ as the list containing the single range constraint for the interval starting from $a$
          and ending at $a$, that is, $\ConstraintRange(\ELInt{a}, \ELInt{a})$.
  \end{itemize}

  \item All of the following apply (\textsc{new\_interval}):
  \begin{itemize}
    \item define $a$ as the minimal element of $\vs$;
    \item define $\vsone$ as the set $\vs$ with $a$ removed from it;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item $\csone$ is a list where its \head\ is a range constraint for the interval starting from $b$ and ending at $c$
          and \tail\ $\cstwo$;
    \item $b$ is greater than $a+1$;
    \item define $\cs$ as the list with first element a range constraint for the interval from $a$ to $a$,
          second element a range constraint for the interval from $b$ to $c$, and remaining elements given by $\cstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{merge\_interval}):
  \begin{itemize}
    \item define $a$ as the minimal element of $\vs$;
    \item define $\vsone$ as the set $\vs$ with $a$ removed from it;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item $\csone$ is a list where its \head\ is a range constraint for the interval starting from $b$ and ending at $c$
          and \tail\ $\cstwo$;
    \item $b$ is equal to $a+1$;
    \item define $\cs$ as the list with \head\  a range constraint for the interval from $a$ to $c$
          and \tail\ $\cstwo$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \intsettointconstraints(\overname{\emptyset}{\vs}) \typearrow \overname{\emptylist}{\cs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[singleton]{}{
  \intsettointconstraints(\overname{\{a\}}{\vs}) \typearrow \overname{[\ConstraintRange(\ELInt{a}, \ELInt{a})]}{\cs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[new\_interval]{
  a = \min(\vs)\\
  \vsone \eqdef \vs \setminus \{a\}\\
  \intsettointconstraints(\vsone) \typearrow \csone\\
  \csone = [\ConstraintRange(\ELInt{b}, \ELInt{c})] \concat \cstwo\\
  b > a + 1\\\\
  {
    \begin{array}{rcl}
  \cs  &\eqdef & [\ConstraintRange(\ELInt{a}, \ELInt{a})]\ \concat\\
        &       & [\ConstraintRange(\ELInt{b}, \ELInt{c})]\ \concat \\
        &       & \cstwo
    \end{array}
  }
}{
  \intsettointconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\begin{mathpar}
\inferrule[merge\_interval]{
  a = \min(\vs)\\
  \vsone \eqdef \vs \setminus \{a\}\\
  \intsettointconstraints(\vsone) \typearrow \csone\\
  \csone = [\ConstraintRange(\ELInt{b}, \ELInt{c})] \concat \cstwo\\
  b = a + 1\\
  \cs \eqdef [\ConstraintRange(\ELInt{a}, \ELInt{c})] \concat \cstwo
}{
  \intsettointconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\section{TypingRule.SymDomOfLiteral \label{sec:TypingRule.SymDomOfLiteral}}
\hypertarget{def-symdomofliteral}{}
The function
\[
\symdomofliteral(\overname{\literal}{\vv}) \typearrow \overname{\symdom}{\vd}
\]
returns the symbolic domain $\vd$ that corresponds to the literal $\vv$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{l\_int}):
  \begin{itemize}
    \item $\vv$ is an integer literal for $n$;
    \item define $\vd$ as the symbolic finite set integer domain for the singleton set for $n$, that is, $\DInt(\Finite(\{n\}))$.
  \end{itemize}

  \item All of the following apply (\textsc{l\_bool}):
  \begin{itemize}
    \item $\vv$ is a Boolean literal;
    \item define $\vd$ as the symbolic Boolean domain.
  \end{itemize}

  \item All of the following apply (\textsc{l\_real}):
  \begin{itemize}
    \item $\vv$ is a real literal;
    \item define $\vd$ as the symbolic real domain.
  \end{itemize}

  \item All of the following apply (\textsc{l\_string}):
  \begin{itemize}
    \item $\vv$ is a string literal;
    \item define $\vd$ as the symbolic string domain.
  \end{itemize}

  \item All of the following apply (\textsc{l\_bitvector}):
  \begin{itemize}
    \item $\vv$ is a bitvector literal for the sequence of bits $\bv$;
    \item the length of $\bv$ is $n$;
    \item define $\vd$ as the symbolic finite set width bitvector domain for the singleton set for $n$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[l\_int]{}{
  \symdomofliteral(\overname{\lint(n)}{\vv}) \typearrow \overname{\DInt(\Finite(\{n\}))}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[l\_bool]{}{
  \symdomofliteral(\overname{\lbool(\Ignore)}{\vv}) \typearrow \overname{\DBool}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[l\_real]{}{
  \symdomofliteral(\overname{\lreal(\Ignore)}{\vv}) \typearrow \overname{\DReal}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[l\_string]{}{
  \symdomofliteral(\overname{\lstring(\Ignore)}{\vv}) \typearrow \overname{\DString}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[l\_bitvector]{
  n \eqdef |\bv|
}{
  \symdomofliteral(\overname{\lbitvector(\bv)}{\vv}) \typearrow \overname{\DBits(\Finite(\{n\}))}{\vd}
}
\end{mathpar}

\section{TypingRule.SymIntSetOfConstraints \label{sec:TypingRule.SymIntSetOfConstraints}}
\hypertarget{def-intsetofintconstraintse}{}
The function
\[
  \intsetofintconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\constraints}{\vcs}
  ) \aslto
  \overname{\intset}{\vis}
\]
returns the symbolic set of integers $\vis$ for the list of constraints $\vcs$
in the static environment $\tenv$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{finite}):
  \begin{itemize}
    \item applying $\constrainttointset$ to every constraint $\vcs[\vi]$ in $\tenv$, for $\vi$ in $\listrange(\vcs)$,
          yields a finite set of integers $C_\vi$, that is, $\Finite(C_\vi)$;
    \item define $\vis$ as the union of $C_\vi$ for all $\vi$ in $\listrange(\vcs)$.
  \end{itemize}

  \item All of the following apply (\textsc{symbolic}):
  \begin{itemize}
    \item there exists a constraint $\vc$ in $\vcs$ such that applying $\constrainttointset$ to $\vc$
          in $\tenv$ does not yield a finite set of integers;
    \item define $\vis$ as the symbolic constrained integer domain for $\vcs$, that is, \\
          $\FromSyntax(\vcs)$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[finite]{
  \vi\in\listrange(\vcs): \constrainttointset(\tenv, \vcs[\vi]) \typearrow \Finite(C_\vi)\\
  C \eqdef \bigcup_{\vi\in\listrange(\vcs)} C_\vi
}{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \overname{\Finite(C)}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[symbolic]{
  {
    \begin{array}{r}
  \exists \vi\in\listrange(\vcs): \constrainttointset(\tenv, \vcs[\vi]) \typearrow \\
     \visone \land \astlabel(\visone) \neq \Finite
    \end{array}
  }
}{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \overname{\FromSyntax(\vcs)}{\vis}
}
\end{mathpar}

\section{TypingRule.ConstraintToIntSet \label{sec:TypingRule.ConstraintToIntSet}}
\hypertarget{def-constrainttointset}{}
The function
\[
  \constrainttointset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\intconstraint}{\vc}
  ) \aslto
  \overname{\intset}{\vis} \cup \{\Top\}
\]
transforms an integer constraint $\vc$ into a set of integers $\vis$ or $\Top$
if the expressions involved in the integer constraints cannot be simplified
to integers.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is a single expression constraint for $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\normalizetoint$ to $\ve$ in $\tenv$ yields the integer $n$\ProseTerminateAs{\Top};
    \item define $\vis$ as the singleton set for $n$, that is, $\Finite(\{n\})$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is a range constraint for $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\normalizetoint$ to $\veone$ in $\tenv$ yields the integer $b$\ProseTerminateAs{\Top};
    \item applying $\normalizetoint$ to $\vetwo$ in $\tenv$ yields the integer $t$\ProseTerminateAs{\Top};
    \item define $\vis$ as the set integers that are both greater or equal to $b$ and less than or equal to $t$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[exact]{
  \normalizetoint(\tenv, \ve) \typearrow n \terminateas \Top
}{
  \constrainttointset(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\Finite(\{n\})}{\vis}
}
\and
\inferrule[range]{
  \normalizetoint(\tenv, \veone) \typearrow b \terminateas \Top\\\\
  \normalizetoint(\tenv, \vetwo) \typearrow t \terminateas \Top\\\\
  \vis \eqdef \Finite(\{ n \;|\; b \leq n \leq t\})
}{
  \constrainttointset(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vis
}
\end{mathpar}

\section{TypingRule.NormalizeToInt \label{sec:TypingRule.NormalizeToInt}}
\hypertarget{def-normalizetoint}{}
The function
\[
\normalizetoint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\Z}{n} \cup \{\Top\}
\]
\symbolicallysimplifies\ the \underline{integer-typed} expression $\ve$ and returns the resulting integer or $\Top$ if
the result of the simplification is not an integer.

We assume that $\ve$ has been annotated as it is part of the constraint for an integer type,
and therefore applying $\normalize$ to it does not yield a type error.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{integer}):
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the integer literal for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{top}):
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields $\top$.
    \item the result is $\Top$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[integer]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \lint(n)
}{
  \normalizetoint(\tenv, \ve) \typearrow n
}
\and
\inferrule[top]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \top
}{
  \normalizetoint(\tenv, \ve) \typearrow \Top
}
\end{mathpar}

\section{TypingRule.SymDomIsSubset \label{sec:TypingRule.SymDomIsSubset}}
\hypertarget{def-symdomissubset}{}
The function
\[
  \symdomissubset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\symdom}{\vdone} \aslsep
    \overname{\symdom}{\vdtwo}
  ) \aslto
  \overname{\Bool}{\vb}
\]
conservatively tests whether the symbolic domain $\vdone$ is subsumed by the symbolic domain $\vdtwo$,
yielding the result $\vb$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item the AST labels of $\vdone$ and $\vdtwo$ are different, which means they are symbolic domains of unrelated types;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{unknown}):
  \begin{itemize}
    \item one of $\vdone$ and $\vdtwo$ is $\DUnknown$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{bool\_string\_real}):
  \begin{itemize}
    \item the AST labels of $\vdone$ and $\vdtwo$ are equal and they are one of $\DBool$, $\DString$, and $\DReal$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{symbols}):
  \begin{itemize}
    \item $\vdone$ is a symbolic enumeration domain for the list of identifiers $\visone$;
    \item $\vdtwo$ is a symbolic enumeration domain for the list of identifiers $\vistwo$;
    \item $\vb$ is $\True$ if and only if the set for $\visone$ is a subset of the set for $\vistwo$ (including if both sets are equal).
  \end{itemize}

  \item All of the following apply (\textsc{bits}):
  \begin{itemize}
    \item $\vdone$ is a symbolic bitvector domain for $\visone$;
    \item $\vdtwo$ is a symbolic bitvector domain for $\vistwo$;
    \item applying $\symintsetsubset$ to $\visone$ and $\vistwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{int}):
  \begin{itemize}
    \item $\vdone$ is a symbolic integer domain for $\visone$;
    \item $\vdtwo$ is a symbolic integer domain for $\vistwo$;
    \item applying $\symintsetsubset$ to $\visone$ and $\vistwo$ in $\tenv$ yields $\vb$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\vdone) \neq \astlabel(\vdtwo)
}{
  \symdomissubset(\tenv, \vdone, \vdtwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unknown]{
  \astlabel(\vdone) = \DUnknown \lor \astlabel(\vdtwo) = \DUnknown
}{
  \symdomissubset(\tenv, \vdone, \vdtwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bool\_string\_real]{
  \astlabel(\vdone) = \astlabel(\vdtwo)\\
  \astlabel(\vdone) \in \{\DBool, \DString, \DReal\}
}{ \symdomissubset(\tenv, \vdone, \vdtwo) \typearrow \overname{\True}{\vb} }
\end{mathpar}

\begin{mathpar}
\inferrule[symbols]{
  \vb \eqdef \{\vsone\} \subseteq \{\vstwo\}
}{
  \symdomissubset(\tenv, \overname{\DSymbols(\vsone)}{\vdone}, \overname{\DSymbols(\vstwo)}{\vdtwo}) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits]{
  \symintsetsubset(\tenv, \isone, \istwo) \typearrow \vb
}{
  \symdomissubset(\tenv, \overname{\DBits(\isone)}{\vdone}, \overname{\DBits(\istwo)}{\vdtwo}) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[int]{
  \symintsetsubset(\tenv, \isone, \istwo) \typearrow \vb
}{
  \symdomissubset(\tenv, \overname{\DInt(\isone)}{\vdone}, \overname{\DInt(\istwo)}{\vdtwo}) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.SymIntSetSubset \label{sec:TypingRule.SymIntSetSubset}}
\hypertarget{def-symintsetsubset}{}
The function
\[
\symintsetsubset(\overname{\staticenvs}{\tenv} \aslsep \overname{\intset}{\visone} \aslsep \overname{\intset}{\vistwo}) \aslto \overname{\Bool}{\vb}
\]

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{right\_top}):
  \begin{itemize}
    \item $\vistwo$ is $\Top$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{left\_top\_right\_not\_top}):
  \begin{itemize}
    \item $\visone$ is $\Top$;
    \item $\vistwo$ is not $\Top$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{finite}):
  \begin{itemize}
    \item $\visone$ is a finite set of integers for $\vsone$, that is, $\Finite(\vsone)$;
    \item $\vistwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item define $\vb$ as $\True$ if and only if $\vsone$ is a subset of $\vstwo$ or both sets are equal.
  \end{itemize}

  \item All of the following apply (\textsc{syntax}):
  \begin{itemize}
    \item $\visone$ is a set of integers given by the list of constraints $\csone$, that is, \\ $\FromSyntax(\vsone)$;
    \item $\vistwo$ is a set of integers given by the list of constraints $\cstwo$, that is, \\ $\FromSyntax(\vstwo)$;
    \item applying $\constraintsequal$ to $\csone$ and $\cstwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item both $\visone$ and $\vistwo$ are not $\Top$;
    \item the AST labels of $\visone$ and $\vistwo$ are different;
    \item define $\vb$ as $\False$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[right\_top]{}{
  \symintsetsubset(\tenv, \visone, \overname{\Top}{\vistwo}) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[left\_top\_right\_not\_top]{
  \vistwo \neq \Top
}{
  \symintsetsubset(\tenv, \overname{\Top}{\visone}, \vistwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite]{}{
  \symintsetsubset(\tenv, \overname{\Finite(\vsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax]{
  \constraintsequal(\tenv, \csone, \cstwo) \typearrow \vb
}{
  \symintsetsubset(\tenv, \overname{\FromSyntax(\csone)}{\visone}, \overname{\FromSyntax(\vitwo)}{\cstwo}) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \visone \neq \Top \and \vistwo \neq \Top\\
  \astlabel(\visone) \neq \astlabel(\vistwo)
}{
  \symintsetsubset(\tenv, \visone, \vistwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\section{TypingRule.ConstraintsBinop \label{sec:TypingRule.ConstraintsBinop}}
\hypertarget{def-constraintsbinop}{}
The function
\[
\constraintsbinop(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint^*}{\csone} \aslsep
  \overname{\intconstraint^*}{\cstwo}
)
\aslto \overname{\intconstraint^*}{\cs} \cup \{\top\}
\]
symbolically applies the binary operation $\op$ to the lists of integer constraints $\csone$ and $\cstwo$,
yielding the list of integer constraints $\cs$.
Otherwise, the result is $\top$, which indicates a failure in representing the result by a list of integer constraints.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item for every $\vi$ in $\listrange(\csone)$ and every $\vj$ in $\listrange(\cstwo)$,
        applying \\
        $\constraintbinop$ to $\op$, $\csone[\vi]$, and $\cstwo[\vj]$,
        yields the constraint $\vc_{(\vi,\vj)}$\ProseTerminateAs{\top};
  \item define $\cs$ as the list consisting of constraints $\vc_{(\vi,\vj)}$,
        for every $\vi$ in $\listrange(\csone)$ and every $\vj$ in $\listrange(\cstwo)$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{r}
  \vi\in\listrange(\csone), \vj\in\listrange(\cstwo):
  \constraintbinop(\op, \csone[\vi], \cstwo[\vj]) \typearrow \\ \vc_{(\vi,\vj)} \terminateas \top
    \end{array}
  }\\
  \cs \eqdef [\vi\in\listrange(\csone), \vj\in\listrange(\cstwo): \vc_{(\vi,\vj)}]
}{
  \constraintsbinop(\op, \csone, \cstwo) \typearrow \cs
}
\end{mathpar}

\section{TypingRule.ConstraintBinop \label{sec:TypingRule.ConstraintBinop}}
\hypertarget{def-constraintbinop}{}
The function
\[
\constraintbinop(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint}{\vcone} \aslsep
  \overname{\intconstraint}{\vctwo}
)
\aslto \overname{\intconstraint}{\vc} \cup \{\top\}
\]
symbolically applies the binary operation $\op$ to the integer constraints $\vcone$ and $\vctwo$,
yielding the integer constraint $\vc$.
Otherwise, the result is $\top$, which indicates a failure in representing the result of
by an integer constraint.

\subsection{Prose}


\subsection{Formally}
\begin{mathpar}
\inferrule[exact\_exact]{
  \vcone = \ConstraintExact(\veone)\\
  \vctwo = \ConstraintExact(\vetwo)\\\\
  \vc \eqdef \ConstraintExact(\EBinop(\op, \veone, \vetwo))
}{
  \constraintbinop(\op, \vcone, \vctwo) \typearrow \vc
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range\_right\_increasing]{
  \vcone = \ConstraintExact(\veone)\\
  \vctwo = \ConstraintRange(\vetwoone, \vetwotwo)\\\\
  \isrightincreasing(\op) \typearrow \True \terminateas \top\\\\
  \vc \eqdef \ConstraintRange(\EBinop(\op, \veone, \vetwoone), \EBinop(\op, \veone, \vetwotwo))
}{
  \constraintbinop(\op, \vcone, \vctwo) \typearrow \vc
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range\_right\_decreasing]{
  \vcone = \ConstraintExact(\veone)\\
  \vctwo = \ConstraintRange(\vetwoone, \vetwotwo)\\\\
  \isrightdecreasing(\op) \typearrow \True \terminateas \top\\\\
  \vc \eqdef \ConstraintRange(\EBinop(\op, \veone, \vetwotwo), \EBinop(\op, \veone, \vetwoone))
}{
  \constraintbinop(\op, \vcone, \vctwo) \typearrow \vc
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range\_top]{
  \vcone = \ConstraintExact(\veone)\\
  \vctwo = \ConstraintRange(\vetwoone, \vetwotwo)\\\\
  \isrightincreasing(\op) \typearrow \False\\
  \isrightdecreasing(\op) \typearrow \False\\
}{
  \constraintbinop(\op, \vcone, \vctwo) \typearrow \vc
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact\_left\_increasing]{
  \vcone = \ConstraintRange(\veoneone, \veonetwo)\\
  \vctwo = \ConstraintExact(\vetwo)\\\\
  \isleftincreasing(\op) \typearrow \True \terminateas \top\\\\
  \vc \eqdef \ConstraintRange(\EBinop(\op, \veoneone, \vetwo), \EBinop(\op, \veonetwo, \vetwo))
}{
  \constraintbinop(\op, \vcone, \vctwo) \typearrow \vc
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range\_left\_increasing\_right\_increasing]{
  \vcone = \ConstraintRange(\veoneone, \veonetwo)\\
  \vctwo = \ConstraintRange(\vetwoone, \vetwotwo)\\\\
  \isleftincreasing(\op) \typearrow \True \terminateas \top\\\\
  \isrightincreasing(\op) \typearrow \True \terminateas \top\\\\
  \vc \eqdef \ConstraintRange(\EBinop(\op, \veoneone, \vetwoone), \EBinop(\op, \veonetwo, \vetwotwo))
}{
  \constraintbinop(\op, \vcone, \vctwo) \typearrow \vc
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range\_left\_increasing\_right\_decreasing]{
  \vcone = \ConstraintRange(\veoneone, \veonetwo)\\
  \vctwo = \ConstraintRange(\vetwoone, \vetwotwo)\\\\
  \isleftincreasing(\op) \typearrow \True \terminateas \top\\\\
  \isrightdecreasing(\op) \typearrow \True \terminateas \top\\\\
  \vc \eqdef \ConstraintRange(\EBinop(\op, \veoneone, \vetwotwo), \EBinop(\op, \veonetwo, \vetwoone))
}{
  \constraintbinop(\op, \vcone, \vctwo) \typearrow \vc
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range\_left\_increasing\_top]{
  \vcone = \ConstraintRange(\veoneone, \veonetwo)\\
  \vctwo = \ConstraintRange(\vetwoone, \vetwotwo)\\\\
  \isleftincreasing(\op) \typearrow \True \terminateas \top\\\\
  \isrightincreasing(\op) \typearrow \False\\
  \isrightdecreasing(\op) \typearrow \False
}{
  \constraintbinop(\op, \vcone, \vctwo) \typearrow \top
}
\end{mathpar}

\section{TypingRule.IsRightIncreasing \label{sec:TypingRule.IsRightIncreasing}}
\hypertarget{def-isrightincreasing}{}
The function
\[
\isrightincreasing(\overname{\binop}{\op}) \aslto \overname{\Bool}{\vb} \cup \{\top\}
\]
tests whether the value of binary operation $\op$ increases along with its right-hand-side operand,
yielding the result in $\vb$.
Otherwise, the result is $\top$, which indicates that the answer is not always $\True$ or $\False$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following (\textsc{true}):
  \begin{itemize}
    \item $\op$ is one of $\MUL, \SHL, \SHR, \POW, \PLUS$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following (\textsc{false}):
  \begin{itemize}
    \item $\op$ is one of $\DIV, \DIVRM, \MOD, \MINUS$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following (\textsc{top}):
  \begin{itemize}
    \item $\op$ is $\RDIV$;
    \item define $\vb$ as $\top$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[true]{
  \op \in \{\MUL, \SHL, \SHR, \POW, \PLUS\}
}{
  \isrightincreasing(\op) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[false]{
  \op \in \{\DIV, \DIVRM, \MOD, \MINUS\}
}{
  \isrightincreasing(\op) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[top]{}{
  \isrightincreasing(\overname{\RDIV}{\op}) \typearrow \top
}
\end{mathpar}

\section{TypingRule.IsRightDecreasing \label{sec:TypingRule.IsRightDecreasing}}
\hypertarget{def-isrightdecreasing}{}
The function
\[
\isrightdecreasing(\overname{\binop}{\op}) \aslto \overname{\Bool}{\vb} \cup \{\top\}
\]
tests whether the value of binary operation $\op$ decreases along with its right-hand-side operand,
yielding the result in $\vb$.
Otherwise, the result is $\top$, which indicates that the answer is not always $\True$ or $\False$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following (\textsc{true}):
  \begin{itemize}
    \item $\op$ is $\MINUS$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following (\textsc{false}):
  \begin{itemize}
    \item $\op$ is one of $\DIV, \DIVRM, \MUL, \SHL, \SHR, \POW, \PLUS, \MOD$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following (\textsc{top}):
  \begin{itemize}
    \item $\op$ is one of $\AND ,\BAND ,\BEQ ,\BOR ,\EOR ,\EQOP ,\GT ,\GEQ ,\IMPL ,\LT ,\LEQ ,\NEQ ,\OR, \RDIV$;
    \item define $\vb$ as $\top$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[true]{}{
  \isrightdecreasing(\overname{\MINUS}{\op}) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[false]{
  \op \in \{\DIV, \DIVRM, \MUL, \SHL, \SHR, \POW, \PLUS, \MOD\}
}{
  \isrightdecreasing(\op) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[top]{
  \op \in \{\AND ,\BAND ,\BEQ ,\BOR ,\EOR ,\EQOP ,\GT ,\GEQ ,\IMPL ,\LT ,\LEQ ,\NEQ ,\OR, \RDIV\}
}{
  \isrightdecreasing(\op) \typearrow \top
}
\end{mathpar}

\section{TypingRule.IsLeftIncreasing \label{sec:TypingRule.IsLeftIncreasing}}
\hypertarget{def-isleftincreasing}{}
The function
\[
\isleftincreasing(\overname{\binop}{\op}) \aslto \overname{\Bool}{\vb} \cup \{\top\}
\]
tests whether the value of binary operation $\op$ increases along with its left-hand-side operand,
yielding $\True$ or $\top$, which indicates that the answer is not always $\True$ or $\False$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following (\textsc{true}):
  \begin{itemize}
    \item $\op$ is one of $\MUL, \DIV, \DIVRM, \MOD, \SHL, \SHR, \POW, \PLUS, \MINUS$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following (\textsc{top}):
  \begin{itemize}
    \item $\op$ is one of $\AND ,\BAND ,\BEQ ,\BOR ,\EOR ,\EQOP ,\GT ,\GEQ ,\IMPL ,\LT ,\LEQ ,\NEQ ,\OR, \RDIV$;
    \item define $\vb$ as $\top$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[true]{
  \op \in \{\MUL, \DIV, \DIVRM, \MOD, \SHL, \SHR, \POW, \PLUS, \MINUS\}
}{
  \isleftincreasing(\op) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[top]{
  \op \in \{\AND ,\BAND ,\BEQ ,\BOR ,\EOR ,\EQOP ,\GT ,\GEQ ,\IMPL ,\LT ,\LEQ ,\NEQ ,\OR, \RDIV\}
}{
  \isleftincreasing(\op) \typearrow \top
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Symbolic Reduction and Equivalence Testing \label{chap:symbolicequivalencetesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we define two forms of symbolic reasoning ---
\emph{symbolic reduction} and \emph{symbolic equivalence testing}.
Symbolic reduction simplifies expressions into \emph{equivalent} expressions
that are simpler to reason about.
In out context, equivalence means that we can substitute one expression for another without
affecting the semantics of the overall specification.
%
Symbolic equivalence is a \emph{conservative} test.
By conservative, we mean that if a test for equivalence returns $\True$ then the expressions
being compared are indeed equivalent, but if the test returns $\False$ then
there are two possibilities:
\begin{itemize}
  \item the expressions are not equivalent;
  \item the expressions are equivalent, but the reasoning power of our rules
  is not enough to prove it, and so we conservatively answer negatively.
\end{itemize}
In proof-theoretic terms, we can say that our equivalence tests are \emph{sound} but \emph{incomplete}.

Notice that for a conservative test, it is always correct to return $\False$.

We first define symbolic expressions and operations over symbolic expressions (\secref{symbolicexpressions})
and then we define the following rules:
\begin{itemize}
  \item TypingRule.Normalize (see \secref{TypingRule.Normalize})
  \item TypingRule.ReduceConstants (see \secref{TypingRule.ReduceConstants})
  \item TypingRule.ReduceConstraint (see \secref{TypingRule.ReduceConstraint})
  \item TypingRule.ReduceConstraints (see \secref{TypingRule.ReduceConstraints})
  \item TypingRule.ToIR (see \secref{TypingRule.ToIR})
  \item TypingRule.ToIRCase (see \secref{TypingRule.ToIRCase})
  \item TypingRule.ExprEqualNorm (see \secref{TypingRule.ExprEqualNorm})
  \item TypingRule.ExprEqual (see \secref{TypingRule.ExprEqual})
  \item TypingRule.ExprEqualCase (see \secref{TypingRule.ExprEqualCase})
  \item TypingRule.TypeEqual (see \secref{TypingRule.TypeEqual})
  \item TypingRule.BitwidthEqual (see \secref{TypingRule.BitwidthEqual})
  \item TypingRule.BitFieldsEqual (see \secref{TypingRule.BitFieldsEqual})
  \item TypingRule.BitFieldEqual (see \secref{TypingRule.BitFieldEqual})
  \item TypingRule.ConstraintsEqual (see \secref{TypingRule.ConstraintsEqual})
  \item TypingRule.ConstraintEqual (see \secref{TypingRule.ConstraintEqual})
  \item TypingRule.SlicesEqual (see \secref{TypingRule.SlicesEqual})
  \item TypingRule.SliceEqual (see \secref{TypingRule.SliceEqual})
  \item TypingRule.ArrayLengthEqual (see \secref{TypingRule.ArrayLengthEqual})
  \item TypingRule.LiteralEqual (see \secref{TypingRule.LiteralEqual})
\end{itemize}

\section{Symbolic Expressions \label{sec:symbolicexpressions}}
Our symbolic reduction and equivalence testing rules use \emph{symbolic expressions}, defined below:
\[
  \begin{array}{rcl}
    \polynomial &\triangleq& \Sum(\unitarymonomial \partialto \Q)                  \hypertarget{def-monomial}{}\hypertarget{def-prod}{}\\
    \unitarymonomial   &\triangleq& \Prod(\Identifiers \partialto \N)\\
  \end{array}
\]

We now explain each component of a symbolic expression and how it can be interpreted as a mathematical formula
via the interpretation function $\alpha$.
We also define operations over symbolic expressions.

\hypertarget{def-unitarymonomial}{}
\begin{definition}[Unitary Monomial]
A \emph{Unitary Monomial} is a partial function from identifiers to non-negative integers\footnote{A unitary monomial has a unit factor,
for example $x^3$, whereas a non-unitary monomial has a non-unit factor, for example, $2 x^3$.}.

A non-empty unitary monomial, $\Prod(\vm)\in\unitarymonomial$ where $\vm \neq \emptyfunc$, can be interpreted as follows:
\[
  \alpha(\Prod(\vm)) \triangleq \prod_{\vx \in \dom(\vm)} \vx^{\vm(\vx)} \enspace.
\]

An empty unitary monomial is interpreted as the constant $1$:
\[
  \alpha(\Prod(\emptyfunc)) \triangleq 1 \enspace.
\]
\end{definition}
For example,
\[
  \alpha(\ \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\})\ ) = x^3 \cdot y \cdot z^2 \enspace.
\]

\hypertarget{def-mulmonomials}{}
The function
\[
  \mulmonomials(\overname{\unitarymonomial}{\vmone} \aslsep \overname{\unitarymonomial}{\vmtwo}) \rightarrow
  \overname{\unitarymonomial}{\vm}
\]
multiplies two unitary monomials and returns a unitary monomial
\begin{mathpar}
  \inferrule{
    {
      \vf \eqdef \lambda \vx\in\identifier.\
      \left\{
      \begin{array}{ll}
        \vfone(\vx) & \text{if } \vx \in \dom(\vfone) \setminus \dom(\vftwo)\\
        \vfone(\vx) & \text{if } \vx \in \dom(\vftwo) \setminus \dom(\vfone)\\
        \vfone(\vx)+\vftwo(\vx) & \text{else } \vx \in \dom(\vfone) \cap \dom(\vftwo)\\
      \end{array}
      \right.
    }
  }
  {
    \mulmonomials(\overname{\Prod(\vfone)}{\vmone}, \overname{\Prod(\vftwo)}{\vmtwo}) \typearrow \overname{\Prod(\vf)}{\vm}
  }
\end{mathpar}
For example,
\[
  \begin{array}{ll}
  \mulmonomials( & \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\}), \Prod(\{\vx\mapsto 1, \vw\mapsto 2\})\ ) =\\
                 & \Prod(\{\vx\mapsto 4, \vy\mapsto 1, \vz\mapsto2, \vw\mapsto2\})
  \end{array}
\]

\hypertarget{def-polynomial}{}
\begin{definition}[Polynomial]
  \emph{Polynomials} are partial functions from monomials to rationals.
  Intuitively, each unitary monomial is mapped to its factor in the polynomial.
  A polynomial $\Sum(\vp)$ can be interpreted as follows:
  %
\[
  \alpha(\Sum(\vp)) \triangleq \sum_{\vm \in \dom(\vp)} \vp(\vm)\cdot\alpha(\vm)
\]
\end{definition}
For example,
\[
  \Sum\left(\left\{
    \begin{array}{lcl}
      \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\}) &\mapsto& -1,\\
      \Prod(\{\vx\mapsto 2, \vy\mapsto 1\}) &\mapsto& \frac{3}{4}
    \end{array} \right\}\right) =
    -1\cdot x^3 \cdot y \cdot z^2 + \frac{3}{4} \cdot \vx^2\cdot \vy \enspace.
\]

The function
\[
  \addpolynomials : \polynomial \times \polynomial \rightarrow \polynomial
\]
adds two polynomials:
\begin{mathpar}
\inferrule{
  {
    \vf \eqdef \lambda \vm\in\unitarymonomial.\
    \left\{
    \begin{array}{ll}
      \vfone(\vm) & \text{if } \vm \in \dom(\vfone) \setminus \dom(\vftwo)\\
      \vfone(\vm) & \text{if } \vm \in \dom(\vftwo) \setminus \dom(\vfone)\\
      \vfone(\vm)+\vftwo(\vm) & \text{else } \vm \in \dom(\vfone) \cap \dom(\vftwo)\\
    \end{array}
    \right.
  }
}{
  \addpolynomials(\overname{\Sum(\vfone)}{\vpone}, \overname{\Sum(\vftwo)}{\vptwo}) \typearrow \overname{\Sum(\vf)}{\vp}
}
\end{mathpar}

The overloaded function
\[
  \addpolynomials : \polynomial^* \rightarrow \polynomial
\]
adds a list of polynomials:
\begin{mathpar}
\inferrule[empty]{}{ \addpolynomials(\emptylist) \typearrow \Prod(\emptyfunc) }
\and
\inferrule[one]{}{ \addpolynomials([ \vp ]) \typearrow \vp }
\and
\inferrule[two\_or\_more]{
  \addpolynomials(\vp_{2..k}) \typearrow \vpp\\
  \addpolynomials(\vp_1, \vpp) \typearrow \vp
}{
  \addpolynomials(\vp_{1..k}) \typearrow \vp
}
\end{mathpar}

The function
\[
  \mulpolynomials : \overname{\polynomial}{\vpone} \times \overname{\polynomial}{\vptwo} \rightarrow \overname{\polynomial}{\vp}
\]
multiplies two polynomials.
\begin{mathpar}
\inferrule{
  {
    \vps \eqdef \{ \Sum(\{\mulmonomials(\vmone, \vmtwo) \mapsto \vcone\times\vctwo\})
      \;|\; \vfone(\vmone)=\vcone, \vftwo(\vmtwo)=\vctwo\}
  }\\
  \vps \eqname \{ i=1..k: \vp[i] \}\\
  \addpolynomials(i=1..k: \vp[i]) \typearrow \vp\\
}{
  \mulpolynomials(\overname{\Sum(\vfone)}{\vpone}, \overname{\Sum(\vftwo)}{\vptwo}) \typearrow \vp
}
\end{mathpar}

\section{TypingRule.Normalize \label{sec:TypingRule.Normalize}}
\hypertarget{def-normalize}{}
The function
\[
\normalize(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto \overname{\expr}{\newe} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
\hypertarget{def-symbolicallysimplifies}{symbolically simplifies} an expression $\ve$ in the static environment $\tenv$,
yielding an expression $\newe$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{normalizable})
  \begin{itemize}
    \item applying $\toir$ to $\ve$ in $\tenv$ to obtain a symbolic expression yields a symbolic expression $\vpone$\ProseOrTypeError;
    \item applying $\reduceir$ to $\vpone$ to symbolically simplify $\vpone$ yields $\vptwo$;
    \item applying $\polynomialtoexpr$ to $\vptwo$ to transform it into an expression yields $\newe$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_normalizable})
  \begin{itemize}
    \item applying $\toir$ to $\ve$ in $\tenv$ to obtain a symbolic expression yields $\CannotBeTransformed$,
          indicating it cannot be transformed to a corresponding symbolic expression;
    \item define $\newe$ as $\ve$.
  \end{itemize}
\end{itemize}
\subsection{Formally}
\begin{mathpar}
\inferrule[normalizable]{
  \toir(\tenv, \ve) \typearrow \vpone \OrTypeError\\\\
  \vpone \neq \CannotBeTransformed\\
  \reduceir(\vpone) \typearrow \vptwo\\
  \polynomialtoexpr(\vptwo) \typearrow \newe
}{
  \normalize(\tenv, \ve) \typearrow \newe
}
\and
\inferrule[not\_normalizable]{
  \toir(\tenv, \ve) \typearrow \CannotBeTransformed
}{
  \normalize(\tenv, \ve) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}
\section{TypingRule.ReduceConstants \label{sec:TypingRule.ReduceConstants}}
\hypertarget{def-reduceconstants}{}
The function
\[
\reduceconstants(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve})
\aslto
\overname{\literal}{\vl} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
\symbolicallysimplifies\ an expression $\ve$ into the literal $\vl$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{eval\_literal}):
  \begin{itemize}
    \item applying $\staticeval$ to $\ve$ in $\tenv$ yields the literal $\vl$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{eval\_normalized}):
  \begin{itemize}
    \item applying $\staticeval$ to $\ve$ in $\tenv$ yields $\CannotBeTransformed$;
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields $\veone$\ProseOrTypeError;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the literal $\vl$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{eval\_failure}):
  \begin{itemize}
    \item applying $\staticeval$ to $\ve$ in $\tenv$ yields $\CannotBeTransformed$;
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields $\veone$\ProseOrTypeError;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields $\CannotBeTransformed$'
    \item the result is a type error indicating that $\ve$ cannot be reduced to a constant in $\tenv$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\ReduceConstantsBegin}{\ReduceConstantsEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[eval\_literal]{
  \staticeval(\tenv, \ve) \typearrow \vl \OrTypeError
}{
  \reduceconstants(\tenv, \ve) \typearrow \vl
}
\and
\inferrule[eval\_noramalized]{
  \staticeval(\tenv, \ve) \typearrow \CannotBeTransformed\\
  \normalize(\tenv, \ve) \typearrow \veone \OrTypeError\\\\
  \staticeval(\tenv, \veone) \typearrow \vl \OrTypeError
}{
  \reduceconstants(\tenv, \ve) \typearrow \vl
}
\and
\inferrule[eval\_failure]{
  \staticeval(\tenv, \ve) \typearrow \CannotBeTransformed\\
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \CannotBeTransformed \OrTypeError
}{
  \reduceconstants(\tenv, \ve) \typearrow \TypeErrorVal{CannotBeReducedToAConstant}
}
\end{mathpar}

\section{TypingRule.ReduceConstraint \label{sec:TypingRule.ReduceConstraint}}
\hypertarget{def-reduceconstraint}{}
The function
\[
\reduceconstraint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\intconstraint}{\vc}
) \aslto
\overname{\intconstraint}{\newc}
\]
\symbolicallysimplifies\ an integer constraint $\vc$, yielding the integer constraint $\newc$

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is an exact integer constraint for $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields $\vep$;
    \item define $\newc$ as the exact integer constraint for $\vep$, that is, $\ConstraintExact(\ve)$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is an range integer constraint for $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\normalize$ to $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\normalize$ to $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newc$ as the exact integer constraint for $\vep$, that is, \\ $\ConstraintRange(\veonep, \vetwop)$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\ReduceConstraintBegin}{\ReduceConstraintEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[exact]{
  \normalize(\tenv, \ve) \typearrow \vep
}{
  \reduceconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\ConstraintExact(\vep)}{\newc}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \normalize(\tenv, \veone) \typearrow \veonep\\
  \normalize(\tenv, \vetwo) \typearrow \vetwop\\
}{
  \reduceconstraint(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\ConstraintRange(\veonep, \vetwop)}{\newc}
}
\end{mathpar}

\section{TypingRule.ReduceConstraints \label{sec:TypingRule.ReduceConstraints}}
\hypertarget{def-reduceconstraints}{}
The function
\[
\reduceconstraints(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\intconstraints}{\vc}
) \aslto
\overname{\intconstraints}{\newc}
\]
\symbolicallysimplifies\ an integer constraints $\vc$, yielding the integer constraints $\newc$

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{unconstrained\_parameterized}):
  \begin{itemize}
    \item the AST label of $\vc$ is either $\unconstrained$ or $\parameterized$;
    \item define $\newc$ as $\vc$.
  \end{itemize}

  \item All of the following apply (\textsc{well\_constrained}):
  \begin{itemize}
    \item $\vc$ is a list of constraints, that is, $\wellconstrained(\cs)$;
    \item define $\newc$ as the application of $\reduceconstraint$ to every constraint in $\cs$ in $\tenv$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\ReduceConstraintsBegin}{\ReduceConstraintsEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[unconstrained\_parameterized]{
  \astlabel(\vc) \in \{\unconstrained, \parameterized\}
}{
  \reduceconstraints(\tenv, \vc) \typearrow \overname{\vc}{\newc}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained\_parameterized]{
  \newc \eqdef [\vi\in\listrange(\cs): \reduceconstraint(\tenv, \cs[\vi])]
}{
  \reduceconstraints(\tenv, \overname{\wellconstrained(\cs)}{\vc}) \typearrow \newc
}
\end{mathpar}

\section{TypingRule.ToIR \label{sec:TypingRule.ToIR}}
\hypertarget{def-toir}{}
The function
\[
  \toir(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\polynomial}{\vp}\ \cup\ \{\CannotBeTransformed\}\ \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
transforms a subset of ASL expressions into symbolic expressions. If an ASL expression cannot be represented
by a symbolic expression (because, for example, it contains operations that are not available in symbolic expressions),
the special value $\CannotBeTransformed$ is returned.

\subsection{Prose}
Intuitively, $\toir$ first conducts a case analysis to determine whether the ASL expression corresponds to a polynomial.
If that fails, it proceeds to check whether the expression is a compile time constant.

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{case\_success}):
  \begin{itemize}
    \item applying $\toircase$ to $\ve$ in $\tenv$ yields a symbolic expression $\vp$.
  \end{itemize}

  \item All of the following apply (\textsc{static\_eval\_literal}):
  \begin{itemize}
    \item applying $\toircase$ to $\ve$ in $\tenv$ yields $\CannotBeTransformed$;
    \item applying $\staticeval$ to $\ve$ yields an integer literal for $\vv$\ProseTerminateAs{\CannotBeTransformed};
    \item define $\vp$ as the polynomial representing the value $\vv$.
  \end{itemize}

  \item All of the following apply (\textsc{static\_eval\_non\_literal}):
  \begin{itemize}
    \item applying $\toircase$ to $\ve$ in $\tenv$ yields $\CannotBeTransformed$;
    \item applying $\staticeval$ to $\ve$ in $\tenv$ yields a literal $\vl$\ProseTerminateAs{\CannotBeTransformed};
    \item $\vl$ is not an integer value;
    \item define $\vp$ as $\CannotBeTransformed$.
  \end{itemize}
\end{itemize}
\subsection{Formally}
\begin{mathpar}
\inferrule[case\_success]{
  \toircase(\tenv, \ve) \typearrow \vp\\
  \vp \neq \CannotBeTransformed
}{
  \toir(\tenv, \ve) \typearrow \vp
}
\and
\inferrule[static\_eval\_literal]{
  \toircase(\tenv, \ve) \typearrow \CannotBeTransformed\\
  \staticeval(\tenv, \ve) \typearrow \lint(\vv) \terminateas \CannotBeTransformed\\\\
  \vp \eqdef \Sum( \{ \Prod(\emptyfunc)\mapsto \vv \} )
}{
  \toir(\tenv, \ve) \typearrow \vp
}
\and
\inferrule[static\_eval\_non\_literal]{
  \toircase(\tenv, \ve) \typearrow \CannotBeTransformed\\
  \staticeval(\tenv, \ve) \typearrow \vl \terminateas \CannotBeTransformed\\\\
  \astlabel(\vl) \neq \lint
}{
  \toir(\tenv, \ve) \typearrow \CannotBeTransformed
}
\end{mathpar}
\section{TypingRule.ToIRCase \label{sec:TypingRule.ToIRCase}}
\hypertarget{def-toircase}{}
The function
\[
  \toircase(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto \overname{\polynomial}{\vp} \cup \{\CannotBeTransformed\}
\]
transforms a subset of ASL expressions into symbolic expressions. If an expression cannot be represented
by a symbolic expression, the special value $\CannotBeTransformed$ is returned.

\subsection{Prose}
Intuitively, $\toir$ first conducts a case analysis to determine whether the ASL expression corresponds to a polynomial.
If that fails, it proceeds to check whether the expression is a compile time constant.

\newcommand\ProseOrTypeErrorOrBot[0]{\ProseTerminateAs{\CannotBeTransformed,\TypeErrorConfig}}

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{literal\_int}):
  \begin{itemize}
    \item $\ve$ is an integer literal expression for $\vi$, that is, $\ELiteral(\lint(\vi))$;
    \item $\vp$ is the symbolic expression for $\vi$.
  \end{itemize}

  \item All of the following apply (\textsc{literal\_other}):
  \begin{itemize}
    \item $\ve$ is a variable expression other than an integer literal;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression with identifier $\vs$, that is, $\EVar(\vs)$;
    \item looking up the constant associated with $\vs$ in $\tenv$ yields the literal expression for $\vv$, that is, $\ELiteral(\vv)$;
    \item checking whether $\vv$ is an integer literal yields $\True$\ProseOrTypeError;
    \item $\vv$ is an integer literal for $\vi$;
    \item $\vp$ is the symbolic expression for $\vi$, that is, $\Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_exact\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression with identifier $\vs$, that is, $\EVar(\vs)$;
    \item looking up the constant associated with $\vs$ in $\tenv$ yields $\bot$;
    \item determining the type of $\vs$ yields $\vt$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vt$ is $\ttyone$\ProseOrTypeError;
    \item checking whether $\ttyone$ is an integer type yields $\True$\ProseOrTypeError;
    \item $\ttyone$ is a well-constrained integer with the exact constraint $\ve$, that is, \\ $\TInt(\wellconstrained([\ConstraintExact(\ve)]))$;
    \item converting $\ve$ to a symbolic expression yields $\vp$ (which may possibly be $\bot$).
  \end{itemize}

  \item All of the following apply (\textsc{int\_var}):
  \begin{itemize}
    \item $\ve$ is a variable expression with identifier $\vs$, that is, $\EVar(\vs)$;
    \item looking up the constant associated with $\vs$ in $\tenv$ yields $\bot$;
    \item determining the type of $\vs$ yields $\vt$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vt$ is $\ttyone$\ProseOrTypeError;
    \item checking whether $\ttyone$ is an integer type yields $\True$\ProseOrTypeError;
    \item $\ttyone$ is not a well-constrained integer with a single exact constraint;
    \item $\vp$ is the symbolic expression for the variable $\vs$, that is, $\Sum( \{ \Prod(\{\vs\mapsto 1\})\mapsto 1 \} )$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_plus}):
  \begin{itemize}
    \item $\ve$ is a binary addition expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\PLUS, \veone, \vetwo)$;
    \item converting $\veone$ to a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeErrorOrBot;
    \item converting $\vetwo$ to a symbolic expression in $\tenv$ yields $\irtwo$\ProseOrTypeErrorOrBot;
    \item $\vp$ is the symbolic expression adding up $\irone$ and $\irtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_minus}):
  \begin{itemize}
    \item $\ve$ is a binary subtraction expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\MINUS, \veone, \vetwo)$;
    \item $\vep$ is the subtraction expression with operands $\veone$ and the negation of $\vetwo$, that is, \\ $\EBinop(\MINUS, \veone, \EUnop(\MINUS, \vetwo))$;
    \item converting $\vpp$ into a symbolic expression in $\tenv$ yields $\vp$\ProseOrTypeErrorOrBot.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_mul}):
  \begin{itemize}
    \item $\ve$ is a binary multiplication expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\MUL, \veone, \vetwo)$;
    \item converting $\veone$ to a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeErrorOrBot;
    \item converting $\vetwo$ to a symbolic expression in $\tenv$ yields $\irtwo$\ProseOrTypeErrorOrBot;
    \item $\vp$ is the symbolic expression multiplying $\irone$ and $\irtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_div\_non\_int\_denominator}):
  \begin{itemize}
    \item $\ve$ is a binary division expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\DIV, \veone, \vetwo)$;
    \item $\vetwo$ is not an integer literal expression;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_div\_int\_denominator}):
  \begin{itemize}
    \item $\ve$ is a binary division expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\DIV, \veone, \vetwo)$;
    \item $\vetwo$ is an integer literal expression for $\vitwo$;
    \item converting $\veone$ to a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeErrorOrBot;
    \item $\vftwo$ is $\frac{1}{\vitwo}$;
    \item $\vp$ is the polynomial $\irone$ with each monomial multiplied by $\vftwo$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_shl\_non\_lint\_exponent}):
  \begin{itemize}
    \item $\ve$ is a binary shift-left expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\SHL, \veone, \vetwo)$;
    \item $\vetwo$ is not an integer literal expression;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_shl\_non\_neg\_shift}):
  \begin{itemize}
    \item $\ve$ is a binary shift-left expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\SHL, \veone, \vetwo)$;
    \item $\vetwo$ is an integer literal expression for $\vitwo$;
    \item $\vitwo$ is negative;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_shl\_okay}):
  \begin{itemize}
    \item $\ve$ is a binary shift-left expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\SHL, \veone, \vetwo)$;
    \item $\vetwo$ is an integer literal expression for $\vitwo$;
    \item converting $\veone$ to a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeErrorOrBot;
    \item $\vitwo$ is non-negative;
    \item $\vftwo$ is $2^{\vitwo}$;
    \item $\vp$ is the polynomial $\irone$ with each monomial multiplied by $\vftwo$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_other\_non\_literals}):
  \begin{itemize}
    \item $\ve$ is a binary expression with an operator $\op$ that is other than $\PLUS$, $\MINUS$, $\MUL$, or $\SHL$,
          applied to the operand expressions $\veone$ and $\vetwo$;
    \item at least one of $\veone$ and $\vetwo$ is not a literal expression;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_other\_literals\_non\_int\_result}):
  \begin{itemize}
    \item $\ve$ is a binary expression with an operator $\op$ that is other than $\PLUS$, $\MINUS$, $\MUL$, $\DIV$, or $\SHL$,
          applied to the operand expressions $\veone$ and $\vetwo$;
    \item $\veone$ is the literal expression for literal $\vlone$;
    \item $\vetwo$ is the literal expression for literal $\vltwo$;
    \item statically applying $\op$ to $\vlone$ and $\vltwo$ yields the literal $\vl$, which is not an integer literal;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_other\_literals\_int\_result}):
  \begin{itemize}
    \item $\ve$ is a binary expression with an operator $\op$ that is other than $\PLUS$, $\MINUS$, $\MUL$, or $\SHL$,
          applied to the operand expressions $\veone$ and $\vetwo$;
    \item $\veone$ is the literal expression for literal $\vlone$;
    \item $\vetwo$ is the literal expression for literal $\vltwo$;
    \item statically applying $\op$ to $\vlone$ and $\vltwo$ yields the integer literal for $k$;
    \item $\vp$ is the symbolic expression for the integer $k$, that is, $\Sum( \{ \Prod(\emptyfunc)\mapsto k \} )$.
  \end{itemize}

  \item All of the following apply (\textsc{eunop\_neg}):
  \begin{itemize}
    \item $\ve$ is a unary expression with the negation operator $\NEG$ and operand $\veone$;
    \item converting the binary expression with operator $\MUL$ and left-hand-side operand for the integer literal $-1$ and
    right-hand-side operand $\veone$ in $\tenv$ yields $\vp$\ProseOrTypeErrorOrBot.
  \end{itemize}

  \item All of the following apply (\textsc{eunop\_other}):
  \begin{itemize}
    \item $\ve$ is a unary expression with an operator other than $\NEG$;
    \item $\vp$ is bottom
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\ve$ is an expression with a label other than $\ELiteral$, $\EVar$, $\EBinop$, and $\EUnop$;
    \item $\vp$ is bottom
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[literal\_int]{}
{
  \toircase(\tenv, \overname{\ELiteral(\lint(\vi))}{\ve}) \typearrow \overname{\Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )}{\vp}
}
\and
\inferrule[literal\_other]{
  \astlabel(\vv) \neq \lint
}{
  \toircase(\tenv, \overname{\ELiteral(\vv)}{\ve}) \typearrow \CannotBeTransformed
}
\and
\inferrule[int\_constant]{
  \lookupconstant(\tenv, \vs) \typearrow \ELiteral(\vv)\\
  \checktrans{\astlabel(\vv) = \lint}{ExpectedIntegerLiteral} \typearrow \True \OrTypeError\\\\
  \vv \eqname \lint(\vi)
}{
  \toircase(\tenv, \overname{\EVar(\vs)}{\ve}) \typearrow \overname{\Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )}{\vp}
}
\and
\inferrule[int\_exact\_constraint]{
  \lookupconstant(\tenv, \vs) \typearrow \CannotBeTransformed\\
  \typeof(\vs) \typearrow \vt \OrTypeError\\\\
  \makeanonymous(\vt) \typearrow \ttyone \OrTypeError\\\\
  \checktrans{\astlabel(\ttyone) = \TInt}{ExpectedIntegerType} \typearrow \True \OrTypeError\\\\
  \ttyone = \TInt(\wellconstrained([\ConstraintExact(\ve)]))\\
  \toir(\ve) \typearrow \vp
}{
  \toircase(\tenv, \overname{\EVar(\vs)}{\ve}) \typearrow \vp
}
\and
\inferrule[int\_var]{
  \lookupconstant(\tenv, \vs) \typearrow \CannotBeTransformed\\
  \typeof(\vs) \typearrow \vt\\
  \makeanonymous(\vt) \typearrow \ttyone\\
  \checktrans{\astlabel(\ttyone) = \TInt}{ExpectedIntegerType} \typearrow \True\\
  \ttyone \neq \TInt(\wellconstrained([\ConstraintExact(\Ignore)]))
}{
  \toircase(\tenv, \overname{\EVar(\vs)}{\ve}) \typearrow \overname{\Sum( \{ \Prod(\{\vs\mapsto 1\})\mapsto 1 \} )}{\vp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_plus]{
  \toir(\tenv, \veone) \typearrow \irone \OrTypeError, \CannotBeTransformed\\\\
  \toir(\tenv, \vetwo) \typearrow \irtwo \OrTypeError, \CannotBeTransformed\\\\
  \vp \eqdef \addpolynomials(\irone, \irtwo)
}{
  \toircase(\tenv, \overname{\EBinop(\PLUS, \veone, \vetwo)}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_minus]{
  \vep \eqdef \EBinop(\PLUS, \veone, \EUnop(\MINUS, \vetwo))\\
  \toir(\tenv, \vpp) \typearrow \vp \OrTypeError, \CannotBeTransformed\\\\
}{
  \toircase(\tenv, \overname{\EBinop(\MINUS, \veone, \vetwo)}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_mul]{
  \toir(\tenv, \veone) \typearrow \irone \OrTypeError, \CannotBeTransformed\\\\
  \toir(\tenv, \vetwo) \typearrow \irtwo \OrTypeError, \CannotBeTransformed\\\\
  \vp \eqdef \mulpolynomials(\irone, \irtwo)
}{
  \toircase(\tenv, \overname{\EBinop(\MUL, \veone, \vetwo)}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_div\_non\_int\_denominator]{
  \vetwo \neq \ELiteral(\lint(\Ignore))
}{
  \toircase(\tenv, \overname{\EBinop(\DIV, \veone, \vetwo)}{\ve}) \typearrow \CannotBeTransformed
}
\and
\inferrule[ebinop\_div\_int\_denominator]{
  \toir(\tenv, \veone) \typearrow \irone \OrTypeError, \CannotBeTransformed\\\\
  \vftwo \eqdef \frac{1}{\vitwo}\\
  \irone \eqname \Sum [i=1..k: \vm_\vi \mapsto \vc_\vi]\\
  \vp \eqdef \Sum [i=1..k: \vm_\vi \mapsto \vc_\vi \times \vftwo]\\
}{
  \toircase(\tenv, \overname{\EBinop(\DIV, \veone, \overname{\ELiteral(\lint(\vitwo))}{\vetwo})}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_shl\_non\_lint\_exponent]{
    \vetwo \neq \ELiteral(\lint(\Ignore))
}{
  \toircase(\tenv, \overname{\EBinop(\SHL, \Ignore, \vetwo)}{\ve}) \typearrow \CannotBeTransformed
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_shl\_neg\_shift]{
  \vitwo < 0
}{
  \toircase(\tenv, \overname{\EBinop(\SHL, \veone, \ELiteral(\lint(\vitwo)))}{\ve}) \typearrow \CannotBeTransformed
}
\and
  \inferrule[ebinop\_shl\_okay]{
    \toir(\tenv, \veone) \typearrow \irone \OrTypeError, \CannotBeTransformed\\\\
    \vitwo \geq 0\\
    \vftwo \eqdef 2^{\vitwo}\\
    \irone \eqname \Sum [i=1..k: \vm_\vi \mapsto \vc_\vi]\\
    \vp \eqdef \Sum [i=1..k: \vm_\vi \mapsto \vc_\vi \times \vftwo]\\
}{
  \toircase(\tenv, \overname{\EBinop(\SHL, \veone, \ELiteral(\lint(\vitwo)))}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_other\_non\_literals]{
  \op \not\in \{\PLUS, \MINUS, \MUL, \DIV, \SHL\}\\
  (\veone \neq \ELiteral(\Ignore) \lor \vetwo \neq \ELiteral(\Ignore))
}{
  \toircase(\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \CannotBeTransformed
}
\and
\inferrule[ebinop\_other\_literals\_non\_int\_result]{
  \op \not\in \{\PLUS, \MINUS, \MUL, \SHL\}\\
  \binopliterals(\op, \vlone, \vltwo) \typearrow \vl\\
  \vl \neq \lint(\Ignore)
}{
  \toircase(\tenv, \overname{\EBinop(\op, \ELiteral(\vlone), \ELiteral(\vltwo))}{\ve}) \typearrow \CannotBeTransformed
}
\and
\inferrule[ebinop\_other\_literals\_int\_result]{
  \op \not\in \{\PLUS, \MINUS, \MUL, \SHL\}\\
  \binopliterals(\op, \vlone, \vltwo) \typearrow \lint(k)\\
  \vp \eqdef \Sum( \{ \Prod(\emptyfunc)\mapsto k \} )
}{
  \toircase(\tenv, \overname{\EBinop(\op, \ELiteral(\vlone), \ELiteral(\vltwo))}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[eunop\_neg]{
  \toir(\tenv, \EBinop(\MUL, \ELiteral(\lint(-1)),\veone )) \typearrow \vp \OrTypeError, \CannotBeTransformed\\\\
}{
  \toircase(\tenv, \overname{\EUnop(\NEG, \veone)}{\ve}) \typearrow \vp
}
\and
\inferrule[eunop\_other]{
  \op \neq \NEG
}{
  \toircase(\tenv, \overname{\EUnop(\op, \Ignore)}{\ve}) \typearrow \CannotBeTransformed
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \not\in \{\ELiteral, \EVar, \EBinop, \EUnop\}
}{
  \toircase(\tenv, \ve) \typearrow \CannotBeTransformed
}
\end{mathpar}

\section{TypingRule.ExprEqualNorm \label{sec:TypingRule.ExprEqualNorm}}
\hypertarget{def-exprequalnorm}{}
The function
\[
  \exprequalnorm(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the expression $\veone$ is equivalent to the expression $\vetwo$ in environment $\tenv$
by attempting to transform both expressions to their symbolic expression form
and, if successful, comparing the resulting normal forms for equality.
The result is given in $\vb$ or a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{all\_supported}):
  \begin{itemize}
    \item transforming $\veone$ into a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeError;
    \item transforming $\vetwo$ into a symbolic expression in $\tenv$ yields $\irtwo$\ProseOrTypeError;
    \item $\vb$ is the result of equating $\irone$ and $\irtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{unsupported1}):
  \begin{itemize}
    \item transforming $\veone$ into a symbolic expression in $\tenv$ yields $\CannotBeTransformed$;
    \item $\vb$ is $\False$;
  \end{itemize}

  \item All of the following apply (\textsc{unsupported2}):
  \begin{itemize}
    \item transforming $\veone$ into a symbolic expression in $\tenv$ yields $\irone$;
    \item transforming $\vetwo$ into a symbolic expression in $\tenv$ yields $\CannotBeTransformed$;
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[all\_supported]{
  \toir(\veone) \typearrow \irone \OrTypeError\\\\
  \toir(\vetwo) \typearrow \irtwo \OrTypeError
}{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \overname{\irone = \irtwo}{\vb}
}
\and
\inferrule[unsupported1]{
  \toir(\veone) \typearrow \CannotBeTransformed
}{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[unsupported2]{
  \toir(\veone) \typearrow \irone\\
  \toir(\vetwo) \typearrow \CannotBeTransformed
}{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\section{TypingRule.ExprEqual \label{sec:TypingRule.ExprEqual}}
\hypertarget{def-exprequal}{}
The function
\[
  \exprequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo}) \aslto
  \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively checks whether the expression $\veone$ is equivalent to the expression $\vetwo$ in environment $\tenv$.
The result is given in $\vb$ or a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{norm\_true}):
  \begin{itemize}
    \item comparing $\veone$ to $\vetwo$ in $\tenv$ via $\exprequalnorm$ yields $\True$\ProseOrTypeError;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{norm\_false}):
  \begin{itemize}
    \item comparing $\veone$ to $\vetwo$ in $\tenv$ via $\exprequalnorm$ yields $\False$;
    \item comparing $\veone$ to $\vetwo$ by case analysis via $\exprequalcase$ yields $\vb$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[norm\_true]{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \True \OrTypeError
}{
  \exprequal(\tenv, \veone, \vetwo) \typearrow \True
}
\and
\inferrule[norm\_false]{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \False\\
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb \OrTypeError
}{
  \exprequal(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.ExprEqualCase \label{sec:TypingRule.ExprEqualCase}}
\hypertarget{def-exprequalcase}{}
The function
\[
  \exprequalcase(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
specializes the equivalence test for expressions $\veone$ and $\vetwo$ in $\tenv$
for the different types of expressions.
The result is given in $\vb$ or a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item the AST labels of $\veone$ and $\vetwo$ are different;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop}):
  \begin{itemize}
    \item $\veone$ is a binary expression with operator $\opone$ and operands $\veoneone$ and $\veonetwo$,
          that is, $\EBinop(\opone, \veoneone, \veonetwo)$;
    \item $\vetwo$ is a binary expression with operator $\optwo$ and operands $\vetwoone$ and $\vetwotwo$,
          that is, $\EBinop(\optwo, \vetwoone, \vetwotwo)$;
    \item testing the equivalence of $\veoneone$ and $\vetwoone$ in $\tenv$ yields $\vbone$\ProseOrTypeError;
    \item testing the equivalence of $\veonetwo$ and $\vetwotwo$ in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\opone$ is equal to $\optwo$ and both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_call}):
  \begin{itemize}
    \item $\veone$ is a call expression with subprogram name $\nameone$ and list of arguments $vargsone$,
          that is, $\ECall(\nameone, \vargsone, \Ignore)$;
    \item $\vetwo$ is a call expression with subprogram name $\nametwo$ and list of arguments $vargstwo$,
          that is, $\ECall(\nametwo, \vargstwo, \Ignore)$;
    \item checking whether $\nameone$ is equal to $\nametwo$ either yields $\True$ or $\False$, which short-circuits the entire rule;
    \item checking whether the lists of arguments $\vargsone$ and $\vargstwo$ have the same length yields
          $\True$ or $\False$, which short-circuits the entire rule;
    \item for each index $i$ in the list of indices for $\vargsone$, testing whether $\vargsone[i]$ is equivalent to $\vargstwo[i]$
          in $\tenv$ yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for each index $i$ in the list of indices for $\vargsone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_concat}):
  \begin{itemize}
    \item $\veone$ is a concatenation expression with $\vlone$, that is, $\EConcat(\vlone)$;
    \item $\vetwo$ is a concatenation expression with $\vltwo$, that is, $\EConcat(\vltwo)$;
    \item checking whether the lists of expressions $\vlone$ and $\vltwo$ have the same length yields
          $\True$ or $\False$, which short-circuits the entire rule;
    \item for each index $i$ in the list of indices for $\vlone$, testing whether $\vlone[i]$ is equivalent to $\vltwo[i]$
          in $\tenv$ yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for each index $i$ in the list of indices for $\vlone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_cond}):
  \begin{itemize}
    \item $\veone$ is a conditional expression with expressions $\veoneone$, $\veonetwo$, and $\veonethree$,
          that is, $\ECond(\veoneone, \veonetwo, \veonethree)$;
    \item $\vetwo$ is a conditional expression with expressions $\vetwoone$, $\vetwotwo$, and $\vetwothree$,
          that is, $\ECond(\vetwoone, \vetwotwo, \vetwothree)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbone$\ProseOrTypeError;
    \item testing whether $\veonetwo$ is equivalent to $\vetwotwo$ yields $\vbtwo$\ProseOrTypeError;
    \item testing whether $\veonethree$ is equivalent to $\vetwothree$ yields $\vbthree$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if all of $\vbone$, $\vbtwo$, and $\vbthree$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice}):
  \begin{itemize}
    \item $\veone$ is a slicing expression with expression $\veoneone$ and list of slices $\slicesone$,
          that is, $\ESlice(\veoneone, \slicesone)$;
    \item $\veone$ is a slicing expression with expression $\vetwoone$ and list of slices $\slicestwo$,
          that is, $\ESlice(\vetwoone, \slicestwo)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbone$\ProseOrTypeError;
    \item testing whether the lists of slices $\slicesone$ and $\slicestwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getarray}):
  \begin{itemize}
    \item $\veone$ is an \arrayaccess\ expression with array expression $\veoneone$ and position expression $\veonetwo$,
          that is, $\EGetArray(\veoneone, \veonetwo)$;
    \item $\vetwo$ is an \arrayaccess\ expression with array expression $\vetwoone$ and position expression $\vetwotwo$,
          that is, $\EGetArray(\vetwoone, \vetwotwo)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbone$\ProseOrTypeError;
    \item testing whether $\veonetwo$ is equivalent to $\vetwotwo$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfield}):
  \begin{itemize}
    \item $\veone$ is a field access expression with subexpression $\veoneone$ and field name $\vfieldone$,
          that is, $\EGetField(\veoneone, \vfieldone)$;
    \item $\vetwo$ is a field access expression with subexpression $\vetwoone$ and field name $\vfieldtwo$,
          that is, $\EGetField(\vetwoone, \vfieldtwo)$;
    \item $\vbone$ is $\True$ if and only if $\vfieldone$ is equal to $\vfieldtwo$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfields}):
  \begin{itemize}
    \item $\veone$ is a fields access expression with subexpression $\veoneone$ and list of field names $\vfieldsone$,
          that is, $\EGetFields(\veoneone, \vfieldsone)$;
    \item $\vetwo$ is a fields access expression with subexpression $\vetwoone$ and list of field names $\vfieldstwo$,
          that is, $\EGetFields(\vetwoone, \vfieldstwo)$;
    \item $\vbone$ is $\True$ if and only if $\vfieldsone$ is equal to $\vfieldstwo$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getitem}):
  \begin{itemize}
    \item $\veone$ is a tuple access expression with subexpression $\veoneone$ and position $\vione$,
          that is, $\EGetItem(\veoneone, \vione)$;
    \item $\vetwo$ is a tuple access expression with subexpression $\vetwoone$ and position $\vitwo$,
          that is, $\EGetItem(\vetwoone, \vitwo)$;
    \item $\vbone$ is $\True$ if and only if $\vione$ is equal to $\vitwo$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_literal}):
  \begin{itemize}
    \item $\veone$ is the literal expression with literal $\vvone$;
    \item $\vetwo$ is the literal expression with literal $\vvtwo$;
    \item $\vb$ is $\True$ if and only if $\vvone$ is equivalent to $\vvtwo$ in $\tenv$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_pattern}):
  \begin{itemize}
    \item both $\veone$ and $\vetwo$ are pattern expressions;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_record}):
  \begin{itemize}
    \item both $\veone$ and $\vetwo$ are record expressions;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_tuple}):
  \begin{itemize}
    \item $\veone$ is a tuple expression with subexpression list $\vlone$,
          that is, $\ETuple(\vlone)$;
    \item $\vetwo$ is a tuple expression with subexpression list $\vltwo$,
          that is, $\ETuple(\vltwo)$;
    \item checking whether the lengths of $\vlone$ and $\vltwo$ are equal yields either $\True$ or $\False$, which short-circuits
          the entire rule;
    \item for each index $i$ in the list of indices for $\vlone$, testing whether $\vlone[i]$ is equivalent to $\vltwo[i]$
          in $\tenv$ yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for each index $i$ in the list of indices for $\vlone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop}):
  \begin{itemize}
    \item $\veone$ is a unary operator expression with operator $\opone$ and operand expressions $\veoneone$,
          that is, $\EUnop(\opone, \veoneone)$;
    \item $\vetwo$ is a unary operator expression with operator $\optwo$ and operand expressions $\vetwoone$,
          that is, $\EUnop(\optwo, \vetwoone)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ in $\tenv$ yields $\vbone$;
    \item $\vb$ is $\True$ if and only if $\opone$ is equal to $\optwo$ and $\vbone$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unknown}):
  \begin{itemize}
    \item both $\veone$ and $\vetwo$ are $\UNKNOWN$ expressions;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_atc}):
  \begin{itemize}
    \item $\veone$ is a type assertion with subexpression with operator $\veoneone$ and type $\vtone$,
          that is, $\EATC(\veoneone, \vtone)$;
    \item $\vetwo$ is a type assertion with subexpression with operator $\vetwoone$ and type $\vttwo$,
          that is, $\EATC(\vetwoone, \vttwo)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ in $\tenv$ yields $\vbone$;
    \item testing whether $\vtone$ is equivalent to $\vttwo$ in $\tenv$ yields $\vbtwo$;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var}):
  \begin{itemize}
    \item $\veone$ is a variable expression with identifier $\nameone$, that is, $\EVar(\nameone)$;
    \item $\vetwo$ is a variable expression with identifier $\nametwo$, that is, $\EVar(\nametwo)$;
    \item $\vb$ is $\True$ if and only if both $\nameone$ is equal to $\nametwo$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\veone) \neq \astlabel(\vetwo)
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{
  \veone \eqname \EBinop(\opone, \veoneone, \veonetwo)\\
  \vetwo \eqname \EBinop(\optwo, \vetwoone, \vetwotwo)\\
  \exprequal(\veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\veonetwo, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef (\opone = \optwo) \land \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

(Recall that a conjunction over an empty set equals $\True$.)
\begin{mathpar}
\inferrule[e\_call]{
  \veone \eqname \ECall(\nameone, \vargsone, \Ignore)\\
  \vetwo \eqname \ECall(\nametwo, \vargstwo, \Ignore)\\\\
  \booltrans{\nameone = \nametwo} \booltransarrow \True \terminateas \False\\\\
  \equallength(\vargsone, \vargstwo) \typearrow \True \terminateas \False\\\\
  i \in \listrange(\vargsone): \exprequal(\tenv, \vargsone[i], \vargstwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vargsone)} \vb_i
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_concat]{
  \veone \eqname \EConcat(\vlone)\\
  \vetwo \eqname \EConcat(\vltwo)\\\\
  \equallength(\vlone, \vltwo) \typearrow \True \terminateas \False\\\\
  i \in \listrange(\vlone): \exprequal(\tenv, \vlone[i], \vltwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vlone)} \vb_i
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{
  \veone \eqname \ECond(\veoneone, \veonetwo, \veonethree)\\
  \vetwo \eqname \ECond(\vetwoone, \vetwotwo, \vetwothree)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \exprequal(\tenv, \veonethree, \vetwothree) \typearrow \vbthree \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_slice]{
  \veone \eqname \ESlice(\veoneone, \slicesone)\\
  \vetwo \eqname \ESlice(\vetwoone, \slicestwo)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getarray]{
  \veone \eqname \EGetArray(\veoneone, \veonetwo)\\
  \vetwo \eqname \EGetArray(\vetwoone, \vetwotwo)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getfield]{
  \veone \eqname \EGetField(\veoneone, \vfieldone)\\
  \vetwo \eqname \EGetField(\vetwoone, \vfieldtwo)\\\\
  \vbone \eqdef \vfieldone = \vfieldtwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getfields]{
  \veone \eqname \EGetFields(\veoneone, \vfieldsone)\\
  \vetwo \eqname \EGetFields(\vetwoone, \vfieldstwo)\\\\
  \vbone \eqdef \vfieldsone = \vfieldstwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getitem]{
  \veone \eqname \EGetItem(\veoneone, \vione)\\
  \vetwo \eqname \EGetItem(\vetwoone, \vitwo)\\\\
  \vbone \eqdef \vione = \vitwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_literal]{
  \veone \eqname \ELiteral(\vvone)\\
  \vetwo \eqname \ELiteral(\vvtwo)\\\\
  \literalequal(\vvone, \vvtwo) \typearrow \vb
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern]{
  \astlabel(\veone) = \EPattern \land \astlabel(\vetwo) = \EPattern
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record]{
  \astlabel(\veone) = \ERecord \land \astlabel(\vetwo) = \ERecord
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_tuple]{
  \veone \eqname \ETuple(\vlone)\\
  \vetwo \eqname \ETuple(\vltwo)\\
  \equallength(\vlone, \vltwo) \typearrow \True \terminateas \False\\\\
  i \in \listrange(\vlone): \exprequal(\tenv, \vlone[i], \vltwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vlone)} \vb_i
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{
  \veone \eqname \EUnop(\opone, \veoneone)\\
  \vetwo \eqname \EUnop(\optwo, \vetwoone)\\\\
  \exprequal(\veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \vb \eqdef (\opone = \optwo) \land \vbone
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unknown]{
  (\astlabel(\veone) = \EUnknown \land \astlabel(\vetwo) = \EUnknown)
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_atc]{
  \veone \eqname \EATC(\veoneone, \vtone)\\
  \vetwo \eqname \EATC(\vetwoone, \vttwo)\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var]{
  \veone \eqname \EVar(\nameone)\\
  \vetwo \eqname \EVar(\nametwo)\\\\
  \vb \eqdef \nameone = \nametwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

%   | E_Pattern _, _ | E_Record _, _ -> assert false

\section{TypingRule.TypeEqual \label{sec:TypingRule.TypeEqual}}
\hypertarget{def-typeequal}{}
The function
\[
  \typeequal(\overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo}) \aslto
   \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the type $\vtone$ is equivalent to the type $\vttwo$ in environment $\tenv$
and yields the result in $\vb$.  \ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item the AST labels of $\vtone$ and $\vttwo$ are different;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{tbool\_treal\_tstring}):
  \begin{itemize}
    \item both $\vtone$ and $\vttwo$ are both either $\TBool$, $\TReal$, or $\TString$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tint\_unconstrained}):
  \begin{itemize}
    \item both $\vtone$ and $\vttwo$ are the unconstrained integer type $\unconstrainedinteger$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tint\_parameterized}):
  \begin{itemize}
    \item $\vtone$ is the \parameterizedintegertype\  with identifier $\vione$, that is, \\ $\TInt(\parameterized(\vione))$;
    \item $\vttwo$ is the \parameterizedintegertype\ with identifier $\vitwo$, that is, \\ $\TInt(\parameterized(\vitwo))$;
    \item $\vb$ is $\True$ if and only if $\vione$ is equal to $\vitwo$.
  \end{itemize}

  \item All of the following apply (\textsc{tint\_wellconstrained}):
  \begin{itemize}
    \item $\vtone$ is the well-constrained integer type with list of constraints $\vcone$, that is, \\ $\TInt(\wellconstrained(\vcone))$;
    \item $\vttwo$ is the well-constrained integer type with list of constraints $\vctwo$, that is, \\ $\TInt(\wellconstrained(\vctwo))$;
    \item testing whether $\vcone$ and $\vctwo$ are equivalent in $\tenv$ yields $\vb$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{tbits}):
  \begin{itemize}
    \item $\vtone$ is the bitvector type with width expression $\vwone$ and list of bitfields $\bfone$, that is, $\TBits(\vwone, \bfone)$;
    \item $\vttwo$ is the bitvector type with width expression $\vwtwo$ and list of bitfields $\bftwo$, that is, $\TBits(\vwtwo, \bftwo)$;
    \item testing whether $\vwone$ and $\vwtwo$ are equivalent bitwidths in $\tenv$ yields $\vbone$\ProseOrTypeError;
    \item testing whether $\bfone$ and $\bftwo$ are equivalent lists of bitfields in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tarray}):
  \begin{itemize}
    \item $\vtone$ is an array type with index $\vlone$ and element type $\vtone$, that is, $\TArray(\vlone, \vtone)$;
    \item $\vttwo$ is an array type with index $\vltwo$ and element type $\vttwo$, that is, $\TArray(\vltwo, \vttwo)$;
    \item testing whether $\vlone$ is equivalent to $\vltwo$ in $\tenv$ yields $\vbone$\ProseOrTypeError;
    \item testing whether $\vtone$ is equivalent to $\vttwo$ in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tnamed}):
  \begin{itemize}
    \item $\vtone$ is a named type with identifier $\vsone$, that is $\TNamed(\vsone)$;
    \item $\vttwo$ is a named type with identifier $\vstwo$, that is $\TNamed(\vstwo)$;
    \item $\vb$ is $\True$ if and only if $\vsone$ is equal to $\vstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{tenum}):
  \begin{itemize}
    \item $\vtone$ is an enumeration type with identifier $\vlone$, that is $\TEnum(\vlone)$;
    \item $\vttwo$ is an enumeration type with identifier $\vltwo$, that is $\TEnum(\vltwo)$;
    \item $\vb$ is $\True$ if and only if $\vlone$ is equal to $\vltwo$.
  \end{itemize}

  \item All of the following apply (\textsc{tstructured}):
  \begin{itemize}
    \item $L$ is either $\TRecord$ or $\TException$;
    \item $\vtone$ is a \structuredtype\ with list of fields $\vfieldsone$, that is $L(\vfieldsone)$;
    \item $\vttwo$ is a \structuredtype\ with list of fields $\vfieldstwo$, that is $L(\vfieldstwo)$;
    \item checking whether the set of field names in $\vfieldsone$ is equal to the set of field names in $\vfieldstwo$
          yields $\True$ or $\False$, which short-circuits the entire rule;
    \item for each field $\vf$ in the set of fields of $\vfieldsone$, testing whether the type associated with
          $\vf$ in $\vfieldsone$ is equivalent to the type associated with
          $\vf$ in $\vfieldstwo$ in $\tenv$ yields $\vb_\vf$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_\vf$ is $\True$ for each field $\vf$ in the set of fields of $\vfieldsone$.
  \end{itemize}

  \item All of the following apply (\textsc{ttuple}):
  \begin{itemize}
    \item $\vtone$ is a tuple type with list of types $\vtsone$, that is $\TTuple(\vtsone)$;
    \item $\vttwo$ is a tuple type with list of types $\vtstwo$, that is $\TTuple(\vtstwo)$;
    \item checking whether the list of types $\vtsone$ has the same length as the list of types $\vtstwo$ yields $\True$
          or $\False$, which short-circuits the entire rule;
    \item for each index $i$ in the list $\vtsone$, testing whether $\vtsone[i]$ is equivalent to $\vtstwo[i]$ in $\tenv$
          yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for each index $i$ in the list $\vtsone$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\vtone) \neq \astlabel(\vttwo)
}{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[TBool\_TReal\_TString]{
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \in \{\TBool, \TReal, \TString\}
}{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \True
}
\and
\end{mathpar}

\begin{mathpar}
\inferrule[tint\_unconstrained]{}
{
  \typeequal(\tenv, \unconstrainedinteger, \unconstrainedinteger) \typearrow \True
}
\and
\inferrule[tint\_parameterized]{
  \vb \eqdef \vione = \vitwo
}{
  \typeequal(\tenv, \TInt(\parameterized(\vione)), \TInt(\parameterized(\vitwo))) \typearrow \vb
}
\and
\inferrule[tint\_wellconstrained]{
  \constraintsequal(\tenv, \vcone, \vctwo) \typearrow \vb \OrTypeError
}{
  \typeequal(\tenv, \TInt(\wellconstrained(\vcone)), \TInt(\wellconstrained(\vctwo))) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tbits]{
  \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vbone \OrTypeError\\\\
  \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \typeequal(\tenv, \TBits(\vwone, \bfone), \TBits(\vwtwo, \bftwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tarray]{
  \exprequal(\tenv, \vlone, \vltwo) \typearrow \vbone \OrTypeError\\\\
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \typeequal(\tenv, \TArray(\vlone, \vtone), \TArray(\vltwo, \vttwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tnamed]{
  \vb \eqdef \vsone = \vstwo
}{
  \typeequal(\tenv, \TNamed(\vsone), \TNamed(\vstwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tenum]{
  \vb \eqdef \vlone = \vltwo
}{
  \typeequal(\tenv, \TEnum(\vlone), \TEnum(\vltwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tstructured]{
  L \in \{\TRecord, \TException\}\\
  \booltrans{\fieldnames(\vfieldsone) = \fieldnames(\vfieldstwo)} \booltransarrow \True \terminateas \False\\\\
  {
    \begin{array}{l}
  \vf \in \fieldnames(\vfieldsone): \\ \typeequal(\tenv, \fieldtype(\vfieldsone, \vf), \fieldtype(\vfieldstwo, \vf)) \typearrow \vb_\vf \OrTypeError
    \end{array}
  }\\\\
  \vb \eqdef \bigwedge_{\vf \in \fieldnames(\vfieldsone)} \vb_\vf
}{
  \typeequal(\tenv, L(\vfieldsone), L(\vfieldstwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[ttuple]{
  \equallength(\vtsone, \vtstwo) \typearrow \True \terminateas \False\\
  i \in \listrange(\vtsone): \typeequal(\tenv, \vtsone[i], \vtstwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vtsone)} \vb_i
}{
  \typeequal(\tenv, \TTuple(\vtsone), \TTuple(\vtstwo)) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.BitwidthEqual \label{sec:TypingRule.BitwidthEqual}}
\hypertarget{def-bitwidthequal}{}
The function
\[
  \bitwidthequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\vwone} \aslsep \overname{\expr}{\vwtwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the bitwidth expression $\vwone$ is equivalent to the bitwidth expression $\vwtwo$
in environment $\tenv$ and yields the result in $\vb$.  \ProseOtherwiseTypeError

\subsection{Prose}
Testing whether the expressions $\vwone$ and $\vwtwo$ are equivalent in $\tenv$ yields $\vb$\ProseOrTypeError.

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \exprequal(\tenv, \vwone, \vwtwo) \typearrow \vb \OrTypeError
}{
  \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.BitFieldsEqual \label{sec:TypingRule.BitFieldsEqual}}
\hypertarget{def-bitfieldsequal}{}
The function
\[
  \bitfieldsequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield^*}{\bfone} \aslsep \overname{\bitfield^*}{\bftwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the list of bitfields $\bfone$ is equivalent to the list of bitfields $\bftwo$
in environment $\tenv$ and yields the result in $\vb$.  \ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_lengths}):
  \begin{itemize}
    \item the number of bitfields in $\bfone$ is different from the number of bitfields in $\bftwo$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{same\_lengths}):
  \begin{itemize}
    \item the number of bitfields in $\bfone$ is the same as the number of bitfields in $\bftwo$;
    \item testing whether the bitfield $\bfone[i]$ is equivalent to $\bftwo[i]$ in $\tenv$ for every index
          of $\bfone$ yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for every index of $\bfone$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_lengths]{
  \equallength(\bfone, \bftwo) \typearrow \False
}{
  \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \False
}
\and
\inferrule[same\_lengths]{
  \equallength(\bfone, \bftwo) \typearrow \True\\
  i\in\listrange(\bfone): \bitfieldequal(\tenv, \bfone[i], \bftwo[i]) \typearrow \vb_i\\\\
  \vb \eqdef \bigwedge_{i\in\listrange(\bfone)} \vb_i
}{
  \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.BitFieldEqual \label{sec:TypingRule.BitFieldEqual}}
The function
\[
  \bitfieldequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield}{\bfone} \aslsep \overname{\bitfield}{\bftwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the bitfield $\bfone$ is equivalent to the bitfield $\bftwo$ in environment $\tenv$
and yields the result in $\vb$.  \ProseOtherwiseTypeError

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item the AST labels of $\bfone$ and $\bftwo$ are different;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{bitfield\_simple}):
  \begin{itemize}
    \item $\bfone$ is a simple bitfield with name $\nameone$ and list of slices $\slicesone$, that is, \\ $\BitFieldSimple(\nameone, \slicesone)$;
    \item $\bftwo$ is a simple bitfield with name $\nametwo$ and list of slices $\slicestwo$, that is, \\ $\BitFieldSimple(\nametwo, \slicestwo)$;
    \item checking whether $\nameone$ is equal to $\nametwo$ yields $\vbone$;
    \item testing whether $\slicesone$ and $\slicestwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{bitfield\_nested}):
  \begin{itemize}
    \item $\bfone$ is a nested bitfield with name $\nameone$, list of slices $\slicesone$, and nested bitfields $\bfoneone$, that is,
          $\BitFieldNested(\nameone, \slicesone, \bfoneone)$;
    \item $\bftwo$ is a nested bitfield with name $\nametwo$, list of slices $\slicestwo$, and nested bitfields $\bftwoone$, that is,
          $\BitFieldNested(\nametwo, \slicestwo, \bftwoone)$;
    \item checking whether $\nameone$ is equal to $\nametwo$ yields $\vbone$;
    \item testing whether $\slicesone$ and $\slicestwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item testing whether the bitfields $\bfoneone$ and $\bftwoone$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{bitfield\_typed}):
  \begin{itemize}
    \item $\bfone$ is a typed bitfield with name $\nameone$, list of slices $\slicesone$, and type $\vtone$, that is,
          $\BitFieldType(\nameone, \slicesone, \vtone)$;
    \item $\bftwo$ is a typed bitfield with name $\nametwo$, list of slices $\slicestwo$, and type $\vttwo$, that is,
          $\BitFieldType(\nametwo, \slicestwo, \vttwo)$;
    \item checking whether $\nameone$ is equal to $\nametwo$ yields $\vbone$;
    \item testing whether $\slicesone$ and $\slicestwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item testing whether the types $\vtone$ and $\vttwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\bfone) \neq \astlabel(\bftwo)
}{
  \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \False
}
\and
\inferrule[bitfield\_simple]{
  \bfone \eqname \BitFieldSimple(\nameone, \slicesone)\\
  \bftwo \eqname \BitFieldSimple(\nametwo, \slicestwo)\\
  \booltrans{\nameone = \nametwo} \booltransarrow \vbone\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\and
\inferrule[bitfield\_nested]{
  \bfone \eqname \BitFieldNested(\nameone, \slicesone, \bfoneone)\\
  \bftwo \eqname \BitFieldNested(\nametwo, \slicestwo, \bftwoone)\\
  \booltrans{\nameone = \nametwo} \booltransarrow \True \terminateas \False\\\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbone \terminateas \TypeErrorConfig,\\\\
  \bitfieldsequal(\tenv, \bfoneone, \bftwoone) \typearrow \vbtwo
}{
  \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\and
\inferrule[bitfield\_typed]{
  \bfone \eqname \BitFieldType(\nameone, \slicesone, \vtone)\\
  \bftwo \eqname \BitFieldType(\nametwo, \slicestwo, \vttwo)\\
  \booltrans{\nameone = \nametwo} \booltransarrow \True \terminateas \False \\\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbone \OrTypeError\\\\
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.ConstraintsEqual \label{sec:TypingRule.ConstraintsEqual}}
\hypertarget{def-constraintsequal}{}
The function
\[
  \constraintsequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint^*}{\csone} \aslsep \overname{\intconstraint^*}{\cstwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the constraint list $\csone$ is equivalent to the constraint list $\cstwo$ in environment $\tenv$
and yields the result in $\vb$.  \ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_lengths}):
  \begin{itemize}
    \item the number of constraints in $\csone$ is different from the number of constraints in $\cstwo$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{same\_lengths}):
  \begin{itemize}
    \item the number of constraints in $\csone$ is the same as the number of constraints in $\cstwo$;
    \item testing whether the constraint $\csone[i]$ is equivalent to the constraint $\cstwo[i]$ in $\tenv$
          yields $\vb_i$ for each index in the index in the indices for $\csone$ ($i\in\listrange(\csone)$)\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if all $\vb_i$ are $\True$ for each index in the indices for $\csone$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_lengths]{
  \equallength(\csone, \cstwo) \typearrow \False
}{
  \constraintsequal(\tenv, \csone, \cstwo) \typearrow \False
}
\and
\inferrule[same\_lengths]{
  \equallength(\csone, \cstwo) \typearrow \True\\
  i\in\listrange(\csone): \constraintequal(\tenv, \csone[i], \cstwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i\in\listrange(\csone)} \vb_i
}{
  \constraintsequal(\tenv, \csone, \cstwo) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.ConstraintEqual \label{sec:TypingRule.ConstraintEqual}}
\hypertarget{def-constraintequal}{}
The function
\[
  \constraintequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vstwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the constraint $\vcone$ is equivalent to the constraint $\vctwo$ in environment $\tenv$
and yields the result in $\vb$.  \ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item the AST labels of $\vcone$ and $\vctwo$ are different;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_exact}):
  \begin{itemize}
    \item $\vcone$ is an exact constraint with subexpression $\veone$, that is, $\ConstraintExact(\veone)$;
    \item $\vctwo$ is an exact constraint with subexpression $\vetwo$, that is, $\ConstraintExact(\vetwo)$;
    \item applying $\exprequal$ to $\veone$ and $\vetwo$ yields $\vb$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_range}):
  \begin{itemize}
    \item $\vcone$ is a range constraint with subexpressions $\veoneone$ and $\veonetwo$, that is, \\ $\ConstraintRange(\veoneone, \veonetwo)$;
    \item $\vctwo$ is a range constraint with subexpressions $\vetwoone$ and $\vetwotwo$, that is, \\ $\ConstraintRange(\vetwoone, \vetwotwo)$;
    \item applying $\exprequal$ to $\veoneone$ and $\vetwoone$ yields $\vbone$\ProseOrTypeError;
    \item applying $\exprequal$ to $\veonetwo$ and $\vetwotwo$ yields $\vbtwo$\ProseOrTypeError;
    \item define $\vb$ as $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\vcone) \neq \astlabel(\vctwo)
}{
  \constraintequal(\tenv, \vcone, \vctwo) \typearrow \False
}
\and
\inferrule[constraint\_exact]{
  \vcone \eqname \ConstraintExact(\veone)\\
  \vctwo \eqname \ConstraintExact(\vetwo)\\
  \exprequal(\tenv, \veone, \vetwo) \typearrow \vb \OrTypeError
}{
  \constraintequal(\tenv, \vcone, \vctwo) \typearrow \vb
}
\and
\inferrule[constraint\_range]{
  \bfone \eqname \ConstraintRange(\veoneone, \veonetwo)\\
  \bftwo \eqname \ConstraintRange(\vetwoone, \vetwotwo)\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \constraintequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.SlicesEqual \label{sec:TypingRule.SlicesEqual}}
\hypertarget{def-slicesequal}{}
The function
\[
  \slicesequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slicesone} \aslsep \overname{\slice^*}{\slicestwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the list of slices $\slicesone$ is equivalent to the list of slices $\slicestwo$
in environment $\tenv$ and yields the result in $\vb$.  \ProseOtherwiseTypeError

\subsection{Formally}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_lengths}):
  \begin{itemize}
    \item checking whether the number of slices in $\slicesone$ is equal to the number of slice in $\slicestwo$ yields $\False$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{same\_lengths}):
  \begin{itemize}
    \item checking whether the number of slices in $\slicesone$ is equal to the number of slice in $\slicestwo$ yields $\True$;
    \item determining whether the expression $\slicesone[i]$ is equivalent to $\slicestwo[i]$ in $\tenv$
          for each index in the indices for $\slicesone$ ($i \in \listrange(\slicesone$) yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if all $\vb_i$ are $\True$ for each index in the indices for $\slicesone$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_lengths]{
  \equallength(\slicesone, \slicestwo) \typearrow \False
}{
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \False
}
\and
\inferrule[same\_lengths]{
  \equallength(\slicesone, \slicestwo) \typearrow \True\\
  i\in\listrange(\slicesone): \sliceequal(\tenv, \slicesone[i], \slicestwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i\in\listrange(\slicesone)} \vb_i
}{
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.SliceEqual \label{sec:TypingRule.SliceEqual}}
\hypertarget{def-sliceequal}{}
The function
\[
  \sliceequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\sliceone} \aslsep \overname{\slice}{\slicetwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the slice $\sliceone$ is equivalent to the slice $\slicetwo$
in environment $\tenv$ and yields the result in $\vb$. \ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item $\sliceone$ and $\slicetwo$ have different AST labels;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{slice\_single}):
  \begin{itemize}
    \item $\sliceone$ is a slice for a single position, given by the expression $\veone$, that is, $\SliceSingle(\veone)$;
    \item $\slicetwo$ is a slice for a single position, given by the expression $\vetwo$, that is, $\SliceSingle(\vetwo)$;
    \item testing $\veone$ and $\vetwo$ for equivalence yields $\vb$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{slice\_range}):
  \begin{itemize}
    \item $\sliceone$ is a slice for a range of positions, given by the expressions $\veoneone$ and $\veonetwo$, that is, $\SliceRange(\veoneone, \veonetwo)$;
    \item $\slicetwo$ is a slice for a range of positions, given by the expressions $\vetwoone$ and $\vetwotwo$, that is, $\SliceRange(\vetwoone, \vetwotwo)$;
    \item testing $\veoneone$ and $\vetwoone$ for equivalence yields $\vbone$\ProseOrTypeError;
    \item testing $\veonetwo$ and $\vetwotwo$ for equivalence yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{slice\_length}):
  \begin{itemize}
    \item $\sliceone$ is a slice for a range of positions, given by the start expression $\veoneone$ and length expression $\veonetwo$, that is, $\SliceLength(\veoneone, \veonetwo)$;
    \item $\slicetwo$ is a slice for a range of positions, given by the start expression $\vetwoone$ and length expression $\vetwotwo$, that is, $\SliceLength(\vetwoone, \vetwotwo)$;
    \item testing $\veoneone$ and $\vetwoone$ for equivalence yields $\vbone$\ProseOrTypeError;
    \item testing $\veonetwo$ and $\vetwotwo$ for equivalence yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_label]{
  \astlabel(\sliceone) \neq \astlabel(\slicetwo)
}{
  \slicesequal(\tenv, \sliceone, \slicetwo) \typearrow \False
}
\and
\inferrule[slice\_single]{
  \exprequal(\tenv, \veone, \vetwo) \typearrow \vb \OrTypeError
}{
  \slicesequal(\tenv, \SliceSingle(\veone), \SliceSingle(\vetwo)) \typearrow \vb
}
\and
\inferrule[slice\_range]{
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \vetwoone, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \slicesequal(\tenv, \SliceRange(\veoneone, \veonetwo), \SliceRange(\vetwoone, \vetwotwo)) \typearrow \vb
}
\and
\inferrule[slice\_length]{
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \vetwoone, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \slicesequal(\tenv, \SliceLength(\veoneone, \veonetwo), \SliceLength(\vetwoone, \vetwotwo)) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.ArrayLengthEqual \label{sec:TypingRule.ArrayLengthEqual}}
\hypertarget{def-arraylengthequal}{}
The function
\[
  \arraylengthequal(\overname{\arrayindex}{\vlone} \aslsep \overname{\arrayindex}{\vltwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the array lengths $\vlone$ and $\vltwo$ are equivalent and yields the result
in $\vb$. \ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item $\vlone$ and $\vltwo$ have different AST labels;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{expr\_expr}):
  \begin{itemize}
    \item $\vlone$ is an integer type length expression with subexpression $\veoneone$, that is, \\ $\ArrayLengthExpr(\veoneone)$;
    \item $\vltwo$ is an integer type length expression with subexpression $\vetwoone$, that is, \\ $\ArrayLengthExpr(\vetwoone)$;
    \item testing whether $\veoneone$ and $\vetwoone$ are equivalent in $\tenv$ yields $\vb$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{enum\_enum}):
  \begin{itemize}
    \item $\vlone$ is an enumeration type length expression over the enumeration $\vsone$, that is, $\ArrayLengthEnum(\vsone, \Ignore)$;
    \item $\vltwo$ is an enumeration type length expression over the enumeration $\vstwo$, that is, $\ArrayLengthEnum(\vstwo, \Ignore)$;
    \item $\vb$ is $\True$ if and only if $\vsone$ is equal to $\vstwo$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\vlone) \neq \astlabel(\vltwo)
}{
  \arraylengthequal(\vlone, \vltwo) \typearrow \False
}
\and
  \inferrule[expr\_expr]{
  \exprequal(\veoneone, \vetwoone) \typearrow \vb \OrTypeError
}{
  \arraylengthequal(\ArrayLengthExpr(\veoneone), \ArrayLengthExpr(\vetwoone)) \typearrow \vb
}
\and
\inferrule[enum\_enum]{
  \vb \eqdef \vsone = \vstwo
}{
  \arraylengthequal(\ArrayLengthEnum(\vsone, \Ignore), \ArrayLengthEnum(\vstwo, \Ignore)) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.LiteralEqual \label{sec:TypingRule.LiteralEqual}}
\hypertarget{def-literalequal}{}
The function
\[
  \literalequal(\overname{\literal}{\vvone} \aslsep \overname{\literal}{\vvtwo}) \rightarrow \overname{\{\True, \False\}}{\vb}
\]
tests whether literal $\vvone$ is $\vvtwo$ by equating them.

\subsection{Prose}
$\vb$ is $\True$ if and only if $\vvone$ is equal to $\vvtwo$.

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef \vvone = \vvtwo
}{
  \literalequal(\vvone, \vvtwo) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.ReduceIR \label{sec:TypingRule.ReduceIR}}
\hypertarget{def-reduceir}{}
The function
\[
\reduceir(\overname{\polynomial}{\vp}) \aslto \overname{\polynomial}{\newp}
\]
simplifies the polynomial $\vp$, yielding the simplified polynomial $\newp$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vp$ is $\Sum(f)$ where $f$ binds monomials to their integer coefficients;
  \item $g$ is the restriction of $f$ to the bindings where the coefficients are non-zero;
  \item $\newp$ is $\Sum(g)$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  { g \eqdef \restrictfunc{f}{\{\vm \in \dom(f)\;|\; f(\vm) \neq 0\}} }
}{
  \reduceir(\overname{\Sum(f)}{\vp}) \typearrow \overname{\Sum(g)}{\newp}
}
\end{mathpar}

\section{TypingRule.PolynomialToExpr \label{sec:TypingRule.PolynomialToExpr}}
\hypertarget{def-polynomialtoexpr}{}
The function
\[
\polynomialtoexpr(\overname{\polynomial}{\vp}) \typearrow \overname{\expr}{\ve}
\]
transforms a polynomial $\vp$ into the corresponding expression $\ve$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\vp$ is the polynomial with an empty list of monomials, that is, $\Sum(\emptyfunc)$;
    \item define $\ve$ as the literal expression for $0$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\vp$ is the polynomial $\Sum(f)$;
    \item sorting (see $\sort$ for details) the graph of $f$ (see $\funcgraph$ for details)
          yields $\monoms$ --- a list consisting of pairs of unitary monomials and rationals.
          In principle, any total order of the graph of $f$ is acceptable for sorting.
          The function $\comparemonomialbindings$ provides one such way of ordering
          the graph of $f$;
    \item transforming $\monoms$ to an expression and sign via $\monomialstoexpr$ yields the expression $\veone$
          and sign $\vsone$;
    \item define $\ve$ as $\veone$ if $\vs$ is either $0$ or $1$ and the unary expression negating $\veone$, that is,
          $\EUnop(\NEG, \veone)$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \polynomialtoexpr(\overname{\Sum(\emptyfunc)}{\vp}) \typearrow \overname{\ELiteral(\lint(0))}{\ve}
}
\and
\inferrule[non\_empty]{
  \sort(\funcgraph(f), \comparemonomialbindings) = \monoms\\
  \monomialstoexpr(\monoms) \typearrow (\veone, \vsone)\\
  {
  \ve \eqdef \begin{cases}
    \veone                & \text{if }\vsone = 0\\
    \veone                & \text{if }\vsone = 1\\
    \EUnop(\NEG, \veone)  & \text{if }\vsone = -1
  \end{cases}
  }
}{
  \polynomialtoexpr(\overname{\Sum(f)}{\vp}) \typearrow \ve
}
\end{mathpar}

\section{TypingRule.CompareMonomialBindings \label{sec:TypingRule.CompareMonomialBindings}}
\hypertarget{def-comparemonomialbindings}{}
The function
\[
\comparemonomialbindings(
  (\overname{\monomial}{\vmone}\times\overname{\Q}{\vqone}) \aslsep
  (\overname{\monomial}{\vmtwo}\times\overname{\Q}{\vqtwo})
) \aslto \overname{\{-1,0,1\}}{\vs}
\]
compares two monomial bindings given by $(\vmone, \vqone)$ and $(\vmtwo, \vqtwo)$
and yields in $\vs$ $-1$ to mean that the first monomial binding should be ordered before the second,
$0$ to mean that any ordering of the monomial bindings is acceptable,
and $1$ to mean that the second monomial binding should be ordered before the first.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{equal\_monomials}):
  \begin{itemize}
    \item $\vmone$ is $\Prod(f)$ and $\vmtwo$ is $\Prod(g)$;
    \item $f$ is equal to $g$;
    \item $\vs$ is the sign of $\vqtwo - \vqone$.
  \end{itemize}

  \item All of the following apply (\textsc{different\_monomials}):
  \begin{itemize}
    \item $\vmone$ is $\Prod(f)$ and $\vmtwo$ is $\Prod(g)$;
    \item $f$ is different from to $g$;
    \item $\ids$ is the list obtained by taking the set of identifiers in the domain of $f$ and in the domain of $g$,
          and sorting them according to the lexical order for identifiers (ASCII string order);
    \item $\vv$ is the first identifier in $\ids$ for which $f$ and $g$ behave differently (either one of them is defined
          for $vv$ and the other is not, or they both bind $\vv$ to a different value);
    \item $s$ is determined as follows: $1$ if $\vv$ is not in the domain of $f$ and is in the domain of $g$;
          $-1$ if $\vv$ is not in the domain of $f$ and is in the domain of $g$;
          otherwise it is the sign of $g(\vv)-f(\vv)$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\hypertarget{def-compareidentifier}{}
The function $\compareidentifier$ compares two identifiers, which are lists of ASCII characters,
via the lexicographic ordering.

\begin{mathpar}
\inferrule[equal\_monomials]{
  f = g\\
  \vs \eqdef \sign(\vqtwo - \vqone)
}{
  \comparemonomialbindings((\overname{\Prod(f)}{\vmone}, \vqone), (\overname{\Prod(g)}{\vmtwo}, \vqtwo)) \typearrow \vs
}
\and
\inferrule[different\_monomials]{
  f \neq g\\
  \ids \eqdef \sort(\dom(f) \cup \dom(g), \compareidentifier)\\
  \ids \eqname \idsone \concat \idstwo\\
  \vi\in\listrange(\idsone): f(\idsone[\vi]) = g(\idsone[\vi])\\
  \vv \eqdef \idstwo[1]\\
  \vs \eqdef {
    \begin{cases}
    1 & f(\vv) = \bot \land g(\vv) \neq \bot\\
    -1  & f(\vv) \neq \bot \land g(\vv) = \bot\\
    \sign(g(\vv) - f(\vv))  & f(\vv) \neq \bot \land g(\vv) \neq \bot\\
    \end{cases}
}
}{
  \comparemonomialbindings((\overname{\Prod(f)}{\vmone}, \vqone), (\overname{\Prod(g)}{\vmtwo}, \vqtwo)) \typearrow \vs
}
\end{mathpar}

\section{TypingRule.MonomialsToExpr \label{sec:TypingRule.MonomialsToExpr}}
\hypertarget{def-monomialstoexpr}{}
The function
\[
\monomialstoexpr(\overname{(\overname{\unitarymonomial}{\vm}\times\overname{\Q}{q})^*}{\monoms}) \aslto
(\overname{\expr}{\ve},\overname{\{-1,0,1\}}{\vs})
\]
transforms a list consisting of pairs of unitary monomials and rational factors $\monoms$ (so, general monomials),
into an expression $\ve$, which represents the absolute value of the sum of all the monomials,
and a sign value $\vs$, which indicates the sign of the resulting sum.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\monoms$ is an empty list;
    \item $\ve$ is the literal expression for the integer $0$ and $\vs$ is $0$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\monoms$ is a list with $(\vm,q)$ as its \head\ and $\monomsone$ as its \tail;
    \item transforming the unitary monomial $\vm$ to an expression via \\ $\unitarymonomialstoexpr$ yields $\veonep$;
    \item transforming $\veonep$ and $q$ via $\monomialtoexpr$ yields the expression $\veone$ and sign $\vsone$;
    \item transforming $\monoms$ to an expression and sign via $\monomialstoexpr$ yields $(\vetwo, \vstwo)$;
    \item symbolically adding $\veone, \vsone, \vetwo, \vstwo$ via $\symaddexpr$ yields $\ve$;
    \item $\vs$ is $\vsone$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \monomialstoexpr(\overname{\emptylist}{\monoms}) \typearrow (\overname{\ELiteral(\lint(0))}{\ve}, \overname{0}{s})
}
\and
\inferrule[non\_empty]{
  \unitarymonomialstoexpr(\vm) \typearrow \veonep\\
  \monomialtoexpr(\veonep, q) \typearrow (\veone,\vsone)\\
  \monomialstoexpr(\monoms) \typearrow (\vetwo, \vstwo)\\
  \symaddexpr(\veone, \vsone, \vetwo, \vstwo) \typearrow \ve
}{
  \monomialstoexpr(\overname{[(\vm,q)] \concat \monomsone}{\monoms}) \typearrow (\ve, \overname{\vsone}{\vs})
}
\end{mathpar}

\section{TypingRule.MonomialToExpr \label{sec:TypingRule.MonomialToExpr}}
\hypertarget{def-monomialtoexpr}{}
The function
\[
\monomialtoexpr(\overname{\expr}{\ve} \aslsep \overname{\Q}{q})
\aslto (\overname{\expr}{\newe} \times \overname{\{-1,0,1\}}{\vs})
\]
transforms an expression $\ve$ and rational $q$ into the expression $\newe$,
which represents the absolute value of $\ve$ multiplied by $q$, and the sign of $q$ as $\vs$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{q\_zero}):
  \begin{itemize}
    \item $q$ is $0$;
    \item $\newe$ is the literal expression for $0$;
    \item $\vs$ is $0$.
  \end{itemize}

  \item All of the following apply (\textsc{q\_natural}):
  \begin{itemize}
    \item $q$ a strictly positive;
    \item symbolically multiplying the literal expression for $q$ and $\ve$ via $\symmulexpr$ yields $\newe$;
    \item $\vs$ is $1$.
  \end{itemize}

  \item All of the following apply (\textsc{q\_positive\_fraction}):
  \begin{itemize}
    \item $q$ a strictly positive fraction, that is, not an integer;
    \item the reduced representation of the fraction $q$ is $\frac{d}{n}$;
    \item symbolically multiplying the literal expression for $q$ and $\ve$ via $\symmulexpr$ yields $\vetwo$;
    \item $\ve$ is the binary expression with operator $\DIV$ and operands $\vetwo$ and the literal expression for $n$;
    \item $\vs$ is $1$.
  \end{itemize}

  \item All of the following apply (\textsc{q\_negative}):
  \begin{itemize}
    \item $q$ a strictly negative;
    \item transforming $\ve$ with $-q$ to an expression and a sign via $\monomialtoexpr$ yields $(\newe, 1)$;
    \item $\vs$ is $-1$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[q\_zero]{
  q = 0\\
}{
  \monomialtoexpr(\ve, q) \typearrow (\overname{\ELiteral(\lint(0))}{\newe}, \overname{0}{\vs})
}
\and
\inferrule[q\_natural]{
  q > 0\\
  q \in \N\\
  \symmulexpr(\ELiteral(\lint(q)), \ve) \typearrow \newe
}{
  \monomialtoexpr(\ve, q) \typearrow (\newe, \overname{1}{\vs})
}
\and
\inferrule[q\_positive\_fraction]{
  q > 0\\
  q \not\in \N\\\\
  q \eqname \frac{d}{n} \;\;\;\;\text{ is the reduced fraction for }q\\\\
  \symmulexpr(\ELiteral(\lint(d)), \ve) \typearrow \vetwo\\
  \newe \eqdef \EBinop(\DIV, \vetwo, \ELiteral(\lint(n)))
}{
  \monomialtoexpr(\ve, q) \typearrow (\newe, \overname{1}{\vs})
}
\and
\inferrule[q\_negative]{
  q < 0\\
  \monomialtoexpr(\ve, -q) \typearrow (\newe, 1)
}{
  \monomialtoexpr(\ve, q) \typearrow (\newe, \overname{-1}{\vs})
}
\end{mathpar}

\section{TypingRule.SymAddExpr \label{sec:TypingRule.SymAddExpr}}
\hypertarget{def-symaddexpr}{}
The function
\[
\symaddexpr(
  \overname{\expr}{\veone} \aslsep
  \overname{\{-1,0,1\}}{\vsone} \aslsep
  \overname{\expr}{\vetwo} \aslsep
  \overname{\{-1,0,1\}}{\vstwo}
  )
  \typearrow \overname{\expr}{\ve}
\]
symbolically sums the expressions $\veone$ and $\vetwo$
with respective signs $\vsone$ and $\vstwo$
yielding the expression $\ve$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{zero}):
  \begin{itemize}
    \item either $\vsone$ or $\vstwo$ are $0$;
    \item $\ve$ is $\veone$ if $\vstwo$ is $0$ and $\veone$, otherwise.
  \end{itemize}

  \item All of the following apply (\textsc{same\_sign}):
  \begin{itemize}
    \item both $\vsone$ and $\vstwo$ are not $0$;
    \item $\vsone$ is equal to $\vstwo$;
    \item $\ve$ is the binary expression with operator $\PLUS$ and operands $\veone$ and $\vetwo$,
          that is, $\EBinop(\PLUS, \veone, \vetwo)$.
  \end{itemize}

  \item All of the following apply (\textsc{same\_sign}):
  \begin{itemize}
    \item both $\vsone$ and $\vstwo$ are not $0$;
    \item $\vsone$ is different from $\vstwo$;
    \item $\ve$ is the binary expression with operator $\MINUS$ and operands $\veone$ and $\vetwo$,
          that is, $\EBinop(\MINUS, \veone, \vetwo)$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[zero]{
  (\vsone = 0 \lor \vstwo = 0)\\
  \ve \eqdef \choice{\vsone = 0}{(\vetwo, \vstwo)}{\veone}
}{
  \symaddexpr(\veone, \vsone, \vetwo, \vstwo) \typearrow \ve
}
\and
\inferrule[same\_sign]{
  \vsone \neq 0 \land \vstwo \neq 0\\
  \vsone = \vstwo
}{
  \symaddexpr(\veone, \vetwo) \typearrow \overname{\EBinop(\PLUS, \veone, \vetwo)}{\ve}
}
\and
\inferrule[differnt\_sign]{
  \vsone \neq 0 \land \vstwo \neq 0\\
  \vsone \neq \vstwo
}{
  \symaddexpr(\veone, \vetwo) \typearrow \overname{\EBinop(\MINUS, \veone, \vetwo)}{\ve}
}
\end{mathpar}

\section{TypingRule.UnitaryMonomialsToExpr \label{sec:TypingRule.UnitaryMonomialsToExpr}}
\hypertarget{def-unitarymonomialstoexpr}{}
The function
\[
\unitarymonomialstoexpr(\overname{(\identifier\times\N)^*}{\monoms}) \aslto \overname{\expr}{\ve}
\]
transforms a list of single-variable unitary monomials $\monoms$ into an expression $\ve$.
Intuitively, $\monoms$ represented a multiplication of the single-variable unitary monomials.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\monoms$ is the empty list;
    \item $\ve$ is the literal expression for $1$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_zero}):
  \begin{itemize}
    \item $\monoms$ is a list where the first element is $(\vv, 0)$ and its tail is $\monoms$;
    \item transforming $\monomsone$ to an expression yields $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_one}):
  \begin{itemize}
    \item $\monoms$ is a list where the first element is $(\vv, 1)$ and its tail is $\monoms$;
    \item $\veone$ is the variable expression for $\vv$;
    \item transforming $\monomsone$ to an expression yields $\vetwo$;
    \item symbolically multiplying $\veone$ and $\vetwo$ via $\symmulexpr$ yields $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_two}):
  \begin{itemize}
    \item $\monoms$ is a list where the first element is $(\vv, 2)$ and its tail is $\monoms$;
    \item $\veone$ is the binary expression with operator $\MUL$ and operands $\EVar(x)$ and $\EVar(x)$;
    \item transforming $\monomsone$ to an expression yields $\vetwo$;
    \item symbolically multiplying $\veone$ and $\vetwo$ via $\symmulexpr$ yields $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_gt\_two}):
  \begin{itemize}
    \item $\monoms$ is a list where the first element is $(\vv, n)$ and its tail is $\monoms$;
    \item $n$ is greater than $1$;
    \item $\veone$ is the binary expression with operator $\POW$ and base operand being the variable expression for $\vv$
          and the exponent operand being the variable expression for $n$;
    \item transforming $\monomsone$ to an expression yields $\vetwo$;
    \item symbolically multiplying $\veone$ and $\vetwo$ via $\symmulexpr$ yields $\ve$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \unitarymonomialstoexpr(\overname{\emptylist}{\monoms}) \typearrow \overname{\ELiteral(\lint(1))}{\ve}
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_zero]{
  \unitarymonomialstoexpr(\monomsone) \typearrow \ve
}{
  \unitarymonomialstoexpr(\overname{[(\vv, 0)] \concat \monomsone}{\monoms}) \typearrow \ve
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_one]{
  \veone \eqdef \EVar(\vv)\\
  \unitarymonomialstoexpr(\monomsone) \typearrow \vetwo\\
  \symmulexpr(\veone, \vetwo) \typearrow \ve
}{
  \unitarymonomialstoexpr(\overname{[(\vv, 1)] \concat \monomsone}{\monoms}) \typearrow \ve
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_two]{
  \veone \eqdef \EBinop(\MUL, \EVar(\vv), \EVar(n))\\
  \unitarymonomialstoexpr(\monomsone) \typearrow \vetwo\\
  \symmulexpr(\veone, \vetwo) \typearrow \ve
}{
  \unitarymonomialstoexpr(\overname{[(\vv, 2)] \concat \monomsone}{\monoms}) \typearrow \ve
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_gt\_two]{
  n \geq 2\\
  \veone \eqdef \EBinop(\POW, \EVar(\vv), \ELiteral(n))\\
  \unitarymonomialstoexpr(\monomsone) \typearrow \vetwo\\
  \symmulexpr(\veone, \vetwo) \typearrow \ve
}{
  \unitarymonomialstoexpr(\overname{[(\vv, n)] \concat \monomsone}{\monoms}) \typearrow \ve
}
\end{mathpar}

\section{TypingRule.SymMulExpr \label{sec:TypingRule.SymMulExpr}}
\hypertarget{def-symmulexpr}{}
The function
$
\symmulexpr(\overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo}) \typearrow \overname{\expr}{\ve}
$
produces an expression representing the multiplication of expressions $\veone$ and $\vetwo$,
simplifying away the case where one of the operands is the literal one.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{one\_operand}):
  \begin{itemize}
    \item either $\veone$ or $\vetwo$ is the literal expression for $1$;
    \item $\ve$ is $\vetwo$ if $\veone$ is the literal expression for $1$ and $\veone$, otherwise.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[one\_operand]{
  (\veone = \ELiteral(\lint(1)) \lor \vetwo = \ELiteral(\lint(1)))\\
  \ve \eqdef \choice{\veone = \ELiteral(\lint(1))}{\vetwo}{\veone}
}{
  \symmulexpr(\EBinop(\MUL, \veone, \vetwo)) \typearrow \ve
}
\and
\inferrule[no\_one\_operand]{
  (\veone \neq \ELiteral(\lint(1)) \land \vetwo \neq \ELiteral(\lint(1)))\\
  \ve \eqdef \EBinop(\MUL, \veone, \vetwo)
}{
  \symmulexpr(\EBinop(\MUL, \veone, \vetwo)) \typearrow \ve
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Utility Rules}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Checked Transitions}
\hypertarget{def-checktrans}{}
We define the following rules to allow us asserting that a condition holds,
returning a type error otherwise:
\begin{mathpar}
  \inferrule[check\_trans\_true]{}{ \checktrans{\True}{<message>} \checktransarrow \True }
  \and
  \inferrule[check\_trans\_false]{}{ \checktrans{\False}{<message>} \checktransarrow \TypeErrorVal{\texttt{<message>}} }
\end{mathpar}

\hypertarget{def-pairstomap}{}
\section{Converting a List of Pairs to a Map \label{sec:PairsToMap}}
The parametric function
\[
  \pairstomap(\overname{(\identifier\times T)^*}{\pairs}) \aslto \overname{(\identifier\partialto T)}{f} \cup \TTypeError
\]
converts a list of pairs --- $\pairs$ --- where each pair consists of an identifier and a value
of type $T$ into a function mapping each identifier to its respective value in the list.
If a duplicate identifier exists in $\pairs$ then a type error is returned.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\pairs$ is empty;
    \item $f$ is the empty function.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item there exist two different positions in the list where the identifier is the same;
    \item the result is a type error indicating the existence of a duplicate identifier.
  \end{itemize}

  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item all identifiers occurring in the list are unique;
    \item $f$ is a function that associates to each identifier the value appearing with it in $\pairs$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[empty]{}{ \pairstomap(\emptylist) \typearrow \emptyfunc }
\and
\inferrule[error]{
  i,j \in 1..k\\
  i \neq j\\
  \id_i = \id_j
}
{
  \pairstomap([i=1..k: (\id_i,t_i)]) \typearrow \TypeErrorVal{DuplicateIdentifier}
}
\and
\inferrule[okay]{
  \forall i,j \in 1..k. \id_i \neq \id_j\\
  {
  f \eqdef \lambda \id.\ \begin{cases}
    t_i & \text{ if }i\in1..k \land \id = \id_i\\
    \bot & \text{ otherwise}
  \end{cases}
  }
}
{
  \pairstomap([i=1..k: (\id_i,t_i)]) \typearrow f
}
\end{mathpar}

\hypertarget{def-checknoduplicates}{}
\section{TypingRule.CheckNoDuplicates \label{sec:TypingRule.CheckNoDuplicates}}
The function
\[
  \checknoduplicates(\overname{\identifier^*}{\id_{1..k}}) \aslto \True \cup \TTypeError
\]
checks whether a non-empty list of identifiers contains a duplicate identifier. If it does not, the result
is $\True$ and otherwise the result is a type error.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item the set containing all identifiers in the list has the same cardinality as the length of the list;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item there exist two different positions in the list where the identifier is the same;
    \item the result is a type error indicating the existence of a duplicate identifier.
  \end{itemize}
\end{itemize}

\begin{mathpar}
  \inferrule[okay]{
    \cardinality{\{\id_{1..k}\}} = k
  }
  {
    \checknoduplicates(\id_{1..k}) \typearrow \True
  }
\and
\inferrule[error]{
  i,j \in 1..k\\
  i \neq j\\
  \id_i = \id_j
}
{
  \checknoduplicates(\id_{1..k}) \typearrow \TypeErrorVal{DuplicateIdentifier}
}
\end{mathpar}

\hypertarget{def-annotatefieldinit}{}
\section{Annotating Field Initializers}
The function
\[
  \annotatefieldinit(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\identifier\times\expr)}{(\name, \vep)} \aslsep
    \overname{\field^*}{\fieldtypes}
  ) \aslto
  \overname{(\identifier\times\expr)}{(\name, \vepp)}
\]
annotates a field initializers $(\name, \vep)$ in a record expression
with list of fields \\ $\fieldtypes$ and returns the annotated field initializer
$(\name, \vepp)$. \ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vtp, \vepp)$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{okay}):
    \begin{itemize}
      \item the unique type associated with $\name$ in $\fieldtypes$ is $\tspecp$;
      \item determining whether $\vtp$ \typesatisfies\ $\tspecp$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \end{itemize}

    \item All of the following apply (\textsc{error}):
    \begin{itemize}
      \item there is no type associated with $\name$ in $\fieldtypes$;
      \item the result is a type error indicating that the field $\name$ does not exist.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \annotateexpr{\tenv, \vep} \typearrow (\vtp, \vepp) \OrTypeError\\\\
  \fieldtype(\fieldtypes, \name) = \tspecp\\
  \checktypesat(\tenv, \vtp, \tspecp) \typearrow \True \OrTypeError
}{
  \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow (\name, \vepp)
}
\and
\inferrule[error]{
  \annotateexpr{\tenv, \vep} \typearrow (\vtp, \vepp) \OrTypeError\\\\
  \fieldtype(\fieldtypes, \name) = \bot
}{
  \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow \\
  \TypeErrorVal{FieldDoesNotExist}
}
\end{mathpar}

\section{TypingRule.BitFieldGetName \label{sec:TypingRule.BitFieldGetName}}
\hypertarget{def-bitfieldgetname}{}
The function
\[
  \bitfieldgetname : \overname{\bitfield}{\vbf} \aslto \overname{\identifier}{\name}
\]
returns the name of a bitfield --- $\name$, given a bitfield $\vbf$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item $\vb$ is a simple bitfield with name $\name$, that is, $\BitFieldSimple(\name, \Ignore)$;
  \item $\vb$ is a nested bitfield with name $\name$, that is, $\BitFieldNested(\name, \Ignore, \Ignore)$;
  \item $\vb$ is a typed bitfield with name $\name$, that is, $\BitFieldType(\name, \Ignore, \Ignore)$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
  \inferrule[simple]{}{
    \bitfieldgetname(\BitFieldSimple(\name, \Ignore)) \typearrow \name
  }
  \and
  \inferrule[nested]{}{
    \bitfieldgetname(\BitFieldNested(\name, \Ignore, \Ignore)) \typearrow \name
  }
  \and
  \inferrule[type]{}{
    \bitfieldgetname(\BitFieldType(\name, \Ignore, \Ignore)) \typearrow \name
  }
\end{mathpar}

\section{TypingRule.CheckVarNotInGEnv}
\hypertarget{def-checkvarnotingenv}{}
The function
\[
  \checkvarnotingenv{\overname{\staticenvs}{\tenv} \aslsep \overname{\Strings}{\id}}
  \aslto \True \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether $\id$ is already declared in the global environment of $\tenv$.
If it is, the result is a type error, and otherwise the result is $\True$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vb$ is $\True$ if and only if one of the following applies:
  \begin{itemize}
    \item $\id$ is declared as a global identifier in $\tenv$;
    \item $\id$ is declared as a subprogram in $\tenv$;
    \item $\id$ is declared as a type in $\tenv$.
  \end{itemize}

  \item checking whether $\vb$ is $\False$ yields $\True$ or a type error indicating
        that $\id$ has already been declared, thereby short-circuiting the rule.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
{
  \begin{array}{rl}
  \vb \eqdef  & G^\tenv.\globalstoragetypes(\id) \neq \bot \lor\\
              & G^\tenv.\subprograms(\id) \neq \bot\ \lor\\
              & G^\tenv.\declaredtypes(\id) \neq \bot
  \end{array}
}\\
\checktrans{\neg\vb}{IdentifierAlreadyDeclared} \checktransarrow \True \OrTypeError
}{
  \checkvarnotingenv{\tenv, \id} \typearrow \True
}
\end{mathpar}

\hypertarget{def-checkvarnotinenv}{}
\hypertarget{def-varinenv}{}
\section{TypingRule.CheckVarNotInEnv}
The function
\[
  \varinenv{\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\id}}
  \aslto \overname{\Bool}{\vb}
\]
determines whether an identifier $\id$ is declared in the static environment $\tenv$.

The function
\[
  \checkvarnotinenv{\overname{\staticenvs}{\tenv} \aslsep \overname{\Strings}{\id}}
  \aslto \True \cup \TTypeError
\]
checks whether $\id$ is already declared in $\tenv$. If it is, the result is a type error,
and otherwise the result is $\True$.

\subsection{Prose}
$\varinenv{\tenv, \id}$ is true if and only if one of the following applies:
\begin{itemize}
  \item $\id$ is declared as a local identifier in $\tenv$;
  \item $\id$ is declared as a global identifier in $\tenv$;
  \item $\id$ is declared as a subprogram in $\tenv$;
  \item $\id$ is declared as a type in $\tenv$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{rl}
  \vb \eqdef & L^\tenv.\localstoragetypes(\id) \neq \bot\ \lor\\
             & G^\tenv.\globalstoragetypes(\id) \neq \bot \lor\\
             & G^\tenv.\subprograms(\id) \neq \bot\ \lor\\
             & G^\tenv.\declaredtypes(\id) \neq \bot
  \end{array}
}
}{
  \varinenv{\tenv, \id} \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[okay]{
  \varinenv{\tenv, \id} \typearrow \False
}{
  \checkvarnotinenv{\tenv, \id} \typearrow \True
}
\and
  \inferrule[error]{
  \varinenv{\tenv, \id} \typearrow \True
}{
  \checkvarnotinenv{\tenv, \id} \typearrow \TypeErrorVal{AlreadyDeclared}
}
\end{mathpar}

\hypertarget{def-addlocal}{}
\section{TypingRule.AddLocal \label{sec:TypingRule.AddLocal}}
The function
\[
  \addlocal(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\id} \aslsep
    \overname{\ty}{\tty} \aslsep
    \overname{\localdeclkeyword}{\ldk})
  \aslto
  \overname{\staticenvs}{\newtenv}
\]
adds the identifier $\id$ as a local storage element with type $\tty$ and local declaration keyword $\ldk$
to the local environment of $\tenv$, resulting in the static environment $\newtenv$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the map $\newlocalstoragetypes$ is defined by updating the map \\
        $\localstoragetypes$ of $\tenv$
        with the binding $\id$ to the type $\tty$ and local declaration keyword $\ldk$, that is, $(\tty,\ldk)$;
  \item $\newtenv$ is defined by updating the local environment with the binding of \\
        $\localstoragetypes$ to $\newlocalstoragetypes$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \newlocalstoragetypes \eqdef L^\tenv.\localstoragetypes[\id \mapsto (\tty, \ldk)]\\
  \newtenv \eqdef (G^\tenv, L^\tenv[\localstoragetypes \mapsto \newlocalstoragetypes])
}
{
  \addlocal(\tenv, \id, \tty, \ldk) \typearrow \newtenv
}
\end{mathpar}

\hypertarget{def-declaredtype}{}
\section{TypingRule.DeclaredType \label{sec:TypingRule.DeclaredType}}

The function
\[
  \declaredtype(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\id}) \aslto \overname{\ty}{\vt} \cup \TTypeError
\]
retrieves the type associated with the identifier $\id$ in the static environment $\tenv$.
If the identifier is not associated with a declared type, a type error is returned.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exists}):
  \begin{itemize}
    \item $\id$ is bound in the global environment to the type $\vt$.
  \end{itemize}

  \item All of the following apply (\textsc{type\_not\_declared}):
  \begin{itemize}
    \item $\id$ is not bound in the global environment to any type;
    \item the result is a type error indicating the lack of a type declaration for $\id$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[exists]{
  G^\tenv.\declaredtypes(\id) = \vt
}
{
  \declaredtype(\tenv, \id) \typearrow \vt
}
\and
\inferrule[type\_not\_declared]{
  G^\tenv.\declaredtypes(\id) = \bot
}
{
  \declaredtype(\tenv, \id) \typearrow \TypeErrorVal{TypeNotDeclared}
}
\end{mathpar}

\section{TypingRule.FindBitfieldOpt}
\hypertarget{def-findbitfieldopt}{}
The function
\[
  \findbitfieldopt(\overname{\identifier}{\name} \aslsep \overname{\bitfield^*}{\bitfields})
  \aslto \overname{\langle\bitfield\rangle}{\vr}
\]
returns the bitfield associated with the name $\name$ in the list of bitfields $\bitfields$,
if there is one. Otherwise, the result is $\None$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{match}):
  \begin{itemize}
    \item $\bitfields$ starts with a bitfield $\vbf$;
    \item obtaining the name associated with $\vbf$ yields $\name$;
    \item the result if $\vbf$.
  \end{itemize}

  \item All of the following apply (\textsc{tail}):
  \begin{itemize}
    \item $\bitfields$ starts with a bitfield $\vbf$ and continues with the tail list $\bitfieldsp$;
    \item obtaining the name associated with $\vbf$ yields $\namep$, which is different than $\name$;
    \item finding the bitfield associated with $\name$ in $\bitfieldsp$ yields the result $\vr$.
  \end{itemize}

  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\bitfields$ is an empty list;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[match]{
  \bitfieldgetname(\vbf) \typearrow \name
}{
  \findbitfieldopt(\name, \overname{\vbf \concat \bitfieldsp}{\bitfields}) \typearrow \overname{\langle\vbf\rangle}{\vr}
}
\and
\inferrule[tail]{
  \bitfieldgetname(\vbf) \typearrow \namep\\
  \name \neq \namep\\
  \findbitfieldopt(\name, \bitfieldsp) \typearrow \vr
}{
  \findbitfieldopt(\name, \overname{\vbf \concat \bitfieldsp}{\bitfields}) \typearrow \vr
}
\and
\inferrule[empty]{}{
  \findbitfieldopt(\name, \overname{\emptylist}{\bitfields}) \typearrow \None
}
\end{mathpar}

\section{TypingRule.MemBfs}
\hypertarget{def-membfs}{}
The function
\[
  \membfs(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield^+}{\bfstwo} \aslsep \overname{\bitfield}{\vbfone})
  \aslto \overname{\Bool}{\vb}
\]
checks whether the bitfield $\vbf$ exists in $\bfstwo$ in the context of $\tenv$, returning the result in $\vb$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\None$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{simple\_any}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{nested\_simple}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{nested\_nested}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a nested bitfield with name $\nameone$, slices $\sliceone$, and $\bfsone$;
    \item $\vbone$ is true if and only if $\nameone$ is equal to $\nametwo$;
    \item symbolically equating the slices $\slicesone$ and $\slicestwo$ in $\tenv$ yields $\vbtwo$;
    \item checking $\bfsone$ is included in $\bfstwop$ in the context of $\tenv$ yields $\vbthree$;
    \item $\vb$ is defined as the conjunction of $\vbone$, $\vbtwo$, and $\vbthree$.
  \end{itemize}

  \item All of the following apply (\textsc{nested\_typed}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a typed bitfield;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{typed\_simple}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{typed\_nested}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a nested bitfield;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{typed\_typed}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a typed bitfield with name $\nameone$, slices $\slicesone$, and type $\ttyone$;
    \item $\vbone$ is true if and only if $\nameone$ is equal to $\nametwo$;
    \item symbolically equating the slices $\slicesone$ and $\slicestwo$ in $\tenv$ yields $\vbtwo$;
    \item checking whether $\ttyone$ structurally subtypes $\ttytwo$ in $\tenv$ yields $\vbthree$;
    \item $\vb$ is defined as the conjunction of $\vbone$, $\vbtwo$, and $\vbthree$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[none]{
  \bitfieldgetname(\vbfone) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \None
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \False
}
\and
\inferrule[simple\_any]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \astlabel(\vbftwo) = \BitFieldSimple\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested\_simple]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \vbfone = \BitFieldSimple(\Ignore)\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[nested\_nested]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \vbfone = \BitFieldNested(\nameone, \slicesone, \bfsone)\\
  \vbone \eqdef \nameone = \nametwo\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \bitfieldsincluded(\tenv, \bfsone, \bfstwop) \typearrow \vbthree\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\and
\inferrule[nested\_typed]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \astlabel(\vbfone) = \BitFieldType
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[typed\_simple]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \vbfone = \BitFieldSimple(\Ignore)\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\and
\inferrule[typed\_nested]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \astlabel(\vbfone) = \BitFieldNested
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[typed\_typed]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \vbfone = \BitFieldType(\nameone, \slicesone, \ttyone)\\
  \vbone \eqdef \nameone = \nametwo\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \structsubtypesat(\tenv, \ttyone, \ttytwo) \typearrow \vbthree \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\end{mathpar}

\section{TypingRule.BitFieldsIncluded}
\hypertarget{def-bitfieldsincluded}{}
The predicate
\[
  \bitfieldsincluded(\overname{\staticenvs}{\tenv}, \overname{\bitfield^*}{\bfsone} \aslsep \overname{\bitfield^*}{\bfstwo})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the set of bit fields $\bfsone$ is included in the set of bit fields $\bfstwo$ in environment $\tenv$,
returning a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking whether each field $\vbf$ in $\bfsone$ exists in $\bfstwo$ via $\membfs$ yields $\vb_\vbf$\ProseOrTypeError;
  \item the result --- $\vb$ --- is the conjunction of $\vb_\vbf$ for all bitfields $\vbf$ in $\bfsone$.
\end{itemize}

\begin{mathpar}
\inferrule{
  \vbf \in \bfsone: \membfs(\bfstwo, \vbf) \typearrow \vb_\vbf \OrTypeError\\\\
  \vbf \eqdef \bigwedge_{\bf \in \bfsone} \vb_\vbf
}{
  \bitfieldsincluded(\tenv, \bfsone, \bfstwo) \typearrow \vb
}
\end{mathpar}

\hypertarget{def-typeofarraylength}{}
\section{TypingRule.TypeOfArrayLength \label{sec:TypingRule.TypeOfArrayLength}}
The function
\[
  \typeofarraylength(\overname{\staticenvs}{\tenv} \aslsep \overname{\arrayindex}{\size}) \aslto
  \overname{\ty}{\vt}
\]
returns the type for the array index $\size$ in the static environment $\tenv$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{enum}):
  \begin{itemize}
    \item $\size$ is an enumeration index over the enumeration $\vs$, that is, \\ $\ArrayLengthEnum(\vs, \Ignore)$;
    \item $\vt$ is the named type for $\vs$, that is, $\TNamed(\vs)$.
  \end{itemize}

  \item All of the following apply (\textsc{expr}):
  \begin{itemize}
    \item $\size$ is an expression index for $\ve$, that is, $\ArrayLengthExpr(\ve)$;
    \item applying $\normalize$ to simplify the expression corresponding to $\ve - 1$ in $\tenv$
          yields the expression $\vm$;
    \item $\vc$ is the range constraint for $0..\vm$, that is, $\ConstraintRange(\eliteral{0}, \vm)$;
    \item $\vt$ is the well-constrained integer with the single constraint $\vc$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\TypeOfArrayLengthBegin}{\TypeOfArrayLengthEnd}{../types.ml}
\subsection{Formally}
\begin{mathpar}
\inferrule[enum]{}
{
  \typeofarraylength(\tenv, \ArrayLengthEnum(\vs, \Ignore)) \typearrow \TNamed(\vs)
}
\and
\inferrule[expr]{
  \normalize(\tenv, \EBinop(\MINUS, \ve, \eliteral{1})) \typearrow \vm\\
  \vc \eqdef \ConstraintRange(\eliteral{0}, \vm)
}{
  \typeofarraylength(\tenv, \ArrayLengthExpr(\ve)) \typearrow \TInt(\wellconstrained([\vc]))
}
\end{mathpar}

\hypertarget{def-checkstructureinteger}{}
\section{TypingRule.CheckStructureInteger \label{sec:TypingRule.CheckStructureInteger}}
The function
\[
  \checkstructureinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \True \cup \TTypeError
\]
returns $\True$ is $\vt$ is has the \structure\ an integer type and a type error otherwise.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ is an integer type;
    \item the result is $\True$;
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ is not an integer type;
    \item the result is a type error indicating that $\vt$ was expected to have the \structure\ of an integer.
  \end{itemize}
\end{itemize}

\CodeSubsection{\CheckStructureIntegerBegin}{\CheckStructureIntegerEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\vt) \typearrow \vtp \OrTypeError\\\\
  \astlabel(\vtp) = \TInt
}
{
  \checkstructureinteger(\tenv, \vt) \typearrow \True
}
\and
\inferrule[error]{
  \tstruct(\vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \TInt
}
{
  \checkstructureinteger(\tenv, \vt) \typearrow \TypeErrorVal{ExpectedIntegerStructure}
}
\end{mathpar}

\hypertarget{def-checkstructurelabel}{}
\section{TypingRule.CheckStructure \label{sec:TypingRule.CheckStructure}}
The function
\[
  \checkstructurelabel(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\astlabels}{\vl}) \aslto
  \True \cup \TTypeError
\]
returns $\True$ is $\vt$ is has the \structure\ a of type corresponding to the AST label $\vl$ and a type error otherwise.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ has the label $\vl$;
    \item the result is $\True$;
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ does not have the label $\vl$;
    \item the result is a type error indicating that $\vt$ was expected to have the \structure\ of a type with the AST label $\vl$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\vt) \typearrow \vtp \OrTypeError\\\\
  \astlabel(\vtp) = \vl
}
{
  \checkstructurelabel(\tenv, \vt, \vl) \typearrow \True
}
\and
\inferrule[error]{
  \tstruct(\vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \vl
}
{
  \checkstructurelabel(\tenv, \vt, \vl) \typearrow \TypeErrorVal{UnexpectedTypeStructure}
}
\end{mathpar}

\hypertarget{def-storageispure}{}
\section{TypingRule.StorageIsPure \label{sec:TypingRule.StorageIsPure}}
The function
\[
  \storageispure(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vs}) \aslto
  \overname{\Bool}{\vb} \cup \TTypeError
\]
$\vb$ is true if and only if the identifier $\vs$ corresponds to a \pure\ storage element
in the static environment $\tenv$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{local}):
  \begin{itemize}
    \item $\vs$ is a locally declared storage element;
    \item $\vb$ is true if and only if $\vs$ is declared as a constant or as an immutable variable (\texttt{let}).
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item $\vs$ is a globally declared storage element;
    \item $\vb$ is true if and only if $\vs$ is declared as a constant, a configuration variable, or an immutable variable.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $\vs$ is not defined in the environment as a storage element;
    \item the result is a type error indicating that $\vs$ is not defined as a storage element.
  \end{itemize}
\end{itemize}

\CodeSubsection{\StorageIsPureBegin}{\StorageIsPureEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\localstoragetypes(\vs) = (\Ignore, \ldk)\\
  \vb \eqdef \ldk \in \{\LDKConstant, \LDKLet\}
}
{
  \storageispure(\tenv, \vs) \typearrow \vb
}
\and
\inferrule[global]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = (\Ignore, \gdk)\\
  \vb \eqdef \gdk \in \{\GDKConstant, \GDKConfig, \GDKLet\}
}
{
  \storageispure(\tenv, \vs) \typearrow \vb
}
\and
\inferrule[error]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = \bot
}
{
  \storageispure(\tenv, \vs) \typearrow \TypeErrorVal{UndefinedIdentifier}
}
\end{mathpar}

\hypertarget{def-checkstaticallyevaluable}{}
\hypertarget{def-staticallyevaluable}{}
\section{TypingRule.CheckStaticallyEvaluable \label{sec:TypingRule.CheckStaticallyEvaluable}}
The function
\[
  \checkstaticallyevaluable(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \True \cup \TTypeError
\]
returns $\True$ if $\ve$ is a \staticallyevaluable\ expression in the static environment $\tenv$ and a type error otherwise.

\subsection{Prose}
All of the following applies:
\begin{itemize}
  \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields $\veone$;
  \item determining the set of used identifiers in $\veone$ yields $\useset$;
  \item $\vb$ is true if and only if every identifier in $\useset$ is pure;
  \item the result is $\True$ is $\vb$ is $\True$, otherwise it is a type error indicating that the expression
  is not statically evaluable.
\end{itemize}

\CodeSubsection{\CheckStaticallyEvaluableBegin}{\CheckStaticallyEvaluableEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \useexpr(\veone) \typearrow \useset\\
  \id\in\useset: \storageispure(\tenv, \id) \typearrow \vb_\id\\
  \vb \eqdef \bigwedge_{\id\in\useset} \vb_\id\\
  \checktrans{\vb}{NotStaticallyEvaluable} \checktransarrow \True \OrTypeError
}
{
  \checkstaticallyevaluable(\tenv, \ve) \typearrow \True
}
\end{mathpar}

\section{TypingRule.ToWellConstrained}
\hypertarget{def-towellconstrained}{}
The function
\[
  \towellconstrained(\overname{\ty}{\vt}) \aslto \overname{\ty}{\vtp}
\]
returns the \wellconstrainedversion\ of a type $\vt$ --- $\vtp$, which is defined as follows.

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{t\_int\_parameterized}):
  \begin{itemize}
    \item $\vt$ is a \parameterizedintegertype\ for the variable $\vv$;
    \item $\vtp$ is the well-constrained integer constrained by the variable expression for $\vv$,
    that is, $\TInt(\wellconstrained(\constraintexact(\EVar(\vv))))$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_other, other}):
  \begin{itemize}
    \item $\vt$ is not a \parameterizedintegertype\ for the variable $\vv$;
    \item $\vtp$ is $\vt$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[t\_int\_parameterized]{}
{
  \towellconstrained(\TInt(\parameterized(\vv))) \typearrow\\ \TInt(\wellconstrained(\constraintexact(\EVar(\vv))))
}
\and
\inferrule[t\_int\_other]{
  \astlabel(\vi) \neq \parameterized
}{
  \towellconstrained(\TInt(\vi)) \typearrow \vt
}
\and
\inferrule[other]{
  \astlabel(\vt) \neq \TInt
}{
  \towellconstrained(\vt) \typearrow \vt
}
\end{mathpar}

\section{TypingRule.GetWellConstrainedStructure}
\hypertarget{def-getwellconstrainedstructure}{}
The function
\[
  \getwellconstrainedstructure(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt})
  \aslto \overname{\ty}{\vtp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the \wellconstrainedstructure\ of a type $\vt$ in the static environment $\tenv$ --- $\vtp$, which is defined as follows.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the \structure\ of $\vt$ in $\tenv$ is $\vtone$\ProseOrTypeError;
  \item the well-constrained version of $\vtone$ is $\vtp$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) \typearrow \vtone \OrTypeError\\\\
  \towellconstrained(\vtone) \typearrow \vtp
}{
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \vtp
}
\end{mathpar}

\section{TypingRule.GetBitvectorWidth}
\hypertarget{def-getbitvectorwidth}{}
The function
\[
  \getbitvectorwidth(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \overname{\expr}{\ve} \cup \TTypeError
\]
returns the expression $\ve$, which represents the width of the bitvector type $\vt$,
or a type error if $\vt$ is not a bitvector type or another type error is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a bitvector type with width expression $\ve$,
          that is, $\TBits(\ve, \Ignore)$\ProseOrTypeError;
    \item the result is $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a type that is not a bitvector type;
    \item the result is a type error indicating that a bitvector type was expected.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\tenv, \vt) \typearrow \TBits(\ve, \Ignore) \OrTypeError
}{
  \getbitvectorwidth(\tenv, \vt) \typearrow \ve
}
\and
\inferrule[error]{
  \tstruct(\tenv, \vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \TBits
}{
  \getbitvectorwidth(\tenv, \vt) \typearrow \TypeErrorVal{\ExpectedBitvectorType}
}
\end{mathpar}

\section{TypingRule.CheckBitsEqualWidth}
\hypertarget{def-checkbitsequalwidth}{}
The function
\[
  \checkbitsequalwidth(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\vtone}) \aslsep
    \overname{\ty}{\vttwo})\aslto
  \True \cup \TTypeError
\]
tests whether the types $\vtone$ and $\vttwo$ are bitvector types of the same width.
If the answer is positive, the result is $\True$. \ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item obtaining the width of $\vtone$ in $\tenv$ (via $\getbitvectorwidth$) yields the expression $\vn$\ProseOrTypeError;
  \item obtaining the width of $\vttwo$ in $\tenv$ (via $\getbitvectorwidth$) yields the expression $\vm$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{true}):
    \begin{itemize}
      \item symbolically checking whether the bitwidth expressions $\vn$ and $\vm$ are equal (via $\bitwidthequal$) yields $\True$;
      \item the result is $\True$.
    \end{itemize}

    \item All of the following apply (\textsc{error}):
    \begin{itemize}
      \item symbolically checking whether the bitwidth expressions $\vn$ and $\vm$ are equal (via $\bitwidthequal$) yields $\False$;
      \item the result is a type error indicating that the bitwidths are different.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[true]{
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vn \OrTypeError\\\\
  \getbitvectorwidth(\tenv, \vttwo) \typearrow \vm \OrTypeError\\\\
  \bitwidthequal(\tenv, \vn, \vm) \typearrow \True
}{
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \True
}
\and
\inferrule[error]{
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vn \OrTypeError\\\\
  \getbitvectorwidth(\tenv, \vttwo) \typearrow \vm \OrTypeError\\\\
  \bitwidthequal(\tenv, \vn, \vm) \typearrow \False
}{
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{DifferentBitwidths}
}
\end{mathpar}

\section{AssocOpt}
\hypertarget{def-assocopt}{}
The function
\[
  \assocopt(\overname{(\identifier\times T)^*}{\vli} \aslsep \overname{\identifier}{\id}) \typearrow \langle \overname{T}{\vv} \rangle
\]
returns the value $\vv$ associated with the identifier $\id$ in the list of pairs $\vli$ or $\None$, if no such association exists.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{member}):
  \begin{itemize}
    \item a pair $(\id,\vv)$ exists in the list $\vli$;
    \item the result is $\langle\vv\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_member}):
  \begin{itemize}
    \item every pair $(\vx,\Ignore)$ in the list $\vli$ has $\vx\neq\id$;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[not\_member]{
  (\vx, \vv) \in \vli: \vx \neq \id
}{
  \assocopt(\vli, \id) \typearrow \None
}
\and
\inferrule[member]{
  (\id, \vv) \in \vli
}{
  \assocopt(\vli, \id) \typearrow \langle \vv \rangle
}
\end{mathpar}

\section{LookupConstant}
\hypertarget{def-lookupconstant}{}
The function
\[
  \lookupconstant(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vs})
  \;\aslto\; \overname{\literal}{\vv}\ \cup\ \{\bot\}
\]
looks up the environment $\tenv$ for a constant $\vv$ associated with an identifier
$\vs$. The result is $\bot$ if $\vs$ is not associated with any constant.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{local}):
  \begin{itemize}
    \item $\vs$ is associated with a constant $\vv$ in the local environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item $\vs$ is not associated with a constant in the local environment of $\tenv$;
    \item $\vs$ is associated with a constant $\vv$ in the global environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vs$ is not associated with a constant in the local environment of $\tenv$;
    \item $\vs$ is not associated with a constant in the global environment of $\tenv$;
    \item the result is $\bot$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\constantvalues(\vs) = \vv
}{
  \lookupconstant(\tenv, \vs) \typearrow \vv
}
\and
\inferrule[global]{
  L^\tenv.\constantvalues(\vs) = \bot\\
  G^\tenv.\constantvalues(\vs) = \vv
}{
  \lookupconstant(\tenv, \vs) \typearrow \vv
}
\and
\inferrule[none]{
  L^\tenv.\constantvalues(\vs) = \bot\\
  G^\tenv.\constantvalues(\vs) = \bot
}{
  \lookupconstant(\tenv, \vs) \typearrow \bot
}
\end{mathpar}

\section{TypeOf}
\hypertarget{def-typeof}{}
The function
\[
  \typeof(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vs})
  \;\aslto\; \overname{\ty}{\tty}\ \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
looks up the environment $\tenv$ for a type $\tty$ associated with an identifier
$\vs$. The result is type error if $\vs$ is not associated with any type.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{local}):
  \begin{itemize}
    \item $\vs$ is associated with a type $\tty$ in the local environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item $\vs$ is not associated with a type in the local environment of $\tenv$;
    \item $\vs$ is associated with a type $\tty$ in the global environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $\vs$ is not associated with a type in the local environment of $\tenv$;
    \item $\vs$ is not associated with a type in the global environment of $\tenv$;
    \item the result is a type error indicating that $\vs$ was expected to be associated
          with a type.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\localstoragetypes(\vs) = \tty
}{
  \typeof(\tenv, \vs) \typearrow \tty
}
\and
\inferrule[global]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = \tty
}{
  \typeof(\tenv, \vs) \typearrow \tty
}
\and
\inferrule[none]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = \bot
}{
  \typeof(\tenv, \vs) \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\section{TypingRule.IsUndefined \label{sec:TypingRule.IsUndefined}}
\hypertarget{def-isundefined}{}
The function
\[
\isundefined(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vx})
\aslto \overname{\Bool}{\vb}
\]
checks whether the identifier $\vx$ is defined as a storage element in the static environment $\tenv$.

\subsection{Prose}
$\vb$ is $\True$ if and only if $\vx$ is not bound in to a global storage in $\tenv$ and
$\vx$ is not bound to a local storage in $\tenv$.

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef G^\tenv.\globalstoragetypes(\vx) = \bot \land L^\tenv.\localstoragetypes(\vx) = \bot
}{
  \isundefined(\tenv, \vx) \typearrow \vb
}
\end{mathpar}

\section{Sorting Lists \label{sec:sortinglists}}
\hypertarget{def-sort}{}
The parametric function
\[
\sort(\overname{T^*}{\vlone}, \overname{(T\times T)\rightarrow \{-1,0,1\}}{\compare}) \typearrow \overname{T^*}{\vltwo}
\]
sorts a list of elements of type $T$ --- $\vlone$ --- using the comparison function $\compare$,
resulting in the sorted list $\vltwo$.
$\compare(a, b)$ returns $1$ to mean that $a$ should be ordered before $b$,
$0$ to mean that $a$ and $b$ can be ordered in any way,
and $-1$ to mean that $b$ should be ordered before $a$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty\_or\_single}):
  \begin{itemize}
    \item $\vlone$ is either empty or contains a single element;
    \item $\vltwo$ is $\vlone$.
  \end{itemize}

  \item All of the following apply (\textsc{two\_or\_more}):
  \begin{itemize}
    \item $\vlone$ contains at least two elements;
    \item $f$ is a permutation of $1..n$;
    \item $\vltwo$ is the application of the permutation $f$ to $\vlone$;
    \item applying $\compare$ to every pair of consecutive elements in $\vltwo$ yields either $0$ or $1$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty\_or\_single]{
  \listlen{\vlone} = n\\
  n < 2
}{
  \sort(\vlone, \compare) \typearrow \overname{\vlone}{\vltwo}
}
\and
\inferrule[two\_or\_more]{
  \listlen{\vlone} = n\\
  f : 1..n \rightarrow 1..n \text{ is a bijection}\\
  \vltwo \eqdef [\ i=1..n: \vlone[f(i)]\ ]\\
  i=1..n-1: \compare(\vltwo[i], \vltwo[i+1]) \geq 0
}{
  \sort(\vlone, \compare) \typearrow \vltwo
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Type Error Codes}

\begin{description}
\hypertarget{def-setterwithoutgetter}{}
\item[$\SetterWithoutGetter$:]
ASL requires each setter for a given identifier to have a corresponding getter for the same
identifier.
The specification either does not contain a getter for the same identifier
or a getter for the same identifier exists, but it does not have the expected
signature (see \secref{TypingRule.CheckSetterHasGetter}).

\hypertarget{def-expectedbitvectortype}{}
\item[$\ExpectedBitvectorType$]
A type that is not that of a bitvector was given where a bitvector type was expected.
See \typingrulecasename{CheckBinop}{plus\_minus\_bits\_bits} (\secref{TypingRule.CheckBinop}) for an example.

\hypertarget{def-undefinedidentifier}{}
\item[$\UndefinedIdentifier$]
An identifier that is missing a definition of the appropriate kind.
See TypingRule.SubprogramForName (\secref{TypingRule.SubprogramForName}) for an example.

\hypertarget{def-subprogramdeclaredmultipletimes}{}
\item[$\SubrogramDeclaredMultipleTimes$]
At least two subprograms in the specification clash (see \secref{TypingRule.AddNewFunc}).

\hypertarget{def-nocallcandidates}{}
\item[$\NoCallCandidates$]
A function call, given by its name and list of formal argument types, does not match any defined subprogram
(see \secref{TypingRule.SubprogramForName}).

\hypertarget{def-toomanycandidates}{}
\item[$\TooManyCandidates$]
A function call, given by its name and list of formal argument types, matches more than one subprogram,
which does not allow the type-checker to decide which subprogram the call refers to
(see \secref{TypingRule.SubprogramForName}).

\hypertarget{def-parameterwithoutdecl}{}
\item[$\ParameterWithoutDecl$]
A subprogram includes a parameter that is not associated with any variable appearing in one of the arguments
(see \secref{TypingRule.AnnotateParams}).

\hypertarget{def-nolca}{}
\item[$\NoLCA$]
A conditional expressions results in two types that have no common ancestor type that can represent both
(see \secref{TypingRule.LowestCommonAncestor}).

\hypertarget{def-mrv}{}
\item[$\MismatchedReturnValue$]
A call to a function must result in a returned value,
whereas a call to a procedure must not.
This error occurs when a call to a function or a getter is inferred to refer to a procedure or a setter,
or a call to a procedure or a setter is inferred to refer to a function or a getter.
(see \secref{TypingRule.AnnotateCallArgTyped}).

\hypertarget{def-cba}{}
\item[$\CallBadArity$]
A call to a subprogram must have the same number of arguments as the list of formal arguments
declared for the subprogram.
This error indicates that the number of arguments is different to the number of declared formal arguments
(see \secref{TypingRule.AnnotateCallArgTyped}).

\hypertarget{def-brd}{}
\item[$\BadRecursiveDecls$]
Only subprogram declarations may be mutually recursive.
This error indicates that at least one declaration in a given list of mutually recursive declarations
is not a subprogram
(see \secref{TypingRule.TypeCheckMutuallyRec}).

\hypertarget{def-lbi}{}
\item[$\RequireIntegerForLoopBounds$]
The expressions defining the bounds of a \texttt{for} loop are required to have the \structure\ of
an integer type.
This error indicates that at least one of the start expression and end expression violate this
requirement.
(see \secref{TypingRule.TypeCheckMutuallyRec}).

\hypertarget{def-rst}{}
\item[$\RequireStructuredType$]
This error indicates that a \structuredtype\ is required where a non-\structuredtype\ was supplied.
(see \secref{TypingRule.ERecord}).

\hypertarget{def-mfi}{}
\item[$\MissingFieldInitializer$]
This error indicates that an initialization of a \structuredtype\ is missing an expression to initialize
one of its fields.
(see \secref{TypingRule.ERecord}).

\hypertarget{def-rsb}{}
\item[$\RequireSameBitwidths$]
This error indicates that two bitvector types are required to have the same bitwidths but the type-checker
was not able to prove it
(see \secref{BitvectorOperations}).

\hypertarget{def-taf}{}
\item[$\TypeAsssertionFails$]
This error indicates that a given at type assertion expression will always fail
(see \secref{TypingRule.CheckATC}).

\end{description}

\bibliographystyle{plain}
\bibliography{ASL}

\end{document}
