\documentclass{book}
\input{ASLmacros}
\input{ASLTypingLines}
\input{ASLTypeSatisfactionLines}
\input{ASLASTLines}
\newcommand{\tests}{../tests/ASLTypingReference.t/}

\newcommand\todocomment[1]{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\typingrulecasename[2]{TypingRule.{#1}.\textsc{#2}}

% The following macros will be moved to ASLmacros.tex when we unify all reference documents.
\newcommand\ReadEffect[0]{\textsf{ReadEffect}}
\newcommand\Normal[0]{\textsf{Normal}}
\newcommand\ThrowingConfig[0]{\texttt{\#T}}
\newcommand\OrAbnormal[0]{\terminateas \ThrowingConfig, \ErrorConfig}
\newcommand\vg[0]{\texttt{g}}
\newcommand\env[0]{\texttt{env}}
\newcommand\parallelcomp[0]{\parallel}
\newcommand\binoprel[0]{\texttt{binop}}
\newcommand\unoprel[0]{\texttt{unop}}
\newcommand\evalexprsef[1]{\hyperlink{def-evalexprsef}{\texttt{eval\_expr\_sef}}(#1)}
\newcommand\XGraphs[0]{\mathcal{G}}
\newcommand\TError[0]{\textsf{TDynError}}
\newcommand\ErrorConfig[0]{\hyperlink{def-errorconfig}{\texttt{\#DE}}}

\newcommand\dynamicdomain[0]{\hyperlink{def-dyndomain}{\textsf{dyn\_dom}}}

\newcommand\OrTypeError[0]{\;\terminateas \TypeErrorConfig}
%\newcommand\ProseOrTypeError[0]{or a type error that short-circuits the entire rule}
\newcommand\ProseOrTypeError[0]{\ProseTerminateAs{\TypeErrorConfig}}

\newcommand\annotaterel[0]{\hyperlink{def-annotaterel}{\textsf{type}}}
\newcommand\typearrow[0]{\xrightarrow{\annotaterel}}
\newcommand\isbuiltinsingular[0]{\hyperlink{def-isbuiltinsingular}{\texttt{is\_builtin\_singular}}}
\newcommand\isbuiltinaggregate[0]{\hyperlink{def-isbuiltinaggregate}{\texttt{is\_builtin\_aggregate}}}
\newcommand\isbuiltin[0]{\hyperlink{def-isbuiltin}{\texttt{is\_builtin}}}
\newcommand\isnamed[0]{\hyperlink{def-isnamed}{\texttt{is\_named}}}
\newcommand\isanonymous[0]{\hyperlink{def-isanonymous}{\texttt{is\_anonymous}}}
\newcommand\issingular[0]{\hyperlink{def-issingular}{\texttt{is\_singular}}}
\newcommand\isaggregate[0]{\hyperlink{def-isaggregate}{\texttt{is\_aggregate}}}
\newcommand\isnonprimitive[0]{\hyperlink{def-isnonprimitive}{\texttt{is\_non\_primitive}}}
\newcommand\isprimitive[0]{\hyperlink{def-isprimitive}{\texttt{is\_primitive}}}

\newcommand\isunconstrainedinteger[0]{\hyperlink{def-isunconstrainedinteger}{\textsf{is\_unconstrained\_integer}}}
\newcommand\isunderconstrainedinteger[0]{\hyperlink{def-isunderconstrainedinteger}{\textsf{is\_under\_constrained\_integer}}}
\newcommand\iswellconstrainedinteger[0]{\hyperlink{def-iswellconstrainedinteger}{\textsf{is\_well\_constrained\_integer}}}
\newcommand\unconstrainedinteger[0]{\hyperlink{def-unconstrainedinteger}{\textsf{unconstrained\_integer}}}

\newcommand\checkconstrainedinteger[0]{\hyperlink{def-checkconstrainedinteger}{\texttt{check\_constrained\_integer}}}

\newcommand\staticeval[0]{\hyperlink{def-staticeval}{\texttt{static\_eval}}}
\newcommand\isstaticallyevaluable[0]{\texttt{check\_statically\_evaluable}}

\newcommand\makeanonymous[0]{\hyperlink{def-makeanonymous}{\texttt{make\_anonymous}}}
\newcommand\subtypesrel[0]{\hyperlink{def-subtypesrel}{\texttt{is\_subtype}}}
\newcommand\structsubtypesat[0]{\hyperlink{def-structsubtypesat}{\texttt{structural\_subtype\_satisfies}}}
\newcommand\domsubtypesat[0]{\hyperlink{def-domsubtypesat}{\texttt{domain\_subtype\_satisfies}}}
\newcommand\subtypesat[0]{\hyperlink{def-subtypesat}{\texttt{subtype\_satisfies}}}
\newcommand\checktypesat[0]{\hyperlink{def-checktypesat}{\texttt{checked\_typesat}}}
\newcommand\typeclashes[0]{\hyperlink{def-typeclashes}{\texttt{type\_clashes}}}
\newcommand\lca[0]{\hyperlink{def-lowestcommonancestor}{\texttt{lowest\_common\_ancestor}}}
\newcommand\namedlca[0]{\hyperlink{def-namedlowestcommonancestor}{\texttt{named\_lowest\_common\_ancestor}}}
\newcommand\Supers{\textsf{Supers}}
\newcommand\bitfieldsincluded[0]{\hyperlink{def-bitfieldsincluded}{\texttt{bitfields\_included}}}
\newcommand\membfs[0]{\hyperlink{def-membfs}{\texttt{mem\_bfs}}}
\newcommand\instantiate[0]{\texttt{instantiate}}
\newcommand\canbeinitializedwith[0]{\texttt{can\_be\_initialized\_with}}
\newcommand\getbitvectorwidth[0]{\hyperlink{def-getbitvectorwidth}{\texttt{get\_bitvector\_width}}}
\newcommand\checkbitsequalwidth[0]{\hyperlink{def-checkbitsequalwidth}{\texttt{check\_bits\_equal\_width}}}
\newcommand\findsubprogram[0]{\hyperlink{def-findsubprogram}{\texttt{find\_subprogram}}}
\newcommand\subprogramtypeclash[0]{\texttt{subprogram\_type\_clash}}
\newcommand\hassubprogramtypeclash[0]{\texttt{subprogram\_type\_clash}}
\newcommand\subprogramclash[0]{\hyperlink{def-subprogramclash}{\texttt{subprogram\_clash}}}
\newcommand\argsclash[0]{\texttt{args\_clash}}
\newcommand\bitfieldgetname[0]{\hyperlink{def-bitfieldgetname}{\texttt{bitfield\_get\_name}}}
\newcommand\pairstomap[0]{\hyperlink{def-pairstomap}{\texttt{pairs\_to\_map}}}
\newcommand\assocopt[0]{\hyperlink{def-assocopt}{\texttt{assoc\_opt}}}
\newcommand\annotatefieldinit[0]{\hyperlink{def-annotatefieldinit}{\texttt{annotate\_field\_init}}}
\newcommand\annotatestaticconstrainedinteger[0]{\hyperlink{def-annotatestaticconstrainedinteger}{\texttt{annotate\_static\_constrained\_integer}}}
\newcommand\checkstructurelabel[0]{\hyperlink{def-checkstructurelabel}{\texttt{check\_structure}}}
\newcommand\checkstructureinteger[0]{\hyperlink{def-checkstructureinteger}{\texttt{check\_structure\_integer}}}
\newcommand\checkstaticallyevaluable[0]{\hyperlink{def-checkstaticallyevaluable}{\texttt{check\_statically\_evaluable}}}
\newcommand\storageispure[0]{\hyperlink{def-storageispure}{\texttt{storage\_is\_pure}}}
\newcommand\negateconstraint[0]{\hyperlink{def-negateconstraint}{\texttt{negate\_constraint}}}
\newcommand\getwellconstrainedstructure[0]{\hyperlink{def-getwellconstrainedstructure}{\texttt{get\_well\_constrained\_structure}}}
\newcommand\towellconstrained[0]{\hyperlink{def-towellconstrained}{\texttt{to\_well\_constrained}}}
\newcommand\annotatelebits[0]{\hyperlink{def-annotatelebits}{\texttt{annotate\_lebits}}}
\newcommand\annotatecase[1]{\hyperlink{def-annotatecase}{\texttt{annotate\_case}}(#1)}
\newcommand\getforconstraints[0]{\hyperlink{def-getforconstraints}{\texttt{for\_constraints}}}
\newcommand\minconstraints[0]{\hyperlink{def-minconstraints}{\texttt{min\_constraints}}}
\newcommand\maxconstraints[0]{\hyperlink{def-maxconstraints}{\texttt{max\_constraints}}}
\newcommand\minconstraint[0]{\hyperlink{def-minconstraint}{\texttt{min\_constraint}}}
\newcommand\maxconstraint[0]{\hyperlink{def-maxconstraint}{\texttt{max\_constraint}}}
\newcommand\findbitfieldopt[0]{\hyperlink{def-findbitfieldopt}{\texttt{find\_bitfield\_opt}}}
\newcommand\lookupconstant[0]{\hyperlink{def-lookupconstant}{\texttt{lookup\_constant}}}
\newcommand\typeof[0]{\hyperlink{def-typeof}{\texttt{type\_of}}}
\newcommand\typecheckdecl[0]{\hyperlink{def-typecheckdecl}{\texttt{typecheck\_decl}}}
\newcommand\annotateanddeclarefunc[0]{\hyperlink{def-annotateanddeclarefunc}{\texttt{annotate\_and\_declare\_func}}}
\newcommand\declareglobalstorage[0]{\hyperlink{def-declareglobalstorage}{\texttt{declare\_global\_storage}}}
\newcommand\annotatefuncsig[0]{\hyperlink{def-annotatefuncsig}{\texttt{annotate\_func\_sig}}}
\newcommand\declareonefunc[0]{\hyperlink{def-declareonefunc}{\texttt{declare\_one\_func}}}
\newcommand\checksetterhasgetter[0]{\hyperlink{def-checksetterhashgetter}{\texttt{check\_setter\_has\_getter}}}
\newcommand\addnewfunc[0]{\hyperlink{def-addnewfunc}{\texttt{add\_new\_func}}}
\newcommand\addsubprogram[0]{\hyperlink{def-addsubprogram}{\texttt{add\_subprogram}}}
\newcommand\isundefined[0]{\hyperlink{def-isundefined}{\texttt{is\_undedined}}}
\newcommand\scanforparams[0]{\hyperlink{def-scanforparams}{\texttt{scan\_for\_params}}}
\newcommand\annotateparams[0]{\hyperlink{def-annotateparams}{\texttt{annotate\_params}}}
\newcommand\annotateoneparam[0]{\hyperlink{def-annotateoneparam}{\texttt{annotate\_one\_param}}}
\newcommand\argsasparams[0]{\hyperlink{def-argsasparams}{\texttt{args\_as\_params}}}
\newcommand\argasparam[0]{\hyperlink{def-argasparam}{\texttt{arg\_as\_param}}}
\newcommand\annotatetypeopt[0]{\hyperlink{def-annotatetypeopt}{\texttt{annotate\_type\_opt}}}
\newcommand\annotateexpropt[0]{\hyperlink{def-annotateexpropt}{\texttt{annotate\_expr\_opt}}}
\newcommand\annotateinittype[0]{\hyperlink{def-annotateinittype}{\texttt{annotate\_init\_type}}}
\newcommand\addglobalstorage[0]{\hyperlink{def-addglobalstorage}{\texttt{add\_global\_storage}}}
\newcommand\annotateextrafields[0]{\hyperlink{def-annotateextrafields}{\texttt{annotate\_extra\_fields}}}
\newcommand\declareenumlabels[0]{\hyperlink{def-annotateenumlabels}{\texttt{declare\_enum\_labels}}}
\newcommand\declareconst[0]{\hyperlink{def-declareconst}{\texttt{declare\_const}}}
\newcommand\annotateparamtype[0]{\hyperlink{def-annotateparamtype}{\texttt{annotate\_param\_type}}}
\newcommand\annotateargs[0]{\hyperlink{def-annotateargs}{\texttt{annotate\_args}}}
\newcommand\annotateonearg[0]{\hyperlink{def-annotateonearg}{\texttt{annotate\_one\_arg}}}
\newcommand\annotatereturntype[0]{\hyperlink{def-annotatereturntype}{\texttt{annotate\_return\_type}}}
\newcommand\slicestopositions[0]{\hyperlink{def-slicestopositions}{\texttt{slices\_to\_positions}}}
\newcommand\extractslice[0]{\hyperlink{def-extractslice}{\texttt{extract\_slice}}}
\newcommand\slicetopositions[0]{\hyperlink{def-slicetopositions}{\texttt{slice\_to\_positions}}}
\newcommand\evaltoint[0]{\hyperlink{def-evaltoint}{\texttt{eval\_to\_int}}}
\newcommand\sort[0]{\hyperlink{def-sort}{\texttt{sort}}}
\newcommand\comparemonomialbindings[0]{\hyperlink{def-comparemonomialbindings}{\texttt{compare\_monomial\_bindings}}}

% Symbolic equivalence testing macros
\newcommand\normalize[0]{\hyperlink{def-normalize}{\texttt{normalize}}}
\newcommand\typeequal[0]{\hyperlink{def-typeequal}{\texttt{type\_equal}}}
\newcommand\exprequal[0]{\hyperlink{def-exprequal}{\texttt{expr\_equal}}}
\newcommand\bitwidthequal[0]{\hyperlink{def-bitwidthequal}{\texttt{bitwidth\_equal}}}
\newcommand\bitfieldequal[0]{\hyperlink{def-bitfieldequal}{\texttt{bitfield\_equal}}}
\newcommand\bitfieldsequal[0]{\hyperlink{def-bitfieldsequal}{\texttt{bitfields\_equal}}}
\newcommand\reduceir[0]{\hyperlink{def-reduceir}{\texttt{reduce\_ir}}}
\newcommand\polynomialtoexpr[0]{\hyperlink{def-polynomialtoexpr}{\texttt{polynomial\_to\_expr}}}
\newcommand\monomialtoexpr[0]{\hyperlink{def-monomialtoexpr}{\texttt{monomial\_to\_expr}}}
\newcommand\symmulexpr[0]{\hyperlink{def-symmulexpr}{\texttt{sym\_mul\_expr}}}
\newcommand\symaddexpr[0]{\hyperlink{def-symaddexpr}{\texttt{sym\_add\_expr}}}
\newcommand\monomialstoexpr[0]{\hyperlink{def-monomialstoexpr}{\texttt{monomials\_to\_expr}}}
\newcommand\unitarymonomialstoexpr[0]{\hyperlink{def-unitarymonomialstoexpr}{\texttt{unitary\_monomials\_to\_expr}}}
\newcommand\compareidentifier[0]{\hyperlink{def-compareidentifier}{\texttt{compare\_identifier}}}

\newcommand\subsumes[0]{\hyperlink{def-subsumes}{\texttt{subsumes}}}
\newcommand\symsubsumes[0]{\hyperlink{def-symsubsumes}{\texttt{sym\_subsumes}}}

\newcommand\toir[0]{\hyperlink{def-toir}{\texttt{to\_ir}}}
\newcommand\toircase[0]{\hyperlink{def-toircase}{\texttt{to\_ir\_case}}}
\newcommand\Prod[0]{\hyperlink{def-prod}{\textsf{Prod}}}
\newcommand\Sum[0]{\hyperlink{def-sum}{\textsf{Sum}}}
\newcommand\unitarymonomial[0]{\hyperlink{def-unitarymonomial}{\textsf{unitary\_monomial}}}
\newcommand\monomial[0]{\hyperlink{def-monomial}{\textsf{monomial}}}
\newcommand\polynomial[0]{\hyperlink{def-polynomial}{\textsf{polynomial}}}
\newcommand\addpolynomials[0]{\hyperlink{def-addpolynomials}{\texttt{add\_polynomials}}}
\newcommand\mulpolynomials[0]{\hyperlink{def-mulpolynomials}{\texttt{mul\_polynomials}}}
\newcommand\mulmonomials[0]{\hyperlink{def-mulmonomials}{\texttt{mul\_mononimials}}}

\newcommand\declaredtype[0]{\hyperlink{def-declaredtype}{\texttt{declared\_type}}}

\newcommand\fieldnames[0]{\hyperlink{def-fieldnames}{\texttt{field\_names}}}
\newcommand\fieldtype[0]{\hyperlink{def-fieldtype}{\texttt{field\_type}}}

\newcommand\eliteral[1]{\textsf{E\_Literal}(#1)}

% An expression that we do not statically evaluate.
\newcommand\CannotBeTransformed[0]{\hyperlink{def-unsupportedexpression}{\top}}

\newcommand\unopsignatures[0]{\hyperlink{def-unopsignatures}{\texttt{unop\_signatures}}}
\newcommand\binopsignatures[0]{\hyperlink{def-binopsignatures}{\texttt{binop\_signatures}}}

% Glossary
\newcommand\structure[0]{\hyperlink{def-structure}{structure}}
\newcommand\underlyingtype[0]{\hyperlink{def-underlyingtype}{underlying type}}
\newcommand\symbolicdomain[0]{\hyperlink{def-symbolicdomain}{symbolic domain}}
\newcommand\typesatisfies[0]{\hyperlink{def-typesatisfies}{type-satisfies}}
\newcommand\typesatisfy[0]{\hyperlink{def-typesatisfies}{type-satisfy}}
\newcommand\checkedtypesatisfies[0]{\hyperlink{def-checktypesat}{checked-type-satisfies}}
\newcommand\typesatisft[0]{\hyperlink{def-typesatisfies}{type-satisft}}
\newcommand\subtypesatisfies[0]{\hyperlink{def-subtypesatisfies}{subtype-satisfies}}
\newcommand\subtypesatisfy[0]{\hyperlink{def-subtypesatisfies}{subtype-satisfisfy}}
\newcommand\typeequivalent[0]{\hyperlink{def-typeequal}{type-equivalent}}
\newcommand\bitwidthequivalent[0]{\hyperlink{def-bitwidthequal}{bitwidth-equivalent}}
\newcommand\typeclash[0]{\hyperlink{def-typeclashes}{type-clash}}
\newcommand\constrainedinteger[0]{\hyperlink{def-checkconstrainedinteger}{constrained integer}}
\newcommand\structureofinteger[0]{\hyperlink{def-checkstructureinteger}{structure of an integer}}
\newcommand\staticallyevaluable[0]{\hyperlink{def-staticallyevaluable}{statically evaluable}}
\newcommand\pure[0]{\hyperlink{def-storageispure}{pure}}
\newcommand\wellconstrainedstructure[0]{\hyperlink{def-getwellconstrainedstructure}{well-constrained structure}}
\newcommand\wellconstrainedversion[0]{\hyperlink{def-towellconstrained}{well-constrained version}}
\newcommand\namedlowestcommonancestor[0]{\hyperlink{def-namedlowestcommonancestor}{named lowest common ancestor}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type functions
\newcommand\CheckUnop[0]{\hyperlink{def-checkunop}{\texttt{check\_unop}}}
\newcommand\CheckBinop[0]{\hyperlink{def-checkbinop}{\texttt{check\_binop}}}
\newcommand\constraintbinop[0]{\texttt{constraint\_binop}}
\newcommand\sliceswidth[0]{\texttt{slices\_width}}
\newcommand\annotatetype[1]{\hyperlink{def-annotatetype}{\texttt{annotate\_type}}(#1)}
\newcommand\annotateexpr[1]{\hyperlink{def-annotateexpr}{\texttt{annotate\_expr}}(#1)}
\newcommand\annotateexprlist[1]{\hyperlink{def-annotateexprs}{\texttt{annotate\_exprs}}(#1)}
\newcommand\annotatelexpr[1]{\hyperlink{def-annotatelexpr}{\texttt{annotate\_lexpr}}(#1)}
\newcommand\annotatearrayindex[0]{\texttt{annotate\_array\_index}}
\newcommand\annotateslice[0]{\hyperlink{def-annotateslice}{\texttt{annotate\_slice}}}
\newcommand\annotateslices[0]{\hyperlink{def-annotateslices}{\texttt{annotate\_slices}}}
\newcommand\annotatepattern[0]{\hyperlink{def-annotatepattern}{\texttt{annotate\_pattern}}}
\newcommand\annotatelocaldeclitem[1]{\hyperlink{def-annotatelocaldeclitem}{\texttt{annotate\_local\_decl\_item}}(#1)}
\newcommand\annotatestmt[1]{\hyperlink{def-annotatestmt}{\texttt{annotate\_stmt}}(#1)}
\newcommand\annotateblock[1]{\hyperlink{def-annotateblock}{\texttt{annotate\_block}}(#1)}
\newcommand\inlinesetter[1]{\texttt{setter\_should\_reduce\_to\_call\_s}(#1)}
\newcommand\annotatecall[1]{\hyperlink{def-annotatecall}{\texttt{annotate\_call}}(#1)}
\newcommand\annotatecatcher[1]{\hyperlink{def-annotatecatcher}{\texttt{annotate\_catcher}}(#1)}
\newcommand\reduceconstants[0]{\hyperlink{def-reduceconstants}{\texttt{reduce\_constants}}}
\newcommand\declarelocalconstant[1]{\texttt{declare\_local\_constant}(#1)}
\newcommand\annotatelocaldeclitemuninit[1]{\texttt{annotate\_local\_decl\_item\_uninit}(#1)}
\newcommand\checkvarnotinenv[1]{\hyperlink{def-checkvarnotinenv}{\texttt{check\_var\_not\_in\_env}}(#1)}
\newcommand\checkvarnotingenv[1]{\hyperlink{def-checkvarnotingenv}{\texttt{check\_var\_not\_in\_genv}}(#1)}
\newcommand\varinenv[1]{\hyperlink{def-varinenv}{\texttt{var\_in\_env}}(#1)}
\newcommand\annotatesubprogram[1]{\hyperlink{def-annotatesubprogram}{\texttt{annotate\_subprogram}}(#1)}
\newcommand\annotatedecl[1]{\hyperlink{def-annotatedecl}{\texttt{annotate\_decl}}(#1)}
\newcommand\declaredecl[1]{\hyperlink{def-declaredecl}{\texttt{declare\_decl}}(#1)}
\newcommand\annotatespec[1]{\texttt{annotate\_spec}(#1)}
\newcommand\evalexpr[1]{\texttt{eval\_expr}(#1)}
\newcommand\evalconstraint[1]{\texttt{eval\_constraint}(#1)}
\newcommand\annotateliteral[1]{\hyperlink{def-annotateliteral}{\texttt{annotate\_literal}}(#1)}
\newcommand\exprequalcase[0]{\hyperlink{def-exprequalcase}{\texttt{expr\_equal\_case}}}
\newcommand\exprequalnorm[0]{\hyperlink{def-exprequalnorm}{\texttt{expr\_equal\_norm}}}
\newcommand\slicesequal[0]{\hyperlink{def-slicesequal}{\texttt{slices\_equal}}}
\newcommand\sliceequal[0]{\hyperlink{def-sliceequal}{\texttt{slice\_equal}}}
\newcommand\constraintsequal[0]{\hyperlink{def-constraintsequal}{\texttt{constraints\_equal}}}
\newcommand\constraintequal[0]{\hyperlink{def-constraintequal}{\texttt{constraint\_equal}}}
\newcommand\arraylengthequal[0]{\hyperlink{def-arraylengthequal}{\texttt{array\_length\_equal}}}
\newcommand\literalequal[0]{\hyperlink{def-literalequal}{\texttt{literal\_equal}}}
\newcommand\findcheckdeduce[0]{\hyperlink{def-findcheckdeduce}{\texttt{find\_check\_deduce}}}
%\newcommand\renametyeqs[0]{\texttt{rename\_ty\_eqs}}
\newcommand\annotatebitfield[0]{\hyperlink{def-annotatebitfield}{\texttt{annotate\_bitfield}}}
\newcommand\annotatebitfields[0]{\hyperlink{def-annotatebitfields}{\texttt{annotate\_bitfields}}}
\newcommand\checknoduplicates[0]{\hyperlink{def-checknoduplicates}{\texttt{check\_no\_duplicates}}}
\newcommand\reduceslicestocall[0]{\hyperlink{def-reduceslicestocall}{\texttt{reduce\_slices\_to\_call}}}
\newcommand\typeofarraylength[0]{\hyperlink{def-typeofarraylength}{\texttt{type\_of\_array\_length}}}
\newcommand\addlocal[0]{\hyperlink{def-addlocal}{\texttt{add\_local}}}
\newcommand\declaretype[0]{\hyperlink{def-declaretype}{\texttt{declare\_type}}}
\newcommand\subprogramtypesclash[0]{\hyperlink{def-subprogramtypeclash}{\texttt{subprogram\_types\_clash}}}
\newcommand\subprogramforname[0]{\hyperlink{def-subprogramforname}{\texttt{subprogram\_for\_name}}}
\newcommand\hasargclash[0]{\hyperlink{def-hasargclash}{\texttt{has\_arg\_clash}}}
\newcommand\filtercallcandidates[0]{\hyperlink{def-filtercandidates}{\texttt{filter\_call\_candidates}}}
\newcommand\deduceeqs[0]{\hyperlink{def-deduceeqs}{\texttt{deduce\_eqs}}}
\newcommand\getundeclareddefining[0]{\hyperlink{def-getundeclareddefining}{\texttt{get\_undeclared\_defining}}}
\newcommand\bintounsigned[0]{\hyperlink{def-bintounsigned}{\textsf{binary\_to\_unsigned}}}
\newcommand\inttobits[0]{\hyperlink{def-inttobits}{\texttt{int\_to\_bits}}}

% Symbolic domain subsumption
\newcommand\symdom[0]{\hyperlink{def-symdom}{\textsf{sym\_dom}}}
\newcommand\intset[0]{\hyperlink{def-intset}{\textsf{int\_set}}}
\newcommand\syntax[0]{\hyperlink{def-syntax}{\textsf{syntax}}}

\newcommand\DBool[0]{\hyperlink{def-dbool}{\textsf{D\_Bool}}}
\newcommand\DString[0]{\hyperlink{def-dstring}{\textsf{D\_String}}}
\newcommand\DReal[0]{\hyperlink{def-dreal}{\textsf{D\_Real}}}
\newcommand\DSymbols[0]{\hyperlink{def-dsymbols}{\textsf{D\_Symbols}}}
\newcommand\DInt[0]{\hyperlink{def-dint}{\textsf{D\_Int}}}
\newcommand\DBits[0]{\hyperlink{def-dbits}{\textsf{D\_Bits}}}

\newcommand\Finite[0]{\hyperlink{def-finite}{\textsf{Finite}}}
\newcommand\Top[0]{\hyperlink{def-top}{\textsf{Top}}}
\newcommand\FromSyntax[0]{\hyperlink{def-fromsymtax}{\textsf{FromSyntax}}}

\newcommand\symdomoftype[0]{\hyperlink{def-symdomoftype}{\texttt{symdom\_of\_type}}}
\newcommand\symdomofexpr[0]{\hyperlink{def-symdomofexpr}{\texttt{symdom\_of\_expr}}}
\newcommand\symdomofliteral[0]{\hyperlink{def-symdomofliteral}{\texttt{symdom\_of\_literal}}}
\newcommand\intsetofintconstraints[0]{\hyperlink{def-intsetofintconstraintse}{\texttt{intset\_of\_intconstraints}}}
\newcommand\symdomissubset[0]{\hyperlink{def-symdomissubset}{\texttt{symdom\_is\_subset}}}
\newcommand\symintsetsubset[0]{\hyperlink{def-symintsetsubset}{\texttt{sym\_intset\_subset}}}

%% Type Error codes
\newcommand\TypeErrorCode[1]{\texttt{TE\_#1}}
\newcommand\UndefinedIdentifier[0]{\hyperlink{def-undefinedidentifier}{\TypeErrorCode{UI}}}
\newcommand\SetterWithoutGetter[0]{\hyperlink{def-setterwithoutgetter}{\TypeErrorCode{SWG}}}
\newcommand\ExpectedBitvectorType[0]{\hyperlink{def-expectedbitvectortype}{\TypeErrorCode{EBT}}}
\newcommand\SubrogramDeclaredMultipleTimes[0]{\hyperlink{def-subprogramdeclaredmultipletimes}{\TypeErrorCode{SDM}}}
\newcommand\NoCallCandidates[0]{\hyperlink{def-nocallcandidates}{\TypeErrorCode{NCC}}}
\newcommand\TooManyCandidates[0]{\hyperlink{def-toomanycandidates}{\TypeErrorCode{TMC}}}
\newcommand\ParameterWithoutDecl[0]{\hyperlink{def-parameterwithoutdecl}{\TypeErrorCode{PWD}}}
\newcommand\NoLCA[0]{\hyperlink{def-nolca}{\TypeErrorCode{LCA}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Typeset variable names
\newcommand\newtenv[0]{\texttt{new\_tenv}}
\newcommand\tenvone[0]{\texttt{tenv1}}
\newcommand\tenvonep[0]{\texttt{tenv1'}}
\newcommand\tenvonepp[0]{\texttt{tenv1''}}
\newcommand\tenvtwo[0]{\texttt{tenv2}}
\newcommand\tenvtwop[0]{\texttt{tenv2'}}
\newcommand\tenvtwopp[0]{\texttt{tenv2''}}
\newcommand\vc[0]{\texttt{c}}
\newcommand\vcone[0]{\texttt{c1}}
\newcommand\vctwo[0]{\texttt{c2}}
\newcommand\vione[0]{\texttt{i1}}
\newcommand\vitwo[0]{\texttt{i2}}
\newcommand\vf[0]{\texttt{f}}
\newcommand\vfone[0]{\texttt{f1}}
\newcommand\vftwo[0]{\texttt{f2}}
\newcommand\vl[0]{\texttt{l}}
\newcommand\vm[0]{\texttt{m}}
\newcommand\vmone[0]{\texttt{m1}}
\newcommand\vmtwo[0]{\texttt{m2}}
\newcommand\vy[0]{\texttt{y}}
\newcommand\vp[0]{\texttt{p}}
\newcommand\vo[0]{\texttt{o}}
\newcommand\vvone[0]{\texttt{v1}}
\newcommand\vvtwo[0]{\texttt{v2}}
\newcommand\vt[0]{\texttt{t}}
\newcommand\vte[0]{\texttt{t\_e}}
\newcommand\veone[0]{\texttt{e1}}
\newcommand\vetwo[0]{\texttt{e2}}
\newcommand\vethree[0]{\texttt{e3}}
\newcommand\vefour[0]{\texttt{e4}}
\newcommand\vefive[0]{\texttt{e5}}
\newcommand\vleone[0]{\texttt{le1}}
\newcommand\vletwo[0]{\texttt{le2}}
\newcommand\vtleone[0]{\texttt{t\_le1}}
\newcommand\vre[0]{\texttt{re}}
\newcommand\vs[0]{\texttt{s}}
\newcommand\vtsone[0]{\texttt{ts1}}
\newcommand\vtstwo[0]{\texttt{ts2}}
\newcommand\vlt[0]{\texttt{l\_t}}
\newcommand\vls[0]{\texttt{l\_s}}
\newcommand\vtt[0]{\texttt{t\_t}}
\newcommand\vts[0]{\texttt{t\_s}}
\newcommand\vsone[0]{\texttt{s1}}
\newcommand\vstwo[0]{\texttt{s2}}
\newcommand\vz[0]{\texttt{z}}
\newcommand\vw[0]{\texttt{w}}
\newcommand\vwone[0]{\texttt{w1}}
\newcommand\vwtwo[0]{\texttt{w2}}
\newcommand\vwidth[0]{\texttt{width}}
\newcommand\size[0]{\texttt{size}}
\newcommand\vfield[0]{\texttt{field}}
\newcommand\vfieldone[0]{\texttt{field1}}
\newcommand\vfieldtwo[0]{\texttt{field2}}
\newcommand\vfieldsone[0]{\texttt{fields1}}
\newcommand\vfieldstwo[0]{\texttt{fields2}}
\newcommand\bitfields[0]{\texttt{bitfields}}
\newcommand\bfone[0]{\texttt{bf1}}
\newcommand\bftwo[0]{\texttt{bf2}}
\newcommand\bfoneone[0]{\texttt{bf1\_1}}
\newcommand\bftwoone[0]{\texttt{bf2\_1}}
\newcommand\vslices[0]{\texttt{slices}}
\newcommand\newle[0]{\texttt{new\_le}}
\newcommand\ldi[0]{\texttt{ldi}}
\newcommand\ldk[0]{\texttt{ldk}}
\newcommand\tsy[0]{\texttt{sy}}
\newcommand\tyopt[0]{\texttt{ty\_opt}}
\newcommand\ldis[0]{\texttt{ldis}}
\newcommand\newldi[0]{\texttt{new\_ldi}}
\newcommand\news[0]{\texttt{new\_s}}
\newcommand\newsone[0]{\texttt{new\_s1}}
\newcommand\newstwo[0]{\texttt{new\_s2}}
\newcommand\newargs[0]{\texttt{new\_args}}
\newcommand\eqs[0]{\texttt{eqs}}
\newcommand\neweqs[0]{\texttt{new\_eqs}}
\newcommand\reduced[0]{\texttt{reduced}}
\newcommand\tcond[0]{\texttt{t\_cond}}
\newcommand\econd[0]{\texttt{e\_cond}}
\newcommand\vcond[0]{\texttt{v\_cond}}
\newcommand\etrue[0]{\texttt{e\_true}}
\newcommand\efalse[0]{\texttt{e\_false}}
\newcommand\ttrue[0]{\texttt{t\_true}}
\newcommand\tfalse[0]{\texttt{t\_false}}
\newcommand\dir[0]{\texttt{dir}}
\newcommand\eindex[0]{\texttt{e\_index}}
\newcommand\wantedtindex[0]{\texttt{wanted\_t\_index}}
\newcommand\tindex[0]{\texttt{t\_index}}
\newcommand\fieldname[0]{\texttt{field\_name}}
\newcommand\fields[0]{\texttt{fields}}
\newcommand\fieldsone[0]{\texttt{fields1}}
\newcommand\fieldstwo[0]{\texttt{fields2}}
\newcommand\slices[0]{\texttt{slices}}
\newcommand\newe[0]{\texttt{new\_e}}
\newcommand\ta[0]{\texttt{ta}}
\newcommand\les[0]{\texttt{les}}
\newcommand\subtys[0]{\texttt{sub\_tys}}
\newcommand\catchers[0]{\texttt{catchers}}
\newcommand\otherwise[0]{\texttt{otherwise}}
\newcommand\csone[0]{\texttt{cs1}}
\newcommand\cstwo[0]{\texttt{cs2}}
\newcommand\irone[0]{\texttt{ir1}}
\newcommand\irtwo[0]{\texttt{ir2}}
\newcommand\vpone[0]{\texttt{p1}}
\newcommand\vptwo[0]{\texttt{p2}}
\newcommand\vps[0]{\texttt{ps}}
\newcommand\opone[0]{\texttt{op1}}
\newcommand\optwo[0]{\texttt{op2}}
\newcommand\vep[0]{\texttt{e'}}
\newcommand\veoneone[0]{\texttt{e1\_1}}
\newcommand\veonetwo[0]{\texttt{e1\_2}}
\newcommand\veonethree[0]{\texttt{e1\_3}}
\newcommand\vetwoone[0]{\texttt{e2\_1}}
\newcommand\vetwotwo[0]{\texttt{e2\_2}}
\newcommand\vetwothree[0]{\texttt{e2\_3}}
\newcommand\vbone[0]{\texttt{b1}}
\newcommand\vbtwo[0]{\texttt{b2}}
\newcommand\vbthree[0]{\texttt{b3}}
\newcommand\nameone[0]{\texttt{name1}}
\newcommand\nametwo[0]{\texttt{name2}}
\newcommand\vargsone[0]{\texttt{args1}}
\newcommand\vargstwo[0]{\texttt{args2}}
\newcommand\vargone[0]{\texttt{arg1}}
\newcommand\vargtwo[0]{\texttt{arg2}}
\newcommand\vlone[0]{\texttt{l1}}
\newcommand\vltwo[0]{\texttt{l2}}
\newcommand\sliceone[0]{\texttt{slice1}}
\newcommand\slicetwo[0]{\texttt{slice2}}
\newcommand\slicesone[0]{\texttt{slices1}}
\newcommand\slicestwo[0]{\texttt{slices2}}
\newcommand\positions[0]{\texttt{positions}}
\newcommand\posmax[0]{\texttt{pos\_max}}
\newcommand\bv[0]{\texttt{bv}}
\newcommand\bvone[0]{\texttt{bv1}}
\newcommand\vtp[0]{\texttt{t'}}
\newcommand\vli[0]{\texttt{li}}
\newcommand\tys[0]{\texttt{tys}}
\newcommand\name[0]{\texttt{name}}
\newcommand\newname[0]{\texttt{new\_name}}

% Increase indentation of sections in the table of contents
% to allow a space between the section numbers and their titles.
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{2.6em}}
\makeatother
\setcounter{tocdepth}{1}

\author{Arm Architecture Technology Group}
\title{ASL Typing Reference \\
       DDI 0622}
\begin{document}
\maketitle

\tableofcontents{}

\include{notice.tex}

\include{disclaimer.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The purpose of this document is to describe, in a formal and authoritative way,
which ASL specifications are considered \emph{well-typed}.
Whether a specification is well-typed is defined in terms of a \emph{type system}~\cite{TypeSystemsLucaCardelli}.
That is, a set of \emph{typing rules}.

An ASL parser accepts an ASL specification and checks whether it is valid with respect to the syntax of ASL,
which is defined in~\cite{ASLAbstractSyntaxReference}.
If the specification is syntactically valid, the parser returns an \emph{abstract syntax tree} (AST, for short),
which represents the specification as a labelled structured tree. Otherwise, it returns a syntax error.
When an ASL specification is successfully parsed, we refer to the resulting AST as the \emph{parsed AST}.

A \emph{type checker} is an implementation of the ASL type system, which accepts a parsed AST and applies the
rules of the type system to the parsed AST. If it is successful, the specification
is considered \emph{well-typed} and the result is a pair consisting of
a \emph{static environment} and a \emph{typed AST}, which are used in defining the ASL semantics~\cite{ASLSemanticsReference}.
Otherwise, the type checker returns a type error.

\paragraph{Related documents:}
\begin{itemize}
  % \item The ASL Language Reference Manual~\cite{LRM} (LRM, for short) introduces the concrete syntax and intent
  % of all ASL language constructs.
  % Please note that the LRM will be retired in due course. For ease of reviewing, we currently indicate which statement
  % of the LRM the present rules correspond to.
  \item The Abstract Syntax Reference~\cite{ASLAbstractSyntaxReference} defines the abstract syntax, parsed AST, and typed AST.
  \item The ASL Semantics Reference~\cite{ASLSemanticsReference} defines all valid behaviors of a well-typed ASL specification.
\end{itemize}

\paragraph{Understanding the Typing Formalization:}
We assume basic familiarity with the ASL language.
The ASL type system is defined in terms of its AST,
and familiarity with the AST is \underline{required} to understand it.
The mathematical background needed to understand the mathematical formalization
of the ASL semantics appears in \chapref{formal} and \chapref{typesystembuildingblocks}.

\include{ASLFormal}

\section{Reading guide}
The typing rules are organized into chapters, which roughly group the rules by their AST node type.
The set of rules in each chapter is further split according to additional syntactic and semantic
predicates over the AST node.
For example, an expression can be a literal, or a binary operator, amongst other
things. Each of those has its own evaluation rule: TypingRule.ELit in
\secref{TypingRule.ELit} and
Typing.Binop in \secref{TypingRule.Binop}, respectively.

Each rule is presented using the following template:
\begin{itemize}
\item a Prose paragraph gives the rule in English, and corresponds as much as possible to the code of the reference implementation ASLRef given at
\href{https://github.com/herd/herdtools7//tree/master/asllib}{/herdtools7/asllib};
\item one or several Example paragraphs, which as much as possible are also given as regression tests in
\href{https://github.com/herd/herdtools7//tree/master/asllib/tests/ASLTypingReference.t}{/herdtools7/asllib/tests/ASLTypingReference.t};
\ifcode
\item a Code paragraph which gives a verbatim of the corresponding OCaml implementation in the type-checker of ASLRef
\href{https://github.com/herd/herdtools7//tree/master/asllib/Typing.ml}{/herdtools7/asllib/Typing.ml};
\fi
\item Formal paragraphs which give formal definitions of the rule.
\item Comments paragraphs, which provide additional details. %refer to one or more rules from the Language Reference Manual~\cite{LRM} and
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Type System Building Blocks}
\label{chap:typesystembuildingblocks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter defines necessary mathematical types and concepts for the ASL system.

Types are represented by ASTs derived from the non-terminal $\ty$ (see \cite{ASLAbstractSyntaxReference}
for the precise definition of $\ty$).

\section{Static Environments}

A \emph{static environment} (also called a \emph{type environment}) is what the typing rules operate over:
a structure, which amongst other things, associates types to variables.
Throughout this document, we will use the term environment for static environment, unless otherwise stated.
Intuitively, the typing of a
specification makes an initial environment evolve, with new types as given by the
variable declarations of the specification.

\begin{definition}
\hypertarget{def-staticenvs}{}
Static environments, denoted as $\staticenvs$, are defined as follows (referring to symbols defined by the abstract syntax):
\[
\begin{array}{rcl}
\staticenvs 	          &\triangleq& \mathbb{G} \times \mathbb{L}\\
\mathbb{G} 	            &\triangleq& \declaredtypes \times \constantvalues \times \globalstoragetypes\\
  			                &          & \times\ \subtypes \times \subprograms \times \subprogramrenamings\\
\mathbb{L} 	            &\triangleq& \constantvalues \times \localstoragetypes \times \returntype\\
\hline
\declaredtypes	        &\triangleq& \identifier \partialto \ty\\
\constantvalues         &\triangleq& \identifier \partialto \literal\\
\globalstoragetypes     &\triangleq& \identifier \partialto \ty \times \globaldeclkeyword\\
\localstoragetypes      &\triangleq& \identifier \partialto \ty \times \localdeclkeyword\\
\subtypes		            &\triangleq& \identifier \partialto \identifier\\
\subprograms	          &\triangleq& \identifier \partialto \func\\
\subprogramrenamings	  &\triangleq& \identifier \rightarrow \pow{\Strings}\\
\returntype             &\triangleq& \langle \ty \rangle
\end{array}
\]
\end{definition}

We use $\tenv$ to range over static environments.

A static environment $\tenv=(G^\tenv, L^\tenv)$ consists of two
distinct components: the global environment $G^\tenv$---pertaining to AST nodes
appearing outside of a given subprogram, and the local environment
$L^\tenv$---pertaining to AST nodes appearing inside a given subprogram.
This separation allows us to type-check subprograms by using an empty local environment.

The intuitive meaning of each component is as follows:
\begin{itemize}
  \hypertarget{def-declaredtypes}{}
  \item $\declaredtypes$ assigns types to their declared names;
  \hypertarget{def-constantvalues}{}
  \item $\constantvalues$ assigns literals to their declaring (constant) names;
  \hypertarget{def-globalstoragetypes}{}
  \item $\globalstoragetypes$ associates names of global storage elements to their inferred type
  and how they were declared --- as constants, configuration variables, \texttt{let} variables,
  or mutable variables;
  \hypertarget{def-localstoragetypes}{}
  \item $\localstoragetypes$ associates names of local storage elements to their inferred type
  and how they were declared --- as variables, constants, or as \texttt{let} variables;
  \hypertarget{def-subtypes}{}
  \item $\subtypes$ associates type names to the names that their type subtypes;
  \hypertarget{def-subprograms}{}
  \item $\subprograms$ associates names of subprograms to the $\func$ AST node they were
  declared with;
  \hypertarget{def-subprogramrenamings}{}
  \item $\subprogramrenamings$ associates names of subprograms to the set of overloading
  subprograms ---  $\func$ AST nodes that share the same name;
  \hypertarget{def-returntype}{}
  \item $\returntype$ contains the name of the type that a subprogram declares, if it is
  a function or a getter.
\end{itemize}

\hypertarget{def-emptytenv}{}
\begin{definition}[Empty Static Environment]
  The \emph{empty static environment}, \\ denoted as $\emptytenv$, is defined as follows:
  \[
    \emptytenv \triangleq \left(
      \begin{array}{c}
        \overname{
      (\overname{\emptyfunc}{\declaredtypes},
      \overname{\emptyfunc}{\constantvalues},
      \overname{\emptyfunc}{\globalstoragetypes},
      \overname{\emptyfunc}{\subtypes},
      \overname{\emptyfunc}{\subprograms},
      \overname{\emptyfunc}{\subprogramrenamings})}{G},\\
      \overname{
      (
        \overname{\emptyfunc}{\constantvalues},
        \overname{\emptyfunc}{\localstoragetypes},
        \overname{\None}{\returntype}
      )}{L}
      \enspace.
    \end{array}
    \right)
  \]
\end{definition}

The global environment and local environment consist of various components.
We use the notation $G^\tenv.m$ and $L^\tenv.m$ to access the $m$ component of a given environment.

To update a function component $f$ (e.g., $\declaredtypes$) of an environment $\tenv$ (either local or global)
with a new mapping $x \mapsto v$, we use the notation $\tenv.f[x \mapsto v]$ to stand for $\tenv[f \mapsto E.f[x \mapsto v]]$.

\lrmcomment{This is related to \identd{JRXM} and \identi{ZTMQ}.}

\section{Constrained Types}
\begin{itemize}
  \item A \emph{constrained type} is a type whose definition relies on an expression, for example, certain integers and bitvectors.
  \item A type which is not constrained is \emph{unconstrained}.
  \item A constrained type with a non-empty constraint is \emph{well-constrained}.
  \item An \emph{under-constrained integer type} is an implicit type of a subprogram parameter.
  \end{itemize}
The widths of bitvector storage elements are constrained integers.

\hypertarget{def-isunconstrainedinteger}{}
\hypertarget{def-isunderconstrainedinteger}{}
\hypertarget{def-iswellconstrainedinteger}{}
We define the following helper predicates to classify integer types:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \isunderconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool\\
  \iswellconstrainedinteger(\overname{\ty}{\vt}) &\aslto& \Bool
  \end{array}
\]

We define the following shorthands for classifying integers:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\vt) &\triangleq& \vt = \TInt(\unconstrained)\\
  \isunderconstrainedinteger(\vt) &\triangleq& \vt = \TInt(\Ignore)\\
  \iswellconstrainedinteger(\vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\wellconstrained\\
\end{array}
\]

\subsection{Comments}
\lrmcomment{This is related to \identd{ZTPP}, \identr{WJYH}, \identr{HJPN}, \identr{CZTX}, \identr{TPHR}.}

\section{ASL Type System}
\hypertarget{def-annotaterel}{}
The type system of ASL is given by the relation $\annotaterel$, which is defined as the disjoint union
of the partial functions and relations defined in this document.
The \hyperlink{def-partialfunc}{partial functions} and relations in this document are defined, in turn, via type system rules.

The output configurations of type assertions have two flavors:
\begin{description}
  \item[Normal Outputs.] \hypertarget{def-normal-type-outputs}{}
  Configurations are typically tuples with different combinations
  of \emph{static environments}, types, and Boolean values.

  \hypertarget{def-typeerror}{}
  \item[Type Errors.] Configurations in $\TypeError(\texttt{<string>})$
  represent type errors, for example, using an integer type as a condition expression, as in \verb|if 5 then 1 else 2|.
  The ASL type system is designed such that when these \emph{type error configurations} appear,
  the typing of the entire specification terminates by outputting them.
\end{description}

We define the mathematical type of type error configurations
(which is needed to define the types of functions in the ASL type system)
as follows:
\hypertarget{def-ttypeerror}{}
\[
  \TTypeError \triangleq \{\TypeErrorVal{\vs} \;|\; \vs \in \texttt{<string>} \} \enspace.
\]

\hypertarget{def-typeerrorconfig}{}
and the shorthand $\TypeErrorConfig \triangleq \TypeError(\vs)$ for type error configurations.

% \hypertarget{def-proseortypeerror}{}
% Specifically,\ProseOrTypeError\ means: ``or a type error configuration $\TypeErrorConfig$, which short-circuits the rule,
% making it transition into the type error configuration $\TypeErrorConfig$.''.
%
When several \hyperlink{def-caserules}{case rules} for the same function use the same short-circuiting transition assertion,
we do not repeat the\ProseOrTypeError, but rather include it only in the first rule.

% \subsection*{Rule Example}
% The following rule is used to type a sequence of two statements:
% \[
% \inferrule{
%   \annotatestmt{\tenv, \vs1} = (\newsone, \tenvone)\\
%   \annotatestmt{\tenvone, \vs2} = (\newstwo, \tenvtwo)\\
% }
% {
%   \annotatestmt{\tenv, \SSeq(\vsone, \vstwo)} = (\SSeq(\newsone, \newstwo), \tenvtwo)
% }
% \]
% The rule uses the annotation function $\annotatestmt{\cdot}$, which
% accepts an environment $\tenv$ and two statements and returns a new statement and a new environment.
% The function returns a new statement in order to implement certain code transformations, such as
% inlining setter functions.

\section{Annotation}

Typing a specification consists of annotating the root of its AST with the rules defined
in the remainder of this document.

% The rules are organized into groups that define functions to annotate different types of nodes:
% \begin{itemize}
% \item \texttt{annotate\_expr} annotates expressions;
% \item \texttt{annotate\_slices} annotates slices;
% \item \texttt{annotate\_pattern} annotates pattern;
% \item \texttt{annotate\_local\_decl\_item} annotates local declarations;
% \item \texttt{annotate\_lexpr} annotates left-hand sides of assignments;
% \item \texttt{annotate\_stmt} annotates statements;
% \item \texttt{annotate\_block} annotates blocks;
% \item \texttt{annotate\_catcher} annotates catchers;
% \item \texttt{annotate\_call} annotates functions calls;
% \item \texttt{annotate\_func} annotates functions.
% \end{itemize}

\paragraph{Shorthand Notations:}
\hypertarget{def-elit}{}
\newcommand\ELInt[1]{\hyperlink{def-elit}{\texttt{ELInt}}(#1)}
We use the shorthand $\ELInt{n}$ for the expression denoting the literal integer value $n$. That is, $\ELiteral(\overname{\lint(n)}{\vr})$.

\hypertarget{def-unconstrainedinteger}{}
We use the shorthand notation $\unconstrainedinteger$ to denote the unconstrained integer type: $\TInt(\unconstrained)$.

Note that throughout this document we use $\tty$ to denote a type variable, which should not be confused with the abstract syntax variable $\ty$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Domain of Values for Types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter formalises the concept of the set of values for a given type.
The formalism is given in the form of rules.
%
The chapter also defines the concept of checking whether the set of values
for one type is included in the set of values for another type.

\hypertarget{def-vals}{}
\section{Native Values \label{sec:nativevalues}}

Types define sets of values that variables can take when a specification is executed.
To formalize this, we define the set of \emph{native values}, denoted $\vals$,
as the minimal set defined by the following recursive rules (\texttt{NV} stands for Native Value):
\hypertarget{def-nvliteral}{}
\hypertarget{def-nvvector}{}
\hypertarget{def-nvrecord}{}
\begin{mathpar}
  \inferrule[(Basis Set: Integers, Reals, Booleans, Strings, and Bitvectors)]
  {\vv \in \literal}
  { \nvliteral{\vv} \in \vals }
  \and
  \inferrule[(Tuple Values and Array Values)]{\vvl \in \vals^*}
  { \nvvector{\vvl} \in \vals }
  \and
  \inferrule[(Record Values)]
  {\vr : \Identifiers \rightarrowfin \vals}
  { \nvrecord{\vr} \in \vals }
\end{mathpar}

We define the following shorthands for native value literals:
\hypertarget{def-nvint}{}
\[
\begin{array}{rcl}
\nvint(z)       &\triangleq& \nvliteral{\lint(z)}           \hypertarget{def-nvbool}{}\\
\nvbool(b)      &\triangleq& \nvliteral{\lbool(b)}          \hypertarget{def-nvreal}{}\\
\nvreal(r)      &\triangleq& \nvliteral{\lreal(r)}          \hypertarget{def-nvstring}{}\\
\nvstring(s)    &\triangleq& \nvliteral{\lstring(s)}        \hypertarget{def-nvbitvector}{}\\
\nvbitvector(v) &\triangleq& \nvliteral{\lbitvector(v)}\\
\end{array}
\]

We define the following types of native values:
\hypertarget{def-tint}{}
\[
\begin{array}{rcl}
  \tint       &\triangleq& \{ \nvint(z) \;|\; z \in \Z\}                                        \hypertarget{def-tbool}{}\\
  \tbool      &\triangleq& \{ \nvbool(\True), \nvbool(\False) \}                                \hypertarget{def-treal}{}\\
  \treal      &\triangleq& \{ \nvreal(r) \;|\; r \in \Q\}                                       \hypertarget{def-tstring}{}\\
  \tstring    &\triangleq& \{ \nvstring(s) \;|\; \texttt{"}s\texttt{"} \in \texttt{<string>}\}  \hypertarget{def-tbitvector}{}\\
  \tbitvector &\triangleq& \{ \nvbitvector(\textit{bits}) \;|\; \textit{bits} \in \{0,1\}^*\}   \hypertarget{def-tvector}{}\\
  \tvector    &\triangleq& \{ \nvvector{\textit{vals}} \;|\; \textit{vals} \in \vals^*\}        \hypertarget{def-trecord}{}\\
  \trecord  &\triangleq& \{ \nvrecord{\fieldmap} \;|\; \fieldmap \in \Identifiers\rightarrow\vals\}\\
\end{array}
\]

\section{Dynamic Domain of a Type}
\hypertarget{def-dyndomain}{}

We now define the concept of a \emph{dynamic domain} of a type
and the \emph{static domain} of a type.
Intuitively, domains assign potentially infinite sets of native values to types.
Dynamic domains are used by the semantics to evaluate expressions of the form \texttt{UNKNOWN: t}
by choosing a single value from the dynamic domain of $\vt$.
Static domains are used to define (domain) subtype satisfaction in \secref{TypingRule.DomainSubtypeSatisfaction}.

\hypertarget{def-dynamicenvs}{}
The definition of a dynamic domain refers to \emph{dynamic environments}, denoted $\dynamicenvs$,
which assigns native values to identifiers~\cite{ASLSemanticsReference}.

\hypertarget{def-envs}{}
We define \emph{environments} as pairs of static environments and dynamic environments:
$\envs \triangleq \staticenvs \times \dynamicenvs$.

Formally, the partial function
\[
  \dynamicdomain : \overname{\envs}{\env} \times \overname{\ty}{\vt}
  \partialto \overname{\pow{\vals}}{\vd}
\]
assigns the set of values that a type $\vt$ can hold in a given environment $\env$.
%
We say that $\dynamicdomain(\env, \vt)$ is the \emph{dynamic domain} of $\vt$
in the environment $\env$.
%
The \emph{static domain} of a type is the set of values which storage elements of that type may hold
\underline{across all possible dynamic environments}.
%
The reason for this distinction is that the sets of values
of integer types, bitvector types, array types can depend on the dynamic values of variables.

Types that do not refer to variables whose values are only known dynamically have
a static domain that is equal to any of their dynamic domains.
In those cases, we simply refer to their \emph{domain}.

Associating a set of values to a type is done by evaluating any expression appearing
in the type definitions. Evaluation is defined by the ASL semantics~\cite{ASLSemanticsReference}
via the relation
\hypertarget{def-evalexprsef}{}
\[
  \evalexprsef{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
  \Normal(\overname{\vals}{\vv}\aslsep\overname{\XGraphs}{\vg}) \cup
  \overname{\TError}{\ErrorConfig}
\]
\hypertarget{def-errorconfig}{}
which evaluates side-effect-free expressions and either returns
a configuration of the form $\Normal(\vv,\vg)$ or a dynamic error configuration $\ErrorConfig$.
In the first case, $\vv$ is a native value and $\vg$
is an \emph{execution graph}. Execution graphs are related to the concurrent semantics
and can be ignored in the context of defining dynamic domains.
In the latter case (which can occur if, for example, an expression attempts to divide
\texttt{8} by \texttt{0}), a dynamic error configuration, for which we use the notation
$\ErrorConfig$, is returned.
%
The dynamic domain is empty in cases where evaluating side-effect-free expressions
results in a dynamic error.
%
The dynamic domain is undefined if the type $\vt$ is not well-typed in $\tenv$.
That is, if $\annotatetype{\tenv, \vt} \typearrow \TypeErrorConfig$.

As part of the definition, we also associate dynamic domains to integer constraints
by overloading $\dynamicdomain$:
\[
  \dynamicdomain : \overname{\envs}{\env} \times \overname{\intconstraint}{\vc}
  \partialto \overname{\pow{\vals}}{\vd}
\]

\subsection{Prose}
For an environment $\env \in \envs$ and a type $\vt$, the domain is $\vd$ and one of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{t\_bool}):
  \begin{itemize}
    \item $\vt$ is the Boolean type, $\TBool$;
    \item $\vd$ is the set of native Boolean values, $\tbool$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_string}):
  \begin{itemize}
    \item $\vt$ is the string type, $\TString$;
    \item $\vd$ is the set of all native string values, $\tstring$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_real}):
  \begin{itemize}
    \item $\vt$ is the real type, $\TReal$;
    \item $\vd$ is the set of all native real values, $\treal$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_enumeration}):
  \begin{itemize}
    \item $\vt$ is the enumeration type with labels $\id_{1..k}$, that is $\TEnum(\id_{1..k})$;
    \item $\vd$ is the set of all native integer values for $1..k$.\\
    \textbf{Why represent enumeration domains via integers:}
    Conceptually, enumeration labels carry two pieces of information --- the identifiers themselves
    and their position in the list of identifiers, which are used for accessing arrays.
    For the purpose of type-checking, we use the identifiers, but for the purpose of the semantics
    and the domain of values, only the positions are relevant.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_unconstrained}):
  \begin{itemize}
    \item $\vt$ is the unconstrained integer type, $\TInt(\unconstrained)$;
    \item $\vd$ is the set of all native integer values, $\tint$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_well\_constrained}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type $\TInt(\wellconstrained(\vc_{1..k}))$;
    \item $\vd$ is the union of the dynamic domains of each of the constraints $vc_{1..k}$ in $\env$.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_exact\_okay}):
  \begin{itemize}
    \item $\vc$ is a constraint consisting of a single side-effect-free expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $n$;
    \item $\vd$ is the set containing the single native integer value for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_exact\_dynamic\_error}):
  \begin{itemize}
    \item $\vc$ is a constraint consisting of a single side-effect-free expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item evaluating $\ve$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_range\_okay}):
  \begin{itemize}
    \item $\vc$ is a range constraint consisting of a two side-effect-free expressions $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item evaluating $\veone$ in $\env$, results in a configuration with the native integer for $a$;
    \item evaluating $\vetwo$ in $\env$, results in a configuration with the native integer for $b$;
    \item $a$ is less than or equal to $b$;
    \item $\vd$ is the set containing all native integer values for integers from $a$ to $b$, inclusive.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_range\_dynamic\_error1}):
  \begin{itemize}
    \item $\vc$ is a range constraint consisting of a two side-effect-free expressions $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item evaluating $\veone$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_range\_dynamic\_error2}):
  \begin{itemize}
    \item $\vc$ is a range constraint consisting of a two side-effect-free expressions $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item evaluating $\veone$ in $\env$, results in a configuration with the native integer for $a$;
    \item evaluating $\vetwo$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_underconstrained}):
  \begin{itemize}
    \item $\vt$ is an under constrained integer for parameter $\id$, \\ $\TInt(\underconstrained(\id))$;
    \item the native value associated with $\id$ in the local dynamic environment is the native integer value for $n$;
    \item $\vd$ is the set containing the single integer value for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_dynamic\_error}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_negative\_width\_error}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $k$ is negative;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_empty}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $0$;
    \item $\vd$ is the set containing the single native value for an empty bitvector.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_non\_empty}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $k$ is greater than $0$;
    \item $\vd$ is the set containing all native values for bitvectors of size exactly $k$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
    \item $\vt$ is a tuple type over types $\vt_i$, for $i=1..k$, $\TTuple(\vt_{1..k})$;
    \item the domain of each element $\vt_i$ is $D_i$, for $i=1..k$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $\vd$ is the set containing all native vectors of $k$ values, where the value at position $i$
    is from $D_i$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array\_dynamic\_error}):
  \begin{itemize}
    \item $\vt$ is an array type with length expression $\ve$ and element type $\vt_i$, for $i=1..k$, $\TArray(\ve, \vtone)$;
    \item evaluating $\ve$ in $\env$, results in a dynamic error configuration;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array\_negative\_length\_error}):
  \begin{itemize}
    \item $\vt$ is an array type with length expression $\ve$ and element type $\vt_i$, for $i=1..k$, $\TArray(\ve, \vtone)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $k$ is negative;
    \item $\vd$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array\_okay}):
  \begin{itemize}
    \item $\vt$ is an array type with length expression $\ve$ and element type $\vt_i$, for $i=1..k$, $\TArray(\ve, \vtone)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $k$ is greater than or equal to $0$;
    \item the domain of $\vtone$ is $D_\vtone$;
    \item $\vd$ is the set containing all native vectors of $k$ values taken from $D_\vtone$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_structured}):
  \begin{itemize}
    \item $\vt$ is either a record type or an exception type with typed fields $(\id_i, \vt_i$, for $i=1..k$, that is $L([i=1..k: (\id_i,\vt_i))]$
    where $L\in\{\TRecord, \TException\}$;
    \item the domain of each type $\vt_i$ is $D_i$, for $i=1..k$;
    \item $\vd$ is the set containing all native records where $\id_i$ is mapped to a value taken from $D_i$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_named}):
  \begin{itemize}
    \item $\vt$ is a named type with name $\id$, $\TNamed(\id)$;
    \item the type associated with $\id$ in $\tenv$ is $\tty$;
    \item $\vd$ is the domain of $\tty$ in $\env$.
  \end{itemize}
\end{itemize}

\subsection{Formally}

\begin{mathpar}
\inferrule[t\_bool]{}{ \dynamicdomain(\env, \TBool) = \tbool }
\and
\inferrule[t\_string]{}{ \dynamicdomain(\env, \TString) = \tstring }
\and
\inferrule[t\_real]{}{ \dynamicdomain(\env, \TReal) = \treal }
\and
\inferrule[t\_enumeration]{}{
  \dynamicdomain(\env, \TEnum(\id_{1..k})) = \{\nvint(1),\ldots,\nvint(k)\}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[t\_int\_unconstrained]{}{
  \dynamicdomain(\env, \TInt(\unconstrained)) = \tint
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_int\_well\_constrained]{}{
  \dynamicdomain(\env, \TInt(\wellconstrained(\vc_{1..k}))) = \bigcup_{i=1}^k \dynamicdomain(\env, \vc_i)
}
\end{mathpar}

\begin{mathpar}
\inferrule[constraint\_exact\_okay]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(n), \Ignore)
}{
  \dynamicdomain(\env, \ConstraintExact(\ve)) = \{ \nvint(n) \}
}
\and
\inferrule[constraint\_exact\_dynamic\_error]{
  \evalexprsef{\env, \ve} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \ConstraintExact(\ve)) = \emptyset
}
\end{mathpar}

\begin{mathpar}
\inferrule[constraint\_range\_okay]{
  \evalexprsef{\env, \veone} \evalarrow \Normal(\nvint(a), \Ignore)\\
  \evalexprsef{\env, \vetwo} \evalarrow \Normal(\nvint(b), \Ignore)
}{
  \dynamicdomain(\env, \ConstraintRange(\veone, \vetwo)) = \{ \nvint(n) \;|\;  a \leq n \land n \leq b\}
}
\and
\inferrule[constraint\_range\_dynamic\_error1]{
  \evalexprsef{\env, \veone} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \ConstraintRange(\veone, \vetwo)) = \emptyset
}
\and
\inferrule[constraint\_range\_dynamic\_error2]{
  \evalexprsef{\env, \veone} \evalarrow \Normal(\Ignore, \Ignore)\\
  \evalexprsef{\env, \vetwo} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \ConstraintRange(\veone, \vetwo)) = \emptyset
}
\end{mathpar}

The notation $L^\denv(\id)$ denotes the native value associated with the identifier $\id$
in the \emph{local dynamic environment} of $\denv$.
\begin{mathpar}
  \inferrule[t\_int\_underconstrained]{
  L^\denv(\id) = \nvint(n)
}{
  \dynamicdomain(\env, \TInt(\underconstrained(\id))) = \{ \nvint(n) \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits\_dynamic\_error]{
  \evalexprsef{\env, \ve} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \TBits(\ve, \Ignore)) = \emptyset
}
\and
\inferrule[t\_bits\_negative\_width\_error]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
  k < 0
}{
  \dynamicdomain(\env, \TBits(\ve, \Ignore)) = \emptyset
}
\and
\inferrule[t\_bits\_empty]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(0), \Ignore)
}{
  \dynamicdomain(\env, \TBits(\ve, \Ignore)) = \{ \nvbitvector(\emptylist) \}
}
\and
\inferrule[t\_bits\_non\_empty]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
  k > 0
}{
  \dynamicdomain(\env, \TBits(\ve, \Ignore)) = \{ \nvbitvector(\vb_{1..k}) \;|\; \vb_1,\ldots,\vb_k \in \{0,1\} \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  i=1..k: \dynamicdomain(\env, \vt_i) = D_i
}{
  \dynamicdomain(\env, \TTuple(\vt_{1..k})) =
  \{ \nvvector{\vv_{1..k}} \;|\; \vv_i \in D_i \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_dynamic\_error]{
  \evalexprsef{\env, \ve} \evalarrow \ErrorConfig
}{
  \dynamicdomain(\env, \TArray(\ve, \vtone)) = \emptyset
}
\and
\inferrule[t\_array\_negative\_length\_error]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
  k < 0
}{
  \dynamicdomain(\env, \TArray(\ve, \vtone)) = \emptyset
}
\and
\inferrule[t\_array\_okay]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
  \dynamicdomain(\env, \vtone) = D_\vtone
}{
  \dynamicdomain(\env, \TArray(\ve, \vtone)) =
  \{ \nvvector{\vv_{1..k}} \;|\; \vv_{1..k} \in D_{\vtone} \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\
  i=1..k: \dynamicdomain(\env, \vt_i) = D_i
}{
  \dynamicdomain(\env, L([i=1..k: (\id_i,\vt_i))]) = \\
  \{ \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}} \;|\; \vv_i \in D_i \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_named]{
  G^\tenv.\declaredtypes(\id)=\tty
}{
  \dynamicdomain(\env, \TNamed(\id)) = \dynamicdomain(\env, \tty)
}
\end{mathpar}

\subsection{Example}
The domain of \texttt{integer} is the infinite set of all integers.

The domain of \verb|integer {2,16}| is the set $\{\nvint(2), \nvint(16)\}$.

The domain of \verb|integer{1..3}| is the set $\{\nvint(1), \nvint(2), \nvint(3)\}$.

The domain of \verb|integer{10..1}| is the empty set as there are no integers that are
both greater than $10$ and smaller than $1$.

The domain of \texttt{bits(1)} is the set $\{\nvint(1), \nvint(2)\}$.

The domain of \verb|enumeration {GREEN, ORANGE, RED}| is the set \\
$\{\nvint(1), \nvint(2), \nvint(3)\}$ and so is the domain
of \\
\verb|type TrafficLights of enumeration {GREEN, ORANGE, RED}|.

The domain of \texttt{bits({2,16})} is the set containing native bitvectors of all 2-bit and all 16-bit binary sequences.

The domain of \texttt{(integer, integer)} is the set containing all pairs of native integer values.

The domain of \verb|record {a: integer;  b: boolean}| contains all native records
that map \texttt{a} to a native integer value and \texttt{b} to a native Boolean value.

The dynamic domain of a subprogram parameter \texttt{N: integer} is the (singleton) set containing
the native integer value $c$,
which is assigned to \texttt{N} by a given dynamic environment. The static domain of that parameter
is the infinite set of all native integer values.

\lrmcomment{
This is related to \identd{BMGM}, \identr{PHRL}, \identr{PZNR},
\identr{RLQP}, \identr{LYDS}, \identr{SVDJ}, \identi{WLPJ}, \identr{FWMM},
\identi{WPWL}, \identi{CDVY}, \identi{KFCR}, \identi{BBQR}, \identr{ZWGH},
\identr{DKGQ}, \identr{DHZT}, \identi{HSWR}, \identd{YZBQ}.
}

\section{Subsumption Testing}
Whether an assignment statement is well-typed depends on whether the dynamic domain of the
right hand side type is contained in the dynamic domain of the left hand side type,
for any given dynamic environment
(see \secref{TypingRule.DomainSubtypeSatisfaction} where this is checked).

\begin{definition}[Subsumption]
For any given types $\vt$ and $\vs$ and static environment $\tenv$,
we say that $\vt$ \emph{subsumes} $\vs$ in $\tenv$,
if the following condition holds:
\hypertarget{def-subsumes}{}
\begin{equation}
  \subsumes(\tenv, \vt, \vs) \triangleq \forall \denv\in\dynamicenvs.\ \dynamicdomain((\tenv, \denv), \vt) \supseteq \dynamicdomain((\tenv, \denv), \vs) \enspace.
\end{equation}
\end{definition}

For example, consider the assignment
\begin{center}
\verb|var x : integer{1,2,3} = UNKNOWN : integer{1,2};|
\end{center}

It is legal, since (in any static environment), the domain of \verb|integer{1,2,3}|
is \\
$\{\nvint(1), \nvint(2), \nvint(3)\}$, which subsumes
the domain of \verb|integer{1,2}|, which is \\ $\{\nvint(1), \nvint(2)\}$.

Since dynamic domains are potentially infinite, this requires \emph{symbolic reasoning}.
Furthermore, since any (statically evaluable) expressions may appear inside integer and bitvector
types, testing subsumption is undecidable.
We therefore approximate subsumption testing \emph{conservatively} via the predicate $\symsubsumes(\tenv, \vt, \vs)$.

\begin{definition}[Sound Subsumption Test]
A predicate
\[
  \symsubsumes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs}) \aslto \Bool
\]
is \emph{sound} if the following condition holds:
\begin{equation}
  \begin{array}{l}
  \forall \vt,\vs\in\ty.\ \tenv\in\staticenvs. \\
  \;\;\;\; \symsubsumes(\tenv, \vt, \vs) \typearrow \True \;\Longrightarrow\; \subsumes(\tenv, \vt, \vs)  \enspace.
  \end{array}
\end{equation}
\end{definition}

That is, if a sound subsumption test returns a positive answer, it means that
$\vt$ definitely \emph{subsumes} $\vs$ in the static environment $\tenv$.
This is referred to as a \emph{true positive}.
However, a negative answer means one of two things:
\begin{description}
  \item[True Negative:] indeed, $\vt$ does not subsume $\vs$ in the static environment $\tenv$; or
  \item[False Negative:] the symbolic reasoning is unable to decide.
\end{description}

In other words, $\symsubsumes(\tenv, \vt, \vs)$ errs on the \emph{safe side} ---
it never answers $\True$ when the real answer is $\False$, which would (undesirably)
determine the following statement as well-typed:
\begin{center}
  \verb|var x : integer{1,2} = UNKNOWN: integer;|
\end{center}

A sound but trivial subsumption test is one that always returns $\False$.
However, that would make all assignments be considered as not well-typed.
Indeed, it has the maximal set of false negatives.
Reducing the set of false negatives requires stronger symbolic reasoning algorithms,
which inevitably leads to higher computational complexity.
%
The symbolic subsumption test in \chapref{symbolicsubsumptiontesting}
attempts to accept a large enough set of true positives, based on empirical trial and error,
while maintaining the computational complexity of the symbolic reasoning relatively low.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basic Type Attributes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter defines some basic predicates for classifying types as well as
functions that inspect the structure of types:
\begin{itemize}
  \item Builtin singular types (\secref{TypingRule.BuiltinSingularType})
  \item Builtin aggregate types (\secref{TypingRule.BuiltinAggregateType})
  \item Builtin types (\secref{TypingRule.BuiltinSingularOrAggregate})
  \item Named types (\secref{TypingRule.NamedType})
  \item Anonymous types (\secref{TypingRule.AnonymousType})
  \item Singular types (\secref{TypingRule.SingularType})
  \item Aggregate types (\secref{TypingRule.AggregateType})
  \item Non-primitive types (\secref{TypingRule.NonPrimitiveType})
  \item Primitive types (\secref{TypingRule.PrimitiveType})
  \item The structure of a type (\secref{structure})
  \item The underlying type of a type (\secref{anonymize})
  \item Checked constrained integers (\secref{TypingRule.CheckConstrainedInteger})
\end{itemize}

\section{TypingRule.BuiltinSingularType \label{sec:TypingRule.BuiltinSingularType}}
\hypertarget{def-isbuiltinsingular}{}
The predicate
\[
  \isbuiltinsingular(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{builtin singular type}.

\subsection{Prose}
The \emph{builtin singular types} are:
\begin{itemize}
\item \texttt{integer};
\item \texttt{real};
\item \texttt{string};
\item \texttt{boolean};
\item \texttt{bits} (which also represents \texttt{bit}, as a special case);
\item \texttt{enumeration}.
\end{itemize}

\subsection{Example}

In this example:
\VerbatimInput[firstline=3,lastline=8]{\tests/TypingRule.BuiltinSingularTypes.asl}

Variables of builtin singular types \texttt{integer}, \texttt{real},
\texttt{boolean}, \texttt{bits(4)}, \\ and~\texttt{bits(2)} are defined.

\subsection{Example}
\VerbatimInput{\tests/TypingRule.EnumerationType.asl}
The builtin singular type \texttt{Color} consists in two constants
\texttt{RED}, and~\texttt{BLACK}.

\CodeSubsection{\BuiltinSingularBegin}{\BuiltinSingularEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef \astlabel(\tty) \in \{\TReal, \TString, \TBool, \TBits, \TEnum, \TInt\}
}{
  \isbuiltinsingular(\tty) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{PQCK} and \identd{NZWT}.}

\section{TypingRule.BuiltinAggregateType \label{sec:TypingRule.BuiltinAggregateType}}
\hypertarget{def-isbuiltinaggregate}{}
The predicate
\[
  \isbuiltinaggregate(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{builtin aggregate type}.

\subsection{Prose}
The builtin aggregate types are:
\begin{itemize}
\item tuple;
\item \texttt{array};
\item \texttt{record};
\item \texttt{exception}.
\end{itemize}

\subsection{Example}
\VerbatimInput{\tests/TypingRule.BuiltinAggregateTypes.asl}
Type \texttt{Pair} is the type of integer and boolean pairs.

Arrays are declared with indices that are either integer-typed
or enumeration-typed.  In the example above, \texttt{T} is
declared as an array with an integer-typed index (as indicated
by the used of the integer-typed constant \texttt{3}) whereas
\texttt{PointArray} is declared with the index of
\texttt{Coord}, which is an enumeration type.

Arrays declared with integer-typed indices can be accessed only by integers ranging from $0$ to
the size of the array minus $1$. In the example above, $\texttt{T}$ can be accessed with
one of $0$, $1$, and $2$.

Arrays declared with an enumeration-typed index can only be accessed with labels from the corresponding
enumeration. In the example above, \texttt{PointArray} can only be accessed with one of the labels
\texttt{CX}, \texttt{CY}, and \texttt{CZ}.

The (builtin aggregate) type \verb|{ x : real, y : real, z : real }| is a record type with three fields
\texttt{x}, \texttt{y} and \texttt{z}.

\subsection{Example}
\VerbatimInput{\tests/TypingRule.BuiltinExceptionType.asl}
Two (builtin aggregate) exception types are defined:
\begin{itemize}
\item \verb|exception{}| (for \texttt{Not\_found}), which carries no value; and
\item \verb|exception { message:string }| (for \texttt{SyntaxException}), which carries a message.
\end{itemize}
Notice the similarity with record types and that the empty field list \verb|{}| can be
omitted in type declarations, as is the case for \texttt{Not\_found}.

\CodeSubsection{\BuiltinAggregateBegin}{\BuiltinAggregateEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{ \vb \eqdef \astlabel(\tty) \in \{\TTuple, \TArray, \TRecord, \TException\} }
{ \isbuiltinaggregate(\tty) \typearrow \vb }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{PQCK} and \identd{KNBD}.}

\section{TypingRule.BuiltinSingularOrAggregate \label{sec:TypingRule.BuiltinSingularOrAggregate}}
\hypertarget{def-isbuiltin}{}
The predicate
\[
  \isbuiltin(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{builtin type}.

\subsection{Prose}
$\tty$ is a builtin type and one of the following applies:
\begin{itemize}
\item $\tty$ is singular;
\item $\tty$ is builtin aggregate.
\end{itemize}

\subsection{Example}
In the specification
\begin{verbatim}
  type ticks of integer;
\end{verbatim}
the type \texttt{integer} is a builtin type but the type of \texttt{ticks} is not.

\CodeSubsection{\BuiltinSingularOrAggregateBegin}{\BuiltinSingularOrAggregateEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \isbuiltinsingular(\tty) \typearrow \vbone\\
    \isbuiltinaggregate(\tty) \typearrow \vbtwo
  }{
    \isbuiltin(\tty) \typearrow \vbone \lor \vbtwo
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.NamedType \label{sec:TypingRule.NamedType} }
\hypertarget{def-isnamed}{}
The predicate
\[
  \isnamed(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{named type}.

\subsection{Prose}
A named type is a type that is declared by using the \texttt{type of} syntax.

\subsection{Example}
In the specification
\begin{verbatim}
  type ticks of integer;
\end{verbatim}
\texttt{ticks} is a named type.

\CodeSubsection{\NamedBegin}{\NamedEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef \astlabel(\tty) = \TNamed
}{
  \isnamed(\tty) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{vmzx}.}

\section{TypingRule.AnonymousType \label{sec:TypingRule.AnonymousType}}
\hypertarget{def-isanonymous}{}
The predicate
\[
  \isanonymous(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is an \emph{anonymous type}.

\subsection{Prose}
An anonymous type is a type that is not declared using the type syntax.

\subsection{Example}
The tuple type \texttt{(integer, integer)} is an anonymous type.

\CodeSubsection{\AnonymousBegin}{\AnonymousEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{ \vb \eqdef \astlabel(\tty) \neq \TNamed }
{ \isanonymous(\tty) \typearrow \vb }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{VMZX}.}

\section{TypingRule.SingularType \label{sec:TypingRule.SingularType}}
\hypertarget{def-issingular}{}
The predicate
\[
  \issingular(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \;\aslto\;
  \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the type $\tty$ is a \emph{singular type} in the static environment $\tenv$.

\subsection{Prose}
A type $\tty$ is singular if and only if all of the following apply:
\begin{itemize}
  \item obtaining the \underlyingtype\ of $\tty$ in the environment $\tenv$ yields $\vtone$\ProseOrTypeError;
  \item $\vtone$ is a builtin singular type.
\end{itemize}

\subsection{Example}
In the following example, the types \texttt{A}, \texttt{B}, and \texttt{C} are all singular types:
\begin{verbatim}
type A of integer;
type B of A;
type C of B;
\end{verbatim}

\CodeSubsection{\SingularBegin}{\SingularEnd}{../types.ml}
\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \makeanonymous(\tenv, \vt) \typearrow \vtone \OrTypeError\\\\
  \isbuiltinsingular(\vtone) \typearrow \vb
}{
\issingular(\tenv, \tty) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{GVZK}.}

\section{TypingRule.AggregateType \label{sec:TypingRule.AggregateType}}
\hypertarget{def-isbuiltinaggregate}{}
The predicate
\[
  \isaggregate(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \;\aslto\;
  \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the type $\tty$ is an \emph{aggregate type} in the static environment $\tenv$.

\subsection{Prose}
A type $\tty$ is aggregate in an environment $\tenv$ if and only if all of the following apply:
\begin{itemize}
  \item obtaining the \underlyingtype\ of $\tty$ in the environment $\tenv$ yields $\vtone$\ProseOrTypeError;
  \item $\vtone$ is a builtin aggregate.
\end{itemize}

\subsection{Example}
In the following example, the types \texttt{A}, \texttt{B}, and \texttt{C} are all aggregate types:
\begin{verbatim}
type A of (integer, integer);
type B of A;
type C of B;
\end{verbatim}

\CodeSubsection{\AggregateBegin}{\AggregateEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \makeanonymous(\tenv, \tty) \typearrow \vtone \OrTypeError\\\\
  \isbuiltinaggregate(\vtone) \typearrow \vb
}{
  \isaggregate(\tenv, \tty) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{GVZK}.}

\section{TypingRule.NonPrimitiveType \label{sec:TypingRule.NonPrimitiveType}}
\hypertarget{def-isnonprimitive}{}
The predicate
\[
  \isnonprimitive(\overname{\ty}{\tty}) \;\aslto\; \overname{\Bool}{\vb}
\]
tests whether the type $\tty$ is a \emph{non-primitive type}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{singular}):
  \begin{itemize}
  \item $\tty$ is a builtin singular type;
  \item $\vb$ is $\False$.
  \end{itemize}
  \item All of the following apply (\textsc{named}):
  \begin{itemize}
    \item $\tty$ is a named type;
    \item $\vb$ is $\True$.
  \end{itemize}
  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\tty$ is a tuple type $\vli$;
    \item $\vb$ is $\True$ if and only if there exists a non-primitive type in $\vli$.
  \end{itemize}
  \item All of the following apply (\textsc{array}):
    \begin{itemize}
    \item $\tty$ is an array of type $\tty'$
    \item $\vb$ is $\True$ if and only if $\tty'$ is non-primitive.
    \end{itemize}
  \item All of the following apply (\textsc{structured}):
    \begin{itemize}
    \item $\tty$ is a record or exception with fields $\fields$;
    \item $\vb$ is $\True$ if and only if there exists a non-primitive type in $\fields$.
    \end{itemize}
\end{itemize}

\subsection{Example}
The following types are non-primitive:

\begin{tabular}{ll}
\textbf{Type definition} & \textbf{Reason for being non-primitive}\\
\hline
\texttt{type A of integer}  & Named types are non-primitive\\
\texttt{(integer, A)}       & The second component, \texttt{A}, has non-primitive type\\
\texttt{array[6] of A}      & Element type \texttt{A} has a non-primitive type\\
\verb|record { a : A }|     & The field \texttt{a} has a non-primitive type
\end{tabular}

\CodeSubsection{\NonPrimitiveBegin}{\NonPrimitiveEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
The cases \textsc{tuple} and \textsc{structured} below, use the notation $\vb_\vt$ to name
Boolean variables by using the types denoted by $\vt$ as a subscript.
\begin{mathpar}
  \inferrule[singular]{
    \astlabel(\tty) \in \{\TReal, \TString, \TBool, \TBits, \TEnum, \TInt\}
  }
  {
    \isnonprimitive(\tty) \typearrow \False
  }
  \and
  \inferrule[named]{\astlabel(\tty) = \TNamed}{\isnonprimitive(\tty) \typearrow \True}
  \and
  \inferrule[tuple]{
    \vt \in \vli: \isnonprimitive(\vt) \typearrow \vb_{\vt}\\
    \vb \eqdef \bigvee_{\vt \in \vli} \vb_{\vt}
  }{
    \isnonprimitive(\TTuple(\vli)) \typearrow \vb
  }
  \and
  \inferrule[array]{
    \isnonprimitive(\tty') \typearrow \vb
  }{
    \isnonprimitive(\TArray(\Ignore, \tty')) \typearrow \vb
  }
  \and
  \inferrule[structured]{
    L \in \{\TRecord, \TException\}\\
    (\Ignore,\vt) \in \fields : \isnonprimitive(\vt) \typearrow \vb_\vt\\
    \vb \eqdef \bigvee_{\vt \in \vli} \vb_{\vt}
  }{
    \isnonprimitive(L(\fields)) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{GWXK}.}

\section{TypingRule.PrimitiveType \label{sec:TypingRule.PrimitiveType}}
\hypertarget{def-isprimitive}{}
The predicate
\[
  \isprimitive(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{primitive type}.

\subsection{Prose}
A type $\tty$ is primitive if it is not non-primitive.

\subsection{Example}
The following types are primitive:

\begin{tabular}{ll}
\textbf{Type definition} & \textbf{Reason for being primitive}\\
\hline
\texttt{integer} & Integers are primitive\\
\texttt{(integer, integer)} & All tuple elements are primitive\\
\texttt{array[5] of integer} & The array element type is primitive\\
\verb|record {ticks : integer}| & The single field \texttt{ticks} has a primitive type
\end{tabular}

\CodeSubsection{\PrimitiveBegin}{\PrimitiveEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \isnonprimitive(\tty) \typearrow \vb
}{
  \isprimitive(\tty) \typearrow \neg\vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{GWXK}.}

\section{TypingRule.Structure \label{sec:structure}}
\hypertarget{def-structure}{}
The function
\[
  \tstruct(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \aslto \overname{\ty}{\vt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
assigns a type to its \hypertarget{def-tstruct}{\emph{\structure}}, which is the type formed by
recursively replacing named types by their type definition in the static environment $\tenv$.
If a named type is not associated with a declared type in $\tenv$, a type error is returned.

TypingRule.Specification ensures the absence of circular type definitions,
which ensures that TypingRule.Structure terminates\footnote{In mathematical terms,
this ensures that TypingRule.Structure is a proper \emph{structural induction.}}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
\item All of the following apply (\textsc{named}):
  \begin{itemize}
  \item $\tty$ is a named type $\vx$;
  \item obtaining the declared type associated with $\vx$ in the static environment $\tenv$ yields $\vtone$\ProseOrTypeError;
  \item obtaining the structure of $\vtone$ static environment $\tenv$ yields $\vt$\ProseOrTypeError;
  \end{itemize}
\item All of the following apply (\textsc{builtin\_singular}):
  \begin{itemize}
  \item $\tty$ is a builtin singular type;
  \item $\vt$ is $\tty$.
  \end{itemize}
\item All of the following apply (\textsc{tuple}):
  \begin{itemize}
  \item $\tty$ is a tuple type with list of types $\tys$;
  \item the types in $\tys$ are indexed as $\vt_i$, for $i=1..k$;
  \item obtaining the structure of each type $\vt_i$, for $i=1..k$, in $\tys$ in the static environment $\tenv$,
  yields $\vtp_i$\ProseOrTypeError;
  \item $\vt$ is a tuple type with the list of types $\vtp_i$, for $i=1..k$.
  \end{itemize}
\item All of the following apply (\textsc{array}):
  \begin{itemize}
    \item $\tty$ is an array type of length $\ve$ with element type $\vt$;
    \item obtaining the structure of $\vt$ yields $\vtone$\ProseOrTypeError;
    \item $\vt$ is is an array type with of length $\ve$ with element type $\vtone$.
  \end{itemize}
\item All of the following apply (\textsc{structured}):
  \begin{itemize}
  \item $\tty$ is either a record or an exception with fields $\fields$;
  \item obtaining the structure for each type $\vt$ associated with field $\id$ yields a type $\vt_\id$\ProseOrTypeError;
  \item $\vt$ is a record or an exception, in correspondence to $\tty$, with the list of pairs $(\id, \vt\_\id)$;
  \end{itemize}
\end{itemize}

\subsection{Example}
In this example:
\texttt{type T1 of integer;} is the named type \texttt{T1}
whose structure is \texttt{integer}.

In this example:
\texttt{type T2 of (integer, T1);}
is the named type \texttt{T2} whose structure is (integer, integer). In this
example, \texttt{(integer, T1)} is non-primitive since it uses \texttt{T1}, which is builtin aggregate.

In this example:
\texttt{var x: T1;}
the type of $\vx$ is the named (hence non-primitive) type \texttt{T1}, whose structure
is \texttt{integer}.

In this example:
\texttt{var y: integer;}
the type of \texttt{y} is the anonymous primitive type \texttt{integer}.

In this example:
\texttt{var z: (integer, T1);}
the type of \texttt{z} is the anonymous non-primitive type
\texttt{(integer, T1)} whose structure is \texttt{(integer, integer)}.

\CodeSubsection{\StructureBegin}{\StructureEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[named]{
  \declaredtype(\tenv, \vx) \typearrow \vtone \OrTypeError\\\\
  \tstruct(\tenv, \vtone)\typearrow\vt \OrTypeError
}{
  \tstruct(\tenv, \TNamed(\vx)) \typearrow \vt
}
\and
\inferrule[builtin\_singular]{
  \isbuiltinsingular(\tty) \typearrow \True
}{
  \tstruct(\tenv, \tty) \typearrow \tty
}
\and
\inferrule[tuple]{
  \tys \eqname \vt_{1..k}\\
  i=1..k: \tstruct(\tenv, \vt_i) \typearrow \vtp_i \OrTypeError
}{
  \tstruct(\tenv, \TTuple(\tys)) \typearrow  \TTuple(i=1..k: \vtp_i)
}
\and
\inferrule[array]{
  \tstruct(\tenv, \vt) \typearrow \vtone \OrTypeError
}{
  \tstruct(\tenv, \TArray(\ve, \vt)) \typearrow \TArray(\ve, \vtone)
}
\and
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\\\
  (\id,\vt) \in \fields : \tstruct(\tenv, \vt) \typearrow \vt_\id \OrTypeError
}{
  \tstruct(\tenv, L(\fields)) \typearrow
 L([ (\id,\vt) \in \fields : (\id,\vt_\id) ])
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{FXQV}.}

\section{TypingRule.Anonymize \label{sec:anonymize}}
\hypertarget{def-makeanonymous}{}
\hypertarget{def-underlyingtype}{}
The function
\[
  \makeanonymous(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \aslto \overname{\ty}{\vt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the \emph{\underlyingtype} --- $\vt$ --- of the type $\tty$ in the static environment $\tenv$ or a type error.
Intuitively, $\tty$ is the first non-named type that is used to define $\tty$. Unlike $\tstruct$,
$\makeanonymous$ replaces named types by their definition until the first non-named type is found but
does not recurse further.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{named}):
  \begin{itemize}
    \item $\tty$ is a named type $\vx$;
    \item obtaining the type declared for $\vx$ yields $\vtone$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vtone$ is $\vt$.
  \end{itemize}

  \item All of the following apply (\textsc{non-named}):
  \begin{itemize}
    \item $\tty$ is not a named type $\vx$;
    \item $\vt$ is $\tty$.
  \end{itemize}
\end{itemize}

\subsection{Example}
Consider the following example:
\begin{verbatim}
type T1 of integer;
type T2 of T1;
type T3 of (integer, T2);
\end{verbatim}

The underlying types of \texttt{integer}, \texttt{T1}, and \texttt{T2} is \texttt{integer}.

The underlying type of \texttt{(integer, T2)} and \texttt{T3} is
\texttt{(integer, T2)}.  Notice how the underlying type does not replace
\texttt{T2} with its own underlying type, in contrast to the structure of
\texttt{T2}, which is \texttt{(integer, integer)}.

\CodeSubsection{\AnonymizeBegin}{\AnonymizeEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[named]{
  \tty \eqname \TNamed(\vx) \\
  \declaredtype(\tenv, \vx) \typearrow \vtone \OrTypeError \\\\
  \makeanonymous(\tenv, \vtone) \typearrow \vt
}{
  \makeanonymous(\tenv, \tty) \typearrow \vt
}
\and
\inferrule[non-named]{
  \astlabel(\tty) \neq \TNamed
}{
  \makeanonymous(\tenv, \tty) \typearrow \tty
}
\end{mathpar}
\end{emptyformal}
\subsection{Comments}

\section{TypingRule.CheckConstrainedInteger \label{sec:TypingRule.CheckConstrainedInteger}}
\hypertarget{def-checkconstrainedinteger}{}
The function
\[
  \checkconstrainedinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \aslto \True \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the type $\vt$ is a \constrainedinteger. If so, the result is $\True$, otherwise a type error is returned.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{well-constrained}):
  \begin{itemize}
    \item $\vt$ is a well-constrained integer;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{underconstrained}):
  \begin{itemize}
    \item $\vt$ is an underconstrained integer;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{unconstrained}):
  \begin{itemize}
    \item $\vt$ is an unconstrained integer;
    \item the result is a type error indicating that a constrained integer type is expected.
  \end{itemize}

  \item All of the following apply (\textsc{conflicting\_type}):
  \begin{itemize}
    \item $\vt$ is not an integer type;
    \item the result is a type error indicating the type conflict.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\CheckConstrainedIntegerBegin}{\CheckConstrainedIntegerEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[well-constrained]{}
{
  \checkconstrainedinteger(\tenv, \TInt(\wellconstrained(\Ignore))) \typearrow \True
}
\and
\inferrule[underconstrained]{}
{
  \checkconstrainedinteger(\tenv, \TInt(\underconstrained(\Ignore))) \typearrow \True
}
\and
\inferrule[unconstrained]{}
{
  \checkconstrainedinteger(\tenv, \TInt(\unconstrained(\Ignore))) \typearrow \\
  \TypeErrorVal{ConstrainedIntegerExpected}
}
\and
\inferrule[conflicting\_type]{
  \astlabel(\vt) \neq \TInt
}
{
  \checkconstrainedinteger(\tenv, \vt) \typearrow \TypeErrorVal{TypeConflict}
}
\end{mathpar}
\end{emptyformal}
\subsection{Comments}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Relations Over Types \label{chap:relationsovertypes}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We define the following relations over types and operators:
\begin{itemize}
  \item Subtype (\secref{TypingRule.Subtype})
  \item Structural Subtype Satisfaction (\secref{TypingRule.StructuralSubtypeSatisfaction})
  \item Domain Subtype Satisfaction (\secref{TypingRule.DomainSubtypeSatisfaction})
  \item Subtype Satisfaction (\secref{TypingRule.SubtypeSatisfaction})
  \item Type Satisfaction (\secref{TypingRule.TypeSatisfaction})
  \item Type Clash (\secref{TypingRule.TypeClash})
  \item Lowest Common Ancestor (\secref{TypingRule.LowestCommonAncestor})
  \item Checking adequacy of a unary operator for a type (\secref{TypingRule.CheckUnop})
  \item Checking adequacy of a binary operator for a pair of types (\secref{TypingRule.CheckBinop})
\end{itemize}

We also define the helper rule TypingRule.FindNamedLCA (\secref{TypingRule.FindNamedLCA}).

\section{TypingRule.Subtype\label{sec:TypingRule.Subtype}}
The \emph{subtype} relation is a partial order over \underline{named types}.
The \emph{supertype} is the symmetric relation. That is, \tty\ is a supertype of \tsy\ if and only if \tsy\ is a subtype of \tty.

\hypertarget{def-subtypesrel}{}
The predicate
\[
  \subtypesrel(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\Bool}{\vb}
\]

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item all of the following apply (\textsc{reflexive}):
  \begin{itemize}
    \item $\vtone$ and $\vttwo$ are both the same named type;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item all of the following apply (\textsc{transitive}):
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the global static environment maintains that $\idone$ is a subtype of $\idthree$;
    \item testing whether the type named $\idthree$ is a subtype of $\vttwo$ in the static environment $\tenv$
    gives $\vb$.
  \end{itemize}

  \item all of the following apply (\textsc{no\_supertype}):
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the global static environment maintains that $\idone$ does subtype any named type;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item all of the following apply (\textsc{not\_named}):
  \begin{itemize}
    \item at least one of $\vtone$ and $\vttwo$ is not a named type;
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}
\subsection{Example}
In the following example \texttt{subInt} is a subtype of itself and of \texttt{superInt}:
\begin{verbatim}
type superInt of integer;
type subInt of integer subtypes superInt;
\end{verbatim}

\CodeSubsection{\SubtypeBegin}{\SubtypeEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[reflexive]{}{
    \subtypesrel(\tenv, \TNamed(\id), \TNamed(\id)) \typearrow \True
  }
  \and
  \inferrule[transitive]{
    \idone \neq \idtwo\\
    G^\tenv.\subtypes(\idone) = \idthree\\
    \subtypesrel(\tenv, \TNamed(\idthree), \vttwo) \typearrow \vb
  }{
    \subtypesrel(\tenv, \TNamed(\idone), \TNamed(\idtwo)) \typearrow \vb
  }
  \and
  \inferrule[no\_supertype]{
    \idone \neq \idtwo\\
    G^\tenv.\subtypes(\idone) = \bot
  }{
    \subtypesrel(\tenv, \TNamed(\idone), \TNamed(\idtwo)) \typearrow \False
  }
  \and
  \inferrule[not\_named]{
    (\astlabel(\vtone) \neq \TNamed \lor \astlabel(\vttwo) \neq \TNamed)
  }{
    \subtypesrel(\tenv, \vtone, \vttwo) \typearrow \False
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{NXRX}, \identi{KGKS}, \identi{MTML}, \identi{JVRM}, \identi{CHMP}.}

\section{TypingRule.StructuralSubtypeSatisfaction\label{sec:TypingRule.StructuralSubtypeSatisfaction}}
\hypertarget{def-structsubtypesat}{}
The predicate
\[
  \structsubtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{structurally-subtype-satisfies} a type $\vs$ in environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.
The function assumes that both $\vt$ and $\vs$ are well-typed according to \chapref{typingoftypes}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
\item All of the following apply (\textsc{error1}):
  \begin{itemize}
  \item obtaining the \underlyingtype\ of $\vt$ gives a type error;
  \item the rule results in a type error.
  \end{itemize}

\item All of the following apply (\textsc{error2}):
  \begin{itemize}
    \item obtaining the \underlyingtype\ of $\vt$ gives a type $\vttwo$;
    \item obtaining the \underlyingtype\ of $\vs$ gives a type error;
    \item the rule results in a type error.
    \end{itemize}

\item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
  \item the underlying types of $\vt$ and $\vs$ have different AST labels
  (for example, \texttt{integer} and \texttt{real});
  \item $\vb$ is $\False$.
  \end{itemize}

\item All of the following apply (\textsc{simple}):
  \begin{itemize}
  \item the \underlyingtype\ of $\vt$, $\vttwo$, is either \texttt{integer} (any kind), \texttt{real}, \texttt{string}, or \texttt{bool};
  \item the \underlyingtype\ of $\vs$, $\vstwo$, is either \texttt{integer} (any kind), \texttt{real}, \texttt{string}, or \texttt{bool};
  \item $\vb$ is $\True$ if and only if both $\vttwo$ and $\vstwo$ have the same ASL label.
  \end{itemize}

\item All of the following apply (\textsc{t\_enum}):
  \begin{itemize}
  \item the \underlyingtype\ of $\vt$, $\vttwo$, is an enumeration type;
  \item the \underlyingtype\ of $\vs$ is $\vstwo$;
  \item $\vb$ is $\True$ if and only if $\vttwo$ is equal to $\vstwo$.
  \end{itemize}

\item All of the following apply (\textsc{t\_bits}):
  \begin{itemize}
  \item the \underlyingtype\ of $\vs$ is a bitvector type with width $\ws$ and bit fields $\bfss$, that is $\TBits(\ws, \bfss)$;
  \item the \underlyingtype\ of $\vt$ is a bitvector type with width $\wt$ and bit fields $\bfst$, that is $\TBits(\wt, \bfst)$;
  \item determining whether the bitwidth $\ws$ is equivalent to $\wt$ in $\tenv$ either yields $\True$ or yields $\False$,
        which short-circuits the entire rule;
  \item determining whether the bit fields $\bfss$ are included in the bit fields $\bfst$ in $\tenv$ yields $\vb$\ProseOrTypeError
  \end{itemize}

\item All of the following apply (\textsc{t\_array\_expr}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtype\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are equivalent in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array length expression with $\vlengthexprs$, that is \\ $\ArrayLengthExpr(\vlengthexprs)$;
  \item $\vlengtht$ is an array length expression with $\vlengthexprt$, that is \\ $\ArrayLengthExpr(\vlengthexprt)$;
  \item determining whether expressions $\vlengthexprs$ and $\vlengthexprt$ are equivalent gives $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array\_enum}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtype\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are equivalent in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array with indices taken from the enumeration $\vnames$, that is $\ArrayLengthEnum(\vnames, \Ignore)$;
  \item $\vlengtht$ is an array with indices taken from the enumeration $\vnamet$, that is $\ArrayLengthEnum(\vnamet, \Ignore)$;
  \item $\vb$ is $\True$ if and only if $\vnames$ and $\vnamet$ are the same.
  \end{itemize}

\item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of a tuple with type list $\vlis$, that is $\TTuple(\vlis)$;
  \item $\vt$ has the \underlyingtype\ of a tuple with type list $\vlit$, that is $\TTuple(\vlit)$;
  \item equating the lengths of $\vlis$ and $\vlit$ is either $\True$ or $\False$, which short-circuits
  the entire rule with $\vb=\False$;
  \item checking at each index $\vi$ of the list $\vlis$ whether the type $\vlit[\vi]$ \typesatisfies\ the type $\vlis[\vi]$
  yields $\vb_\vi$\ProseOrTypeError;
  \item $\vb$ is $\True$ if and only if all $\vb_\vi$ are $\True$;
  \end{itemize}

\item All of the following apply (\textsc{structured}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ $L(\vfieldss)$, which is either a record type or an exception type;
  \item $\vt$ has the \underlyingtype\ $L(\vfieldst)$, which is either a record type or an exception type;
  \item since both underlying types have the same AST label they are either both record types or both exception types;
  \item $\vb$ is $\True$ if and only if for each field in $\vfieldss$ with type $\vtys$
  there exists a field in $\vfieldst$ with type $\vtyt$ such that both $\vtys$ and $\vtyt$
  are determined to be \typeequivalent\ in $\tenv$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\StructuralSubtypeSatisfactionBegin}{\StructuralSubtypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[error1]{
    \makeanonymous(\tenv, \vt) \typearrow \TypeErrorConfig
  }
  {
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
  }
  \and
  \inferrule[error2]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \TypeErrorConfig
  }
  {
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
  }
  \and
  \inferrule[different\_labels]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \astlabel(\vttwo) \neq \astlabel(\vstwo)
  }
  {
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \False
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[simple]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \astlabel(\vttwo) \in \{\TInt, \TReal, \TString, \TBool\}\\
    \vb \eqdef \astlabel(\vstwo) = \astlabel(\vttwo)
  }{
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[t\_enum]{
    \makeanonymous(\tenv, \vt) \typearrow \TEnum(\Ignore)\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \vb \eqdef \vstwo = \vttwo
  }{
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \makeanonymous(\tenv, \vs) \typearrow \TBits(\ws, \bfss)\\
  \makeanonymous(\tenv, \vt) \typearrow \TBits(\wt, \bfst)\\
  \bitwidthequal(\tenv, \ws, \wt) \typearrow \True \terminateas \False\\
  \bitfieldsincluded(\tenv, \bfss, \bfst) \typearrow \vb \OrTypeError
}{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_expr]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True \terminateas \False\\
  \booltrans{\astlabel(\vlengths) = \astlabel(\vlengtht)} \booltransarrow \True \terminateas \False\\
  \vlengths \eqname \ArrayLengthExpr(\vlengthexprs)\\
  \vlengtht \eqname \ArrayLengthExpr(\vlengthexprt)\\
  \exprequal(\tenv, \vlengthexprs, \vlengthexprt) \typearrow \vb
}
{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\and
\inferrule[t\_array\_enum]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True\\
  \booltrans{\astlabel(\vlengths) = \astlabel(\vlengtht)} \typearrow \True\\
  \vlengths \eqname \ArrayLengthEnum(\vnames, \Ignore)\\
  \vlengtht \eqname \ArrayLengthEnum(\vnamet, \Ignore)\\
  \vb \eqdef \vnames = \vnamet
}
{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]
{ \makeanonymous(\tenv, \vs) \typearrow\TTuple(\vlis)\\
  \makeanonymous(\tenv, \vt) \typearrow\TTuple(\vlit)\\
  \equallength(\vlis, \vlit) \typearrow\True \terminateas \False\\
  \vi\in\listrange(\vlis): \typesat(\tenv, \vlit[\vi], \vlis[\vi]) \typearrow \vb_i \terminateas \TTypeError\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_\vi
}{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\hypertarget{def-fieldnames}{}
For a list of typed fields $\fields$, we define the set of its field identifiers as:
\[
  \fieldnames(\fields) \triangleq \{ \id \;|\; (\id, \vt) \in \fields\}
\]
\hypertarget{def-fieldtype}{}
We define the type associated with the field name $\id$ in a list of typed fields $\fields$,
if there is a unique one, as follows:
\[
  \fieldtype(\fields, \id) \triangleq
  \begin{cases}
  \vt  & \text{ if }\{ \vtp \;|\; (\id,\vtp) \in \fields\} = \{\vt\}\\
  \bot & \text{ otherwise}
  \end{cases}
\]

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\
  \makeanonymous(\tenv, \vs)\typearrow L(\vfieldss) \\
  \makeanonymous(\tenv, \vt)\typearrow L(\vfieldst) \\
  \vnamess \eqdef \fieldnames(\vfieldss)\\
  \vnamest \eqdef \fieldnames(\vfieldst)\\
  \booltrans{\vnamess \subseteq \vnamest} \booltransarrow \True \terminateas \False\\
  (\id,\vtys)\in\vfieldss: \typeequal(\tenv, \vtys, \fieldtype(\vfieldst, \id)) \typearrow \vb_\id\\
  \vb \eqdef \bigwedge_{\id \in \vnamess} \vb_\id
}{
  \structsubtypesat(\tenv, \vs, \vt) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{TRVR}, \identi{SJDC}, \identi{MHYB}, \identi{TWTZ}, \identi{GYSK}, \identi{KXSD}.}

\section{TypingRule.DomainSubtypeSatisfaction\label{sec:TypingRule.DomainSubtypeSatisfaction}}
\hypertarget{def-domsubtypesat}{}
The predicate
\[
  \domsubtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{domain-subtype-satisfies} a type $\vs$ in environment $\tenv$,\\
\underline{assuming that $\vt$ structurally-subtype-satisfies $\vs$},
returning the result $\vb$ or a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{error1}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type error;
    \item the rule gives a type error.
  \end{itemize}

  \item All of the following apply (\textsc{error2}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type $\vsstruct$;
    \item obtaining the \structure\ of $\vt$ results in a type error;
    \item the rule gives a type error.
  \end{itemize}

  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type $\vsstruct$;
    \item the AST label of $\vsstruct$ is either $\TTuple$, $\TArray$, $\TRecord$, or $\TException$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{symbolic}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type $\vsstruct$;
    \item obtaining the \structure\ of $\vt$ results in a type $\vtstruct$;
    \item the AST label of $\vsstruct$ is either $\TReal$, $\TString$, $\TBool$, $\TEnum$, or $\TInt$;
    \item determining whether $\vs$ subsumes $\vt$ in $\tenv$ via symbolic reasoning results in $\vb$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\DomainSubtypeSatisfactionBegin}{\DomainSubtypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[error1]{
  \tstruct(\tenv, \vs) \typearrow \TypeErrorConfig\\
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\and
\inferrule[error2]{
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \tstruct(\tenv, \vt) \typearrow \TypeErrorConfig\\
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\and
\inferrule[simple]{
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \astlabel(\vsstruct) \in \{\TTuple, \TArray, \TRecord, \TException\}
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[symbolic]{
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct\\
  \astlabel(\vsstruct) \in \{\TReal, \TString, \TBool, \TEnum, \TInt\}\\
  \symsubsumes(\tenv, \vsstruct, \vtstruct) \typearrow \vb
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{TRVR}.}

\section{TypingRule.SubtypeSatisfaction\label{sec:TypingRule.SubtypeSatisfaction}}
\hypertarget{def-subtypesat}{}
The predicate
\[
  \subtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{subtype-satisfies} a type $\vs$ in environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item determining whether $\vt$ structurally-subtype-satisfies $\vs$ yields $\vbone$\ProseOrTypeError;
  \item determining whether $\vt$ domain-subtype-satisfies $\vs$ yields $\vbtwo$;
  \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SubtypeSatisfactionBegin}{\SubtypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
\begin{mathpar}
\inferrule{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vbone \OrTypeError\\
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{TRVR}, \identi{KNXJ}.}

\section{TypingRule.TypeSatisfaction \label{sec:TypingRule.TypeSatisfaction}}
\hypertarget{def-typesatisfies}{}
The predicate
\[
  \typesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{\typesatisfies} a type $\vs$ in environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.

\hypertarget{def-checktypesat}{}
We also define
\[
  \checktypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \True \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
which is the same as $\typesat$, but yields a type error when \\ $\typesat(\tenv, \vt, \vs)$ is $\False$.

\subsection{Prose}
One of the following applies:
 \begin{itemize}
  \item All of the following apply (\textsc{subtypes}):
    \begin{itemize}
    \item $\vt$ subtypes $\vs$ in $\tenv$ ;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{anonymous1}, \textsc{anonymous2}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item at least one of $\vt$ and $\vs$ is an anonymous type in $\tenv$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item determining whether $\vt$ is anonymous yields $\vbone$;
    \item determining whether $\vs$ is anonymous yields $\vbtwo$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\vbthree$;
    \item $(\vbone \lor \vbtwo) \land \vbthree$ is $\False$;
    \item determining whether $\vt$ is a bitvector type yields $\True$\ProseOrTypeError;
    \item $\vt$ is a bitvector type with width $\widtht$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a bitvector type with width $\widths$\ProseOrTypeError;
    \item determining whether $\widtht$ and $\widths$ are \bitwidthequivalent\ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{otherwise}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item neither one of $\vt$ and $\vs$ is an anonymous type in $\tenv$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\False$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a type $\vtone$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a type $\vsone$;
    \item at least one of $\vtone$ and $\vsone$ is not a bitvector type;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a bitvector type of length $\widths$\ProseOrTypeError;
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}

\subsection{Example}
In the specification:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction1.asl}
\texttt{var pair: pairT = (1, dataT1)} is legal since the right-hand-side has
anonymous, non-primitive type \texttt{(integer, T1)}.

\subsection{Example}
In the specification:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction2.asl}
\texttt{pair = (1, dataAsInt);} is legal since the right-hand-side has anonymous,
primitive type \texttt{(integer, integer)}.

\subsection{Example}
In the specification:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction3.asl}
\texttt{pair = (1, dataT2);} is illegal since the right-hand-side has anonymous,
non-primitive type \texttt{(integer, T2)} which does not subtype-satisfy named
type \texttt{pairT}.

\CodeSubsection{\TypeSatisfactionBegin}{\TypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[subtypes]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \True
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[anonymous1]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \True\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \True \OrTypeError
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[anonymous2]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vs) \typearrow \True\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \True
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[t\_bits]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \vbone\\
  \isanonymous(\tenv, \vs) \typearrow \vbtwo\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \vbthree\\
  \neg((\vbone \lor \vbtwo) \land \vbthree)\\
  \checktrans{\astlabel(\vt) = \TBits}{\ExpectedBitvectorType} \checktransarrow \True \OrTypeError\\\\
  \vt \eqname \TBits(\widtht, \Ignore)\\
  \tstruct(\tenv, \vs) \typearrow \TBits(\widths, \Ignore) \OrTypeError\\
  \bitwidthequal(\tenv, \widtht, \widths) \typearrow \vb
}{
  \typesat(\tenv, \vt, \vs) \typearrow \vb
}
\and
\inferrule[otherwise]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \False\\
  \isanonymous(\tenv, \vs) \typearrow \False\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \vtone\\
  \tstruct(\tenv, \vs) \typearrow \vsone\\
  \astlabel(\vtone) \neq \TBits \lor \astlabel(\vsone) \neq \TBits
}{
  \typesat(\tenv, \vt, \vs) \typearrow \False
}
\end{mathpar}

The rules for the checked type-satisfy predicate are:
\begin{mathpar}
\inferrule[true]{
  \typesat(\tenv, \vt, \vs) \typearrow \True \OrTypeError\\
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[error]{
  \typesat(\tenv, \vt, \vs) \typearrow \False
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \TypeErrorVal{TypeConflict}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
Since the subtype relation is a partial order, it is reflexive. Therefore
every type $\vt$ is a subtype of itself, and as a consequence, every type $\vt$
\typesatisfies\  itself.

\lrmcomment{This is related to \identr{FMXK} and \identi{NLFD}.}

\section{TypingRule.TypeClash\label{sec:TypingRule.TypeClash}}
\hypertarget{def-typeclashes}{}
The predicate
\[
  \typeclashes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{type-clashes} with a type $\vs$ in environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.

\subsection{Prose}
 One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{subtype1}, \textsc{subtype2}):
  \begin{itemize}
    \item either $\vs$ subtypes $\vt$ or $\vt$ subtypes $\vs$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields $\vsstruct$\ProseOrTypeError;
    \item both $\vtstruct$ and $\vsstruct$ are one of the following types: \\ \texttt{integer}, \texttt{real}, \texttt{string};
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_enum}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields an enumeration type with labels $\vlit$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields an enumeration type with labels $\vlis$;
    \item $\vb$ is $\True$ if and only if $\vlis$ and $\vlit$ are equal.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields an array type with element type $\vtyt$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields an array type with element type $\vtys$;
    \item $\vb$ is $\True$ if and only if $\vtyt$ and $\vtys$ type-clash.
  \end{itemize}

  \item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a tuple type with element types $\vt_{1..k}$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a tuple type with element types $\vs_{1..n}$;
    \item if $n \neq k$ the rule short-circuits with $\vb=\False$;
    \item $\vb$ is $\True$ if and only if $\vt_i$ type-clashes with $\vs_i$, for all $i=1..k$.
  \end{itemize}

  \item All of the following apply (\textsc{otherwise}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a tuple type with element types $\vt_{1..k}$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a tuple type with element types $\vs_{1..n}$;
    \item either $\vsstruct$ and $\vtstruct$ have different AST labels or one of their labels
    is $\TRecord$ or $\TException$;
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\TypeClashBegin}{\TypeClashEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[subtype1]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \True
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[subtype2]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \True
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[simple]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \OrTypeError \\
  \astlabel(\vtstruct)=\astlabel(\vsstruct) \in \{\TInt, \TReal, \TString, \TBits\}
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \TEnum(\Ignore, \vlis) \\
  \tstruct(\tenv, \vs) \typearrow \TEnum(\Ignore, \vlit)
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \overname{\vlis = \vlit}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \TArray(\Ignore, \vtyt) \\
  \tstruct(\tenv, \vs) \typearrow \TArray(\Ignore, \vtys) \\
  \typeclashes(\tenv, \vtyt, \vtys) \typearrow \vb
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) \typearrow \TTuple(\vs_{1..n}) \\
  \booltrans{n = k} \booltransarrow \True \terminateas \False\\
  i=1..k: \typeclashes(\tenv, \vt_i, \vs_i) \typearrow \vb_i\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_i
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \\
  \booltrans{\astlabel(\vtstruct) \neq \astlabel(\vsstruct)} \booltransarrow \True \terminateas \False\\
  \vb \eqdef \astlabel(\vtstruct) \not\in \{\TRecord, \TException\}\\
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \False
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
Note that if $\vt$ subtype-satisfies $\vs$ then $\vt$ and $\vs$ type-clash, but not the other
way around.

Note that type-clashing is an equivalence relation. Therefore if $\vt$
type-clashes with \texttt{A} and \texttt{B} then it is also the case that \texttt{A} and \texttt{B} type-clash.

\lrmcomment{This is related to \identd{VPZZ}, \identi{PQCT} and \identi{WZKM}.}

\section{TypingRule.LowestCommonAncestor \label{sec:TypingRule.LowestCommonAncestor}}
\hypertarget{def-lowestcommonancestor}{}
Annotating a conditional expression (see \secref{TypingRule.ECond}),
requires finding a single type that can be used to annotate the results of both sub-expressions.
The function
\[
  \lca(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\ty}{\tty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the \emph{lowest common ancestor} of types $\vt$ and $\vs$ in $\tenv$ --- $\tty$.
The result is a type error if a lowest common ancestor does not exist or a type error is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{type\_equal}):
  \begin{itemize}
    \item $\vt$ is \typeequal\ to $\vs$ in $\tenv$;
    \item $\tty$ is $\vs$ (can as well be $\vt$).
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\vt$ is not \typeequal\ to $\vs$ in $\tenv$ and one of the following applies:

    \item All of the following apply (\textsc{named\_subtype1}):
    \begin{itemize}
      \item $\vt$ is a named type with identifier $\namesubt$, that is, $\TNamed(\namesubt)$;
      \item $\vs$ is a named type with identifier $\namesubs$, that is, $\TNamed(\namesubs)$;
      \item there is no \namedlowestcommonancestor\ of $\namesubs$ and $\namesubt$ in $\tenv$;
      \item obtaining the \underlyingtype\ of $\vs$ yields $\vanons$\ProseOrTypeError;
      \item obtaining the \underlyingtype\ of $\vt$ yields $\vanont$\ProseOrTypeError;
      \item obtaining the lowest common ancestor of $\vanons$ and $\vanont$ in $\tenv$ yields $\tty$\ProseOrTypeError.
    \end{itemize}

    \item All of the following apply (\textsc{named\_subtype2}):
    \begin{itemize}
      \item $\vt$ is a named type with identifier $\namesubt$, that is, $\TNamed(\namesubt)$;
      \item $\vs$ is a named type with identifier $\namesubs$, that is, $\TNamed(\namesubs)$;
      \item the \namedlowestcommonancestor\ of $\namesubs$ and $\namesubt$ in $\tenv$ is $\name$\ProseOrTypeError;
      \item $\tty$ is the named type with identifier $\name$, that is, $\TNamed(\name)$.
    \end{itemize}

    \item All of the following apply (\textsc{one\_named1}):
    \begin{itemize}
      \item only one of $\vt$ or $\vs$ is a named type;
      \item obtaining the \underlyingtype\ of $\vs$ yields $\vanons$\ProseOrTypeError;
      \item obtaining the \underlyingtype\ of $\vt$ yields $\vanont$\ProseOrTypeError;
      \item $\vanont$ is \typeequal\ to $\vanons$;
      \item $\tty$ is $\vt$ if it is a named type (that is, $\astlabel(\vt)=\TNamed$), and $\vs$ otherwise.
    \end{itemize}

    \item All of the following apply (\textsc{one\_named2}):
    \begin{itemize}
      \item only one of $\vt$ or $\vs$ is a named type;
      \item obtaining the \underlyingtype\ of $\vs$ yields $\vanons$\ProseOrTypeError;
      \item obtaining the \underlyingtype\ of $\vt$ yields $\vanont$\ProseOrTypeError;
      \item $\vanont$ is not \typeequal\ to $\vanons$;
      \item the lowest common ancestor of $\vanont$ and $\vanons$ in $\tenv$ is $\tty$\ProseOrTypeError.
    \end{itemize}

    \item All of the following apply (\textsc{t\_int\_unconstrained}):
    \begin{itemize}
      \item at least one of $\vt$ or $\vs$ is an unconstrained integer type;
      \item $\tty$ is the unconstrained integer type.
    \end{itemize}

    \item All of the following apply (\textsc{t\_int\_underconstrained}):
    \begin{itemize}
      \item neither of $\vt$ and $\vs$ are the unconstrained integer type;
      \item the \wellconstrainedversion\ of $\vt$ is $\vtone$;
      \item the \wellconstrainedversion\ of $\vs$ is $\vsone$;
      \item $\tty$ the lowest common ancestor of $\vtone$ and $\vsone$ in $\tenv$ is $\tty$\ProseOrTypeError.
    \end{itemize}

    \item All of the following apply (\textsc{t\_int\_wellconstrained}):
    \begin{itemize}
      \item $\vt$ is a well-constrained integer type with constraints $\cst$;
      \item $\vs$ is a well-constrained integer type with constraints $\css$;
      \item $\tty$ is the well-constrained integer type with constraints $\cst \concat \css$.
    \end{itemize}

    \item All of the following apply (\textsc{t\_bits\_equal}):
    \begin{itemize}
      \item $\vt$ is a bitvector type with with length expression $\vet$, that is, $\TBits(\vet, \Ignore)$;
      \item $\vs$ is a bitvector type with with length expression $\ves$, that is, $\TBits(\ves, \Ignore)$;
      \item $\vet$ is equivalent to $\ves$ in $\tenv$;
      \item $\tty$ is a bitvector type with length expression $\vet$ and an empty bitfield list, that is, $\TBits(\vet, \emptylist)$.
    \end{itemize}

    \item All of the following apply (\textsc{t\_bits\_not\_equal}):
    \begin{itemize}
      \item $\vt$ is a bitvector type with length expression $\vet$;
      \item $\vs$ is a bitvector type with length expression $\ves$;
      \item $\vet$ is not equivalent to $\ves$ in $\tenv$;
      \item the result is a type error indicating the lack of a lowest common ancestor.
    \end{itemize}

    \item All of the following apply (\textsc{t\_array\_equal}):
    \begin{itemize}
      \item $\vt$ is an array type with width expression $\widtht$ and element type $\vtyt$;
      \item $\vs$ is an array type with width expression $\widths$ and element type $\vtys$;
      \item $\widtht$ is equivalent to $\widths$ in $\tenv$;
      \item the lowest common ancestor of $\vtyt$ and $\vtys$ is $\vtone$\ProseOrTypeError;
      \item $\tty$ is an array type with width expression $\widths$ and element type $\vtone$.
    \end{itemize}

    \item All of the following apply (\textsc{t\_array\_not\_equal}):
    \begin{itemize}
      \item $\vt$ is an array type with width expression $\widtht$ and element type $\vtyt$;
      \item $\vs$ is an array type with width expression $\widths$ and element type $\vtys$;
      \item $\widtht$ is not equivalent to $\widths$ in $\tenv$;
      \item the result is a type error indicating the lack of a lowest common ancestor.
    \end{itemize}

    \item All of the following apply (\textsc{t\_tuple}):
    \begin{itemize}
      \item $\vt$ is a tuple type with type list $\vlit$;
      \item $\vs$ is a tuple type with type list $\vlis$;
      \item checking whether $\vlit$ and $\vlis$ have the same number of elements yields $\True$
            or a type error, which short-circuits the entire rule (indicating that the number of elements in both tuples is expected
            to be the same and thus there is no lowest common ancestor);
      \item $\vli[\vi]$ is the of types lowest common ancestor of $\vlit[\vi]$ and $\vlis[\vi]$, for every position of $\vlit$;
      \item $\tty$ is the tuple type with list of types $\vli$, that is, $\TTuple(\vli)$.
    \end{itemize}

    \item All of the following apply (\textsc{labels}):
    \begin{itemize}
      \item either the AST labels of $\vt$ and $\vs$ are different, or one of them is $\TEnum$, $\TRecord$, or $\TException$;
      \item the result is a type error indicating the lack of a lowest common ancestor.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\LowestCommonAncestorBegin}{\LowestCommonAncestorEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
Since we do not impose a canonical representation on types (e.g., \verb|integer {1, 2}| is equivalence to \verb|integer {1..2}|),
the lowest common ancestor is not unique.
We define $\lca(\tenv, \vt, \vs)$ to be any type $\vtp$ that is \typeequivalent\ to the lowest common ancestor of $\vt$ and $\vs$.

\begin{mathpar}
\inferrule[type\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \True
}{
  \lca(\tenv, \vt, \vs) \typearrow \vs
}
\and
\inferrule[named\_subtype1]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \namedlca(\tenv, \namesubs, \namesubt) \typearrow \None \OrTypeError\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\
  \lca(\tenv, \vanont, \vanons) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \TNamed(\namesubs), \TNamed(\namesubt)) \typearrow \tty
}
\and
\inferrule[named\_subtype2]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \namedlca(\tenv, \namesubs, \namesubt) \typearrow \langle\name\rangle \OrTypeError\\
}{
  \lca(\tenv, \TNamed(\namesubs), \TNamed(\namesubt)) \typearrow \TNamed(\name)
}
\and
\inferrule[one\_named1]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) = \TNamed \lor \astlabel(\vs) = \TNamed)\\
  \astlabel(\vt) \neq \astlabel(\vs)\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\
  \typeequal(\tenv, \vanont, \vanons) \typearrow \True\\
  \tty \eqdef \choice{\astlabel(\vt) = \TNamed}{\vt}{\vs}
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\and
\inferrule[one\_named2]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) = \TNamed \lor \astlabel(\vs) = \TNamed)\\
  \astlabel(\vt) \neq \astlabel(\vs)\\
  \makeanonymous(\tenv, \vs) \typearrow \vanons \OrTypeError\\
  \makeanonymous(\tenv, \vt) \typearrow \vanont \OrTypeError\\
  \typeequal(\tenv, \vanont, \vanons) \typearrow \False\\
  \lca(\tenv, \vanont, \vanons) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_int\_unconstrained]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \isunconstrainedinteger(\vt) \lor \isunconstrainedinteger(\vs)
}{
  \lca(\tenv, \vt, \vs) \typearrow \unconstrainedinteger
}
\and
\inferrule[t\_int\_underconstrained]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \neg\isunconstrainedinteger(\vt)\\
  \neg\isunconstrainedinteger(\vs)\\
  \isunderconstrainedinteger(\vt) \lor \isunderconstrainedinteger(\vs)\\
  \towellconstrained(\tenv, \vt) \typearrow \vtone\\
  \towellconstrained(\tenv, \vs) \typearrow \vsone\\
  \lca(\tenv, \vtone, \vsone) \typearrow \tty \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \tty
}
\and
\inferrule[t\_int\_wellconstrained]
{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \astlabel(\vt) = \astlabel(\vs) = \TInt\\
  \vt \eqname \TInt(\wellconstrained(\cst))\\
  \vs \eqname \TInt(\wellconstrained(\css))
}{
  \lca(\tenv, \vt, \vs) \typearrow \TInt(\wellconstrained(\cst \concat \css))
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TBits(\vet, \Ignore)\\
  \vs \eqname \TBits(\ves, \Ignore)\\
  \exprequal(\tenv, \vet, \ves) \typearrow \True
}{
  \lca(\tenv, \vt, \vs) \typearrow \TBits(\vet, \emptylist)
}
\and
\inferrule[t\_bits\_not\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TBits(\vet, \Ignore)\\
  \vs \eqname \TBits(\ves, \Ignore)\\
  \exprequal(\tenv, \vet, \ves) \typearrow \False
}{
  \lca(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\NoLCA}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TArray(\widtht, \vtyt)\\
  \vs \eqname \TArray(\widths, \vtys)\\
  \arraylengthequal(\tenv, \widtht, \widths) \typearrow \True\\
  \lca(\tenv, \vtyt, \vtys) \typearrow \vtone \OrTypeError
}{
  \lca(\tenv, \vt, \vs) \typearrow \TArray(\widtht, \vtone)
}
\and
\inferrule[t\_array\_not\_equal]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TArray(\widtht, \vtyt)\\
  \vs \eqname \TArray(\widths, \vtys)\\
  \arraylengthequal(\tenv, \widtht, \widths) \typearrow \False
}{
  \lca(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\NoLCA}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  \vt \eqname \TTuple(\vlit)\\
  \vs \eqname \TTuple(\vlis)\\
  \equallength(\vlit, \vlis) \typearrow \vb\\
  \checktrans{\vb}{NoLCA/TuplesHaveDifferentLengths} \typearrow \True \OrTypeError\\\\
  \vi\in\listrange(\vlit): \lca(\tenv, \vlit[\vi], \vlis[\vi]) \typearrow \vli[\vi] \OrTypeError\\
  \vli \eqdef [\vi\in\listrange(\vlit): \vli[\vi]]
}{
  \lca(\tenv, \vt, \vs) \typearrow \TTuple(\vli)
}
\end{mathpar}

\begin{mathpar}
\inferrule[labels]{
  \typeequal(\tenv, \vt, \vs) \typearrow \False\\
  (\astlabel(\vt) \neq \astlabel(\vs)) \lor
  \astlabel(\vt) \in \{\TEnum, \TRecord, \TException\}
}
{
  \lca(\tenv, \vt, \vs) \typearrow \TypeErrorVal{\NoLCA}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{YZHM}.}

\section{TypingRule.CheckUnop \label{sec:TypingRule.CheckUnop}}
\hypertarget{def-checkunop}{}
The function
\[
  \CheckUnop(\overname{\staticenvs}{\tenv} \aslsep \overname{\unop}{\op} \aslsep \overname{\ty}{\vt})
  \aslto \overname{\ty}{\vs}
\]
determines the result type of applying a unary operator when the type of its operand is known.
Similarly, we determine the negation of integer constraints.

\subsection{Prose}
One of the following applies:
\begin{itemize}
\item All of the following apply (\textsc{bnot\_t\_bool}):
  \begin{itemize}
    \item $\op$ is $\BNOT$;
    \item determining whether $\vt$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vs$ is $\TBool$;
  \end{itemize}

\item All of the following apply (\textsc{neg\_error}):
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\TReal$ yields $\False$\ProseOrTypeError;
  \item determining whether $\vt$ \typesatisfies\ $\TInt(\unconstrained)$ yields $\False$\ProseOrTypeError;
  \item the result is a type error indicating the $\NEG$ is appropriate only for \texttt{real} and \texttt{integer} types;
\end{itemize}

\item All of the following apply (\textsc{neg\_t\_rel}):
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\TReal$ yields $\True$\ProseOrTypeError;
  \item $\vs$ is $\TReal$;
\end{itemize}

\item All of the following apply (\textsc{neg\_t\_int\_unconstrained}):
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\unconstrainedinteger$ yields $\True$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ yields $\unconstrainedinteger$\ProseOrTypeError;
  \item $\vs$ is $\unconstrainedinteger$;
\end{itemize}

\item All of the following apply (\textsc{neg\_t\_int\_well\_constrained}):
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\unconstrainedinteger$ yields $\True$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ yields the well-constrained integer type with constraints $\vcs$\ProseOrTypeError;
  \item negating the constraints in $\vcs$ (see $\negateconstraint$) yields $\vcsnew$;
  \item $\vs$ is the well-constrained integer type with constraints $\vcsnew$, that is, \\
  $\TInt(\wellconstrained(\vcsnew))$;
\end{itemize}

\item All of the following apply (\textsc{neg\_t\_int\_underconstrained}):
\begin{itemize}
  \item $\op$ is $\NEG$;
  \item determining whether $\vt$ \typesatisfies\ $\unconstrainedinteger$ yields $\True$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ yields the underconstrained integer type with parameter $\vv$, that is,
  $\TInt(\wellconstrained(\vv))$\ProseOrTypeError;
  \item converting $\TInt(\wellconstrained(\vv))$ to a well-constrained integer with an exact constraint expression for $\vv$
  (see $\getwellconstrainedstructure$) yields $\vtone$;
  \item obtaining the appropriate type for the unary operator $\NEG$ in $\tenv$ for $\vt$ yields $\vs$.
\end{itemize}

\item All of the following apply (\textsc{not\_t\_bits}):
  \begin{itemize}
  \item $\op$ is $\NOT$;
  \item $\vt$ has the structure of a bitvector;
  \item $\vs$ is $\vt$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\CheckUnopBegin}{\CheckUnopEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[bnot\_t\_bool]{
  \checktypesat(\tenv, \vtone, \TBool) \typearrow \True \OrTypeError\\
}{
  \CheckUnop(\tenv, \BNOT, \vtone) \typearrow \TBool
}
\end{mathpar}

\hypertarget{def-negateconstraint}{}
We now define the helper function
\[
  \negateconstraint(\intconstraint) \aslto \intconstraint
\]
which takes an integer constraint and returns the constraint that corresponds to the negation of all
the values it represents:

\begin{mathpar}
\inferrule{}
{
  \negateconstraint(\ConstraintExact(\ve)) \typearrow \ConstraintExact(\EUnop(\MINUS, \ve))
}
\and
\inferrule{}
{
  \negateconstraint(\ConstraintRange(\vvtop, \vbot)) \typearrow \\
  \ConstraintRange(\EUnop(\MINUS, \vbot), \EUnop(\MINUS, \vvtop))
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_error]{
  \typesat(\tenv, \vtone, \TInt(\unconstrained)) \typearrow \False \OrTypeError\\
  \typesat(\tenv, \vtone, \TReal) \typearrow \False \OrTypeError\\
}{
  \CheckUnop(\tenv, \NEG, \vt) \typearrow \TypeErrorVal{InappropriateTypeForNeg}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_real]{
  \typesat(\tenv, \vtone, \TReal) \typearrow \True \OrTypeError
}{
  \CheckUnop(\tenv, \NEG, \vt) \typearrow \TReal
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_int\_unconstrained]{
  \typesat(\tenv, \vtone, \unconstrainedinteger) \typearrow \vbone \OrTypeError\\
  \tstruct(\tenv, \vtone) \typearrow \TInt(\unconstrained)\\
}{
  \CheckUnop(\tenv, \NEG, \vt) \typearrow \TInt(\unconstrained)
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_int\_well\_constrained]{
  \typesat(\tenv, \vt, \unconstrainedinteger) \typearrow \True\\
  \tstruct(\tenv, \vtone) \typearrow \TInt(\wellconstrained(\vcs))\\
  \vc \in \vcs: \negateconstraint(\vc) \typearrow \vneg_\vc\\
  \vcsnew \eqdef [\vc \in \vcs: \vneg_\vc]
}{
  \CheckUnop(\tenv, \NEG, \vt) \typearrow \TInt(\wellconstrained(\vcsnew))
}
\end{mathpar}

\begin{mathpar}
\inferrule[neg\_t\_int\_underconstrained]{
  \typesat(\tenv, \vt, \unconstrainedinteger) \typearrow \True\\
  \tstruct(\tenv, \vtone) \typearrow \TInt(\underconstrained(\vv))\\
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \vtone\\
  \CheckUnop(\tenv, \NEG, \vtone) \typearrow \vs
}{
  \CheckUnop(\tenv, \NEG, \vt) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_t\_bits]{
  \checkstructurelabel(\tenv, \vt, \TBits) \typearrow \True \OrTypeError
}{
  \CheckUnop(\tenv, \NOT, \vt) \typearrow \vt
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.CheckBinop \label{sec:TypingRule.CheckBinop}}
\hypertarget{def-checkbinop}{}
The function
\[
  \CheckBinop(\overname{\staticenvs}{\tenv} \aslsep \overname{\binop}{\op} \aslsep \overname{\ty}{\vtone}
  \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\ty}{\vt}
\]
determines the result type $\vt$ of applying the binary operator $\op$
to operands of type $\vtone$ and $\vttwo$ in the static environment $\tenv$,
returning a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{boolean}):
  \begin{itemize}
    \item $\op$ is $\AND$, $\OR$, $\EQOP$ or $\IMPL$;
    \item determining whether $\vtone$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item determining whether $\vttwo$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{bits\_bool}):
  \begin{itemize}
    \item $\op$ is $\AND$, $\OR$, or $\EOR$;
    \item checking whether $\vtone$ and $\vttwo$ have the \structure\ of bitvector types
          of the same width in $\tenv$ yields $\True$\ProseOrTypeError;
    \item the bitvector width of $\vtone$ in $\tenv$ is $\vw$;
    \item $\vt$ is the bitvector type of width $\vw$ and empty list of bitfields, that is, \\ $\TBits(\vw, \emptylist)$.
  \end{itemize}

  \item All of the following apply (\textsc{plus\_minus\_error}):
  \begin{itemize}
    \item $\op$ is $\PLUS$ or $\MINUS$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ is $\vtonestruct$\ProseOrTypeError;
    \item $\vtonestruct$ is neither a bitvector type nor an integer type;
    \item the result is a type error indicating that the type of $\vtone$ is inappropriate for $\op$.
  \end{itemize}

  \item All of the following apply (\textsc{plus\_minus\_bits\_int}):
  \begin{itemize}
    \item $\op$ is $\PLUS$ or $\MINUS$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ is $\vtonestruct$\ProseOrTypeError;
    \item $\vtonestruct$ is a bitvector type;
    \item $\vttwo$ \typesatisfies\ the unconstrained integer type in $\tenv$;
    \item obtaining the bitwidth of $\vtone$ in $\tenv$ yields $\vw$.
    \item $\vt$ is the bitvector type of width $\vw$ and empty list of bitfields, that is, \\ $\TBits(\vw, \emptylist)$.
  \end{itemize}

  \item All of the following apply (\textsc{plus\_minus\_bits\_bits}):
  \begin{itemize}
    \item $\op$ is $\PLUS$ or $\MINUS$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ is a bitvector of width $\veone$, that is,\\ $\TBits(\veone, \Ignore)$;
    \item $\vttwo$ does not \typesatisfy\ the unconstrained integer type in $\tenv$
    \item obtaining the \structure\ of $\vttwo$ in $\tenv$ is $\vttwostruct$\ProseOrTypeError;
    \item determining whether $\vttwostruct$ has a bitvector type yields $\True$\ProseOrTypeError;
    \item $\vttwostruct$ is a bitvector of width $\vwtwo$, that is, $\TBits(\vwtwo, \Ignore)$;
    \item determining whether $\vwone$ and $\vwtwo$ are equal bitwidths yields $\vb$;
    \item $\vb$ is $\True$\ProseOrTypeError;
    \item $\vt$ is the bitvector type of width $\vwone$ and empty list of bitfields, that is, \\ $\TBits(\vwone, \emptylist)$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_error}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\vtoneanon$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\vttwoanon$\ProseOrTypeError;
    \item the AST labels of $\vtoneanon$ and $\vttwoanon$ are different or one of them is not in
          $\{\TInt, \TReal, \TBool, \TBits, \TEnum\}$;
    \item the result is a type error indicating that the types of $\vtone$ and $\vttwo$ are inappropriate for $\op$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_bits}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\vtoneanon$\ProseOrTypeError;
    \item $\vtoneanon$ is a bitvector type;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\vttwoanon$\ProseOrTypeError;
    \item checking whether the bitwidth of $\vtoneanon$ and $\vttwoanon$ is the same yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_bool}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\TBool$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\TBool$\ProseOrTypeError;
    \item checking whether $\vtoneanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item checking whether $\vttwoanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_real}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\TReal$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\TReal$\ProseOrTypeError;
    \item checking whether $\vtoneanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item checking whether $\vttwoanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_string}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\TString$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\TString$\ProseOrTypeError;
    \item checking whether $\vtoneanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item checking whether $\vttwoanon$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_neq\_enum}):
  \begin{itemize}
    \item $\op$ is either $\EQOP$ or $\NEQ$;
    \item the \underlyingtype\ of $\vtone$ in $\tenv$ is $\TEnum(\vlione)$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vttwo$ in $\tenv$ is $\\TEnum(\vlitwo)$\ProseOrTypeError;
    \item checking whether $\vlione$ is equal to $\vlitwo$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{relational}):
  \begin{itemize}
    \item $\op$ is one of $\LT$, $\LEQ$, $\GT$, and $\GEQ$;
    \item determining whether both $\vtone$ and $\vttwo$ \typesatisfy\ the unconstrained integer type in $\tenv$
          or both $\vtone$ and $\vttwo$ \typesatisfy\ the \texttt{real} type in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply (\textsc{arith\_error}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ yields $\vtonestruct$\ProseOrTypeError;
    \item obtaining the \structure\ of $\vttwo$ in $\tenv$ yields $\vttwostruct$\ProseOrTypeError;
    \item the operator and the AST labels of $\vtonestruct$ and $\vttwostruct$ do not match any of the rows in the following table:

    \begin{center}
    \begin{tabular}{lll}
      \op    & $\astlabel(\vtonestruct)$ & $\astlabel(\vttwostruct)$\\
      \hline
      \MUL   & \TInt  & \TInt\\
      \DIV   & \TInt  & \TInt\\
      \DIVRM & \TInt  & \TInt\\
      \MOD   & \TInt  & \TInt\\
      \SHL   & \TInt  & \TInt\\
      \SHR   & \TInt  & \TInt\\
      \POW   & \TInt  & \TInt\\
      \PLUS  & \TInt  & \TInt\\
      \MINUS & \TInt  & \TInt\\
      \PLUS  & \TReal & \TReal\\
      \MINUS & \TReal & \TReal\\
      \MUL   & \TReal & \TReal\\
      \RDIV  & \TReal & \TReal\\
      \POW   & \TReal & \TInt\\
    \end{tabular}
  \end{center}
    \item the result is a type error indicating that the types of $\vtone$ and $\vttwo$ are inappropriate for $\op$.
  \end{itemize}

  \item All of the following apply (\textsc{arith\_t\_int\_unconstrained1}, \\
                                    \textsc{arith\_t\_int\_unconstrained2}):
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}$;
    \item the \wellconstrainedstructure\ of either $\vtone$ or $\vttwo$ in $\tenv$ is that of the unconstrained integer type;
    \item $\vt$ is the unconstrained integer type;
  \end{itemize}

  \item All of the following apply (\textsc{arith\_t\_int\_wellconstrained1}):
  \begin{itemize}
    \item $\op$ is one of $\{\MUL, \POW, \PLUS, \MINUS\}$;
    \item the \wellconstrainedstructure\ of either $\vtone$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcsone$;
          \item the \wellconstrainedstructure\ of either $\vttwo$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcstwo$;
    \item applying $\op$ to $\vcsone$ and $\vcstwo$ in $\tenv$ yields $\vcs$;
    \item $\vt$ is the well-constrained integer type with constraints $\vcs$;
  \end{itemize}

  \item All of the following apply (\textsc{arith\_t\_int\_wellconstrained2}):
  \begin{itemize}
    \item $\op$ is one of $\{\DIVRM, \DIV, \MOD\}$;
    \item the \wellconstrainedstructure\ of either $\vtone$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcsone$;
          \item the \wellconstrainedstructure\ of either $\vttwo$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcstwo$;
    \item checking whether $\vcstwo$ represents strictly-positive integers yields $\True$\ProseOrTypeError;
    \item applying $\op$ to $\vcsone$ and $\vcstwo$ in $\tenv$ yields $\vcs$;
    \item $\vt$ is the well-constrained integer type with constraints $\vcs$;
  \end{itemize}

  \item All of the following apply (\textsc{arith\_t\_int\_wellconstrained3}):
  \begin{itemize}
    \item $\op$ is one of $\{\DIVRM, \DIV, \MOD\}$;
    \item the \wellconstrainedstructure\ of either $\vtone$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcsone$;
          \item the \wellconstrainedstructure\ of either $\vttwo$ in $\tenv$ is that of a well-constrained integer type with
          constraints $\vcstwo$;
    \item checking whether $\vcstwo$ represents non-negative integers yields $\True$\ProseOrTypeError;
    \item applying $\op$ to $\vcsone$ and $\vcstwo$ in $\tenv$ yields $\vcs$;
    \item $\vt$ is the well-constrained integer type with constraints $\vcs$;
  \end{itemize}

  \item All of the following apply (\textsc{plus\_minus\_mul\_real}):
  \begin{itemize}
    \item $\op$ is one of $\{\PLUS, \MINUS, \MUL\}$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ yields $\TReal$;
    \item obtaining the \structure\ of $\vttwo$ in $\tenv$ yields $\TReal$;
    \item $\vt$ is $\TReal$.
  \end{itemize}

  \item All of the following apply (\textsc{pow\_real\_int}):
  \begin{itemize}
    \item $\op$ is one of $\{\PLUS, \MINUS, \MUL\}$;
    \item obtaining the \structure\ of $\vtone$ in $\tenv$ yields $\TReal$;
    \item obtaining the \structure\ of $\vttwo$ in $\tenv$ yields an integer type;
    \item $\vt$ is $\TReal$.
  \end{itemize}

  \item All of the following apply (\textsc{rdiv}):
  \begin{itemize}
    \item $\op$ is one of $\{\RDIV\}$;
    \item determining whether $\vtone$ \typesatisfies\ $\TReal$ yields $\True$\ProseOrTypeError;
    \item determining whether $\vttwo$ \typesatisfies\ $\TReal$ yields $\True$\ProseOrTypeError;
    \item $\vt$ is $\TReal$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\CheckBinopBegin}{\CheckBinopEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[boolean]{
  \op \in  \{\BAND, \BOR, \IMPL, \EQOP\}\\
  \checktypesat(\tenv, \vt1, \TBool) \typearrow \True \OrTypeError\\
  \checktypesat(\tenv, \vttwo, \TBool) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool}
\end{mathpar}

\begin{mathpar}
\inferrule[bits\_bool]{
  \op \in  \{\AND, \OR, \EOR\}\\
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError\\
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vw
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBits(\vw, \emptylist)
}
\end{mathpar}

\begin{mathpar}
\inferrule[plus\_minus\_error]{
  \op \in  \{\PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \vtonestruct \OrTypeError\\\\
  \astlabel(\vtonestruct) \not\in \{\TBits,\TInt\}\\
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TypeErrorVal{InappropriateTypeForPlusMinus}
}
\and
\inferrule[plus\_minus\_bits\_int]{
  \op \in  \{\PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \vtonestruct \OrTypeError\\\\
  \astlabel(\vtonestruct) = \TBits\\
  \typesat(\tenv, \vttwo, \unconstrainedinteger) \typearrow \True\\
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vw\\
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBits(\vw, \emptylist)
}
\and
\inferrule[plus\_minus\_bits\_bits]{
  \op \in  \{\PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \TBits(\vwone, \Ignore) \\
  \typesat(\tenv, \vttwo, \unconstrainedinteger) \typearrow \False\\
  \tstruct(\tenv, \vttwo) \typearrow \vttwostruct \OrTypeError\\\\
  \checktrans{\astlabel(\vttwostruct)=\TBits}{\ExpectedBitvectorType} \checktransarrow \True \OrTypeError\\
  \vttwostruct \eqname \TBits(\vwtwo, \Ignore)\\
  \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vb\\
  \checktrans{\vb}{DifferentBitwidths} \checktransarrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBits(\vwone, \emptylist)
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_neq\_error]
{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \vtoneanon \OrTypeError\\
  \makeanonymous(\tenv, \vttwo) \typearrow \vttwoanon \OrTypeError\\
  (\astlabel(\vtoneanon) \neq \astlabel(\vttwoanon)) \lor
  \astlabel(\vtone) \not\in \{\TInt, \TReal, \TBool, \TBits, \TEnum\}
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TypeErrorVal{InappropriateTypeForEQ}
}
\and
\inferrule[eq\_neq\_bits]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \vtoneanon \OrTypeError\\
  \astlabel(\vtoneanon) = \TBits\\
  \makeanonymous(\tenv, \vttwo) \typearrow \vttwoanon \OrTypeError\\
  \checkbitsequalwidth(\tenv, \vtoneanon, \vttwoanon) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\and
\inferrule[eq\_neq\_bool]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \TBool\\
  \makeanonymous(\tenv, \vttwo) \typearrow \TBool\\
  \checktypesat(\tenv, \vtoneanon, \TBool) \typearrow \True \OrTypeError\\
  \checktypesat(\tenv, \vttwoanon, \TBool) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\and
\inferrule[eq\_neq\_real]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \TReal\\
  \makeanonymous(\tenv, \vttwo) \typearrow \TReal\\
  \checktypesat(\tenv, \vtoneanon, \TReal) \typearrow \True \OrTypeError\\
  \checktypesat(\tenv, \vttwoanon, \TReal) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\and
\inferrule[eq\_neq\_string]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \TString\\
  \makeanonymous(\tenv, \vttwo) \typearrow \TString\\
  \checktypesat(\tenv, \vtoneanon, \TString) \typearrow \True \OrTypeError\\
  \checktypesat(\tenv, \vttwoanon, \TString) \typearrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\and
\inferrule[eq\_neq\_enum]{
  \op \in  \{\EQOP, \NEQ\}\\
  \makeanonymous(\tenv, \vtone) \typearrow \TEnum(\vlione)\\
  \makeanonymous(\tenv, \vttwo) \typearrow \TEnum(\vlitwo)\\
  \checktrans{\vlione = \vlitwo}{DifferentEnumLabels} \checktransarrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\end{mathpar}

\begin{mathpar}
\inferrule[relational]{
  \op \in  \{\LT, \LEQ, \GT, \GEQ\}\\
  \typesat(\tenv, \vtone, \unconstrainedinteger) \typearrow \vbone \OrTypeError\\
  \typesat(\tenv, \vttwo, \unconstrainedinteger) \typearrow \vbtwo \OrTypeError\\
  \typesat(\tenv, \vtone, \TReal) \typearrow \vbthree \OrTypeError\\
  \typesat(\tenv, \vttwo, \TReal) \typearrow \vbfour \OrTypeError\\
  \checktrans{\vbone \land \vbtwo \lor \vbthree \land \vbfour}{InappropriateTypeForRel} \checktransarrow \True \OrTypeError
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_error]{
  \tstruct(\tenv, \vtone) \typearrow \vtonestruct \OrTypeError\\
  \tstruct(\tenv, \vttwo) \typearrow \vttwostruct \OrTypeError\\
  (\op, \astlabel(\vtonestruct), \astlabel(\vttwostruct)) \not\in
  {
    \left\{
    \begin{array}{lclcl}
      (\MUL   &,& \TInt  &,& \TInt)\\
      (\DIV   &,& \TInt  &,& \TInt)\\
      (\DIVRM &,& \TInt  &,& \TInt)\\
      (\MOD   &,& \TInt  &,& \TInt)\\
      (\SHL   &,& \TInt  &,& \TInt)\\
      (\SHR   &,& \TInt  &,& \TInt)\\
      (\POW   &,& \TInt  &,& \TInt)\\
      (\PLUS  &,& \TInt  &,& \TInt)\\
      (\MINUS &,& \TInt  &,& \TInt)\\
      (\PLUS  &,& \TReal &,& \TReal)\\
      (\MINUS &,& \TReal &,& \TReal)\\
      (\MUL   &,& \TReal &,& \TReal)\\
      (\RDIV  &,& \TReal &,& \TReal)\\
      (\POW   &,& \TReal &,& \TInt)\\
    \end{array}
    \right\}
  }
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TypeErrorVal{InappropriateTypeForBinop}
}
\end{mathpar}

The following two rules are not mutually exclusive, but both yield the same result when they are both active.
\begin{mathpar}
\inferrule[arith\_t\_int\_unconstrained1]{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \unconstrainedinteger\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \TInt(\Ignore)\\
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \unconstrainedinteger
}
\and
\inferrule[arith\_t\_int\_unconstrained2]{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \TInt(\Ignore)\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \unconstrainedinteger\\
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \unconstrainedinteger
}
\end{mathpar}

\begin{mathpar}
\inferrule[arith\_t\_int\_wellconstrained1]{
  \op \in  \{\MUL, \POW, \PLUS, \MINUS\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \TInt(\wellconstrained(\vcsone))\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \TInt(\wellconstrained(\vcstwo))\\
  \tododefine{constraints\_binop}(\tenv, \op, \vcsone, \vcstwo) \typearrow \vcs
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TInt(\wellconstrained(\vcs))
}
\and
\inferrule[arith\_t\_int\_wellconstrained2]{
  \op \in  \{\DIVRM, \DIV, \MOD\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \TInt(\wellconstrained(\vcsone))\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \TInt(\wellconstrained(\vcstwo))\\
  \tododefine{constraints\_is\_strict\_positive}(\vcstwo) \typearrow \vb\\
  \checktrans{\vb}{DenominatorMustBePositive} \checktransarrow \True \OrTypeError\\
  \tododefine{constraints\_binop}(\tenv, \op, \vcsone, \vcstwo) \typearrow \vcs
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TInt(\wellconstrained(\vcs))
}
\and
\inferrule[arith\_t\_int\_wellconstrained3]{
  \op \in  \{\SHL, \SHR\}\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \TInt(\wellconstrained(\vcsone))\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \TInt(\wellconstrained(\vcstwo))\\
  \tododefine{constraints\_is\_non\_negative}(\vcstwo) \typearrow \vb\\
  \checktrans{\vb}{ShifterMustBeNonNegative} \checktransarrow \True \OrTypeError\\
  \tododefine{constraints\_binop}(\tenv, \op, \vcsone, \vcstwo) \typearrow \vcs
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TInt(\wellconstrained(\vcs))
}
\end{mathpar}

\begin{mathpar}
\inferrule[plus\_minus\_mul\_real]{
  \op \in  \{\PLUS, \MINUS, \MUL\}\\
  \tstruct(\tenv, \vtone) \typearrow \TReal\\
  \tstruct(\tenv, \vttwo) \typearrow \TReal
}{
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TReal
}
\end{mathpar}

\begin{mathpar}
\inferrule[pow\_real\_int]{
  \tstruct(\tenv, \vtone) \typearrow \TReal\\
  \astlabel(\tstruct(\tenv, \vttwo)) \typearrow \TInt
}{
  \CheckBinop(\tenv, \POW, \vtone, \vttwo) \typearrow \TReal
}
\end{mathpar}

\begin{mathpar}
\inferrule[rdiv]{
  \checktypesat(\tenv, \vtone, \TReal) \typearrow \True \OrTypeError\\
  \checktypesat(\tenv, \vttwo, \TReal) \typearrow \True \OrTypeError\\
}{
  \CheckBinop(\tenv, \RDIV, \vtone, \vttwo) \typearrow \TReal
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{
  This is related to \identr{BKNT}, \identr{ZYWY}, \identr{BZKW},
  \identr{KFYS}, \identr{KXMR}, \identr{SQXN}, \identr{MRHT}, \identr{JGWF},
  \identr{TTGQ}, \identi{YHML}, \identi{YHRP}, \identi{VMZF}, \identi{YXSY},
  \identi{LGHJ}, \identi{RXLG}.
}

\section{TypingRule.FindNamedLCA \label{sec:TypingRule.FindNamedLCA}}
\hypertarget{def-namedlowestcommonancestor}{}
The function
\[
  \namedlca(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\ty}{\tty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the lowest common named super type --- $\tty$ --- of the types $\vt$ and $\vs$ in $\tenv$.

\newcommand\supers[0]{\texttt{supers}}
The helper function
\[
  \supers(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt})
  \aslto \pow{\ty}
\]
returns the set of \emph{named supertypes} given via the $\subtypes$ function of the global environment:
\[
  \supers(\tenv, \vt) \triangleq
  \begin{cases}
    \{\vt\} \cup (\vs) & \text{ if }G^\tenv.\subtypes(\vt) = \vs\\
    \{\vt\}  & \text{ otherwise } (G^\tenv.\subtypes(\vt) = \bot)\\
  \end{cases}
\]

\subsection{Prose}
One of the following holds:
\begin{itemize}
  \item $\vtsupers$ is in the set of named supertypes of $\vt$;
  \item All of the following hold (\textsc{found}):
  \begin{itemize}
    \item $\vs$ is in $\vtsupers$;
    \item $\tty$ is $\vs$;
  \end{itemize}

  \item All of the following hold (\textsc{super}):
  \begin{itemize}
    \item $\vs$ is not in $\vtsupers$;
    \item $\vs$ has a named super type in $\tenv$ --- $\vsp$;
    \item $\tty$ is the lowest common named supertype of $\vt$ and $\vsp$ in $\tenv$.
  \end{itemize}

  \item All of the following hold (\textsc{none}):
  \begin{itemize}
    \item $\vs$ is not in $\vtsupers$;
    \item $\vs$ has no named super type in $\tenv$;
    \item $\tty$ is $\None$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[found]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \in \vtsupers
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \vs
}
\and
\inferrule[super]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \not\in \vtsupers\\
  G^\tenv.\subtypes(\vs) = \vsp\\
  \namedlca(\tenv, \vt, \vsp) \typearrow \tty
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \tty
}
\and
\inferrule[none]{
  \supers(\tenv, \vt) \typearrow \vtsupers\\
  \vs \not\in \vtsupers\\
  G^\tenv.\subtypes(\vs) = \None
}{
  \namedlca(\tenv, \vt, \vs) \typearrow \None
}
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of types \label{chap:typingoftypes}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatetype}{}
The function
\[
  \annotatetype{\overname{\Bool}{\decl} \aslsep \overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}}
  \aslto \overname{\ty}{\newty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a type $\tty$ in an environment $\tenv$, resulting in a
annotated type $\newty$.
The flag $\decl$ indicates whether $\tty$ is a type currently being declared.
The result is a type error, if one is detected.

One of the following applies:
\begin{itemize}
  \item TypingRule.TString (see \secref{TypingRule.TString});
  \item TypingRule.TReal (see \secref{TypingRule.TReal});
  \item TypingRule.TBool (see \secref{TypingRule.TBool});
  \item TypingRule.TNamed (see \secref{TypingRule.TNamed});
  \item TypingRule.TInt (see \secref{TypingRule.TInt});
  \item TypingRule.TBits (see \secref{TypingRule.TBits});
  \item TypingRule.TTuple (see \secref{TypingRule.TTuple});
  \item TypingRule.TArray (see \secref{TypingRule.TArray});
  \item TypingRule.TEnumDecl (see \secref{TypingRule.TEnumDecl});
  \item TypingRule.TRecordExceptionDecl (see
    \secref{TypingRule.TRecordExceptionDecl});
  \item TypingRule.TNonDecl (see \secref{TypingRule.TNonDecl});
\end{itemize}
A type error is returned, if one is detected.

\section{TypingRule.TString \label{sec:TypingRule.TString}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the string type \TString.
  \item $\newty$ is the string type \TString.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{string} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TString.asl}

\CodeSubsection{\TStringBegin}{\TStringEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\Ignore, \tenv, \TString} \typearrow \TString
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TReal \label{sec:TypingRule.TReal}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the real type \TReal.
  \item $\newty$ is the real type \TReal.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{real} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TReal.asl}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\Ignore, \tenv, \TReal} \typearrow \TReal
}
\end{mathpar}
\end{emptyformal}

\CodeSubsection{\TRealBegin}{\TRealEnd}{../Typing.ml}

\isempty{\subsection{Comments}}

\section{TypingRule.TBool \label{sec:TypingRule.TBool}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the boolean type, \TBool;
  \item $\newty$ is the boolean type, \TBool.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{boolean} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBool.asl}

\CodeSubsection{\TBoolBegin}{\TBoolEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\Ignore, \tenv, \TBool} \typearrow \TBool
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TNamed \label{sec:TypingRule.TNamed}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the named type $\vx$, that is $\TNamed(\vx)$;
  \item retrieving the type associated with $\vx$ from the static environment $\tenv$ \\ (via $\declaredtype$) yields $\vt$\ProseOrTypeError;
  \item $\newty$ is $\tty$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{MyType} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TNamed.asl}

\CodeSubsection{\TNamedBegin}{\TNamedEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \declaredtype(\tenv, \vx) \typearrow \vt \OrTypeError
}{
  \annotatetype{\Ignore, \tenv, \TNamed(\vx)} \typearrow \TNamed(\vx)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TInt \label{sec:TypingRule.TInt}}

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item $\tty$ is the unconstrained integer type;
      \item $\newty$ is the unconstrained integer type.
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item $\tty$ is a under-constrained integer type;
      \item $\newty$ is the under-constrained integer type $\tty$.
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item $\tty$ is the well-constrained integer type constrained by
        constraints $\vc_i$, for $u=1..k$;
      \item annotating each constraint $\vc_i$, for $i=1..k$,
      yields $\newc_i$\ProseOrTypeError;
      \item $\newconstraints$ is the list of annotated constraints $\newc_i$,
      for $i=1..k$;
      \item $\newty$ is the well-constrained integer type constrained
        by $\newconstraints$.
    \end{itemize}
\end{itemize}

\subsection{Example}

In the following examples, all the uses of integer types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntUnConstrained.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntWellConstrained.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntUnderConstrained.asl}

\CodeSubsection{\TIntBegin}{\TIntEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[unconstrained]{
  \tty \eqname \TInt(\unconstrained)\\
}{
  \annotatetype{\Ignore, \tenv, \tty} \typearrow \tty
}
\and
\inferrule[underconstrained]{
  \tty \eqname \TInt(\underconstrained(\Ignore))\\
}{
  \annotatetype{\Ignore, \tenv, \tty} \typearrow \tty
}
\and
\inferrule[well\_constrained]{
  \constraints \eqname \vc_{1..k}\\
  i=1..k: \tododefine{annotate\_constraint}(\vc_i) \typearrow\newc_i \OrTypeError\\\\
  \newconstraints \eqdef \newc_{1..k}
}{
  \annotatetype{\Ignore, \tenv, \TInt(\wellconstrained(\constraints))} \typearrow \\ \TInt(\wellconstrained(\newconstraints))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TBits \label{sec:TypingRule.TBits}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the bit-vector type with width given by the expression
    $\ewidth$ and the bitfields given by $\bitfields$, that is, $\TBits(\ewidth, \bitfields)$;
  \item annotating the \staticallyevaluable\  integer expression $\ewidth$ yields $\ewidthp$\ProseOrTypeError;
  \item annotating the bitfields $\bitfields$ yields $\bitfieldsp$\ProseOrTypeError;
  \item $\newty$ is the bit-vector type with width given by the expression
    $\ewidthp$ and the bitfields given by $\bitfieldsp$, that is, $\TBits(\ewidthp, \bitfieldsp)$
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBits.asl}

In the following example, all the uses of bitvector types are valid:
\CodeSubsection{\TBitsBegin}{\TBitsEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatestaticconstrainedinteger(\tenv, \ewidth) \typearrow \ewidthp \OrTypeError\\
  \annotatebitfields(\tenv, \ewidthp, \bitfields) \typearrow \bitfieldsp \OrTypeError
}{
  \annotatetype{\Ignore, \tenv, \TBits(\ewidth, \bitfields)} \typearrow \TBits(\ewidthp, \bitfieldsp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TTuple \label{sec:TypingRule.TTuple}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the tuple type with member types $\tys$, that is, $\TTuple(\tys)$;
  \item $\tys$ is the list $\tty_i$, for $i=1..k$;
  \item annotating each type $\tty_i$ in $\tenv$, for $i=1..k$,
  yields $\ttyp_i$\ProseOrTypeError;
  \item $\newty$ is the tuple type with member types $\ttyp$, for $i=1..k$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of tuple types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TTuple.asl}

\CodeSubsection{\TTupleBegin}{\TTupleEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  k \geq 2\\
  \tys \eqname \tty_{1..k}\\
  i=1..k: \annotatetype{\False, \tenv, \tty_i} \typearrow \ttyp_i \OrTypeError
}{
  \annotatetype{\Ignore, \tenv, \TTuple(\tys)} \typearrow \TTuple(\tysp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TArray \label{sec:TypingRule.TArray}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the array type indexed by integer bounded by the
    expression $\ve$ and of elements of type $\vt$;
  \item Annotating the type $\vt$ in $\tenv$ yields $\vtp$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{expr\_is\_enum}):
    \begin{itemize}
      \item determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via \\ $\tododefine{get\_variable\_enum}$ yields the enumeration variable
      name $\vs$ of size $\vi$, that is, $\langle \vs, \vi \rangle$;
      \item $\newty$ is the array type indexed by an enumeration type
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$.
    \end{itemize}

    \item All of the following apply (\textsc{expr\_not\_enum}):
    \begin{itemize}
      \item determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via \\ $\tododefine{get\_variable\_enum}$ yields $\None$ (meaning it does not
      correspond to an enumeration);
      \item annotating the statically evaluable integer expression $\ve$ yields
      $\vep$\ProseOrTypeError;
      \item $\newty$ the array type indexed by integer bounded by
      the expression $\vep$ and of elements of type $\vtp$, that is,
      $\TArray(\ArrayLengthExpr(\vep), \vtp)$.
    \end{itemize}

    \item All of the following apply (\textsc{index\_enum}):
    \begin{itemize}
      \item $\ve$ is an enumeration type index with variable $\vs$ and size $\vi$,
      that is, \\ $\ArrayLengthEnum(\vs, \vi)$;
      \item let $\tty$ be the named type defined for $\vs$, that is, $\TNamed(\vs)$;
      \item determining the \underlyingtype\ of $\tty$ yields $\vt$\ProseOrTypeError;
      \item checking whether $\vt$ is an enumeration type yields $\True$\ProseOrTypeError;
      \item $\vt$ is an enumeration with labels $\vli$;
      \item checking whether $\vli$ has the same length as $\vi$ yields $\True$\ProseOrTypeError;
      \item $\newty$ is the array type indexed by an enumeration type
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following example, all the uses of array types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TArray.asl}

\CodeSubsection{\TArrayBegin}{\TArrayEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[expr\_is\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \tododefine{get\_variable\_enum}(\tenv, \ve) \typearrow \langle \vs, \vi \rangle
}{
  \annotatetype{\Ignore, \tenv, \TArray(\ArrayLengthExpr(\ve), \vt)} \typearrow \TArray(\ArrayLengthEnum(\vs, \vi), \vtp)
}
\and
\inferrule[expr\_not\_enum]{
  \annotatetype{\tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \tododefine{get\_variable\_enum}(\tenv, \ve) \typearrow \None\\
  \tododefine{annotate\_static\_integer}(\tenv, \ve) \typearrow \vep \OrTypeError
}{
  \annotatetype{\Ignore, \tenv, \TArray(\ArrayLengthExpr(\ve), \vt)} \typearrow \TArray(\ArrayLengthExpr(\vep), \vtp)
}
\and
\inferrule[index\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \tsubs \eqdef \TNamed(\vs)\\
  \makeanonymous(\tenv, \tsubs) \typearrow \vt \OrTypeError\\\\
  \checktrans{\astlabel(\vt) = \TEnum}{ExpectedEnumeration} \checktransarrow \True \OrTypeError\\\\
  \vt \eqname \TEnum((\vli))\\
  \checktrans{\equallength(\vli, \vi)}{TypeConflict} \checktransarrow \True \OrTypeError
}{
  \annotatetype{\Ignore, \tenv, \TArray(\ArrayLengthEnum(\vs, \vi), \vt)} \typearrow \\
  \TArray(\ArrayLengthEnum(\vs, \vi), \vtp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TEnumDecl \label{sec:TypingRule.TEnumDecl}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the enumeration type with enumeration literals
    $\vli$, that is, $\TEnum(\vli)$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item determining that $\vli$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item determining that none of the labels in $\vli$ is declared in the global environment
  yields $\True$\ProseOrTypeError;
  \item $\newty$ is the enumeration type $\tty$.
\end{itemize}

\subsection{Example}
The following example declares a valid enumeration type:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TEnumDecl.asl}

\CodeSubsection{\TEnumDeclBegin}{\TEnumDeclEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checknoduplicates(\vli) \typearrow \True \OrTypeError\\
  \vl \in \vli: \checkvarnotingenv{\tenv, \vl} \typearrow \True \OrTypeError
}{
  \annotatetype{\True, \tenv, \TEnum(\vli)} \typearrow \TEnum(\vli)
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{YZBQ}, \identr{DWSP}, \identi{MZXL}.}

\section{TypingRule.TRecordExceptionDecl \label{sec:TypingRule.TRecordExceptionDecl}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is either a record type or an exception type, corresponding to its AST label $L$;
  \item the list of fields of $\tty$ is $\fields$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item $\fields$ is a list of pairs where the first element is an identifier and the second is a type --- $(\vx_i, \vt_i)$, for $i=1..k$;
  \item checking that the list of field identifiers $\vx_{1..k}$ does not contain duplicates
  yields $\True$\ProseOrTypeError;
  \item annotating each field type $\vt_i$, for $i=1..k$, yields an annotated type $\vtp_i$
 \ProseOrTypeError;
  \item $\fieldsp$ is the list with $(\vx_i, \vtp_i)$, for $i=1..k$;
  \item $\newty$ is the AST node with AST label $L$ (either record type or exception type,
  corresponding to the type $\tty$) and fields $\fieldsp$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of record or exception types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TRecordExceptionDecl.asl}

\CodeSubsection{\TRecordExceptionDeclBegin}{\TRecordExceptionDeclEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \fields \eqname [i=1..k: (\vx_i, \vt_i)]\\
  \checknoduplicates(\vx_{1..k}) \typearrow \True \OrTypeError\\
  i=1..k: \annotatetype{\False, \tenv, \vt_i} \typearrow \vtp_i \OrTypeError\\
  \fieldsp \eqdef [i=1..k: (\vx_i, \vtp_i)]
}{
  \annotatetype{\True, \tenv, L(\fields)} \typearrow L(\fieldsp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.TNonDecl \label{sec:TypingRule.TNonDecl}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is either a record type, an exception type, or an enumeration type;
  \item $\decl$ is $\False$, indicating that $\tty$ should be considered to be outside the context of a declaration
  of $\tty$;
  \item a type error is returned, indicating that the use of anonymous form of enumerations, record,
  and exceptions types is not allowed here.
\end{itemize}

\subsection{Example}

In the following example, the use of a record type outside of a declaration is erroneous:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TNonDecl.asl}

\CodeSubsection{\TNonDeclBegin}{\TNonDeclEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \astlabel(\tty) \in \{\TEnum, \TRecord, \TException\}
}{
  \annotatetype{\False, \tenv, \tty} \typearrow \TypeErrorVal{AnnonymousFormNotAllowedHere}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Bitfields}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We define rules for annotating a single bitfield and a list of bitfields:
\begin{itemize}
  \item TypingRule.TBitField (see \secref{TypingRule.TBitField});
  \item TypingRule.TBitFields (see \secref{TypingRule.TBitFields});
\end{itemize}

\section{TypingRule.TBitField \label{sec:TypingRule.TBitField}}
\hypertarget{def-annotatebitfield}{}
The function
\[
  \annotatebitfield(\overname{\staticenvs}{\tenv} \aslsep \overname{\Z}{\width} \aslsep \overname{\bitfield}{\field})
  \aslto \overname{\bitfield}{\newfield} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a bitfield --- $\field$ --- with an integer --- $\width$ --- indicating the number of bits in
the bitvector type that contains $\field$,
in an environment $\tenv$, resulting in an
annotated bitfield --- $\newfield$ --- or a type error, if one is detected.

\subsection{Prose}
\begin{itemize}
  \item Annotating the slices $\slices$ yields $\slicesone$\ProseOrTypeError;
  One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{simple}):
    \begin{itemize}
      \item checking whether the range of positions in $\slicesone$ fit inside $0..\width$ yields $\True$\ProseOrTypeError;
      \item $\newfield$ is a bitfield named $\name$ with list of slices $\slicesone$, that is, $\BitFieldSimple(\name, \sliceone)$.
    \end{itemize}

    \item All of the following apply (\textsc{nested}):
    \begin{itemize}
      \item converting the $\slicesone$ into a list of positions with $\width$ and static environment $\tenv$
      yields $\positions$\ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields \\
            $\True$\ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item annotating the bitfields $\bitfieldsp$ with $\widthp$ in static environment $\tenv$ yields $\bitfieldspp$\ProseOrTypeError;
      \item $\newfields$ is the nested bitfield with $\slicesone$ and bitfields $\bitfieldspp$, that is, $\BitFieldNested(\slicesone, \bitfieldspp)$.
    \end{itemize}

    \item All of the following apply (\textsc{type}):
    \begin{itemize}
      \item Annotating the type $\vt$ yields $\vtp$\ProseOrTypeError;
      \item checking whether the range of positions in $\slicesone$ fit inside $0..\width$ yields $\True$\ProseOrTypeError;
      \item converting the list of slices $\slicesone$ into a list of positions in $\tenv$ yields $\positions$\ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields $\True$\ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item checking whether the $\vt$ and the bitvector with $\widthp$ bits have the same width yields $\True$\ProseOrTypeError
      \item $\newfield$ is the typed-bitfield with name $\name$, list of slices $\slicesone$ and type $\vtp$, that is, \BitFieldType(\name, \slicesone, \vtp).
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following example, all the uses of bitvector types with bitfields are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBitField.asl}

\CodeSubsection{\TBitFieldBegin}{\TBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[simple]{
  \annotateslices(\tenv, \slices) \typearrow \slicesone \OrTypeError\\
  \tododefine{check\_slices\_in\_width}(\tenv, \width, \slicesone) \typearrow \True \OrTypeError
}{
  \annotatebitfield(\tenv, \width, \BitFieldSimple(\name, \slices)) \typearrow \\
  \BitFieldSimple(\name, \sliceone)
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested]{
  \annotateslices(\tenv, \slices) \typearrow \slicesone \OrTypeError\\
  \tododefine{disjoint\_slices\_to\_positions}(\tenv, \width, \slicesone) \typearrow \positions \OrTypeError\\\\
  \tododefine{check\_positions\_in\_width}(\tenv, \width, \positions) \typearrow \True \OrTypeError\\
  \widthp \eqdef \listlen{\positions}\\
  \annotatebitfields(\tenv, \widthp, \bitfieldsp) \typearrow \bitfieldspp \OrTypeError\\
}{
  \annotatebitfield(\tenv, \width, \BitFieldNested(\name, \slices, \bitfieldsp)) \typearrow \\
  \BitFieldNested(\slicesone, \bitfieldspp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[type]{
  \annotateslices(\tenv, \slices) \typearrow \slicesone \OrTypeError\\
  \annotatetype{\tenv, \vt} \typearrow \vtp \OrTypeError\\
  \tododefine{check\_slices\_in\_width}(\tenv, \width, \slicesone) \typearrow \True \OrTypeError\\
  \tododefine{disjoint\_slices\_to\_positions}(\tenv, \slicesone) \typearrow \positions \OrTypeError\\\\
  \tododefine{check\_positions\_in\_width}(\tenv, \slicesone, \width, \positions) \typearrow \True \OrTypeError\\
  \widthp \eqdef \listlen{\positions}\\
  \checkbitsequalwidth(\TBits(\widthp, \emptylist), \vt) \typearrow \True \OrTypeError
}{
  \annotatebitfield(\tenv, \width, \BitFieldType(\name, \slices, \vt)) \typearrow \\
  \BitFieldType(\name, \slicesone, \vtp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TBitFields \label{sec:TypingRule.TBitFields}}
\hypertarget{def-annotatebitfields}{}
The function
\[
  \annotatebitfields(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ewidth} \aslsep \overname{\bitfields}{\fields})
  \aslto \overname{\bitfields}{\newfields} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of bitfields --- $\fields$ --- with an expression denoting the overall number of bits in the containing
bitvector type --- $\ewidth$,
in an environment $\tenv$, resulting in an
annotated list of bitfields --- $\newfields$ or a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that the list of bitfield names in $\bitfields$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item symbolically simplifying $\ewidth$ in $\tenv$ via $\reduceconstants$ yields the literal integer for $\width$\ProseOrTypeError;
  \item annotating each bitfield $\field$ in $\fields$ with width $\width$ in $\tenv$ yields the corresponding annotated
  bitfield $\newfield$\ProseOrTypeError;
  \item $\newfields$ is the list of annotated bitfields.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\TBitFieldsBegin}{\TBitFieldsEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \names \eqdef [\field\in\fields: \bitfieldgetname(\field)]\\
  \checknoduplicates(\names) \typearrow \True \OrTypeError\\
  \reduceconstants(\tenv, \ewidth) \typearrow \lint(\width) \OrTypeError\\\\
  \field\in\fields: \annotatebitfield(\tenv, \width, \field) \typearrow \newfield \OrTypeError\\
  \newfields \eqdef [\field\in\fields: \newfield]
}{
  \annotatebitfields(\tenv, \ewidth, \fields) \typearrow \newfields
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotateexpr}{}
The function
\[
  \annotateexpr{\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}}
  \aslto (\overname{\ty}{\vt} \times \overname{\expr}{\newe})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
specifies how to annotate an expression $\ve$ in
an environment \tenv.  Formally, the result of annotating the expression
$\ve$ in \tenv\ is either the pair $(\vt, \newe)$, where $\vt$ is a type and
$\newe$ is an annotated expression, or a type error, and one of the following applies:
\begin{itemize}
\item TypingRule.ELit (see \secref{TypingRule.ELit});
\item TypingRule.ELocalVarConstant (see \secref{TypingRule.ELocalVarConstant})
\item TypingRule.ELocalVar (see \secref{TypingRule.ELocalVar})
\item TypingRule.EGlobalVarConstant (see \secref{TypingRule.EGlobalVarConstant})
\item TypingRule.EGlobalVarConstantNoVal (see \secref{TypingRule.EGlobalVarConstantNoVal})
\item TypingRule.EGlobalVar (see \secref{TypingRule.EGlobalVar})
\item TypingRule.EUndefIdent (see \secref{TypingRule.EUndefIdent})
\item TypingRule.Binop (see \secref{TypingRule.Binop})
\item TypingRule.Unop (see \secref{TypingRule.Unop})
\item TypingRule.ECond (see \secref{TypingRule.ECond})
\item TypingRule.ESlice (see \secref{TypingRule.ESlice})
\item TypingRule.ESetter (see \secref{TypingRule.ESetter})
\item TypingRule.ECall (see \secref{TypingRule.ECall})
\item TypingRule.EGetArray (see \secref{TypingRule.EGetArray})
\item TypingRule.ESliceOrEGetArrayError (see \secref{TypingRule.ESliceOrEGetArrayError})
\item TypingRule.EStructuredNotStructured (see \secref{TypingRule.EStructuredNotStructured})
\item TypingRule.EStructuredMissingField (see \secref{TypingRule.EStructuredMissingField})
\item TypingRule.ERecord (see \secref{TypingRule.ERecord})
\item TypingRule.EGetRecordField (see \secref{TypingRule.EGetRecordField})
\item TypingRule.EGetBadRecordField (see \secref{TypingRule.EGetBadRecordField})
\item TypingRule.EGetBadBitField (see \secref{TypingRule.EGetBadBitField})
\item TypingRule.EGetBitField (see \secref{TypingRule.EGetBitField})
\item TypingRule.EGetBitFieldNested (see \secref{TypingRule.EGetBitFieldNested})
\item TypingRule.EGetBitFieldTyped (see \secref{TypingRule.EGetBitFieldTyped})
\item TypingRule.EGetTupleItem (see \secref{TypingRule.EGetTupleItem})
\item TypingRule.EGetBadField (see \secref{TypingRule.EGetBadField})
\item TypingRule.EConcat (see \secref{TypingRule.EConcat})
\item TypingRule.ETuple (see \secref{TypingRule.ETuple})
\item TypingRule.EUnknown (see \secref{TypingRule.EUnknown})
\item TypingRule.EPattern (see \secref{TypingRule.EPattern})
\item TypingRule.ATC (see \secref{TypingRule.ATC})
\end{itemize}

The annotation rewrites the input expression in the following cases, making the annotation of statements simpler:
\begin{itemize}
  \item Variables with constant values are substituted by their constant values.
  \item Slicing expressions that correspond to calling a getter are replaced with respective call expressions.
  \item Slicing expressions that correspond to array accesses are replaced with array access expressions.
\end{itemize}

We also define the following helper rules:
\begin{itemize}
  \item TypingRule.Lit (\secref{TypingRule.Lit})
  \item TypingRule.ExpressionList (\secref{TypingRule.ExpressionList})
  \item TypingRule.TypingRule.ReduceSlicesToCall (\secref{TypingRule.ReduceSlicesToCall})
  \item TypingRule.StaticConstrainedInteger (\secref{TypingRule.StaticConstrainedInteger})
\end{itemize}

\section{TypingRule.ELit \label{sec:TypingRule.ELit}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ is the literal expression $\vv$;
\item $\vt$ is the type of the literal $\vv$;
\item $\newe$ is $\ve$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ELitBegin}{\ELitEnd}{../Typing.ml}
\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{\annotateliteral{\vv} \typearrow \vt}
{\annotateexpr{\tenv, \ELiteral(\vv)} \typearrow (\vt, \ELiteral(\vv))}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ELocalVarConstant \label{sec:TypingRule.ELocalVarConstant}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a local variable $\vx$;
\item $\vx$ is bound to a local constant $\vv$ of type $\tty$ in the local environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is the Literal $\vv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ELocalVarConstantBegin}{\ELocalVarConstantEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\constantvalues(\vx) = \vv\\
  L^\tenv.\localstoragetypes(\vx) = (\tty, \LDKConstant)
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \eliteral{\vv})}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ELocalVar \label{sec:TypingRule.ELocalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a local variable $\vx$;
\item $\vx$ is not bound to a constant in the local environment given by $\tenv$;
\item $\vx$ has type $\tty$ in the local environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is $\ve$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ELocalVarBegin}{\ELocalVarEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\constantvalues(\vx) = \bot\\
  L^\tenv.\localstoragetypes(\vx) =  (\tty, k) \\
  k \in \{\LDKVar, \LDKLet\}
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \EVar(\vx))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVarConstantVal \label{sec:TypingRule.EGlobalVarConstant}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a global variable $\vx$;
\item $\vx$ is bound to a constant $\vv$ of type $\tty$ in the global environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is the Literal $\vv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGlobalVarConstantBegin}{\EGlobalVarConstantEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \vv
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \eliteral{\vv})}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVarConstantNoVal \label{sec:TypingRule.EGlobalVarConstantNoVal}}
Our type system does not currently address assignments of non-constant expressions (for example,
function calls) to global constant variables. This section can be seen as a place holder until
the right details are filled in.

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a global variable $\vx$;
\item $\vx$ is not bound to constant in the global environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is $\ve$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGlobalVarConstantNoValBegin}{\EGlobalVarConstantNoValEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \bot
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \EVar(\vx))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVar \label{sec:TypingRule.EGlobalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a global variable $\vx$;
\item $\vx$ is not bound to a global constant;
\item $\vx$ has type $\tty$ in the global environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is $\ve$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGlobalVarBegin}{\EGlobalVarEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\constantvalues(\vx) = \bot\\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, k)\\
  k \neq \GDKConstant
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \EVar(\vx))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EUndefIdent \label{sec:TypingRule.EUndefIdent}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ is a variable $\vx$;
\item $\vx$ is not bound in $\tenv$;
\item the result is a type error indicating that $\vx$ is an undefined identifier.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EUndefIdentBegin}{\EUndefIdentEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\globalstoragetypes(\vx) = \bot\\
  L^\tenv.\globalstoragetypes(\vx) = \bot\\
}{
  \annotateexpr{\tenv, \EVar(\vx)} \typearrow \TypeErrorVal{UndefinedIdentifier}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.Binop \label{sec:TypingRule.Binop}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a binary operation $\op$ over two expressions $\veone$ and $\vetwo$, that is, \\ $\EBinop(\op, \veone, \vetwo)$;
  \item the result of annotating $\veone$ in $\tenv$ is $(\vtone, \veonep)$\ProseOrTypeError;
  \item the result of annotating $\vetwo$ in $\tenv$ is $(\vttwo, \vetwop)$\ProseOrTypeError;
  \item the result of checking compatibility of $\op$ with $\vtone$ and $\vttwo$ as per \secref{TypingRule.CheckBinop}
  is $\vt$\ProseOrTypeError;
  \item $\newenv$ denotes $\op$ over $\veonep$ and $\vetwop$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\BinopBegin}{\BinopEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veone') \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwo') \OrTypeError\\\\
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\tenv, \EBinop(\op, \veone, \vetwo)} \typearrow (\vt, \EBinop(\op, \veone', \vetwo'))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.Unop \label{sec:TypingRule.Unop}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a unary operation $\op$ over an expression $\vep$, that is $\EUnop(\op, \vep)$;
  \item annotating $\vep$ in $\tenv$ yields $(\vtpp, \vepp)$\ProseOrTypeError;
  \item checking compatibility of $\op$ with $\vtpp$ as per \secref{TypingRule.CheckUnop} yields $\vt$\ProseOrTypeError;
  \item $\newe$ denotes $\op$ over $\vepp$, that is, $\EUnop(\op, \vepp)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\UnopBegin}{\UnopEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vtpp, \vepp) \OrTypeError\\
  \CheckUnop(\tenv, \op, \vtpp) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\tenv, \EUnop(\op, \vep)} \typearrow (\vt, \EUnop(\op, \vepp))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ECond \label{sec:TypingRule.ECond}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a conditional expression with condition $\econd$ with two options $\etrue$ and $\efalse$;
  \item annotating $\econd$ in $\tenv$ results in $(\tcond, \econdp)$\ProseOrTypeError;
  \item annotating $\etrue$ in $\tenv$ results in $(\ttrue, \etruep)$\ProseOrTypeError;
  \item annotating $\efalse$ in $\tenv$ results in $(\tfalse, \efalsep)$;
  \item obtaining the lowest common ancestor of $\ttrue$ and $\tfalse$ results in $\vt$\ProseOrTypeError;
  \item $\newe$ is the condition $\econdp$ with two options $\etruep$ and $\efalsep$, that is, $\ECond(\econdp, \etruep, \efalsep)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ECondBegin}{\ECondEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \econd} \typearrow (\tcond, \econd') \OrTypeError\\
  \annotateexpr{\tenv, \etrue} \typearrow (\ttrue, \etrue') \OrTypeError\\
  \annotateexpr{\tenv, \efalse} \typearrow (\tfalse, \efalse') \OrTypeError\\
  \lca(\ttrue, \tfalse) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\ECond(\econd, \etrue, \efalse)} \typearrow (\vt, \ECond(\econdp, \etruep, \efalsep))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{XZVT}.}

\section{TypingRule.ESlice \label{sec:TypingRule.ESlice}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
  $\ESlice(\vep, \slices)$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a negative answer --- $\None$\ProseOrTypeError;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\tep,\vepp)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\structtep$\ProseOrTypeError;
  \item $\structtep$ is either a bitvector or an integer;
  \item obtaining the width of $\slices$ in $\tenv$ via $\sliceswidth$ yields $\vw$\ProseOrTypeError;
  \item $\slicesp$ is the result of annotating $\slices$ in $\tenv$;
  \item $\vt$ is the bitvector type of width $\vw$, that is, $\TBits(\vw, \emptylist)$;
  \item $\newe$ is the slicing of expression $\vepp$ by the slices $\slicesp$, that is, \\
  $\ESlice(\vepp, \slicesp)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ESliceBegin}{\ESliceEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \vep} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \structtep \OrTypeError\\\\
  \astlabel(\structtep) \in \{\TInt, \TBits\}\\
  \sliceswidth(\tenv, \slices) \typearrow \vw \OrTypeError\\\\
  \annotateslices(\tenv, \slices) \typearrow \slicesp \OrTypeError
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow (\TBits(\vw, \emptylist), \ESlice(\vepp, \slicesp))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  The width of \slices\ might be a symbolic expression if one of the
  widths references a \texttt{let} identifier with a non-compile-time-constant
  initialiser expression.

  \lrmcomment{This is related to \identi{MJWM}.}

\section{TypingRule.ESetter \label{sec:TypingRule.ESetter}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
  $\ESlice(\vep, \slices)$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a positive answer --- $\langle (\name, \vargs)\rangle$\ProseOrTypeError;
  \item annotating a call with $(\tenv, \name, \vargs, \emptylist, \STSetter)$
  (that is, an empty list of parameters) yields $(\nameone, \vargsone, \eqs, \langle\tty\rangle)$\ProseOrTypeError;
  \item $vt$ is $\tty$;
  \item $\newe$ is the call expression $\ECall(\nameone, \vargsone, \eqs)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ESetterBegin}{\ESetterEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \langle(\name, \vargs)\rangle \OrTypeError\\\\
  \annotatecall{\tenv, \name, \vargs, \STSetter} \typearrow (\nameone, \vargsone, \eqs, \langle\tty\rangle) \OrTypeError\\
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow (\tty, \ECall(\nameone, \vargsone, \eqs))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}

\section{TypingRule.ECall \label{sec:TypingRule.ECall}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a call to a subprogram named $\name$ with arguments $\vargs$, that is, \\ $\ECall(\name, \vargs)$;
  \item annotating the call of that subprogram in $\tenv$ (annotating calls is defined in Chapter~\ref{chap:TypingSubprogramCalls})
  yields $(\namep, \vargsp, \eqsp, \langle \vt \rangle)$\ProseOrTypeError;
  \item $\newe$ is the call to the subprogram named $\namep$ with arguments $\vargsp$
    and parameters $\eqsp$, that is, $\ECall(\name, \vargsp, \eqsp)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ECallBegin}{\ECallEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatecall{\tenv, \name, \vargs, \STFunction} \typearrow (\namep, \vargsp, \eqsp, \langle \vt \rangle) \OrTypeError
}{
  \annotateexpr{\tenv, \ECall(\name, \vargs)} \typearrow (\vt, \ECall(\name, \vargsp, \eqsp))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{CFYP}, \identr{BQJG}.}

\section{TypingRule.EGetArray \label{sec:TypingRule.EGetArray}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a negative answer --- $\None$\ProseOrTypeError;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure of an array with index $\size$ and element type $\tty$';
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{okay}):
    \begin{itemize}
      \item $\slices$ consists of a single slice $\SliceSingle(\eindex)$;
      \item annotating the expression $\eindex$ in $\tenv$ yields $(\tindexp, \eindexp)$\ProseOrTypeError;
      \item determining the type of the array index for $\size$ in $\tenv$ via \\ $\typeofarraylength$
      yields $\wantedtindex$;
      \item determining whether $\tindexp$ \typesatisfies\ $\wantedtindex$ yields $\True$\ProseOrTypeError;
      \item $\vt$ is $\ttyp$;
      \item $\newe$ is the array access expression for $\vepp$ and index $\eindexp$, that is, $\EGetArray(\vepp, \eindexp)$.
    \end{itemize}

    \item All of the following apply (\textsc{error}):
    \begin{itemize}
      \item $\slices$ consists of a single slice $\SliceSingle(\eindex)$;
      \item the result is a type error indicating that an array must be accessed with a slice corresponding to a single index
      expression.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGetArrayBegin}{\EGetArrayEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \ve} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \TArray(\size, \ttyp) \OrTypeError\\\\
  \slices = [ \SliceSingle(\eindex) ]\\
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp) \OrTypeError\\
  \typeofarraylength(\tenv, \size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow (\ttyp, \EGetArray(\vepp, \eindexp))
}
\and
\inferrule[error]{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \ve} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \TArray(\size, \ttyp) \OrTypeError\\\\
  \slices \neq [ \SliceSingle(\Ignore) ]\\
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow \TypeErrorVal{IllegalArraySlice}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ESliceOrEGetArrayError \label{sec:TypingRule.ESliceOrEGetArrayError}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a negative answer --- $\None$\ProseOrTypeError;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure $\vtp$;
  \item $\vtp$ is neither an integer type, a bitvector type, or an array type;
  \item the result is an error indicating that the type of $\vep$ is inappropriate for slicing.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ESliceOrEGetArrayErrorBegin}{\ESliceOrEGetArrayErrorEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \ve} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \vtp\\
  \astlabel(\vtp) \not\in \{\TInt, \TBits, \TArray\}
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow \TypeErrorVal{IllegalSliceType}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EStructuredNotStructured \label{sec:TypingRule.EStructuredNotStructured}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes the record expression or an exception expression of type $\tty$ with fields $\fields$;
\item determining whether $\tty$ is a named type yields $\True$\ProseOrTypeError;
\item determining the \structure\ of $\tty$ yields $\vtp$\ProseOrTypeError;
\item $\vtp$ is neither a record nor an exception type;
\item the result is an error indicating that $\tty$ is not appropriate for constructing a record.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EStructuredNotStructuredBegin}{\EStructuredNotStructuredEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed}{NamedTypeExpected} \checktransarrow \True \OrTypeError\\
  \tstruct{\tenv, \tty} \typearrow\vtp \OrTypeError\\\\
  \astlabel(\vtp) \not\in \{\TRecord, \TException\}
}
{
  \annotateexpr{\tenv, \ERecord(\tty, \fields)} \typearrow \TypeErrorVal{NonStructuredType}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{WBCQ}.}

\section{TypingRule.EStructuredMissingField \label{sec:TypingRule.EStructuredMissingField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the record expression or an exception expression of type $\tty$ with fields $\fields$;
  \item $\tty$ is the name of a record or exception type with fields $\fieldtypes$;
  \item there exists a field in $\fieldtypes$ that is not initialised by $\fields$;
  \item the result is an error indicating that a field is missing initialization.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EStructuredMissingFieldBegin}{\EStructuredMissingFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed}{NamedTypeExpected} \checktransarrow \True \OrTypeError\\
  \tstruct(\tenv, \tty) \typearrow L(\fieldtypes) \OrTypeError\\\\
  L \in \{\TRecord, \TException\}\\
  \initializedfields \eqdef \{\name \;|\; (\name, \Ignore)\in\fields\}\\
  \names \eqdef \fieldnames(\fieldtypes)\\
  \vb \eqdef \initializedfields = \names\\
  \vb = \False
}
{
  \annotateexpr{\tenv, \ERecord(\tty, \fields)} \typearrow \TypeErrorVal{MissingField}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{WBCQ}.}

\section{TypingRule.ERecord \label{sec:TypingRule.ERecord}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the record creation expression (which is also used for creating exceptions) of type $\tty$ with fields $\fields$;
  \item $\tty$ is the name of a record or exception type with fields $\fieldtypes$;
  \item \underline{every} field in $\fieldtypes$ is initialised by a corresponding expression in $\fields$;
  \item annotating the expressions that initialize each of the fields in $\fields$ via \\
        $\annotatefieldinit$ yields $\fieldsp$\ProseOrTypeError;
  \item $\vt$ is $\tty$;
  \item $\newe$ is the record expression with type $\tty$ and field initializers $\fieldsp$, that is, $\ERecord(\tty, \fieldsp)$;
\end{itemize}

\subsection{Example}

\CodeSubsection{\ERecordBegin}{\ERecordEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed}{NamedTypeExpected} \checktransarrow \True \OrTypeError\\
  \tstruct(\tenv, \tty) \typearrow L(\fieldtypes) \OrTypeError\\\\
  L \in \{\TRecord, \TException\}\\
  \initializedfields \eqdef \{\name \;|\; (\name, \Ignore)\in\fields\}\\
  \names \eqdef \fieldnames(\fieldtypes)\\
  \initializedfields = \names\\
  (\name, \vep) \in \fields: \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow (\name, \vepp) \OrTypeError\\
  \fieldsp \eqdef [(\name, \vep) \in \fields : (\name, \vepp)]
}{
  \annotateexpr{\tenv, \ERecord(\tty, \fields)} \typearrow (\tty, \ERecord(\tty, \fieldsp))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{WBCQ}.}

\section{TypingRule.EGetRecordField \label{sec:TypingRule.EGetRecordField}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is either a record type or an exception type with fields $\fields$;
  \item the field $\fieldname$ is associated with the type $\vt$ in $\fields$
  \item $\newe$ is the access of field $\fieldname$ on the record or exception object $\vetwo$, that is, $\EGetField(\vetwo, \fieldname)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGetRecordFieldBegin}{\EGetRecordFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\
  \vtetwo \eqname L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \langle \vt\rangle
}{
  \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow (\vt, \EGetField(\vetwo, \fieldname))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadRecordField \label{sec:TypingRule.EGetBadRecordField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is either a record type or an exception type with fields $\fields$;
  \item the field $\fieldname$ is not associated with any type in $\fields$
  \item the result is a type error indicating the missing field.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGetBadRecordFieldBegin}{\EGetBadRecordFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\
  \vtetwo \eqname L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow \TypeErrorVal{FieldDoesNotExist}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadBitField \label{sec:TypingRule.EGetBadBitField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item the field $\fieldname$ is not found in $\bitfields$
  \item the result is a type error indicating the missing field.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGetBadBitFieldBegin}{\EGetBadBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \tododefine{find\_bitfield}(\bitfields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \ve} \typearrow \TypeErrorVal{FieldDoesNotExist}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.EGetBitField \label{sec:TypingRule.EGetBitField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$, that is, \\ $\BitFieldSimple(\Ignore, \slices)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vt, \newe)$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGetBitFieldBegin}{\EGetBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \tododefine{find\_bitfield}(\bitfields, \fieldname) \typearrow \langle \BitFieldSimple(\Ignore, \slices)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vt, \newe) \OrTypeError
}{
  \annotateexpr{\tenv, \ve} \typearrow \typearrow (\vt, \newe)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldNested \label{sec:TypingRule.EGetBitFieldNested}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and nested bitfields $\bitfieldsp$, that is,
        $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe)$\ProseOrTypeError;
  \item $\vtefour$ is a bitvector type with length expression $\width$, that is, $\TBits(\width, \Ignore)$;
  \item $\vt$ is a bitvector type with length expression $\width$ and bitfields $\bitfieldsp$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGetBitFieldNestedBegin}{\EGetBitFieldNestedEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \tododefine{find\_bitfield}(\bitfields, \fieldname) \typearrow \langle \BitFieldNested(\Ignore, \slices, \bitfieldsp)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe) \OrTypeError\\\\
  \vtefour \eqname \TBits(\width, \Ignore)\\
  \vt \eqdef \TBits(\width, \bitfieldsp)
}{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \newe)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldTyped \label{sec:TypingRule.EGetBitFieldTyped}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and typed-bitfield with type $vt$ that is,
        $\BitFieldType(\Ignore, \slices, \vt)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe)$\ProseOrTypeError;
  \item determining whether $\vtefour$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGetBitFieldTypedBegin}{\EGetBitFieldTypedEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \tododefine{find\_bitfield}(\bitfields, \fieldname) \typearrow \langle \BitFieldType(\Ignore, \slices, \vt)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe) \OrTypeError\\\\
  \checktypesat(\tenv, \vtefour, \vt) \typearrow \True \OrTypeError
}{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \newe)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetTupleItem \label{sec:TypingRule.EGetTupleItem}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is tuple type with list of types $\tys$, that is, $\TTuple(\tys)$;
  \item $\fieldname$ is an identifier with the prefix \texttt{item} and the constant $\vindex$;
  \item determining whether $\vindex$ is between $0$ and the number of types in $\tys$, inclusive, yields $\True$\ProseOrTypeError;
  \item $\vt$ is the type at position $\vindex$ of $\tys$;
  \item $\newe$ is the expression for obtaining the item at index $\vindex$ from the expression $\vetwo$, that is, $\EGetItem(\vetwo, \vindex)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGetTupleItemBegin}{\EGetTupleItemEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \vtetwo \eqname \TTuple(\tys)\\
  \fieldname \eqname \texttt{"item<index>"}\\
  \checktrans{0 \leq \vindex \leq \listlen{\tys}}{IndexOutOfRange} \checktransarrow \True \OrTypeError\\\\
  \vt \eqdef \tys[\vindex]\\
  \newe \eqdef \EGetItem(\vetwo, \vindex)
}{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \newe)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadField \label{sec:TypingRule.EGetBadField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  % \item checking whether the field access with expression $\vtetwo$ and $\fieldname$ represents a call yields $\None$\ProseOrTypeError;
  \item $\vtetwo$ is neither one of the following types: record, exception, bitvector, or tuple;
  \item the result is an error indicating that the type of $\veone$ is inappropriate for accessing the field $\fieldname$.
\end{itemize}

 \subsection{Example}

\CodeSubsection{\EGetBadFieldBegin}{\EGetBadFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ve \eqname \EGetField(\veone, \fieldname)\\
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\
  % \tododefine{reduce\_field\_to\_call}(\tenv, \vtetwo, \fieldname) \typearrow \None \OrTypeError\\\\
  \astlabel(\vtetwo) \not\in \{\TRecord, \TException, \TBits, \TTuple\}
}{
  \annotateexpr{\tenv, \ve} \typearrow \TypeErrorVal{ConflictingTypes}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EConcat \label{sec:TypingRule.EConcat}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the concatenation of a non-empty list of expressions $\vli$, that is, \\ $\EConcat(\vli)$;
  \item annotating each expression $\vle[i]$ in $\tenv$, for $i=1..k$, yields $(\vt_i, \ve_i$)\ProseOrTypeError;
  \item $\ves$ is the list of expressions $\ve_i$, for $i=1..k$;
  \item obtaining the bitvector width of $\vt_i$ in $\tenv$ (which also checks that $\vt_i$ is a bitvector type),
        for $i=1..k$, yields $\vw_i$\ProseOrTypeError;
  \item to obtain the (symbolic) width of the resulting bitvector, first define $\widthsum_1$ to be $\vw_1$;
  \item then define $\widthsum_i$, for $i=2..k$, to be obtained by reducing the expression that sums \\ $\widthsum_{i-1}$ with the width $\vw_i$;
  \item $\vt$ is the bitvector of length $\widthsum_k$ and the empty bitfield list, that is, \\ $\TBits(\widthsum_k, \emptylist)$;
  \item $\newe$ is the concatenation expression for $\ves$, that is, $\EConcat(\ves)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EConcatBegin}{\EConcatEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  i=1..k: \annotateexpr{\tenv, \vli[i]} \typearrow (\vt_i, \ve_i) \OrTypeError\\\\
  \vts \eqdef [i=1..k: \vt_i]\\
  \ves \eqdef [i=1..k: \ve_i]\\
  i=1..k: \getbitvectorwidth(\tenv, \vt_i) \typearrow \vw_i \OrTypeError\\\\
  \widthsum_1 \eqdef \vw_1\\
  i=2..k: \normalize(\tenv, \EBinop(\PLUS, \widthsum_{i-1}, \vw_i)) \typearrow \widthsum_i
}{
  \annotateexpr{\tenv, \EConcat(\vli)} \typearrow (\TBits(\widthsum_k, \emptylist), \EConcat(\ves))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{NYNK} and \identr{KCZS}.}

  The sum of the widths of the bitvector types~\texttt{ts} might be a symbolic
expression that is unresolvable to an integer. For example:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.EConcatUnresolvableToInteger.asl}

\section{TypingRule.ETuple \label{sec:TypingRule.ETuple}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a tuple expression with list of expressions $\vli$, that is, $ \ETuple(\vli)$;
  \item annotating each expression $\vle[i]$ in $\tenv$, for $i=1..k$, yields $(\vt_i, \ve_i$)\ProseOrTypeError;
  \item $\vt$ is the tuple type with list of types $\vt_i$, for $i=1..k$;
  \item $\newe$ is tuple expression over list of expressions $\ve_i$, for $i=1..k$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ETupleBegin}{\ETupleEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  i=1..k: \annotateexpr{\tenv, \vle[i]} \typearrow (\vt_i, \ve_i) \OrTypeError
}{
  \annotateexpr{\tenv, \ETuple(\vli)} \typearrow (\TTuple(\vt_{1..k}), \ETuple(\ve_{1..k}))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EUnknown \label{sec:TypingRule.EUnknown}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes an expression \UNKNOWN\ of type $\tty$, that is, $\EUnknown(\tty)$;
  \item annotating the type $\tty$ in $\tenv$ yields $\ttyone$\ProseOrTypeError;
  \item obtaining the \structure\ of $\ttyone$ in $\tenv$ yields $\ttytwo$\ProseOrTypeError;
  \item $\vt$ is $\ttyone$;
  \item $\newe$ is an expression \UNKNOWN\ of type $\ttytwo$, that is, $\EUnknown(\ttytwo)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EUnknownBegin}{\EUnknownEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \tty} \typearrow \ttyone \OrTypeError\\
  \tstruct(\tenv, \ttyone) \typearrow \ttytwo \OrTypeError
}{
  \annotateexpr{\tenv, \EUnknown(\tty)} \typearrow (\ttyone, \EUnknown(\ttytwo))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EPattern \label{sec:TypingRule.EPattern}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes whether the expression $\veone$ matches the pattern $\vpat$, that is, \\ $\EPattern(\veone, \vpat)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vtetwo, \vetwo)$\ProseOrTypeError;
  \item annotating the pattern $\vttwo$ in $\tenv$ yields $\vpatp$\ProseOrTypeError;
  \item $\vt$ is $\TBool$;
  \item $\newe$ denotes whether the expression $\vetwo$ matches $\vpatp$, that is, $\EPattern(\vetwo, \vpatp)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EPatternBegin}{\EPatternEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtetwo, \vetwo) \OrTypeError\\
  \annotatepattern(\tenv, \vtetwo) \typearrow \vpatp \OrTypeError
}{
  \annotateexpr{\tenv, \EPattern(\veone, \vpat)} \typearrow (\TBool, \EPattern(\vetwo, \vpatp))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ATC \label{sec:TypingRule.ATC}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes an asserting type conversion with expression $\vep$ and type $\tty$, that is $\EATC(\vep, \tty)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vt, \vepp)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
  \item annotating the type $\tty$ in $\tenv$ yields $\tty'$\ProseOrTypeError;
  \item obtaining the \structure\ of $\tty'$ in $\tenv$ yields $\vtystruct$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
  \item All of the following apply (\textsc{type\_equal}):
  \begin{itemize}
    \item determining whether $\vtstruct$ is equivalent to $\vtystruct$ in $\tenv$ \\ yields $\True$;
    \item $\vt$ is $\tty'$ and $\newe$ is $\vepp$.
  \end{itemize}
  \item All of the following apply (\textsc{dynamic}):
    \begin{itemize}
      \item determining whether $\vtstruct$ is equivalent to $\vtystruct$ in $\tenv$ \\ yields $\False$,
      meaning that an execution-time check that the expression $\vep$ evaluates to a value in the
      dynamic domain of $\tty$ is required;
      \item both $\vtstruct$ and $\vtystruct$ are bitvector types or integer types.
      \item $\vt$ is $\vtp$ and $\newe$ is the asserting type conversion expression over $\vepp$ \\ and
      $\vtystruct$, that is, $\EATC(\vepp, \vtystruct)$.
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item determining whether $\vtstruct$ is equivalent to $\vtystruct$ in $\tenv$ \\ yields $\False$;
    \item $\vtstruct$ and $\vtystruct$ are not both bitvector types or integer types.
    \item a type error indicating the conflicting types is returned.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\ATCBegin}{\ATCEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[type\_equal]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \annotatetype{\tenv, \tty} \typearrow \tty' \OrTypeError\\
  \tstruct(\tenv, \tty') \typearrow \vtystruct \OrTypeError\\
  \typeequal(\tenv, \vtstruct, \vtystruct) \typearrow \True
}{
  \annotateexpr{\tenv, \EATC(\vep, \tty)} \typearrow (\tty', \vepp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[dynamic]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \annotatetype{\tenv, \tty} \typearrow \tty' \OrTypeError\\
  \tstruct(\tenv, \tty') \typearrow \vtystruct \OrTypeError\\
  \typeequal(\tenv, \vtstruct, \vtystruct) \typearrow \False\\
  \vb \eqdef \astlabel(\vtstruct) = \astlabel(\vtystruct) \land
  \astlabel(\vtstruct) \in \{\TBits, \TInt \}\\
  \vb \eqdef \True
}{
  \annotateexpr{\tenv, \EATC(\vep, \tty)} \typearrow (\vtp, \EATC(\vepp, \vtystruct))
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \annotatetype{\tenv, \tty} \typearrow \tty' \OrTypeError\\
  \tstruct(\tenv, \tty') \typearrow \vtystruct \OrTypeError\\
  \typeequal(\tenv, \vtstruct, \vtystruct) \typearrow \False\\
  \vb \eqdef \astlabel(\vtstruct) = \astlabel(\vtystruct) \land
  \astlabel(\vtstruct) \in \{\TBits, \TInt \}\\
  \vb = \False
}{
  \annotateexpr{\tenv, \EATC(\vep, \tty)} \typearrow \TypeErrorVal{ATC}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{
  This is related to \identr{VBLL}, \identi{KRLL}, \identg{PFRQ}, \identi{XVBG},
  \identr{GYJZ}, \identi{SZVF}, \identr{PZZJ}, \identr{YCPX}, \identi{ZLBW},
  \identi{TCST}, \identi{CGRH}, \identi{YJBB}.
}

\hypertarget{def-annotateliteral}{}
\section{TypingRule.Lit \label{sec:TypingRule.Lit}}

Annotating literals is done via the helper function
\[
  \annotateliteral{\overname{\literal}{\vl}} \aslto \overname{\ty}{\vt}
\]
which we use in this chapter for TypingRule.ELit as well as in subsequent chapters.
\subsection{Prose}
The result of annotating a literal $\vl$ is $\vt$ and one of the following applies:
\begin{itemize}
\item $\vl$ is an integer literal $\vn$ and $\vt$ is the well-constrained integer type, constraining
its set to the single value $\vn$;
\item $\vl$ is a Boolean literal and $\vt$ is the Boolean type;
\item $\vl$ is a real literal and $\vt$ is the real type;
\item $\vl$ is a string literal and $\vt$ is the string type;
\item $\vl$ is a string literal and $\vt$ is the string type;
\item $\vl$ is a bitvector literal of length $\vn$ and $\vt$ is the bitvector type of fixed width $\vn$.
\end{itemize}

\subsection{Example}
In the following example, we show several literals and their corresponding types in comments:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.Lit.asl}

\CodeSubsection{\LitBegin}{\LitEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}{\annotateliteral{\lint(n)}\typearrow \TInt(\langle[\ConstraintExact(\ELInt{n})]\rangle)}
\and
\inferrule{}{\annotateliteral{\lbool(\Ignore)}\typearrow \TBool}
\and
\inferrule{}{\annotateliteral{\lreal(\Ignore)}\typearrow \TReal}
\and
\inferrule{}{\annotateliteral{\lstring(\Ignore)}\typearrow \TString}
\and
\inferrule{
  n \eqdef \listlen{\bits}
}{
  \annotateliteral{\lbitvector(\bits)}\typearrow \TBits(\ELInt{n}, \emptylist)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ExpressionList \label{sec:TypingRule.ExpressionList}}
\hypertarget{def-annotateexprs}{}
The function
\[
  \annotateexprlist{\overname{\staticenvs}{\tenv} \aslsep \overname{\expr^*}{\exprs}}
  \aslto \overname{(\ty \times \expr)^*}{\typedexprs}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of expressions in from left to right.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\exprs$ is empty;
    \item $\typedexprs$ is empty.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\exprs$ has $\ve$ as its head expression and $\exprsone$ as its tail;
    \item annotating $\ve$ in $\tenv$ yields the pair $\typedexpr$ consisting of a type and an expression
    \ProseOrTypeError;
    \item annotating the expression list $\exprsone$ in $\tenv$ yields
    $\typedexprs$\ProseOrTypeError;
    \item $\typedexprs$ is the list with $\typedexpr$ as its head
    and $\typedexprs$ as its tail.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \annotateexprlist{\tenv, \emptylist} \typearrow \emptylist
}
\and
\inferrule[non\_empty]{
  \annotateexpr{\tenv, \ve} \typearrow \typedexpr \OrTypeError\\
  \annotateexprlist{\tenv, \exprsone} \typearrow \typedexprs \OrTypeError\\
  \typedexprs \eqdef [\typedexpr] + \typedexprsone
}
{
  \annotateexprlist{\tenv, [\ve] + \exprsone} \typearrow \typedexprs
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ReduceSlicesToCall \label{sec:TypingRule.ReduceSlicesToCall}}
\hypertarget{def-reduceslicestocall}{}
The function
\[
  \reduceslicestocall(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve} \aslsep \overname{\slice^*}{\slices})
  \aslto
  \langle (\overname{\identifier}{\name} \times \overname{\expr^*}{\vargs})\rangle
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the expression $\ve$ together with the list of slices $\slices$ constitute
a call to a subprogram in $\tenv$.
If so, it returns a pair consisting of the name of the called subprogram --- $\name$ ---
and the list of actual arguments --- $\vargs$. Otherwise, it returns $\None$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{yes}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is a subprogram name with $\slices$ as its actual arguments
    via $\tododefine{should\_slices\_reduce\_to\_call}$
    yields a list of actual argument expressions $\vargs$\ProseOrTypeError;
    \item $\name$ is $\vx$;
    \item the result is $\langle (\name, \vle)\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{no}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is a subprogram name with $\slices$ as its actual arguments
    via $\tododefine{should\_slices\_reduce\_to\_call}$
    yields $\None$;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_var}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\ReduceSlicesToCallBegin}{\ReduceSlicesToCallEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[yes]{
  \tododefine{should\_slices\_reduce\_to\_call}(\tenv, \vx, \slices) \typearrow \langle \vargs \rangle\\
  \name \eqdef \vx
}
{
  \reduceslicestocall(\tenv, \EVar(\vx), \slices) \typearrow \langle (\name, \vargs)\rangle
}
\and
\inferrule[no]{
  \tododefine{should\_slices\_reduce\_to\_call}(\tenv, \vx, \slices) \typearrow \None
}
{
  \reduceslicestocall(\tenv, \EVar(\vx), \slices) \typearrow \None
}
\and
\inferrule[non\_var]{
  \astlabel(\ve) \neq \EVar
}
{
  \reduceslicestocall(\tenv, \ve, \slices) \typearrow \None
}
\end{mathpar}
\end{emptyformal}

\hypertarget{def-annotatestaticconstrainedinteger}{}
\section{TypingRule.StaticConstrainedInteger \label{sec:TypingRule.StaticConstrainedInteger}}

The function
\[
  \annotatestaticconstrainedinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\expr}{\vepp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a \staticallyevaluable\  integer expression $\ve$ in the static environment $\tenv$
and returns the annotated expression $\vepp$.
A type error is returned, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the expression $\ve$ in $\tenv$ yields $ (\vt, \vep)$\ProseOrTypeError;
  \item determining whether $\vt$ is a statically \constrainedinteger\ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item determining whether $\vep$ is \staticallyevaluable\  in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\normalize$ to $\vep$ in $\tenv$ yields $\vepp$.
\end{itemize}

\CodeSubsection{\StaticConstrainedIntegerBegin}{\StaticConstrainedIntegerEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \vep) \OrTypeError\\
  \checkconstrainedinteger(\tenv, \vt) \typearrow \True \OrTypeError\\
  \checkstaticallyevaluable(\tenv, \vep) \typearrow \True \OrTypeError\\
  \normalize(\tenv, \vep) \typearrow \vepp
}{
  \annotatestaticconstrainedinteger(\tenv, \ve) \typearrow \vepp
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Left-Hand-Side Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatelexpr}{}
The function
\[
  \annotatelexpr{
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\lexpr}{\vle} \aslsep
    \overname{\ty}{\vte}} \aslto
    \overname{\lexpr}{\newle} \cup \TTypeError
\]
annotates a left-hand side expression $\vle$ in an environment $\tenv$, assuming $\vle$
to be the type of the corresponding right-hand-side expression,
resulting in an annotated expression $\newle$.
The result is a type error, if one is detected.
One of the following applies:
\begin{itemize}
\item TypingRule.LEDiscard (see \secref{TypingRule.LEDiscard}),
\item TypingRule.LELocalVar (see \secref{TypingRule.LELocalVar}),
\item TypingRule.LEGlobalVar (see \secref{TypingRule.LEGlobalVar}),
\item TypingRule.LEDestructuring (see \secref{TypingRule.LEDestructuring}),
\item TypingRule.LESlice (see \secref{TypingRule.LESlice}),
\item TypingRule.LESetArray (see \secref{TypingRule.LESetArray}),
\item TypingRule.LESetBadStructuredField (see \secref{TypingRule.LESetBadStructuredField}),
\item TypingRule.LESetStructuredField (see \secref{TypingRule.LESetStructuredField}),
\item TypingRule.LESetBadBitField (see \secref{TypingRule.LESetBadBitField}),
\item TypingRule.LESetBitField (see \secref{TypingRule.LESetBitField}),
\item TypingRule.LESetBitFieldNested (see \secref{TypingRule.LESetBitFieldNested}),
\item TypingRule.LESetBitFieldTyped (see \secref{TypingRule.LESetBitFieldTyped}),
\item TypingRule.LESetBadField (see \secref{TypingRule.LESetBadField}),
\item TypingRule.LEConcat (see \secref{TypingRule.LEConcat}).
\end{itemize}

We also make use of the helper tuple
TypingRule.LEBits (see \secref{TypingRule.LEBits}).

\hypertarget{def-rexpr}{}
Some of the rules require viewing left-hand-side expressions as their corresponding right-hand side expressions.
The correspondence is defined in the ASL Syntax Reference~\cite[Chapter 5]{ASLAbstractSyntaxReference}
and given by the function $\torexpr : \lexpr \rightarrow \expr$.

\section{TypingRule.LEDiscard \label{sec:TypingRule.LEDiscard}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vle$ denotes an expression that can be discarded, that is, $\LEDiscard$;
\item $\newle$ is $\vle$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LEDiscardBegin}{\LEDiscardEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \annotatelexpr{\tenv, \LEDiscard, \vte} \typearrow \vle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LELocalVar \label{sec:TypingRule.LELocalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes a local variable $\vx$, that is, $\LEVar(\vx)$;
  \item $\vx$ is locally declared as a mutable variable of type $\tty$ in $\tenv$;
  \item determining whether $\tty$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newle$ is $\vle$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LELocalVarBegin}{\LELocalVarEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \LEVar(\vx)\\
  L^\tenv.\localstoragetypes(\id) = (\tty, \LDKVar)\\
  \checktypesat(\tenv, \vte, \tty) \typearrow \True \OrTypeError
}{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \vle
}
\end{mathpar}

\end{emptyformal}

\subsection{Comments}
\lrmcomment{
  This is related to \identr{WDGQ}, \identr{GNTS}, \identi{MMKF},
  \identi{DGWJ}, \identi{KKCC} and \identr{LXQZ}.
}

\section{TypingRule.LEGlobalVar \label{sec:TypingRule.LEGlobalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes a local variable $\vx$, that is, $\LEVar(\vx)$;
  \item $\vx$ is globally declared as a mutable variable of type $\tty$ in $\tenv$;
  \item determining whether $\tty$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newle$ is $\vle$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LEGlobalVarBegin}{\LEGlobalVarEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \LEVar(\vx)\\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKVar)\\
  \checktypesat(\tenv, \vte, \tty) \typearrow \True \OrTypeError
 }{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{WDGQ}.}

\section{TypingRule.LEDestructuring \label{sec:TypingRule.LEDestructuring}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes a tuple of left-hand-side expressions $\les$, that is, $\LEDestructuring(\les)$;
  \item $\les$ is a list $\ve_{1..k}$;
  \item $\vte$ is a tuple type $\subtys$;
  \item determining whether $\les$ and $\subtys$ have the same length yields $\True$\ProseOrTypeError;
  \item $\subtys$ is the list of types $\vt_{1..k}$;
  \item annotating the left-hand-side expression $\ve_i$ with the type $\vt_i$, for $i=1..k$, yields $\vep_i$\ProseOrTypeError;
  \item the list of expressions $\lesp$ is $\vep_i$, for $i=1..k$;
  \item $\newle$  is the list of left-hand-side expressions $\lesp$, that is, $\LEDestructuring(\lesp)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LEDestructuringBegin}{\LEDestructuringEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \LEDestructuring(\les)\\
  \les \eqname [\ve_{1..k}]\\
  \checktrans{\astlabel(\vle) = \TTuple}{TupleTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \vte \eqname \TTuple(\subtys)\\
  \equallength(\les, \subtys) \typearrow \vb\\
  \checktrans{\vb}{DifferentLengths} \checktransarrow \True \OrTypeError\\\\
  \subtys \eqname [\vt_{1..k}]\\
  i=1..k: \annotatelexpr{\tenv, \ve_i,\vt_i} \typearrow \vep_i \OrTypeError\\
  \lesp \eqname [i=1..k: \vep_i]
}{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \LEDestructuring(\lesp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESlice \label{sec:TypingRule.LESlice}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the slicing of a left-hand-side expression $\vleone$ by the slices $\slices$, that is, $\LESlice(\vleone, \slices)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\
        $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item $\vtleone$ is a bitvector type;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the width of the slices $\slices$ in $\tenv$ and simplifying them yields $\vwidth$;
  \item $\vt$ is the bitvector type of width $\width$ and empty list of bitfields;
  \item checking whether $\vte$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item annotating $\slices$ in $\tenv$ yields $\slicestwo$\ProseOrTypeError;
  \item checking that the slices $\slicestwo$ are all disjoint yields $\True$\ProseOrTypeError;
  \item $\newle$ is the slicing of $\vletwo$ by $\slicestwo$, that is, $\LESlice(\vletwo, \slicestwo)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LESliceBegin}{\LESliceEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore)\\
  \tstruct(\tenv, \vtleone) \typearrow \structtleone \OrTypeError\\
  \astlabel(\structtleone) = \TBits\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo\\
  \sliceswidth(\tenv, \slices) \typearrow \widthp\\
  \normalize(\tenv, \widthp) \typearrow \vwidth\\
  \vt \eqdef \TBits(\vwidth, \emptylist)\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\
  \annotateslices(\tenv, \slices) \typearrow \slicestwo \OrTypeError\\
  \tododefine{check\_disjoint\_slices}(\tenv, \slicestwo) \typearrow \True \OrTypeError\\
  \newle \eqdef \LESlice(\vletwo, \slicestwo)
}{
  \annotatelexpr{\tenv, \overname{\LESlice(\vleone, \slices)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetArray \label{sec:TypingRule.LESetArray}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the slicing of a left-hand-side expression $\vleone$ by the slices $\slices$, that is, $\LESlice(\vleone, \slices)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields an array type of size $\size$ and element type $\vt$, that is, $\TArray(\size, \vt)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ with type $\vtleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item determining that $\vte$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item determining whether $\slices$ is a single slice with index expression $\eindex$ yields $\True$\ProseOrTypeError;
  \item annotating the index expression $\eindex$ in $\tenv$ yields $(\tindexp, \eindexp)$\ProseOrTypeError;
  \item determining the array length type of $\size$ in $\tenv$ (via $\typeofarraylength$) yields $\wantedtindex$;
  \item determining whether $\tindexp$ \typesatisfies\ $\wantedtindex$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newle$ is an access to array $\vletwo$ at index $\eindexp$, that is, \\ $\LESetArray(\vletwo, \eindexp)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LESetArrayBegin}{\LESetArrayEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\
  \tstruct(\tenv, \vtleone) \typearrow \TArray(\size, \vt) \OrTypeError\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\
  \checktrans{\listlen{\slices} = 1}{ArraySliceShouldBeSingleIndex} \checktransarrow \True \OrTypeError\\\\
  \slices \eqname [\vs]\\
  \checktrans{\astlabel(\vs) = \SliceSingle}{ArraySliceShouldBeSingleIndex} \checktransarrow \True \OrTypeError\\\\
  \vs \eqname \SliceSingle(\eindex)\\
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp) \OrTypeError\\
  \typeofarraylength(\tenv, \size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\
  \newle \eqdef \LESetArray(\vletwo, \eindexp)
}{
  \annotatelexpr{\tenv, \overname{\LESlice(\vleone, \slices)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadStructuredField \label{sec:TypingRule.LESetBadStructuredField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item the \structure\ of $\vtleone$ in $\tenv$ is either a record type or an exception type with list of fields $\fields$\ProseOrTypeError;
  \item $\field$ is not associated with any type in $\fields$;
  \item the result is an error indicating that the field $\field$ is missing from the type of $\vleone$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LESetBadStructuredFieldBegin}{\LESetBadStructuredFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\
  \tstruct(\tenv, \vtleone) \typearrow L(\fields) \OrTypeError\\
  L \in \{\TException, \TRecord\}\\
  \assocopt(\fields, \field) \typearrow \None
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{MissingField}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetStructuredField \label{sec:TypingRule.LESetStructuredField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named \texttt{field} in $\vleone$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression  $\vleone$ with type $\vtleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields either a record type or an exception type with fields $\fields$\ProseOrTypeError;
  \item the type associated with the field $\field$ in $\fields$ is $\vt$;
  \item determining whether $\vte$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item $\newle$ is the access to the field $\field$ in $\vletwo$, that is, $\LESetField(\vletwo, \field)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LESetStructuredFieldBegin}{\LESetStructuredFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\
  \tstruct(\tenv, \vtleone) \typearrow L(\fields) \OrTypeError\\
  L \in \{\TException, \TRecord\}\\
  \assocopt(\fields, \field) \typearrow \langle\vt\rangle\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \newle \eqdef \LESetField(\vletwo, \field)
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadBitField \label{sec:TypingRule.LESetBadBitField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields $\vtleone$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a bitvector type with bitfields \\ $\bitfields$, that is,
        $\TBits(\Ignore, \bitfields)$\ProseOrTypeError;
  \item find whether a bitfield $\field$ exists in $\bitfields$ yields $\None$;
  \item the result is a type error indicating that the field $\field$ is missing from the type of $\vleone$.
\end{itemize}

\subsection{Example}


\CodeSubsection{\LESetBadBitFieldBegin}{\LESetBadBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\
  \tododefine{find\_bitfield\_opt}(\bitfields, \field) \typearrow \None
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{MissingField}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitField \label{sec:TypingRule.LESetBitField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
\item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
\item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
\item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a bitvector type with with bitfields $\bitfields$\ProseOrTypeError;
\item looking for $\field$ in $\bitfields$ yields a bitfield with corresponding slices $\slices$, that is, $\BitFieldSimple(\Ignore, \slices)$;
\item $\vw$ is the width of $\slices$;
\item $\vt$ is defined as the bitvector type of width $\vw$ and empty list of bitfields, that is, $\TBits(\vw, \emptylist)$;
\item checking whether $\vt$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item $\vletwo$ is defined as the slicing of $\vleone$ by $\slices$, that is, $\LESlice(\vleone, \slices)$;
\item annotating the left-hand-side expression $\vletwo$ in $\tenv$ yields $\newle$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LESetBitFieldBegin}{\LESetBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\
  \tododefine{find\_bitfield\_opt}(\bitfields, \field) \typearrow \langle \BitFieldSimple(\Ignore, \slices) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vt \eqdef \TBits(\vw, \emptylist)\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow \newle \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldNested \label{sec:TypingRule.LESetBitFieldNested}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
\item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
\item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
\item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a bitvector type with with bitfields $\bitfields$\ProseOrTypeError;
\item looking for $\field$ in $\bitfields$ yields a nested bitfield with corresponding slices $\slices$ and list of bitfields
      $\bitfieldsp$, that is, \\ $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
\item $\vw$ is the width of $\slices$;
\item $\vt$ is defined as the bitvector type of width $\vw$ and list of bitfields $\bitfieldsp$, that is, $\TBits(\vw, \bitfieldsp)$;
\item checking whether $\vt$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item $\vletwo$ is defined as the slicing of $\vleone$ by $\slices$, that is, $\LESlice(\vleone, \slices)$;
\item annotating the left-hand-side expression $\vletwo$ in $\tenv$ yields $\newle$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LESetBitFieldNestedBegin}{\LESetBitFieldNestedEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\
  \tododefine{find\_bitfield\_opt}(\bitfields, \field) \typearrow \langle \BitFieldNested(\Ignore, \slices, \bitfieldsp) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vt \eqdef \TBits(\vw, \bitfieldsp)\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow \newle \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldTyped \label{sec:TypingRule.LESetBitFieldTyped}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a bitvector type with with bitfields $\bitfields$\ProseOrTypeError;
  \item looking for $\field$ in $\bitfields$ yields a typed bitfield with corresponding slices $\slices$ and a type $\vt$,
        that is, \\ $\BitFieldType(\Ignore, \vslices, \vt))$;
  \item $\vw$ is the width of $\slices$;
  \item $\vtp$ is defined as the bitvector type of width $\vw$ and an empty list of bitfields, that is, $\TBits(\vw , \emptylist)$;
  \item checking whether $\vtp$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item checking whether $\vt$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\vletwo$ is defined as the slicing of $\vleone$ by $\slices$, that is, $\LESlice(\vleone, \slices)$;
  \item annotating the left-hand-side expression $\vletwo$ in $\tenv$ yields $\newle$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LESetBitFieldTypedBegin}{\LESetBitFieldTypedEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\
  \tododefine{find\_bitfield\_opt}(\bitfields, \field) \typearrow \langle \BitFieldType(\Ignore, \vslices, \vt) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vtp \eqdef \TBits(\vw , \emptylist)
  \checktypesat(\tenv, \vtp, \vt) \typearrow \True \OrTypeError\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow \newle \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadField \label{sec:TypingRule.LESetBadField}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $\vletwo$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vtleone$ in $\tenv$ yields a type $\vt$\ProseOrTypeError;
  \item $\vt$ is neither a record type, an exception type, or a bitvector type;
  \item the result is an error indicating that the type of $\vle$ conflicts with the requirements of a field access expression.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LESetBadFieldBegin}{\LESetBadFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore) \OrTypeError\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo \OrTypeError\\
  \tstruct(\tenv, \vtleone) \typearrow \vt \OrTypeError\\
  \astlabel(\vt) \not\in \{\TException, \TRecord, \TBits\}
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{TypeConflict}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LEConcat \label{sec:TypingRule.LEConcat}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vle$ denotes the concatenation of left-hand-side expressions $\les$, that is, \\ $\LEConcat(\les, \Ignore)$;
  \item annotating the right-hand-side expression corresponding to $\vle$ in $\tenv$ yields \\ $(\vteeq, \Ignore)$\ProseOrTypeError;
  \item checking whether the bitwidth of $\vteeq$ equals the bitwidth of $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\les$ is the list of left-hand-side expressions $\vle_i$, for $i=1..k$;
  \item annotating each left-hand-side expression $\vle_i$ as a bitvector-typed expression (via $\annotatelebits$)
        yields the annotated left-hand-side expression $\vleone_i$ and corresponding bitwidth $\width_i$, for $i=1..k$;
  \item $\lesone$ is defined as the list $\vleone_{1..k}$;
  \item $\widths$ is defined as the list $\width_{1..k}$;
  \item $\newle$ is the concatenation of left-hand-side expressions $\lesone$ with corresponding list of widths $\widths$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\LEConcatBegin}{\LEConcatEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \LEConcat(\les, \Ignore)\\
  \annotateexpr{\tenv, \torexpr(\vle)} \typearrow (\vteeq, \Ignore) \OrTypeError\\
  \checkbitsequalwidth(\tenv, \vteeq, \vte) \typearrow \True \OrTypeError\\
  \les \eqname \vle_{1..k}\\
  i=1..k: \annotatelebits(\tenv, \vle_i) \typearrow (\vleone_i, \width_i) \OrTypeError\\
  \lesone \eqdef \vleone_{1..k}\\
  \widths \eqdef \width_{1..k}
}{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \overname{\LEConcat(\lesone, \widths)}{\newle}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LEBits \label{sec:TypingRule.LEBits}}
\hypertarget{def-annotatelebits}{}
The helper function
\[
  \annotatelebits(\overname{\staticenvs}{\tenv} \aslsep \overname{\lexpr}{\vle})
  \aslto \overname{\lexpr}{\vleone} \times \overname{\N}{\width}
\]
annotates a left-hand-side expression $\vle$, which is checked to be of bitvector type
with width $\width$,
resulting in the annotated expression and $\width$, or a type error, if one is detected.

All of the following apply:
\begin{itemize}
  \item annotating the right-hand-side expression corresponding to $\vle$ in $\tenv$ yields \\ $(\vteone, \Ignore)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vteone$ in $\tenv$ yields $\vteonestruct$\ProseOrTypeError;
  \item checking whether $\vteonestruct$ is a bitvector type yields $\True$\ProseOrTypeError;
  \item $\vteonestruct$ is a bitvector type with width $\ewidth$;
  \item applying $\reduceconstants$ to $\ewidth$ yields the literal $\vl$\ProseOrTypeError;
  \item checking whether $\vl$ is an integer literal yields $\True$\ProseOrTypeError;
  \item $\vl$ is the integer literal for the integer $\width$;
  \item $\vtetwo$ is defined as the bitvector type of width given by $\width$ and an empty list of bitfields, that is,
        $\TBits(\ELInt{\width}, \emptylist)$;
  \item annotating the left-hand-side expression $\vtetwo$ in $\tenv$ yields $\vleone$\ProseOrTypeError.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vteone, \Ignore) \OrTypeError\\
  \tstruct(\tenv, \vteone) \typearrow \vteonestruct \OrTypeError\\
  \checktrans{\astlabel(\vteonestruct) = \TBits}{BitvectorTypeExpected} \checktransarrow \True \OrTypeError\\
  \vteonestruct \eqname \TBits(\ewidth, \Ignore)\\
  \reduceconstants(\tenv, \ewidth) \typearrow \vl\\
  \checktrans{\astlabel(\vl) = \lint}{IntegerLiteralExpected} \checktransarrow \True \OrTypeError\\
  \vl \eqname \lint(\width)\\
  \vtetwo \eqdef \TBits(\ELInt{\width}, \emptylist)\\
  \annotatelexpr{\tenv, \vtetwo} \typearrow \vleone \OrTypeError
}{
  \annotatelebits(\tenv, \vle) \typearrow (\vleone, \width)
}
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Slices \label{chap:typingslices}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotateslice}{}
The function
\[
  \annotateslice(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\vs})
  \aslto
  \overname{\slice}{\vsp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a slices $\vs$ in the static environment $\tenv$,
resulting in an annotated slice $\vsp$.
A type error is returned, if one is detected.

One of the following applies:
\begin{itemize}
\item TypingRule.SliceSingle (see \secref{TypingRule.SliceSingle}),
\item TypingRule.SliceLength (see \secref{TypingRule.SliceLength}),
\item TypingRule.SliceRange (see \secref{TypingRule.SliceRange}),
\item TypingRule.SliceStar (see \secref{TypingRule.SliceStar}).
\end{itemize}

We also define a rule for typing of a list of slices:
TypingRule.Slices (see \secref{TypingRule.Slices}).

\hypertarget{def-annotateslices}{}
The function
\[
  \annotateslices(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slices})
  \aslto
  \overname{\slice^*}{\slicesp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of slices $\slices$ in the static environment $\tenv$,
resulting in an annotated list of slices $\slicesp$.
A type error is returned, if one is detected.

The relevant rule is given by:
\begin{itemize}
  \item TypingRule.Slices (see \secref{TypingRule.Slices})
\end{itemize}

\section{TypingRule.SliceSingle \label{sec:TypingRule.SliceSingle}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a slice at index \vi, that is $\SliceSingle(\vi)$;
  \item annotating the slice at offset $\vi$ of length $1$ yields $\vsp$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SliceSingleBegin}{\SliceSingleEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateslice(\SliceLength(\vi, \eliteral{1})) \typearrow \vsp \OrTypeError
}{
  \annotateslice(\tenv, \SliceSingle(\vi)) \typearrow \vsp
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  \identr{GXKG}: The notation \texttt{b[i]} is syntactic sugar for \texttt{b[i +: 1]}.

\section{TypingRule.SliceLength \label{sec:TypingRule.SliceLength}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a slice of length $\elength$ and offset $\eoffset$, that is, $\SliceLength(\eoffset, \elength)$;
  \item annotating the expression $\eoffset$ in $\tenv$ yields $(\toffset, \eoffsetp)$\ProseOrTypeError;
  \item annotating the \staticallyevaluable\ \constrainedinteger\ expression $\elength$ in $\tenv$ yields
  $\elength$\ProseOrTypeError;
  \item determining whether $\toffset$ has the \structureofinteger\ yields $\True$\ProseOrTypeError;
  \item $\vsp$ is the slice at offset $\eoffsetp$ and length $\elength'$, that is,\\
   $\SliceLength(\eoffsetp, \elength')$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SliceLengthBegin}{\SliceLengthEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \eoffset} \typearrow (\toffset, \eoffsetp) \OrTypeError\\
  \annotatestaticconstrainedinteger(\tenv, \elength) \typearrow \elengthp \OrTypeError\\
  \checkstructureinteger(\tenv, \eoffsetp, \toffset) \typearrow \True \OrTypeError
}{
  \annotateslice(\tenv, \SliceLength(\eoffset, \elength)) \typearrow \SliceLength(\eoffsetp, \elength')
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SliceRange \label{sec:TypingRule.SliceRange}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a slice for the range \texttt{(j, i)}, that is $\SliceRange(\vj, \vi)$;
  \item $\prelength$ is \texttt{i+:(j-i+1)};
  \item annotating the slice at offset $\vi$ of length $\prelength$ yields $\vsp$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SliceRangeBegin}{\SliceRangeEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \binopliterals(\MINUS, \vi, \vi) \typearrow \prelengthp\\
  \binopliterals(\PLUS, \prelengthp, \eliteral{1}) \typearrow \prelength\\
  \annotateslice(\SliceLength(\vi, \prelength)) \typearrow \vsp \OrTypeError
}{
  \annotateslice(\tenv, \SliceRange(\vj, \vi)) \typearrow \vsp
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    \identr{GXKG}: The notation \texttt{b[j:i]} is syntactic sugar for \texttt{b[i+:(j-i+1)]}.

\section{TypingRule.SliceStar \label{sec:TypingRule.SliceStar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a slice \texttt{[factor *: pre\_length]}, that is, $\SliceStar(\factor, \prelength)$;
  \item $\preoffset$ is $\factor * \prelength$;
  \item annotating the slice at offset $\preoffset$ of length $\prelength$ yields $\vsp$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SliceStarBegin}{\SliceStarEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \binopliterals(\MUL, \factor, \prelength) \typearrow \preoffset\\
  \annotateslice(\SliceLength(\preoffset, \prelength)) \typearrow \vsp \OrTypeError
}{
  \annotateslice(\tenv, \SliceStar(\factor, \prelength)) \typearrow \vsp
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    \identr{GXQG}: The notation \texttt{b[i *: n]} is syntactic sugar for \texttt{b[i*n +: n]}

\section{TypingRule.Slices \label{sec:TypingRule.Slices}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the slices in $\slices$ from left to right yields the list of annotated slices $\slicesp$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vs\in\slices: \annotateslice(\tenv, \vs) \typearrow \vsp \OrTypeError\\\\
  \slicesp = [\vs\in\slices: \vsp]
}{
  \annotateslices(\tenv, \slices) \typearrow \slicesp
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Patterns}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatepattern}{}
The function
\[
  \annotatepattern(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\vt} \aslsep
    \overname{\pattern}{\vp}) \aslto \overname{\pattern}{\newp} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a pattern $\vp$ in a static environment $\tenv$ given a type $\vt$,
resulting in a pattern $\newp$ or a type error, if one is detected, and one of the following applies:
\begin{itemize}
\item TypingRule.PAll (see \secref{TypingRule.PAll}),
\item TypingRule.PAny (see \secref{TypingRule.PAny}),
\item TypingRule.PGeq (see \secref{TypingRule.PGeq}),
\item TypingRule.PLeq (see \secref{TypingRule.PLeq}),
\item TypingRule.PNot (see \secref{TypingRule.PNot}),
\item TypingRule.PRange (see \secref{TypingRule.PRange}),
\item TypingRule.PSingle (see \secref{TypingRule.PSingle}),
\item TypingRule.PMask (see \secref{TypingRule.PMask}),
\item TypingRule.PTuple (see \secref{TypingRule.PTuple}).
\end{itemize}

\section{TypingRule.PAll \label{sec:TypingRule.PAll}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vp$ is the pattern matching everything, that is, $\PatternAll$;
  \item $\newp$ is $\vp$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\PAllBegin}{\PAllEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatepattern(\tenv, \vt, \PatternAll) \typearrow \PatternAll
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PAny\label{sec:TypingRule.PAny}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vp$ is the pattern which matches anything in a list $\vli$, that is, $\PatternAny(\vli)$;
\item annotating each pattern in $\vli$ yields the list of annotated pattern $\newli$\ProseOrTypeError;
\item $\newp$ is the pattern which matches anything in $\newli$, that is, \\ $\PatternAny(\newli)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\PAnyBegin}{\PAnyEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vl\in\vli: \annotatepattern(\tenv, \vt, \vl) \typearrow \vlp \OrTypeError\\\\
  \newli \eqdef [\vl\in\vli: \vlp]
}
{
  \annotatepattern(\tenv, \vt, \PatternAny(\vli)) \typearrow \PatternAny(\newli)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PGeq \label{sec:TypingRule.PGeq}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vp$ is the pattern which matches anything greater than or equal to an expression $\ve$,
that is, $\PatternGeq(\ve)$;
\item annotating the expression $\ve$ in $\tenv$ yields $(\vte, \vep)$\ProseOrTypeError;
\item determining whether $\vep$ is a \staticallyevaluable\ expression yields $\True$\ProseOrTypeError;
\item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
\item obtaining the \structure\ of $\vte$ in $\tenv$ yields $\testruct$\ProseOrTypeError;
\item $\vb$ is true if and only if $\vtstruct$ and $\testruct$ are both integer types or both real types;
\item if $\vb$ is $\False$ a type error is returned (indicating that the types of $\vt$ and $\vte$
      are inappropriate for the $\GEQ$ operator),
which short-circuits the entire rule;
\item $\newp$ is the pattern which matches anything greater than or equal to $\vep$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\PGeqBegin}{\PGeqEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \checkstaticallyevaluable(\tenv, \vep) \typearrow \True \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \tstruct(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  {
    \begin{array}{rl}
      \vb \eqdef& \astlabel(\vtstruct) = \astlabel(\testruct)\ \land\\
                & \astlabel(\vtstruct) \in \{\TInt, \TReal\}
    \end{array}
  }\\
  \checktrans{\vb}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError
}
{
  \annotatepattern(\tenv, \vt, \PatternGeq(\ve)) \typearrow \PatternGeq(\vep)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PLeq \label{sec:TypingRule.PLeq}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vp$ is the pattern which matches anything less than or equal to an expression $\ve$,
that is, $\PatternLeq(\ve)$;
\item annotating the expression $\ve$ in $\tenv$ yields $(\vte, \vep)$\ProseOrTypeError;
\item determining whether $\vep$ is a \staticallyevaluable\ expression yields $\True$\ProseOrTypeError;
\item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
\item obtaining the \structure\ of $\vte$ in $\tenv$ yields $\testruct$\ProseOrTypeError;
\item $\vb$ is true if and only if $\vtstruct$ and $\testruct$ are both integer types or both real types;
\item if $\vb$ is $\False$ a type error is returned (indicating that the types of $\vt$ and $\vte$
      are inappropriate for the $\LEQ$ operator),
which short-circuits the entire rule;
\item $\newp$ is the pattern which matches anything less than or equal to $\vep$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\PLeqBegin}{\PLeqEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \checkstaticallyevaluable(\tenv, \vep) \typearrow \True \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \tstruct(\tenv, \vte) \typearrow \testruct \OrTypeError\\\\
  {
    \begin{array}{rl}
      \vb \eqdef& \astlabel(\vtstruct) = \astlabel(\testruct)\ \land\\
                & \astlabel(\vtstruct) \in \{\TInt, \TReal\}
    \end{array}
  }\\
  \checktrans{\vb}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError
}
{
  \annotatepattern(\tenv, \vt, \PatternLeq(\ve)) \typearrow \PatternLeq(\vep)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PNot \label{sec:TypingRule.PNot}}

\subsection{Prose}
Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern $\newp$ and all of the following apply:
\begin{itemize}
  \item $\vp$ is the pattern which matches the negation of a pattern $\vq$, that is, $\PatternNot(\vq)$;
  \item annotating $\vq$ in $\tenv$ yields $\newq$\ProseOrTypeError;
  \item $\newp$ is pattern which matches the negation of $\newq$, that is, $\PatternLeq(\newq)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\PNotBegin}{\PNotEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatepattern(\tenv, \vq) \typearrow \newq \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \PatternNot(\vq)) \PatternNot \PatternLeq(\newq)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PRange \label{sec:TypingRule.PRange}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vp$ is the pattern which matches anything within the range given by
  expressions $\veone$ and $\vetwo$, that is, $\PatternRange(\veone, \vetwo)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \veonep)$\ProseOrTypeError;
  \item annotating the expression $\vetwo$ in $\tenv$ yields $(\vtetwo, \vetwop)$\ProseOrTypeError;
  \item determining whether both $\veonep$ and $\vetwop$ are compile-time constant expressions yields $\True$\ProseOrTypeError;
  \item obtaining the \structure\ for $\vt$, $\vteone$, and $\vtetwo$ yields
        $\vtstruct$, $\vteonestruct$, and $\vtetwostruct$, respectively\ProseOrTypeError;
  \item a check the AST labels of $\vtstruct$, $\vteonestruct$, and $\vtetwostruct$ are all the same and are either
        $\TInt$ or $\TReal$ yields $\True$. Otherwise, the result is a type error, which short-circuits the entire rule.
        The type error indicates that the types of
        $\veone$, $\vetwo$ and the type $\vt$ must be either of integer type or of real type.
  \item $\newp$ is a range pattern with bounds $\veonep$ and $\vetwop$, that is, $\PatternRange(\veonep, \vetwop)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\PRangeBegin}{\PRangeEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \veonep) \OrTypeError\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vtetwo, \vetwop) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \tstruct(\tenv, \vteone) \typearrow \vteonestruct \OrTypeError\\
  \tstruct(\tenv, \vtetwo) \typearrow \vtetwostruct \OrTypeError\\
  {
    \begin{array}{rl}
      \vb \eqdef& \astlabel(\vtstruct) = \astlabel(\vteonestruct) = \astlabel(\vtetwostruct)\ \land\\
                & \astlabel(\vtstruct) \in \{\TInt, \TReal\}
    \end{array}
  }\\
  \checktrans{\vb}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \PatternRange(\veone, \vetwo)) \typearrow \PatternRange(\veonep, \vetwop)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PSingle \label{sec:TypingRule.PSingle}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vp$ is the pattern that matches the expression $\ve$, that is, $\PatternSingle(\ve)$;
  \item annotating the expression $\ve$ in $\tenv$ yields $(\vte, \vep)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ yields $\vtstruct$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vte$ yields $\testruct$\ProseOrTypeError;
  \item One of the following holds:
  \begin{itemize}
    \item All of the following apply (\textsc{t\_bool, t\_real, t\_int}):
    \begin{itemize}
      \item the labels of $\vtstruct$ and $\testruct$ are both either $\TBool$, $\TReal$, or $\TInt$\ProseOrTypeError;
    \end{itemize}

    \item All of the following apply (\textsc{t\_bits}):
    \begin{itemize}
      \item the labels of $\vtstruct$ and $\testruct$ are both $\TBits$\ProseOrTypeError;
      \item determining whether the bitwidths of $\vtstruct$ and $\testruct$ are equal yields $\True$\ProseOrTypeError;
    \end{itemize}

    \item All of the following apply (\textsc{t\_enum}):
    \begin{itemize}
      \item the labels of $\vtstruct$ and $\testruct$ are both $\TEnum$\ProseOrTypeError;
      \item determining whether the lists of enumeration literals of $\vtstruct$ and $\testruct$ are equal yields $\True$\ProseOrTypeError;
    \end{itemize}

    \item All of the following apply (\textsc{error}):
    \begin{itemize}
      \item determining whether the labels of $\vtstruct$ and $\testruct$ are the same yields $\True$\ProseOrTypeError;
      \item the label of $\vtstruct$ is not one of $\TBool$, $\TReal$, $\TInt$, $\TBits$, or $\TEnum$;
      \item the result is a type error indicating that the types $\vt$ and $\vte$ are inappropriate for this pattern.
    \end{itemize}
  \end{itemize}
  \item $\newp$ is the pattern that matches the expression $\vep$, that is, $\PatternSingle(\vep)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\PSingleBegin}{\PSingleEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[t\_bool, t\_real, t\_int]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \tstruct(\tenv, \vte) \typearrow \testruct \OrTypeError\\
  \checktrans{\astlabel(\vtstruct) = \astlabel(\testruct)}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError\\\\
  \astlabel(\vtstruct) \in \{\TBool, \TReal, \TInt\}
}{
  \annotatepattern(\tenv, \vt, \PatternSingle(\ve)) \typearrow \PatternSingle(\vep)
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \tstruct(\tenv, \vte) \typearrow \vtestruct \OrTypeError\\
  \astlabel(\vtstruct) = \astlabel(\testruct) = \TBits\\
  \bitwidthequal(\tenv, \vtstruct, \testruct) \typearrow \vb\\
  \checktrans{\vb}{BitvectorsDifferentWidths} \checktransarrow \True \OrTypeError\\
}{
  \annotatepattern(\tenv, \vt, \PatternSingle(\ve)) \typearrow \PatternSingle(\vep)
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \tstruct(\tenv, \vte) \typearrow \vtestruct \OrTypeError\\
  \vtstruct \eqname \TEnum(\vlione)\\
  \vtestruct \eqname \TEnum(\vlitwo)\\
  \checktrans{\vlione = \vlitwo}{EnumDifferentLabels} \checktransarrow \True \OrTypeError\\
}{
  \annotatepattern(\tenv, \vt, \PatternSingle(\ve)) \typearrow \PatternSingle(\vep)
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \tstruct(\tenv, \vte) \typearrow \testruct \OrTypeError\\
  \checktrans{\astlabel(\vtstruct) = \astlabel(\testruct)}{InvalidTypesForBinop} \checktransarrow \True \OrTypeError\\\\
  \astlabel(\vtstruct) \in \{\TBool, \TReal, \TInt, \TBits, \TEnum\}
}{
  \annotatepattern(\tenv, \vt, \PatternSingle(\ve)) \typearrow \TypeErrorVal{TypeConflict}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PMask \label{sec:TypingRule.PMask}}

\subsection{Prose}
All of the following apply:
  \begin{itemize}
  \item $\vp$ is the pattern which matches a mask $\vm$, that is, $\PatternMask(\vm)$;
  \item determining whether $\vt$ has the structure of a bitvector type yields $\True$\ProseOrTypeError;
  \item $\vn$ is the length of mask $\vm$;
  \item determining whether $\vt$ \typesatisfies\ the bitvector type of length $\vn$ \\
        (that is, $\TBits(\vn, \emptylist)$), yields $\True$\ProseOrTypeError;
  \item $\newp$ is $\vp$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\PMaskBegin}{\PMaskEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checkstructurelabel(\tenv, \vt, \TBits) \typearrow \True \OrTypeError\\
  \vn \eqdef \listlen{\vm}\\
  \checktypesat(\tenv, \vt, \TBits(\vn, \emptylist)) \typearrow \True \OrTypeError
}{
  \annotatepattern(\tenv, \vt, \PatternMask(\vm)) \typearrow \PatternMask(\vm)
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identi{VMKF}.}

\section{TypingRule.PTuple \label{sec:TypingRule.PTuple}}

\subsection{Prose}
All of the following apply:
  \begin{itemize}
  \item $\vp$ is the pattern which matches a tuple $\vli$, that is, $\PatternTuple(\vli)$;
  \item obtaining the \structure\ of $\vt$ yields $\vtstruct$\ProseOrTypeError;
  \item determining whether $\vtstruct$ is a tuple type yields $\True$\ProseOrTypeError;
  \item $\vtstruct$ is a tuple type with list of tuple $\vts$;
  \item determining whether $\vts$ is a list of the same size as $\vli$ yields $\True$\ProseOrTypeError;
  \item annotating each pattern in $\vli$ with the corresponding type in $\vts$ at each position $\vi$
        yields a pattern $\vlip[\vi]$\ProseOrTypeError;
  \item $\newli$ is the list of annotated patterns $\vlip[\vi]$ at the same positions those of $\vli$;
  \item $\newp$ is the pattern which matches the tuple $\newli$, that is, $\PatternTuple(\newli)$.
  \end{itemize}

\subsection{Example}

\CodeSubsection{\PTupleBegin}{\PTupleEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \checktrans{\astlabel(\vtstruct) = \TTuple}{TypeConflict} \checktransarrow \True \OrTypeError\\
  \vtstruct \eqname \TTuple(\vts)\\
  \checktrans{\equallength(\vli, \vts)}{InvalidArity} \checktransarrow \True \OrTypeError\\
  \vi\in\listrange(\vli): \annotatepattern(\tenv, \vts[\vi], \vli[\vi]) \typearrow \vlip[i] \OrTypeError\\
  \newli \eqdef \vi\in\listrange(\vli): \vlip[\vi]
}{
  \annotatepattern(\tenv, \vt, \PatternTuple(\vli)) \typearrow \PatternTuple(\newli)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Local Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatelocaldeclitem}{}
The function
\[
  \begin{array}{c}
  \annotatelocaldeclitem{
    \overname{\ty}{\tty} \aslsep
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\localdeclkeyword}{\ldk} \aslsep
    \overname{\localdeclitem}{\ldi}
   } \aslto\\
  (\overname{\staticenvs}{\newtenv} \aslsep \overname{\localdeclitem}{\newldi})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
  \end{array}
\]
annotates a local declaration item $\ldi$ with a local declaration keyword $\ldk$, given a type $\tty$,
in a static environment $\tenv$ results in $(\newenv, \newldi)$ where $\newenv$ is the modified
static environment and $\newldi$ is the annotated local declaration item.
A type error is returned, if one is detected.

One of the following applies:
\begin{itemize}
\item TypingRule.LDDiscard (see \secref{TypingRule.LDDiscard}),
\item TypingRule.LDVar (see \secref{TypingRule.LDVar}),
\item TypingRule.LDTyped (see \secref{TypingRule.LDTyped}),
\item TypingRule.LDTuple (see \secref{TypingRule.LDTuple}).
\end{itemize}

\lrmcomment{This is related to \identr{YSPM}.}

\section{TypingRule.LDDiscard \label{sec:TypingRule.LDDiscard}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ldi$ is a local declaration which can be discarded, that is, $\LDIDiscard(\None)$;
  \item $\newenv$ is $\tenv$;
  \item $\newldi$ is $\ldi$.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDDiscard.asl}

\CodeSubsection{\LDDiscardBegin}{\LDDiscardEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \annotatelocaldeclitem{\tenv, \tty, \LDIDiscard(\None), \ldk} \typearrow (\tenv, \ldi)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LDVar \label{sec:TypingRule.LDVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ldi$ denotes a variable $\vx$, that is, $\LDIVar(\vx)$;
  \item determining whether $\vx$ is not declared in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newenv$ is $\tenv$ modified so that $\vx$ is locally declared to have type $\tty$;
  \item $\newldi$ is the declaration of variable $\vx$.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDVar.asl}

\CodeSubsection{\LDVarBegin}{\LDVarEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checkvarnotinenv{\tenv, \vx} \typearrow \True \OrTypeError\\
  \addlocal(\tenv, \vx, \tty, \ldk) \typearrow \newtenv
}{
  \annotatelocaldeclitem{\tenv, \tty, \LDIVar(\vx), \ldk} \typearrow (\newtenv, \LDIVar(\vx))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{YSPM}, \identd{FXST}.}

\section{TypingRule.LDTyped\label{sec:TypingRule.LDTyped}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ldi$ denotes a local declaration item $\ldip$ with local declaration keyword $\ldk$
  and a type $\vt$, that is $\LDITyped(\ldip, \vt)$;
  \item annotating the type $\vt$ in $\tenv$ yields $\vtp$\ProseOrTypeError;
  \item determining whether $\vtp$ can be initialized with $\tty$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the local declaration item $\ldip$ with the local declaration keyword $\ldk$, given
  the type $\vt$, in the environment $\tenv$, yields $(\newtenv,\newldip)$;
  \item $\newldi$ is the local declaration denoting $\newldip$ and the type $\vtp$, that is, \\
  $\LDITyped(\newldip, \vtp)$.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDTyped.asl}

\CodeSubsection{\LDTypedBegin}{\LDTypedEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \vt} \typearrow \vtp \OrTypeError\\
  \canbeinitializedwith(\tenv, \vtp, \tty) \typearrow \True \OrTypeError\\
  \annotatelocaldeclitem{\tenv, \vtp, \ldip, \ldk} \typearrow (\newtenv, \newldip) \OrTypeError
}
{
  \annotatelocaldeclitem{\tenv, \tty, \LDITyped(\ldip, \vt), \ldk} \typearrow \\
  (\newtenv, \LDITyped(\newldip, \vtp))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LDTuple\label{sec:TypingRule.LDTuple}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ldi$ denotes a tuple of local declaration items $\ldi_{1..k}$, that is, $\LDITuple(\ldi_{1..k})$;
  \item determining the \structure\ of $\tty$ in $\tenv$ yields $\vtp$\ProseOrTypeError;
  \item determining whether $\vtp$ is a tuple type yields $\True$\ProseOrTypeError;
  \item determining whether $\vtp$ the number of elements of $vtp$ is $k$ yields $\True$\ProseOrTypeError;
  \item annotating the local declaration items in $\ldis$ from right to left with their corresponding
        (that is, with the same index) types $t_{1..k}$ in $\tenv$,
        propagating static environments from one annotation to the next,
        yields the local declaration items $\ldip_{1..k}$\ProseOrTypeError;
  \item $\newtenv$ is the static environment yielded by annotating $\ldi_1$;
  \item $\newldi$ is a tuple of local declaration items with $\ldip_{1..k}$, that is, \\
        $\LDITuple(\ldip_{1..k})$.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDTuple.asl}

\CodeSubsection{\LDTupleBegin}{\LDTupleEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \tty) \typearrow \vtp \OrTypeError\\\\
  \checktrans{\astlabel(\vtp) = \TTuple}{TupleTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \vtp \eqname \TTuple([\vt_{1..n}])\\\\
  \checktrans{k = n}{InvalidArity} \checktransarrow \True \OrTypeError\\\\
  \newtenv_k = \tenv\\
  i=k..1:
  \annotatelocaldeclitem{\newtenv_{i}, \vt_{i}, \ldi_{i}, \ldk} \typearrow (\newtenv_{i-1}, \ldip_i) \OrTypeError\\\\
  \newtenv = \newtenv_0
}{
  \annotatelocaldeclitem{\tenv, \tty, \LDITuple(\ldi_{1..k}), \ldk} \typearrow \\
  (\newtenv, \LDITuple(\ldip_{1..k}))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Statements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The function
\[
  \annotatestmt{\overname{\staticenvs}{\tenv} \aslsep \overname{\stmt}{\vs}} \aslto
  (\overname{\stmt}{\news}\aslsep \overname{\staticenvs}{\newenv})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a statement $\vs$ in an environment $\tenv$, resulting in the annotated statement
$\news$ and a modified environment $\newenv$. The result is a type error, if one is detected.

One of the following applies:
\begin{itemize}
  \item TypingRule.SPass (see \secref{TypingRule.SPass}),
  \item TypingRule.SAssign (see \secref{TypingRule.SAssign}),
  \item TypingRule.SReturnNone (see \secref{TypingRule.SReturnNone}),
  \item TypingRule.SReturnOne (see \secref{TypingRule.SReturnOne}),
  \item TypingRule.SReturnSome (see \secref{TypingRule.SReturnSome}),
  \item TypingRule.SSeq (see \secref{TypingRule.SSeq}),
  \item TypingRule.SCall (see \secref{TypingRule.SCall}),
  \item TypingRule.SCond (see \secref{TypingRule.SCond}),
  \item TypingRule.SCase (see \secref{TypingRule.SCase}),
  \item TypingRule.SAssert (see \secref{TypingRule.SAssert}),
  \item TypingRule.SWhile (see \secref{TypingRule.SWhile}),
  \item TypingRule.SRepeat (see \secref{TypingRule.SRepeat}),
  \item TypingRule.SFor (see \secref{TypingRule.SFor}),
  \item TypingRule.SThrowNone (see \secref{TypingRule.SThrowNone}),
  \item TypingRule.SThrowSome (see \secref{TypingRule.SThrowSome}),
  \item TypingRule.STry (see \secref{TypingRule.STry}).
  \item TypingRule.SDeclSome (see \secref{TypingRule.SDeclSome}),
  \item TypingRule.SDeclNone (see \secref{TypingRule.SDeclNone}).
\end{itemize}

We also define the following helper functions:
\begin{itemize}
  \item TypingRule.CaseAlt (see \secref{TypingRule.CaseAlt}),
  \item TypingRule.SForConstraints (see \secref{TypingRule.SForConstraints}),
  \item TypingRule.MinConstraints (see \secref{TypingRule.MinConstraints}),
  \item TypingRule.MaxConstraints (see \secref{TypingRule.MaxConstraints}),
  \item TypingRule.MinConstraint (see \secref{TypingRule.MinConstraint}),
  \item TypingRule.MaxConstraint (see \secref{TypingRule.MaxConstraint}).
\end{itemize}

\section{TypingRule.SPass \label{sec:TypingRule.SPass}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a pass statement, that is, $\SPass$;
  \item $\news$ is $\vs$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SPassBegin}{\SPassEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}{\annotatestmt{\tenv, \SPass} \typearrow (\SPass,\tenv)}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SAssign \label{sec:TypingRule.SAssign}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is an assignment \texttt{le = re}, that is, $\SAssign(\vle, \vre)$;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{setter}):
    \begin{itemize}
      \item reducing $(\tenv, \vle, \vre)$ to a setter call via \\ $\inlinesetter{}$ yields the statement $\news$
      (indicating that the assignment corresponds to setter)\ProseOrTypeError;
      \item $\newenv$ is $\tenv$.
    \end{itemize}

    \item All of the following apply (\textsc{non\_setter}):
    \begin{itemize}
      \item reducing $(\tenv, \vle, \vre)$ to a setter call via \\ $\inlinesetter{}$ yields $\None$
            (indicating the assignment does not correspond to a setter);
      \item annotating the right-hand-side expression $\vre$ in $\tenv$ yields $(\vtre, \vreone)$\ProseOrTypeError;
      \item annotating the left-hand-side expression $\vle$ with the type $\vtre$ in $\tenv$ yields $\vleone$\ProseOrTypeError;
      \item $\news$ is the assignment \texttt{le1 = re1}, that is, $\SAssign(\vleone, \vreone)$;
      \item $\newenv$ is $\tenv$.
    \end{itemize}

  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\SAssignBegin}{\SAssignEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[setter]{
  \inlinesetter{\tenv, \vle, \vre} \typearrow \langle \news \rangle \OrTypeError\\
}{
  \annotatestmt{\tenv, \overname{\SAssign(\vle, \vre)}{\vs}} \typearrow (\news,\overname{\tenv}{\newtenv})
}
\and
\inferrule[non\_setter]{
  \inlinesetter{\tenv, \vle, \vre} \typearrow \langle \rangle \OrTypeError\\
  \annotateexpr{\tenv, \vre} \typearrow (\vtre, \vreone) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vle, \vtre} \typearrow \vleone \OrTypeError
}{
  \annotatestmt{\tenv, \overname{\SAssign(\vle, \vre)}{\vs}} \typearrow (\overname{\SAssign(\vleone, \vreone)}{\news},\overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SReturnNone \label{sec:TypingRule.SReturnNone}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
  \item the enclosing subprogram does not have a \texttt{return} type (it is either a setter
        or a procedure);
  \item $\news$ is a \texttt{return} statement with no expression, that is, $\SReturn(\None)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SReturnNoneBegin}{\SReturnNoneEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\returntype = \None
}{
  \annotatestmt{\tenv, \overname{\SReturn(\None)}{\vs}} \typearrow (\overname{\SReturn(\None)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{FTPK}.}

\section{TypingRule.SReturnOne \label{sec:TypingRule.SReturnOne}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{return\_expr\_no\_return\_type}):
    \begin{itemize}
      \item $\vs$ is a \texttt{return} statement with some expression;
      \item the enclosing subprogram does not have a return type;
    \end{itemize}
    \item All of the following apply (\textsc{return\_type\_no\_return\_expr}):
    \begin{itemize}
      \item $\vs$ is a \texttt{return} statement with no expression;
      \item the enclosing subprogram has a returned type;
    \end{itemize}
  \end{itemize}
  \item the result is an error indicating the mismatch between the declared (existence of the) return type
        and the (existence of the) return expression.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SReturnOneBegin}{\SReturnOneEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[return\_expr\_no\_return\_type]{
  L^\tenv.\returntype = \None
}{
  \annotatestmt{\tenv, \overname{\SReturn(\langle\Ignore\rangle)}{\vs}} \typearrow \TypeErrorVal{InvalidReturnStmt}
}
\and
\inferrule[return\_type\_no\_return\_expr]{
  L^\tenv.\returntype = \langle\Ignore\rangle
}{
  \annotatestmt{\tenv, \overname{\SReturn(\None)}{\vs}} \typearrow \TypeErrorVal{InvalidReturnStmt}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{FTPK}.}

\section{TypingRule.SReturnSome \label{sec:TypingRule.SReturnSome}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{return} statement with an expression $\ve$, that is, $\SReturn(\langle \vep \rangle)$;
  \item the enclosing subprogram has a return type $\vt$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tep,\vep)$\ProseOrTypeError;
  \item checking whether $\vtep$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is a \texttt{return} statement with value $\vep$, that is, $\SReturn(\langle \vep \rangle)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SReturnSomeBegin}{\SReturnSomeEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\returntype = \langle \vt \rangle\\
  \annotateexpr{\tenv, \ve} \typearrow (\vtep, \vep) \OrTypeError\\\\
  \checktypesat(\tenv, \vtep, \vt) \typearrow \True \OrTypeError
}{
  \annotatestmt{\tenv, \overname{\SReturn(\langle \ve \rangle)}{\vs}} \typearrow
  (\overname{\SReturn(\langle \vep \rangle)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{FTPK}.}

\section{TypingRule.SSeq \label{sec:TypingRule.SSeq}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is the AST node for the sequence of statements $\vsone$ and $\vstwo$, that is, $\SSeq(\vsone, \vstwo)$;
  \item annotating $\vsone$ in $\tenv$ yields $(\newsone, \tenvone)$\ProseOrTypeError;
  \item annotating $\vstwo$ in $\tenvone$ yields $(\newstwo, \newtenv)$\ProseOrTypeError;
  \item $\news$ is the AST node for the sequence of statements $\newsone$ and $\newstwo$, that is, $\SSeq(\newsone, \newstwo)$.
\end{itemize}

\subsection{Example}


\CodeSubsection{\SSeqBegin}{\SSeqEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatestmt{\tenv, \vs1} \typearrow (\newsone, \tenvone) \OrTypeError\\\\
  \annotatestmt{\tenvone, \vs2} \typearrow (\newstwo, \newtenv) \OrTypeError
}{
  \annotatestmt{\tenv, \overname{\SSeq(\vsone, \vstwo)}{\vs}} \typearrow (\overname{\SSeq(\newsone, \newstwo)}{\news}, \newtenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SCall \label{sec:TypingRule.SCall}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a call to a subprogram named $\name$ with arguments $\vargs$;
  \item annotating the call to $\name$ with arguments $\vargs$, as a procedure (that is, with $\STProcedure$),
        as per \chapref{TypingSubprogramCalls} (which makes sure that the call does not have a return type),
        yields $(\newname, \newargs, \neweqs)$\ProseOrTypeError;
  \item $\news$ is the call to a subprogram named $\newname$ with arguments
        $\newargs$ and parameter assignments $\neweqs$;
  \item $\newtenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SCallBegin}{\SCallEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatecall{\tenv, \name, \vargs, \STProcedure} \typearrow (\newname, \newargs, \neweqs)
}{
  \annotatestmt{\tenv, \overname{\SCall(\name, \vargs)}{\vs}} \typearrow (\overname{\SCall(\newname, \newargs, \neweqs)}{\news}, \tenv)
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identd{VXKM}.}

\section{TypingRule.SCond \label{sec:TypingRule.SCond}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a condition $\ve$ with the statements $\vsone$ and $\vstwo$, that is, $\SCond(\ve, \vsone, \vstwo)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tcond, \econd)$\ProseOrTypeError;
  \item checking that $\tcond$ \typesatisfies\ $\TBool$ yields $\True$\ProseOrTypeError;
  \item annotating the statement $\vsone$ in $\tenv$ yields $\vsonep$\ProseOrTypeError;
  \item annotating the statement $\vstwo$ in $\tenv$ yields $\vstwop$\ProseOrTypeError;
  \item $\news$ is the condition $\econd$ with the statements $\vsonep$ and $\vstwop$, that is, \\ $\SCond(\econd, \vsonep, \vstwop)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SCondBegin}{\SCondEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\tcond, \econd) \OrTypeError\\\\
  \checktypesat(\tenv, \tcond, \TBool) \typearrow \True \OrTypeError\\\\
  \annotateblock{\tenv, \vsone} \typearrow \vsonep \OrTypeError\\\\
  \annotateblock{\tenv, \vstwo} \typearrow \vstwop \OrTypeError
}{
  \annotatestmt{\tenv, \overname{\SCond(\ve, \vsone, \vstwo)}{\vs}} \typearrow
  (\overname{\SCond(\econd, \vsonep, \vstwop)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{NBDJ}.}

\section{TypingRule.SCase \label{sec:TypingRule.SCase}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a case statement with expression $\ve$ and case clauses $\vcases$, that is, \\
        $\SCase(\veone, \vcasesone)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte, \veone)$\ProseOrTypeError;
  \item annotating each case clause as per \secref{TypingRule.CaseAlt} in $\vcases$ yields the annotated list of clauses $\vcasesone$\ProseOrTypeError;
  \item $\news$ is a case statement with expression $\veone$ and case clauses $\vcasesone$;
  \item $\newenv$ is $\tenvone$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SCaseBegin}{\SCaseEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \veone) \OrTypeError\\\\
  \vi\in\listrange(\vcases): \annotatecase{\tenv, \vcases[\vi]} \typearrow \vcase_\vi \OrTypeError\\\\
  \vcasesone \eqdef [\vi\in\listrange(\vcases): \vcase_\vi]
}{
  \annotatestmt{\tenv, \overname{\SCase(\ve, \vcases)}{\vs}} \typearrow
  (\overname{\SCase(\veone, \vcasesone)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{WGSY}.}

\section{TypingRule.SAssert \label{sec:TypingRule.SAssert}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is an assert statement with expression $\ve$, that is, $\SAssert(\ve)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\tep,\vep)$\ProseOrTypeError;
  \item checking that $\vtep$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is an assert statement with expression $\vep$, that is, $\SAssert(\vep)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SAssertBegin}{\SAssertEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vtep, \vep) \OrTypeError\\
  \checktypesat(\tenv, \vtep, \TBool) \typearrow \True \OrTypeError
}{
  \annotatestmt{\tenv, \overname{\SAssert(\ve)}{\vs}} \typearrow (\overname{\SAssert(\vep)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{JQYF}.}

\section{TypingRule.SWhile \label{sec:TypingRule.SWhile}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vs$ is a \texttt{while} statement with expression $\veone$ and statement block $\vsone$, that is, \\
      $\SWhile(\veone, \vsone)$;
\item annotating the right-hand-side expression $\veone$ in $\tenv$ yields $(\vt, \vetwo)$\ProseOrTypeError;
\item checking that $\vt$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
\item $\news$ is a \texttt{while} statement with expression $\vetwo$ and statement block $\vstwo$, that is, $\SWhile(\vetwo, \vstwo)$;
\item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SWhileBegin}{\SWhileEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\
  \annotateblock{\tenv, \vsone} \typearrow \vstwo \OrTypeError
}{
  \annotatestmt{\tenv, \overname{\SWhile(\veone, \vsone)}{\vs}} \typearrow (\overname{\SWhile(\vetwo, \vstwo)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{FTVN}.}

\section{TypingRule.SRepeat \label{sec:TypingRule.SRepeat}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{repeat} statement with expression $\veone$ and statement block $\vsone$, that is, \\
        $\SRepeat(\vetwo, \vstwo)$;
  \item annotating $\vsone$ as a block statement in $\tenv$ yields $\vstwo$\ProseOrTypeError;
  \item annotating the right-hand-side expression $\veone$ in $\tenv$ yields $(\vt, \vetwo)$\ProseOrTypeError;
  \item checking that $\vt$ \typesatisfies\ $\TBool$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\news$ is a \texttt{repeat} statement with expression $\vetwo$ and statement block $\vstwo$, that is, $\SRepeat(\vetwo, \vstwo)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SRepeatBegin}{\SRepeatEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateblock{\tenv, \vsone} \typearrow \vstwo \OrTypeError\\\\
  \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo) \OrTypeError\\\\
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError
}{
  \annotatestmt{\tenv, \overname{\SRepeat(\veone, \vsone)}{\vs}} \typearrow
  (\overname{\SRepeat(\vetwo, \vstwo)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{FTVN}.}

\section{TypingRule.SFor \label{sec:TypingRule.SFor}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a \texttt{for} statement with index $\id$, direction $\dir$, start expression
        $\veone$, end expression $\vetwo$, and a body statement (block) $\vsp$, that is, $\SFor(\id, \dir, \veone, \vetwo, \vsp)$;
  \item annotating the right-hand-side expression $\veone$ in $\tenv$ yields $(\vtone, \veonep)$\ProseOrTypeError;
  \item annotating the right-hand-side expression $\vetwo$ in $\tenv$ yields $(\vttwo, \vetwop)$\ProseOrTypeError;
  \item obtaining the \wellconstrainedversion\ of $\vtone$ in $\tenv$ yields $\structone$;
  \item obtaining the \wellconstrainedversion\ of $\vttwo$ in $\tenv$ yields $\structtwo$;
  \item obtaining the constraints on the loop index $\id$ from $\structone$, $\structtwo$, and $\dir$ in $\tenv$
        via $\getforconstraints$ yields $\vcs$\ProseOrTypeError;
  \item $\tty$ is the integer type with constraints $\vcs$;
  \item checking that $\id$ is not already declared in $\tenv$ yields $\True$\ProseOrTypeError;
  \item adding $\id$ as a local immutable variable with type $\tty$ to $\tenv$ yields $\tenvp$;
  \item annotating $\vsp$ as a block statement in $\tenvp$ yields $\vspp$\ProseOrTypeError;
  \item $\news$ is the \texttt{for} statement with index $\id$, direction $\dir$, start expression $\veonep$,
        end expression $\vetwop$, and the body statement (block) $\vspp$, that is, \\
        $\SFor(\id, \veonep, \dir, \vetwop, \vspp)$;
  \item $\newtenv$ is $\tenv$ (notice that this means $\id$ is only declared for annotating $\vsp$ but then goes
        out of scope).
\end{itemize}

% \begin{itemize}
% \item $\vs$ is a \texttt{for} statement with index \texttt{id}, direction \texttt{dir}, two expressions
%   $\veone$ and \vetwo and a statement block \texttt{s'};
% \item \texttt{t1,e1'} is the result of annotating $\veone$ in $\tenv$;
% \item \texttt{t2,e2'} is the result of annotating \vetwo in $\tenv$;
% \item an error is returned: ``\texttt{ASL Typing Error : A subtype of integer was expected, t1 was provided}'' or $\vtone$ has the structure of an integer type and all of the following apply:
% \item an error is returned: ``\texttt{ASL Typing Error : A subtype of integer was expected, t2 was provided}'' or $\vttwo$ has the structure of an integer type and all of the following apply:
% \item One of the following applies:
%   \begin{itemize}
%     \item All of the following apply:
%       \begin{itemize}
%         \item $\vtone$ has the structure of an unconstrained integer type;
%         \item $\tty$ is the unconstrained integer type;
%       \end{itemize}
%     \item All of the following apply:
%       \begin{itemize}
%         \item $\vttwo$ has the structure of an unconstrained integer type;
%         \item $\tty$ is the unconstrained integer type;
%       \end{itemize}
%     \item All of the following apply:
%       \begin{itemize}
%         \item $\vtone$ has the structure of a constrained integer type with constraint \texttt{cs1};
%         \item $\vttwo$ has the structure of a constrained integer type with constraint \texttt{cs2};
%         \item One of the following applies:
%           \begin{itemize}
%             \item All of the following apply:
%               \begin{itemize}
%                 \item \texttt{dir} is \texttt{to};
%                 \item \texttt{bot\_cs} is \texttt{cs1};
%                 \item \texttt{top\_cs} is \texttt{cs2};
%               \end{itemize}
%             \item All of the following apply:
%               \begin{itemize}
%                 \item \texttt{dir} is \texttt{down to};
%                 \item \texttt{bot\_cs} is \texttt{cs2};
%                 \item \texttt{top\_cs} is \texttt{cs1};
%               \end{itemize}
%           \end{itemize}
%         \item One of the following applies:
%           \begin{itemize}
%             \item All of the following apply:
%               \begin{itemize}
%                 \item \texttt{bot\_cs} contains a an expression that is not evaluable at compile-time;
%                 \item \texttt{cs} is the empty constraint;
%               \end{itemize}
%             \item All of the following apply:
%               \begin{itemize}
%                 \item \texttt{top\_cs} contains a an expression that is not evaluable at compile-time;
%                 \item \texttt{cs} is the empty constraint;
%               \end{itemize}
%             \item All of the following apply:
%               \begin{itemize}
%                 \item \texttt{bot} is the minimum of the constraints \texttt{bot\_cs};
%                 \item \texttt{top} is the maximum of the constraints \texttt{top\_cs};
%                 \item \texttt{bot} is less or equal than \texttt{top};
%                 \item \texttt{cs} is the constraint \texttt{bot .. top};
%               \end{itemize}
%             \item All of the following apply:
%               \begin{itemize}
%                 \item \texttt{bot} is the minimum of the constraints \texttt{bot\_cs};
%                 \item \texttt{top} is the maximum of the constraints \texttt{top\_cs};
%                 \item \texttt{top} is strictly less than \texttt{bot}
%                 \item \texttt{cs} is \texttt{cs1};
%               \end{itemize}
%           \end{itemize}
%         \item $\tty$ is the constrained integer type with constraint \texttt{cs};
%       \end{itemize}
%   \end{itemize}
% \item an error is returned ``\texttt{ASL Typing Error: cannot declare already \\ declared element "id".}'' or \texttt{id} is not bound in $\tenv$ and all of the following apply:
% \item $\tenvp$ is $\tenv$ modified so that \texttt{id} is locally declared of type $\tty$;
% \item \texttt{s''} is the result of annotating \texttt{s'} in $\tenvp$;
% \item $\news$ is a for statement with index \texttt{id}, direction \texttt{dir}, two expressions $\veonep$ and $\vetwop$ and statement \texttt{s''};
% \item $\newenv$ is $\tenv$.
% \end{itemize}

\subsection{Example}

\CodeSubsection{\SForBegin}{\SForEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veonep) \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwop) \OrTypeError\\\\
  \getwellconstrainedstructure(\tenv, \vtone) \typearrow \structone\\
  \getwellconstrainedstructure(\tenv, \vttwo) \typearrow \structtwo\\
  \getforconstraints(\tenv, \structone, \structtwo, \dir) \typearrow \vcs \OrTypeError\\\\
  \tty \eqdef \TInt(\vcs)\\
  \checkvarnotinenv{\tenv, \id} \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \tty, \id, \LDKLet) \typearrow \tenvp\\
  \annotateblock{\tenvp, \vsp} \typearrow \vspp \OrTypeError\\\\
  \news \eqdef \SFor(\id, \veonep, \dir, \vetwop, \vspp)
}{
  \annotatestmt{\tenv, \overname{\SFor(\id, \dir, \veone, \vetwo, \vsp)}{\vs}} \typearrow (\news, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{SSBD}, \identr{ZSND}, \identr{VTJW}.}

\section{TypingRule.SThrowNone \label{sec:TypingRule.SThrowNone}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a throw statement with no expression, that is, $\SThrow(\None)$;
  \item $\news$ is $\vs$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SThrowNoneBegin}{\SThrowNoneEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \annotatestmt{\tenv, \overname{\SThrow(\None)}{\vs}} \typearrow (\overname{\SThrow(\None)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  Note that \identr{BRCJ} is done in~\cite[SemanticsRule.TopLevel]{ASLSemanticsReference}.

\section{TypingRule.SThrowSome \label{sec:TypingRule.SThrowSome}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a throw statement with expression $\ve$, that is, $\SThrow(\langle (\ve, \Ignore) \rangle)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte, \vep)$\ProseOrTypeError;
  \item checking that $\vte$ has the structure of an exception type yields $\True$\ProseOrTypeError;
  \item $\news$ is a throw statement with expression $\vep$ and type $\vte$, that is, \\
        $\SThrow(\langle (\vep, \langle\vte\rangle) \rangle)$;
  \item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SThrowSomeBegin}{\SThrowSomeEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \checkstructurelabel(\tenv, \vte, \TException) \typearrow \True \OrTypeError
}{
  \annotatestmt{\tenv, \overname{\SThrow(\langle (\ve, \Ignore) \rangle)}{\vs}} \typearrow
  (\overname{\SThrow(\langle (\vep, \langle\vte\rangle) \rangle)}{\news}, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{NXRC}.}

\section{TypingRule.STry \label{sec:TypingRule.STry}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a try statement with statement $\vsp$, list of catchers $\catchers$ and an optional \texttt{otherwise} block;
  \item annotating the statement $\vsp$ as a block statement yields $\vspp$\ProseOrTypeError;
  \item annotating each catcher $\vc$ in $\catchers$ in $\tenv$ yields $\vcp$\ProseOrTypeError;
  \item $\catchersp$ is the list of annotated catchers $\vcp$ for each $\vc\in\catchers$;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{no\_otherwise}):
    \begin{itemize}
      \item there is no \texttt{otherwise} statement;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and no \texttt{otherwise} statement,
            that is \\
            $\STry(\vspp, \catchersp, \None)$;
    \end{itemize}

    \item All of the following apply (\textsc{otherwise}):
    \begin{itemize}
      \item there is an \texttt{otherwise} statement $\otherwise$;
      \item annotating the statement $\otherwise$ as a block statement in $\tenv$ yields $\otherwisep$\ProseOrTypeError;
      \item $\news$ is a try statement with statement $\vspp$, list catchers $\catchersp$ and \texttt{otherwise} statement
            $\otherwisep$, that is \\
            $\STry(\vspp, \catchersp, \langle\otherwisep\rangle)$;
    \end{itemize}
  \end{itemize}
  \item $\newenv$ is $\tenv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\STryBegin}{\STryEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[no\_otherwise]{
  \annotateblock{\tenv, \vsp} \typearrow \vspp \OrTypeError\\\\
  \vc \in \catchers: \annotatecatcher{\tenv, \vc} \typearrow \vcp \OrTypeError\\\\
  \catchersp \eqdef [\vc \in \catchers : \vcp]\\
  \news \eqdef \STry(\vspp, \catchersp, \None)
}{
  \annotatestmt{\tenv, \overname{\STry(\vsp, \catchers, \None)}{\vs}} \typearrow (\news, \overname{\tenv}{\newtenv})
}
\and
\inferrule[otherwise]{
  \annotateblock{\tenv, \vsp} \typearrow \vspp \OrTypeError\\\\
  \annotateblock{\tenv, \otherwise} \typearrow \otherwisep \OrTypeError\\\\
  \vc \in \catchers: \annotatecatcher{\tenv, \vc} \typearrow \vcp \OrTypeError\\\\
  \catchersp \eqdef [\vc \in \catchers : \vcp]\\
  \news \eqdef \STry(\vspp, \catchersp, \otherwise')
}{
  \annotatestmt{\tenv, \overname{\STry(\vsp, \catchers, \langle\otherwise\rangle)}{\vs}} \typearrow (\news, \overname{\tenv}{\newtenv})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{WVXS}.}

\section{TypingRule.SDeclSome \label{sec:TypingRule.SDeclSome}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vs$ is a declaration with local declaration keyword $\ldk$, local identifiers $\ldi$, and an expression $\ve$,
        that is, $\SDecl(\ldk, \ldi, \langle\ve\rangle)$;
  \item annotating the right-hand-side expression $\ve$ in $\tenv$ yields $(\vte,\vep)$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{constant}):
    \begin{itemize}
      \item $\ldk$ indicates a local constant declaration, that is, $\LDKConstant$;
      \item symbolically simplifying $\ve$ in $\tenv$ yields the literal $\vv$\ProseOrTypeError;
      \item declaring a local constant of type $\vte$, literal $\vv$ and identifier $\ldi$ in $\tenv$ yields $(\newtenv, \ldip)$;
      \item $\news$ is a declaration with $\ldk$, $\ldip$ and an expression $\vep$.
    \end{itemize}

    \item All of the following apply (\textsc{non\_constant}):
    \begin{itemize}
      \item $\ldk$ indicates that this is not a local constant declaration, that is, $\ldk\neq\LDKConstant$;
      \item declaring the local identifiers $\ldi$ of type $\vte$ with local declaration keyword $\ldk$ in $\tenv$
            yields $(\newtenv, \ldip)$;
      \item $\news$ is a declaration with $\ldk$, $\ldip$ and an expression $\vep$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\SDeclSomeBegin}{\SDeclSomeEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[constant]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \ldk =\LDKConstant\\
  \reduceconstants(\tenv, \ve) \typearrow \vv \OrTypeError\\\\
  \declarelocalconstant{\tenv, \vte, \vv, \ldi} \typearrow (\newtenv, \ldip)\\
  \news \eqdef \SDecl(\LDKConstant, \ldip, \langle\vep\rangle)
}{
  \annotatestmt{\tenv, \overname{\SDecl(\ldk, \ldi, \langle\ve\rangle)}{\vs}} \typearrow (\news, \newtenv)
}
\and
\inferrule[non\_constant]{
  \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep) \OrTypeError\\\\
  \ldk \neq \LDKConstant\\
  \annotatelocaldeclitem{\tenv, \vte, \ldk, \ldi} \typearrow (\newtenv, \ldip)\\
  \news \eqdef \SDecl(\LDKConstant, \ldip, \langle\vep\rangle)
}{
  \annotatestmt{\tenv, \overname{\SDecl(\ldk, \ldi, \langle\ve\rangle)}{\vs}} \typearrow (\news, \newtenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
\lrmcomment{This is related to \identr{YSPM}.}

\section{TypingRule.SDeclNone \label{sec:TypingRule.SDeclNone}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\vs$ is a local declaration statement with a variable keyword and local identifiers $\ldi$, and no initial expression,
      that is, $\SDecl(\LDKVar, \ldi, \None)$ (local declarations of \texttt{let} variables and constants require
      an initializing expression, otherwise they are rejected by an ASL parser);
\item annotating the uninitialised local declarations $\ldi$ in $\tenv$ yields $(\newtenv, \ldip)$;
\item $\news$ is a local declaration statement with variable keyword, local identifiers $\ldip$, and no initial expression,
      that is, $\SDecl(\LDKVar, \ldip, \None)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SDeclNoneBegin}{\SDeclNoneEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatelocaldeclitemuninit{\tenv, \ldi} \typearrow (\newtenv, \ldip) \OrTypeError\\\\
  \news \eqdef \SDecl(\LDKVar, \ldip, \None)
}{
  \annotatestmt{\tenv, \overname{\SDecl(\LDKVar, \ldi, \None)}{\vs}} \typearrow (\news, \newtenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.CaseAlt \label{sec:TypingRule.CaseAlt}}

\hypertarget{def-annotatecase}{}
The helper function
\[
  \annotatecase{
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\vte} \aslsep
    \overname{\casealt}{\vcase}
  } \aslto
  \overname{\casealt}{\vcaseone} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the case clause $\vcase$ for matching an expression of type $\vte$ in $\tenv$,
resulting in the annotated case clause $\vcaseone$, or a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vcase$ is a case clause with pattern $\vpzero$, optional \texttt{where} expression $\vwzero$,
        and \texttt{otherwise} statement $\vszero$, that is,
        $\{ \text{pattern} : \vpzero, \text{where} : \vwzero, \text{stmt} : \vszero \}$;
  \item annotating the pattern $\vpzero$ with type $\vte$ in $\tenv$ yields $\vpone$\ProseOrTypeError;
  \item annotating the statement $\vszero$ as a block statement in $\tenv$ yields $\vsone$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{no\_where}):
    \begin{itemize}
      \item $\vwzero$ is $\None$ (that is, no \texttt{where} expression);
      \item $\vcaseone$ is $\{ \text{pattern} : \vpone, \text{where} : \None, \text{stmt} : \vsone \}$.
    \end{itemize}

    \item All of the following apply (\textsc{where}):
    \begin{itemize}
      \item $\vwzero$ is the expression $\vewzero$;
      \item annotating the expression $\vewzero$ in $\tenv$ yields $(\vtwe, \vewone)$\ProseOrTypeError;
      \item checking whether the structure of $\vtwe$ in $\tenv$ is that of the \texttt{boolean} type yields $\True$\ProseOrTypeError;
      \item $\vcaseone$ is $\{ \text{pattern} : \vpone, \text{where} : \langle\vewone\rangle, \text{stmt} : \vsone \}$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[no\_where]{
  \vcase \eqname \{ \text{pattern} : \vpzero, \text{where} : \None, \text{stmt} : \vszero \}\\
  \annotatepattern(\tenv, \vte, \vpzero) \typearrow \vpone \OrTypeError\\\\
  \annotateblock{\tenv, \vszero} \typearrow \vsone \OrTypeError\\
}{
  \annotatecase{\tenv, \vcase} \typearrow \{ \text{pattern} : \vpone, \text{where} : \None, \text{stmt} : \vsone \}
}
\and
\inferrule[where]{
  \vcase \eqname \{ \text{pattern} : \vpzero, \text{where} : \langle\vewzero\rangle, \text{stmt} : \vszero \}\\
  \annotatepattern(\tenv, \vte, \vpzero) \typearrow \vpone \OrTypeError\\\\
  \annotateblock{\tenv, \vszero} \typearrow \vsone \OrTypeError\\\\
  \annotateexpr{\tenv, \vewzero} \typearrow (\vtwe, \vewone) \OrTypeError\\\\
  \checkstructurelabel(\tenv, \vtwe, \TBool) \typearrow \True \OrTypeError
}{
  \annotatecase{\tenv, \vcase} \typearrow \{ \text{pattern} : \vpone, \text{where} : \langle\vewone\rangle, \text{stmt} : \vsone \}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SForConstraints \label{sec:TypingRule.SForConstraints}}
\hypertarget{def-getforconstraints}{}
\newcommand\minmaxtop[0]{\texttt{MinMaxTop}}
The function
\[
  \getforconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\structone} \aslsep
    \overname{\ty}{\structtwo} \aslsep
    \overname{\dir}{\dir}
  ) \aslto
  \begin{array}{c}
    \overname{\left\{
      \begin{array}{c}
        \unconstrained,\\
        \wellconstrained(\intconstraint^+),\\
        \underconstrained(\identifier)
      \end{array}
    \right\}}{\vcs} \\
    \cup\ \overname{\TTypeError}{\TypeErrorConfig}
    \end{array}
\]
infers the constraints --- $\vcs$ --- for a \texttt{for} loop index variable from the
\wellconstrainedversion\ of the type of the start expression --- $\structone$ ---
and the \wellconstrainedversion\ of the type of the end expression --- $\structtwo$.
A type error is returned, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{non\_integer\_error}):
  \begin{itemize}
    \item at least one of $\structone$ and $\structtwo$ is not an integer type;
    \item the result is a type error indicating that an integer-typed expression is expected.
  \end{itemize}

  \item All of the following apply (\textsc{unconstrained}):
  \begin{itemize}
    \item both $\structone$ and $\structtwo$ are integer types;
    \item either one of $\structone$ and $\structtwo$ is an unconstrained integer;
    \item $\vc$ is $\unconstrained$.
  \end{itemize}

  \item All of the following apply (\textsc{well\_constrained\_int\_range}):
  \begin{itemize}
    \item $\structone$ is an integer type with constraint $\vcone$;
    \item $\structtwo$ is an integer type with constraint $\vctwo$;
    \item the pair $(\botcs, \topcs)$ is defined to be $(\csone, \cstwo)$ if $\dir$ is $\UP$ and $(\cstwo, \csone)$, otherwise;
    \item obtaining the minimum of $\botcs$ via $\minconstraints$ in $\tenv$ yields an integer $\vbot$;
    \item obtaining the maximum of $\topcs$ via $\maxconstraints$ in $\tenv$ yields an integer $\vvtop$;
    \item $\vbot$ is less than or equal to $\vvtop$;
    \item $\vc$ is the well-constrained range between between the literal integer expression for $\vbot$ and
          the literal integer expression for $\vvtop$, that is, \\
          $\wellconstrained([\ConstraintRange(\ELInt{\vbot}, \ELInt{\vvtop})])$;
  \end{itemize}

  \item All of the following apply (\textsc{well\_constrained\_int\_reverse\_range}):
  \begin{itemize}
    \item $\structone$ is an integer type with constraint $\vcone$;
    \item $\structtwo$ is an integer type with constraint $\vctwo$;
    \item the pair $(\botcs, \topcs)$ is defined to be $(\csone, \cstwo)$ if $\dir$ is $\UP$ and $(\cstwo, \csone)$, otherwise;
    \item obtaining the minimum of $\botcs$ via $\minconstraints$ in $\tenv$ yields an integer $\vbot$;
    \item obtaining the maximum of $\topcs$ via $\maxconstraints$ in $\tenv$ yields an integer $\vvtop$;
    \item $\vbot$ is greater than $\vvtop$;
    \item $\vc$ is the well-constrained constraint for $\csone$, that is, \\
          $\wellconstrained(\csone)$;
  \end{itemize}

  \item All of the following apply (\textsc{well\_constrained\_int\_symbolic\_range}):
  \begin{itemize}
    \item $\structone$ is a well-constrained integer with constraints $\csone$;
    \item $\structtwo$ is a well-constrained integer with constraints $\cstwo$;
    \item the pair $(\botcs, \topcs)$ is defined to be $(\csone, \cstwo)$ if $\dir$ is $\UP$ and $(\cstwo, \csone)$, otherwise;
    \item obtaining the minimum of $\botcs$ via $\minconstraints$ in $\tenv$ yields $\vbot$;
    \item obtaining the maximum of $\topcs$ via $\maxconstraints$ in $\tenv$ yields $\vvtop$;
    \item at least one of $\vbot$ and $\vvtop$ is not an integer;
    \item $\botcs$ is a single exact constraint with expression $\ebot$;
    \item $\topcs$ is a single exact constraint with expression $\etop$;
    \item $\vc$ is the single (well-constrained) range constraint for from $\ebot$ to $\etop$, that is, \\
          $\wellconstrained([\ConstraintRange(\ebot, \etop)])$
  \end{itemize}

  \item All of the following apply (\textsc{well\_constrained\_else}):
  \begin{itemize}
    \item $\structone$ is a well-constrained integer with constraints $\csone$;
    \item $\structtwo$ is a well-constrained integer with constraints $\cstwo$;
    \item the pair $(\botcs, \topcs)$ is defined to be $(\csone, \cstwo)$ if $\dir$ is $\UP$ and $(\cstwo, \csone)$, otherwise;
    \item obtaining the minimum of $\botcs$ via $\minconstraints$ in $\tenv$ yields $\vbot$;
    \item obtaining the maximum of $\topcs$ via $\maxconstraints$ in $\tenv$ yields $\vvtop$;
    \item at least one of $\vbot$ and $\vvtop$ is not an integer;
    \item at least one of $\botcs$ and $\topcs$ is not a single exact constraint;
    \item $\vc$ is $\unconstrained$
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[non\_integer\_error]{
    \astlabel(\structone) \neq \TInt \land \astlabel(\structtwo) \neq \TInt
}{
  \getforconstraints(\tenv, \structone, \structtwo, \dir) \typearrow \\
  \TypeErrorVal{IntegerTypeExpected}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  \astlabel(\vcone) = \unconstrained \lor \astlabel(\vctwo) = \unconstrained
}{
  \getforconstraints(\tenv, \overname{\TInt(\vcone)}{\structone}, \overname{\TInt(\vctwo)}{\structtwo}, \dir) \typearrow
  \overname{\unconstrained}{\vc}
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained\_int\_range]{
    \astlabel(\vcone) = \wellconstrained(\csone) \land \astlabel(\vctwo) = \wellconstrained(\cstwo)\\
    (\botcs, \topcs) \eqdef \choice{\dir = \UP}{(\csone, \cstwo)}{(\cstwo, \csone)}\\
    \minconstraints(\tenv, \botcs) \typearrow \vbot \in \Z\\
    \maxconstraints(\tenv, \topcs) \typearrow \vvtop \in \Z\\
    \vbot \leq \vvtop\\
    \vc \eqdef \wellconstrained([\ConstraintRange(\ELInt{\vbot}, \ELInt{\vvtop})])
}{
  \getforconstraints(\tenv, \overname{\TInt(\vcone)}{\structone}, \overname{\TInt(\vctwo)}{\structtwo}, \dir) \typearrow \vc
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained\_int\_reverse\_range]{
    \astlabel(\vcone) = \wellconstrained(\csone) \land \astlabel(\vctwo) = \wellconstrained(\cstwo)\\
    (\botcs, \topcs) \eqdef \choice{\dir = \UP}{(\csone, \cstwo)}{(\cstwo, \csone)}\\
    \minconstraints(\tenv, \botcs) \typearrow \vbot \in \Z\\
    \maxconstraints(\tenv, \topcs) \typearrow \vvtop \in \Z\\
    \vbot > \vvtop
}{
  \getforconstraints(\tenv, \overname{\TInt(\vcone)}{\structone}, \overname{\TInt(\vctwo)}{\structtwo}, \dir) \typearrow
  \overname{\wellconstrained(\csone)}{\vc}
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained\_int\_symbolic\_range]{
    \astlabel(\vcone) = \wellconstrained(\csone) \land \astlabel(\vctwo) = \wellconstrained(\cstwo)\\
    (\botcs, \topcs) \eqdef \choice{\dir = \UP}{(\csone, \cstwo)}{(\cstwo, \csone)}\\
    \minconstraints(\tenv, \botcs) \typearrow \vbot\\
    \maxconstraints(\tenv, \topcs) \typearrow \vvtop\\
    (\vbot \not\in \Z \lor \vvtop \not\in \Z)\\
    \botcs = [\ConstraintExact(\ebot)]\\
    \topcs = [\ConstraintExact(\etop)]\\
    \vc \eqdef \wellconstrained([\ConstraintRange(\ebot, \etop)])
}{
  \getforconstraints(\tenv, \overname{\TInt(\vcone)}{\structone}, \overname{\TInt(\vctwo)}{\structtwo}, \dir) \typearrow \vc
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained\_else]{
  \astlabel(\vcone) = \wellconstrained(\csone) \land \astlabel(\vctwo) = \wellconstrained(\cstwo)\\
  (\botcs, \topcs) \eqdef \choice{\dir = \UP}{(\csone, \cstwo)}{(\cstwo, \csone)}\\
  \minconstraints(\tenv, \botcs) \typearrow \vbot\\
  \maxconstraints(\tenv, \topcs) \typearrow \vvtop\\
  (\vbot \not\in \Z \lor \vvtop \not\in \Z)\\
  (\botcs \neq [\ConstraintExact(\Ignore)] \lor \botcs \neq [\ConstraintExact(\Ignore)])
}{
  \getforconstraints(\tenv, \overname{\TInt(\vcone)}{\structone}, \overname{\TInt(\vctwo)}{\structtwo}, \dir) \typearrow \overname{\unconstrained}{\vc}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.MinConstraints \label{sec:TypingRule.MinConstraints}}
The function
\hypertarget{def-minconstraints}{}
\[
  \minconstraints(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint^*}{\vcs}) \aslto
  \overname{\overname{\Z}{\vi} \cup \{\minmaxtop\}}{r}
\]
operate over a list of constraints $\vcs$ to find whether there is an integer $\vi$ that represents the
minimal value of all the constraints. Otherwise, the result is the special value $\minmaxtop$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\vcs$ consists of a single constraint $\vc$;
    \item $r$ is the result of finding the minimal constraint in $\vc$ via $\minconstraint$.
  \end{itemize}

  \item All of the following apply (\textsc{head\_tail}):
  \begin{itemize}
    \item $\vcs$ is a list consisting of a constraint $\vc_1$ followed by a non-empty list of constraints $\vc_{2..k}$;
    \item finding the minimal constraint in $\vc_1$ via $\minconstraint$ results in the integer $a$ or $\minmaxtop$,
          which short-circuits the entire rule;
    \item finding the minimal constraints in $\vc_{2..k}$ via $\minconstraints$ results in the integer $b$ or $\minmaxtop$,
          which short-circuits the entire rule;
    \item $r$ is the minimum of $a$ and $b$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[single]{
  \minconstraint(\tenv, \vc) \typearrow r
}{
  \minconstraints(\tenv, [\vc]) \typearrow r
}
\and
\inferrule[head\_tail]{
  k > 1\\
  \minconstraint(\tenv, \vc_1) \typearrow a \terminateas \minmaxtop\\\\
  \minconstraints(\tenv, \vc_{2..k}) \typearrow b \terminateas \minmaxtop
}{
  \minconstraints(\tenv, [\vc_{1..k}]) \typearrow \overname{\min\{a,b\}}{r}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.MaxConstraints \label{sec:TypingRule.MaxConstraints}}
The function
\hypertarget{def-maxconstraints}{}
\[
  \maxconstraints(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint^*}{\vcs}) \aslto
  \overname{\overname{\Z}{\vi} \cup \{\minmaxtop\}}{r}
\]
operate over a list of constraints $\vcs$ to find whether there is an integer $\vi$ that represents the
maximal value of all the constraints. Otherwise, the result is the special value $\minmaxtop$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\vcs$ consists of a single constraint $\vc$;
    \item $r$ is the result of finding the maximal constraint in $\vc$ via $\maxconstraint$.
  \end{itemize}

  \item All of the following apply (\textsc{head\_tail}):
  \begin{itemize}
    \item $\vcs$ is a list consisting of a constraint $\vc_1$ followed by a non-empty list of constraints $\vc_{2..k}$;
    \item finding the maximal constraint in $\vc_1$ via $\maxconstraint$ results in the integer $a$ or $\minmaxtop$,
          which short-circuits the entire rule;
    \item finding the maximal constraints in $\vc_{2..k}$ via $\maxconstraints$ results in the integer $b$ or $\minmaxtop$,
          which short-circuits the entire rule;
    \item $r$ is the maximum of $a$ and $b$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[single]{
  \maxconstraint(\tenv, \vc) \typearrow r
}{
  \maxconstraints(\tenv, [\vc]) \typearrow r
}
\and
\inferrule[head\_tail]{
  k > 1\\
  \maxconstraint(\tenv, \vc_1) \typearrow a \terminateas \minmaxtop\\\\
  \maxconstraints(\tenv, \vc_{2..k}) \typearrow b \terminateas \minmaxtop
}{
  \maxconstraints(\tenv, [\vc_{1..k}]) \typearrow \overname{\max\{a,b\}}{r}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.MinConstraint \label{sec:TypingRule.MinConstraint}}
\hypertarget{def-minconstraint}{}
The function
\[
  \minconstraint(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vc}) \aslto \overname{\Z \cup \{\minmaxtop\}}{r}\\
\]
infers an integer representing the minimal value of the constraint $\vc$ if it can be symbolically
simplified into an integer literal. Otherwise, the result is $\minmaxtop$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{min\_exact\_literal}):
  \begin{itemize}
    \item $\vc$ is a single value constraint with expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields a literal integer expression for $\vi$;
    \item $r$ is $\vi$.
  \end{itemize}

  \item All of the following apply (\textsc{min\_exact\_top}):
  \begin{itemize}
    \item $\vc$ is a single value constraint with expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ does not yield a literal integer expression for $\vi$;
    \item $r$ is $\minmaxtop$.
  \end{itemize}

  \item All of the following apply (\textsc{min\_range\_literal}):
  \begin{itemize}
    \item $\vc$ is a range constraint with start expression $\ve$, that is, $\ConstraintRange(\ve, \Ignore)$;
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields a literal integer expression for $\vi$;
    \item $r$ is $\vi$.
  \end{itemize}

  \item All of the following apply (\textsc{min\_range\_top}):
  \begin{itemize}
    \item $\vc$ is a range constraint with start expression $\ve$, that is, $\ConstraintRange(\ve, \Ignore)$;
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ does not yield a literal integer expression for $\vi$;
    \item $r$ is $\minmaxtop$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[min\_exact\_literal]{
  \normalize(\tenv, \ve) \typearrow \ELInt{\vi}
}{
  \minconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vi
}
\and
\inferrule[min\_exact\_top]{
  \normalize(\tenv, \ve) \typearrow \vep\\
  \astlabel(\vep) \neq \ELiteral
}{
  \minconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \minmaxtop
}
\and
\inferrule[min\_range\_literal]{
  \normalize(\tenv, \ve) \typearrow \ELInt{\vi}
}{
  \minconstraint(\tenv, \overname{\ConstraintRange(\ve, \Ignore)}{\vc}) \typearrow \vi
}
\and
\inferrule[min\_range\_top]{
  \normalize(\tenv, \ve) \typearrow \vep\\
  \astlabel(\vep) \neq \ELiteral
}{
  \minconstraint(\tenv, \overname{\ConstraintRange(\ve, \Ignore)}{\vc}) \typearrow \minmaxtop
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.MaxConstraint \label{sec:TypingRule.MaxConstraint}}
\hypertarget{def-maxconstraint}{}
\[
  \maxconstraint(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vc}) \aslto \Z \cup \{\minmaxtop\}\\
\]
infers an integer representing the maximal value of the constraint $\vc$ if it can be symbolically
simplified into an integer literal. Otherwise, the result is $\minmaxtop$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{max\_exact\_literal}):
  \begin{itemize}
    \item $\vc$ is a single value constraint with expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields a literal integer expression for $\vi$;
    \item $r$ is $\vi$.
  \end{itemize}

  \item All of the following apply (\textsc{max\_exact\_top}):
  \begin{itemize}
    \item $\vc$ is a single value constraint with expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ does not yield a literal integer expression for $\vi$;
    \item $r$ is $\minmaxtop$.
  \end{itemize}

  \item All of the following apply (\textsc{max\_range\_literal}):
  \begin{itemize}
    \item $\vc$ is a range constraint with an end expression $\ve$, that is, $\ConstraintRange(\Ignore, \ve)$;
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields a literal integer expression for $\vi$;
    \item $r$ is $\vi$.
  \end{itemize}

  \item All of the following apply (\textsc{max\_range\_top}):
  \begin{itemize}
    \item $\vc$ is a range constraint with an end expression $\ve$, that is, $\ConstraintRange(\Ignore, \ve)$;
    \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ does not yield a literal integer expression for $\vi$;
    \item $r$ is $\minmaxtop$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[max\_exact\_literal]{
  \normalize(\tenv, \ve) \typearrow \ELInt{\vi}
}{
  \maxconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vi
}
\and
\inferrule[max\_exact\_top]{
  \normalize(\tenv, \ve) \typearrow \vep\\
  \astlabel(\vep) \neq \ELiteral
}{
  \maxconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \minmaxtop
}
\and
\inferrule[max\_range\_literal]{
  \normalize(\tenv, \ve) \typearrow \ELInt{\vi}
}{
  \maxconstraint(\tenv, \overname{\ConstraintRange(\Ignore, \ve)}{\vc}) \typearrow \vi
}
\and
\inferrule[max\_range\_top]{
  \normalize(\tenv, \ve) \typearrow \vep\\
  \astlabel(\vep) \neq \ELiteral
}{
  \maxconstraint(\tenv, \overname{\ConstraintRange(\Ignore, \ve)}{\vc}) \typearrow \minmaxtop
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Blocks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotateblock}{}
The function
\[
  \annotateblock{\overname{\staticenvs}{\tenv} \aslsep \overname{\stmt}{\vs}} \aslto
  \overname{\stmt}{\newstmt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a block statement $\vs$ in static environment $\tenv$ and returns the annotated
statement $\newstmt$ or a type error, if one is detected.

\section{TypingRule.Block \label{sec:TypingRule.Block}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the statement $\vs$ in $\tenv$ yields $(\newstmt, \newtenv)$\ProseOrTypeError;
  \item the modified environment $\newtenv$ is dropped.
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.Block0.asl}

\CodeSubsection{\BlockBegin}{\BlockEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatestmt{\tenv, \vs} \typearrow (\newstmt, \Ignore) \OrTypeError
}{
  \annotateblock{\tenv, \vs} \typearrow \newstmt
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
A local identifier declared in a block statement (with \texttt{var}, \texttt{let}, or \texttt{constant})
is in scope from the point immediately after its declaration until the end of the
immediately enclosing block. This means, we can discard the environment at the end of
an enclosing block, which has the effect of dropping bindings of the identifiers declared inside the block.

\lrmcomment{This is related to \identr{JBXQ}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Catchers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatecatcher}{}
The function
\[
\begin{array}{r}
  \annotatecatcher{
    \overname{\staticenvs}{\tenv} \aslsep
    (\overname{\langle\identifier\rangle}{\nameopt} \times \overname{\ty}{\tty} \times \overname{\stmt}{\vstmt})
  } \aslto \\
  (\overname{\langle\identifier\rangle}{\nameopt} \times \overname{\ty}{\ttyp} \times \overname{\stmt}{\newstmt})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates a catcher given by the optional name of the matched exception --- $\nameopt$ ---
the exception type --- $\tty$ --- and the statement to execute upon catching the exception --- $\vstmt$.
The result is the catcher with the same optional name --- $\nameopt$, an annotated type $\ttyp$, and annotated statement $\newstmt$.
The result is a type error, if one is detected.

One of the following applies:
\begin{itemize}
\item TypingRule.CatcherNone (see \secref{TypingRule.CatcherNone}),
\item TypingRule.CatcherSome (see \secref{TypingRule.CatcherSome}).
\end{itemize}

\section{TypingRule.CatcherNone \label{sec:TypingRule.CatcherNone}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the catcher has no named identifier, that is, $(\None, \tty, \vstmt)$;
  \item annotating the type $\tty$ in $\tenv$ yields $\ttyp$\ProseOrTypeError;
  \item determining whether $\ttyp$ has the \structure\ of an exception type yields $\True$\ProseOrTypeError;
  \item annotating the block $\vstmt$ in $\tenv$ yields $\newstmt$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\CatcherNoneBegin}{\CatcherNoneEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \vt} \typearrow \ttyp \OrTypeError\\
  \checkstructurelabel(\tenv, \ttyp, \TException) \typearrow \True \OrTypeError\\
  \annotateblock{\tenv, \vstmt} \typearrow \newstmt \OrTypeError
}{
  \annotatecatcher{\tenv, (\overname{\None}{\nameopt}, \tty, \vstmt)} \typearrow (\overname{\None}{\nameopt}, \ttyp, \newstmt)
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{SDJK}.}

\section{TypingRule.CatcherSome \label{sec:TypingRule.CatcherSome}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the catcher has a named identifier, that is, $(\langle\name\rangle, \tty, \vstmt)$;
  \item annotating the type $\tty$ in $\tenv$ yields $\ttyp$\ProseOrTypeError;
  \item determining whether $\ttyp$ has the \structure\ of an exception type yields $\True$\ProseOrTypeError;
  \item the identifier $\name$ is not bound in $\tenv$;
  \item binding $\name$ in the local environment of $\tenv$ with the type $\ttyp$ as an immutable variable
        (that is, with the local declaration keyword $\LDKLet$), yields the static environment $\tenvp$;
  \item annotating the block $\vstmt$ in $\tenvp$ yields $\newstmt$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\CatcherSomeBegin}{\CatcherSomeEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \vt} \typearrow \ttyp \OrTypeError\\
  \checkstructurelabel(\tenv, \ttyp, \TException) \typearrow \True \OrTypeError\\\\
  \checkvarnotinenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
  \addlocal(\tenv, \name, \ttyp, \LDKLet) \typearrow \tenvp\\
  \annotateblock{\tenvp, \vstmt} \typearrow \newstmt \OrTypeError
}{
  \annotatecatcher{\tenv, (\overname{\langle\name\rangle}{\nameopt}, \tty, \vstmt)} \typearrow
  (\overname{\langle\name\rangle}{\nameopt}, \ttyp, \newstmt)
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{This is related to \identr{SDJK}, \identr{WVXS}, \identi{FCGK}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Subprogram Calls \label{chap:TypingSubprogramCalls}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatecall}
The function
\[
  \begin{array}{rl}
  \annotatecall{ &
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\expr^*}{\vargs} \aslsep
    \overname{\subprogramtype}{\calltype}
  } \aslto \\ &
  (\overname{\identifier}{\nameone} \aslsep
  \overname{\expr^*}{\vargsone} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqsone} \aslsep
  \overname{\langle \ty \rangle}{\rettyone})
\end{array}
\]
annotates the call to subprogram $\name$ with arguments $\vargs$,
parameters $\eqs$, and call type $\calltype$, resulting in values for an annotated call ---
$\nameone$, $\vargsone$, $\eqstwo$, $\rettyone$ --- or a type error if one is detected.

The rule TypingRule.FCall (see \secref{TypingRule.FCall}) applies.

We also define helper functions via respective rules:
\begin{itemize}
  \item TypingRule.FindCheckDeduce (see \secref{TypingRule.FindCheckDeduce}),
  which finds a subprogram that matches the call, checks for type errors, and infers expressions
  for parameters.
  % \item TypingRule.FindSubprogram (see \secref{TypingRule.FindSubprogram}),
  % which finds a subprogram that clashes with the subprogram
  % \item TypingRule.SubprogramFinder (see \secref{TypingRule.SubprogramFinder}),
  % \item TypingRule.DeduceEquations (see \secref{TypingRule.DeduceEquations}),
  % \item TypingRule.RenameTypeEquations (see \secref{TypingRule.RenameTypeEquations}),
  \item TypingRule.SubprogramForName (see \secref{TypingRule.SubprogramForName})
  \item TypingRule.FilterCallCandidates (see \secref{TypingRule.FilterCallCandidates})
  \item TypingRule.HasArgClash (see \secref{TypingRule.HasArgClash})
\end{itemize}

\section{TypingRule.FCall \label{sec:TypingRule.FCall}}
\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{function\_or\_getter}):
  \begin{itemize}
    \item Applying $\findcheckdeduce$ to $\tenv$, $\name$, $\exprs$, $\eqs$, and $\calltype$
    yields $(\nameone, \vargsone, \eqsone, \langle \tty \rangle)$\ProseOrTypeError;
    \item $\calltype$ is either a function $\STFunction$ or a getter $\STGetter$;
    \item substituting the variables appearing in $\tty$ by the corresponding expressions,
    according to $\eqsone$ yields $\retty$;
    \item $\rettyone$ is $\langle\retty\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{procedure\_or\_setter}):
  \begin{itemize}
    \item Applying $\findcheckdeduce$ to $\tenv$, $\name$, $\exprs$, $\eqs$, and $\calltype$
    yields $(\nameone, \vargsone, \eqsone, \None)$;
    \item $\calltype$ is either a procedure $\STProcedure$ or a setter $\STSetter$;
    \item $\rettyone$ is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{mismatch}):
  \begin{itemize}
    \item Applying $\findcheckdeduce$ to $\tenv$, $\name$, $\exprs$, $\eqs$, and $\calltype$
    yields $(\nameone, \vargsone, \eqsone, \retty)$;
    \item the following condition does not hold:
    $\retty$ is $\None$ if and only if $\calltype$ is one of $\STProcedure$ or $\STSetter$;
    \item a type error is returned indicating that the existence of a return value does not match
    the kind of subprogram.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\FCallBegin}{\FCallEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[function\_or\_getter]{
  \findcheckdeduce(\tenv, \name, \exprs, \calltype) \typearrow \\
  (\nameone, \vargsone, \eqsone, \langle \tty \rangle) \OrTypeError\\\\
  \calltype \in \{\STFunction, \STGetter, \STEmptyGetter\}\\
  \tododefine{rename\_ty\_eqs}(\tenv, \eqsone, \tty) \typearrow \retty
}
{
  \annotatecall{\tenv, \name, \exprs, \calltype} \typearrow (\nameone, \vargsone, \eqsone, \langle\retty\rangle)
}
\and
\inferrule[procedure\_or\_setter]{
  \findcheckdeduce(\tenv, \name, \exprs,\calltype) \typearrow \\
  (\nameone, \vargsone, \eqsone, \None) \\\\
  \calltype \in \{\STProcedure, \STSetter, \STEmptySetter\}
}
{
  \annotatecall{\tenv, \name, \exprs, \calltype} \typearrow (\nameone, \vargsone, \eqsone, \None)
}
\and
\inferrule[mismatch]{
  \findcheckdeduce(\tenv, \name, \exprs, \calltype) \typearrow \\
  (\nameone, \vargsone, \eqsone, \retty) \\\\
  \neg(\calltype \in \{\STProcedure, \STSetter\} \leftrightarrow \retty=\None)
}
{
  \annotatecall{\tenv, \name, \exprs, \calltype} \typearrow \TypeErrorVal{CallMismatch}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{
  This is related to \identi{VFDP}, \identd{TRFW}, \identr{KMDB},
  \identi{YMHX}, \identr{CCVD}, \identr{QYBH}, \identr{PFWQ}, \identr{ZLWD},
  \identi{FLKF}, \identd{PMBL}, \identr{MWBN}, \identr{TZSP}, \identr{SBWR},
  \identi{CMLP}, \identr{BQJG}, \identr{RTCF}.
}

\section{TypingRule.FindCheckDeduce \label{sec:TypingRule.FindCheckDeduce}}
\hypertarget{def-findcheckdeduce}{}
The function
\[
  \begin{array}{rl}
    \findcheckdeduce( &
      \overname{\staticenvs}{\tenv} \aslsep
      \overname{\identifier}{\name} \aslsep
      \overname{\expr^*}{\vargs} \aslsep
      \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
      \overname{\subprogramtype}{\calltype}
     ) \aslto \\ &
    \overname{\identifier}{\nameone} \aslsep
    \overname{\expr^*}{\vargsone} \aslsep
    \overname{(\identifier\times\expr)^*}{\eqsone} \aslsep
    \overname{\subprogramtype}{\retty}
  \end{array}
\]
performs three tasks:
\begin{itemize}
  \item Resolving the correct subprogram from the rule arguments. That is, finding a subprogram
  that with the same name and argument types that \typeclash\ with the actual argument types;
  \item Deducing from the actual arguments and formal parameters equations ---
  the expressions associated with parameter names;
  \item Checking that the call expression matches the subprogram declaration.
\end{itemize}
The function takes a static environment $\tenv$, a subprogram $\name$,
a list of actual arguments $\vargs$,
parameters $\eqs$ arguments, and call type $\calltype$.
It returns a unique name $\nameone$, annotated actual arguments $\vargsone$,
parameter arguments $\eqsfour$, and an optional return type $\retty$.
A type error is returned, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item Annotating the list of actual argument expressions $\vargs$ in $\tenv$ yields \\ $\callerargtyped$\ProseOrTypeError;
  \item $\callerargtyped$ is a list of pairs where the first element is a type and the second is an expression;
  \item splitting $\callerargtyped$ yields a list of types --- $\callerargtypes$ --- and a list of expressions ---
  $\vargsone$, respectively;
  \item finding the subprogram matching the name $\name$ and argument types \\ $\callerargtypes$ in $\tenv$
  yields a tuple \\ $(\extranargs, \nameone, \calleeargtypes, \retty, \calleeparams)$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{bad\_arity}):
    \begin{itemize}
      \item the length of the actual list of arguments is not the same as the list of arguments of the matched
      subprogram;
      \item a type error is returned.
    \end{itemize}

    \item All of the following apply (\textsc{okay}):
    \begin{itemize}
      \item The list of parameter arguments $\eqs$ is reversed and prepended to the list of parameter arguments
      i$\extranargs$, yielding $\eqstwo$;
      \item annotating static constrained integers in $\eqstwo$ in $\tenv$ yields $\eqsthree$\ProseOrTypeError;
      \item annotating the callee parameters using $\calleeargtypes$ and \\ $\callerargtypes$ in $\tenv$
      yields $\eqsfour'$;
      \item $\eqsfour$ is $\eqsfour'$ concatenated with $\eqsthree$;
      \item checking that $\callerargtypes$ \typesatisfies\ $\calleeargtypes$ in $\tenv$ yields
      $\True$\ProseOrTypeError;
      \item checking that each callee parameter in $\calleeparams$ is defined by the call
      parameters $\eqsfour$ yields $\True$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
\end{itemize}

\CodeSubsection{\FindCheckDeduceBegin}{\FindCheckDeduceEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[bad\_arity]{
  \annotateexprlist{\tenv, \vargs} \typearrow \callerargtyped \OrTypeError\\
  \splitlist(\callerargtyped) = (\callerargtypes, \vargsone)\\
  \findsubprogram(\tenv, \name, \callerargtypes) \typearrow \\
  (\Ignore, \Ignore, \calleeargtypes, \Ignore, \Ignore) \OrTypeError\\\\
  \equallength(\calleeargtypes, \vargsone) \typearrow \False
}
{
  \findcheckdeduce(\tenv, \name, \vargs, \eqs, \calltype) \typearrow \\
  \TypeErrorVal{CallBadArity}
}
\and
\inferrule[okay]{
  \annotateexprlist{\tenv, \vargs} \typearrow \callerargtyped \OrTypeError\\
  \splitlist(\callerargtyped) = (\callerargtypes, \defpoint{\vargsone})\\
  \findsubprogram(\tenv, \name, \callerargtypes) \typearrow \\
  (\extranargs, \defpoint{\nameone}, \calleeargtypes, \defpoint{\retty}, \calleeparams) \OrTypeError\\\\
  \equallength(\calleeargtypes, \vargsone) \typearrow \True\\
  \eqs \eqname \veq_{1..k}\\
  \eqstwo \eqdef [i=k..1: \veq_i] + \extranargs\\
  % \tododefine{apply\_eqs}(\tenv, \calleeargtypes, \callerargtyped) \typearrow \eqstwo' \OrTypeError\\
  % \eqstwo \eqdef \eqstwo' + \eqsone\\
  \tododefine{annotate\_static\_constrained\_integers}(\tenv, \eqstwo) \typearrow \eqsthree \OrTypeError\\
  \tododefine{annotate\_callee\_params}(\tenv, \calleeargtypes, \callerargtypes) \typearrow \eqsfour' \OrTypeError\\
  \defpoint{\eqsfour} \eqdef \eqsfour' + \eqsthree\\
  \tododefine{check\_args\_typesat}(\tenv, \calleeargtypes, \callerargtypes) \typearrow \True \OrTypeError\\
  \tododefine{check\_callee\_params}(\tenv, \calleeparams, \eqsfour) \typearrow \True \OrTypeError\\
}
{
  \findcheckdeduce(\tenv, \name, \vargs, \eqs, \calltype) \typearrow
  (\nameone, \vargsone, \eqsfour, \retty)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.FindSubprogram \label{sec:TypingRule.FindSubprogram}}
\hypertarget{def-findsubprogram}{}
The function
\[
  \begin{array}{l}
    \findsubprogram(
      \overname{\staticenvs}{\tenv} \aslsep
      \overname{\identifier}{\name} \aslsep
      \overname{\ty^*}{\callerargtypes}
     ) \aslto \\
    (
      \overname{(\identifier\times\expr)^*}{\extranargs} \aslsep
      \overname{\identifier}{\nameone} \aslsep
      \overname{(\identifier\times\ty)^*}{\calleeargtypes} \aslsep
      \overname{\langle\ty\rangle}{\retty} \aslsep
      \overname{(\identifier \times \langle\ty\rangle)}{\calleeparams}
    )
  \end{array}
\]
takes the name of a subprogram --- $\name$ --- and a list argument types --- \\ $\calleeargtypes$,
and determines whether:
\begin{itemize}
  \item there is no declared subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is exactly one subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is more than one subprogram that matches ($\name$ and $\calleeargtypes$);
\end{itemize}
The first and last cases indicate a type error.
If the second case holds, the function returns:
\begin{itemize}
\item $\extranargs$ --- a list matching parameters to their caller expressions based on bitvector parameters;
\item $\identifier$ --- an identifier that uniquely matches this subprogram;
\item $\calleeargtypes$ --- the list of formal argument types of the matched subprogram;
\item $\retty$ --- the type of the returned value, in case of a function or a getter;
\item $\calleeparams$ --- parameters declared in the matched subprogram.
\end{itemize}
A type error is returned, if one is detected.

\begin{emptyformal}
\subsection{Formally}
\end{emptyformal}

\section{TypingRule.SubprogramForName \label{sec:TypingRule.SubprogramForName}}
\hypertarget{def-subprogramforname}{}
The function
\[
  \begin{array}{rl}
    \subprogramforname(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\ty^*}{\callerargtypes}
  )
  \aslto &
    (\overname{(\identifier \times \expr)^*}{\extranargs} \aslsep
    \overname{\Strings}{\namep} \aslsep
    \overname{\func}{\callee}
    )\\
  & \cup\ \overname{\TTypeError}{\TypeErrorConfig}
  \end{array}
\]
looks up the static environment $\tenv$ for a subprogram associated with $\name$
and the list of argument types $\calleeargtypes$ and determines which one of the following
cases holds:
\begin{itemize}
  \item there is no declared subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is exactly one subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is more than one subprogram that matches $\name$ and $\calleeargtypes$;
\end{itemize}
The first and last cases result in a type error.
If the second case holds, the function returns a tuple comprised of:
\begin{itemize}
\item $\extranargs$ --- the list of extra named arguments (parameters);
\item $\namep$ --- the string that uniquely identifies this subprogram;
\item $\callee$ --- the AST node defining the called subprogram.
\end{itemize}
A type error is returned, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{undefined}):
  \begin{itemize}
    \item $\tenv$ does not contain a binding for $\name$ in the $\subprogramrenamings$ map
          ($G^\tenv.\subprogramrenamings$);
    \item the result is a type error indicating that the identifier has not been declared (as a subprogram).
  \end{itemize}

  \item All of the following apply (\textsc{no\_candidates}):
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\subprogramrenamings$ map to $\renamingset$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \secref{TypingRule.FilterCallCandidates}) yields an empty set\ProseOrTypeError;
    \item the result is a type error indicating that the call given by $\name$ and \\ $\callerargtypes$
          does not match any defined subprogram.
  \end{itemize}

  \item All of the following apply (\textsc{too\_many\_candidates}):
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\subprogramrenamings$ map to $\renamingset$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \secref{TypingRule.FilterCallCandidates}) yields $\matchingrenamings$\ProseOrTypeError;
    \item $\matchingrenamings$ contains at least two elements;
    \item the result is a type error indicating that the call given by $\name$ and \\
          $\callerargtypes$ matches more than one defined subprogram.
  \end{itemize}

  \item All of the following apply (\textsc{one\_candidate}):
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\subprogramrenamings$ map to $\renamingset$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \secref{TypingRule.FilterCallCandidates}) yields $\matchingrenamings$\ProseOrTypeError;
    \item $\matchingrenamings$ contains a single element --- $(\matchedname, \funcsig)$;
    \item deducing the argument values for the parameters via $\deduceeqs$ with \\
          $\callerargtypes$, $\funcsig.\funcargs$, $\matchedname$, and $\funcsig$ in $\tenv$ yields
          $(\extranargs, \namep, \callee)$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\SubprogramForNameBegin}{\SubprogramForNameEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[undefined]{
  G^\tenv.\subprogramrenamings(\name) = \bot
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\and
\inferrule[no\_candidates]{
  G^\tenv.\subprogramrenamings(\name) = \renamingset\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \emptyset \OrTypeError
    \end{array}
  }
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\NoCallCandidates}
}
\and
\inferrule[too\_many\_candidates]{
  G^\tenv.\subprogramrenamings(\name) = \renamingset\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \\ \matchingrenamings \OrTypeError
    \end{array}
  }\\\\
  \cardinality{\matchingrenamings} \geq 2
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\TooManyCandidates}
}
\and
\inferrule[one\_candidate]{
  G^\tenv.\subprogramrenamings(\name) = \renamingset\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \\ \matchingrenamings \OrTypeError
    \end{array}
  }\\\\
  \matchingrenamings = [(\matchedname, \funcsig)]\\
  {
    \begin{array}{r}
  \tododefine{deduce\_eqs}(\tenv, \callerargtypes, \funcsig.\funcargs, \matchedname, \funcsig)
  \typearrow \\ (\extranargs, \namep, \callee) \OrTypeError
    \end{array}
  }
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow (\extranargs, \namep, \callee)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.FilterCallCandidates \label{sec:TypingRule.FilterCallCandidates}}
\hypertarget{def-filtercandidates}{}
The helper function
\[
  \filtercallcandidates(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty^*}{\formaltypes} \aslsep
    \overname{\pow{\Strings}}{\candidates}
    )
  \aslto \overname{(\Strings\times\func)^*}{\matches}
\]
iterates over the list of unique subprogram names in $\candidates$ and checks whether
their lists of arguments clash with the types in $\formaltypes$ in $\tenv$.
The result is the set of pairs consisting of the names and function definitions of the
subprograms whose arguments clash in $\candidates$.
The result is a type error, if one is detected.

The names $\candidates$ are assumed to exist in $G^\tenv.\subprograms$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{no\_candidates}):
  \begin{itemize}
    \item $\candidates$ is empty;
    \item $\matches$ is empty.
  \end{itemize}

  \item All of the following apply (\textsc{candidates\_exist}):
  \begin{itemize}
    \item $\candidates$ is a list with head $\name$ and tail $\candidatesone$;
    \item the function definition associated with $\name$ in $\tenv$ is $\funcdef$;
    \item determining whether there is an argument clash between $\formaltypes$ and the arguments in $\funcdef$
          (that is, $\funcdef.\funcargs$) yields $\vb$\ProseOrTypeError;
    \item filtering the call candidates in $\candidatesone$ with $\formaltypes$ in $\tenv$ yields $\matchesone$\ProseOrTypeError;
    \item if $\vb$ is $\True$ then $\matches$ is the list with head $(\name,\funcdef)$ and tail $\matchesone$,
          and otherwise it is $\matchesone$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[no\_candidates]
{}{
  \filtercallcandidates(\tenv, \formaltypes, \overname{\emptylist}{\candidates}) \typearrow \overname{\emptylist}{\matches}
}
\and
\inferrule[candidates\_exist]
{
  \funcdef \eqdef G^\tenv.\subprograms(\name) \\
  \hasargclash(\tenv, \formaltypes, \funcdef.\funcargs) \typearrow \vb \OrTypeError\\\\
  \filtercallcandidates(\tenv, \formaltypes, \candidatesone) \typearrow \matchesone \OrTypeError\\\\
  \matches \eqdef \choice{\vb}{\;[(\name,\funcdef)] \concat \matchesone}{\;\matchesone}
}{
  \filtercallcandidates(\tenv, \formaltypes, \overname{[\name] \concat \candidatesone}{\candidates}) \typearrow \matches
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.HasArgClash \label{sec:TypingRule.HasArgClash}}
\hypertarget{def-hasargclash}{}
The function
\[
  \hasargclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty^*}{\formaltys} \aslsep
    \overname{(\identifier\times\ty)^*}{\vargs}
  )
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether a list of types $\formaltys$ clashes with the list of types appearing
in the list of arguments $\vargs$ in $\tenv$, yielding the result in $\vb$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item equating the list lengths of $\formaltys$ and $\vargs$ either yields $\True$
        or $\False$, which short-circuits the entire rule;
  \item $\argtys$ is the list of types appearing in $\vargs$, in the same order;
  \item for each $\vi$ in the list of indices of $\formaltys$, applying $\typeclashes$ to
        $\formaltys[\vi]$ and $\argtys[\vi]$ in $\tenv$ yields $\True$\ProseTerminateAs{\False, \TypeErrorConfig};
  \item $\vb$ is $\True$ (unless the rule short-circuited with $\False$ or a type error).
\end{itemize}

\CodeSubsection{\HasArgClashBegin}{\HasArgClashEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \equallength(\formaltypes, \vargs) \typearrow \True \terminateas \False\\
  \argtys \eqdef [(\Ignore, \vt) \in\listrange(\vargs): \vt]\\
  \vi\in\listrange(\formaltys): \typeclashes(\tenv, \formaltys[\vi], \argtys[\vi]) \typearrow \True \terminateas \False,\TypeErrorConfig
}{
  \hasargclash(\tenv, \formaltys, \vargs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Subprograms \label{chap:TypingSubprograms}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatesubprogram}{}
The function
\[
  \annotatesubprogram{\overname{\staticenvs}{\tenv} \aslsep \overname{\func}{\vf}} \aslto \overname{\func}{\vfp}
\]
annotates a subprogram $\vf$ in an environment $\tenv$, resulting in an annotated subprogram $\vfp$,
or a type error, if one is detected.

\section{TypingRule.Subprogram \label{sec:TypingRule.Subprogram}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vf$ is a $\func$ AST node subprogram body $\body$;
  \item annotating the block $\body$ in $\tenv$ as per \secref{TypingRule.Block} yields $\newbody$\ProseOrTypeError;
  \item $\vfp$ is $\vf$ with the subprogram body substituted with $\newbody$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SubprogramBegin}{\SubprogramEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{rrcl}
  \vf \eqname \{ & \funcname            &:& \id,\\
                 & \funcparameters      &:& \vp,\\
                 & \funcargs            &:& \vargs,\\
                 & \funcbody            &:& \SBASL(\body),\\
                 & \funcreturntype      &:& \vt,\\
                 & \funcsubprogramtype  &:& \subprogramtype \\
              \} &&&
    \end{array}
  }\\
  \annotateblock{\tenv, \body} \typearrow \newbody \OrTypeError\\
  {
    \begin{array}{rrcl}
  \vfp \eqdef \{ & \funcname            &:& \id,\\
                 & \funcparameters      &:& \vp,\\
                 & \funcargs            &:& \vargs,\\
                 & \funcbody            &:& \SBASL(\newbody),\\
                 & \funcreturntype      &:& \vt,\\
                 & \funcsubprogramtype  &:& \subprogramtype \\
              \} &&&
    \end{array}
  }\\
}{
  \annotatesubprogram{\tenv, \vf} \typearrow \vfp
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
\lrmcomment{
This is related to \identi{GHGK}, \identr{HWTV}, \identr{SCHV}, \identr{VDPC},
\identr{TJKQ}, \identi{LFJZ}, \identi{BZVB}, \identi{RQQB}.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Global Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-typecheckdecl}{}
The function
\[
  \typecheckdecl(
    \overname{\decl}{\vd} \aslsep
    (\overname{\decl^*}{\acc} \times \overname{\staticenvs}{\tenv})
  )
  \aslto (\overname{\decl^*}{\annotateddecls} \times \overname{\staticenvs}{\newtenv})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a global declaration $\vd$, given a list of already annotated declarations
$\acc$ ($\acc$ stands for ``accumulated'') and static environment $\tenv$ and returns a list of annotated declarations
$\annotateddecls$ and new static environment $\newtenv$.
The result is a type error, if one is detected.

One of the following applies:
\begin{itemize}
  \item TypingRule.TypecheckFunc (see \secref{TypingRule.TypecheckFunc})
  \item TypingRule.TypecheckGlobalStorage (see \secref{TypingRule.TypecheckGlobalStorage})
  \item TypingRule.TypecheckTypeDecl (see \secref{TypingRule.TypecheckTypeDecl})
\end{itemize}
We also define the following helper rules:
\begin{itemize}
  \item TypingRule.AnnotateAndDeclareFunc (see \secref{TypingRule.AnnotateAndDeclareFunc})
  \item TypingRule.AnnotateFuncSig (see \secref{TypingRule.AnnotateFuncSig})
  \item TypingRule.GetUndeclaredDefining (see \secref{TypingRule.GetUndeclaredDefining})
  \item TypingRule.ScanForParams (see \secref{TypingRule.ScanForParams})
  \item TypingRule.AnnotateParams (see \secref{TypingRule.AnnotateParams})
  \item TypingRule.AnnotateOneParam (see \secref{TypingRule.AnnotateOneParam})
  \item TypingRule.ArgsAsParams (see \secref{TypingRule.ArgsAsParams})
  \item TypingRule.ArgAsParam (see \secref{TypingRule.ArgAsParam})
  \item TypingRule.AnnotateParamType (see \secref{TypingRule.AnnotateParamType})
  \item TypingRule.AnnotateArgs (see \secref{TypingRule.AnnotateArgs})
  \item TypingRule.AnnotateOneArg (see \secref{TypingRule.AnnotateOneArg})
  \item TypingRule.AnnotateReturnType (see \secref{TypingRule.AnnotateReturnType})
  \item TypingRule.DeclareOneFunc (see \secref{TypingRule.DeclareOneFunc})
  \item TypingRule.SubprogramClash (see \secref{TypingRule.SubprogramClash})
  \item TypingRule.AddNewFunc (see \secref{TypingRule.AddNewFunc})
  \item TypingRule.CheckSetterHasGetter (see \secref{TypingRule.CheckSetterHasGetter})
  \item TypingRule.AddSubprogram (see \secref{TypingRule.AddSubprogram})
  \item TypingRule.DeclareGlobalStorage (see \secref{TypingRule.DeclareGlobalStorage})
  \item TypingRule.AnnotateTypeOpt (see \secref{TypingRule.AnnotateTypeOpt})
  \item TypingRule.AnnotateExprOpt (see \secref{TypingRule.AnnotateExprOpt})
  \item TypingRule.AnnotateInitType (see \secref{TypingRule.AnnotateInitType})
  \item TypingRule.AddGlobalStorage (see \secref{TypingRule.AddGlobalStorage})
  \item TypingRule.DeclareType (see \secref{TypingRule.DeclareType})
  \item TypingRule.AnnotateExtraFields (see \secref{TypingRule.AnnotateExtraFields})
  \item TypingRule.AnnotateEnumLabels (see \secref{TypingRule.AnnotateEnumLabels})
  \item TypingRule.DeclareConst (see \secref{TypingRule.DeclareConst})
\end{itemize}

\section{TypingRule.TypecheckFunc \label{sec:TypingRule.TypecheckFunc}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vd$ is a subprogram AST node with a subprogram definition $\vf$, that is, $\DFunc(\vf)$;
  \item annotating and declaring the subprogram for $\vf$ in $\tenv$ as per \secref{TypingRule.AnnotateAndDeclareFunc}
        yields the new environment $\newtenv$ and a subprogram definition $\vfone$\ProseOrTypeError;
  \item annotating the subprogram definition $\vfone$ in $\tenv$ as per \chapref{TypingSubprograms} yields
        the annotated subprogram definition $\vftwo$\ProseOrTypeError;
  \item $\newd$ is the subprogram AST node with $\vftwo$, that is, $\DFunc(\vftwo)$;
  \item $\annotateddecls$ is the list with $\newd$ as its head and $\decls$ as its tail.
\end{itemize}

\subsection{Example}
\CodeSubsection{\TypecheckFuncBegin}{\TypecheckFuncEnd}{../Typing.ml}
\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vf \eqname \{\text{body}: \SBASL, \ldots\}\\
  \annotateanddeclarefunc(\tenv, \vf) \typearrow (\newtenv, \vfone) \OrTypeError\\\\
  \annotatesubprogram{\newtenv, \vfone} \typearrow \vftwo \OrTypeError\\\\
  \newd \eqdef \DFunc(\vftwo)
}{
  \typecheckdecl(\overname{\DFunc(\vf)}{\vd}, \overname{(\decls, \tenv)}{\acc})
  \typearrow (\overname{[\newd] \concat \decls}{\annotateddecls}, \newtenv)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.TypecheckGlobalStorage \label{sec:TypingRule.TypecheckGlobalStorage}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vd$ is a global storage declaration with description $\gsd$, that is, \\ $\DGlobalStorage(\gsd)$;
  \item declaring the global storage with description $\gsd$ in $\tenv$ yields the new environment
        $\newtenv$ and new global storage description $\gsdp$\ProseOrTypeError;
  \item $\newd$ is the global storage declaration with description $\gsdp$, that is, \\ $\DGlobalStorage(\gsdp)$;
  \item $\annotateddecls$ is the list with $\newd$ as its head and $\decls$ as its tail.
\end{itemize}
\subsection{Example}

\CodeSubsection{\TypecheckGlobalStorageBegin}{\TypecheckGlobalStorageEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \declareglobalstorage(\tenv, \gsd) \typearrow (\newtenv, \gsdp) \OrTypeError\\\\
  \newd \eqdef \DGlobalStorage(\gsdp)
}{
  \typecheckdecl(\overname{\DGlobalStorage(\gsd)}{\vd}, \overname{(\decls, \tenv)}{\acc})
  \typearrow (\overname{[\newd] \concat \decls}{\annotateddecls}, \newtenv)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.TypecheckTypeDecl \label{sec:TypingRule.TypecheckTypeDecl}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vd$ is a type declaration with identifier $\vx$, type $\tty$,
        and optional field initializers $\vs$, that is, $\DTypeDecl(\vx, \tty, \vs)$;
  \item declaring the type described by $(\vx, \tty, \vs)$ in $\tenv$
        as per \secref{TypingRule.DeclaredType} yields the modified environment $\newtenv$\ProseOrTypeError;
  \item $\annotateddecls$ is the list with $\vd$ as its head and $\decls$ as its tail.
  \end{itemize}

\subsection{Example}

\CodeSubsection{\TypecheckTypeDeclBegin}{\TypecheckTypeDeclEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vd \eqname \DTypeDecl(\vx, \tty, \vs)\\
  \declaretype(\tenv, \vx, \tty, \vs) \typearrow \newtenv \OrTypeError
}{
  \typecheckdecl(\vd, \overname{(\decls, \tenv)}{\acc})
  \typearrow (\overname{[\vd] \concat \decls}{\annotateddecls}, \newtenv)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateAndDeclareFunc \label{sec:TypingRule.AnnotateAndDeclareFunc}}
\hypertarget{def-annotateanddeclarefunc}{}

The function
\[
  \annotateanddeclarefunc(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\tenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a subprogram definition $\funcsig$ in the static environment $\tenv$,
yielding a new subprogram definition $\newfuncsig$ and modified static environment
$\newtenv$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the signature of $\funcsig$ in $\tenv$ as per
        \secref{TypingRule.AnnotateFuncSig} yields
        the environment $\tenvone$ and subprogram definition $\funcsigone$\ProseOrTypeError;
  \item declaring the function with description $\funcsigone$ in $\tenvone$
        as per \secref{TypingRule.DeclareOneFunc} yields the environment $\newtenv$
        and new function description $\newfuncsig$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\AnnotateAndDeclareFuncBegin}{\AnnotateAndDeclareFuncEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatefuncsig(\tenv, \funcsig) \typearrow (\tenvone, \funcsigone) \OrTypeError\\\\
  \declareonefunc(\tenvone, \funcsigone) \typearrow (\newtenv, \newfuncsig) \OrTypeError
}{
  \annotateanddeclarefunc(\tenv, \funcsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateFuncSig \label{sec:TypingRule.AnnotateFuncSig}}
\hypertarget{def-annotatefuncsig}{}
The function
\[
  \annotatefuncsig(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the signature of a function definition $\funcsig$ in the static environment $\tenv$,
yielding a new function definition $\newfuncsig$ and modified static environment
$\newtenv$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tenvone$ is the static environment comprised of the global environment of $\tenv$ and an empty local environment;
  \item obtaining the variables appearing in the formal types in $\funcsig$ that may be parameter-defining
        in $\tenvone$ via $\getundeclareddefining$ yields \\ $\potentialparams$;
  \item annotating the parameters explicitly listed in $\funcsig$ ($\funcsig.\funcparameters)$ \\
        yields environment $\tenvtwo$, in which the parameters are declared,
        and the function \\
        $\declaredparams$, which binds parameter identifiers to their types\ProseOrTypeError;
  \item annotating arguments from $\funcsig$ that serve as parameters in $\tenvtwo$ yields the list of parameters
        $\argparams$ and modified environment $\tenvthree$\ProseOrTypeError;
  \item $\vparameters$ is the list $\declaredparams$ concatenated with $\argparams$ with each type
        wrapped in an optional;
  \item annotating the arguments listed in $\funcsig$ in $\tenvthree$ with $\tenvtwo$ via \\
        $\annotateargs$ yields the list of annotated
        arguments $\vargs$ and modified environment $\tenvfour$\ProseOrTypeError;
  \item annotating the return type of $\funcsig$ in $\tenvfour$ with $\tenvthree$ via \\ $\annotatereturntype$ yields
        the annotated return type $\vreturntype$ and modified environment $\tenvfive$\ProseOrTypeError;
  \item $\newfuncsig$ is $\funcsig$ with the listed of parameters substituted with \\ $\vparameters$,
        the list of arguments substituted with $\vargs$, and return type substituted with $\vreturntype$;
  \item $\newtenv$ is $\tenvfive$.
\end{itemize}
\subsection{Example}

\CodeSubsection{\AnnotateFuncSigBegin}{\AnnotateFuncSigEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tenvone \eqdef (G^\tenv, L^{\emptytenv})\\
  \getundeclareddefining(\tenvone, \funcsig) \typearrow \potentialparams\\
  {
    \begin{array}{r}
    \annotateparams(\tenvone, \potentialparams, \funcsig.\funcparameters, (\tenvone, \emptyfunc)) \typearrow \\
    (\tenvtwo, \declaredparams) \OrTypeError
    \end{array}
  }\\
  {
    \begin{array}{r}
    \argsasparams(\tenvtwo, \funcsig) \typearrow (\tenvthree, \argparams) \OrTypeError
    \end{array}
  }\\
  {
    \begin{array}{rl}
    \vparameters \eqdef & [(\id,\vt) \in \declaredparams: (\id, \langle\vt\rangle)]\ \concat \\
                     & [(\id,\vt) \in \argparams: (\id, \langle\vt\rangle)]
    \end{array}
  }\\
  \annotateargs(\tenvthree, \tenvtwo, \funcsig, \argparams) \typearrow (\tenvfour, \vargs) \OrTypeError\\\\
  {
    \begin{array}{r}
  \annotatereturntype(\tenvfour, \tenvthree, \funcsig.\funcreturntype) \typearrow \\
    (\tenvfive, \vreturntype) \OrTypeError
    \end{array}
  }\\\\
  {
    \begin{array}{rrcl}
      \newfuncsig \eqdef \{
                      & \funcname            &:& \funcsig.\funcname,\\
                      & \funcparameters      &:& \vparameters,\\
                      & \funcargs            &:& \vargs,\\
                      & \funcbody            &:& \funcsig.\funcbody,\\
                      & \funcreturntype      &:& \vreturntype,\\
                      & \funcsubprogramtype  &:&  \funcsig.\subprogramtype \\
                  \}  &  &&
        \end{array}
  }
}{
  \annotatefuncsig(\tenv, \funcsig) \typearrow (\overname{\tenvfive}{\newtenv}, \newfuncsig, \argparams)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.GetUndeclaredDefining \label{sec:TypingRule.GetUndeclaredDefining}}
\hypertarget{def-getundeclareddefining}{}
The function
\[
\getundeclareddefining(\overname{\staticenvs}{\tenv} \aslsep \overname{\func}{\funcsig})
\aslto \overname{\pow{\identifier}}{\potentialparams}
\]
scans the list of types appearing in $\funcsig.\funcargs$ and in the return type
and returns the set of
identifiers that may be parameter-defining in $\tenv$.

\subsection{Example}
In the following specification, the set of identifiers that may correspond
to parameters of the function \texttt{signature\_example} is $\{\texttt{A}\}$,
since \texttt{A} appears in the type \texttt{bits(A)}
of the argument \texttt{bv}.

\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

\CodeSubsection{\GetUndeclaredDefiningBegin}{\GetUndeclaredDefiningEnd}{../Typing.ml}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\formaltypes$ consists of the types associated with the list of arguments in $\funcsig$
        and the return type in $\funcsig$, if one exists;
  \item scanning each type $\vt$ in $\formaltypes$ via $\scanforparams$ yields the set $\vparams_\vt$;
  \item $\potentialparams$ is the union of $\vparams_\vt$ for each type $\vt$ in $\formaltypes$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{rcl}
      \formaltypes &\eqdef&
    [(\Ignore, \vt) \in \funcsig.\funcargs: \vt]\ \concat \\
    && \choice{\funcsig.\funcreturntype = \langle\vreturntype\rangle}{[\vreturntype]}{\emptylist}
    \end{array}
  }\\
  \vt\in\formaltypes: \scanforparams(\tenv, \vt) \typearrow \vparams_\vt
}{
  \getundeclareddefining(\tenv, \funcsig) \typearrow \overname{\bigcup_{\vt \in \tys} \vparams_\vt}{\potentialparams}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ScanForParams \label{sec:TypingRule.ScanForParams}}
\hypertarget{def-scanforparams}{}
The function
\[
\scanforparams(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty})
\aslto \overname{\pow{\identifier}}{\potentialparams}
\]
scans a single type $\tty$ in $\tenv$ and returns the set of
identifiers that may be parameters in $\tenv$.

\subsection{Example}
Consider the following specification:
\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

Scanning each type in the signature
of the function \texttt{signature\_example} yields the following results:
\begin{center}
\begin{tabular}{lll}
\textbf{Expression} & \textbf{Result} & \textbf{Reason}\\
\hline
\texttt{bits(A)} & $\{\texttt{A}\}$ & \texttt{A} is a variable expression \\
& & and \texttt{A} is not defined in the environment.\\
\texttt{bits(W)} & $\emptyset$ & \texttt{W} is defined in the environment.\\
\texttt{bits(A+B)} & $\emptyset$ & \texttt{A+B} is not a variable expression.\\
\end{tabular}
\end{center}

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{tbits\_evar}):
  \begin{itemize}
    \item $\tty$ is a bitvector type over a variable expression for $\vx$, that is, \\ $\TBits(\EVar(\vx), \Ignore)$;
    \item $\potentialparams$ is the singleton set consisting of $\vx$ if $\vx$ is not defined as a storage type in $\tenv$
          and the empty set, otherwise.
  \end{itemize}

  \item All of the following apply (\textsc{tbits\_other}):
  \begin{itemize}
    \item $\tty$ is a bitvector type where the bitwidth expression is not a variable expression;
    \item $\potentialparams$ is the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{ttuple}):
  \begin{itemize}
    \item $\tty$ is a tuple type over a list of types $\tys$;
    \item obtaining the set of potential parameters for each type $\vt$ of $\tys$ in $\tenv$ yields $\vparams_\vt$;
    \item $\potentialparams$ is the union of sets $\vparams_\vt$, for each type $\vt$ of $\tys$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\tty$ is neither a bitvector type or a tuple type;
    \item $\potentialparams$ is the empty set.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
  \inferrule[tbits\_evar]{
    \isundefined(\tenv, \vx) \typearrow \vb\\
    \potentialparams \eqdef \choice{\vb}{\{\vx\}}{\emptyset}
  }{
    \scanforparams(\tenv, \overname{\TBits(\EVar(\vx), \Ignore)}{\tty}) \typearrow \potentialparams
  }
  \and
  \inferrule[tbits\_other]{
    \astlabel(\ve) \neq \EVar
  }{
    \scanforparams(\tenv, \overname{\TBits(\ve, \Ignore)}{\tty}) \typearrow \overname{\emptyset}{\potentialparams}
  }
  \and
  \inferrule[ttuple]{
    \vt \in \tys: \scanforparams(\tenv, \vt) \typearrow \vparams_\vt
  }{
    \scanforparams(\tenv, \overname{\TTuple(\tys)}{\tty}) \typearrow \overname{\bigcup_{\vt \in \tys} \vparams_\vt}{\potentialparams}
  }
  \and
  \inferrule[other]{
    \astlabel(\tty) \not\in \{\TBits, \TTuple\}
  }{
    \scanforparams(\tenv, \tty) \typearrow \overname{\emptyset}{\potentialparams}
  }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateParams \label{sec:TypingRule.AnnotateParams}}
\hypertarget{def-annotateparams}{}
The function
\[
\begin{array}{r}
\annotateparams(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\pow{\identifier}}{\potentialparams} \aslsep
  \overname{(\identifier \times \langle\ty\rangle)^*}{\vparameters} \aslsep\
  (\overname{\staticenvs}{\tenvonep} \times \overname{\identifier\rightarrow\ty}{\acc})
) \aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\identifier\rightarrow\ty}{\declaredparams})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
scans the list of explicitly defined parameters $\vparameters$ with respect to the set of potential
parameters $\potentialparams$ in $\tenv$ and then updates a pair
consisting of an updated environment $\tenvonep$, which accumulates local storage declarations
for the parameters, and a function $\acc$, which maps identifiers corresponding to parameters
to their associated types.
The updated pair is given in $\newtenv$ and $\declaredparams$.
The result is a type error, if one is detected.

\subsection{Example}
In the following specification, the list of explicitly defined parameters
of the function \texttt{signature\_example} is $\{\texttt{A}\}$.
Therefore, $\declaredparams$ binds \texttt{A} to the type \verb|integer{A}|
and $\newtenv$ effectively reflects an added declaration \verb|let A: integer{A}|.

\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\vparameters$ is the empty list;
    \item $\newtenv$ is $\tenvonep$;
    \item $\declaredparams$ is $\acc$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\vparameters$ is a list with $(\vx, \tyopt)$ as its head and $\vparametersone$ as its tail;
    \item annotating the parameter $(\vx, \tyopt)$ in $\tenvone$ with $\potentialparams$ and the pair $(\tenvonep, \acc)$
          via $\annotateoneparam$ yields the pair $(\tenvonepp, \accp)$\ProseOrTypeError;
    \item annotating the parameter list $\vparametersone$ in $\tenvone$ with $\potentialparams$, starting with the pair
          $(\tenvonepp, \accp)$ yields the pair \\ $(\newtenv, \declaredparams)$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  {
    \begin{array}{r}
  \annotateparams(\tenvone, \potentialparams, \overname{\emptylist}{\vparameters}, (\tenvonep, \acc)) \typearrow \\
  (\overname{\tenvonep}{\newtenv}, \overname{\acc}{\declaredparams})
    \end{array}
  }
}
\and
\inferrule[non\_empty]{
  \vparameters \eqname [(\vx,\tyopt)]\concat\vparametersone\\
  {
    \begin{array}{r}
  \annotateoneparam(\tenvone, \potentialparams, (\vx,\tyopt), (\tenvonep, \acc)) \typearrow \\ (\tenvonepp, \accp) \OrTypeError
    \end{array}
  }\\\\
  {
    \begin{array}{r}
  \annotateparams(\tenvone, \potentialparams, \vparametersone, (\tenvonepp, \accp)) \typearrow \\ (\newtenv, \declaredparams) \OrTypeError
\end{array}
}\\\\
}{
  {
    \begin{array}{r}
  \annotateparams(\tenvone, \potentialparams, \vparameters, (\tenvonep, \acc)) \typearrow \\
  (\newtenv, \declaredparams)
    \end{array}
}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateOneParam \label{sec:TypingRule.AnnotateOneParam}}
The function
\hypertarget{def-annotateoneparam}{}
\[
\begin{array}{r}
\annotateoneparam(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\pow{\identifier}}{\potentialparams} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\langle\ty\rangle}{\tyopt}) \aslsep
  (\overname{\staticenvs}{\tenvonep} \times \overname{\identifier\rightarrow\ty}{\acc})
) \\ \aslto
(\overname{\staticenvs}{\newtenv} \times \overname{\identifier\rightarrow\ty}{\declaredparams})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the explicitly defined parameter given by $\vx$ and the optional type $\tyoptp$
with respect to the set of potential
parameters $\potentialparams$ in $\tenv$ and then updates a pair
consisting of an updated environment $\tenvonep$, which accumulates local storage declarations
for the parameters, and a function $\acc$, which maps identifiers corresponding to parameters
to their associated types.
The updated pair is given in $\newtenv$ and $\declaredparams$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that $\vx$ is not defined as a variable in $\tenvonep$ yields $\True$\ProseOrTypeError;
  \item checking whether $\vx$ is included in the set $\potentialparams$ yields $\True$ or a type error
        indicating that each parameter must have a defining argument, thus short-circuiting the entire rule;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{type\_underconstrained}):
    \begin{itemize}
      \item $\tyopt$ is either $\None$ or an unconstrained integer type;
      \item $\vt$ is defined as the underconstrained integer type for the identifier $\vx$.
    \end{itemize}

    \item All of the following apply (\textsc{type\_annotated}):
    \begin{itemize}
      \item $\tyopt$ is the type $\vtone$, which is not the unconstrained integer type;
      \item annotating $\vtone$ in $\tenvone$ yields $\vt$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
  \item checking that $\vt$ is a constrained integer in $\tenvone$ via $\checkconstrainedinteger$
        yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\vt$, and local declaration keyword
        $\LDKLet$ in $\tenvonep$ yields $\newtenv$;
  \item $\declaredparams$ is $\acc$ updated by the binding of $\vx$ to $\vt$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[type\_underconstrained]{
  \checkvarnotinenv{\tenvonep, \vx} \typearrow \True \OrTypeError\\\\
  \checktrans{\vx \in \potentialparams}{\ParameterWithoutDecl} \checktransarrow \True \OrTypeError\\\\
  (\tyopt = \None \lor \tyopt = \langle \TInt(\unconstrained)\rangle) \\
  \vt \eqdef \TInt(\underconstrained(\vx))\\
  \checkconstrainedinteger(\tenvone, \vt) \typearrow \True \OrTypeError\\\\
  \addlocal(\tenvonep, \vx, \vt, \LDKLet) \typearrow \newtenv\\
  \declaredparams \eqdef \acc[\vx \mapsto \vt]
}{
  {
    \begin{array}{r}
  \annotateoneparam(\tenvone, \potentialparams, (\vx, \tyopt), (\tenvonep, \acc)) \typearrow \\ (\newtenv, \declaredparams)
    \end{array}
  }
}
\and
\inferrule[type\_annotated]{
  \checkvarnotinenv{\tenvonep, \vx} \typearrow \True \OrTypeError\\\\
  \checktrans{\vx \in \potentialparams}{\ParameterWithoutDecl} \checktransarrow \True \OrTypeError\\\\
  \vtone \neq \TInt(\unconstrained)\\
  \annotatetype{\False, \tenvone, \vtone} \typearrow \vt \OrTypeError\\\\
  \checkconstrainedinteger(\tenvone, \vt) \typearrow \True \OrTypeError\\\\
  \addlocal(\tenvonep, \vx, \vt, \LDKLet) \typearrow \newtenv\\
  \declaredparams \eqdef \acc[\vx \mapsto \vt]
}{
  {
    \begin{array}{r}
  \annotateoneparam(\tenvone, \potentialparams, (\vx, \overname{\langle\vtone\rangle}{\tyopt}),  (\tenvonep, \acc)) \typearrow \\ (\newtenv, \declaredparams)
    \end{array}
  }
}
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.ArgsAsParams \label{sec:TypingRule.ArgsAsParams}}
\hypertarget{def-argsasparams}{}
The function
\[
\begin{array}{r}
\argsasparams(
  \overname{\staticenvs}{\tenvone} \aslsep
  \overname{\staticenvs}{\tenvtwo} \aslsep
  \overname{\func}{\funcsig} \aslsep
  \overname{\identifier\rightarrow\ty}{\declaredparams}
  )
\aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\identifier\rightarrow\ty}{\argparams})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
scans the list of arguments in $\func$ ($\func.\funcargs$) to find the ones that serve as
implicit parameters in $\tenvone$ and are not already included in the domain of $\declaredparams$.
The found parameters are added as local declarations to $\tenvtwo$, resulting in $\newtenv$,
and are used to update $\argparams$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item the subprogram defined by $\funcsig$ has no arguments;
    \item $\newtenv$ is $\tenvtwo$;
    \item $\argparams$ is the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item the subprogram defined by $\funcsig$ has arguments $\varg_{1..k}$;
    \item obtaining the identifiers that can serve as parameters in the types of the formal arguments of $\funcsig$
          and in its return type yields $\vusedone$;
    \item the set $\vused$ contains all identifiers $\vs$ from $\vusedone$ that are undefined in $\tenvone$ and are not
          bound in $\declaredparams$;
    \item the following premises define the sequences $\argparams_{1..k}$ and $\tenvtwo_{0..k}$ as follows;
    \item $\argparams_1$ is $\declaredparams$;
    \item $\tenvtwo_0$ is $\tenvtwo$;
    \item for $\vi=1..k$, annotating the argument $\varg_\vi$ in $\tenvtwo$ with $\vused$ and the static environment $\tenvtwo_{\vi-1}$
          via $\argasparam$ yields $\tenvtwo_\vi$ and $\argparams_\vi$\ProseOrTypeError;
    \item $\newtenv$ is $\tenvtwo_k$;
    \item $\argparams$ is $\argparams_k$.
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following specification, the argument \texttt{B}
of the function \texttt{signature\_example} is an implicit parameter
as it appears in the type \texttt{bits(A+B)}
(both for the argument \texttt{bv3} and as the return type)
and it is not listed as an explicit parameter.
Therefore, $\newtenv$ will effectively contain the declaration \verb|let B: integer{B}|.

\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{
  \funcsig.\funcargs = \emptylist
}{
  {
    \begin{array}{r}
  \argsasparams(\tenvone, \tenvtwo, \funcsig, \declaredparams) \typearrow \\
  (\overname{\tenvtwo}{\newtenv}, \overname{\emptylist}{\argparams})
    \end{array}
  }
}
\and
\inferrule[non\_empty]{
  \funcsig.\funcargs \eqname \varg_{1..k}\\
  \tododefine{use\_func\_sig}(\funcsig) \typearrow \vusedone\\
  \vs\in\vusedone : \isundefined(\tenvone, \vs) \typearrow \vb_\vs\\
  \vused \eqdef \setcomprehension{\vs\in\vusedone \land \vb_\vs \land \declaredparams(\vs) = \bot}{\vs}\\
  \argparams_1 \eqdef \declaredparams\\
  \tenvtwo_0 \eqdef \tenvtwo\\
  \vi=1..k: \argasparam(\tenvtwo, \vused, \varg_\vi,\tenvtwo_{\vi-1}) \typearrow (\tenvtwo_\vi, \argparams_\vi) \OrTypeError
}{
  {
    \begin{array}{r}
  \argsasparams(\tenvone, \tenvtwo, \funcsig, \declaredparams) \typearrow \\
  (\overname{\tenvtwo_k}{\newtenv}, \overname{\argparams_k}{\argparams})
    \end{array}
  }
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ArgAsParam \label{sec:TypingRule.ArgAsParam}}
\hypertarget{def-argasparam}{}
The function
\[
\argasparam\left(
  \begin{array}{c}
  \overname{\staticenvs}{\tenvtwo} \aslsep\\
  \overname{\pow{\identifier}}{\vused} \aslsep\\
  (\overname{\identifier}{\vx} \times \overname{\ty}{\tty}) \aslsep\\
  (\overname{\staticenvs}{\tenvtwop} \times \overname{\identifier\rightarrow\ty}{\acc})
  \end{array}
  \right)
\aslto
(\overname{\staticenvs}{\newtenv} \times \overname{\identifier\rightarrow\ty}{\accp})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the argument given by $\vx$ and type $\tty$ is an implicit parameter
by checking whether it appears in $\vused$ and not in $\acc$.
If it is identified as an implicit parameter, it is used to update $\tenvtwop$ to yield $\newtenv$
and to update $\acc$ to yield $\accp$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{not\_used}):
  \begin{itemize}
    \item $\vx$ is not a member of $\vused$;
    \item $\newtenv$ is $\tenvtwop$;
    \item $\accp$ is $\acc$.
  \end{itemize}

  \item All of the following apply (\textsc{used}):
  \begin{itemize}
    \item $\vx$ is a member of $\vused$;
    \item checking that $\vx$ is not declared in $\tenvtwop$ yields $\True$\ProseOrTypeError;
    \item annotating $\tty$ with identifier $\vx$ as a potential parameter type in $\tenvtwo$,
          which is an environment to which all explicit parameters have been added but implicit parameters were not added to,
          via $\annotateparamtype$ yields $\vt$\ProseOrTypeError;
    \item checking whether $\vt$ is a constrained integer type in $\tenvtwo$ yields $\True$\ProseOrTypeError;
    \item adding $\vx$ as a local storage element to $\tenvtwop$ with type $\vt$ and local declaration keyword $\LDKLet$ yields
          $\newtenv$;
    \item $\accp$ is $\acc$ updated by binding $\vx$ to $\vt$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[not\_used]{
  \vx \not\in \vused
}{
  \argasparam(\tenvtwo, \vused, (\vx, \tty), (\tenvtwop, \acc))
  \typearrow (\overname{\tenvtwop}{\newtenv}, \overname{\acc}{\accp})
}
\and
\inferrule[used]{
  \vx \in \vused\\
  \checkvarnotinenv{\tenvtwop, \vx} \typearrow \True \OrTypeError\\\\
  \annotateparamtype(\tenvtwo, \tty, \vx) \typearrow \vt \OrTypeError\\\\
  \checkconstrainedinteger(\tenvtwo, \vt) \typearrow \True \OrTypeError\\\\
  \addlocal(\tenvtwop, \vx, \vt, \LDKLet) \typearrow \newtenv\\
  \accp \eqdef \acc[\vx\mapsto\vt]
}{
  \argasparam(\tenvtwo, \vused, (\vx, \tty), (\tenvtwop, \acc))
  \typearrow (\newtenv, \accp)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateParamType \label{sec:TypingRule.AnnotateParamType}}
\hypertarget{def-annotateparamtype}{}
The function
\[
  \annotateparamtype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty} \aslsep \overname{\identifier}{\vx})
  \typearrow \overname{\ty}{\newty}
\]
annotates the type $\tty$ in $\tenv$, considering it as a subprogram parameter with identifier $\vx$,
yielding the type $\newtenv$.
It is assumed that $\tenv$ is an environment to which all explicitly defined parameters of the subprogram
in context were added to, but the implicitly defined parameters were not added to.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{tint\_unconstrained}):
  \begin{itemize}
    \item $\tty$ is the unconstrained integer type;
    \item $\newty$ is the underconstrained integer type for the identifier $\vx$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\tty$ is not the unconstrained integer type;
    \item annotating the type $\tty$ in $\tenv$ yields $\newty$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
\inferrule[tint\_unconstrained]{}
{
  \annotateparamtype(\tenv, \overname{\TInt(\unconstrained)}{\tty}) \typearrow \overname{\TInt(\unconstrained(\vx))}{\newty}
}
\and
\inferrule[other]{
  \tty \neq \TInt(\unconstrained)\\
  \annotatetype{\tenv, \tty} \typearrow \newty \OrTypeError
}{
  \annotateparamtype(\tenv, \tty) \typearrow \newty
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateArgs \label{sec:TypingRule.AnnotateArgs}}
\hypertarget{def-annotateargs}{}
The function
\[
\begin{array}{r}
\annotateargs(
  \overname{\staticenvs}{\tenvtwo} \aslsep
  \overname{\staticenvs}{\tenvthree} \aslsep
  \overname{\func}{\funcsig} \aslsep
  \overname{\identifier\rightarrow\ty}{\argparams}
)
\aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\vnewargs})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the arguments listed in $\funcsig$ in the context of
of $\argparams$, which binds parameters to their types,
and two static environments:
$\tenvtwo$ --- the environment to which only explicit parameters were added, and
$\tenvthree$ --- the environment to which all parameters (explicit and implicit) were added.
The result is the environment $\newtenv$ where all arguments have been declared and
the annotated arguments $\vnewargs$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{no\_args}):
  \begin{itemize}
    \item the function defined by $\funcsig$ has no arguments;
    \item $\newtenv$ is $\tenvthree$;
    \item $\vnewargs$ is the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{some\_args}):
  \begin{itemize}
    \item the function defined by $\funcsig$ has arguments $\varg_{1..k}$;
    \item the following premises define the sequence of static environments $\tenvthree_{0..k}$ and
          list of typed identifiers $\vnewarg_{1..k}$;
    \item $\tenvthree_0$ is $\tenvthree$;
    \item annotating the argument $\varg_\vi$ in the context of $\tenvtwo$, $\tenvthree$, $\argparams$,
          and $\tenvthree_{\vi-1}$ via $\annotateonearg$ yields $(\tenvthree_\vi, \vnewarg_\vi)$\ProseOrTypeError;
    \item $\newtenv$ is $\tenvthree_k$;
    \item $\vnewargs$ is the list $\vnewarg_{1..k}$.
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following specification, the annotated arguments are
\texttt{bv}, \texttt{bv2}, \texttt{bv3}, and \texttt{C}.
The argument \texttt{B} is not annotated as an argument since it is classified
and annotated as a parameter.

\VerbatimInput{\tests/TypingRule.AnnotateFuncSig.asl}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[no\_args]{
  \funcsig.\funcargs = \emptylist
}{
  \annotateargs(\tenvtwo, \tenvthree, \funcsig, \argparams) \typearrow (\overname{\tenvthree}{\newtenv}, \overname{\emptylist}{\vnewargs})
}
\and
\inferrule[some\_args]{
  \funcsig.\funcargs \eqname \varg_{1..k}\\
  \tenvthree_{0} \eqdef \tenvthree\\
  {
    \begin{array}{r}
  \vi=1..k: \annotateonearg(\tenvtwo, \tenvthree, \argparams, (\tenvthree_{\vi-1}, \varg_{\vi})) \typearrow \\
    (\tenvthree_{\vi}, \vnewarg_\vi) \OrTypeError
    \end{array}
  }\\
  \vnewargs \eqdef [i=1..k: \vnewarg_{\vi}]
}{
  \annotateargs(\tenvtwo, \tenvthree, \funcsig, \argparams) \typearrow
  (\overname{\tenvthree_k}{\newtenv}, \vnewargs)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateOneArg \label{sec:TypingRule.AnnotateOneArg}}
\hypertarget{def-annotateonearg}{}
The function
\[
\begin{array}{r}
\annotateonearg(
  \overname{\staticenvs}{\tenvtwo} \aslsep
  \overname{\staticenvs}{\tenvthree} \aslsep
  \overname{\identifier\rightarrow\ty}{\argparams} \aslsep
  (\overname{\staticenvs}{\tenvthreep} \times (\overname{\vx}{\identifier} \times \overname{\ty}{\tty}))
) \aslto \\
(\overname{\staticenvs}{\newtenv} \times\ (\overname{\vx}{\identifier} \times \overname{\ty}{\ttyp}))
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the argument $\vx$ of type $\tty$ in the context of $\argparams$, which binds parameters to their types,
and the following static environments:
$\tenvtwo$ --- the environment to which only explicit parameters were added to,
$\tenvthree$ --- $\tenvtwo$ with the addition of implicit parameters, and
$\tenvthreep$ --- same as $\tenvthree$ but updated with previously annotated arguments.
The result is the updated environment $\newtenv$ with the added declaration for the current argument
and the annotated argument, which has the same identifier $\vx$ and the annotated type $\vtp$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{param}):
  \begin{itemize}
    \item $\vx$ is not bound in $\argparams$;
    \item annotating the type $\tty$ in $\tenvtwo$ yields $\ttyp$;
    \item $\newtenv$ is $\tenvthreep$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_param}):
  \begin{itemize}
    \item $\vx$ is bound in $\argparams$;
    \item checking that $\vx$ is not defined in $\tenvthreep$ yields $\True$\ProseOrTypeError;
    \item annotating the type $\tty$ in $\tenvthree$ yields $\ttyp$;
    \item adding a local storage element $\vx$ with type $\ttyp$ and local declaration keyword $\LDKLet$ yields
          $\newtenv$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[param]{
  \argparams(\vx) \neq \bot\\
  \annotatetype{\tenvtwo, \tty} \typearrow \ttyp \OrTypeError
}{
  \annotateonearg(\tenvtwo, \tenvthree, \argparams, (\tenvthreep, (\vx, \tty)))
  \typearrow (\overname{\tenvthreep}{\newtenv}, (\vx, \ttyp))
}
\and
\inferrule[not\_param]{
  \argparams(\vx) = \bot\\
  \checkvarnotinenv{\tenvthreep, \vx} \typearrow \True \OrTypeError\\\\
  \annotatetype{\tenvthree, \tty} \typearrow \ttyp \OrTypeError\\\\
  \addlocal(\tenvthreep, \vx, \ttyp, \LDKLet) \typearrow \newtenv
}{
  \annotateonearg(\tenvtwo, \tenvthree, \argparams, (\tenvthreep, (\vx, \tty)))
  \typearrow (\newtenv, (\vx, \ttyp))
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateReturnType \label{sec:TypingRule.AnnotateReturnType}}
\hypertarget{def-annotatereturntype}{}
The function
\[
\annotatereturntype(
  \overname{\staticenvs}{\tenvthree} \aslsep
  \overname{\staticenvs}{\tenvfour} \aslsep
  \overname{\langle\ty\rangle}{\returntype}
) \aslto
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newreturntype})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the optional return type $\returntype$ in the context of the static environment
$\tenvthree$ where all parameters have been added to, and
$\tenvfour$ where all parameters and arguments have been added to.
The result is the static environment $\newtenv$, which is $\tenvfour$ with the
annotated return type and the optional annotated return type $\newreturntype$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{no\_return\_type}):
  \begin{itemize}
    \item $\returntype$ is $\None$;
    \item $\newtenv$ is $\tenvfour$;
    \item $\newreturntype$ is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{has\_return\_type}):
  \begin{itemize}
    \item $\returntype$ is $\langle\tty\rangle$;
    \item annotating $\tty$ in $\tenvthree$ yields $\ttyp$\ProseOrTypeError;
    \item $\newreturntype$ is $\langle\ttyp\rangle$;
    \item $\newtenv$ is $\tenvfour$ with its local environment updated by binding its \\ $\funcreturntype$ field
          to $\newreturntype$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[no\_return\_type]{}
{
  \annotatereturntype(\tenvthree, \tenvfour, \overname{\None}{\returntype}) \typearrow
  (\overname{\tenvfour}{\newtenv}, \overname{\None}{\newreturntype})
}
\and
\inferrule[has\_return\_type]{
  \annotatetype{\tenvthree, \tty} \typearrow \ttyp \OrTypeError\\\\
  \newreturntype \eqdef \langle\ttyp\rangle\\
  \newtenv \eqdef (G^\tenvfour, L^\tenvfour[\funcreturntype\mapsto\newreturntype])
}{
  \annotatereturntype(\tenvthree, \tenvfour, \overname{\langle\tty\rangle}{\returntype}) \typearrow
  (\newtenv, \newreturntype)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.DeclareOneFunc \label{sec:TypingRule.DeclareOneFunc}}
\hypertarget{def-declareonefunc}{}
The function
\[
  \declareonefunc(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks that a subprogram defined by $\funcsig$ can be added to the static environment $\tenv$,
resulting in an annotated function definition $\newfuncdef$ and new static environment $\newtenv$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\funcsig$ has name $\name$, arguments $\vargs$, and type $\subprogramtype$, that is,
  \[
    \begin{array}{rrcl}
      \funcsig \eqdef \{
                      & \funcname            &:& \name,\\
                      & \funcparameters      &:& \vp,\\
                      & \funcargs            &:& \vargs,\\
                      & \funcbody            &:& \SBASL(\bd),\\
                      & \funcreturntype      &:& \vt,\\
                      & \funcsubprogramtype  &:& \subprogramtype \\
                  \}  & ; &&
        \end{array}
  \]
  \item adding a new subprogram with $\name$, $\vargs$, and $\subprogramtype$ to $\tenv$ yields the new
        environment $\tenvone$ and new name $\namep$\ProseOrTypeError;
  \item checking that $\namep$ is not already declared in the global environment of $\tenvone$
        yields $\True$\ProseOrTypeError;
  \item ensuring that each setter has a getter given $\funcsig$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\funcsigone$ is $\funcsig$ with $\name$ substituted by $\nameone$;
  \item adding a subprogram with name $\namep$ and definition $\funcsigone$ to $\tenvone$ yields $\newtenv$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\CodeSubsection{\DeclareOneFuncBegin}{\DeclareOneFuncEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rrcl}
    \funcsig \eqdef \{
                    & \funcname            &:& \name,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype \\
                \} &&&
      \end{array}
    }\\
  \addnewfunc(\tenv, \name, \vargs, \subprogramtype) \typearrow
  (\tenvone, \namep) \OrTypeError\\\\
  \checkvarnotingenv{\tenvone, \namep} \typearrow \True \OrTypeError\\\\
  \checksetterhasgetter(\tenvone, \funcsig) \typearrow \True \OrTypeError\\\\
  {
  \begin{array}{rrcl}
    \newfuncsig \eqdef \{
                    & \funcname            &:& \namep,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype \\
                \} &&&
      \end{array}
    }\\
    \addsubprogram(\tenvone, \namep, \funcsigone) \typearrow \newtenv \OrTypeError
}{
  \declareonefunc(\tenv, \funcsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}
\end{emptyformal}
\subsection{Comments}

This relates to \identi{HJRD}, \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}, and \identr{PGFC}.

\section{TypingRule.SubprogramClash \label{sec:TypingRule.SubprogramClash}}
\hypertarget{def-subprogramclash}{}
The partial function
\[
  \subprogramclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\subprogramtype}{\subpgmtype} \aslsep
    \overname{\ty^*}{\formaltypes}
  )
  \aslto
  \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the unique subprogram associated with $\name$
clashes with another subprogram
that has subprogram type $\subpgmtype$ and list of formal types $\formaltypes$,
yielding a Boolean value in $\vb$.
The result is a type error, if one is detected.

The function is only defined when there exists a binding for $\name$ in the
$\subprograms$ map of $\tenv$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the subprogram type associated with the unique subprogram named by $\name$ is $\namesubpgmtype$;
  \item applying $\subprogramtypesclash$ to $\namesubpgmtype$ and $\subpgmtype$ yields $\True$\ProseTerminateAs{\False}
        (that is, if both $\namesubpgmtype$ and $\subpgmtype$ are $\STGetter$ or both are $\STSetter$ then the
        subprogram types are considered to be non-clashing and the entire rule short-circuits to $\False$);
  \item $\nameargs$ is the list of pairs of types and identifiers associated with the function definition
        of $\name$ in $\tenv$;
  \item determining whether there is an argument clash between $\formaltypes$ and \\
        $\nameformals$ in $\tenv$ yields $\vb$\ProseOrTypeError.
\end{itemize}

\subsection{Example}

\begin{emptyformal}
\subsection{Formally}
\hypertarget{def-subprogramtypeclash}{}
We first introduce the helper predicate
\[
  \subprogramtypesclash(
    \overname{\subprogramtype}{\subpgmtypeone} \aslsep
    \overname{\subprogramtype}{\subpgmtypetwo}
  ) \aslto \overname{\Bool}{\vb}
\]
which defines whether two subprogram types are considered to be clashing:
\begin{mathpar}
\inferrule{
  \vbone \eqdef
  {
    \begin{array}{l}
  (\subpgmtypeone=\STGetter \land \subpgmtypetwo=\STSetter)\ \lor\\
  (\subpgmtypeone=\STSetter \land \subpgmtypetwo=\STGetter)
    \end{array}
  }\\\\
  \vb \eqdef \neg\vbone
}{
  \subprogramtypesclash(\subpgmtypeone, \subpgmtypetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \namesubpgmtype \eqdef G^\tenv.\subprograms(\name).\subprogramtype\\
  \subprogramtypesclash(\namesubpgmtype, \subpgmtype) \typearrow \True \terminateas \False\\
  \nameargs \eqdef G^\tenv.\subprograms(\name).\funcargs\\
  \hasargclash(\formaltypes, \nameargs) \typearrow \vb
}{
  \subprogramclash(\tenv, \namep, \subpgmtype, \formaltypes) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}

\lrmcomment{This is related to \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}.}

\section{TypingRule.AddNewFunc \label{sec:TypingRule.AddNewFunc}}
\hypertarget{def-addnewfunc}{}
The function
\[
  \begin{array}{rl}
  \addnewfunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\typedidentifier^*}{\formals} \aslsep
    \overname{\subprogramtype}{\subpgmtype})
  & \aslto\\
  (\overname{\staticenvs}{\newtenv} \times \overname{\Strings}{\newname})
  \cup \overname{\TTypeError}{\TypeErrorConfig} &
  \end{array}
\]
ensures that the subprogram given by the identifier $\name$, list of formals $\formals$,
and subprogram type $\subpgmtype$ has a unique name among all the potential subprograms
that overload $\name$.
The result is the unique subprogram identifier $\newname$, which is used to distinguish it from the overloaded
subprograms and the environment $\newtenv$, which is updated with $\newname$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{first\_name}):
  \begin{itemize}
    \item the $\subprogramrenamings$ map in the global environment of $\tenv$ does not have a binding for $\name$;
    \item $\newtenv$ is $\tenv$ with the $\subprogramrenamings$ updated by binding $\name$ to the singleton set containing
          $\name$.
  \end{itemize}

  \item All of the following apply (\textsc{name\_exists}):
  \begin{itemize}
    \item the $\subprogramrenamings$ map in the global environment of $\tenv$ binds $\name$ to the set of strings $\othernames$;
    \item $\newname$ is the unique name that will be associated with the subprogram given by the identifier $\name$, list of formals $\formals$,
          and subprogram type $\subpgmtype$. It is constructed by concatenating a hyphen (\texttt{-}) to $\name$, followed
          by a string corresponding to the number of strings in $\othernames$.
          Notice that this is not an ASL identifier, as ASL identifiers do not contain hyphens, which ensures that this string
          does not occur in any specification;
    \item $\formaltypes$ is the list of types that appear in $\formals$ in the same order;
    \item checking for each $\namep$ in $\othernames$ whether the subprogram associated with $\namep$ clashes
          with the subprogram type $\subpgmtype$ and list of types $\formaltypes$ yields $\True$
          or a type error that indicates there are multiply defined subprograms, which short-circuits the entire rule;
    \item $\newtenv$ is $\tenv$ with the $\subprogramrenamings$ updated by binding $\name$ to the union of $\othernames$ and
          $\{\newname\}$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\AddNewFuncBegin}{\AddNewFuncEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\newcommand\stringconcat[0]{\hyperlink{def-stringconcat}{\texttt{+}}}
\newcommand\stringofint[0]{\hyperlink{def-stringofnat}{\texttt{string\_of\_nat}}}

We use the following functions to construct a unique string for each subprogram:
\begin{itemize}
\hypertarget{def-stringconcat}{}
\item The function $\stringconcat : \Strings \times \Strings \rightarrow \Strings$
concatenates two strings.

\hypertarget{def-stringofnat}{}
\item The function $\stringofint : \N \rightarrow \Strings$ converts a natural number
to the corresponding string.
\end{itemize}

\begin{mathpar}
\inferrule[first\_name]{
  G^\tenv.\subprogramrenamings(\name) = \bot\\
  \newtenv \eqdef (G^\tenv.\subprogramrenamings[\name\mapsto\{\name\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \overname{\name}{\newname})
}
\and
\inferrule[name\_exists]{
  G^\tenv.\subprogramrenamings(\name) \neq \othernames\\
  k \eqdef \cardinality{\othernames}\\
  \newname \eqdef \name\ \stringconcat\ \texttt{"-"}\ \stringconcat\ \stringofint(k)\\
  \formaltypes \eqdef [(\id,\vt) \in \formals : \vt]\\
  {
    \begin{array}{l}
  \namep \in \othernames: \\ \subprogramclash(\tenv, \namep, \subpgmtype, \formaltypes) \typearrow
  \vb_{\namep} \OrTypeError
    \end{array}
  }\\\\
  {
    \begin{array}{l}
      \namep \in \othernames: \\ \checktrans{\neg\vb_{\namep}}{\SubrogramDeclaredMultipleTimes} \typearrow \True \OrTypeError
    \end{array}
    }\\\\
  \newtenv \eqdef (G^\tenv.\subprogramrenamings[\name\mapsto \othernames \cup \{\newname\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \newname)
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}

\lrmcomment{This is related to \identr{PGFC}.}

\section{TypingRule.CheckSetterHasGetter \label{sec:TypingRule.CheckSetterHasGetter}}
\hypertarget{def-checksetterhashgetter}{}
The function
\[
  \checksetterhasgetter(\overname{\staticenvs}{\tenv} \aslsep \overname{\func}{\funcsig})
  \aslto \overname{\True}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the setter procedure given by $\funcsig$ has a corresponding getter,
returning $\True$ if this condition holds and a type error otherwise.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that the subprogram type of $\funcsig$ is one of $\STSetter$ and \\ $\STEmptySetter$
        has one of two outcomes:
        $\False$, which satisfies the premise;
        or $\True$, which short-circuits the entire rule
        (since the subprogram is not any kind of setter and no getter is required);
  \item \view\ the list of arguments of $\funcsig$ (that is, $\funcsig.\funcargs$) as follows:
        the head is an argument that has the type $\rettype$;
        the tail is a list with arguments that have the types $\argtypes$;
  \item applying $\subprogramforname$ to look up $\tenv$ for a subprogram with the name given by $\funcsig$ (that is, $\funcsig.\funcname$)
        yields a subprogram definition AST node $\funcsigp$\ProseOrTypeError;
  \item define $\watendgettertype$ as $\STGetter$ if $\funcsig.\subprogramtype$ is \\ $\STSetter$ and
        $\STEmptyGetter$ otherwise (meaning, $\funcsig.\subprogramtype$ is $\STEmptySetter$);
  \item checking that $\watendgettertype$ is the same as $\funcsigp.\funcsubprogramtype$ \\ yields $\True$\ProseOrTypeError;
  \item define $\argtypesp$ as the list of types appearing in the signature of $\funcsigp$ (that is, in $\funcsigp.\funcargs$);
  \item checking, for each index $\vi$ in the indices for $\argtypes$, that the type at $\argtypes[\vi]$ and the type at $\argtypesp[\vi]$
        are \typeequivalent\ yields $\True$\ProseOrTypeError;
  \item checking that $\rettype$ and $\funcsigp.\funcreturntype$ are \typeequivalent\ yields $\True$\ProseOrTypeError;
  \item define $\vb$ as $\True$ (that is, unless the rule short-circuited with a type error).
\end{itemize}

\subsection{Example}

\CodeSubsection{\CheckSetterHasGetterBegin}{\CheckSetterHasGetterEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
We define the helper function
\newcommand\matchsettertype[0]{\hyperlink{def-matchsettertype}{\texttt{match\_setter\_type}}}
\hypertarget{def-matchsettertype}{}
\[
  \matchsettertype \triangleq [\STSetter \mapsto \STGetter, \STEmptySetter \mapsto \STEmptyGetter] \enspace.
\]

\begin{mathpar}
\inferrule{
  \issetter \eqdef \funcsig.\subprogramtype \in \{ \STSetter, \STEmptySetter\}\\
  \booltrans{\issetter} \booltransarrow \False \terminateas \True\\\\
  \funcsig.\funcargs \eqname (\Ignore, \rettype) \concat \vargs\\
  \argtypes \eqdef [(\Ignore, \vt) \in \vargs: \vt]\\
  \subprogramforname(\tenv, \funcsig.\funcname, \argtypes) \typearrow (\Ignore, \Ignore, \funcsigp) \OrTypeError\\\\
  \matchsettertype(\funcsig.\funcsubprogramtype) \typearrow \watendgettertype\\
  \checktrans{\watendgettertype = \funcsigp.\funcsubprogramtype}{\SetterWithoutGetter} \typearrow \True \OrTypeError\\
  \argtypesp \eqdef [(\Ignore, \vt) \in \funcsigp.\funcargs : \vt]\\
  \vi\in\listrange(\argtypes): \typeequal(\argtypes[\vi], \argtypesp[\vi]) \typearrow \vb_\vi \OrTypeError\\\\
  \vi\in\listrange(\argtypes): \checktrans{\vb_\vi}{\SetterWithoutGetter} \typearrow \True \OrTypeError\\\\
  \typeequal(\rettype, \funcsigp.\funcreturntype) \typearrow \vb_\ret \OrTypeError\\\\
  \checktrans{\vb_\ret}{\SetterWithoutGetter} \typearrow \True \OrTypeError
}{
  \checksetterhasgetter(\tenv, \funcsig) \typearrow \overname{\True}{\vb}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AddSubprogram \label{sec:TypingRule.AddSubprogram}}
\hypertarget{def-addsubprogram}{}
The function
\[
  \addsubprogram(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\func}{\funcdef})
   \aslto
  \overname{\staticenvs}{\newtenv}
\]
updates the global environment of $\tenv$ by mapping the (unique) subprogram identifier $\name$
to the function definition $\funcdef$ in $\tenv$, resulting in a new static environment $\newtenv$.

\subsection{Prose}
$\newtenv$ is $\tenv$ with its $\subprograms$ component updated by binding $\name$ to $\funcdef$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \newtenv \eqdef (G^\tenv.\subprograms[\name\mapsto\funcdef], L^\tenv)
}{
  \addsubprogram(\tenv, \name, \funcdef) \typearrow \newtenv
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.DeclareGlobalStorage \label{sec:TypingRule.DeclareGlobalStorage}}
\hypertarget{def-declareglobalstorage}{}
The function
\[
  \declareglobalstorage(\overname{\staticenvs}{\tenv} \aslsep \overname{\globaldecl}{\gsd})
  \aslto
  \overname{\staticenvs}{\newtenv} \aslsep \overname{\globaldecl}{\newgsd}
  \cup
  \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the global storage declaration $\gsd$ in the static environment $\tenv$,
yielding a modified static environment $\newtenv$ and annotated global storage declaration $\newgsd$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\gsd$ is a global storage declaration with keyword $\keyword$, initial value \\ $\initialvalue$,
        optional type $\tyopt$, and name $\name$;
  \item checking that $\name$ is not already declared in the global environment of $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the optional type $\tyoptp$ in $\tenv$ via $\annotatetypeopt$ yields $\tyoptp$\ProseOrTypeError;
  \item annotating the optional expression $\initialvalue$ in $\tenv$ via $\annotateexpropt$ yields
        $(\initialvaluetype, \initialvaluep)$\ProseOrTypeError;
  \item choosing the correct type between $\initialvaluetype$ and $\tyoptp$ in $tenv$ via $\annotateinittype$ yields
        $\declaredt$;
  \item adding a global storage element with name $\name$, global declaration keyword \\ $\keyword$ and type $\declaredt$
        to $\tenv$ via $\addglobalstorage$ yields $\tenvone$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{constant}):
    \begin{itemize}
      \item $\keyword$ is $\GDKConstant$ and therefore $\initialvalue$ is some expression $\ve$ (the ASL parser guarantees
            that the expression exists);
      \item symbolically simplifying $\ve$ in $\tenvone$ via $\reduceconstants$ yields the literal $\vv$\ProseOrTypeError;
      \item $\tenvtwo$ is $\tenvone$ with its $\constantvalues$ component updated by binding $\name$ to $\vv$;
      \item $\newgsd$ is $\gsd$ with its type component as $\tyoptp$;
      \item $\newtenv$ is $\tenvtwo$.
    \end{itemize}

    \item All of the following apply (\textsc{non\_contant}):
    \begin{itemize}
      \item $\keyword$ is not $\GDKConstant$;
      \item $\newtenv$ is $\tenvone$.
    \end{itemize}
  \end{itemize}
  \item $\newgsd$ is $\gsd$ with its type component as $\tyoptp$ and $\initialvalue$ component as $\initialvaluep$;
\end{itemize}

\subsection{Example}

\CodeSubsection{\DeclareGlobalStorageBegin}{\DeclareGlobalStorageEnd}{../Typing.ml}
\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[constant]{
  \gsd \eqname \{
    \GDkeyword : \keyword,
    \GDinitialvalue : \initialvalue,
    \GDty : \tyopt,
    \GDname: \name
  \}\\
\checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
\annotatetypeopt(\tenv, \tyopt) \typearrow \tyoptp \OrTypeError\\\\
\annotateexpropt(\tenv, \initialvalue) \typearrow (\initialvaluetype, \initialvaluep) \OrTypeError\\\\
\annotateinittype(\tenv, \initialvaluetype, \tyoptp) \typearrow \declaredt\\
\addglobalstorage(\tenv, \name, \keyword, \declaredt) \typearrow \tenvone \OrTypeError\\\\
\keyword = \GDKConstant\\
\initialvaluep \eqname \langle \ve \rangle\\
\reduceconstants(\tenvone, \ve) \typearrow \vv \OrTypeError\\\\
\tenvtwo \eqdef (G^\tenvone.\constantvalues[\name\mapsto\vv], L^\tenvone)\\
\newgsd \eqdef \{
  \GDkeyword : \keyword,
  \GDinitialvalue : \initialvalue,
  \GDty : \tyoptp,
  \GDname: \name
\}
}{
  \declareglobalstorage(\tenv, \gsd) \typearrow (\overname{\tenvtwo}{\newtenv}, \newgsd)
}
\and
\inferrule[non\_constant]{
  \gsd \eqname \{
    \GDkeyword : \keyword,
    \GDinitialvalue : \initialvalue,
    \GDty : \tyopt,
    \GDname: \name
  \}\\
\checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
\annotatetypeopt(\tenv, \tyopt) \typearrow \tyoptp \OrTypeError\\\\
\annotateexpropt(\tenv, \initialvalue) \typearrow (\initialvaluetype, \initialvaluep) \OrTypeError\\\\
\annotateinittype(\tenv, \initialvaluetype, \tyoptp) \typearrow \declaredt\\
\addglobalstorage(\tenv, \name, \keyword, \declaredt) \typearrow \tenvone \OrTypeError\\\\
\keyword \neq \GDKConstant\\
\newgsd \eqdef \{
  \GDkeyword : \keyword,
  \GDinitialvalue : \initialvalue,
  \GDty : \tyoptp,
  \GDname: \name
\}
}{
  \declareglobalstorage(\tenv, \gsd) \typearrow (\overname{\tenvone}{\newtenv}, \newgsd)
}
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
This relates to \identr{YSPM} and \identr{FWQM}.

\section{TypingRule.AnnotateTypeOpt \label{sec:TypingRule.AnnotateTypeOpt}}
\hypertarget{def-annotatetypeopt}{}
The function
\[
\annotatetypeopt(\overname{\staticenvs}{\tenv} \aslsep \overname{\langle\overname{\ty}{\vt}\rangle}{\tyopt})
\typearrow \overname{\langle\ty\rangle}{\tyoptp}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the type $\vt$ inside an optional $\tyopt$, if there is one, and leaves it as is if $\tyopt$ is $\None$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\tyoptp$ is $\None$;
    \item $\tyoptp$ is $\tyopt$.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\tyoptp$ contains the type $\vt$;
    \item annotating $\vt$ in $\tenv$ yields $\vtone$\ProseOrTypeError;
    \item $\tyoptp$ is $\langle\vtone\rangle$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \annotatetypeopt(\tenv, \overname{\None}{\tyopt}) \typearrow \overname{\tyopt}{\tyoptp}
}
\and
\inferrule[some]{
  \annotatetype{\tenv, \vt} \typearrow \vtone \OrTypeError
}{
  \annotatetypeopt(\tenv, \overname{\langle\vt\rangle}{\tyopt}) \typearrow\overname{\langle\vtone\rangle}{\tyoptp}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateExprOpt \label{sec:TypingRule.AnnotateExprOpt}}
\hypertarget{def-annotateexpropt}{}
The function
\[
  \annotateexpropt(\overname{\staticenvs}{\tenv} \aslsep \overname{\langle\ve\rangle}{\expropt})
  \aslto \overname{(\langle\expr\rangle \times \langle\ty\rangle)}{\vres}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the optional expression $\expropt$ in $\tenv$ and returns a pair of optional expressions
for the type and annotated expression in $\vres$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\exproptp$ is $\None$;
    \item $\vres$ is $(\None, \None)$.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\exproptp$ contains the expression $\ve$;
    \item annotating $\ve$ in $\tenv$ yields $(\vt, \vep)$\ProseOrTypeError;
    \item $\vres$ is $(\langle\vt\rangle, \langle\vep\rangle)$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[none]{}{
  \annotateexpropt(\tenv, \overname{\None}{\expropt}) \typearrow (\None, \None)
}
\and
\inferrule[some]{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \vep)\OrTypeError
}{
  \annotateexpropt(\tenv, \overname{\langle\ve\rangle}{\expropt}) \typearrow \overname{(\langle\vt\rangle, \langle\vep\rangle)}{\vres}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateInitType \label{sec:TypingRule.AnnotateInitType}}
\hypertarget{def-annotateinittype}{}
The function
\[
  \annotateinittype(\overname{\staticenvs}{\tenv} \aslsep
  \overname{\langle\ty\rangle}{\initialvaluetype} \aslsep
  \overname{\langle\ty\rangle}{\typeannotation}
  )
  \aslto \overname{\ty}{\declaredtype}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
takes the optional type associated with the initialization value of a global storage declaration --- $\initialvaluetype$ ---
and the optional type annotation for the same global storage declaration --- $\typeannotation$ ---
and chooses the type that should be associated with the declaration --- $\declaredtype$ -- in $\tenv$.
The result is a type error, if one is detected.

The ASL parser ensures that at least one of $\initialvaluetype$ and \\
$\typeannotation$ should not be $\None$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{both}):
  \begin{itemize}
    \item $\initialvaluetype$ is $\langle\vtone\rangle$ and $\typeannotation$ is $\langle\vttwo\rangle$;
    \item checking that $\vtone$ \typesatisfies\ $\vttwo$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\declaredtype$ is $\vtone$.
  \end{itemize}

  \item All of the following apply (\textsc{annotated}):
  \begin{itemize}
    \item $\initialvaluetype$ is $\None$ and $\typeannotation$ is $\langle\vttwo\rangle$;
    \item $\declaredtype$ is $\vttwo$.
  \end{itemize}

  \item All of the following apply (\textsc{initial}):
  \begin{itemize}
    \item $\initialvaluetype$ is $\langle\vtone\rangle$ and $\typeannotation$ is $\None$;
    \item $\declaredtype$ is $\vtone$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
\inferrule[both]{
  \checktypesat(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError
}{
  \annotateinittype(\tenv, \overname{\langle\vtone\rangle}{\initialvaluetype}, \overname{\langle\vttwo\rangle}{\typeannotation})
  \typearrow \vttwo
}
\and
\inferrule[annotated]{}{
  \annotateinittype(\tenv, \overname{\None}{\initialvaluetype}, \overname{\langle\vttwo\rangle}{\typeannotation})
  \typearrow \vttwo
}
\and
\inferrule[initial]{}{
  \annotateinittype(\tenv, \overname{\langle\vtone\rangle}{\initialvaluetype}, \overname{\None}{\typeannotation})
  \typearrow \vtone
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AddGlobalStorage \label{sec:TypingRule.AddGlobalStorage}}
\hypertarget{def-addglobalstorage}{}
The function
\[
  \addglobalstorage(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\GDkeyword}{\keyword} \aslsep
    \overname{\ty}{\declaredt}
  )
  \aslto
    \overname{\staticenvs}{\newtenv} \aslsep
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
modifies the static environment $\tenv$ by adding a global storage
for the identifier $\name$ with global storage keyword $\keyword$ and type $\declaredtypes$,
resulting in the environment $\newtenv$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that $\name$ is not declared in the global environment of $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\newtenv$ is $\tenv$ with its $\globalstoragetypes$ component updated by binding $\name$ to
        $(\declaredt, \keyword)$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
  \newtenv \eqdef (G^\tenv.\globalstoragetypes[\name \mapsto (\declaredt, \keyword)], L^\tenv)
}
{
  \addglobalstorage(\tenv, \name, \keyword, \declaredt) \typearrow \newtenv
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.DeclareType \label{sec:TypingRule.DeclareType}}
\hypertarget{def-declaretype}{}
The function
\[
\declaretype(\overname{\staticenvs}{\tenv} \aslsep
            \overname{\identifier}{\name} \aslsep
            \overname{\ty}{\tty} \aslsep
            \overname{\langle(\identifier\times\field^*)\rangle}{\vs}
) \aslto \overname{\staticenvs}{\newtenv}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
declares a type named $\name$ with type $\tty$ and optional additional fields
over another type $\vs$
in the static environment $\tenv$, resulting in the modified environment $\newtenv$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that $\name$ is not already declared in the global environment of $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the optional extra fields $\vs$ for $\tty$ in $\tenv$ yields via \\ $\annotateextrafields$
        yields the modified environment $\tenvone$ and type $\vtone$\ProseOrTypeError;
  \item annotating $\vtone$ in $\tenvone$ yields $\vttwo$\ProseOrTypeError;
  \item $\tenvtwo$ is $\tenvone$ with its $\declaredtypes$ component updated by binding $\name$ to $\vttwo$;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{enum}):
    \begin{itemize}
      \item $\vttwo$ is an enumeration type with labels $\ids$, that is, $\TEnum(\ids)$;
      \item annotating the enumeration declaration $\vttwo$ in $\tenvtwo$ via \\
            $\tododefine{annotate\_enum\_decl}$ yields $\newtenv$\ProseOrTypeError.
    \end{itemize}

    \item All of the following apply (\textsc{not\_enum}):
    \begin{itemize}
      \item $\vttwo$ is not an enumeration type;
      \item $\newtenv$ is $\tenvtwo$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\DeclareTypeBegin}{\DeclareTypeEnd}{../Typing.ml}
\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[enum]{
  \checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
  \annotateextrafields(\tenv, \tty, \vs) \typearrow (\tenvone, \vtone)\\
  \annotatetype{\True, \tenvone, \vtone} \typearrow \vttwo \OrTypeError\\\\
  \tenvtwo \eqdef (G^\tenvone.\declaredtypes[\name\mapsto\vttwo], L^\tenvone)\\
  \vttwo = \TEnum(\ids)\\
  \declareenumlabels(\tenvtwo, \vttwo) \typearrow \newtenv \OrTypeError
}{
  \declaretype(\tenv, \name, \tty, \vs) \typearrow \newtenv
}
\and
\inferrule[not\_enum]{
  \checkvarnotingenv{\tenv, \name} \typearrow \True \OrTypeError\\\\
  \annotateextrafields(\tenv, \tty, \vs) \typearrow (\tenvone, \vtone)\\
  \annotatetype{\True, \tenvone, \vtone} \typearrow \vttwo \OrTypeError\\\\
  \tenvtwo \eqdef (G^\tenvone.\declaredtypes[\name\mapsto\vttwo], L^\tenvone)\\
  \astlabel(\vttwo) \neq \TEnum
}{
  \declaretype(\tenv, \name, \tty, \vs) \typearrow \overname{\tenvtwo}{\newtenv}
}
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
\lrmcomment{This is related to \identr{DHRC}, \identd{YZBQ}, \identr{DWSP}, \identi{MZXL}, \identr{MDZD}, \identr{CHKR}.}

\section{TypingRule.AnnotateExtraFields \label{sec:TypingRule.AnnotateExtraFields}}
\hypertarget{def-annotateextrafields}{}
The function
\[
\begin{array}{r}
\annotateextrafields(\overname{\staticenvs}{\tenv} \aslsep
  \overname{\ty}{\tty} \aslsep
  \overname{\langle(\overname{\identifier}{\vsuper}\times\overname{\field^*}{\extrafields})\rangle}{\vs}
)
\aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newty})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the type $\tty$ with the optional extra fields $\vs$ in $\tenv$, yielding
the modified environment $\newtenv$ and type $\newty$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vs$ is $\None$;
    \item $\newtenv$ is $\tenv$;
    \item $\newty$ is $\tty$.
  \end{itemize}

  \item All of the following apply (\textsc{empty\_fields}):
  \begin{itemize}
    \item $\vs$ is $(\vsuper, \emptylist)$;
    \item checking that $\tty$ \subtypesatisfies\ the named type $\vsuper$ (that is, \\ $\TNamed(\vsuper)$) yields
          $\True$\ProseOrTypeError;
    \item $\newtenv$ is $\tenv$;
    \item $\newty$ is $\tty$.
  \end{itemize}

  \item All of the following apply (\textsc{no\_super}):
  \begin{itemize}
    \item $\vs$ is $(\vsuper, \emptylist)$;
    \item checking that $\tty$ \subtypesatisfies\ the named type $\vsuper$ (that is, \\ $\TNamed(\vsuper)$) yields
          $\True$\ProseOrTypeError;
    \item $\vsuper$ is not bound to a type in $\tenv$;
    \item the result is a type error indicating that $\vsuper$ is not a declared type.
  \end{itemize}

  \item All of the following apply (\textsc{structured}):
  \begin{itemize}
    \item $\vs$ is $(\vsuper, \emptylist)$;
    \item checking that $\tty$ \subtypesatisfies\ the named type $\vsuper$ (that is,\\ $\TNamed(\vsuper)$) yields
          $\True$\ProseOrTypeError;
    \item $\vsuper$ is bound to a type $\vt$ in $\tenv$;
    \item checking that $\vt$ is either a record type or an exception type yields $\True$ or a type error
          indicating that either a record type or an exception was expected, thereby short-circuiting the entire rule;
    \item $\vt$ has AST label $L$ and fields $\fields$;
    \item $\newty$ is the type with AST label $L$ and list fields that is the concatenation of $\fields$ and $\extrafields$;
    \item $\newtenv$ is $\tenv$ with its $\subtypes$ component updated by binding $\name$ to $\vsuper$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
\inferrule[none]{}{
  \annotateextrafields(\tenv, \tty, \overname{\None}{\vs}) \typearrow (\overname{\tenv}{\newtenv}, \overname{\tty}{\newty})
}
\and
\inferrule[empty\_fields]{
  \vs = \langle(\vsuper, \emptylist)\rangle\\
  \subtypesat(\tty, \TNamed(\vsuper)) \typearrow \vb\\
  \checktrans{\vb}{TypeConflict} \typearrow \True \OrTypeError
}{
  \annotateextrafields(\tenv, \tty, \vs) \typearrow (\overname{\tenv}{\newtenv}, \overname{\tty}{\newty})
}
\and
\inferrule[no\_super]{
  \subtypesat(\tty, \TNamed(\vsuper)) \typearrow \vb\\
  \checktrans{\vb}{TypeConflict} \typearrow \True \OrTypeError\\\\
  G^\tenv.\declaredtypes(\vsuper) = \bot
}{
  \annotateextrafields(\tenv, \tty, \overname{\langle(\vsuper, \extrafields)\rangle}{\vs}) \typearrow
  \TypeErrorVal{\UndefinedIdentifier}
}
\and
\inferrule[structured]{
  \subtypesat(\tty, \TNamed(\vsuper)) \typearrow \vb\\
  \checktrans{\vb}{TypeConflict} \typearrow \True \OrTypeError\\\\
  G^\tenv.\declaredtypes(\vsuper) = \vt\\
  \checktrans{\astlabel(\vt) \in \{\TRecord, \TException\}}{ExpectedStructuredType} \typearrow \True \OrTypeError\\\\
  \vt \eqname L(\fields)\\
  \newty \eqdef L(\fields \concat \extrafields)\\
  \newtenv \eqdef (G^\tenv.\subtypes[\name\mapsto\vsuper], L^\tenv)
}{
  \annotateextrafields(\tenv, \tty, \overname{\langle(\vsuper, \extrafields)\rangle}{\vs}) \typearrow (\newtenv, \newty)
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.AnnotateEnumLabels \label{sec:TypingRule.AnnotateEnumLabels}}
\hypertarget{def-annotateenumlabels}{}
The function
\[
\declareenumlabels(\overname{\staticenvs}{\tenv} \aslsep
  \overname{\identifier}{\name} \aslsep
  \overname{\identifier^+}{\ids} \aslsep
  \aslto \overname{\staticenvs}{\newtenv}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
)
\]
updates the static environment $\tenv$ with the identifiers $\ids$ listed by an enumeration type,
yielding the modified environment $\newtenv$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ids$ is the (non-empty) list of labels $\id_{1..k}$;
  \item $\tenv_0$ is $\tenv$;
  \item declaring the constant $\id_i$ with the type $\TNamed(\name)$ and literal \lint(i-1) in $\tenv_{i-1}$
        via $\declareconst$
        yields $\tenv_i$, for $i=1 $ to $k$ (if $k>1$)\ProseOrTypeError;
  \item $\newtenv$ is $\tenv_k$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \ids \eqname \id_{1..k}\\
  \tenv_0 \eqdef \tenv\\
  \vi=1..k: \declareconst(\tenv_{\vi-1}, \id_\vi, \TNamed(\name), \lint(\vi-1)) \typearrow \tenv_{\vi} \OrTypeError
}{
  \declareenumlabels(\tenv, \name, \ids) \typearrow \overname{\tenv_k}{\newtenv}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.DeclareConst \label{sec:TypingRule.DeclareConst}}
\hypertarget{def-declareconst}{}
The function
\[
\declareconst(\overname{\staticenvs}{\tenv} \aslsep
              \overname{\identifier}{\name} \aslsep
              \overname{\ty}{\tty} \aslsep
              \overname{\literal}{vv})
              \aslto
              \overname{\staticenvs}{\newtenv} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
adds a constant given by the identifier $\name$, type $\tty$, and literal $\vv$ to the
static environment $\tenv$, yielding the modified environment $\newtenv$.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item adding the global storage given by the identifier $\name$, global declaration keyword $\GDKConstant$,
        and type $\tty$ to $\tenv$ yields $\tenvone$;
  \item $\newtenv$ is $\tenvone$ with its $\constantvalues$ component updated by binding $\name$ to $\vv$.
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
\inferrule{
  \addglobalstorage(\tenv, \name, \GDKConstant, \tty) \typearrow \tenvone\\
  \newtenv \eqdef (G^\tenvone.\constantvalues[\name, \vv], L^\tenvone)
}{
  \declareconst(\tenv, \name, \tty, \vv) \typearrow \newtenv
}
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Specifications}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An ASL specification consists of a list of declarations.
The type system does not take the order of declarations into consideration.
More precisely, the type system operates over the declarations after they have been
ordered based on their dependencies.
Type checking the specification succeeds if all declarations can be successfully annotated.

\section{TypingRule.Specification \label{sec:TypingRule.Specification}}
\subsection{Prose}
Annotating an ASL specification $\decls$ in an environment $\tenv$ results in an annotated specification $\declsp$
and a new environment $\newenv$ and all of the following apply:
\begin{itemize}
  \item $\ordereddecls$ is the result of topologically ordering $\decls$ according to their
  mutual dependencies.
  \item \newtenv\ is the result of declaring all global declarations in $\ordereddecls$ in \tenv.
  \item $\declsp$ is the result of annotating every declaration in $\decls$ in the environment \newtenv.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SpecificationBegin}{\SpecificationEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \texttt{order\_topologically}(\tenv, \decls) \typearrow \ordereddecls\\
    \ordereddecls = [i=1..k: \vd_i]\\
    \tenv_0 = \tenv\\
    i=1..k: \declaredecl{\tenv_{i-1}, \vd_{i-1}} \typearrow \tenv_{i}\\
    \newtenv = \tenv_{k}\\
    \decls' = [i=1..k: \texttt{annotate\_decl}(\newtenv, \vd_i) ]
  }
  { \annotatespec{\tenv, \decls} \typearrow (\decls', \newtenv) }
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
This relates to \identi{LWQQ}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Static Evaluation \label{chap:staticevaluation}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we define how to statically evaluate a subset of expressions
and how to apply basic operators to literals via the following rules:
\begin{itemize}
  \item TypingRule.StaticEval (see \secref{TypingRule.StaticEval})
  \item TypingRule.UnopLiterals (see \secref{TypingRule.UnopLiterals})
  \item TypingRule.BinopLiterals (see \secref{TypingRule.BinopLiterals})
\end{itemize}
We also define the following helper rules:
\begin{itemize}
  \item TypingRule.SlicesToPositions (see \secref{TypingRule.SlicesToPositions})
  \item TypingRule.SliceToPositions (see \secref{TypingRule.SliceToPositions})
  \item TypingRule.EvalToInt (see \secref{TypingRule.EvalToInt})
  \item TypingRule.ExtractSlice (see \secref{TypingRule.ExtractSlice})
\end{itemize}

\hypertarget{def-unsupportedexpression}
In this chapter and the following ones, we use the special value $\CannotBeTransformed$
to represent a failure in transforming an expression into a desired form (the specific
desired form varies according to the functions utilizing this value).

\hypertarget{def-staticeval}{}
\section{TypingRule.StaticEval \label{sec:TypingRule.StaticEval}}
The function
\[
  \staticeval(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \;\aslto\;
  \overname{\literals}{\vv} \cup
  \{\CannotBeTransformed\}
  \overname{\TTypeError}{\TypeErrorConfig}
\]
evaluates an expression $\ve$, from a restricted subset of all expressions,
in the static environment $\tenv$, returning a literal $\vv$.
If $\ve$ is not in the restricted set of expressions or cannot be statically evaluated to a compile-time
constant, the result is $\CannotBeTransformed$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{e\_literal}):
  \begin{itemize}
    \item $\ve$ is the literal expression for the literal $\vv$, that is, $\ELiteral(\vv)$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression with the identifier $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is bound to a constant in $\tenv$ via $\lookupconstant$ yields the literal $\vv$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_non\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression with the identifier $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is bound to a constant in $\tenv$ via $\lookupconstant$ yields $\bot$
          (that is, $\vx$ is not bound to a constant);
    \item checking whether $\vx$ is defined in $\tenv$ yields $\True$\ProseOrTypeError;
    \item the result is $\CannotBeTransformed$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop}):
  \begin{itemize}
    \item $\ve$ is a binary operation expression with operator $\op$ and operand expressions $\veone$ and $\vetwo$,
          that is, $\EBinop(\op, \veone, \vetwo)$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the literal $\vvone$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item applying $\staticeval$ to $\vetwo$ in $\tenv$ yields the literal $\vvtwo$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item applying $\op$ to $\vvone$ and $\vvtwo$ via $\binopliterals$ yields $\vv$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop}):
  \begin{itemize}
    \item $\ve$ is a unary operation expression with operator $\op$ and operand expression $\veone$,
          that is, $\EUnop(\op, \veone)$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the literal $\vvone$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item applying $\op$ to $\vvone$ via $\unopliterals$ yields $\vv$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice\_int}):
  \begin{itemize}
    \item $\ve$ is a slicing expression of the integer literal for $\vi$ and slice list $\vslices$, that is,
          $\ESlice(\lint(\vi), \vslices)$;
    \item obtaining the indices of the slice list $\vslices$ in $\tenv$ via $\slicestopositions$
          yields $\positions$\ProseOrTypeError;
    \item $\posmax$ is the maximum index in $\positions$;
    \item converting the first $\posmax+1$ digits of the binary representation of $\vi$ into a bitvector
          via $\inttobits$ yields $\bvone$;
    \item extracting the slice of $\bvone$ given by $\positions$ yields $\bvtwo$\ProseOrTypeError;
    \item $\vv$ is the bitvector literal for $\bvtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice\_bitvector}):
  \begin{itemize}
    \item $\ve$ is a slicing expression of the bitvector literal for $\bv$ and slice list $\vslices$, that is,
          $\ESlice(\lbitvector(\bv), \vslices)$;
    \item obtaining the indices of the slice list $\vslices$ in $\tenv$ via $\slicestopositions$
          yields $\positions$\ProseOrTypeError;
    \item $\posmax$ is the maximum index in $\positions$;
    \item checking that the length of $\bv$ is greater than $\posmax$ (which is $0$-based) yields $\True$\ProseOrTypeError;
    \item extracting the slice of $\bv$ given by $\positions$ yields $\bvtwo$\ProseOrTypeError;
    \item $\vv$ is the bitvector literal for $\bvtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice\_type\_error}):
  \begin{itemize}
    \item $\ve$ is a slicing expression of sub-expression $\veone$ and slice list $\vslices$, that is, $\ESlice(\veone, \vslices)$;
    \item $\veone$ is neither an integer literal nor a bitvector literal;
    \item the result is a type error indicating that either an integer literal or a bitvector literal were expected.
  \end{itemize}

  \item All of the following apply (\textsc{e\_cond}):
  \begin{itemize}
    \item $\ve$ is a conditional expression with condition sub-expression $\econd$ and sub-expressions $\veone$ (true case)
          and $\vetwo$ (false case), that is, $\ECond(\econd, \veone, \vetwo)$;
    \item evaluating $\econd$ in $\tenv$ either yields a Boolean literal $\vb$ or a type error or $\CannotBeTransformed$,
          either of which short-circuits the rule;
    \item $\vep$ is $\veone$ if $\vb$ is $\True$ and $\vetwo$ otherwise;
    \item the result is given by applying $\staticeval$ to $\vep$ in $\tenv$.
  \end{itemize}

  \item All of the following apply (\textsc{unsupported}):
  \begin{itemize}
    \item $\ve$ is an expression that is not one of the following: a literal, a variable, a binary operation expression,
          a unary operation expression, a slice expression, and a conditional expression;
    \item the result is a type error indicating that $\ve$ is not an expression that is supported
          for static evaluation.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[e\_literal]{}
{
  \staticeval(\tenv, \overname{\ELiteral(\vv)}{\ve}) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_constant]{
  \lookupconstant(\tenv, \vx) \typearrow \vv
}{
  \staticeval(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vv
}
\and
\inferrule[e\_var\_non\_constant]{
  \lookupconstant(\tenv, \vx) \typearrow \bot\\
  \isundefined(\tenv, \vx) \typearrow \vb\\
  \checktrans{\neg\vb}{\UndefinedIdentifier} \typearrow \True \OrTypeError
}{
  \staticeval(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \CannotBeTransformed
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{
  \staticeval(\tenv, \veone) \typearrow \vvone \terminateas \TypeErrorConfig, \CannotBeTransformed\\\\
  \staticeval(\tenv, \vetwo) \typearrow \vvtwo \terminateas \TypeErrorConfig, \CannotBeTransformed\\\\
  \binopliterals(\op, \vvone, \vvtwo) \typearrow \vv \OrTypeError
}{
  \staticeval(\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{
  \staticeval(\tenv, \veone) \typearrow \vvone \terminateas \TypeErrorConfig, \CannotBeTransformed\\\\
  \unopliterals(\op, \vvone) \typearrow \vv \OrTypeError
}{
  \staticeval(\tenv, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice\_int]{
  \slicestopositions(\tenv, \slices) \typearrow \positions \OrTypeError\\\\
  \posmax \eqdef \max(\positions)\\
  \bvone \eqdef \inttobits(\vi, \posmax + 1)\\
  \extractslice(\bvone, \positions) \typearrow \bvtwo \OrTypeError
}{
  \staticeval(\tenv, \overname{\ESlice(\lint(\vi), \slices)}{\ve}) \typearrow \overname{\lbitvector(\bvtwo)}{\vv}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice\_bitvector]{
  \slicestopositions(\tenv, \slices) \typearrow \positions \OrTypeError\\\\
  \posmax \eqdef \max(\positions)\\
  \checktrans{\listlen{\bv} > \posmax}{SliceOutOfRange} \checktransarrow \True \OrTypeError\\\\
  \extractslice(\bv, \positions) \typearrow \bvtwo \OrTypeError
}{
  \staticeval(\tenv, \overname{\ESlice(\lbitvector(\bv), \slices)}{\ve}) \typearrow \overname{\lbitvector(\bvtwo)}{\vv}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice\_type\_error]{
  \astlabel(\veone) \not\in \{\lint, \lbitvector\}
}{
  \staticeval(\tenv, \overname{\ESlice(\veone, \slices)}{\ve}) \typearrow \TypeErrorVal{TypeMismatch}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{
  \staticeval(\tenv, \econd) \typearrow \vcond \terminateas \TypeErrorConfig, \CannotBeTransformed\\\\
  \vcond \eqname \lbool(\vb)\\
  \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\
  \staticeval(\tenv, \vep) \typearrow \vv \terminateas \TypeErrorConfig, \CannotBeTransformed
}{
  \staticeval(\tenv, \overname{\ECond(\econd, \veone, \vetwo)}{\ve}) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[unsupported]{
  \astlabel(\ve) \not\in \{ \ELiteral, \EVar, \EBinop, \EUnop, \ESlice, \ECond\}
}{
  \staticeval(\tenv, \ve) \typearrow \TypeErrorVal{UnsupportedExpression}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.UnopLiterals \label{sec:TypingRule.UnopLiterals}}
\hypertarget{def-unopliterals}{}
The function
\[
  \unopliterals(\overname{\unop}{\op} \aslsep \overname{\literals}{\vl}) \aslto
  \overname{\literals}{\vr} \cup \TTypeError
\]
statically evaluates a unary operator $\op$ (a terminal derived from the AST non-terminal for unary operators)
over a literal $\vl$ and returns the resulting literal $\vr$.
The result is a type error, if one is detected.

\hypertarget{def-unopsignatures}{}
The following set of unary operator types and argument types defines the correct argument type
for a given unary operator:
\[
\unopsignatures \triangleq
\left\{
\begin{array}{lcll}
  (\NEG   &,& \lint)        &,\\
  (\NEG   &,& \lreal)       &,\\
  (\BNOT  &,& \lbool)       &,\\
  (\NOT   &,& \lbitvector)  &\\
\end{array}
\right\}
\]

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $(\op, \astlabel(\vl))$ is not in $\unopsignatures$;
    \item the result is a type error indicating that the combination of $\op$ and $\astlabel(\vl)$
          is not legal.
  \end{itemize}

  \item All of the following apply (\textsc{negate\_int}):
  \begin{itemize}
    \item $\op$ is $\NEG$ and $\vl$ is an integer literal for $\vn$;
    \item define $\vr$ as the integer literal for $- \vn$.
  \end{itemize}

  \item All of the following apply (\textsc{negate\_real}):
  \begin{itemize}
    \item $\op$ is $\NEG$ and $\vl$ is a real literal for $\vq$;
    \item define $\vr$ as the real literal for $- \vq$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_bool}):
  \begin{itemize}
    \item $\op$ is $\BNOT$ and $\vl$ is a Boolean literal for $\vb$;
    \item define $\vr$ as the Boolean literal for $\neg\vq$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_bits\_empty}, \textsc{not\_bits\_empty}):
  \begin{itemize}
    \item $\op$ is $\NOT$ and $\vl$ is a bitvector literal for the sequence of bits $\bits$;
    \item $\vc$ is the sequence of bits of the same length as $\bits$ where in each position
          the bit in define $\vr$ as the negation of the corresponding bit in $\bits$;
    \item define $\vr$ as the bitvector literal for $\vc$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[error]{
  (\op, \vl) \not\in \unopsignatures
}{
  \unopliterals(\op, \astlabel(\vl)) \typearrow \TypeErrorVal{TypeMismatch}
}
\and
\inferrule[negate\_int]{}{
  \unopliterals(\overname{\NEG}{\op}, \overname{\lint(n)}{\vl}) \typearrow \overname{\lint(- n)}{\vr}
}
\and
\inferrule[negate\_real]{}{
  \unopliterals(\overname{\NEG}{\op}, \overname{\lreal(q)}{\vl}) \typearrow \overname{\lreal(- q)}{\vr}
}
\and
\inferrule[not\_bool]{}{
  \unopliterals(\overname{\BNOT}{\op}, \overname{\lbool(b)}{\vl}) \typearrow \overname{\lbool(\neg b)}{\vr}
}
\and
\inferrule[not\_bits\_empty]{
  \bits \eqname \emptylist\\
  c \eqdef \emptylist
}{
  \unopliterals(\overname{\NOT}{\op}, \overname{\lbitvector(\bits)}{\vl}) \typearrow\overname{\lbitvector(c)}{\vr}
}
\and
\inferrule[not\_bits\_not\_empty]{
  \bits \eqname \vb_{1..k}\\
  c \eqdef [i=1..k: (1-\vb_\vi)]
}{
  \unopliterals(\overname{\NOT}{\op}, \overname{\lbitvector(\bits)}{\vl}) \typearrow\overname{\lbitvector(c)}{\vr}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.BinopLiterals \label{sec:TypingRule.BinopLiterals}}
\hypertarget{def-binopliterals}{}
The function
\[
  \binopliterals(\overname{\binop}{\op} \aslsep \overname{\literals}{\vvone} \aslsep \overname{\literals}{\vvtwo}) \aslto
  \overname{\literals}{\vr} \cup \TTypeError
\]
statically evaluates a binary operator $\op$ (a terminal derived from the AST non-terminal for binary operators)
over a pair of literals $\vlone$ and $\vltwo$
and returns the resulting literal $\vr$.
The result is a type error, if it is considered illegal to apply the operator
to the given values, or a different kind of type error is detected.

\hypertarget{def-binopsignatures}{}
The following set of binary operator types and argument types defines the correct
argument types for a given binary operator:
\[
\binopsignatures \triangleq
\left\{
\begin{array}{lclcll}
  (\PLUS      &,& \lint &,& \lint)&,\\
  (\MINUS     &,& \lint &,& \lint)&,\\
  (\MUL       &,& \lint &,& \lint)&,\\
  (\DIV       &,& \lint &,& \lint)&,\\
  (\DIVRM     &,& \lint &,& \lint)&,\\
  (\MOD       &,& \lint &,& \lint)&,\\
  (\POW       &,& \lint &,& \lint)&,\\
  (\SHL       &,& \lint &,& \lint)&,\\
  (\SHR       &,& \lint &,& \lint)&,\\
  (\EQOP      &,& \lint &,& \lint)&,\\
  (\NEQ       &,& \lint &,& \lint)&,\\
  (\LEQ       &,& \lint &,& \lint)&,\\
  (\LT        &,& \lint &,& \lint)&,\\
  (\GEQ       &,& \lint &,& \lint)&,\\
  (\GT        &,& \lint &,& \lint)&,\\
  (\BAND      &,& \lbool &,& \lbool)&,\\
  (\BOR       &,& \lbool &,& \lbool)&,\\
  (\IMPL      &,& \lbool &,& \lbool)&,\\
  (\EQOP      &,& \lbool &,& \lbool)&,\\
  (\NEQ       &,& \lbool &,& \lbool)&,\\
  (\PLUS      &,& \lreal &,& \lreal)&,\\
  (\MINUS     &,& \lreal &,& \lreal)&,\\
  (\MUL       &,& \lreal &,& \lreal)&,\\
  (\RDIV      &,& \lreal &,& \lreal)&,\\
  (\POW       &,& \lreal &,& \lreal)&,\\
  (\EQOP      &,& \lreal &,& \lreal)&,\\
  (\NEQ       &,& \lreal &,& \lreal)&,\\
  (\LEQ       &,& \lreal &,& \lreal)&,\\
  (\LT        &,& \lreal &,& \lreal)&,\\
  (\GEQ       &,& \lreal &,& \lreal)&,\\
  (\GT        &,& \lreal &,& \lreal)&,\\
  (\EQOP      &,& \lbitvector &,& \lbitvector)&,\\
  (\NEQ       &,& \lbitvector &,& \lbitvector)&,\\
  (\OR        &,& \lbitvector &,& \lbitvector)&,\\
  (\AND       &,& \lbitvector &,& \lbitvector)&,\\
  (\EOR       &,& \lbitvector &,& \lbitvector)&,\\
  (\MINUS     &,& \lbitvector &,& \lbitvector)&,\\
  (\PLUS      &,& \lbitvector &,& \lbitvector)&,\\
  (\MINUS     &,& \lbitvector &,& \lint)&,\\
  (\PLUS      &,& \lbitvector &,& \lint)&\\
\end{array}
\right\}
\]

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $(\op, \astlabel(\vlone), \astlabel(\vltwo))$ is not included in $\binopsignatures$;
    \item the result is a type error indicating the $\op$ cannot be applied to the arguments
          with the types given by $\astlabel(\vlone)$ and $\astlabel(\vltwo)$.
  \end{itemize}

  \item All of the following apply (\textsc{add\_int}):
  \begin{itemize}
    \item $\op$ is $\PLUS$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal integer for $a+b$.
  \end{itemize}

  \item All of the following apply (\textsc{sub\_int}):
  \begin{itemize}
    \item $\op$ is $\MINUS$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal integer for $a-b$.
  \end{itemize}

  \item All of the following apply (\textsc{mul\_int}):
  \begin{itemize}
    \item $\op$ is $\MUL$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the literal integer for $a\times b$.
  \end{itemize}

  \item All of the following apply (\textsc{div\_int}):
  \begin{itemize}
    \item $\op$ is $\DIV$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is positive yields $\True$\ProseOrTypeError;
    \item define $n$ as $a$ divided by $b$ (note that $n$ is potentially a fraction);
    \item checking that $n$ is an integer yields $\True$\ProseOrTypeError;
    \item define $\vr$ as the literal integer for $a\div b$.
  \end{itemize}

  \item All of the following apply (\textsc{fdiv\_int}):
  \begin{itemize}
    \item $\op$ is $\DIVRM$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is positive yields $\True$\ProseOrTypeError;
    \item define $n$ as $a$ divided by $b$, rounded down (if $a$ is negative, $n$ is rounded down towards infinity);
    \item define $\vr$ as the literal integer for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{frem\_int}):
  \begin{itemize}
    \item $\op$ is $\MOD$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item applying $\binopliterals$ to $\DIVRM$ with $\vlone$ and $\vltwo$ yields $c$\ProseOrTypeError;
    \item define $n$ as $a-c$;
    \item define $\vr$ as the literal integer for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_int}):
  \begin{itemize}
    \item $\op$ is $\POW$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item define $n$ as $a^b$;
    \item define $\vr$ as the literal integer for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{shl}):
  \begin{itemize}
    \item $\op$ is $\SHL$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item applying $\binopliterals$ to $\POW$ with $2$ and $\vltwo$ yields the literal integer for $e$;
    \item applying $\binopliterals$ to $\MUL$ with $2$ and the literal integer for $e$ yields $\vr$.
  \end{itemize}

  \item All of the following apply (\textsc{shr}):
  \begin{itemize}
    \item $\op$ is $\SHL$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item checking that $b$ is non-negative yields $\True$\ProseOrTypeError;
    \item applying $\binopliterals$ to $\POW$ with $2$ and $\vltwo$ yields the literal integer for $e$;
    \item applying $\binopliterals$ to $\DIVRM$ with $2$ and the literal integer for $e$ yields $\vr$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_int}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{ne\_int}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is different from $b$ holds.
  \end{itemize}

  \item All of the following apply (\textsc{le\_int}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than or equal to $b$s.
  \end{itemize}

  \item All of the following apply (\textsc{lt\_int}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than $b$s.
  \end{itemize}

  \item All of the following apply (\textsc{ge\_int}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater or equal than $b$s.
  \end{itemize}

  \item All of the following apply (\textsc{gt\_int}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal integer for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater than $b$s.
  \end{itemize}

  \item All of the following apply (\textsc{and\_bool}):
  \begin{itemize}
    \item $\op$ is $\BAND$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if both $a$ and $b$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{or\_bool}):
  \begin{itemize}
    \item $\op$ is $\BOR$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if one of $a$ and $b$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{implies\_bool}):
  \begin{itemize}
    \item $\op$ is $\IMPL$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if one of $a$ is $\False$ or $b$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_bool}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if one of $a$ is equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{ne\_bool}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal Boolean for $a$, and $\vltwo$ is the literal Boolean for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if one of $a$ is different from $b$.
  \end{itemize}

  \item All of the following apply (\textsc{add\_real}):
  \begin{itemize}
    \item $\op$ is $\PLUS$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the real literal for $a + b$.
  \end{itemize}

  \item All of the following apply (\textsc{sub\_real}):
  \begin{itemize}
    \item $\op$ is $\MINUS$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the real literal for $a - b$.
  \end{itemize}

  \item All of the following apply (\textsc{mul\_real}):
  \begin{itemize}
    \item $\op$ is $\MUL$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the real literal for $a \times b$.
  \end{itemize}

  \item All of the following apply (\textsc{div\_real}):
  \begin{itemize}
    \item $\op$ is $\RDIV$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item checking whether $b$ is different from $0$ yields $\True$\ProseOrTypeError;
    \item define $\vr$ as the real literal for $a \div b$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_real}):
  \begin{itemize}
    \item $\op$ is $\POW$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal integer for $b$;
    \item define $\vr$ as the real literal for $a^b$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_real}):
  \begin{itemize}
    \item $\op$ is $\EQOP$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{ne\_real}):
  \begin{itemize}
    \item $\op$ is $\NEQ$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is different from $b$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_real}):
  \begin{itemize}
    \item $\op$ is $\LEQ$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than or equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{lt\_real}):
  \begin{itemize}
    \item $\op$ is $\LT$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is less than $b$.
  \end{itemize}

  \item All of the following apply (\textsc{ge\_real}):
  \begin{itemize}
    \item $\op$ is $\GEQ$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater than or equal to $b$.
  \end{itemize}

  \item All of the following apply (\textsc{gt\_real}):
  \begin{itemize}
    \item $\op$ is $\GT$, $\vlone$ is the literal real for $a$, and $\vltwo$ is the literal real for $b$;
    \item define $\vr$ as the Boolean literal that is $\True$ if and only if $a$ is greater than $b$.
  \end{itemize}

  \item All of the following apply (\textsc{bitwise\_different\_bitwidths}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is a bitvector literal for $b$;
    \item the lengths of $a$ and $b$ are different;
    \item the result is a type error indicating that the bitvectors must be of the same width.
  \end{itemize}

  \item All of the following apply (\textsc{bitwise\_empty}):
  \begin{itemize}
    \item $\vvone$ is the empty bitvector literal;
    \item $\vvtwo$ is the empty bitvector literal;
    \item $\op$ is one of $\OR$, $\AND$, $\EOR$, $\PLUS$, or $\MINUS$;
    \item define $\vr$ as the empty bitvector literal.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_bits\_empty}):
  \begin{itemize}
    \item $\vvone$ is the empty bitvector literal;
    \item $\vvtwo$ is the empty bitvector literal;
    \item $\op$ is $\EQOP$;
    \item define $\vr$ as the Boolean literal for $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{eq\_bits\_not\_empty}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\EQOP$;
    \item define $\vb$ as $\True$ if and only if $a_i$ is equal to $b_i$, for $i=1..k$;
    \item define $\vr$ as the Boolean literal for $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{ne\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is a bitvector literal for $b$;
    \item $\op$ is $\NEQ$;
    \item applying $\binopliterals$ to $\EQOP$ for $\vvone$ and $\vvtwo$ yields the Boolean literal for $\vb$\ProseOrTypeError;
    \item define $\vr$ as the Boolean literal for $\neg\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{or\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\OR$;
    \item define $c_i$ as the maximum of $a_i$ and $b_i$ for $i=1..k$;
    \item define $\vr$ as the bitvector literal for $c_{1..k}$.
  \end{itemize}

  \item All of the following apply (\textsc{and\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\OR$;
    \item define $c_i$ as the minimum of $a_i$ and $b_i$ for $i=1..k$;
    \item define $\vr$ as the bitvector literal for $c_{1..k}$.
  \end{itemize}

  \item All of the following apply (\textsc{xor\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\OR$;
    \item define $c_i$ as $1$ if $a_i$ is different from $b_i$ and $0$ otherwise, for $i=1..k$;
    \item define $\vr$ as the bitvector literal for $c_{1..k}$.
  \end{itemize}

  \item All of the following apply (\textsc{add\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\PLUS$;
    \item define $a$ as the natural number represented by $a_{1..k}$;
    \item define $b$ as the natural number represented by $b_{1..k}$;
    \item define $c$ as the two's complement little endian representation of $a+b$ in $k$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item All of the following apply (\textsc{sub\_bits}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a_{1..k}$;
    \item $\vvtwo$ is a bitvector literal for $b_{1..k}$;
    \item $\op$ is $\PLUS$;
    \item define $a$ as the natural number represented by $a_{1..k}$;
    \item define $b$ as the natural number represented by $b_{1..k}$;
    \item define $c$ as the two's complement little endian representation of $a-b$ in $k$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item All of the following apply (\textsc{add\_bits\_int}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is an integer literal for $b$;
    \item $\op$ is $\PLUS$;
    \item define $y$ as the natural number represented by $a$;
    \item define $c$ as the two's complement little endian representation of $y+b$ in $\listlen{a}$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}

  \item All of the following apply (\textsc{sub\_bits\_int}):
  \begin{itemize}
    \item $\vvone$ is a bitvector literal for $a$;
    \item $\vvtwo$ is an integer literal for $b$;
    \item $\op$ is $\PLUS$;
    \item define $y$ as the natural number represented by $a$;
    \item define $c$ as the two's complement little endian representation of $y-b$ in $\listlen{a}$ bits;
    \item define $\vr$ as the bitvector literal for $c$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}

\begin{mathpar}
\inferrule[error]{
  (\op, \astlabel(\vlone), \astlabel(\vltwo)) \not\in \binopsignatures
}{
  \binopliterals(\op, \overname{\vlone}{\vvone}, \overname{\vltwo}{\vvtwo}) \typearrow \TypeErrorVal{TypeMismatch}
}
\end{mathpar}

\subsubsection{Arithmetic Operators Over Integer Values \label{sec:AthimeticOverInt}}
\begin{mathpar}
\inferrule[add\_int]{}{
  \binopliterals(\overname{\PLUS}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a + b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_int]{}{
  \binopliterals(\overname{\MINUS}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a - b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul\_int]{}{
  \binopliterals(\overname{\MUL}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a \times b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_int]{
  \checktrans{b > 0}{DIV\_DenominatorNegative} \checktransarrow \True \OrTypeError\\\\
  n \eqdef a \div b \\\\
  \checktrans{n \in \Z}{DIVInt\_Indivisibile} \checktransarrow \True \OrTypeError
}{
  \binopliterals(\overname{\DIV}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(n)}{\vr}
}
\and
\inferrule[fdiv\_int]{
  \checktrans{b > 0}{FDIV\_DenominatorNegative} \checktransarrow \True \OrTypeError\\\\
  n \eqdef \choice{a \geq 0}{\lfloor a \div b \rfloor}{-(\lceil (-a) \div b \rceil)}
}{
  \binopliterals(\overname{\DIVRM}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(n)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[frem\_int]{
  \binopliterals(\DIVRM, \lint(a), \lint(b)) \typearrow \lint(c) \OrTypeError
}{
  \binopliterals(\overname{\MOD}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a - (c \times b))}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_int]{
  \checktrans{b \geq 0}{ExponentNegative} \checktransarrow \True \OrTypeError
}{
  \binopliterals(\overname{\POW}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lint(a^b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[shl]{
  \checktrans{b \geq 0}{ShifterNegative} \checktransarrow \True \OrTypeError\\\\
  \binopliterals(\POW, \lint(2), \lint(b)) \typearrow \lint(e)\\
  \binopliterals(\MUL, \lint(a), \lint(e)) \typearrow \vr
}{
  \binopliterals(\overname{\SHL}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \vr
}
\end{mathpar}

\begin{mathpar}
\inferrule[shr]{
  \checktrans{b \geq 0}{ShifterNegative} \checktransarrow \True \OrTypeError\\\\
  \binopliterals(\POW, \lint(2), \lint(b)) \typearrow \lint(e)\\
  \binopliterals(\DIVRM, \lint(a), \lint(e)) \typearrow \vr
}{
  \binopliterals(\overname{\SHR}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \vr
}
\end{mathpar}

\subsubsection{Relational Operators Over Integer Values \label{sec:RelationalOverInt}}
\begin{mathpar}
\inferrule[eq\_int]{}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_int]{}{
  \binopliterals(\overname{\NEQ}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a \neq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_int]{}{
  \binopliterals(\overname{\LEQ}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a \leq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[lt\_int]{}{
  \binopliterals(\overname{\LT}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a < b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ge\_int]{}{
  \binopliterals(\overname{\GEQ}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a \geq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[gt\_int]{}{
  \binopliterals(\overname{\GT}{\op}, \overname{\lint(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbool(a > b)}{\vr}
}
\end{mathpar}

\subsubsection{Boolean Operators Over Boolean Values \label{sec:BooleanOverBoolean}}
\begin{mathpar}
\inferrule[and\_bool]{}{
  \binopliterals(\overname{\BAND}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(a \wedge b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[or\_bool]{}{
  \binopliterals(\overname{\BOR}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(a \vee b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[implies\_bool]{}{
  \binopliterals(\overname{\IMPL}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(\neg a \vee b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_bool]{}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_bool]{}{
  \binopliterals(\overname{\NEQ}{\op}, \overname{\lbool(a)}{\vvone}, \overname{\lbool(b)}{\vvtwo}) \typearrow \overname{\lbool(a \neq b)}{\vr}
}
\end{mathpar}

\subsubsection{Arithmetic Operators Over Real Values \label{sec:AthimeticOverReal}}
\begin{mathpar}
\inferrule[add\_real]{}{
  \binopliterals(\overname{\PLUS}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lreal(a+b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_real]{}{
  \binopliterals(\overname{\MINUS}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lreal(a-b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul\_real]{}{
  \binopliterals(\overname{\MUL}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lreal(a\times b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_real]{
  \checktrans{b \neq 0}{RDIV\_DenominatorZero} \checktransarrow \True \OrTypeError
}{
  \binopliterals(\overname{\RDIV}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lreal(a\div b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_real]{}{
  \binopliterals(\overname{\POW}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lreal(a^b)}{\vr}
}
\end{mathpar}

\subsubsection{Relational Operators Over Real Values \label{sec:RealtionalOverReal}}
\begin{mathpar}
\inferrule[eq\_real]{}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a = b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_real]{}{
  \binopliterals(\overname{\NEQ}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a \neq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_real]{}{
  \binopliterals(\overname{\LEQ}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a \leq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[lt\_real]{}{
  \binopliterals(\overname{\LT}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a < b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ge\_real]{}{
  \binopliterals(\overname{\GEQ}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a \geq b)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[gt\_real]{}{
  \binopliterals(\overname{\GT}{\op}, \overname{\lreal(a)}{\vvone}, \overname{\lreal(b)}{\vvtwo}) \typearrow \overname{\lbool(a > b)}{\vr}
}
\end{mathpar}

\subsection{Operators Over Bitvectors \label{sec:BitvectorOperations}}
\hypertarget{def-bintounsigned}{}
The function $\bintounsigned : \{0,1\}^* \rightarrow \N$ converts a non-empty sequence of bits
into a natural number:
\[
  \bintounsigned(a_{n..1}) \triangleq \sum_{i=1}^n a_i \cdot 2^{a_i}
\]
and an empty sequence of bits into $0$:
\[
  \bintounsigned(\emptylist) \triangleq 0 \enspace.
\]

\hypertarget{def-inttobits}{}
The function $\inttobits : \overname{\Z}{\texttt{val}} \times \overname{\Z}{\texttt{width}} \rightarrow \{0,1\}^*$
converts an integer \texttt{val} to its two's complement little endian representation
of \texttt{width} bits.

\begin{mathpar}
\inferrule[bitwise\_different\_bitwidths]{
  \listlen{a} \neq \listlen{b}
}{
  \binopliterals(\op, \overname{\lbitvector(a)}{\vvone}, \overname{\lbitvector(b)}{\vvtwo}) \typearrow
  \TypeErrorVal{DifferentBitwidths}
}
\and
\inferrule[bitwise\_empty]{
  \op \in \{\OR, \AND, \EOR, \PLUS, \MINUS\}
}{
  \binopliterals(\op, \overname{\lbitvector(\emptylist)}{\vvone}, \overname{\lbitvector(\emptylist)}{\vvtwo}) \typearrow
  \overname{\lbitvector(\emptylist)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq\_bits\_empty]{}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lbitvector(\emptylist)}{\vvone}, \overname{\lbitvector(\emptylist)}{\vvtwo}) \typearrow
  \overname{\lbool(\True)}{\vr}
}
\and
\inferrule[eq\_bits\_not\_empty]{
  \vb \eqdef \bigwedge_{i=1}^k a_i = b_i
}{
  \binopliterals(\overname{\EQOP}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow
  \overname{\lbool(\vb)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ne\_bits]{
  \binopliterals(\EQOP, \lbitvector(a), \lbitvector(b)) \typearrow \lbool(\vb) \OrTypeError
}{
  \binopliterals(\overname{\NEQ}{\op}, \overname{\lbitvector(a)}{\vvone}, \overname{\lbitvector(b)}{\vvtwo}) \typearrow \lbool(\neg\vb)
}
\end{mathpar}

\begin{mathpar}
\inferrule[or\_bits]{
  i=1..k: c_i = \max(a_i, b_i)
}{
  \binopliterals(\overname{\OR}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \lbitvector(c_{1..k})
}
\end{mathpar}

\begin{mathpar}
\inferrule[and\_bits]{
  i=1..k: c_i = \min(a_i, b_i)
}{
  \binopliterals(\overname{\AND}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \lbitvector(c_{1..k})
}
\end{mathpar}

\begin{mathpar}
\inferrule[xor\_bits]{
  {
    \textit{xor\_bit} = \lambda a,b\in\{0,1\}.\ \left\{
      \begin{array}{ll}
        0 & \text{ if } a = b\\
        1 & \text{ otherwise}
      \end{array}
    \right.
  }\\
  i=1..k: c_i=\textit{xor\_bit}(a_i, b_i)
}{
  \binopliterals(\overname{\EOR}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \lbitvector(c_{1..k})
}
\end{mathpar}

\begin{mathpar}
\inferrule[add\_bits]{
  a \eqdef \bintounsigned(a_{1..k})\\
  b \eqdef \bintounsigned(b_{1..k})\\
  c \eqdef \inttobits(a + b, k)
}{
  \binopliterals(\overname{\PLUS}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \overname{\lbitvector(c)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_bits]{
  a \eqdef \bintounsigned(a_{1..k})\\
  b \eqdef \bintounsigned(b_{1..k})\\
  c \eqdef \inttobits(a - b, k)
}{
  \binopliterals(\overname{\MINUS}{\op}, \overname{\lbitvector(a_{1..k})}{\vvone}, \overname{\lbitvector(b_{1..k})}{\vvtwo}) \typearrow \overname{\lbitvector(c)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[add\_bits\_int]{
  y \eqdef \bintounsigned(a)\\
  c \eqdef \inttobits(y + b, \listlen{a})
}{
  \binopliterals(\overname{\PLUS}{\op}, \overname{\lbitvector(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbitvector(c)}{\vr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sub\_bits\_int]{
  y \eqdef \bintounsigned(a)\\
  c \eqdef \inttobits(y - b, \listlen{a})
}{
  \binopliterals(\overname{\MINUS}{\op}, \overname{\lbitvector(a)}{\vvone}, \overname{\lint(b)}{\vvtwo}) \typearrow \overname{\lbitvector(c)}{\vr}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SlicesToPositions \label{sec:TypingRule.SlicesToPositions}}
\hypertarget{def-slicestopositions}{}
The function
\[
  \slicestopositions(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slices}) \aslto
  \overname{\Z^*}{\positions} \cup \{\CannotBeTransformed\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
transforms the list of slices $\slices$ in $\tenv$ to a list of indices $\positions$.
The result is $\CannotBeTransformed$ if $\slices$ cannot be statically evaluated to
a list of positions.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\slices$ is the empty list;
    \item $\positions$ is the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item \view\ $\slices$ as the list with $\vs$ as its head and $\slicesone$ as its tail;
    \item applying $\slicetopositions$ to $\vs$ in $\tenv$ yields the list of positions \\
          $\positionsone$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item transforming $\slicesone$ to a list of positions in $\tenv$ via $\slicestopositions$ yields
          $\positionstwo$\ProseTerminateAs{\CannotBeTransformed, \TypeErrorConfig};
    \item $\positions$ is the concatenation of $\positionsone$ and $\positionstwo$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \slicestopositions(\tenv, \overname{\emptylist}{\slices}) \typearrow \overname{\emptylist}{\positions}
}
\and
\inferrule[non\_empty]{
  \slicetopositions(\tenv, \vs) \typearrow \positionsone \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \slicestopositions(\tenv, \slicesone) \typearrow \positionstwo \terminateas \CannotBeTransformed,\TypeErrorConfig
}{
  \slicestopositions(\tenv, \overname{[\vs] + \slicesone}{\slices}) \typearrow \overname{\positionsone \concat \positionstwo}{\positions}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SliceToPositions \label{sec:TypingRule.SliceToPositions}}
\hypertarget{def-slicetopositions}{}
The function
\[
  \slicetopositions(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\vs}) \aslto
  \overname{\Z^+}{\positions} \cup \{\CannotBeTransformed\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
transforms a slice $\vs$ in $\tenv$ to a list of indices $\positions$.
The result is $\CannotBeTransformed$ if $\slices$ cannot be statically evaluated to
a list of positions.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\vs$ is a slice for a single position given by the expression $\ve$, that is, \\ $\SliceSingle(\ve)$;
    \item applying $\evaltoint$ to $\ve$ in $\tenv$ yields the integer $n$\ProseOrTypeError;
    \item checking that $n$ is non-negative yields $\True$\ProseOrTypeError;
    \item $\positions$ is the list containing the single element $n$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vs$ is a slice for a range given by the expression $\etop$
          for the top position and $\ebot$ for the bottom position, that is, \\ $\SliceRange(\etop, \ebot)$;
    \item applying $\evaltoint$ to $\ebot$ in $\tenv$ yields the integer $b$\ProseOrTypeError;
    \item applying $\evaltoint$ to $\etop$ in $\tenv$ yields the integer $t$\ProseOrTypeError;
    \item checking that $t$ is greater or equal to $b$ and that $b$ is greater or equal to $0$ yields $\True$\ProseOrTypeError;
    \item $\positions$ is the list of integers from $t$ down to $b$, inclusive.
  \end{itemize}

  \item All of the following apply (\textsc{length}):
  \begin{itemize}
    \item $\vs$ is a slice for a length slice given by the expression $\ebot$
          for the bottom position and $\elength$ for the length of the slice, that is, \\ $\SliceLength(\ebot, \elength)$;
    \item applying $\evaltoint$ to $\ebot$ in $\tenv$ to an integer yields the integer $b$\ProseOrTypeError;
    \item applying $\evaltoint$ to $\elength$ in $\tenv$ to an integer yields the integer $l$\ProseOrTypeError;
    \item $t$ is $b + l - 1$;
    \item checking that $t$ is greater or equal to $b$ and that $b$ is greater or equal to $0$ yields $\True$\ProseOrTypeError;
    \item $\positions$ is the list of integers from $t$ down to $b$, inclusive.
  \end{itemize}

  \item All of the following apply (\textsc{star}):
  \begin{itemize}
    \item $\vs$ is a slice for a scaled slice given by the expression $\efactor$
          for the factor and $\elength$ for the length of the slice (\texttt{$\elength$*:$\efactor$}),
          that is, \\ $\SliceStar(\efactor, \elength)$;
    \item applying $\evaltoint$ to $\efactor$ in $\tenv$ to an integer yields the integer $f$\ProseOrTypeError;
    \item applying $\evaltoint$ to $\elength$ in $\tenv$ to an integer yields the integer $l$\ProseOrTypeError;
    \item $t$ is $(f \times l) + l - 1$;
    \item $b$ is $t - l + 1$;
    \item checking that $t$ is greater or equal to $b$ and that $b$ is greater or equal to $0$ yields $\True$\ProseOrTypeError;
    \item $\positions$ is the list of integers from $t$ down to $b$, inclusive.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}

\begin{mathpar}
\inferrule[single]{
  \evaltoint(\tenv, \ve) \typearrow n \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \checktrans{n \geq 0}{BadSlice} \checktransarrow \True \OrTypeError
}{
  \slicetopositions(\tenv, \overname{\SliceSingle(\ve)}{\vs}) \typearrow [ n ]
}
\and
\inferrule[range]{
  \evaltoint(\tenv, \ebot) \typearrow b \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \evaltoint(\tenv, \etop) \typearrow t \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \checktrans{t \geq b \geq 0}{BadSlice} \checktransarrow \True \OrTypeError
}{
  \slicetopositions(\tenv, \overname{\SliceRange(\etop, \ebot)}{\vs}) \typearrow [ t..b ]
}
\and
\inferrule[length]{
  \evaltoint(\tenv, \ebot) \typearrow b \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \evaltoint(\tenv, \elength) \typearrow l \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  t \eqdef b + l - 1
  \checktrans{t \geq b \geq 0}{BadSlice} \checktransarrow \True \OrTypeError
}{
  \slicetopositions(\tenv, \overname{\SliceLength(\ebot, \elength)}{\vs}) \typearrow [ t..b ]
}
\and
\inferrule[star]{
  \evaltoint(\tenv, \efactor) \typearrow f \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  \evaltoint(\tenv, \elength) \typearrow l \terminateas \CannotBeTransformed,\TypeErrorConfig\\\\
  t \eqdef (f \times l) + l - 1\\
  b \eqdef t - l\\
  \checktrans{t \geq b \geq 0}{BadSlice} \checktransarrow \True \OrTypeError
}{
  \slicetopositions(\tenv, \overname{\SliceStar(\efactor, \elength)}{\vs}) \typearrow [ t..b ]
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.EvalToInt \label{sec:TypingRule.EvalToInt}}
\hypertarget{def-evaltoint}{}
The function
\[
\evaltoint(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve})
\aslto \overname{\Z}{n} \cup \{\CannotBeTransformed\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
statically evaluates the expression $\ve$ to the integer $n$.
The result is $\CannotBeTransformed$ if $\ve$ cannot be statically evaluated
to an integer.
The result is a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\staticeval$ to $\ve$ in $\tenv$ has one of three outcomes:
  \begin{itemize}
  \item a literal $\vl$, which satisfies the premise;
  \item $\CannotBeTransformed$ (which means the expression could not be evaluated to a literal),
  which short-circuits the entire rule;
  or
  \item $\TypeErrorConfig$ (indicating a type error was detected), which short-circuits the entire rule;
  \end{itemize}
  \item checking that $\vl$ is an integer literal yields $\True$\ProseOrTypeError;
  \item define $\vl$ as the literal integer for $n$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \staticeval(\tenv, \ve) \typearrow \vl \terminateas \CannotBeTransformed, \TypeErrorConfig\\\\
  \checktrans{\astlabel(\vl) = \lint}{ExpectedIntegerType} \checktransarrow \True \OrTypeError\\\\
  \vl \eqname \lint(n)
}{
  \evaltoint(\tenv, \ve) \typearrow n
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ExtractSlice \label{sec:TypingRule.ExtractSlice}}
\hypertarget{def-extractslice}{}
The function
\[
  \extractslice(\overname{\{0,1\}^*}{\bits} \aslsep \overname{\Z^*}{\positions}) \aslto
  \overname{\{0,1\}^*}{\vr} \cup\ \TTypeError
\]
extracts from the list of bits $\bits$ the sub-list $\vr$ of bits appearing at the positions given by $\positions$.
The result is a type error, if one is detected.

\subsection{Prose}
Define $\vr$ the sub-list of $\bits$ given by taking $\bits[\vi]$, for every value given in $\positions$ (in the order they appear).

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}{
  \extractslice(\tenv, \bits, \positions) \typearrow \overname{[ \vi\in\positions: \bits[\vi] ]}{\vr}
}
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Symbolic Subsumption Testing \label{chap:symbolicsubsumptiontesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-symbolicdomain}{}
The symbolic reasoning operates by first transforming types into expressions in a \emph{symbolic domain} AST
(defined next, reusing $\intconstraint$ from the parsed AST) over which it then operates:
\hypertarget{def-symdom}{}
\hypertarget{def-dbool}{}
\[
  \begin{array}{rcl}
    \symdom &::=& \DBool                    \hypertarget{def-dstring}{}\\
            &|  & \DString                  \hypertarget{def-dreal}{}\\
            &|  & \DReal                    \hypertarget{def-dsymbols}{}\\
            &|  & \DSymbols(\identifier^+)  \hypertarget{def-dint}{}\\
            &|  & \DInt(\intset)            \hypertarget{def-dbits}{}\\
            &|  & \DBits(\intset)           \hypertarget{def-intset}{} \hypertarget{def-finite}{}\\
    \intset &::=& \Finite(\Z^+)             \hypertarget{def-top}{}\\
            &|  & \Top                      \hypertarget{def-fromsymtax}{}\\
            &|  & \FromSyntax(\syntax)      \hypertarget{def-syntax}{}\\
    \syntax &::=& \intconstraint^*
  \end{array}
\]

\section{TypingRule.SymSubsumes}
\hypertarget{def-symsubsumes}{}
The predicate
\[
  \symsubsumes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb}
\]
soundly approximates $\subsumes(\tenv, \vt, \vs)$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \symdomoftype(\tenv, \vt) \typearrow \dt\\
    \symdomoftype(\tenv, \vs) \typearrow \ds\\
    \symdomissubset(\tenv, \dt, \ds) \typearrow \vb
  }
  {
    \symsubsumes(\tenv, \vt, \vs) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SymDomOfType}
\hypertarget{def-symdomoftype}{}
The partial function
\[
  \symdomoftype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto \overname{\symdom}{\vd}
\]
transforms a type $\vt$ in a static environment $\tenv$ into a symbolic domain $\vd$.

% | T_Bits (width, _) -> (
%     try
%       match of_expr env width with
%       | D_Int (Finite int_set as d) ->
%           if Z.equal (IntSet.cardinal int_set) Z.one then D_Bits d
%           else raise StaticEvaluationTop
%       | D_Int (FromSyntax [ Constraint_Exact _ ] as d) -> D_Bits d
%       | _ -> raise StaticEvaluationTop
%     with StaticEvaluationTop ->
%       D_Bits (FromSyntax [ Constraint_Exact width ]))
% | T_Array _ | T_Exception _ | T_Record _ | T_Tuple _ ->
%     failwith "Unimplemented: domain of a non singular type."
% | T_Named _ -> assert false (* make anonymous *)

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TBool) \typearrow \DBool }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TString) \typearrow \DString }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TReal) \typearrow \DReal }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TEnum(\vli)) \typearrow \DSymbols(\vli) }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TInt(\unconstrained)) \typearrow \DInt(\Top) }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TInt(\underconstrained(\id))) \typearrow \\
  \DInt(\FromSyntax([\ConstraintExact(\EVar(\id))])) }
  \and
  \inferrule{
    \intsetofintconstraints(\tenv, \vcs) \typearrow \vis
  }{ \symdomoftype(\tenv, \vt, \TInt(\wellconstrained(\vcs))) \typearrow \DInt(\vis)}
\end{mathpar}

\begin{mathpar}
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\Finite([n]))
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \DBits(\Finite([n]))
  }
  \and
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\Finite([n_{1..k}]))\\
    k > 1
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \\ \DBits(\FromSyntax([\ConstraintExact(\EVar(\width))]))
  }
  \and
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\FromSyntax([\ConstraintExact(\vv)]))
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \\ \DBits(\FromSyntax([\ConstraintExact(\vv)]))
  }
  \and
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\FromSyntax(\vc))\\
    \vc \neq [\ConstraintExact(\vv)]
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \\ \DBits(\FromSyntax([\ConstraintExact(\EVar(\width))]))
  }
  \and
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\Top)
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \\ \DBits(\FromSyntax([\ConstraintExact(\EVar(\width))]))
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SymDomOfExpr}
\hypertarget{def-symdomofexpr}{}

\section{TypingRule.SymDomOfLiteral}
\hypertarget{def-symdomofliteral}{}

\section{TypingRule.SymIntSetOfConstraints}
\hypertarget{def-intsetofintconstraintse}{}

\section{TypingRule.SymDomIsSubset}
\hypertarget{def-symdomissubset}{}

% | D_Bool, D_Bool | D_String, D_String | D_Real, D_Real -> true
% | D_Symbols s1, D_Symbols s2 -> ISet.subset s1 s2
% | D_Bits is1, D_Bits is2 | D_Int is1, D_Int is2 ->
%     int_set_is_subset env is1 is2

\begin{mathpar}
  \inferrule[bool]{}{ \symdomissubset(\tenv, \DBool, \DBool) \typearrow \True }
  \and
  \inferrule[string]{}{ \symdomissubset(\tenv, \DString, \DString) \typearrow \True }
  \and
  \inferrule[real]{}{ \symdomissubset(\tenv, \DReal, \DReal) \typearrow \True }
  \and
  \inferrule[symbols]{
    \vb \eqdef \{\vsone\} = \{\vstwo\}
  }{ \symdomissubset(\tenv, \DSymbols(\vsone), \DSymbols(\vstwo)) \typearrow \vb }
  \and
  \inferrule[bits]{
    \symintsetsubset(\tenv, \isone, \istwo) \typearrow \vb
  }{ \symdomissubset(\tenv, \DBits(\isone), \DBits(\istwo)) \typearrow \vb }
  \and
  \inferrule[int]{
    \symintsetsubset(\tenv, \isone, \istwo) \typearrow \vb
  }{ \symdomissubset(\tenv, \DInt(\isone), \DInt(\istwo)) \typearrow \vb }
  \and
  \inferrule[different\_labels]{
    \astlabel(\dt) \neq \astlabel(\ds)
  }{ \symdomissubset(\tenv, \dt, \ds) \typearrow \False }
\end{mathpar}

\section{TypingRule.SymIntSetSubset}
\hypertarget{def-symintsetsubset}{}

\section{TypingRule.SymSyntaxSubset}
\hypertarget{def-symsyntaxsubset}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Symbolic Reduction and Equivalence Testing \label{chap:symbolicequivalencetesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we define two forms of symbolic reasoning ---
\emph{symbolic reduction} and \emph{symbolic equivalence testing}.
Symbolic reduction simplifies expressions into \emph{equivalent} expressions
that are simpler to reason about.
In out context, equivalence means that we can substitute one expression for another without
affecting the semantics of the overall specification.
%
Symbolic equivalence is a \emph{conservative} test.
By conservative, we mean that if a test for equivalence returns $\True$ then the expressions
being compared are indeed equivalent, but if the test returns $\False$ then
there are two possibilities:
\begin{itemize}
  \item the expressions are not equivalent;
  \item the expressions are equivalent, but the reasoning power of our rules
  is not enough to prove it, and so we conservatively answer negatively.
\end{itemize}
In proof-theoretic terms, we can say that our equivalence tests are \emph{sound} but \emph{incomplete}.

Notice that for a conservative test, it is always correct to return $\False$.

We first define symbolic expressions and operations over symbolic expressions (\secref{symbolicexpressions})
and then we define the following rules:
\begin{itemize}
  \item TypingRule.Normalize (see \secref{TypingRule.Normalize})
  \item TypingRule.ReduceConstants (see \secref{TypingRule.ReduceConstants})
  \item TypingRule.ToIR (see \secref{TypingRule.ToIR})
  \item TypingRule.ToIRCase (see \secref{TypingRule.ToIRCase})
  \item TypingRule.ExprEqualNorm (see \secref{TypingRule.ExprEqualNorm})
  \item TypingRule.ExprEqual (see \secref{TypingRule.ExprEqual})
  \item TypingRule.ExprEqualCase (see \secref{TypingRule.ExprEqualCase})
  \item TypingRule.TypeEqual (see \secref{TypingRule.TypeEqual})
  \item TypingRule.BitwidthEqual (see \secref{TypingRule.BitwidthEqual})
  \item TypingRule.BitFieldsEqual (see \secref{TypingRule.BitFieldsEqual})
  \item TypingRule.BitFieldEqual (see \secref{TypingRule.BitFieldEqual})
  \item TypingRule.ConstraintsEqual (see \secref{TypingRule.ConstraintsEqual})
  \item TypingRule.ConstraintEqual (see \secref{TypingRule.ConstraintEqual})
  \item TypingRule.SlicesEqual (see \secref{TypingRule.SlicesEqual})
  \item TypingRule.SliceEqual (see \secref{TypingRule.SliceEqual})
  \item TypingRule.ArrayLengthEqual (see \secref{TypingRule.ArrayLengthEqual})
  \item TypingRule.LiteralEqual (see \secref{TypingRule.LiteralEqual})
\end{itemize}

\section{Symbolic Expressions \label{sec:symbolicexpressions}}
Our symbolic reduction and equivalence testing rules use \emph{symbolic expressions}, defined below:
\[
  \begin{array}{rcl}
    \polynomial &\triangleq& \Sum(\unitarymonomial \partialto \Q)                  \hypertarget{def-monomial}{}\hypertarget{def-prod}{}\\
    \unitarymonomial   &\triangleq& \Prod(\Identifiers \partialto \N)\\
  \end{array}
\]

We now explain each component of a symbolic expression and how it can be interpreted as a mathematical formula
via the interpretation function $\alpha$.
We also define operations over symbolic expressions.

\hypertarget{def-unitarymonomial}{}
\begin{definition}[Unitary Monomial]
A \emph{Unitary Monomial} is a partial function from identifiers to non-negative integers\footnote{A unitary monomial has a unit factor,
for example $x^3$, whereas a non-unitary monomial has a non-unit factor, for example, $2 x^3$.}.

A non-empty unitary monomial, $\Prod(\vm)\in\unitarymonomial$ where $\vm \neq \emptyfunc$, can be interpreted as follows:
\[
  \alpha(\Prod(\vm)) \triangleq \prod_{\vx \in \dom(\vm)} \vx^{\vm(\vx)} \enspace.
\]

An empty unitary monomial is interpreted as the constant $1$:
\[
  \alpha(\Prod(\emptyfunc)) \triangleq 1 \enspace.
\]
\end{definition}
For example,
\[
  \alpha(\ \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\})\ ) = x^3 \cdot y \cdot z^2 \enspace.
\]

\hypertarget{def-mulmonomials}{}
The function
\[
  \mulmonomials(\overname{\unitarymonomial}{\vmone} \aslsep \overname{\unitarymonomial}{\vmtwo}) \rightarrow
  \overname{\unitarymonomial}{\vm}
\]
multiplies two unitary monomials and returns a unitary monomial
\begin{mathpar}
  \inferrule{
    {
      \vf \eqdef \lambda \vx\in\identifier.\
      \left\{
      \begin{array}{ll}
        \vfone(\vx) & \text{if } \vx \in \dom(\vfone) \setminus \dom(\vftwo)\\
        \vfone(\vx) & \text{if } \vx \in \dom(\vftwo) \setminus \dom(\vfone)\\
        \vfone(\vx)+\vftwo(\vx) & \text{else } \vx \in \dom(\vfone) \cap \dom(\vftwo)\\
      \end{array}
      \right.
    }
  }
  {
    \mulmonomials(\overname{\Prod(\vfone)}{\vmone}, \overname{\Prod(\vftwo)}{\vmtwo}) \typearrow \overname{\Prod(\vf)}{\vm}
  }
\end{mathpar}
For example,
\[
  \begin{array}{ll}
  \mulmonomials( & \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\}), \Prod(\{\vx\mapsto 1, \vw\mapsto 2\})\ ) =\\
                 & \Prod(\{\vx\mapsto 4, \vy\mapsto 1, \vz\mapsto2, \vw\mapsto2\})
  \end{array}
\]

\hypertarget{def-polynomial}{}
\begin{definition}[Polynomial]
  \emph{Polynomials} are partial functions from monomials to rationals.
  Intuitively, each unitary monomial is mapped to its factor in the polynomial.
  A polynomial $\Sum(\vp)$ can be interpreted as follows:
  %
\[
  \alpha(\Sum(\vp)) \triangleq \sum_{\vm \in \dom(\vp)} \vp(\vm)\cdot\alpha(\vm)
\]
\end{definition}
For example,
\[
  \Sum\left(\left\{
    \begin{array}{lcl}
      \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\}) &\mapsto& -1,\\
      \Prod(\{\vx\mapsto 2, \vy\mapsto 1\}) &\mapsto& \frac{3}{4}
    \end{array} \right\}\right) =
    -1\cdot x^3 \cdot y \cdot z^2 + \frac{3}{4} \cdot \vx^2\cdot \vy \enspace.
\]

The function
\[
  \addpolynomials : \polynomial \times \polynomial \rightarrow \polynomial
\]
adds two polynomials:
\begin{mathpar}
\inferrule{
  {
    \vf \eqdef \lambda \vm\in\unitarymonomial.\
    \left\{
    \begin{array}{ll}
      \vfone(\vm) & \text{if } \vm \in \dom(\vfone) \setminus \dom(\vftwo)\\
      \vfone(\vm) & \text{if } \vm \in \dom(\vftwo) \setminus \dom(\vfone)\\
      \vfone(\vm)+\vftwo(\vm) & \text{else } \vm \in \dom(\vfone) \cap \dom(\vftwo)\\
    \end{array}
    \right.
  }
}{
  \addpolynomials(\overname{\Sum(\vfone)}{\vpone}, \overname{\Sum(\vftwo)}{\vptwo}) \typearrow \overname{\Sum(\vf)}{\vp}
}
\end{mathpar}

The overloaded function
\[
  \addpolynomials : \polynomial^* \rightarrow \polynomial
\]
adds a list of polynomials:
\begin{mathpar}
\inferrule[empty]{}{ \addpolynomials(\emptylist) \typearrow \Prod(\emptyfunc) }
\and
\inferrule[one]{}{ \addpolynomials([ \vp ]) \typearrow \vp }
\and
\inferrule[two\_or\_more]{
  \addpolynomials(\vp_{2..k}) \typearrow \vpp\\
  \addpolynomials(\vp_1, \vpp) \typearrow \vp
}{
  \addpolynomials(\vp_{1..k}) \typearrow \vp
}
\end{mathpar}

The function
\[
  \mulpolynomials : \overname{\polynomial}{\vpone} \times \overname{\polynomial}{\vptwo} \rightarrow \overname{\polynomial}{\vp}
\]
multiplies two polynomials.
\begin{mathpar}
\inferrule{
  {
    \vps \eqdef \{ \Sum(\{\mulmonomials(\vmone, \vmtwo) \mapsto \vcone\times\vctwo\})
      \;|\; \vfone(\vmone)=\vcone, \vftwo(\vmtwo)=\vctwo\}
  }\\
  \vps \eqname \{ i=1..k: \vp[i] \}\\
  \addpolynomials(i=1..k: \vp[i]) \typearrow \vp\\
}{
  \mulpolynomials(\overname{\Sum(\vfone)}{\vpone}, \overname{\Sum(\vftwo)}{\vptwo}) \typearrow \vp
}
\end{mathpar}

\section{TypingRule.Normalize \label{sec:TypingRule.Normalize}}
\hypertarget{def-normalize}{}
The function
\[
\normalize(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto \overname{\expr}{\newe} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
symbolically simplifies an expression $\ve$ in the static environment $\tenv$,
yielding an expression $\newe$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{normalizable})
  \begin{itemize}
    \item applying $\toir$ to $\ve$ in $\tenv$ to obtain a symbolic expression yields a symbolic expression $\vpone$\ProseOrTypeError;
    \item applying $\reduceir$ to $\vpone$ to symbolically simplify $\vpone$ yields $\vptwo$;
    \item applying $\polynomialtoexpr$ to $\vptwo$ to transform it into an expression yields $\newe$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_normalizable})
  \begin{itemize}
    \item applying $\toir$ to $\ve$ in $\tenv$ to obtain a symbolic expression yields $\CannotBeTransformed$,
          indicating it cannot be transformed to a corresponding symbolic expression;
    \item define $\newe$ as $\ve$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[normalizable]{
  \toir(\tenv, \ve) \typearrow \vpone \OrTypeError\\\\
  \vpone \neq \CannotBeTransformed\\
  \reduceir(\vpone) \typearrow \vptwo\\
  \polynomialtoexpr(\vptwo) \typearrow \newe
}{
  \normalize(\tenv, \ve) \typearrow \newe
}
\and
\inferrule[not\_normalizable]{
  \toir(\tenv, \ve) \typearrow \CannotBeTransformed
}{
  \normalize(\tenv, \ve) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ReduceConstants \label{sec:TypingRule.ReduceConstants}}
\hypertarget{def-reduceconstants}{}
The function
\[
\reduceconstants(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve})
\aslto
\overname{\literal}{\vl} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
symbolically simplifies an expresson $\ve$ into the literal $\vl$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{eval\_literal}):
  \begin{itemize}
    \item applying $\staticeval$ to $\ve$ in $\tenv$ yields the literal $\vl$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{eval\_normalized}):
  \begin{itemize}
    \item applying $\staticeval$ to $\ve$ in $\tenv$ yields $\CannotBeTransformed$;
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields $\veone$\ProseOrTypeError;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the literal $\vl$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{eval\_failure}):
  \begin{itemize}
    \item applying $\staticeval$ to $\ve$ in $\tenv$ yields $\CannotBeTransformed$;
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields $\veone$\ProseOrTypeError;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields $\CannotBeTransformed$'
    \item the result is a type error indicating that $\ve$ cannot be reduced to a constant in $\tenv$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\ReduceConstantsBegin}{\ReduceConstantsEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[eval\_literal]{
  \staticeval(\tenv, \ve) \typearrow \vl \OrTypeError
}{
  \reduceconstants(\tenv, \ve) \typearrow \vl
}
\and
\inferrule[eval\_noramalized]{
  \staticeval(\tenv, \ve) \typearrow \CannotBeTransformed\\
  \normalize(\tenv, \ve) \typearrow \veone \OrTypeError\\\\
  \staticeval(\tenv, \veone) \typearrow \vl \OrTypeError
}{
  \reduceconstants(\tenv, \ve) \typearrow \vl
}
\and
\inferrule[eval\_failure]{
  \staticeval(\tenv, \ve) \typearrow \CannotBeTransformed\\
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \CannotBeTransformed \OrTypeError
}{
  \reduceconstants(\tenv, \ve) \typearrow \TypeErrorVal{CannotBeReducedToAConstant}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ToIR \label{sec:TypingRule.ToIR}}
\hypertarget{def-toir}{}
The function
\[
  \toir(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\polynomial}{\vp}\ \cup\ \{\CannotBeTransformed\}\ \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
transforms a subset of ASL expressions into symbolic expressions. If an ASL expression cannot be represented
by a symbolic expression (because, for example, it contains operations that are not available in symbolic expressions),
the special value $\CannotBeTransformed$ is returned.

\subsection{Prose}
Intuitively, $\toir$ first conducts a case analysis to determine whether the ASL expression corresponds to a polynomial.
If that fails, it proceeds to chek whether the expression is a compile time constant.

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{case\_success}):
  \begin{itemize}
    \item applying $\toircase$ to $\ve$ in $\tenv$ yields a symbolic expression $\vp$.
  \end{itemize}

  \item All of the following apply (\textsc{static\_eval\_literal}):
  \begin{itemize}
    \item applying $\toircase$ to $\ve$ in $\tenv$ yields $\CannotBeTransformed$;
    \item applying $\staticeval$ to $\ve$ yields an integer literal for $\vv$\ProseTerminateAs{\CannotBeTransformed};
    \item define $\vp$ as the polynomial representing the value $\vv$.
  \end{itemize}

  \item All of the following apply (\textsc{static\_eval\_non\_literal}):
  \begin{itemize}
    \item applying $\toircase$ to $\ve$ in $\tenv$ yields $\CannotBeTransformed$;
    \item applying $\staticeval$ to $\ve$ in $\tenv$ yields a literal $\vl$\ProseTerminateAs{\CannotBeTransformed};
    \item $\vl$ is not an integer value;
    \item define $\vp$ as $\CannotBeTransformed$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[case\_success]{
  \toircase(\tenv, \ve) \typearrow \vp\\
  \vp \neq \CannotBeTransformed
}{
  \toir(\tenv, \ve) \typearrow \vp
}
\and
\inferrule[static\_eval\_literal]{
  \toircase(\tenv, \ve) \typearrow \CannotBeTransformed\\
  \staticeval(\tenv, \ve) \typearrow \lint(\vv) \terminateas \CannotBeTransformed\\\\
  \vp \eqdef \Sum( \{ \Prod(\emptyfunc)\mapsto \vv \} )
}{
  \toir(\tenv, \ve) \typearrow \vp
}
\and
\inferrule[static\_eval\_non\_literal]{
  \toircase(\tenv, \ve) \typearrow \CannotBeTransformed\\
  \staticeval(\tenv, \ve) \typearrow \vl \terminateas \CannotBeTransformed\\\\
  \astlabel(\vl) \neq \lint
}{
  \toir(\tenv, \ve) \typearrow \CannotBeTransformed
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ToIRCase \label{sec:TypingRule.ToIRCase}}
\hypertarget{def-toircase}{}
The function
\[
  \toircase(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto \overname{\polynomial}{\vp} \cup \{\CannotBeTransformed\}
\]
transforms a subset of ASL expressions into symbolic expressions. If an expression cannot be represented
by a symbolic expression, the special value $\CannotBeTransformed$ is returned.

\subsection{Prose}
Intuitively, $\toir$ first conducts a case analysis to determine whether the ASL expression corresponds to a polynomial.
If that fails, it proceeds to chek whether the expression is a compile time constant.

\newcommand\ProseOrTypeErrorOrBot[0]{\ProseTerminateAs{\CannotBeTransformed,\TypeErrorConfig}}

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{literal\_int}):
  \begin{itemize}
    \item $\ve$ is an integer literal expression for $\vi$, that is, $\ELiteral(\lint(\vi))$;
    \item $\vp$ is the symbolic expression for $\vi$.
  \end{itemize}

  \item All of the following apply (\textsc{literal\_other}):
  \begin{itemize}
    \item $\ve$ is a variable expression other than an integer literal;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression with identifier $\vs$, that is, $\EVar(\vs)$;
    \item looking up the constant associated with $\vs$ in $\tenv$ yields the literal expression for $\vv$, that is, $\ELiteral(\vv)$;
    \item checking whether $\vv$ is an integer literal yields $\True$\ProseOrTypeError;
    \item $\vv$ is an integer literal for $\vi$;
    \item $\vp$ is the symbolic expression for $\vi$, that is, $\Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_exact\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression with identifier $\vs$, that is, $\EVar(\vs)$;
    \item looking up the constant associated with $\vs$ in $\tenv$ yields $\bot$;
    \item determining the type of $\vs$ yields $\vt$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vt$ is $\ttyone$\ProseOrTypeError;
    \item checking whether $\ttyone$ is an integer type yields $\True$\ProseOrTypeError;
    \item $\ttyone$ is a well-constrained integer with the exact constraint $\ve$, that is, \\ $\TInt(\wellconstrained([\ConstraintExact(\ve)]))$;
    \item converting $\ve$ to a symbolic expression yields $\vp$ (which may possibly be $\bot$).
  \end{itemize}

  \item All of the following apply (\textsc{int\_var}):
  \begin{itemize}
    \item $\ve$ is a variable expression with identifier $\vs$, that is, $\EVar(\vs)$;
    \item looking up the constant associated with $\vs$ in $\tenv$ yields $\bot$;
    \item determining the type of $\vs$ yields $\vt$\ProseOrTypeError;
    \item the \underlyingtype\ of $\vt$ is $\ttyone$\ProseOrTypeError;
    \item checking whether $\ttyone$ is an integer type yields $\True$\ProseOrTypeError;
    \item $\ttyone$ is not a well-constrained integer with a single exact constraint;
    \item $\vp$ is the symbolic expression for the variable $\vs$, that is, $\Sum( \{ \Prod(\{\vs\mapsto 1\})\mapsto 1 \} )$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_plus}):
  \begin{itemize}
    \item $\ve$ is a binary addition expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\PLUS, \veone, \vetwo)$;
    \item converting $\veone$ to a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeErrorOrBot;
    \item converting $\vetwo$ to a symbolic expression in $\tenv$ yields $\irtwo$\ProseOrTypeErrorOrBot;
    \item $\vp$ is the symbolic expression adding up $\irone$ and $\irtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_minus}):
  \begin{itemize}
    \item $\ve$ is a binary Substraction expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\MINUS, \veone, \vetwo)$;
    \item $\vep$ is the addition expression with operands $\veone$ and the negation of $\vetwo$, that is, \\ $\EBinop(\PLUS, \veone, \EBinop(\MINUS, \vetwo))$;
    \item converting $\vpp$ into a symbolic expression in $\tenv$ yields $\vp$\ProseOrTypeErrorOrBot.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_mul}):
  \begin{itemize}
    \item $\ve$ is a binary multiplication expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\MUL, \veone, \vetwo)$;
    \item converting $\veone$ to a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeErrorOrBot;
    \item converting $\vetwo$ to a symbolic expression in $\tenv$ yields $\irtwo$\ProseOrTypeErrorOrBot;
    \item $\vp$ is the symbolic expression multiplying $\irone$ and $\irtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_div\_non\_int\_denominator}):
  \begin{itemize}
    \item $\ve$ is a binary division expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\DIV, \veone, \vetwo)$;
    \item $\vetwo$ is not an integer literal expression;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_div\_int\_denominator}):
  \begin{itemize}
    \item $\ve$ is a binary division expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\DIV, \veone, \vetwo)$;
    \item $\vetwo$ is an integer literal expression for $\vitwo$;
    \item converting $\veone$ to a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeErrorOrBot;
    \item $\vftwo$ is $\frac{1}{\vitwo}$;
    \item $\vp$ is the polynomial $\irone$ with each monomial multiplied by $\vftwo$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_shl\_non\_lint\_exponent}):
  \begin{itemize}
    \item $\ve$ is a binary shift-left expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\SHL, \veone, \vetwo)$;
    \item $\vetwo$ is not an integer literal expression;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_shl\_non\_neg\_shift}):
  \begin{itemize}
    \item $\ve$ is a binary shift-left expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\SHL, \veone, \vetwo)$;
    \item $\vetwo$ is an integer literal expression for $\vitwo$;
    \item $\vitwo$ is negative;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_shl\_okay}):
  \begin{itemize}
    \item $\ve$ is a binary shift-left expression with operands $\veone$ and $\vetwo$, that is, \\ $\EBinop(\SHL, \veone, \vetwo)$;
    \item $\vetwo$ is an integer literal expression for $\vitwo$;
    \item converting $\veone$ to a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeErrorOrBot;
    \item $\vitwo$ is non-negative;
    \item $\vftwo$ is $2^{\vitwo}$;
    \item $\vp$ is the polynomial $\irone$ with each monomial multiplied by $\vftwo$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_other\_non\_literals}):
  \begin{itemize}
    \item $\ve$ is a binary expression with an operator $\op$ that is other than $\PLUS$, $\MINUS$, $\MUL$, or $\SHL$,
          applied to the operand expressions $\veone$ and $\vetwo$;
    \item at least one of $\veone$ and $\vetwo$ is not a literal expression;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_other\_literals\_non\_int\_result}):
  \begin{itemize}
    \item $\ve$ is a binary expression with an operator $\op$ that is other than $\PLUS$, $\MINUS$, $\MUL$, $\DIV$, or $\SHL$,
          applied to the operand expressions $\veone$ and $\vetwo$;
    \item $\veone$ is the literal expression for literal $\vlone$;
    \item $\vetwo$ is the literal expression for literal $\vltwo$;
    \item statically applying $\op$ to $\vlone$ and $\vltwo$ yields the literal $\vl$, which is not an integer literal;
    \item $\vp$ is $\bot$.
  \end{itemize}

  \item All of the following apply (\textsc{ebinop\_other\_literals\_int\_result}):
  \begin{itemize}
    \item $\ve$ is a binary expression with an operator $\op$ that is other than $\PLUS$, $\MINUS$, $\MUL$, or $\SHL$,
          applied to the operand expressions $\veone$ and $\vetwo$;
    \item $\veone$ is the literal expression for literal $\vlone$;
    \item $\vetwo$ is the literal expression for literal $\vltwo$;
    \item statically applying $\op$ to $\vlone$ and $\vltwo$ yields the integer literal for $k$;
    \item $\vp$ is the symbolic expression for the integer $k$, that is, $\Sum( \{ \Prod(\emptyfunc)\mapsto k \} )$.
  \end{itemize}

  \item All of the following apply (\textsc{eunop\_neg}):
  \begin{itemize}
    \item $\ve$ is a unary expression with the negation operator $\NEG$ and operand $\veone$;
    \item converting the binary expression with operator $\MUL$ and left-hand-side operand for the integer literal $-1$ and
    right-hand-side operand $\veone$ in $\tenv$ yields $\vp$\ProseOrTypeErrorOrBot.
  \end{itemize}

  \item All of the following apply (\textsc{eunop\_other}):
  \begin{itemize}
    \item $\ve$ is a unary expression with an operator other than $\NEG$;
    \item $\vp$ is bottom
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\ve$ is an expression with a label other than $\ELiteral$, $\EVar$, $\EBinop$, and $\EUnop$;
    \item $\vp$ is bottom
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[literal\_int]{}
{
  \toircase(\tenv, \overname{\ELiteral(\lint(\vi))}{\ve}) \typearrow \overname{\Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )}{\vp}
}
\and
\inferrule[literal\_other]{
  \astlabel(\vv) \neq \lint
}{
  \toircase(\tenv, \overname{\ELiteral(\vv)}{\ve}) \typearrow \CannotBeTransformed
}
\and
\inferrule[int\_constant]{
  \lookupconstant(\tenv, \vs) \typearrow \ELiteral(\vv)\\
  \checktrans{\astlabel(\vv) = \lint}{ExpectedIntegerLiteral} \typearrow \True \OrTypeError\\
  \vv \eqname \lint(\vi)
}{
  \toircase(\tenv, \overname{\EVar(\vs)}{\ve}) \typearrow \overname{\Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )}{\vp}
}
\and
\inferrule[int\_exact\_constraint]{
  \lookupconstant(\tenv, \vs) \typearrow \CannotBeTransformed\\
  \typeof(\vs) \typearrow \vt \OrTypeError\\\\
  \makeanonymous(\vt) \typearrow \ttyone \OrTypeError\\\\
  \checktrans{\astlabel(\ttyone) = \TInt}{ExpectedIntegerType} \typearrow \True \OrTypeError\\\\
  \ttyone = \TInt(\wellconstrained([\ConstraintExact(\ve)]))\\
  \toir(\ve) \typearrow \vp
}{
  \toircase(\tenv, \overname{\EVar(\vs)}{\ve}) \typearrow \vp
}
\and
\inferrule[int\_var]{
  \lookupconstant(\tenv, \vs) \typearrow \CannotBeTransformed\\
  \typeof(\vs) \typearrow \vt\\
  \makeanonymous(\vt) \typearrow \ttyone\\
  \checktrans{\astlabel(\ttyone) = \TInt}{ExpectedIntegerType} \typearrow \True\\
  \ttyone \neq \TInt(\wellconstrained([\ConstraintExact(\Ignore)]))
}{
  \toircase(\tenv, \overname{\EVar(\vs)}{\ve}) \typearrow \overname{\Sum( \{ \Prod(\{\vs\mapsto 1\})\mapsto 1 \} )}{\vp}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_plus]{
  \toir(\tenv, \veone) \typearrow \irone \OrTypeError, \CannotBeTransformed\\\\
  \toir(\tenv, \vetwo) \typearrow \irtwo \OrTypeError, \CannotBeTransformed\\\\
  \vp \eqdef \addpolynomials(\irone, \irtwo)
}{
  \toircase(\tenv, \overname{\EBinop(\PLUS, \veone, \vetwo)}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_minus]{
  \vep \eqdef \EBinop(\PLUS, \veone, \EBinop(\MINUS, \vetwo))\\
  \toir(\tenv, \vpp) \typearrow \vp \OrTypeError, \CannotBeTransformed\\\\
}{
  \toircase(\tenv, \overname{\EBinop(\MINUS, \veone, \vetwo)}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_mul]{
  \toir(\tenv, \veone) \typearrow \irone \OrTypeError, \CannotBeTransformed\\\\
  \toir(\tenv, \vetwo) \typearrow \irtwo \OrTypeError, \CannotBeTransformed\\\\
  \vp \eqdef \mulpolynomials(\irone, \irtwo)
}{
  \toircase(\tenv, \overname{\EBinop(\MUL, \veone, \vetwo)}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_div\_non\_int\_denominator]{
  \vetwo \neq \ELiteral(\lint(\Ignore))
}{
  \toircase(\tenv, \overname{\EBinop(\DIV, \veone, \vetwo)}{\ve}) \typearrow \CannotBeTransformed
}
\and
\inferrule[ebinop\_div\_int\_denominator]{
  \toir(\tenv, \veone) \typearrow \irone \OrTypeError, \CannotBeTransformed\\\\
  \vftwo \eqdef \frac{1}{\vitwo}\\
  \irone \eqname \Sum [i=1..k: \vm_\vi \mapsto \vc_\vi]\\
  \vp \eqdef \Sum [i=1..k: \vm_\vi \mapsto \vc_\vi \times \vftwo]\\
}{
  \toircase(\tenv, \overname{\EBinop(\DIV, \veone, \overname{\ELiteral(\lint(\vitwo))}{\vetwo})}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_shl\_non\_lint\_exponent]{
    \vetwo \neq \ELiteral(\lint(\Ignore))
}{
  \toircase(\tenv, \overname{\EBinop(\SHL, \Ignore, \vetwo)}{\ve}) \typearrow \CannotBeTransformed
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_shl\_neg\_shift]{
  \vitwo < 0
}{
  \toircase(\tenv, \overname{\EBinop(\SHL, \veone, \ELiteral(\lint(\vitwo)))}{\ve}) \typearrow \CannotBeTransformed
}
\and
  \inferrule[ebinop\_shl\_okay]{
    \toir(\tenv, \veone) \typearrow \irone \OrTypeError, \CannotBeTransformed\\\\
    \vitwo \geq 0\\
    \vftwo \eqdef 2^{\vitwo}\\
    \irone \eqname \Sum [i=1..k: \vm_\vi \mapsto \vc_\vi]\\
    \vp \eqdef \Sum [i=1..k: \vm_\vi \mapsto \vc_\vi \times \vftwo]\\
}{
  \toircase(\tenv, \overname{\EBinop(\SHL, \veone, \ELiteral(\lint(\vitwo)))}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop\_other\_non\_literals]{
  \op \not\in \{\PLUS, \MINUS, \MUL, \DIV, \SHL\}\\
  (\veone \neq \ELiteral(\Ignore) \lor \vetwo \neq \ELiteral(\Ignore))
}{
  \toircase(\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \CannotBeTransformed
}
\and
\inferrule[ebinop\_other\_literals\_non\_int\_result]{
  \op \not\in \{\PLUS, \MINUS, \MUL, \SHL\}\\
  \binopliterals(\op, \vlone, \vltwo) \typearrow \vl\\
  \vl \neq \lint(\Ignore)
}{
  \toircase(\tenv, \overname{\EBinop(\op, \ELiteral(\vlone), \ELiteral(\vltwo))}{\ve}) \typearrow \CannotBeTransformed
}
\and
\inferrule[ebinop\_other\_literals\_int\_result]{
  \op \not\in \{\PLUS, \MINUS, \MUL, \SHL\}\\
  \binopliterals(\op, \vlone, \vltwo) \typearrow \lint(k)\\
  \vp \eqdef \Sum( \{ \Prod(\emptyfunc)\mapsto k \} )
}{
  \toircase(\tenv, \overname{\EBinop(\op, \ELiteral(\vlone), \ELiteral(\vltwo))}{\ve}) \typearrow \vp
}
\end{mathpar}

\begin{mathpar}
\inferrule[eunop\_neg]{
  \toir(\tenv, \EBinop(\MUL, \ELiteral(\lint(-1)),\veone )) \typearrow \vp \OrTypeError, \CannotBeTransformed\\\\
}{
  \toircase(\tenv, \overname{\EUnop(\NEG, \veone)}{\ve}) \typearrow \vp
}
\and
\inferrule[eunop\_other]{
  \op \neq \NEG
}{
  \toircase(\tenv, \overname{\EUnop(\op, \Ignore)}{\ve}) \typearrow \CannotBeTransformed
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \not\in \{\ELiteral, \EVar, \EBinop, \EUnop\}
}{
  \toircase(\tenv, \ve) \typearrow \CannotBeTransformed
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ExprEqualNorm \label{sec:TypingRule.ExprEqualNorm}}
\hypertarget{def-exprequalnorm}{}
The function
\[
  \exprequalnorm(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the expression $\veone$ is equivalent to the expression $\vetwo$ in environment $\tenv$
by attempting to transform both expressions to their symbolic expression form
and, if successful, comparing the resulting normal forms for equality.
The result is given in $\vb$ or a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{all\_supported}):
  \begin{itemize}
    \item transforming $\veone$ into a symbolic expression in $\tenv$ yields $\irone$\ProseOrTypeError;
    \item transforming $\vetwo$ into a symbolic expression in $\tenv$ yields $\irtwo$\ProseOrTypeError;
    \item $\vb$ is the result of equating $\irone$ and $\irtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{unsupported1}):
  \begin{itemize}
    \item transforming $\veone$ into a symbolic expression in $\tenv$ yields $\CannotBeTransformed$;
    \item $\vb$ is $\False$;
  \end{itemize}

  \item All of the following apply (\textsc{unsupported2}):
  \begin{itemize}
    \item transforming $\veone$ into a symbolic expression in $\tenv$ yields $\irone$;
    \item transforming $\vetwo$ into a symbolic expression in $\tenv$ yields $\CannotBeTransformed$;
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[all\_supported]{
  \toir(\veone) \typearrow \irone \OrTypeError\\\\
  \toir(\vetwo) \typearrow \irtwo \OrTypeError
}{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \overname{\irone = \irtwo}{\vb}
}
\and
\inferrule[unsupported1]{
  \toir(\veone) \typearrow \CannotBeTransformed
}{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[unsupported2]{
  \toir(\veone) \typearrow \irone\\
  \toir(\vetwo) \typearrow \CannotBeTransformed
}{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ExprEqual \label{sec:TypingRule.ExprEqual}}
\hypertarget{def-exprequal}{}
The function
\[
  \exprequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo}) \aslto
  \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively checks whether the expression $\veone$ is equivalent to the expression $\vetwo$ in environment $\tenv$.
The result is given in $\vb$ or a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{norm\_true}):
  \begin{itemize}
    \item comparing $\veone$ to $\vetwo$ in $\tenv$ via $\exprequalnorm$ yields $\True$\ProseOrTypeError;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{norm\_false}):
  \begin{itemize}
    \item comparing $\veone$ to $\vetwo$ in $\tenv$ via $\exprequalnorm$ yields $\False$;
    \item comparing $\veone$ to $\vetwo$ by case analysis via $\exprequalcase$ yields $\vb$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[norm\_true]{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \True \OrTypeError
}{
  \exprequal(\tenv, \veone, \vetwo) \typearrow \True
}
\and
\inferrule[norm\_false]{
  \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \False\\
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb \OrTypeError
}{
  \exprequal(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ExprEqualCase \label{sec:TypingRule.ExprEqualCase}}
\hypertarget{def-exprequalcase}{}
The function
\[
  \exprequalcase(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
specializes the equivalence test for expressions $\veone$ and $\vetwo$ in $\tenv$
for the different types of expressions.
The result is given in $\vb$ or a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item the AST labels of $\veone$ and $\vetwo$ are different;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop}):
  \begin{itemize}
    \item $\veone$ is a binary expression with operator $\opone$ and operands $\veoneone$ and $\veonetwo$,
          that is, $\EBinop(\opone, \veoneone, \veonetwo)$;
    \item $\vetwo$ is a binary expression with operator $\optwo$ and operands $\vetwoone$ and $\vetwotwo$,
          that is, $\EBinop(\optwo, \vetwoone, \vetwotwo)$;
    \item testing the equivalence of $\veoneone$ and $\vetwoone$ in $\tenv$ yields $\vbone$\ProseOrTypeError;
    \item testing the equivalence of $\veonetwo$ and $\vetwotwo$ in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\opone$ is equal to $\optwo$ and both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_call}):
  \begin{itemize}
    \item $\veone$ is a call expression with subprogram name $\nameone$ and list of arguments $vargsone$,
          that is, $\ECall(\nameone, \vargsone, \Ignore)$;
    \item $\vetwo$ is a call expression with subprogram name $\nametwo$ and list of arguments $vargstwo$,
          that is, $\ECall(\nametwo, \vargstwo, \Ignore)$;
    \item checking whether $\nameone$ is equal to $\nametwo$ either yields $\True$ or $\False$, which short-circuits the entire rule;
    \item checking whether the lists of arguments $\vargsone$ and $\vargstwo$ have the same length yields
          $\True$ or $\False$, which short-circuits the entire rule;
    \item for each index $i$ in the list of indices for $\vargsone$, testing whether $\vargsone[i]$ is equivalent to $\vargstwo[i]$
          in $\tenv$ yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for each index $i$ in the list of indices for $\vargsone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_concat}):
  \begin{itemize}
    \item $\veone$ is a concatenation expression with $\vlone$, that is, $\EConcat(\vlone)$;
    \item $\vetwo$ is a concatenation expression with $\vltwo$, that is, $\EConcat(\vltwo)$;
    \item checking whether the lists of expressions $\vlone$ and $\vltwo$ have the same length yields
          $\True$ or $\False$, which short-circuits the entire rule;
    \item for each index $i$ in the list of indices for $\vlone$, testing whether $\vlone[i]$ is equivalent to $\vltwo[i]$
          in $\tenv$ yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for each index $i$ in the list of indices for $\vlone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_cond}):
  \begin{itemize}
    \item $\veone$ is a conditional expression with expressions $\veoneone$, $\veonetwo$, and $\veonethree$,
          that is, $\ECond(\veoneone, \veonetwo, \veonethree)$;
    \item $\vetwo$ is a conditional expression with expressions $\vetwoone$, $\vetwotwo$, and $\vetwothree$,
          that is, $\ECond(\vetwoone, \vetwotwo, \vetwothree)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbone$\ProseOrTypeError;
    \item testing whether $\veonetwo$ is equivalent to $\vetwotwo$ yields $\vbtwo$\ProseOrTypeError;
    \item testing whether $\veonethree$ is equivalent to $\vetwothree$ yields $\vbthree$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if all of $\vbone$, $\vbtwo$, and $\vbthree$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice}):
  \begin{itemize}
    \item $\veone$ is a slicing expression with expression $\veoneone$ and list of slices $\slicesone$,
          that is, $\ESlice(\veoneone, \slicesone)$;
    \item $\veone$ is a slicing expression with expression $\vetwoone$ and list of slices $\slicestwo$,
          that is, $\ESlice(\vetwoone, \slicestwo)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbone$\ProseOrTypeError;
    \item testing whether the lists of slices $\slicesone$ and $\slicestwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getarray}):
  \begin{itemize}
    \item $\veone$ is an array access expression with array expression $\veoneone$ and position expression $\veonetwo$,
          that is, $\EGetArray(\veoneone, \veonetwo)$;
    \item $\vetwo$ is an array access expression with array expression $\vetwoone$ and position expression $\vetwotwo$,
          that is, $\EGetArray(\vetwoone, \vetwotwo)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbone$\ProseOrTypeError;
    \item testing whether $\veonetwo$ is equivalent to $\vetwotwo$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfield}):
  \begin{itemize}
    \item $\veone$ is a field access expression with sub-expression $\veoneone$ and field name $\vfieldone$,
          that is, $\EGetField(\veoneone, \vfieldone)$;
    \item $\vetwo$ is a field access expression with sub-expression $\vetwoone$ and field name $\vfieldtwo$,
          that is, $\EGetField(\vetwoone, \vfieldtwo)$;
    \item $\vbone$ is $\True$ if and only if $\vfieldone$ is equal to $\vfieldtwo$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfields}):
  \begin{itemize}
    \item $\veone$ is a fields access expression with sub-expression $\veoneone$ and list of field names $\vfieldsone$,
          that is, $\EGetFields(\veoneone, \vfieldsone)$;
    \item $\vetwo$ is a fields access expression with sub-expression $\vetwoone$ and list of field names $\vfieldstwo$,
          that is, $\EGetFields(\vetwoone, \vfieldstwo)$;
    \item $\vbone$ is $\True$ if and only if $\vfieldsone$ is equal to $\vfieldstwo$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getitem}):
  \begin{itemize}
    \item $\veone$ is a tuple access expression with sub-expression $\veoneone$ and position $\vione$,
          that is, $\EGetItem(\veoneone, \vione)$;
    \item $\vetwo$ is a tuple access expression with sub-expression $\vetwoone$ and position $\vitwo$,
          that is, $\EGetItem(\vetwoone, \vitwo)$;
    \item $\vbone$ is $\True$ if and only if $\vione$ is equal to $\vitwo$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_literal}):
  \begin{itemize}
    \item $\veone$ is the literal expression with literal $\vvone$;
    \item $\vetwo$ is the literal expression with literal $\vvtwo$;
    \item $\vb$ is $\True$ if and only if $\vvone$ is equivalent to $\vvtwo$ in $\tenv$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_pattern}):
  \begin{itemize}
    \item both $\veone$ and $\vetwo$ are pattern expressions;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_record}):
  \begin{itemize}
    \item both $\veone$ and $\vetwo$ are record expressions;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_tuple}):
  \begin{itemize}
    \item $\veone$ is a tuple expression with sub-expressions list $\vlone$,
          that is, $\ETuple(\vlone)$;
    \item $\vetwo$ is a tuple expression with sub-expressions list $\vltwo$,
          that is, $\ETuple(\vltwo)$;
    \item checking whether the lengths of $\vlone$ and $\vltwo$ are equal yields either $\True$ or $\False$, which short-circuits
          the entire rule;
    \item for each index $i$ in the list of indices for $\vlone$, testing whether $\vlone[i]$ is equivalent to $\vltwo[i]$
          in $\tenv$ yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for each index $i$ in the list of indices for $\vlone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop}):
  \begin{itemize}
    \item $\veone$ is a unary operator expression with operator $\opone$ and operand expressions $\veoneone$,
          that is, $\EUnop(\opone, \veoneone)$;
    \item $\vetwo$ is a unary operator expression with operator $\optwo$ and operand expressions $\vetwoone$,
          that is, $\EUnop(\optwo, \vetwoone)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ in $\tenv$ yields $\vbone$;
    \item $\vb$ is $\True$ if and only if $\opone$ is equal to $\optwo$ and $\vbone$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unknown}):
  \begin{itemize}
    \item both $\veone$ and $\vetwo$ are $\UNKNOWN$ expressions;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_atc}):
  \begin{itemize}
    \item $\veone$ is a type assertion with sub-expression with operator $\veoneone$ and type $\vtone$,
          that is, $\EATC(\veoneone, \vtone)$;
    \item $\vetwo$ is a type assertion with sub-expression with operator $\vetwoone$ and type $\vttwo$,
          that is, $\EATC(\vetwoone, \vttwo)$;
    \item testing whether $\veoneone$ is equivalent to $\vetwoone$ in $\tenv$ yields $\vbone$;
    \item testing whether $\vtone$ is equivalent to $\vttwo$ in $\tenv$ yields $\vbtwo$;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var}):
  \begin{itemize}
    \item $\veone$ is a variable expression with identifier $\nameone$, that is, $\EVar(\nameone)$;
    \item $\vetwo$ is a variable expression with identifier $\nametwo$, that is, $\EVar(\nametwo)$;
    \item $\vb$ is $\True$ if and only if both $\nameone$ is equal to $\nametwo$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\veone) \neq \astlabel(\vetwo)
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{
  \veone \eqname \EBinop(\opone, \veoneone, \veonetwo)\\
  \vetwo \eqname \EBinop(\optwo, \vetwoone, \vetwotwo)\\
  \exprequal(\veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\veonetwo, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef (\opone = \optwo) \land \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

(Recall that a conjunction over an empty set equals $\True$.)
\begin{mathpar}
\inferrule[e\_call]{
  \veone \eqname \ECall(\nameone, \vargsone, \Ignore)\\
  \vetwo \eqname \ECall(\nametwo, \vargstwo, \Ignore)\\\\
  \booltrans{\nameone = \nametwo} \booltransarrow \True \terminateas \False\\\\
  \equallength(\vargsone, \vargstwo) \typearrow \True \terminateas \False\\\\
  i \in \listrange(\vargsone): \exprequal(\tenv, \vargsone[i], \vargstwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vargsone)} \vb_i
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_concat]{
  \veone \eqname \EConcat(\vlone)\\
  \vetwo \eqname \EConcat(\vltwo)\\\\
  \equallength(\vlone, \vltwo) \typearrow \True \terminateas \False\\\\
  i \in \listrange(\vlone): \exprequal(\tenv, \vlone[i], \vltwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vlone)} \vb_i
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{
  \veone \eqname \ECond(\veoneone, \veonetwo, \veonethree)\\
  \vetwo \eqname \ECond(\vetwoone, \vetwotwo, \vetwothree)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \exprequal(\tenv, \veonethree, \vetwothree) \typearrow \vbthree \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_slice]{
  \veone \eqname \ESlice(\veoneone, \slicesone)\\
  \vetwo \eqname \ESlice(\vetwoone, \slicestwo)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getarray]{
  \veone \eqname \EGetArray(\veoneone, \veonetwo)\\
  \vetwo \eqname \EGetArray(\vetwoone, \vetwotwo)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getfield]{
  \veone \eqname \EGetField(\veoneone, \vfieldone)\\
  \vetwo \eqname \EGetField(\vetwoone, \vfieldtwo)\\\\
  \vbone \eqdef \vfieldone = \vfieldtwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getfields]{
  \veone \eqname \EGetFields(\veoneone, \vfieldsone)\\
  \vetwo \eqname \EGetFields(\vetwoone, \vfieldstwo)\\\\
  \vbone \eqdef \vfieldsone = \vfieldstwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getitem]{
  \veone \eqname \EGetItem(\veoneone, \vione)\\
  \vetwo \eqname \EGetItem(\vetwoone, \vitwo)\\\\
  \vbone \eqdef \vione = \vitwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_literal]{
  \veone \eqname \ELiteral(\vvone)\\
  \vetwo \eqname \ELiteral(\vvtwo)\\\\
  \literalequal(\vvone, \vvtwo) \typearrow \vb
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern]{
  \astlabel(\veone) = \EPattern \land \astlabel(\vetwo) = \EPattern
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record]{
  \astlabel(\veone) = \ERecord \land \astlabel(\vetwo) = \ERecord
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_tuple]{
  \veone \eqname \ETuple(\vlone)\\
  \vetwo \eqname \ETuple(\vltwo)\\
  \equallength(\vlone, \vltwo) \typearrow \True \terminateas \False\\\\
  i \in \listrange(\vlone): \exprequal(\tenv, \vlone[i], \vltwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vlone)} \vb_i
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{
  \veone \eqname \EUnop(\opone, \veoneone)\\
  \vetwo \eqname \EUnop(\optwo, \vetwoone)\\\\
  \exprequal(\veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \vb \eqdef (\opone = \optwo) \land \vbone
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unknown]{
  (\astlabel(\veone) = \EUnknown \land \astlabel(\vetwo) = \EUnknown)
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_atc]{
  \veone \eqname \EATC(\veoneone, \vtone)\\
  \vetwo \eqname \EATC(\vetwoone, \vttwo)\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var]{
  \veone \eqname \EVar(\nameone)\\
  \vetwo \eqname \EVar(\nametwo)\\\\
  \vb \eqdef \nameone = \nametwo
}{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}
%   | E_Pattern _, _ | E_Record _, _ -> assert false

\section{TypingRule.TypeEqual \label{sec:TypingRule.TypeEqual}}
\hypertarget{def-typeequal}{}
The function
\[
  \typeequal(\overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo}) \aslto
   \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the type $\vtone$ is equivalent to the type $\vttwo$ in environment $\tenv$
and yields the result in $\vb$.  The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item the AST labels of $\vtone$ and $\vttwo$ are different;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{tbool\_treal\_tstring}):
  \begin{itemize}
    \item both $\vtone$ and $\vttwo$ are both either $\TBool$, $\TReal$, or $\TString$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tint\_unconstrained}):
  \begin{itemize}
    \item both $\vtone$ and $\vttwo$ are the unconstrained integer type $\TInt(\unconstrained)$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tint\_underconstrained}):
  \begin{itemize}
    \item $\vtone$ is the underconstrained integer type with identifier $\vione$, that is, \\ $\TInt(\underconstrained(\vione))$;
    \item $\vttwo$ is the underconstrained integer type with identifier $\vitwo$, that is, \\ $\TInt(\underconstrained(\vitwo))$;
    \item $\vb$ is $\True$ if and only if $\vione$ is equal to $\vitwo$.
  \end{itemize}

  \item All of the following apply (\textsc{tint\_wellconstrained}):
  \begin{itemize}
    \item $\vtone$ is the well-constrained integer type with list of constraints $\vcone$, that is, \\ $\TInt(\wellconstrained(\vcone))$;
    \item $\vttwo$ is the well-constrained integer type with list of constraints $\vctwo$, that is, \\ $\TInt(\wellconstrained(\vctwo))$;
    \item testing whether $\vcone$ and $\vctwo$ are equivalent in $\tenv$ yields $\vb$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{tbits}):
  \begin{itemize}
    \item $\vtone$ is the bitvector type with width expression $\vwone$ and list of bitfields $\bfone$, that is, $\TBits(\vwone, \bfone)$;
    \item $\vttwo$ is the bitvector type with width expression $\vwtwo$ and list of bitfields $\bftwo$, that is, $\TBits(\vwtwo, \bftwo)$;
    \item testing whether $\vwone$ and $\vwtwo$ are equivalent bitwidths in $\tenv$ yields $\vbone$\ProseOrTypeError;
    \item testing whether $\bfone$ and $\bftwo$ are equivalent lists of bitfields in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tarray}):
  \begin{itemize}
    \item $\vtone$ is an array type with index $\vlone$ and element type $\vtone$, that is, $\TArray(\vlone, \vtone)$;
    \item $\vttwo$ is an array type with index $\vltwo$ and element type $\vttwo$, that is, $\TArray(\vltwo, \vttwo)$;
    \item testing whether $\vlone$ is equivalent to $\vltwo$ in $\tenv$ yields $\vbone$\ProseOrTypeError;
    \item testing whether $\vtone$ is equivalent to $\vttwo$ in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tnamed}):
  \begin{itemize}
    \item $\vtone$ is a named type with identifier $\vsone$, that is $\TNamed(\vsone)$;
    \item $\vttwo$ is a named type with identifier $\vstwo$, that is $\TNamed(\vstwo)$;
    \item $\vb$ is $\True$ if and only if $\vsone$ is equal to $\vstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{tenum}):
  \begin{itemize}
    \item $\vtone$ is an enumeration type with identifier $\vlone$, that is $\TEnum(\vlone)$;
    \item $\vttwo$ is an enumeration type with identifier $\vltwo$, that is $\TEnum(\vltwo)$;
    \item $\vb$ is $\True$ if and only if $\vlone$ is equal to $\vltwo$.
  \end{itemize}

  \item All of the following apply (\textsc{tstructured}):
  \begin{itemize}
    \item $L$ is either $\TRecord$ or $\TException$;
    \item $\vtone$ is either a record type or an exception type with list of fields $\vfieldsone$, that is $L(\vfieldsone)$;
    \item $\vttwo$ is either a record type or an exception type with list of fields $\vfieldstwo$, that is $L(\vfieldstwo)$;
    \item checking whether the set of field names in $\vfieldsone$ is equal to the set of field names in $\vfieldstwo$
          yields $\True$ or $\False$, which short-circuits the entire rule;
    \item for each field $\vf$ in the set of fields of $\vfieldsone$, testing whether the type associated with
          $\vf$ in $\vfieldsone$ is equivalent to the type associated with
          $\vf$ in $\vfieldstwo$ in $\tenv$ yields $\vb_\vf$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_\vf$ is $\True$ for each field $\vf$ in the set of fields of $\vfieldsone$.
  \end{itemize}

  \item All of the following apply (\textsc{ttuple}):
  \begin{itemize}
    \item $\vtone$ is a tuple type with list of types $\vtsone$, that is $\TTuple(\vtsone)$;
    \item $\vttwo$ is a tuple type with list of types $\vtstwo$, that is $\TTuple(\vtstwo)$;
    \item checking whether the list of types $\vtsone$ has the same length as the list of types $\vtstwo$ yields $\True$
          or $\False$, which short-circuits the entire rule;
    \item for each index $i$ in the list $\vtsone$, testing whether $\vtsone[i]$ is equivalent to $\vtstwo[i]$ in $\tenv$
          yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for each index $i$ in the list $\vtsone$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\vtone) \neq \astlabel(\vttwo)
}{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[TBool\_TReal\_TString]{
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \in \{\TBool, \TReal, \TString\}
}{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \True
}
\and
\end{mathpar}

\begin{mathpar}
\inferrule[tint\_unconstrained]{}
{
  \typeequal(\tenv, \TInt(\unconstrained), \TInt(\unconstrained)) \typearrow \True
}
\and
\inferrule[tint\_underconstrained]{
  \vb \eqdef \vione = \vitwo
}{
  \typeequal(\tenv, \TInt(\underconstrained(\vione)), \TInt(\underconstrained(\vitwo))) \typearrow \vb
}
\and
\inferrule[tint\_wellconstrained]{
  \constraintsequal(\tenv, \vcone, \vctwo) \typearrow \vb \OrTypeError
}{
  \typeequal(\tenv, \TInt(\wellconstrained(\vcone)), \TInt(\wellconstrained(\vctwo))) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tbits]{
  \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vbone \OrTypeError\\\\
  \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \typeequal(\tenv, \TBits(\vwone, \bfone), \TBits(\vwtwo, \bftwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tarray]{
  \exprequal(\tenv, \vlone, \vltwo) \typearrow \vbone \OrTypeError\\\\
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \typeequal(\tenv, \TArray(\vlone, \vtone), \TArray(\vltwo, \vttwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tnamed]{
  \vb \eqdef \vsone = \vstwo
}{
  \typeequal(\tenv, \TNamed(\vsone), \TNamed(\vstwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tenum]{
  \vb \eqdef \vlone = \vltwo
}{
  \typeequal(\tenv, \TEnum(\vlone), \TEnum(\vltwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[tstructured]{
  L \in \{\TRecord, \TException\}\\
  \booltrans{\fieldnames(\vfieldsone) = \fieldnames(\vfieldstwo)} \booltransarrow \True \terminateas \False\\\\
  {
    \begin{array}{l}
  \vf \in \fieldnames(\vfieldsone): \\ \typeequal(\tenv, \fieldtype(\vfieldsone, \vf), \fieldtype(\vfieldstwo, \vf)) \typearrow \vb_\vf \OrTypeError
    \end{array}
  }\\\\
  \vb \eqdef \bigwedge_{\vf \in \fieldnames(\vfieldsone)} \vb_\vf
}{
  \typeequal(\tenv, L(\vfieldsone), L(\vfieldstwo)) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[ttuple]{
  \equallength(\vtsone, \vtstwo) \typearrow \True \terminateas \False\\
  i \in \listrange(\vtsone): \typeequal(\tenv, \vtsone[i], \vtstwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vtsone)} \vb_i
}{
  \typeequal(\tenv, \TTuple(\vtsone), \TTuple(\vtstwo)) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.BitwidthEqual \label{sec:TypingRule.BitwidthEqual}}
\hypertarget{def-bitwidthequal}{}
The function
\[
  \bitwidthequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\vwone} \aslsep \overname{\expr}{\vwtwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the bitwidth expression $\vwone$ is equivalent to the bitwidth expression $\vwtwo$
in environment $\tenv$ and yields the result in $\vb$.  The result is a type error, if one is detected.

\subsection{Prose}
Testing whether the expressions $\vwone$ and $\vwtwo$ are equivalent in $\tenv$ yields $\vb$\ProseOrTypeError.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \exprequal(\tenv, \vwone, \vwtwo) \typearrow \vb \OrTypeError
}{
  \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.BitFieldsEqual \label{sec:TypingRule.BitFieldsEqual}}
\hypertarget{def-bitfieldsequal}{}
The function
\[
  \bitfieldsequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield^*}{\bfone} \aslsep \overname{\bitfield^*}{\bftwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the list of bitfields $\bfone$ is equivalent to the list of bitfields $\bftwo$
in environment $\tenv$ and yields the result in $\vb$.  The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_lengths}):
  \begin{itemize}
    \item the number of bitfields in $\bfone$ is different from the number of bitfields in $\bftwo$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{same\_lengths}):
  \begin{itemize}
    \item the number of bitfields in $\bfone$ is the same as the number of bitfields in $\bftwo$;
    \item testing whether the bitfield $\bfone[i]$ is equivalent to $\bftwo[i]$ in $\tenv$ for every index
          of $\bfone$ yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if $\vb_i$ is $\True$ for every index of $\bfone$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[different\_lengths]{
  \equallength(\bfone, \bftwo) \typearrow \False
}{
  \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \False
}
\and
\inferrule[same\_lengths]{
  \equallength(\bfone, \bftwo) \typearrow \True\\
  i\in\listrange(\bfone): \bitfieldequal(\tenv, \bfone[i], \bftwo[i]) \typearrow \vb_i\\\\
  \vb \eqdef \bigwedge_{i\in\listrange(\bfone)} \vb_i
}{
  \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.BitFieldEqual \label{sec:TypingRule.BitFieldEqual}}
The function
\[
  \bitfieldequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield}{\bfone} \aslsep \overname{\bitfield}{\bftwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the bitfield $\bfone$ is equivalent to the bitfield $\bftwo$ in environment $\tenv$
and yields the result in $\vb$.  The result is a type error, if one is detected.

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item the AST labels of $\bfone$ and $\bftwo$ are different;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{bitfield\_simple}):
  \begin{itemize}
    \item $\bfone$ is a simple bitfield with name $\nameone$ and list of slices $\slicesone$, that is, \\ $\BitFieldSimple(\nameone, \slicesone)$;
    \item $\bftwo$ is a simple bitfield with name $\nametwo$ and list of slices $\slicestwo$, that is, \\ $\BitFieldSimple(\nametwo, \slicestwo)$;
    \item checking whether $\nameone$ is equal to $\nametwo$ yields $\vbone$;
    \item testing whether $\slicesone$ and $\slicestwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{bitfield\_nested}):
  \begin{itemize}
    \item $\bfone$ is a nested bitfield with name $\nameone$, list of slices $\slicesone$, and nested bitfields $\bfoneone$, that is,
          $\BitFieldNested(\nameone, \slicesone, \bfoneone)$;
    \item $\bftwo$ is a nested bitfield with name $\nametwo$, list of slices $\slicestwo$, and nested bitfields $\bftwoone$, that is,
          $\BitFieldNested(\nametwo, \slicestwo, \bftwoone)$;
    \item checking whether $\nameone$ is equal to $\nametwo$ yields $\vbone$;
    \item testing whether $\slicesone$ and $\slicestwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item testing whether the bitfields $\bfoneone$ and $\bftwoone$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{bitfield\_typed}):
  \begin{itemize}
    \item $\bfone$ is a typed bitfield with name $\nameone$, list of slices $\slicesone$, and type $\vtone$, that is,
          $\BitFieldType(\nameone, \slicesone, \vtone)$;
    \item $\bftwo$ is a typed bitfield with name $\nametwo$, list of slices $\slicestwo$, and type $\vttwo$, that is,
          $\BitFieldType(\nametwo, \slicestwo, \vttwo)$;
    \item checking whether $\nameone$ is equal to $\nametwo$ yields $\vbone$;
    \item testing whether $\slicesone$ and $\slicestwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item testing whether the types $\vtone$ and $\vttwo$ are equivalent in $\tenv$ yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\bfone) \neq \astlabel(\bftwo)
}{
  \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \False
}
\and
\inferrule[bitfield\_simple]{
  \bfone \eqname \BitFieldSimple(\nameone, \slicesone)\\
  \bftwo \eqname \BitFieldSimple(\nametwo, \slicestwo)\\
  \booltrans{\nameone = \nametwo} \booltransarrow \vbone\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\and
\inferrule[bitfield\_nested]{
  \bfone \eqname \BitFieldNested(\nameone, \slicesone, \bfoneone)\\
  \bftwo \eqname \BitFieldNested(\nametwo, \slicestwo, \bftwoone)\\
  \booltrans{\nameone = \nametwo} \booltransarrow \True \terminateas \False\\\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbone \terminateas \TypeErrorConfig,\\\\
  \bitfieldsequal(\tenv, \bfoneone, \bftwoone) \typearrow \vbtwo
}{
  \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\and
\inferrule[bitfield\_typed]{
  \bfone \eqname \BitFieldType(\nameone, \slicesone, \vtone)\\
  \bftwo \eqname \BitFieldType(\nametwo, \slicestwo, \vttwo)\\
  \booltrans{\nameone = \nametwo} \booltransarrow \True \terminateas \False \\\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbone \OrTypeError\\\\
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ConstraintsEqual \label{sec:TypingRule.ConstraintsEqual}}
\hypertarget{def-constraintsequal}{}
The function
\[
  \constraintsequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraints}{\csone} \aslsep \overname{\intconstraints}{\cstwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the constraint list $\csone$ is equivalent to the constraint list $\cstwo$ in environment $\tenv$
and yields the result in $\vb$.  The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_lengths}):
  \begin{itemize}
    \item the number of constraints in $\csone$ is different from the number of constraints in $\cstwo$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{same\_lengths}):
  \begin{itemize}
    \item the number of constraints in $\csone$ is the same as the number of constraints in $\cstwo$;
    \item testing whether the constraint $\csone[i]$ is equivalent to the constraint $\cstwo[i]$ in $\tenv$
          yields $\vb_i$ for each index in the index in the indices for $\csone$ ($i\in\listrange(\csone)$)\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if all $\vb_i$ are $\True$ for each index in the indices for $\csone$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[different\_lengths]{
  \equallength(\csone, \cstwo) \typearrow \False
}{
  \constraintsequal(\tenv, \csone, \cstwo) \typearrow \False
}
\and
\inferrule[same\_lengths]{
  \equallength(\csone, \cstwo) \typearrow \True\\
  i\in\listrange(\csone): \constraintequal(\tenv, \csone[i], \cstwo[i]) \typearrow \vb_i\\
  \vb \eqdef \bigwedge_{i\in\listrange(\csone)} \vb_i
}{
  \constraintsequal(\tenv, \csone, \cstwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ConstraintEqual \label{sec:TypingRule.ConstraintEqual}}
\hypertarget{def-constraintequal}{}
The function
\[
  \constraintequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vstwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the constraint $\vcone$ is equivalent to the constraint $\vctwo$ in environment $\tenv$
and yields the result in $\vb$.  The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item the AST labels of $\vcone$ and $\vctwo$ are different;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_exact}):
  \begin{itemize}
    \item $\vcone$ is an exact constraint with sub-expression $\veone$, that is, $\ConstraintExact(\veone)$;
    \item $\vctwo$ is an exact constraint with sub-expression $\vetwo$, that is, $\ConstraintExact(\vetwo)$;
    \item applying $\exprequal$ to $\veone$ and $\vetwo$ yields $\vb$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_range}):
  \begin{itemize}
    \item $\vcone$ is a range constraint with sub-expressions $\veoneone$ and $\veonetwo$, that is, \\ $\ConstraintRange(\veoneone, \veonetwo)$;
    \item $\vctwo$ is a range constraint with sub-expressions $\vetwoone$ and $\vetwotwo$, that is, \\ $\ConstraintRange(\vetwoone, \vetwotwo)$;
    \item applying $\exprequal$ to $\veoneone$ and $\vetwoone$ yields $\vbone$\ProseOrTypeError;
    \item applying $\exprequal$ to $\veonetwo$ and $\vetwotwo$ yields $\vbtwo$\ProseOrTypeError;
    \item define $\vb$ as $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\vcone) \neq \astlabel(\vctwo)
}{
  \constraintequal(\tenv, \vcone, \vctwo) \typearrow \False
}
\and
\inferrule[constraint\_exact]{
  \vcone \eqname \ConstraintExact(\veone)\\
  \vctwo \eqname \ConstraintExact(\vetwo)\\
  \exprequal(\tenv, \veone, \vetwo) \typearrow \vb \OrTypeError
}{
  \constraintequal(\tenv, \vcone, \vctwo) \typearrow \vb
}
\and
\inferrule[constraint\_range]{
  \bfone \eqname \ConstraintRange(\veoneone, \veonetwo)\\
  \bftwo \eqname \ConstraintRange(\vetwoone, \vetwotwo)\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \constraintequal(\tenv, \bfone, \bftwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SlicesEqual \label{sec:TypingRule.SlicesEqual}}
\hypertarget{def-slicesequal}{}
The function
\[
  \slicesequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slicesone} \aslsep \overname{\slice^*}{\slicestwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the list of slices $\slicesone$ is equivalent to the list of slices $\slicestwo$
in environment $\tenv$ and yields the result in $\vb$.  The result is a type error, if one is detected.

\subsection{Formally}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_lengths}):
  \begin{itemize}
    \item checking whether the number of slices in $\slicesone$ is equal to the number of slice in $\slicestwo$ yields $\False$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{same\_lengths}):
  \begin{itemize}
    \item checking whether the number of slices in $\slicesone$ is equal to the number of slice in $\slicestwo$ yields $\True$;
    \item determining whether the expression $\slicesone[i]$ is equivalent to $\slicestwo[i]$ in $\tenv$
          for each index in the indices for $\slicesone$ ($i \in \listrange(\slicesone$) yields $\vb_i$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if all $\vb_i$ are $\True$ for each index in the indices for $\slicesone$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[different\_lengths]{
  \equallength(\slicesone, \slicestwo) \typearrow \False
}{
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \False
}
\and
\inferrule[same\_lengths]{
  \equallength(\slicesone, \slicestwo) \typearrow \True\\
  i\in\listrange(\slicesone): \sliceequal(\tenv, \slicesone[i], \slicestwo[i]) \typearrow \vb_i \OrTypeError\\\\
  \vb \eqdef \bigwedge_{i\in\listrange(\slicesone)} \vb_i
}{
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SliceEqual \label{sec:TypingRule.SliceEqual}}
\hypertarget{def-sliceequal}{}
The function
\[
  \sliceequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\sliceone} \aslsep \overname{\slice}{\slicetwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
conservatively tests whether the slice $\sliceone$ is equivalent to the slice $\slicetwo$
in environment $\tenv$ and yields the result in $\vb$. The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item $\sliceone$ and $\slicetwo$ have different AST labels;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{slice\_single}):
  \begin{itemize}
    \item $\sliceone$ is a slice for a single position, given by the expression $\veone$, that is, $\SliceSingle(\veone)$;
    \item $\slicetwo$ is a slice for a single position, given by the expression $\vetwo$, that is, $\SliceSingle(\vetwo)$;
    \item testing $\veone$ and $\vetwo$ for equivalence yields $\vb$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{slice\_range}):
  \begin{itemize}
    \item $\sliceone$ is a slice for a range of positions, given by the expressions $\veoneone$ and $\veonetwo$, that is, $\SliceRange(\veoneone, \veonetwo)$;
    \item $\slicetwo$ is a slice for a range of positions, given by the expressions $\vetwoone$ and $\vetwotwo$, that is, $\SliceRange(\vetwoone, \vetwotwo)$;
    \item testing $\veoneone$ and $\vetwoone$ for equivalence yields $\vbone$\ProseOrTypeError;
    \item testing $\veonetwo$ and $\vetwotwo$ for equivalence yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{slice\_length}):
  \begin{itemize}
    \item $\sliceone$ is a slice for a range of positions, given by the start expression $\veoneone$ and length expression $\veonetwo$, that is, $\SliceLength(\veoneone, \veonetwo)$;
    \item $\slicetwo$ is a slice for a range of positions, given by the start expression $\vetwoone$ and length expression $\vetwotwo$, that is, $\SliceLength(\vetwoone, \vetwotwo)$;
    \item testing $\veoneone$ and $\vetwoone$ for equivalence yields $\vbone$\ProseOrTypeError;
    \item testing $\veonetwo$ and $\vetwotwo$ for equivalence yields $\vbtwo$\ProseOrTypeError;
    \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[different\_label]{
  \astlabel(\sliceone) \neq \astlabel(\slicetwo)
}{
  \slicesequal(\tenv, \sliceone, \slicetwo) \typearrow \False
}
\and
\inferrule[slice\_single]{
  \exprequal(\tenv, \veone, \vetwo) \typearrow \vb \OrTypeError
}{
  \slicesequal(\tenv, \SliceSingle(\veone), \SliceSingle(\vetwo)) \typearrow \vb
}
\and
\inferrule[slice\_range]{
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \vetwoone, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \slicesequal(\tenv, \SliceRange(\veoneone, \veonetwo), \SliceRange(\vetwoone, \vetwotwo)) \typearrow \vb
}
\and
\inferrule[slice\_length]{
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone \OrTypeError\\\\
  \exprequal(\tenv, \vetwoone, \vetwotwo) \typearrow \vbtwo \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \slicesequal(\tenv, \SliceLength(\veoneone, \veonetwo), \SliceLength(\vetwoone, \vetwotwo)) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ArrayLengthEqual \label{sec:TypingRule.ArrayLengthEqual}}
\hypertarget{def-arraylengthequal}{}
The function
\[
  \arraylengthequal(\overname{\arrayindex}{\vlone} \aslsep \overname{\arrayindex}{\vltwo})
  \aslto \overname{\{\True, \False\}}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the array lengths $\vlone$ and $\vltwo$ are equivalent and yields the result
in $\vb$. The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
    \item $\vlone$ and $\vltwo$ have different AST labels;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{expr\_expr}):
  \begin{itemize}
    \item $\vlone$ is an integer type length expression with sub-expression $\veoneone$, that is, $\ArrayLengthExpr(\veoneone)$;
    \item $\vltwo$ is an integer type length expression with sub-expression $\vetwoone$, that is, $\ArrayLengthExpr(\vetwoone)$;
    \item testing whether $\veoneone$ and $\vetwoone$ are equivalent in $\tenv$ yields $\vb$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{enum\_enum}):
  \begin{itemize}
    \item $\vlone$ is an enumeration type length expression over the enumeration $\vsone$, that is, $\ArrayLengthEnum(\vsone, \Ignore)$;
    \item $\vltwo$ is an enumeration type length expression over the enumeration $\vstwo$, that is, $\ArrayLengthEnum(\vstwo, \Ignore)$;
    \item $\vb$ is $\True$ if and only if $\vsone$ is equal to $\vstwo$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[different\_labels]{
  \astlabel(\vlone) \neq \astlabel(\vltwo)
}{
  \arraylengthequal(\vlone, \vltwo) \typearrow \False
}
\and
  \inferrule[expr\_expr]{
  \exprequal(\veoneone, \vetwoone) \typearrow \vb \OrTypeError
}{
  \arraylengthequal(\ArrayLengthExpr(\veoneone), \ArrayLengthExpr(\vetwoone)) \typearrow \vb
}
\and
\inferrule[enum\_enum]{
  \vb \eqdef \vsone = \vstwo
}{
  \arraylengthequal(\ArrayLengthEnum(\vsone, \Ignore), \ArrayLengthEnum(\vstwo, \Ignore)) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.LiteralEqual \label{sec:TypingRule.LiteralEqual}}
\hypertarget{def-literalequal}{}
The function
\[
  \literalequal(\overname{\literal}{\vvone} \aslsep \overname{\literal}{\vvtwo}) \rightarrow \overname{\{\True, \False\}}{\vb}
\]
tests whether literal $\vvone$ is $\vvtwo$ by equating them.

\subsection{Prose}
$\vb$ is $\True$ if and only if $\vvone$ is equal to $\vvtwo$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef \vvone = \vvtwo
}{
  \literalequal(\vvone, \vvtwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ReduceIR \label{sec:TypingRule.ReduceIR}}
\hypertarget{def-reduceir}{}
The function
\[
\reduceir(\overname{\polynomial}{\vp}) \aslto \overname{\polynomial}{\newp}
\]
simplifies the polynomial $\vp$, yielding the simplified polynomial $\newp$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vp$ is $\Sum(f)$ where $f$ binds monomials to their integer coefficients;
  \item $g$ is the restriction of $f$ to the bindings where the coefficients are non-zero;
  \item $\newp$ is $\Sum(g)$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  { g \eqdef \restrictfunc{f}{\{\vm \in \dom(f)\;|\; f(\vm) \neq 0\}} }
}{
  \reduceir(\overname{\Sum(f)}{\vp}) \typearrow \overname{\Sum(g)}{\newp}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.PolynomialToExpr \label{sec:TypingRule.PolynomialToExpr}}
\hypertarget{def-polynomialtoexpr}{}
The function
\[
\polynomialtoexpr(\overname{\polynomial}{\vp}) \typearrow \overname{\expr}{\ve}
\]
transforms a polynomial $\vp$ to the corresponding expression $\ve$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\vp$ is the polynomial with an empty list of monomials, that is, $\Sum(\emptyfunc)$;
    \item define $\ve$ as the literal expression for $0$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\vp$ is the polynomial $\Sum(f)$;
    \item sorting (see $\sort$ for details) the graph of $f$ (see $\funcgraph$ for details)
          yields $\monoms$ --- a list consisting of pairs of unitary monomials and rationals.
          In principle, any total order of the graph of $f$ is acceptable for sorting.
          The function $\comparemonomialbindings$ provides one such way of ordering
          the graph of $f$;
    \item transforming $\monoms$ to an expression and sign via $\monomialstoexpr$ yields the expression $\veone$
          and sign $\vsone$;
    \item define $\ve$ as $\veone$ if $\vs$ is either $0$ or $1$ and the unary expression negating $\veone$, that is,
          $\EUnop(\NEG, \veone)$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \polynomialtoexpr(\overname{\Sum(\emptyfunc)}{\vp}) \typearrow \overname{\ELiteral(\lint(0))}{\ve}
}
\and
\inferrule[non\_empty]{
  \sort(\funcgraph(f), \comparemonomialbindings) = \monoms\\
  \monomialstoexpr(\monoms) \typearrow (\veone, \vsone)\\
  {
  \ve \eqdef \begin{cases}
    \veone                & \text{if }\vsone = 0\\
    \veone                & \text{if }\vsone = 1\\
    \EUnop(\NEG, \veone)  & \text{if }\vsone = -1
  \end{cases}
  }
}{
  \polynomialtoexpr(\overname{\Sum(f)}{\vp}) \typearrow \ve
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.CompareMonomialBindings \label{sec:TypingRule.CompareMonomialBindings}}
\hypertarget{def-comparemonomialbindings}{}
The function
\[
\comparemonomialbindings(
  (\overname{\monomial}{\vmone}\times\overname{\Q}{\vqone}) \aslsep
  (\overname{\monomial}{\vmtwo}\times\overname{\Q}{\vqtwo})
) \aslto \overname{\{-1,0,1\}}{\vs}
\]
compares two monomial bindings given by $(\vmone, \vqone)$ and $(\vmtwo, \vqtwo)$
and yields in $\vs$ $-1$ to mean that the first monomial binding should be ordered before the second,
$0$ to mean that any ordering of the monomial bindings is acceptable,
and $1$ to mean that the second monomial binding should be ordered before the first.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{equal\_monomials}):
  \begin{itemize}
    \item $\vmone$ is $\Prod(f)$ and $\vmtwo$ is $\Prod(g)$;
    \item $f$ is equal to $g$;
    \item $\vs$ is the sign of $\vqtwo - \vqone$.
  \end{itemize}

  \item All of the following apply (\textsc{different\_monomials}):
  \begin{itemize}
    \item $\vmone$ is $\Prod(f)$ and $\vmtwo$ is $\Prod(g)$;
    \item $f$ is different from to $g$;
    \item $\ids$ is the list obtained by taking the set of identifiers in the domain of $f$ and in the domain of $g$,
          and sorting them according to the lexical order for identifiers (ASCII string order);
    \item $\vv$ is the first identifier in $\ids$ for which $f$ and $g$ behave differently (either one of them is defined
          for $vv$ and the other is not, or they both bind $\vv$ to a different value);
    \item $s$ is determined as follows: $1$ if $\vv$ is not in the domain of $f$ and is in the domain of $g$;
          $-1$ if $\vv$ is not in the domain of $f$ and is in the domain of $g$;
          otherwise it is the sign of $g(\vv)-f(\vv)$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\hypertarget{def-compareidentifier}{}
The function $\compareidentifier$ compares two identifiers, which are lists of ASCII characters,
via the lexicographic ordering.

\begin{mathpar}
\inferrule[equal\_monomials]{
  f = g\\
  \vs \eqdef \sign(\vqtwo - \vqone)
}{
  \comparemonomialbindings((\overname{\Prod(f)}{\vmone}, \vqone), (\overname{\Prod(g)}{\vmtwo}, \vqtwo)) \typearrow \vs
}
\and
\inferrule[different\_monomials]{
  f \neq g\\
  \ids \eqdef \sort(\dom(f) \cup \dom(g), \compareidentifier)\\
  \ids \eqname \idsone \concat \idstwo\\
  \vi\in\listrange(\idsone): f(\idsone[\vi]) = g(\idsone[\vi])\\
  \vv \eqdef \idstwo[1]\\
  \vs \eqdef {
    \begin{cases}
    1 & f(\vv) = \bot \land g(\vv) \neq \bot\\
    -1  & f(\vv) \neq \bot \land g(\vv) = \bot\\
    \sign(g(\vv) - f(\vv))  & f(\vv) \neq \bot \land g(\vv) \neq \bot\\
    \end{cases}
}
}{
  \comparemonomialbindings((\overname{\Prod(f)}{\vmone}, \vqone), (\overname{\Prod(g)}{\vmtwo}, \vqtwo)) \typearrow \vs
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.MonomialsToExpr \label{sec:TypingRule.MonomialsToExpr}}
\hypertarget{def-monomialstoexpr}{}
The function
\[
\monomialstoexpr(\overname{(\overname{\unitarymonomial}{\vm}\times\overname{\Q}{q})^*}{\monoms}) \aslto
(\overname{\expr}{\ve},\overname{\{-1,0,1\}}{\vs})
\]
transforms a list consisting of pairs of unitary monomials and rational factors $\monoms$ (so, general monomials),
to an expression $\ve$, which represents the absolute value of the sum of all the monomials,
and a sign value $\vs$, which indicates the sign of the resulting sum.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\monoms$ is an empty list;
    \item $\ve$ is the literal expression for the integer $0$ and $\vs$ is $0$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\monoms$ is a list with $(\vm,q)$ as its head and $\monomsone$ as its tail;
    \item transforming the unitary monomial $\vm$ to an expression via \\ $\unitarymonomialstoexpr$ yields $\veonep$;
    \item transforming $\veonep$ and $q$ via $\monomialtoexpr$ yields the expression $\veone$ and sign $\vsone$;
    \item transforming $\monoms$ to an expression and sign via $\monomialstoexpr$ yields $(\vetwo, \vstwo)$;
    \item symbolically adding $\veone, \vsone, \vetwo, \vstwo$ via $\symaddexpr$ yields $\ve$;
    \item $\vs$ is $\vsone$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \monomialstoexpr(\overname{\emptylist}{\monoms}) \typearrow (\overname{\ELiteral(\lint(0))}{\ve}, \overname{0}{s})
}
\and
\inferrule[non\_empty]{
  \unitarymonomialstoexpr(\vm) \typearrow \veonep\\
  \monomialtoexpr(\veonep, q) \typearrow (\veone,\vsone)\\
  \monomialstoexpr(\monoms) \typearrow (\vetwo, \vstwo)\\
  \symaddexpr(\veone, \vsone, \vetwo, \vstwo) \typearrow \ve
}{
  \monomialstoexpr(\overname{[(\vm,q)] \concat \monomsone}{\monoms}) \typearrow (\ve, \overname{\vsone}{\vs})
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.MonomialToExpr \label{sec:TypingRule.MonomialToExpr}}
\hypertarget{def-monomialtoexpr}{}
The function
\[
\monomialtoexpr(\overname{\expr}{\ve} \aslsep \overname{\Q}{q})
\aslto (\overname{\expr}{\newe} \times \overname{\{-1,0,1\}}{\vs})
\]
transforms an expression $\ve$ and rational $q$ into the expression $\newe$,
which represents the absolute value of $\ve$ multiplied by $q$, and the sign of $q$ as $\vs$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{q\_zero}):
  \begin{itemize}
    \item $q$ is $0$;
    \item $\newe$ is the literal expression for $0$;
    \item $\vs$ is $0$.
  \end{itemize}

  \item All of the following apply (\textsc{q\_natural}):
  \begin{itemize}
    \item $q$ a strictly positive;
    \item symbolically multiplying the literal expression for $q$ and $\ve$ via $\symmulexpr$ yields $\newe$;
    \item $\vs$ is $1$.
  \end{itemize}

  \item All of the following apply (\textsc{q\_positive\_fraction}):
  \begin{itemize}
    \item $q$ a strictly positive fraction, that is, not an integer;
    \item the reduced representation of the fraction $q$ is $\frac{d}{n}$;
    \item symbolically multiplying the literal expression for $q$ and $\ve$ via $\symmulexpr$ yields $\vetwo$;
    \item $\ve$ is the binary expression with operator $\DIV$ and operands $\vetwo$ and the literal expression for $n$;
    \item $\vs$ is $1$.
  \end{itemize}

  \item All of the following apply (\textsc{q\_negative}):
  \begin{itemize}
    \item $q$ a strictly negative;
    \item transforming $\ve$ with $-q$ to an expression and a sign via $\monomialtoexpr$ yields $(\newe, 1)$;
    \item $\vs$ is $-1$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
\inferrule[q\_zero]{
  q = 0\\
}{
  \monomialtoexpr(\ve, q) \typearrow (\overname{\ELiteral(\lint(0))}{\newe}, \overname{0}{\vs})
}
\and
\inferrule[q\_natural]{
  q > 0\\
  q \in \N\\
  \symmulexpr(\ELiteral(\lint(q)), \ve) \typearrow \newe
}{
  \monomialtoexpr(\ve, q) \typearrow (\newe, \overname{1}{\vs})
}
\and
\inferrule[q\_positive\_fraction]{
  q > 0\\
  q \not\in \N\\\\
  q \eqname \frac{d}{n} \;\;\;\;\text{ is the reduced fraction for }q\\\\
  \symmulexpr(\ELiteral(\lint(d)), \ve) \typearrow \vetwo\\
  \newe \eqdef \EBinop(\DIV, \vetwo, \ELiteral(\lint(n)))
}{
  \monomialtoexpr(\ve, q) \typearrow (\newe, \overname{1}{\vs})
}
\and
\inferrule[q\_negative]{
  q < 0\\
  \monomialtoexpr(\ve, -q) \typearrow (\newe, 1)
}{
  \monomialtoexpr(\ve, q) \typearrow (\newe, \overname{-1}{\vs})
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SymAddExpr \label{sec:TypingRule.SymAddExpr}}
\hypertarget{def-symaddexpr}{}
The function
\[
\symaddexpr(
  \overname{\expr}{\veone} \aslsep
  \overname{\{-1,0,1\}}{\vsone} \aslsep
  \overname{\expr}{\vetwo} \aslsep
  \overname{\{-1,0,1\}}{\vstwo}
  )
  \typearrow \overname{\expr}{\ve}
\]
symbolically sums the expressions $\veone$ and $\vetwo$
with respective signs $\vsone$ and $\vstwo$
yielding the expression $\ve$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{zero}):
  \begin{itemize}
    \item either $\vsone$ or $\vstwo$ are $0$;
    \item $\ve$ is $\veone$ if $\vstwo$ is $0$ and $\veone$, otherwise.
  \end{itemize}

  \item All of the following apply (\textsc{same\_sign}):
  \begin{itemize}
    \item both $\vsone$ and $\vstwo$ are not $0$;
    \item $\vsone$ is equal to $\vstwo$;
    \item $\ve$ is the binary expression with operator $\PLUS$ and operands $\veone$ and $\vetwo$,
          that is, $\EBinop(\PLUS, \veone, \vetwo)$.
  \end{itemize}

  \item All of the following apply (\textsc{same\_sign}):
  \begin{itemize}
    \item both $\vsone$ and $\vstwo$ are not $0$;
    \item $\vsone$ is different from $\vstwo$;
    \item $\ve$ is the binary expression with operator $\MINUS$ and operands $\veone$ and $\vetwo$,
          that is, $\EBinop(\MINUS, \veone, \vetwo)$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[zero]{
  (\vsone = 0 \lor \vstwo = 0)\\
  \ve \eqdef \choice{\vsone = 0}{(\vetwo, \vstwo)}{\veone}
}{
  \symaddexpr(\veone, \vsone, \vetwo, \vstwo) \typearrow \ve
}
\and
\inferrule[same\_sign]{
  \vsone \neq 0 \land \vstwo \neq 0\\
  \vsone = \vstwo
}{
  \symaddexpr(\veone, \vetwo) \typearrow \overname{\EBinop(\PLUS, \veone, \vetwo)}{\ve}
}
\and
\inferrule[differnt\_sign]{
  \vsone \neq 0 \land \vstwo \neq 0\\
  \vsone \neq \vstwo
}{
  \symaddexpr(\veone, \vetwo) \typearrow \overname{\EBinop(\MINUS, \veone, \vetwo)}{\ve}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.UnitaryMonomialsToExpr \label{sec:TypingRule.UnitaryMonomialsToExpr}}
\hypertarget{def-unitarymonomialstoexpr}{}
The function
\[
\unitarymonomialstoexpr(\overname{(\identifier\times\N)^*}{\monoms}) \aslto \overname{\expr}{\ve}
\]
transforms a list of single-variable unitary monomials $\monoms$ to an expression $\ve$.
Intuitively, $\monoms$ represented a multiplication of the single-variable unitary monomials.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\monoms$ is the empty list;
    \item $\ve$ is the literal expression for $1$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_zero}):
  \begin{itemize}
    \item $\monoms$ is a list where the first element is $(\vv, 0)$ and its tail is $\monoms$;
    \item transforming $\monomsone$ to an expression yields $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_one}):
  \begin{itemize}
    \item $\monoms$ is a list where the first element is $(\vv, 1)$ and its tail is $\monoms$;
    \item $\veone$ is the variable expression for $\vv$;
    \item transforming $\monomsone$ to an expression yields $\vetwo$;
    \item symbolically multiplying $\veone$ and $\vetwo$ via $\symmulexpr$ yields $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_two}):
  \begin{itemize}
    \item $\monoms$ is a list where the first element is $(\vv, 2)$ and its tail is $\monoms$;
    \item $\veone$ is the binary expression with operator $\MUL$ and operands $\EVar(x)$ and $\EVar(x)$;
    \item transforming $\monomsone$ to an expression yields $\vetwo$;
    \item symbolically multiplying $\veone$ and $\vetwo$ via $\symmulexpr$ yields $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{exp\_gt\_two}):
  \begin{itemize}
    \item $\monoms$ is a list where the first element is $(\vv, n)$ and its tail is $\monoms$;
    \item $n$ is greater than $1$;
    \item $\veone$ is the binary expression with operator $\POW$ and base operand being the variable expression for $\vv$
          and the exponent operand being the variable expression for $n$;
    \item transforming $\monomsone$ to an expression yields $\vetwo$;
    \item symbolically multiplying $\veone$ and $\vetwo$ via $\symmulexpr$ yields $\ve$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \unitarymonomialstoexpr(\overname{\emptylist}{\monoms}) \typearrow \overname{\ELiteral(\lint(1))}{\ve}
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_zero]{
  \unitarymonomialstoexpr(\monomsone) \typearrow \ve
}{
  \unitarymonomialstoexpr(\overname{[(\vv, 0)] \concat \monomsone}{\monoms}) \typearrow \ve
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_one]{
  \veone \eqdef \EVar(\vv)\\
  \unitarymonomialstoexpr(\monomsone) \typearrow \vetwo\\
  \symmulexpr(\veone, \vetwo) \typearrow \ve
}{
  \unitarymonomialstoexpr(\overname{[(\vv, 1)] \concat \monomsone}{\monoms}) \typearrow \ve
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_two]{
  \veone \eqdef \EBinop(\MUL, \EVar(\vv), \EVar(n))\\
  \unitarymonomialstoexpr(\monomsone) \typearrow \vetwo\\
  \symmulexpr(\veone, \vetwo) \typearrow \ve
}{
  \unitarymonomialstoexpr(\overname{[(\vv, 2)] \concat \monomsone}{\monoms}) \typearrow \ve
}
\end{mathpar}

\begin{mathpar}
\inferrule[exp\_gt\_two]{
  n \geq 2\\
  \veone \eqdef \EBinop(\POW, \EVar(\vv), \ELiteral(n))\\
  \unitarymonomialstoexpr(\monomsone) \typearrow \vetwo\\
  \symmulexpr(\veone, \vetwo) \typearrow \ve
}{
  \unitarymonomialstoexpr(\overname{[(\vv, n)] \concat \monomsone}{\monoms}) \typearrow \ve
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SymMulExpr \label{sec:TypingRule.SymMulExpr}}
\hypertarget{def-symmulexpr}{}
The function
$
\symmulexpr(\overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo}) \typearrow \overname{\expr}{\ve}
$
produces an expression representing the multiplication of expressions $\veone$ and $\vetwo$,
simplifying away the case where one of the operands is the literal one.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{one\_operand}):
  \begin{itemize}
    \item either $\veone$ or $\vetwo$ is the literal expression for $1$;
    \item $\ve$ is $\vetwo$ if $\veone$ is the literal expression for $1$ and $\veone$, otherwise.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[one\_operand]{
  (\veone = \ELiteral(\lint(1)) \lor \vetwo = \ELiteral(\lint(1)))\\
  \ve \eqdef \choice{\veone = \ELiteral(\lint(1))}{\vetwo}{\veone}
}{
  \symmulexpr(\EBinop(\MUL, \veone, \vetwo)) \typearrow \ve
}
\and
\inferrule[no\_one\_operand]{
  (\veone \neq \ELiteral(\lint(1)) \land \vetwo \neq \ELiteral(\lint(1)))\\
  \ve \eqdef \EBinop(\MUL, \veone, \vetwo)
}{
  \symmulexpr(\EBinop(\MUL, \veone, \vetwo)) \typearrow \ve
}
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Utility Rules}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Checked Transitions}
\hypertarget{def-checktrans}{}
We define the following rules to allow us asserting that a condition holds,
returning a type error otherwise:
\begin{mathpar}
  \inferrule[check\_trans\_true]{}{ \checktrans{\True}{<message>} \checktransarrow \True }
  \and
  \inferrule[check\_trans\_false]{}{ \checktrans{\False}{<message>} \checktransarrow \TypeErrorVal{\texttt{<message>}} }
\end{mathpar}

\hypertarget{def-pairstomap}{}
\section{Converting a List of Pairs to a Map \label{sec:PairsToMap}}
The parametric function
\[
  \pairstomap(\overname{(\identifier\times T)^*}{\pairs}) \aslto \overname{(\identifier\partialto T)}{f} \cup \TTypeError
\]
converts a list of pairs --- $\pairs$ --- where each pair consists of an identifier and a value
of type $T$ into a function mapping each identifier to its respective value in the list.
If a duplicate identifier exists in $\pairs$ then a type error is returned.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\pairs$ is empty;
    \item $f$ is the empty function.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item there exist two different positions in the list where the identifier is the same;
    \item the result is a type error indicating the existence of a duplicate identifier.
  \end{itemize}

  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item all identifiers occurring in the list are unique;
    \item $f$ is a function that associates to each identifier the value appearing with it in $\pairs$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
\inferrule[empty]{}{ \pairstomap(\emptylist) \typearrow \emptyfunc }
\and
\inferrule[error]{
  i,j \in 1..k\\
  i \neq j\\
  \id_i = \id_j
}
{
  \pairstomap([i=1..k: (\id_i,t_i)]) \typearrow \TypeErrorVal{DuplicateIdentifier}
}
\and
\inferrule[okay]{
  \forall i,j \in 1..k. \id_i \neq \id_j\\
  {
  f \eqdef \lambda \id.\ \begin{cases}
    t_i & \text{ if }i\in1..k \land \id = \id_i\\
    \bot & \text{ otherwise}
  \end{cases}
  }
}
{
  \pairstomap([i=1..k: (\id_i,t_i)]) \typearrow f
}
\end{mathpar}
\end{emptyformal}

\hypertarget{def-checknoduplicates}{}
\section{TypingRule.CheckNoDuplicates \label{sec:TypingRule.CheckNoDuplicates}}
The function
\[
  \checknoduplicates(\overname{\identifier^*}{\id_{1..k}}) \aslto \True \cup \TTypeError
\]
checks whether a non-empty list of identifiers contains a duplicate identifier. If it does not, the result
is $\True$ and otherwise the result is a type error.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item the set containing all identifiers in the list has the same cardinality as the length of the list;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item there exist two different positions in the list where the identifier is the same;
    \item the result is a type error indicating the existence of a duplicate identifier.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
  \inferrule[okay]{
    \cardinality{\{\id_{1..k}\}} = k
  }
  {
    \checknoduplicates(\id_{1..k}) \typearrow \True
  }
\and
\inferrule[error]{
  i,j \in 1..k\\
  i \neq j\\
  \id_i = \id_j
}
{
  \checknoduplicates(\id_{1..k}) \typearrow \TypeErrorVal{DuplicateIdentifier}
}
\end{mathpar}
\end{emptyformal}

\hypertarget{def-annotatefieldinit}{}
\section{Annotating Field Initializers}
The function
\[
  \annotatefieldinit(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\identifier\times\expr)}{(\name, \vep)} \aslsep
    \overname{\field^*}{\fieldtypes}
  ) \aslto
  \overname{(\identifier\times\expr)}{(\name, \vepp)}
\]
annotates a field initializers $(\name, \vep)$ in a record expression
with list of fields \\ $\fieldtypes$ and returns the annotated field initializer
$(\name, \vepp)$. A type error is returned, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vtp, \vepp)$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{okay}):
    \begin{itemize}
      \item the unique type associated with $\name$ in $\fieldtypes$ is $\tspecp$;
      \item determining whether $\vtp$ \typesatisfies\ $\tspecp$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \end{itemize}

    \item All of the following apply (\textsc{error}):
    \begin{itemize}
      \item there is no type associated with $\name$ in $\fieldtypes$;
      \item the result is a type error indicating that the field $\name$ does not exist.
    \end{itemize}
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \annotateexpr{\tenv, \vep} \typearrow (\vtp, \vepp) \OrTypeError\\\\
  \fieldtype(\fieldtypes, \name) = \tspecp\\
  \checktypesat(\tenv, \vtp, \tspecp) \typearrow \True \OrTypeError
}{
  \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow (\name, \vepp)
}
\and
\inferrule[error]{
  \annotateexpr{\tenv, \vep} \typearrow (\vtp, \vepp) \OrTypeError\\\\
  \fieldtype(\fieldtypes, \name) = \bot
}{
  \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow \\
  \TypeErrorVal{FieldDoesNotExist}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.BitFieldGetName \label{sec:TypingRule.BitFieldGetName}}
\hypertarget{def-bitfieldgetname}{}
The function
\[
  \bitfieldgetname : \overname{\bitfield}{\vbf} \aslto \overname{\identifier}{\name}
\]
returns the name of a bitfield --- $\name$, given a bitfield $\vbf$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item $\vb$ is a simple bitfield with name $\name$, that is, $\BitFieldSimple(\name, \Ignore)$;
  \item $\vb$ is a nested bitfield with name $\name$, that is, $\BitFieldNested(\name, \Ignore, \Ignore)$;
  \item $\vb$ is a typed bitfield with name $\name$, that is, $\BitFieldType(\name, \Ignore, \Ignore)$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[simple]{}{
    \bitfieldgetname(\BitFieldSimple(\name, \Ignore)) \typearrow \name
  }
  \and
  \inferrule[nested]{}{
    \bitfieldgetname(\BitFieldNested(\name, \Ignore, \Ignore)) \typearrow \name
  }
  \and
  \inferrule[type]{}{
    \bitfieldgetname(\BitFieldType(\name, \Ignore, \Ignore)) \typearrow \name
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.CheckVarNotInGEnv}
\hypertarget{def-checkvarnotingenv}{}
The function
\[
  \checkvarnotingenv{\overname{\staticenvs}{\tenv} \aslsep \overname{\Strings}{\id}}
  \aslto \True \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether $\id$ is already declared in the global environment of $\tenv$.
If it is, the result is a type error, and otherwise the result is $\True$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vb$ is $\True$ if and only if one of the following applies:
  \begin{itemize}
    \item $\id$ is declared as a global identifier in $\tenv$;
    \item $\id$ is declared as a subprogram in $\tenv$;
    \item $\id$ is declared as a type in $\tenv$.
  \end{itemize}

  \item checking whether $\vb$ is $\False$ yields $\True$ or a type error indicating
        that $\id$ has already been declared, thereby short-circuiting the rule.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
{
  \begin{array}{rl}
  \vb \eqdef  & G^\tenv.\globalstoragetypes(\id) \neq \bot \lor\\
              & G^\tenv.\subprograms(\id) \neq \bot\ \lor\\
              & G^\tenv.\declaredtypes(\id) \neq \bot
  \end{array}
}\\
\checktrans{\neg\vb}{IdentifierAlreadyDeclared} \checktransarrow \True \OrTypeError
}{
  \checkvarnotingenv{\tenv, \id} \typearrow \True
}
\end{mathpar}
\end{emptyformal}

\hypertarget{def-checkvarnotinenv}{}
\hypertarget{def-varinenv}{}
\section{TypingRule.CheckVarNotInEnv}
The function
\[
  \varinenv{\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\id}}
  \aslto \overname{\Bool}{\vb}
\]
determines whether an identifier $\id$ is declared in the static environment $\tenv$.

The function
\[
  \checkvarnotinenv{\overname{\staticenvs}{\tenv} \aslsep \overname{\Strings}{\id}}
  \aslto \True \cup \TTypeError
\]
checks whether $\id$ is already declared in $\tenv$. If it is, the result is a type error,
and otherwise the result is $\True$.

\subsection{Prose}
$\varinenv{\tenv, \id}$ is true if and only if one of the following applies:
\begin{itemize}
  \item $\id$ is declared as a local identifier in $\tenv$;
  \item $\id$ is declared as a global identifier in $\tenv$;
  \item $\id$ is declared as a subprogram in $\tenv$;
  \item $\id$ is declared as a type in $\tenv$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \begin{array}{rl}
  \vb \eqdef & L^\tenv.\localstoragetypes(\id) \neq \bot\ \lor\\
             & G^\tenv.\globalstoragetypes(\id) \neq \bot \lor\\
             & G^\tenv.\subprograms(\id) \neq \bot\ \lor\\
             & G^\tenv.\declaredtypes(\id) \neq \bot
  \end{array}
}
}{
  \varinenv{\tenv, \id} \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[okay]{
  \varinenv{\tenv, \id} \typearrow \False
}{
  \checkvarnotinenv{\tenv, \id} \typearrow \True
}
\and
  \inferrule[error]{
  \varinenv{\tenv, \id} \typearrow \True
}{
  \checkvarnotinenv{\tenv, \id} \typearrow \TypeErrorVal{AlreadyDeclared}
}
\end{mathpar}
\end{emptyformal}

\hypertarget{def-addlocal}{}
\section{TypingRule.AddLocal \label{sec:TypingRule.AddLocal}}
The function
\[
  \addlocal(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\id} \aslsep
    \overname{\ty}{\tty} \aslsep
    \overname{\localdeclkeyword}{\ldk})
  \aslto
  \overname{\staticenvs}{\newtenv}
\]
adds the identifier $\id$ as a local storage element with type $\tty$ and local declaration keyword $\ldk$
to the local environment of $\tenv$, resulting in the static environment $\newtenv$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the map $\newlocalstoragetypes$ is defined by updating the map \\
        $\localstoragetypes$ of $\tenv$
        with the binding $\id$ to the type $\tty$ and local declaration keyword $\ldk$, that is, $(\tty,\ldk)$;
  \item $\newtenv$ is defined by updating the local environment with the binding of \\
        $\localstoragetypes$ to $\newlocalstoragetypes$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \newlocalstoragetypes \eqdef L^\tenv.\localstoragetypes[\id \mapsto (\tty, \ldk)]\\
  \newtenv \eqdef (G^\tenv, L^\tenv[\localstoragetypes \mapsto \newlocalstoragetypes])
}
{
  \addlocal(\tenv, \id, \tty, \ldk) \typearrow \newtenv
}
\end{mathpar}
\end{emptyformal}

\hypertarget{def-declaredtype}{}
\section{TypingRule.DeclaredType \label{sec:TypingRule.DeclaredType}}

The function
\[
  \declaredtype(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\id}) \aslto \overname{\ty}{\vt} \cup \TTypeError
\]
retrieves the type associated with the identifier $\id$ in the static environment $\tenv$.
If the identifier is not associated with a declared type, a type error is returned.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exists}):
  \begin{itemize}
    \item $\id$ is bound in the global environment to the type $\vt$.
  \end{itemize}

  \item All of the following apply (\textsc{type\_not\_declared}):
  \begin{itemize}
    \item $\id$ is not bound in the global environment to any type;
    \item the result is a type error indicating the lack of a type declaration for $\id$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[exists]{
  G^\tenv.\declaredtypes(\id) = \vt
}
{
  \declaredtype(\tenv, \id) \typearrow \vt
}
\and
\inferrule[type\_not\_declared]{
  G^\tenv.\declaredtypes(\id) = \bot
}
{
  \declaredtype(\tenv, \id) \typearrow \TypeErrorVal{TypeNotDeclared}
}
\end{mathpar}

\section{TypingRule.FindBitfieldOpt}
\hypertarget{def-findbitfieldopt}{}
The function
\[
  \findbitfieldopt(\overname{\identifier}{\name} \aslsep \overname{\bitfield^*}{\bitfields})
  \aslto \overname{\langle\bitfield\rangle}{\vr}
\]
returns the bitfield associated with the name $\name$ in the list of bitfields $\bitfields$,
if there is one. Otherwise, the result is $\None$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{match}):
  \begin{itemize}
    \item $\bitfields$ starts with a bitfield $\vbf$;
    \item obtaining the name associated with $\vbf$ yields $\name$;
    \item the result if $\vbf$.
  \end{itemize}

  \item All of the following apply (\textsc{tail}):
  \begin{itemize}
    \item $\bitfields$ starts with a bitfield $\vbf$ and continues with the tail list $\bitfieldsp$;
    \item obtaining the name associated with $\vbf$ yields $\namep$, which is different than $\name$;
    \item finding the bitfield associated with $\name$ in $\bitfieldsp$ yields the result $\vr$.
  \end{itemize}

  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\bitfields$ is an empty list;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
\inferrule[match]{
  \bitfieldgetname(\vbf) \typearrow \name
}{
  \findbitfieldopt(\name, \overname{\vbf + \bitfieldsp}{\bitfields}) \typearrow \overname{\langle\vbf\rangle}{\vr}
}
\and
\inferrule[tail]{
  \bitfieldgetname(\vbf) \typearrow \namep\\
  \name \neq \namep\\
  \findbitfieldopt(\name, \bitfieldsp) \typearrow \vr
}{
  \findbitfieldopt(\name, \overname{\vbf + \bitfieldsp}{\bitfields}) \typearrow \vr
}
\and
\inferrule[empty]{}{
  \findbitfieldopt(\name, \overname{\emptylist}{\bitfields}) \typearrow \None
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.MemBfs}
\hypertarget{def-membfs}{}
The function
\[
  \membfs(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield^+}{\bfstwo} \aslsep \overname{\bitfield}{\vbfone})
  \aslto \overname{\Bool}{\vb}
\]
checks whether the bitfield $\vbf$ exists in $\bfstwo$ in the context of $\tenv$, returning the result in $\vb$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\None$;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{simple\_any}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{nested\_simple}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{nested\_nested}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a nested bitfield with name $\nameone$, slices $\sliceone$, and $\bfsone$;
    \item $\vbone$ is true if and only if $\nameone$ is equal to $\nametwo$;
    \item symbolically equating the slices $\slicesone$ and $\slicestwo$ in $\tenv$ yields $\vbtwo$;
    \item checking $\bfsone$ is included in $\bfstwop$ in the context of $\tenv$ yields $\vbthree$;
    \item $\vb$ is defined as the conjunction of $\vbone$, $\vbtwo$, and $\vbthree$.
  \end{itemize}

  \item All of the following apply (\textsc{nested\_typed}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a nested bitfield with name $\nametwo$, slices $\slicestwo$, and bitfields $\bfstwop$;
    \item $\vbfone$ is a typed bitfield;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{typed\_simple}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a simple bitfield;
    \item symbolically checking whether $\vbfone$ is equivalent to $\vbftwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{typed\_nested}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a nested bitfield;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{typed\_typed}):
  \begin{itemize}
    \item the name associated with the bitfield $\vbfone$ is $\name$;
    \item finding the bitfield associated with $\name$ in $\bfstwo$ yields $\vbftwo$;
    \item $\vbftwo$ is a typed bitfield with name $\nametwo$, slices $\slicestwo$, and type $\ttytwo$;
    \item $\vbfone$ is a typed bitfield with name $\nameone$, slices $\slicesone$, and type $\ttyone$;
    \item $\vbone$ is true if and only if $\nameone$ is equal to $\nametwo$;
    \item symbolically equating the slices $\slicesone$ and $\slicestwo$ in $\tenv$ yields $\vbtwo$;
    \item checking whether $\ttyone$ structurally subtypes $\ttytwo$ in $\tenv$ yields $\vbthree$;
    \item $\vb$ is defined as the conjunction of $\vbone$, $\vbtwo$, and $\vbthree$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
\inferrule[none]{
  \bitfieldgetname(\vbfone) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \None
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \False
}
\and
\inferrule[simple\_any]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \astlabel(\vbftwo) = \BitFieldSimple\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested\_simple]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \vbfone = \BitFieldSimple(\Ignore)\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[nested\_nested]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \vbfone = \BitFieldNested(\nameone, \slicesone, \bfsone)\\
  \vbone \eqdef \nameone = \nametwo\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \bitfieldsincluded(\tenv, \bfsone, \bfstwop) \typearrow \vbthree\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\and
\inferrule[nested\_typed]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldNested(\nametwo, \slicestwo, \bfstwop)\\
  \astlabel(\vbfone) = \BitFieldType
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[typed\_simple]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \vbfone = \BitFieldSimple(\Ignore)\\
  \bitfieldsequal(\tenv, \vbfone, \vbftwo) \typearrow \vb
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\and
\inferrule[typed\_nested]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \astlabel(\vbfone) = \BitFieldNested
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[typed\_typed]{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \findbitfieldopt(\name, \bfstwo) \typearrow \langle \vbftwo \rangle\\
  \vbftwo = \BitFieldType(\nametwo, \slicestwo, \ttytwo)\\
  \vbfone = \BitFieldType(\nameone, \slicesone, \ttyone)\\
  \vbone \eqdef \nameone = \nametwo\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \structsubtypesat(\tenv, \ttyone, \ttytwo) \typearrow \vbthree \OrTypeError\\\\
  \vb \eqdef \vbone \land \vbtwo \land \vbthree
}{
  \membfs(\tenv, \bfstwo, \vbfone) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.BitFieldsIncluded}
\hypertarget{def-bitfieldsincluded}{}
The predicate
\[
  \bitfieldsincluded(\overname{\staticenvs}{\tenv}, \overname{\bitfield^*}{\bfsone} \aslsep \overname{\bitfield^*}{\bfstwo})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the set of bit fields $\bfsone$ is included in the set of bit fields $\bfstwo$ in environment $\tenv$,
returning a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking whether each field $\vbf$ in $\bfsone$ exists in $\bfstwo$ via $\membfs$ yields $\vb_\vbf$\ProseOrTypeError;
  \item the result --- $\vb$ --- is the conjunction of $\vb_\vbf$ for all bitfields $\vbf$ in $\bfsone$.
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
\inferrule{
  \vbf \in \bfsone: \membfs(\bfstwo, \vbf) \typearrow \vb_\vbf \OrTypeError\\\\
  \vbf \eqdef \bigwedge_{\bf \in \bfsone} \vb_\vbf
}{
  \bitfieldsincluded(\tenv, \bfsone, \bfstwo) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\hypertarget{def-typeofarraylength}{}
\section{TypingRule.TypeOfArrayLength \label{sec:TypingRule.TypeOfArrayLength}}
The function
\[
  \typeofarraylength(\overname{\staticenvs}{\tenv} \aslsep \overname{\arrayindex}{\size}) \aslto
  \overname{\ty}{\vt}
\]
returns the type for the array index $\size$ in the static environment $\tenv$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{enum}):
  \begin{itemize}
    \item $\size$ is an enumeration index over the enumeration $\vs$, that is, \\ $\ArrayLengthEnum(\vs, \Ignore)$;
    \item $\vt$ is the named type for $\vs$, that is, $\TNamed(\vs)$.
  \end{itemize}

  \item All of the following apply (\textsc{expr}):
  \begin{itemize}
    \item $\size$ is an expression index for $\ve$, that is, $\ArrayLengthExpr(\ve)$;
    \item applying $\normalize$ to simplify the expression corresponding to $\ve - 1$ in $\tenv$
          yields the expression $\vm$;
    \item $\vc$ is the range constraint for $0..\vm$, that is, $\ConstraintRange(\eliteral{0}, \vm)$;
    \item $\vt$ is the well-constrained integer with the single constraint $\vc$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\TypeOfArrayLengthBegin}{\TypeOfArrayLengthEnd}{../types.ml}
\subsection{Formally}
\begin{mathpar}
\inferrule[enum]{}
{
  \typeofarraylength(\tenv, \ArrayLengthEnum(\vs, \Ignore)) \typearrow \TNamed(\vs)
}
\and
\inferrule[expr]{
  \normalize(\tenv, \EBinop(\MINUS, \ve, \eliteral{1})) \typearrow \vm\\
  \vc \eqdef \ConstraintRange(\eliteral{0}, \vm)
}{
  \typeofarraylength(\tenv, \ArrayLengthExpr(\ve)) \typearrow \TInt(\wellconstrained([\vc]))
}
\end{mathpar}

\hypertarget{def-checkstructureinteger}{}
\section{TypingRule.CheckStructureInteger \label{sec:TypingRule.CheckStructureInteger}}
The function
\[
  \checkstructureinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \True \cup \TTypeError
\]
returns $\True$ is $\vt$ is has the \structure\ an integer type and a type error otherwise.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ is an integer type;
    \item the result is $\True$;
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ is not an integer type;
    \item the result is a type error indicating that $\vt$ was expected to have the \structure\ of an integer.
  \end{itemize}
\end{itemize}

\CodeSubsection{\CheckStructureIntegerBegin}{\CheckStructureIntegerEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\vt) \typearrow \vtp \OrTypeError\\\\
  \astlabel(\vtp) = \TInt
}
{
  \checkstructureinteger(\tenv, \vt) \typearrow \True
}
\and
\inferrule[error]{
  \tstruct(\vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \TInt
}
{
  \checkstructureinteger(\tenv, \vt) \typearrow \TypeErrorVal{ExpectedIntegerStructure}
}
\end{mathpar}

\hypertarget{def-checkstructurelabel}{}
\section{TypingRule.CheckStructure \label{sec:TypingRule.CheckStructure}}
The function
\[
  \checkstructurelabel(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\astlabels}{\vl}) \aslto
  \True \cup \TTypeError
\]
returns $\True$ is $\vt$ is has the \structure\ a of type corresponding to the AST label $\vl$ and a type error otherwise.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ has the label $\vl$;
    \item the result is $\True$;
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ does not have the label $\vl$;
    \item the result is a type error indicating that $\vt$ was expected to have the \structure\ of a type with the AST label $\vl$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\vt) \typearrow \vtp \OrTypeError\\\\
  \astlabel(\vtp) = \vl
}
{
  \checkstructurelabel(\tenv, \vt, \vl) \typearrow \True
}
\and
\inferrule[error]{
  \tstruct(\vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \vl
}
{
  \checkstructurelabel(\tenv, \vt, \vl) \typearrow \TypeErrorVal{UnexpectedTypeStructure}
}
\end{mathpar}

\hypertarget{def-storageispure}{}
\section{TypingRule.StorageIsPure \label{sec:TypingRule.StorageIsPure}}
The function
\[
  \storageispure(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vs}) \aslto
  \overname{\Bool}{\vb} \cup \TTypeError
\]
$\vb$ is true if and only if the identifier $\vs$ corresponds to a \pure\ storage element
in the static environment $\tenv$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{local}):
  \begin{itemize}
    \item $\vs$ is a locally declared storage element;
    \item $\vb$ is true if and only if $\vs$ is declared as a constant or as an immutable variable (\texttt{let}).
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item $\vs$ is a globally declared storage element;
    \item $\vb$ is true if and only if $\vs$ is declared as a constant, a configuration variable, or an immutable variable.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $\vs$ is not defined in the environment as a storage element;
    \item the result is a type error indicating that $\vs$ is not defined as a storage element.
  \end{itemize}
\end{itemize}

\CodeSubsection{\StorageIsPureBegin}{\StorageIsPureEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\localstoragetypes(\vs) = (\Ignore, \ldk)\\
  \vb \eqdef \ldk \in \{\LDKConstant, \LDKLet\}
}
{
  \storageispure(\tenv, \vs) \typearrow \vb
}
\and
\inferrule[global]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = (\Ignore, \gdk)\\
  \vb \eqdef \gdk \in \{\GDKConstant, \GDKConfig, \GDKLet\}
}
{
  \storageispure(\tenv, \vs) \typearrow \vb
}
\and
\inferrule[error]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = \bot
}
{
  \storageispure(\tenv, \vs) \typearrow \TypeErrorVal{UndefinedIdentifier}
}
\end{mathpar}

\hypertarget{def-checkstaticallyevaluable}{}
\section{TypingRule.CheckStaticallyEvaluable \label{sec:TypingRule.CheckStaticallyEvaluable}}
The function
\[
  \checkstaticallyevaluable(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \True \cup \TTypeError
\]
returns $\True$ if $\ve$ is a \staticallyevaluable\ expression in the static environment $\tenv$ and a type error otherwise.

\subsection{Prose}
All of the following applies:
\begin{itemize}
  \item symbolically simplifying $\ve$ in $\tenv$ via $\normalize$ yields $\veone$;
  \item determining the set of used identifiers in $\veone$ yields $\useset$;
  \item $\vb$ is true if and only if every identifier in $\useset$ is pure;
  \item the result is $\True$ is $\vb$ is $\True$, otherwise it is a type error indicating that the expression
  is not statically evaluable.
\end{itemize}

\CodeSubsection{\CheckStaticallyEvaluableBegin}{\CheckStaticallyEvaluableEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \tododefine{use\_e}(\veone) \typearrow \useset\\
  \id\in\useset: \storageispure(\tenv, \id) \typearrow \vb_\id\\
  \vb \eqdef \bigwedge_{\id\in\useset} \vb_\id\\
  \checktrans{\vb}{NotStaticallyEvaluable} \checktransarrow \True \OrTypeError
}
{
  \checkstaticallyevaluable(\tenv, \ve) \typearrow \True
}
\end{mathpar}

\section{TypingRule.ToWellConstrained}
\hypertarget{def-towellconstrained}{}
The function
\[
  \towellconstrained(\overname{\ty}{\vt}) \aslto \overname{\ty}{\vtp}
\]
returns the \wellconstrainedversion\ of a type $\vt$ --- $\vtp$, which is defined as follows.

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{t\_int\_underconstrained}):
  \begin{itemize}
    \item $\vt$ is an underconstrained integer for the variable $\vv$;
    \item $\vtp$ is the well-constrained integer constrained by the variable expression for $\vv$,
    that is, $\TInt(\wellconstrained(\constraintexact(\EVar(\vv))))$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_other, other}):
  \begin{itemize}
    \item $\vt$ is not an underconstrained integer for the variable $\vv$;
    \item $\vtp$ is $\vt$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[t\_int\_underconstrained]{}
{
  \towellconstrained(\TInt(\underconstrained(\vv))) \typearrow\\ \TInt(\wellconstrained(\constraintexact(\EVar(\vv))))
}
\and
\inferrule[t\_int\_other]{
  \astlabel(\vi) \neq \underconstrained
}
{
  \towellconstrained(\TInt(\vi)) \typearrow \vt
}
\and
\inferrule[other]{
  \astlabel(\vt) \neq \TInt
}
{
  \towellconstrained(\vt) \typearrow \vt
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.GetWellConstrainedStructure}
\hypertarget{def-getwellconstrainedstructure}{}
The function
\[
  \getwellconstrainedstructure(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt})
  \aslto \overname{\ty}{\vtp}
\]
returns the \wellconstrainedstructure\ of a type $\vt$ in a static environment $\tenv$ --- $\vtp$, which is defined as follows.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the \structure\ of $\vt$ in $\tenv$ is $\vtone$\ProseOrTypeError;
  \item the well-constrained version of $\vtone$ is $\vtp$.
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) \typearrow \vtone \OrTypeError\\\\
  \towellconstrained(\vtone) \typearrow \vtp
}
{
  \getwellconstrainedstructure(\tenv, \vt) \typearrow \vtp
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.GetBitvectorWidth}
\hypertarget{def-getbitvectorwidth}{}
The function
\[
  \getbitvectorwidth(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \overname{\expr}{\ve} \cup \TTypeError
\]
returns the expression $\ve$, which represents the width of the bitvector type $\vt$,
or a type error if $\vt$ is not a bitvector type or another type error is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a bitvector type with width expression $\ve$,
          that is, $\TBits(\ve, \Ignore)$\ProseOrTypeError;
    \item the result is $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a type that is not a bitvector type;
    \item the result is a type error indicating that a bitvector type was expected.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\tenv, \vt) \typearrow \TBits(\ve, \Ignore) \OrTypeError
}{
  \getbitvectorwidth(\tenv, \vt) \typearrow \ve
}
\and
\inferrule[error]{
  \tstruct(\tenv, \vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \TBits
}{
  \getbitvectorwidth(\tenv, \vt) \typearrow \TypeErrorVal{\ExpectedBitvectorType}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.CheckBitsEqualWidth}
\hypertarget{def-checkbitsequalwidth}{}
The function
\[
  \checkbitsequalwidth(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty}{\vtone}) \aslsep
    \overname{\ty}{\vttwo})\aslto
  \True \cup \TTypeError
\]
tests whether the types $\vtone$ and $\vttwo$ are bitvector types of the same width.
If the answer is positive, the result is $\True$. Otherwise, the result is a type error.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item obtaining the width of $\vtone$ in $\tenv$ (via $\getbitvectorwidth$) yields the expression $\vn$\ProseOrTypeError;
  \item obtaining the width of $\vttwo$ in $\tenv$ (via $\getbitvectorwidth$) yields the expression $\vm$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{true}):
    \begin{itemize}
      \item symbolically checking whether the bitwidth expressions $\vn$ and $\vm$ are equal (via $\bitwidthequal$) yields $\True$;
      \item the result is $\True$.
    \end{itemize}

    \item All of the following apply (\textsc{error}):
    \begin{itemize}
      \item symbolically checking whether the bitwidth expressions $\vn$ and $\vm$ are equal (via $\bitwidthequal$) yields $\False$;
      \item the result is a type error indicating that the bitwidths are different.
    \end{itemize}
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[true]{
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vn \OrTypeError\\
  \getbitvectorwidth(\tenv, \vttwo) \typearrow \vm \OrTypeError\\
  \bitwidthequal(\tenv, \vn, \vm) \typearrow \True
}{
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \True
}
\and
\inferrule[error]{
  \getbitvectorwidth(\tenv, \vtone) \typearrow \vn \OrTypeError\\
  \getbitvectorwidth(\tenv, \vttwo) \typearrow \vm \OrTypeError\\
  \bitwidthequal(\tenv, \vn, \vm) \typearrow \False
}{
  \checkbitsequalwidth(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{DifferentBitwidths}
}
\end{mathpar}
\end{emptyformal}

\section{AssocOpt}
\hypertarget{def-assocopt}{}
The function
\[
  \assocopt(\overname{(\identifier\times T)^*}{\vli} \aslsep \overname{\identifier}{\id}) \typearrow \langle \overname{T}{\vv} \rangle
\]
returns the value $\vv$ associated with the identifier $\id$ in the list of pairs $\vli$ or $\None$, if no such association exists.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{member}):
  \begin{itemize}
    \item a pair $(\id,\vv)$ exists in the list $\vli$;
    \item the result is $\langle\vv\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{not\_member}):
  \begin{itemize}
    \item every pair $(\vx,\Ignore)$ in the list $\vli$ has $\vx\neq\id$;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[not\_member]{
  (\vx, \vv) \in \vli: \vx \neq \id
}{
  \assocopt(\vli, \id) \typearrow \None
}
\and
\inferrule[member]{
  (\id, \vv) \in \vli
}{
  \assocopt(\vli, \id) \typearrow \langle \vv \rangle
}
\end{mathpar}
\end{emptyformal}

\section{LookupConstant}
\hypertarget{def-lookupconstant}{}
The function
\[
  \lookupconstant(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vs})
  \;\aslto\; \overname{\literal}{\vv}\ \cup\ \{\bot\}
\]
looks up the environment $\tenv$ for a constant $\vv$ associated with an identifier
$\vs$. The result is $\bot$ if $\vs$ is not associated with any constant.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{local}):
  \begin{itemize}
    \item $\vs$ is associated with a constant $\vv$ in the local environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item $\vs$ is not associated with a constant in the local environment of $\tenv$;
    \item $\vs$ is associated with a constant $\vv$ in the global environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item $\vs$ is not associated with a constant in the local environment of $\tenv$;
    \item $\vs$ is not associated with a constant in the global environment of $\tenv$;
    \item the result is $\bot$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\constantvalues(\vs) = \vv
}{
  \lookupconstant(\tenv, \vs) \typearrow \vv
}
\and
\inferrule[global]{
  L^\tenv.\constantvalues(\vs) = \bot\\
  G^\tenv.\constantvalues(\vs) = \vv
}{
  \lookupconstant(\tenv, \vs) \typearrow \vv
}
\and
\inferrule[none]{
  L^\tenv.\constantvalues(\vs) = \bot\\
  G^\tenv.\constantvalues(\vs) = \bot
}{
  \lookupconstant(\tenv, \vs) \typearrow \bot
}
\end{mathpar}
\end{emptyformal}

\section{TypeOf}
\hypertarget{def-typeof}{}
The function
\[
  \typeof(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vs})
  \;\aslto\; \overname{\ty}{\tty}\ \cup\ \overname{\TTypeError}{\TypeErrorConfig}
\]
looks up the environment $\tenv$ for a type $\tty$ associated with an identifier
$\vs$. The result is type error if $\vs$ is not associated with any type.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{local}):
  \begin{itemize}
    \item $\vs$ is associated with a type $\tty$ in the local environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{global}):
  \begin{itemize}
    \item $\vs$ is not associated with a type in the local environment of $\tenv$;
    \item $\vs$ is associated with a type $\tty$ in the global environment of $\tenv$;
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $\vs$ is not associated with a type in the local environment of $\tenv$;
    \item $\vs$ is not associated with a type in the global environment of $\tenv$;
    \item the result is a type error indicating that $\vs$ was expected to be associated
          with a type.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\localstoragetypes(\vs) = \tty
}{
  \typeof(\tenv, \vs) \typearrow \tty
}
\and
\inferrule[global]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = \tty
}{
  \typeof(\tenv, \vs) \typearrow \tty
}
\and
\inferrule[none]{
  L^\tenv.\localstoragetypes(\vs) = \bot\\
  G^\tenv.\globalstoragetypes(\vs) = \bot
}{
  \typeof(\tenv, \vs) \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.IsUndefined \label{sec:TypingRule.IsUndefined}}
\hypertarget{def-isundefined}{}
The function
\[
\isundefined(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\vx})
\aslto \overname{\Bool}{\vb}
\]
checks whether the identifier $\vx$ is defined as a storage element in the static environment $\tenv$.

\subsection{Prose}
$\vb$ is $\True$ if and only if $\vx$ is not bound in to a global storage in $\tenv$ and
$\vx$ is not bound to a local storage in $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef G^\tenv.\globalstoragetypes(\vx) = \bot \land L^\tenv.\localstoragetypes(\vx) = \bot
}{
  \isundefined(\tenv, \vx) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\section{Sorting Lists \label{sec:sortinglists}}
\hypertarget{def-sort}{}
The parameteric function
\[
\sort(\overname{T^*}{\vlone}, \overname{(T\times T)\rightarrow \{-1,0,1\}}{\compare}) \typearrow \overname{T^*}{\vltwo}
\]
sorts a list of elements of type $T$ --- $\vlone$ --- using the comparison function $\compare$,
resulting in the sorted list $\vltwo$.
$\compare(a, b)$ returns $1$ to mean that $a$ should be ordered before $b$,
$0$ to mean that $a$ and $b$ can be ordered in any way,
and $-1$ to mean that $b$ should be ordered before $a$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty\_or\_single}):
  \begin{itemize}
    \item $\vlone$ is either empty or contains a single element;
    \item $\vltwo$ is $\vlone$.
  \end{itemize}

  \item All of the following apply (\textsc{two\_or\_more}):
  \begin{itemize}
    \item $\vlone$ contains at least two elements;
    \item $f$ is a permutation of $1..n$;
    \item $\vltwo$ is the application of the permutation $f$ to $\vlone$;
    \item applying $\compare$ to every pair of consecutive elements in $\vltwo$ yields either $0$ or $1$.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[empty\_or\_single]{
  \listlen{\vlone} = n\\
  n < 2
}{
  \sort(\vlone, \compare) \typearrow \overname{\vlone}{\vltwo}
}
\and
\inferrule{two\_or\_more}{
  \listlen{\vlone} = n\\
  f : 1..n \rightarrow 1..n \text{ is a bijection}\\
  \vltwo \eqdef [\ i=1..n: \vlone[f(i)]\ ]\\
  i=1..n-1: \compare(\vltwo[i], \vltwo[i+1]) \geq 0
}{
  \sort(\vlone, \compare) \typearrow \vltwo
}
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Type Error Codes}

\begin{description}
\hypertarget{def-setterwithoutgetter}{}
\item[$\SetterWithoutGetter$:]
ASL requires each setter for a given identifier to have a corresponding getter for the same
identifier.
The specification either does not contain a getter for the same identifier
or a getter for the same identifier exists, but it does not have the expected
signature (see \secref{TypingRule.CheckSetterHasGetter}).

\hypertarget{def-expectedbitvectortype}{}
\item[$\ExpectedBitvectorType$]
A type that is not that of a bitvector was given where a bitvector type was expected.
See \typingrulecasename{CheckBinop}{plus\_minus\_bits\_bits} (\secref{TypingRule.CheckBinop}) for an example.

\hypertarget{def-undefinedidentifier}{}
\item[$\UndefinedIdentifier$]
An identifier that is missing a definition of the appropriate kind.
See TypingRule.SubprogramForName (\secref{TypingRule.SubprogramForName}) for an example.

\hypertarget{def-subprogramdeclaredmultipletimes}{}
\item[$\SubrogramDeclaredMultipleTimes$]
At least two subprograms in the specification clash (see \secref{TypingRule.AddNewFunc}).

\hypertarget{def-nocallcandidates}{}
\item[$\NoCallCandidates$]
A function call, given by its name and list of formal argument types, does not match any defined subprogram
(see \secref{TypingRule.SubprogramForName}).

\hypertarget{def-toomanycandidates}{}
\item[$\TooManyCandidates$]
A function call, given by its name and list of formal argument types, matches more than one subprogram,
which does not allow the type-checker to decide which subprogram the call refers to
(see \secref{TypingRule.SubprogramForName}).

\hypertarget{def-parameterwithoutdecl}{}
\item[$\ParameterWithoutDecl$]
A subprogram includes a parameter that is not associated with any variable appearing in one of the arguments
(see \secref{TypingRule.AnnotateParams}).

\hypertarget{def-nolca}{}
\item[$\NoLCA$]
A conditional expressions results in two types that have no common ancestor type that can represent both
(see \secref{sec:TypingRule.LowestCommonAncestor}).

\end{description}

\noindent\makebox[\linewidth]{\rule{\linewidth}{0.4pt}}
\hypertarget{tododefine}{Function names with red hyperlinks indicated a missing definition that needs to be done.}

\bibliographystyle{plain}
\bibliography{ASL}

\end{document}
