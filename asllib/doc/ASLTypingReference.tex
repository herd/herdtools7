\documentclass{book}
\input{ASLmacros}
\input{ASLTypingLines}
\input{ASLTypeSatisfactionLines}
\input{ASLASTLines}
\newcommand{\tests}{../tests/ASLTypingReference.t/}

\newcommand\todocomment[1]{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The following macros will be moved to ASLmacros.tex when we unify all reference documents.
\newcommand\ReadEffect[0]{\textsf{ReadEffect}}
\newcommand\Normal[0]{\textsf{Normal}}
\newcommand\ThrowingConfig[0]{\texttt{\#T}}
\newcommand\OrAbnormal[0]{\terminateas \ThrowingConfig, \ErrorConfig}
\newcommand\vg[0]{\texttt{g}}
\newcommand\env[0]{\texttt{env}}
\newcommand\parallelcomp[0]{\parallel}
\newcommand\binoprel[0]{\texttt{binop}}
\newcommand\evalexprsef[1]{\hyperlink{def-evalexprsef}{\texttt{eval\_expr\_sef}}(#1)}
\newcommand\XGraphs[0]{\mathcal{G}}
\newcommand\TError[0]{\textsf{TDynError}}
\newcommand\ErrorConfig[0]{\texttt{\#DE}}

\newcommand\dynamicdomain[0]{\hyperlink{def-dyndomain}{\textsf{dyn-dom}}}
\newcommand\literals[0]{\mathcal{L}}

\newcommand\TypeError[0]{\hyperlink{def-typeerror}{\textsf{TypeError}}}
\newcommand\TypeErrorVal[1]{\TypeError(\texttt{"ERROR[#1]"})}
\newcommand\TTypeError[0]{\hyperlink{def-ttypeerror}{\textsf{TTypeError}}}
\newcommand\TypeErrorConfig[0]{\hyperlink{def-typeerrorconfig}{\texttt{\#TE}}}
\newcommand\OrTypeError[0]{\terminateas \TypeErrorConfig}
%\newcommand\ProseOrTypeError[0]{or a type error that short-circuits the entire rule}
\newcommand\ProseOrTypeError[0]{\hyperlink{def-proseortypeerror}{$^{\TypeErrorConfig}$}}

\newcommand\annotaterel[0]{\hyperlink{def-annotaterel}{\textsf{type}}}
\newcommand\typearrow[0]{\xrightarrow{\annotaterel}}
\newcommand\isbuiltinsingular[0]{\hyperlink{def-isbuiltinsingular}{\texttt{is\_builtin\_singular}}}
\newcommand\isbuiltinaggregate[0]{\hyperlink{def-isbuiltinaggregate}{\texttt{is\_builtin\_aggregate}}}
\newcommand\isbuiltin[0]{\hyperlink{def-isbuiltin}{\texttt{is\_builtin}}}
\newcommand\isnamed[0]{\hyperlink{def-isnamed}{\texttt{is\_named}}}
\newcommand\isanonymous[0]{\hyperlink{def-isanonymous}{\texttt{is\_anonymous}}}
\newcommand\issingular[0]{\hyperlink{def-issingular}{\texttt{is\_singular}}}
\newcommand\isaggregate[0]{\hyperlink{def-isaggregate}{\texttt{is\_aggregate}}}
\newcommand\isnonprimitive[0]{\hyperlink{def-isnonprimitive}{\texttt{is\_non\_primitive}}}
\newcommand\isprimitive[0]{\hyperlink{def-isprimitive}{\texttt{is\_primitive}}}

\newcommand\isunconstrainedinteger[0]{\textsf{unconstrained\_integer}}
\newcommand\isunderconstrainedinteger[0]{\textsf{under\_constrained\_integer}}
\newcommand\iswellconstrainedinteger[0]{\textsf{well\_constrained\_integer}}
\newcommand\unconstrainedinteger[0]{\textsf{unconstrained\_integer}}

\newcommand\staticeval[0]{\hyperlink{def-staticeval}{\texttt{static\_eval}}}
\newcommand\isstaticallyevaluable[0]{\texttt{check\_statically\_evaluable}}

\newcommand\makeanonymous[0]{\hyperlink{def-makeanonymous}{\texttt{make\_anonymous}}}
\newcommand\subtypesrel[0]{\hyperlink{def-subtypesrel}{\texttt{subtypes}}}
\newcommand\structsubtypesat[0]{\hyperlink{def-structsubtypesat}{\texttt{structural\_subtype\_satisfies}}}
\newcommand\domsubtypesat[0]{\hyperlink{def-domsubtypesat}{\texttt{domain\_subtype\_satisfies}}}
\newcommand\subtypesat[0]{\hyperlink{def-subtypesat}{\texttt{subtype\_satisfies}}}
\newcommand\checktypesat[0]{\hyperlink{def-checktypesat}{\texttt{checked\_typesat}}}
\newcommand\typeclashes[0]{\hyperlink{def-typeclashes}{\texttt{type\_clashes}}}
\newcommand\lca[0]{\texttt{lowest\_common\_ancestor}}
\newcommand\lcasat[0]{\models}
\newcommand\Supers{\textsf{Supers}}
\newcommand\bitfieldsincluded[0]{\hyperlink{def-bitfieldsincluded}{\texttt{bitfields\_included}}}
\newcommand\instantiate[0]{\textsf{instantiate}}
\newcommand\canbeinitializedwith[0]{\texttt{can\_be\_initialized\_with}}
\newcommand\getbitvectorwidth[0]{\texttt{get\_bitvector\_width}}
\newcommand\findsubprogram[0]{\hyperlink{def-findsubprogram}{\texttt{find\_subprogram}}}
\newcommand\subprogramtypeclash[0]{\texttt{subprogram\_type\_clash}}
\newcommand\hassubprogramtypeclash[0]{\texttt{subprogram\_type\_clash}}
\newcommand\subprogramclash[0]{\texttt{subprogram\_clash}}
\newcommand\argsclash[0]{\texttt{args\_clash}}

\newcommand\typeequal[0]{\hyperlink{def-typeequal}{\texttt{type\_equal}}}
\newcommand\exprequal[0]{\hyperlink{def-exprequal}{\texttt{expr\_equal}}}
\newcommand\bitwidthequal[0]{\hyperlink{def-bitwidthequal}{\texttt{bitwidth\_equal}}}
\newcommand\bitfieldequal[0]{\hyperlink{def-bitfieldequal}{\texttt{bitfield\_equal}}}
\newcommand\bitfieldsequal[0]{\hyperlink{def-bitfildsequal}{\texttt{bitfields\_equal}}}

\newcommand\subsumes[0]{\hyperlink{def-subsumes}{\texttt{subsumes}}}
\newcommand\symsubsumes[0]{\hyperlink{def-symsubsumes}{\texttt{sym\_subsumes}}}

\newcommand\toir[0]{\texttt{to\_ir}}
\newcommand\toircase[0]{\texttt{to\_ir\_case}}
\newcommand\exprir[0]{\textsf{expr\_ir}}
\newcommand\Prod[0]{\textsf{Prod}}
\newcommand\Sum[0]{\textsf{Sum}}
\newcommand\monomials[0]{\textsf{Monomials}}
\newcommand\polynomials[0]{\textsf{Polynomials}}
\newcommand\addpolynomials[0]{\texttt{add\_polynomials}}
\newcommand\mulpolynomials[0]{\texttt{mul\_polynomials}}
\newcommand\mulmonomials[0]{\texttt{mul\_mononimials}}

\newcommand\declaredtype[0]{\hyperlink{def-declaredtype}{\texttt{declared\_type}}}

\newcommand\fieldnames[0]{\hyperlink{def-fieldnames}{\texttt{field\_names}}}
\newcommand\fieldtype[0]{\hyperlink{def-fieldtype}{\texttt{field\_type}}}

\newcommand\eliteral[1]{\textsf{E\_Literal}(#1)}

% Glossary
\newcommand\structure[0]{\hyperlink{def-structure}{structure}}
\newcommand\underlyingtype[0]{\hyperlink{def-underlyingtype}{underlying type}}
\newcommand\symbolicdomain[0]{\hyperlink{def-symbolicdomain}{symbolic domain}}
\newcommand\typesatisfies[0]{\hyperlink{def-typesatisfies}{type-satisfies}}
\newcommand\checkedtypesatisfies[0]{\hyperlink{def-checktypesat}{checked-type-satisfies}}
\newcommand\typesatisft[0]{\hyperlink{def-typesatisfies}{type-satisft}}
\newcommand\subtypesatisfies[0]{\hyperlink{def-subtypesatisfies}{subtype-satisfies}}
\newcommand\subtypesatisfy[0]{\hyperlink{def-subtypesatisfies}{subtype-satisfisfy}}
\newcommand\typeequivalent[0]{\hyperlink{def-typeequal}{type-equivalent}}
\newcommand\bitwidthequivalent[0]{\hyperlink{def-bitwidthequal}{bitwidth-equivalent}}
\newcommand\typeclash[0]{\hyperlink{def-typeclashes}{type-clash}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type functions
\newcommand\CheckUnop[0]{\hyperlink{def-checkunop}{\texttt{check\_unop}}}
\newcommand\CheckBinop[0]{\hyperlink{def-checkbinop}{\texttt{check\_binop}}}
\newcommand\constraintbinop[0]{\texttt{constraint\_binop}}
\newcommand\sliceswidth[0]{\texttt{slices\_width}}
\newcommand\annotatetype[1]{\hyperlink{def-annotatetype}{\texttt{annotate\_type}}(#1)}
\newcommand\annotateexpr[1]{\hyperlink{def-annotateexpr}{\texttt{annotate\_expr}}(#1)}
\newcommand\annotateexprlist[1]{\hyperlink{def-annotateexprs}{\texttt{annotate\_exprs}}(#1)}
\newcommand\annotatelexpr[1]{\textsf{annotate\_lexpr}(#1)}
\newcommand\annotatearrayindex[0]{\textsf{annotate\_array\_index}}
\newcommand\annotateslices[0]{\textsf{annotate\_slices}}
\newcommand\annotatelocaldeclitem[1]{\texttt{annotate\_local\_decl\_item}(#1)}
\newcommand\annotatestmt[1]{\texttt{annotate\_stmt}(#1)}
\newcommand\annotateblock[1]{\texttt{annotate\_block}(#1)}
\newcommand\inlinesetter[1]{\texttt{setter\_should\_reduce\_to\_call\_s}(#1)}
\newcommand\annotatecall[1]{\hyperlink{def-annotatecall}{\texttt{annotate\_call}}(#1)}
\newcommand\annotatecatcher[1]{\texttt{annotate\_catcher}(#1)}
\newcommand\reduceconstants[1]{\texttt{reduce\_constants}(#1)}
\newcommand\declarelocalconstant[1]{\texttt{declare\_local\_constant}(#1)}
\newcommand\annotatelocaldeclitemuninit[1]{\texttt{annotate\_local\_decl\_item\_uninit}(#1)}
\newcommand\checkvarnotinenv[1]{\texttt{check\_var\_not\_in\_env}(#1)}
\newcommand\annotatesubprogram[1]{\texttt{annotate\_subprogram}(#1)}
\newcommand\declaredecl[1]{\texttt{annotate\_decl}(#1)}
\newcommand\annotatespec[1]{\texttt{annotate\_spec}(#1)}
\newcommand\evalexpr[1]{\texttt{eval\_expr}(#1)}
\newcommand\evalconstraint[1]{\texttt{eval\_constraint}(#1)}
\newcommand\annotateliteral[1]{\hyperlink{def-annotateliteral}{\texttt{annotate\_literal}}(#1)}
\newcommand\exprequalcase[0]{\texttt{expr\_equal\_case}}
\newcommand\exprequalnorm[0]{\texttt{expr\_equal\_norm}}
\newcommand\slicesequal[0]{\texttt{slices\_equal}}
\newcommand\sliceequal[0]{\texttt{slice\_equal}}
\newcommand\constraintsequal[0]{\texttt{constraints\_equal}}
\newcommand\constraintequal[0]{\texttt{constraint\_equal}}
\newcommand\literalequal[0]{\texttt{literal\_equal}}
\newcommand\findcheckdeduce[0]{\hyperlink{def-findcheckdeduce}{\texttt{find\_check\_deduce}}}
%\newcommand\renametyeqs[0]{\texttt{rename\_ty\_eqs}}
\newcommand\annotatebitfield[0]{\hyperlink{def-annotatebitfield}{\texttt{annotate\_bitfield}}}
\newcommand\annotatebitfields[0]{\hyperlink{def-annotatebitfields}{\texttt{annotate\_bitfields}}}
\newcommand\checknoduplicates[0]{\hyperlink{def-checknoduplicates}{\texttt{check\_no\_duplicates}}}
\newcommand\reduceslicestocall[0]{\hyperlink{def-reduceslicestocall}{\texttt{reduce\_slices\_to\_call}}}
\newcommand\typeofarraylength[0]{\hyperlink{def-typeofarraylength}{\texttt{type\_of\_array\_length}}}

% Symbolic domain subsumption
\newcommand\symdom[0]{\hyperlink{def-symdom}{\textsf{sym\_dom}}}
\newcommand\intset[0]{\hyperlink{def-intset}{\textsf{int\_set}}}
\newcommand\syntax[0]{\hyperlink{def-syntax}{\textsf{syntax}}}

\newcommand\DBool[0]{\hyperlink{def-dbool}{\textsf{D\_Bool}}}
\newcommand\DString[0]{\hyperlink{def-dstring}{\textsf{D\_String}}}
\newcommand\DReal[0]{\hyperlink{def-dreal}{\textsf{D\_Real}}}
\newcommand\DSymbols[0]{\hyperlink{def-dsymbols}{\textsf{D\_Symbols}}}
\newcommand\DInt[0]{\hyperlink{def-dint}{\textsf{D\_Int}}}
\newcommand\DBits[0]{\hyperlink{def-dbits}{\textsf{D\_Bits}}}

\newcommand\Finite[0]{\hyperlink{def-finite}{\textsf{Finite}}}
\newcommand\Top[0]{\hyperlink{def-top}{\textsf{Top}}}
\newcommand\FromSyntax[0]{\hyperlink{def-fromsymtax}{\textsf{FromSyntax}}}

\newcommand\symdomoftype[0]{\hyperlink{def-symdomoftype}{\texttt{symdom\_of\_type}}}
\newcommand\symdomofexpr[0]{\hyperlink{def-symdomofexpr}{\texttt{symdom\_of\_expr}}}
\newcommand\symdomofliteral[0]{\hyperlink{def-symdomofliteral}{\texttt{symdom\_of\_literal}}}
\newcommand\intsetofintconstraints[0]{\hyperlink{def-intsetofintconstraintse}{\texttt{intset\_of\_intconstraints}}}
\newcommand\symdomissubset[0]{\hyperlink{def-symdomissubset}{\texttt{symdom\_is\_subset}}}
\newcommand\symintsetsubset[0]{\hyperlink{def-symintsetsubset}{\texttt{sym\_intset\_subset}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Typeset variable names
\newcommand\newtenv[0]{\texttt{new\_tenv}}
\newcommand\tenvone[0]{\texttt{tenv1}}
\newcommand\tenvtwo[0]{\texttt{tenv2}}
\newcommand\va[0]{\texttt{a}}
\newcommand\vc[0]{\texttt{c}}
\newcommand\vcone[0]{\texttt{c1}}
\newcommand\vctwo[0]{\texttt{c2}}
\newcommand\vione[0]{\texttt{i1}}
\newcommand\vitwo[0]{\texttt{i2}}
\newcommand\vf[0]{\texttt{f}}
\newcommand\vfone[0]{\texttt{f1}}
\newcommand\vftwo[0]{\texttt{f2}}
\newcommand\vl[0]{\texttt{l}}
\newcommand\vm[0]{\texttt{m}}
\newcommand\vmone[0]{\texttt{m1}}
\newcommand\vmtwo[0]{\texttt{m2}}
\newcommand\vy[0]{\texttt{y}}
\newcommand\vp[0]{\texttt{p}}
\newcommand\vo[0]{\texttt{o}}
\newcommand\vvone[0]{\texttt{v1}}
\newcommand\vvtwo[0]{\texttt{v2}}
\newcommand\vt[0]{\texttt{t}}
\newcommand\vte[0]{\texttt{t\_e}}
\newcommand\veone[0]{\texttt{e1}}
\newcommand\vetwo[0]{\texttt{e2}}
\newcommand\vethree[0]{\texttt{e3}}
\newcommand\vleone[0]{\texttt{le1}}
\newcommand\vletwo[0]{\texttt{le2}}
\newcommand\vtleone[0]{\texttt{t\_le1}}
\newcommand\vre[0]{\texttt{re}}
\newcommand\vs[0]{\texttt{s}}
\newcommand\vtsone[0]{\texttt{ts1}}
\newcommand\vtstwo[0]{\texttt{ts2}}
\newcommand\vlt[0]{\texttt{l\_t}}
\newcommand\vls[0]{\texttt{l\_s}}
\newcommand\vtt[0]{\texttt{t\_t}}
\newcommand\vts[0]{\texttt{t\_s}}
\newcommand\vsone[0]{\texttt{s1}}
\newcommand\vstwo[0]{\texttt{s2}}
\newcommand\vz[0]{\texttt{z}}
\newcommand\vw[0]{\texttt{w}}
\newcommand\vwone[0]{\texttt{w1}}
\newcommand\vwtwo[0]{\texttt{w2}}
\newcommand\vwidth[0]{\texttt{width}}
\newcommand\size[0]{\texttt{size}}
\newcommand\vfield[0]{\texttt{field}}
\newcommand\vfieldone[0]{\texttt{field1}}
\newcommand\vfieldtwo[0]{\texttt{field2}}
\newcommand\vfieldsone[0]{\texttt{fields1}}
\newcommand\vfieldstwo[0]{\texttt{fields2}}
\newcommand\bitfields[0]{\texttt{bitfields}}
\newcommand\bfone[0]{\texttt{bf1}}
\newcommand\bftwo[0]{\texttt{bf2}}
\newcommand\bfoneone[0]{\texttt{bf1\_1}}
\newcommand\bftwoone[0]{\texttt{bf2\_1}}
\newcommand\vslices[0]{\texttt{slices}}
\newcommand\newle[0]{\texttt{new\_le}}
\newcommand\ldi[0]{\texttt{ldi}}
\newcommand\ldk[0]{\texttt{ldk}}
\newcommand\tty[0]{\texttt{ty}}
\newcommand\tsy[0]{\texttt{sy}}
\newcommand\tyopt[0]{\texttt{ty\_opt}}
\newcommand\ldis[0]{\texttt{ldis}}
\newcommand\newldi[0]{\texttt{new\_ldi}}
\newcommand\news[0]{\texttt{new\_s}}
\newcommand\newsone[0]{\texttt{new\_s1}}
\newcommand\newstwo[0]{\texttt{new\_s2}}
\newcommand\newargs[0]{\texttt{new\_args}}
\newcommand\eqs[0]{\texttt{eqs}}
\newcommand\neweqs[0]{\texttt{new\_eqs}}
\newcommand\reduced[0]{\texttt{reduced}}
\newcommand\tcond[0]{\texttt{t\_cond}}
\newcommand\econd[0]{\texttt{e\_cond}}
\newcommand\vcond[0]{\texttt{v\_cond}}
\newcommand\etrue[0]{\texttt{e\_true}}
\newcommand\efalse[0]{\texttt{e\_false}}
\newcommand\ttrue[0]{\texttt{t\_true}}
\newcommand\tfalse[0]{\texttt{t\_false}}
\newcommand\dir[0]{\texttt{dir}}
\newcommand\eindex[0]{\texttt{e\_index}}
\newcommand\wantedtindex[0]{\texttt{wanted\_t\_index}}
\newcommand\tindex[0]{\texttt{t\_index}}
\newcommand\fieldname[0]{\texttt{field\_name}}
\newcommand\fields[0]{\texttt{fields}}
\newcommand\fieldsone[0]{\texttt{fields1}}
\newcommand\fieldstwo[0]{\texttt{fields2}}
\newcommand\slices[0]{\texttt{slices}}
\newcommand\newe[0]{\texttt{new\_e}}
\newcommand\ta[0]{\texttt{ta}}
\newcommand\les[0]{\texttt{les}}
\newcommand\subtys[0]{\texttt{sub\_tys}}
\newcommand\catchers[0]{\texttt{catchers}}
\newcommand\otherwise[0]{\texttt{otherwise}}
\newcommand\csone[0]{\texttt{cs1}}
\newcommand\cstwo[0]{\texttt{cs2}}
\newcommand\irone[0]{\texttt{ir1}}
\newcommand\irtwo[0]{\texttt{ir2}}
\newcommand\vpone[0]{\texttt{p1}}
\newcommand\vptwo[0]{\texttt{p2}}
\newcommand\vps[0]{\texttt{ps}}
\newcommand\opone[0]{\texttt{op1}}
\newcommand\optwo[0]{\texttt{op2}}
\newcommand\vep[0]{\texttt{e'}}
\newcommand\veoneone[0]{\texttt{e1\_1}}
\newcommand\veonetwo[0]{\texttt{e1\_2}}
\newcommand\veonethree[0]{\texttt{e1\_3}}
\newcommand\vetwoone[0]{\texttt{e2\_1}}
\newcommand\vetwotwo[0]{\texttt{e2\_2}}
\newcommand\vetwothree[0]{\texttt{e2\_3}}
\newcommand\vbone[0]{\texttt{b1}}
\newcommand\vbtwo[0]{\texttt{b2}}
\newcommand\vbthree[0]{\texttt{b3}}
\newcommand\nameone[0]{\texttt{name1}}
\newcommand\nametwo[0]{\texttt{name2}}
\newcommand\vargsone[0]{\texttt{args1}}
\newcommand\vargstwo[0]{\texttt{args2}}
\newcommand\vargone[0]{\texttt{arg1}}
\newcommand\vargtwo[0]{\texttt{arg2}}
\newcommand\vlone[0]{\texttt{l1}}
\newcommand\vltwo[0]{\texttt{l2}}
\newcommand\sliceone[0]{\texttt{slice1}}
\newcommand\slicetwo[0]{\texttt{slice2}}
\newcommand\slicesone[0]{\texttt{slices1}}
\newcommand\slicestwo[0]{\texttt{slices2}}
\newcommand\positions[0]{\texttt{positions}}
\newcommand\posmax[0]{\texttt{pos\_max}}
\newcommand\bv[0]{\texttt{bv}}
\newcommand\bvone[0]{\texttt{bv1}}
\newcommand\vtp[0]{\texttt{t'}}
\newcommand\vli[0]{\texttt{li}}
\newcommand\tys[0]{\texttt{tys}}
\newcommand\name[0]{\texttt{name}}
\newcommand\newname[0]{\texttt{new\_name}}

% Increase indentation of sections in the table of contents
% to allow a space between the section numbers and their titles.
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{2.6em}}
\makeatother
\setcounter{tocdepth}{1}

\author{Arm Architecture Technology Group}
\title{ASL Typing Reference \\
       DDI 0622}
\begin{document}
\maketitle

\tableofcontents{}

\include{notice.tex}

\include{disclaimer.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The purpose of this document is to describe, in a formal and authoritative way,
which ASL specifications are considered \emph{well-typed}.
Whether a specification is well-typed is defined in terms of a \emph{type system}~\cite{TypeSystemsLucaCardelli}.
That is, a set of \emph{typing rules}.

A \emph{type checker} is an implementation of the ASL type system, which first parses an ASL specification.
If the parsing is successful, the result is an \emph{abstract syntax tree} (AST, for short),
which represents an ASL specification as a labelled structured tree. Otherwise, the result is a syntax error
and the type checker does not proceed.
%
The ASL syntax and AST is defined in~\cite{ASLAbstractSyntaxReference}.

When an ASL specification is successfully parsed, we refer to the resulting AST as the \emph{parsed AST}.
The type checker apply the rules of the type system to the parsed AST. If it is successful, the specification
is considered well-typed and the result is a pair consisting of
a \emph{static environment} and a \emph{typed AST}. Otherwise, the type checker returns a type error.

\paragraph{Related documents:}
\begin{itemize}
  \item The ASL Language Reference Manual~\cite{LRM} (LRM, for short) introduces the concrete syntax and intent
  of all ASL language constructs.
  Please note that the LRM will be retired in due course. For ease of reviewing, we currently indicate which statement
  of the LRM the present rules correspond to.
  \item The Abstract Syntax Reference~\cite{ASLAbstractSyntaxReference} defines the abstract syntax, parsed AST, and typed AST.
  \item The ASL Semantics Reference~\cite{ASLSemanticsReference} defines all valid behaviors of a well-typed ASL specification.
\end{itemize}

\paragraph{Understanding the Typing Formalization:}
We assume basic familiarity with the ASL language.
The ASL type system is defined in terms of its AST,
and familiarity with the AST is \underline{required} to understand it.
The mathematical background needed to understand the mathematical formalization
of the ASL semantics appears in \chapref{formal} and \chapref{typesystembuildingblocks}.

\include{ASLFormal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Type System Building Blocks}
\label{chap:typesystembuildingblocks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter defines necessary mathematical types and concepts for the ASL system.

Types are represented by ASTs derived from the non-terminal $\ty$ (see \cite{ASLAbstractSyntaxReference}
for the precise definition of $\ty$).

\section{Static Environments}

A \emph{static environment} (also called a \emph{type environment}) is what the typing rules operate over:
a structure, which amongst other things, associates types to variables.
Throughout this document, we will use the term environment for static environment, unless otherwise stated.
Intuitively, the typing of a
specification makes an initial environment evolve, with new types as given by the
variable declarations of the specification.

\begin{definition}
\hypertarget{def-staticenvs}{}
Static environments, denoted as $\staticenvs$, are defined as follows (referring to symbols defined by the abstract syntax):
\[
\begin{array}{rcl}
\staticenvs 	          &\triangleq& \mathbb{G} \times \mathbb{L}\\
\mathbb{G} 	            &\triangleq& \declaredtypes \times \constantvalues \times \globalstoragetypes\\
  			                & & \times\ \subtypes \times \subprograms \times \subprogramrenamings\\
\mathbb{L} 	            &\triangleq& \constantvalues \times \localstoragetypes \times \returntype\\
\hline
\declaredtypes	        &\triangleq& \identifier \partialto \ty\\
\constantvalues         &\triangleq& \identifier \partialto \literal\\
\globalstoragetypes     &\triangleq& \identifier \partialto \ty \times \globaldeclkeyword\\
\localstoragetypes      &\triangleq& \identifier \partialto \ty \times \localdeclkeyword\\
\subtypes		            &\triangleq& \identifier \partialto \identifier\\
\subprograms	          &\triangleq& \identifier \partialto \func\\
\subprogramrenamings	  &\triangleq& \identifier \rightarrow \pow{\func}\\
\returntype             &\triangleq& \langle \ty \rangle
\end{array}
\]
\end{definition}

We use $\tenv$ to range over static environments.

A static environment $\tenv=(G^\tenv, L^\tenv)$ consists of two
distinct components: the global environment $G^\tenv$---pertaining to AST nodes
appearing outside of a given subprogram, and the local environment
$L^\tenv$---pertaining to AST nodes appearing inside a given subprogram.
This separation allows us to typecheck subprograms by using an empty local environment.

The intuitive meaning of each component is as follows:
\begin{itemize}
  \hypertarget{def-declaredtypes}{}
  \item $\declaredtypes$ assigns types to their declared names;
  \hypertarget{def-constantvalues}{}
  \item $\constantvalues$ assigns literals to the their declaring (constant) names;
  \hypertarget{def-globalstoragetypes}{}
  \item $\globalstoragetypes$ associates names of global storage elements to their inferred type
  and how they were declared --- as constants, configuration variables, \texttt{let} variables,
  or mutable variables;
  \hypertarget{def-localstoragetypes}{}
  \item $\globalstoragetypes$ associates names of local storage elements to their inferred type
  and how they were declared --- as variables, constants, or as \texttt{let} variables;
  \hypertarget{def-subtypes}{}
  \item $\subtypes$ associates type names to the names that their type subtypes;
  \hypertarget{def-subprograms}{}
  \item $\subprograms$ associates names of subprograms to the $\func$ AST node they were
  declared with;
  \hypertarget{def-subprogramrenamings}{}
  \item $\subprogramrenamings$ associates names of subprograms to the set of overloading
  subprograms ---  $\func$ AST nodes that share the same name;
  \hypertarget{def-returntype}{}
  \item $\returntype$ contains the name of the type that a subprogram declares, if it is
  a function.
\end{itemize}

\hypertarget{def-emptytenv}{}
\begin{definition}[Empty Static Environment]
  The \emph{empty static environment}, \\ denoted as $\emptytenv$, is defined as follows:
  \[
    \emptytenv \triangleq \left(
      \begin{array}{c}
        \overname{
      (\overname{\emptyfunc}{\declaredtypes},
      \overname{\emptyfunc}{\constantvalues},
      \overname{\emptyfunc}{\globalstoragetypes},
      \overname{\emptyfunc}{\subtypes},
      \overname{\emptyfunc}{\subprograms},
      \overname{\emptyfunc}{\subprogramrenamings})}{G},\\
      \overname{
      (
        \overname{\emptyfunc}{\constantvalues},
        \overname{\emptyfunc}{\localstoragetypes},
        \overname{\None}{\returntype}
      )}{L}
      \enspace.
    \end{array}
    \right)
  \]
\end{definition}

The global environment and local environment consist of various components.
We use the notation $G^\tenv.m$ and $L^\tenv.m$ to access the $m$ component of a given environment.

To update a function component $f$ (e.g., $\declaredtypes$) of an environment $\tenv$ (either local or global)
with a new mapping $x \mapsto v$, we use the notation $\tenv.f[x \mapsto v]$ to stand for $\tenv[f \mapsto E.f[x \mapsto v]]$.

This is related to \identd{JRXM} and \identi{ZTMQ}.

\section{Constrained Types}
\begin{itemize}
  \item A \emph{constrained type} is a type whose definition depends on an expression, for example, certain integers and bitvectors.
  \item A type which is not constrained is \emph{unconstrained}.
  \item A constrained type with a non-empty constraint is \emph{well-constrained}.
  \item An \emph{under-constrained integer type} is an implicit type of a subprogram parameter.
  \end{itemize}
The widths of bitvector storage elements are constrained integers.

We define the following helper predicates to classify integer types:
\[
  \isunconstrainedinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto \Bool
\]

We define the following shorthands for classifying integers:
\[
  \begin{array}{rcl}
  \isunconstrainedinteger(\tenv, \vt) &\triangleq& \vt = \TInt(\unconstrained)\\
  \isunderconstrainedinteger(\tenv, \vt) &\triangleq& \vt = \TInt(\underconstrained)\\
  \iswellconstrainedinteger(\tenv, \vt) &\triangleq& \vt = \TInt(c) \land \astlabel(c)=\wellconstrained\\
\end{array}
\]

\subsection{Comments}
    This is related to \identd{ZTPP}, \identr{WJYH}, \identr{HJPN}, \identr{CZTX}, \identr{TPHR}

\section{ASL Type System}
\hypertarget{def-annotaterel}{}
The type system of ASL is given by the relation $\annotaterel$, which is defined as the disjoint union
of the partial functions and relations defined in this document.
The \hyperlink{def-partialfunc}{partial functions} and relations in this document are defined, in turn, via type system rules.

The output configurations of type assertions have two flavors:
\begin{description}
  \item[Normal Outputs.] \hypertarget{def-normal-type-outputs}{}
  Configurations are typically tuples with different combinations
  of \emph{static environments}, types, and Boolean values.

  \hypertarget{def-typeerror}{}
  \item[Type Errors.] Configurations in $\TypeError(\texttt{<string>})$
  represent type errors, for example, using an integer type as a condition expression, as in \verb|if 5 then 1 else 2|.
  The ASL type system is designed such that when these \emph{type error configurations} appear,
  the typing of the entire specification terminates by outputting them.
\end{description}

We define the mathematical type of type error configurations
(which is needed to define the types of functions in the ASL type system)
as follows:
\hypertarget{def-ttypeerror}{}
\[
  \TTypeError \triangleq \TypeError(\texttt{<string>})
\]

\hypertarget{def-typeerrorconfig}{}
and the shorthand $\TypeErrorConfig \triangleq \TypeError(\vs)$ for type error configurations.

\hypertarget{def-proseortypeerror}{}
\ProseOrTypeError\ means: ``or a type error configuration $\TypeErrorConfig$, which short-circuits the rule,
making it transition into the type error configuration $\TypeErrorConfig$.''\\
We use this when explaining rules in English prose.
%
When several \hyperlink{def-caserules}{case rules} for the same function use the same short-circuiting transition assertion,
we do not repeat the \ProseOrTypeError, but rather include it only in the first rule.

% \subsection*{Rule Example}
% The following rule is used to type a sequence of two statements:
% \[
% \inferrule{
%   \annotatestmt{\tenv, \vs1} = (\newsone, \tenvone)\\
%   \annotatestmt{\tenvone, \vs2} = (\newstwo, \tenvtwo)\\
% }
% {
%   \annotatestmt{\tenv, \SSeq(\vsone, \vstwo)} = (\SSeq(\newsone, \newstwo), \tenvtwo)
% }
% \]
% The rule uses the annotation function $\annotatestmt{\cdot}$, which
% accepts an environment $\tenv$ and two statements and returns a new statement and a new environment.
% The function returns a new statement in order to implement certain code transformations, such as
% inlining setter functions.

\section{Annotation}

Typing a specification consists of annotating the root of its AST. This is typically
done by traversing the AST bottom-up.  To annotate a node, the typing algorithm
finds a rule that matches the node---that is a rule whose conditions are
satisfied. If one such rule is found, the node is annotated by the result type
specified by the rule.  If no such rule is found, it is considered a \emph{typing error}
and the algorithm exits.

Sometimes it is necessary to define \emph{error rules} --- rules that result
in a type error and may provide extra information to help understand the reason for the
error.

We implement the process described above via a set of
\texttt{annotate\_<label>} functions. Each \texttt{annotate\_<label>}
function describes how to annotate an AST node, given its label, as follows:\begin{itemize}
\item \texttt{annotate\_expr} annotates expressions;
\item \texttt{annotate\_slices} annotates slices;
\item \texttt{annotate\_pattern} annotates pattern;
\item \texttt{annotate\_local\_decl\_item} annotates local declarations;
\item \texttt{annotate\_lexpr} annotates left-hand sides of assignments;
\item \texttt{annotate\_stmt} annotates statements;
\item \texttt{annotate\_block} annotates blocks;
\item \texttt{annotate\_catcher} annotates catchers;
\item \texttt{annotate\_call} annotates functions calls;
\item \texttt{annotate\_func} annotates functions.
\end{itemize}

\paragraph{Shorthand Notations:}
\newcommand\Elit[1]{\texttt{E}(#1)}
We use the shorthand $\Elit{n}$ for the expression denoting the literal integer value $n$. That is, $\ELiteral(\lint(n))$.

We use the shorthand notation $\unconstrainedinteger$ to denote the unconstrained integer type: $\TInt(\None)$.

Note that throughout this document we use $\tty$ to denote a type variable, which should not be confused with the abstract syntax variable $\ty$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Reading guide}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The definition of each \texttt{annotation\_<label>} function is given by a number of
rules, which follow the possible shapes the \texttt{label} can have. For
example, an expression can be a literal, or a binary operator, amongst other
things. Each of those has its own evaluation rule: TypingRule.ELit in
\secref{TypingRule.ELit} and
Typing.Binop in \secref{TypingRule.Binop}, respectively.

Each rule is presented using the following template:
\begin{itemize}
\item a Prose paragraph gives the rule in English, and corresponds as much as possible to the code of the reference implementation ASLRef given at
\href{https://github.com/herd/herdtools7//tree/master/asllib}{/herdtools7/asllib};
\item one or several Example paragraphs, which as much as possible are also given as regression tests in
\href{https://github.com/herd/herdtools7//tree/master/asllib/tests/ASLTypingReference.t}{/herdtools7/asllib/tests/ASLTypingReference.t};
\ifcode
\item a Code paragraph which gives a verbatim of the corresponding OCaml implementation in the type-checker of ASLRef
\href{https://github.com/herd/herdtools7//tree/master/asllib/Typing.ml}{/herdtools7/asllib/Typing.ml};
\fi
\item Formal paragraphs which give formal definitions of the rule.
\item Comments paragraphs which may refer to one or more statements from the Language Reference Manual~\cite{LRM}
      and may add more information.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Domain of Values for Types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter formalises the concept of the set of values for a given type.
The formalism is given in the form of rules.
%
The chapter also defines the concept of checking whether the set of values
for one type is included in the set of values for another type.

\hypertarget{def-vals}{}
\section{Native Values \label{sec:nativevalues}}

Types define sets of values that variables can take when a specification is executed.
To formalize this, we define the set of \emph{native values}, denoted $\vals$,
as the minimal set defined by the following recursive rules (\texttt{NV} stands for Native Value):
\hypertarget{def-nvliteral}{}
\hypertarget{def-nvvector}{}
\hypertarget{def-nvrecord}{}
\begin{mathpar}
  \inferrule[(Basis Set: Integers, Reals, Booleans, Strings, and Bitvectors)]
  {\vv \in \literal}
  { \nvliteral{\vv} \in \vals }
  \and
  \inferrule[(Tuple Values and Array Values)]{\vvl \in \vals^*}
  { \nvvector{\vvl} \in \vals }
  \and
  \inferrule[(Record Values)]
  {\vr : \Identifiers \rightarrowfin \vals}
  { \nvrecord{\vr} \in \vals }
\end{mathpar}

We define the following shorthands for native value literals:
\hypertarget{def-nvint}{}
\[
\begin{array}{rcl}
\nvint(z)       &\triangleq& \nvliteral{\lint(z)}           \hypertarget{def-nvbool}{}\\
\nvbool(b)      &\triangleq& \nvliteral{\lbool(b)}          \hypertarget{def-nvreal}{}\\
\nvreal(r)      &\triangleq& \nvliteral{\lreal(r)}          \hypertarget{def-nvstring}{}\\
\nvstring(s)    &\triangleq& \nvliteral{\lstring(s)}        \hypertarget{def-nvbitvector}{}\\
\nvbitvector(v) &\triangleq& \nvliteral{\lbitvector(v)}\\
\end{array}
\]

We define the following types of native values:
\hypertarget{def-tint}{}
\[
\begin{array}{rcl}
  \tint       &\triangleq& \{ \nvint(z) \;|\; z \in \Z\}                                        \hypertarget{def-tbool}{}\\
  \tbool      &\triangleq& \{ \nvbool(\True), \nvbool(\False) \}                                \hypertarget{def-treal}{}\\
  \treal      &\triangleq& \{ \nvreal(r) \;|\; r \in \Q\}                                       \hypertarget{def-tstring}{}\\
  \tstring    &\triangleq& \{ \nvstring(s) \;|\; \texttt{"}s\texttt{"} \in \texttt{<string>}\}  \hypertarget{def-tbitvector}{}\\
  \tbitvector &\triangleq& \{ \nvbitvector(\textit{bits}) \;|\; \textit{bits} \in \{0,1\}^*\}   \hypertarget{def-tvector}{}\\
  \tvector    &\triangleq& \{ \nvvector{\textit{vals}} \;|\; \textit{vals} \in \vals^*\}        \hypertarget{def-trecord}{}\\
  \trecord  &\triangleq& \{ \nvrecord{\fieldmap} \;|\; \fieldmap \in \Identifiers\rightarrow\vals\}\\
\end{array}
\]

\section{Dynamic Domain of a Type}
\hypertarget{def-dyndomain}{}

We now define the concept of a \emph{dynamic domain} of a type
and the \emph{static domain} of a type.
Intuitively, domains assign potentially infinite sets of native values to types.
Dynamic domains are used by the semantics to evaluate expressions of the form \texttt{UNKNOWN: t}
by choosing a single value from the dynamic domain of $\vt$.
Static domains are used to define (domain) subtype satisfaction in \secref{TypingRule.DomainSubtypeSatisfaction}.

\hypertarget{def-dynamicenvs}{}
The definition of a dynamic domain refers to \emph{dynamic environments}, denoted $\dynamicenvs$,
which assigns native values to identifiers~\cite{ASLSemanticsReference}.

\hypertarget{def-envs}{}
We define \emph{environments} as pairs of static environments and dynamic environments:
$\envs = \staticenvs \times \dynamicenvs$.

Formally, the partial function
\[
  \dynamicdomain : \overname{\envs}{\env} \times \overname{\ty}{\vt}
  \partialto \overname{\pow{\vals}}{\vd}
\]
assigns the set of values that a type $\vt$ can hold in a given environment $\env$.
%
We say that $\dynamicdomain(\env, \vt)$ is the \emph{dynamic domain} of $\vt$
in the environment $\env$.
%
The \emph{static domain} of a type is the set of values which storage elements of that type may hold
\underline{across all possible dynamic environments}.
%
The reason that for this distinction is that the sets of values
considered for bitvector types, array types, constrained integers, and constrained bitvectors,
can depend on the dynamic values of variables.

Types that do not refer to variables whose values are only known dynamically have
a static domain that is equal to any of their dynamic domains.
In those cases, we simply refer to their \emph{domain}.

Associating a set of values to a type is done by evaluating any expression appearing
in the type definitions. Evaluation is done using the ASL semantics~\cite{ASLSemanticsReference},
more specifically via the relation
\[
  \evalexprsef{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
  \Normal(\overname{\vals}{\vv}\aslsep\overname{\XGraphs}{\vg}) \cup
  \overname{\TError}{\ErrorConfig}
\]
which evaluates side-effect-free expressions and either returns
a configuration of the form $\Normal(\vv,\vg)$ or a dynamic error.
In the first case, $\vv$ is a native value and $\vg$
is an \emph{execution graph}. Execution graphs are related to the concurrent semantics
and can be ignored in the context of defining dynamic domains.
In the latter case (which can occur if, for example, an expression attempts to divide
\texttt{8} by \texttt{3}), a dynamic error configuration for which we use the notation
$\ErrorConfig$ is returned.
%
The dynamic domain is undefined in cases where evaluating side-effect-free expressions
results in a dynamic error.
%
The dynamic domain is also undefined if the given type $\vt$ is not well-typed in $\tenv$.
That is, if $\annotatetype{\tenv, \vt} \typearrow \TypeErrorConfig$.

As part of the definition, we also associate dynamic domains to integer constraints
by overloading $\dynamicdomain$:
\[
  \dynamicdomain : \overname{\envs}{\env} \times \overname{\intconstraint}{\vc}
  \partialto \overname{\pow{\vals}}{\vd}
\]

\subsection{Prose}
For an environment $\env \in \envs$ and a type $\vt$, the domain is $\vd$ and one of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{t\_bool}):
  \begin{itemize}
    \item $\vt$ is the Boolean type, $\TBool$;
    \item $\vd$ is the set of native Boolean values, $\tbool$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_string}):
  \begin{itemize}
    \item $\vt$ is the string type, $\TString$;
    \item $\vd$ is the set of all native string values, $\tstring$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_real}):
  \begin{itemize}
    \item $\vt$ is the real type, $\TReal$;
    \item $\vd$ is the set of all native real values, $\treal$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_enumeration}):
  \begin{itemize}
    \item $\vt$ is the enumeration type with labels $\id_{1..k}$, that is $\TEnum(\id_{1..k})$;
    \item $\vd$ is the set of all native integer values for $1..k$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_unconstrained}):
  \begin{itemize}
    \item $\vt$ is the unconstrained integer type, $\TInt(\unconstrained)$;
    \item $\vd$ is the set of all native integer values, $\tint$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_well\_constrained}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type $\TInt(\wellconstrained(\vc_{1..k}))$;
    \item $\vd$ is the union of the dynamic domains of each of the constraints $vc_{1..k}$ in $\env$.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_exact}):
  \begin{itemize}
    \item $\vc$ is a constraint consisting of a single side-effect-free expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $n$;
    \item $\vd$ is the set containing the single native integer value for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{constraint\_range}):
  \begin{itemize}
    \item $\vc$ is a range constraint consisting of a two side-effect-free expressions $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item evaluating $\veone$ in $\env$, results in a configuration with the native integer for $a$;
    \item evaluating $\vetwo$ in $\env$, results in a configuration with the native integer for $b$;
    \item $a$ is less than or equal to $b$;
    \item $\vd$ is the set containing all native integer values for integers from $a$ to $b$, inclusive.
  \end{itemize}

  \item All of the following apply (\textsc{t\_int\_underconstrained}):
  \begin{itemize}
    \item $\vt$ is an under constrained integer for parameter $\id$, \\ $\TInt(\underconstrained(\id))$;
    \item the native value associated with $\id$ in the local dynamic environment is the native integer value for $n$;
    \item $\vd$ is the set containing the single integer value for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_empty}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $0$;
    \item $\vd$ is the set containing the single native value for an empty bitvector.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits\_non\_empty}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with size expression $\ve$, $\TBits(\ve, \Ignore)$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $k$ is greater than $0$;
    \item $\vd$ is the set containing all native values for bitvectors of size exactly $k$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
    \item $\vt$ is a tuple type over types $\vt_i$, for $i=1..k$, $\TTuple(\vt_{1..k})$;
    \item the domain of each element $\vt_i$ is $D_i$, for $i=1..k$;
    \item evaluating $\ve$ in $\env$, results in a configuration with the native integer for $k$;
    \item $\vd$ is the set containing all native vectors of $k$ values, where the value at position $i$
    is from $D_i$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array}):
  \begin{itemize}
    \item $\vt$ is an array type with length expression $\ve$ and element type $\vt_i$, for $i=1..k$, $\TArray(\ve, \vtone)$;
    \item the domain of $\vtone$ is $D_\vtone$;
    \item $\vd$ is the set containing all native vectors of $k$ values taken from $D_\vtone$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_structured}):
  \begin{itemize}
    \item $\vt$ is either a record type or an exception type with typed fields $(\id_i, \vt_i$, for $i=1..k$, that is $L([i=1..k: (\id_i,\vt_i))]$
    where $L\in\{\TRecord, \TException\}$;
    \item the domain of each type $\vt_i$ is $D_i$, for $i=1..k$;
    \item $\vd$ is the set containing all native records where $\id_i$ is mapped to a value taken from $D_i$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_named}):
  \begin{itemize}
    \item $\vt$ is a named type with name $\id$, $\TNamed(\id)$;
    \item the type associated with $\id$ in $\tenv$ is $\tty$;
    \item $\vd$ is the domain of $\tty$ in $\env$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
The rules below define $\dynamicdomain$. Notice that if a specification is not well-typed then
the static evaluation of expressions may return an error configuration. Such cases are not
handled by the rules below, which leaves the dynamic domain undefined for the respective types.

\begin{mathpar}
\inferrule[t\_bool]{}{ \dynamicdomain(\env, \TBool) = \tbool }
\and
\inferrule[t\_string]{}{ \dynamicdomain(\env, \TString) = \tstring }
\and
\inferrule[t\_real]{}{ \dynamicdomain(\env, \TReal) = \treal }
\and
\inferrule[t\_enumeration]{}{
  \dynamicdomain(\env, \TEnum(\id_{1..k})) = \{\nvint(1),\ldots,\nvint(k)\}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[t\_int\_unconstrained]{}{
  \dynamicdomain(\env, \TInt(\unconstrained)) = \tint
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_int\_well\_constrained]{}{
  \dynamicdomain(\env, \TInt(\wellconstrained(\vc_{1..k}))) = \bigcup_{i=1}^k \dynamicdomain(\env, \vc_i)
}
\end{mathpar}

\begin{mathpar}
\inferrule[constraint\_exact]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(n), \Ignore)
}{
  \dynamicdomain(\env, \ConstraintExact(\ve)) = \{ \nvint(n) \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constraint\_range]{
  \evalexprsef{\env, \veone} \evalarrow \Normal(\nvint(a), \Ignore)\\
  \evalexprsef{\env, \vetwo} \evalarrow \Normal(\nvint(b), \Ignore)\\
  a \leq b
}{
  \dynamicdomain(\env, \ConstraintRange(\veone, \vetwo)) = \{ \nvint(n) \;|\;  a \leq n \leq b\}
}
\end{mathpar}

The notation $L^\denv(\id)$ denotes the native value associated with the identifier $\id$
in the \emph{local dynamic environment} of $\denv$.
\begin{mathpar}
  \inferrule[t\_int\_underconstrained]{
  L^\denv(\id) = \nvint(n)
}{
  \dynamicdomain(\env, \TInt(\underconstrained(\id))) = \{ \nvint(n) \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits\_empty]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(0), \Ignore)
}{
  \dynamicdomain(\env, \TBits(\ve, \Ignore)) = \{ \nvbitvector(\emptylist) \}
}
\and
\inferrule[t\_bits\_non\_empty]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
  k > 0
}{
  \dynamicdomain(\env, \TBits(\ve, \Ignore)) = \{ \nvbitvector(\vb_{1..k}) \;|\; \vb_1,\ldots,\vb_k \in \{0,1\} \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  i=1..k: \dynamicdomain(\env, \vt_i) = D_i
}{
  \dynamicdomain(\env, \TTuple(\vt_{1..k})) =
  \{ \nvvector{\vv_{1..k}} \;|\; \vv_i \in D_i \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array]{
  \dynamicdomain(\env, \vtone) = D_\vtone\\
  \evalexprsef{\env, \ve} \evalarrow \Normal(\nvint(k), \Ignore)\\
}{
  \dynamicdomain(\env, \TArray(\ve, \vtone)) =
  \{ \nvvector{\vv_{1..k}} \;|\; \vv_{1..k} \in D_{\vtone} \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\
  i=1..k: \dynamicdomain(\env, \vt_i) = D_i
}{
  \dynamicdomain(\env, L([i=1..k: (\id_i,\vt_i))]) = \\
  \{ \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}} \;|\; \vv_i \in D_i \}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_named]{
  G^\tenv.\declaredtypes(\id)=\tty
}{
  \dynamicdomain(\env, \TNamed(\id)) = \dynamicdomain(\env, \tty)
}
\end{mathpar}

\subsection{Example}
The domain of \texttt{integer} is the infinite set of all integers.

The domain of \texttt{bits(1)} is the set $\{\nvint(1), \nvint(2)\}$.

The domain of \verb|integer {2,16}| is the set $\{\nvint(2), \nvint(16)\}$.

The domain of \verb|enumeration {GREEN, ORANGE, RED}| is the set \\
$\{\nvint(1), \nvint(2), \nvint(3)\}$ and so is the domain
of \\
\verb|type TrafficLights of enumeration {GREEN, ORANGE, RED}|.

The domain of \texttt{bits({2,16})} is the set containing native bitvectors of all 2-bit and all 16-bit binary sequences.

The domain of \texttt{(integer, integer)} is the set containing all pairs of native integer values.

The domain of \verb|record {a: integer;  b: boolean}| contains all native records
that map \texttt{a} to a native integer value and \texttt{b} to a native Boolean value.

The dynamic domain of a subprogram parameter \texttt{N: integer} is the (singleton) set containing
the native integer value $c$,
which is assigned to \texttt{N} by a given dynamic environment. The static domain of that parameter
is the infinite set of all native integer values.

This is related to \identd{BMGM}, \identr{PHRL}, \identr{PZNR},
\identr{RLQP}, \identr{LYDS}, \identr{SVDJ}, \identi{WLPJ}, \identr{FWMM},
\identi{WPWL}, \identi{CDVY}, \identi{KFCR}, \identi{BBQR}, \identr{ZWGH},
\identr{DKGQ}, \identr{DHZT}, \identi{HSWR}, \identd{YZBQ}.

\section{Subsumption Testing}
Whether an assignment statement is well-typed depends on whether the dynamic domain of the
right hand side type is contained in the dynamic domain of the left hand side type,
for any given dynamic environment
(see \secref{TypingRule.DomainSubtypeSatisfaction} where this is checked).

\begin{definition}[Subsumption]
For any given types $\vt$ and $\vs$ and static environment $\tenv$,
we say that $\vt$ \emph{subsumes} $\vs$ in $\tenv$,
if the following condition holds:
\hypertarget{def-subsumes}{}
\begin{equation}
  \subsumes(\tenv, \vt, \vs) \triangleq \forall \denv\in\dynamicenvs.\ \dynamicdomain((\tenv, \denv), \vt) \supseteq \dynamicdomain((\tenv, \denv), \vs) \enspace.
\end{equation}
\end{definition}

For example, consider the assignment
\begin{center}
\verb|var x : integer{1,2,3} = UNKNOWN : integer{1,2};|
\end{center}

It is legal, since (in any static environment), the domain of \verb|integer{1,2,3}|
is \\
$\{\nvint(1), \nvint(2), \nvint(3)\}$, which subsumes
the domain of \verb|integer{1,2}|, which is \\ $\{\nvint(1), \nvint(2)\}$.

Since dynamic domains are potentially infinite, this requires \emph{symbolic reasoning}.
Furthermore, since any (statically evaluable) expressions may appear inside integer and bitvector
types, testing subsumption is undecidable.
We therefore approximate subsumption testing \emph{conservatively} via the predicate $\symsubsumes(\tenv, \vt, \vs)$.

\begin{definition}[Sound Subsumption Test]
A predicate
\[
  \symsubsumes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs}) \aslto \Bool
\]
is \emph{sound} if the following condition holds:
\begin{equation}
  \begin{array}{l}
  \forall \vt,\vs\in\ty.\ \tenv\in\staticenvs. \\
  \;\;\;\; \symsubsumes(\tenv, \vt, \vs) \typearrow \True \;\Longrightarrow\; \subsumes(\tenv, \vt, \vs)  \enspace.
  \end{array}
\end{equation}
\end{definition}

That is, if a sound subsumption test returns a positive answer, it means that
$\vt$ definitely \emph{subsumes} $\vs$ in the static environment $\tenv$.
This is referred to as a \emph{true positive}.
However, a negative answer means one of two things:
\begin{description}
  \item[True Negative:] indeed, $\vt$ does not subsume $\vs$ in the static environment $\tenv$; or
  \item[False Negative:] the symbolic reasoning is unable to decide.
\end{description}

In other words, $\symsubsumes(\tenv, \vt, \vs)$ errs on the \emph{safe side} ---
it never answers $\True$ when the real answer is $\False$, which would (undesirably)
determine the following statement as well-typed:
\begin{center}
  \verb|var x : integer{1,2} = integer;|
\end{center}

A sound but trivial subsumption test is one that always returns $\False$.
However, that would make many useful examples, such as the one above,
be considered as not well-typed. Indeed, it has the maximal set of false negatives.
Reducing the set of false negatives requires stronger symbolic reasoning algorithms,
which inevitably leads to higher computational complexity.
%
The symbolic subsumption test in \chapref{symbolicsubsumptiontesting}
attempts to accept a large enough set of true positives, based on empirical trial and error,
while maintaining the computational complexity of the symbolic reasoning relatively low.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basic Type Attributes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter defines some basic predicates for classifying types as well as
functions that inspect the structure of types:
\begin{itemize}
  \item Builtin singular types (\secref{TypingRule.BuiltinSingularType})
  \item Builtin aggregate types (\secref{TypingRule.BuiltinAggregateType})
  \item Buitin types (\secref{TypingRule.BuiltinSingularOrAggregate})
  \item Named types (\secref{TypingRule.NamedType})
  \item Anonymous types (\secref{TypingRule.AnonymousType})
  \item Singular types (\secref{TypingRule.SingularType})
  \item Aggregate types (\secref{TypingRule.AggregateType})
  \item Non-primitive types (\secref{TypingRule.NonPrimitiveType})
  \item Primitive types (\secref{TypingRule.PrimitiveType})
  \item The structure of a type (\secref{structure})
  \item The underlying type of a type (\secref{anonymize})
\end{itemize}

\section{TypingRule.BuiltinSingularType \label{sec:TypingRule.BuiltinSingularType}}
\hypertarget{def-isbuiltinsingular}{}
The predicate
\[
  \isbuiltinsingular(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{builtin singular type}.

\subsection{Prose}
The \emph{builtin singular types} are:
\begin{itemize}
\item \texttt{integer};
\item \texttt{real};
\item \texttt{string};
\item \texttt{boolean};
\item \texttt{bits} (which also represents \texttt{bit}, as a special case);
\item \texttt{enumeration}.
\end{itemize}

\subsection{Example: TypingRule.BuiltinSingularTypes.asl}

In this example:
\VerbatimInput[firstline=3,lastline=8]{\tests/TypingRule.BuiltinSingularTypes.asl}

Variables of builtin singular types \texttt{integer}, \texttt{real},
\texttt{boolean}, \texttt{bits(4)}, \\ and~\texttt{bits(2)} are defined.

\subsection{Example: TypingRule.EnumerationType.asl}
\VerbatimInput{\tests/TypingRule.EnumerationType.asl}
The builtin singular type \texttt{color} consists in two constants
\texttt{RED}, and~\texttt{BLACK}.

\CodeSubsection{\BuiltinSingularBegin}{\BuiltinSingularEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef \astlabel(\tty) \in \{\TReal, \TString, \TBool, \TBits, \TEnum, \TInt\}
}{
  \isbuiltinsingular(\tty) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identd{PQCK} and \identd{NZWT}.

\section{TypingRule.BuiltinAggregateType \label{sec:TypingRule.BuiltinAggregateType}}
\hypertarget{def-isbuiltinaggregate}{}
The predicate
\[
  \isbuiltinaggregate(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{builtin aggregate type}.

\subsection{Prose}
The builtin aggregate types are:
\begin{itemize}
\item tuple;
\item \texttt{array};
\item \texttt{record};
\item \texttt{exception}.
\end{itemize}

\subsection{Example: TypingRule.BuiltinAggregateTypes.asl}
\VerbatimInput{\tests/TypingRule.BuiltinAggregateTypes.asl}
Type \texttt{pair} is the type of integer and booleans pairs.

Arrays are indexed either by integers from 0 to (array size minus $1$) as
specified in type declaration, as illustrated by the type \texttt{T}, or by the
elements of an enumeration type, as illustrated by type~\texttt{pointCoord}.

The (builtin aggregate) type~\texttt{pointRecord} is defined as a record type with three fields
$\vx$, \texttt{y} and~\texttt{z}.

\subsection{Example: TypingRule.BuiltinExceptionType.asl}
\VerbatimInput{\tests/TypingRule.BuiltinExceptionType.asl}
Two (builtin aggregate) exception types are defined: exceptions \texttt{Not\_found} carry no
values, while exceptions \texttt{Error}  carry a message. Notice the
similarity with record types and that the empty field list \verb|{}| can be
omitted in type declarations, as is the case for \texttt{Not\_found}.

\CodeSubsection{\BuiltinAggregateBegin}{\BuiltinAggregateEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{ \vb \eqdef \astlabel(\tty) \in \{\TTuple, \TArray, \TRecord, \TException\} }
{ \isbuiltinaggregate(\tty) \typearrow \vb }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identd{PQCK} and \identd{KNBD}.

\section{TypingRule.BuiltinSingularOrAggregate \label{sec:TypingRule.BuiltinSingularOrAggregate}}
\hypertarget{def-isbuiltin}{}
The predicate
\[
  \isbuiltin(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{builtin type}.

\subsection{Prose}
$\tty$ is a builtin type and one of the following applies:
\begin{itemize}
\item $\tty$ is singular;
\item $\tty$ is builtin aggregate.
\end{itemize}

\subsection{Example}
In ``\texttt{type ticks of integer;}'', the type \texttt{integer} is a builtin type but the named type \texttt{ticks} is not.

\CodeSubsection{\BuiltinSingularOrAggregateBegin}{\BuiltinSingularOrAggregateEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \isbuiltinsingular(\tty) \typearrow \vbone\\
    \isbuiltinaggregate(\tty) \typearrow \vbtwo
  }{
    \isbuiltin(\tty) \typearrow \vbone \lor \vbtwo
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.NamedType \label{sec:TypingRule.NamedType} }
\hypertarget{def-isnamed}{}
The predicate
\[
  \isnamed(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{named type}.

\subsection{Prose}
A named type is a type that is declared by using the \texttt{type of} syntax.

\subsection{Example}
The type \texttt{ticks} in ``\texttt{type ticks of integer;}'' is a named type.

\CodeSubsection{\NamedBegin}{\NamedEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \vb \eqdef \astlabel(\tty) = \TNamed
}{
  \isnamed(\tty) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identd{vmzx}.

\section{TypingRule.AnonymousType \label{sec:TypingRule.AnonymousType}}
\hypertarget{def-isanonymous}{}
The predicate
\[
  \isanonymous(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is an \emph{anonymous type}.

\subsection{Prose}
An anonymous type is a type that is not declared using the type syntax.

\subsection{Example}
The tuple type \texttt{(integer, integer)} is an anonymous type.

\CodeSubsection{\AnonymousBegin}{\AnonymousEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{ \vb \eqdef \astlabel(\tty) \neq \TNamed }
{ \isanonymous(\tty) \typearrow \vb }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identd{VMZX}.

\section{TypingRule.SingularType \label{sec:TypingRule.SingularType}}
\hypertarget{def-issingular}{}
The predicate
\[
  \issingular(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \;\aslto\; \Bool \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the type $\tty$ is a \emph{singular type} in the static environment $\tenv$.

\subsection{Prose}
A type $\tty$ is singular if one of the following applies:
\begin{itemize}
  \item $\tty$ is a builtin singular type;
  \item All of the following apply:
  \begin{itemize}
    \item $\tty$ is a named type;
    \item obtaining the \structure\ of $\tty$ in the environment $\tenv$ yields $\vtone$ \ProseOrTypeError;
    \item $\vtone$ is a builtin singular type.
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following example, the types \texttt{A}, \texttt{B}, and \texttt{C} are all singular types:
\begin{verbatim}
type A of integer;
type B of A;
type C of B;
\end{verbatim}

\CodeSubsection{\SingularBegin}{\SingularEnd}{../types.ml}
\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \isbuiltin(\tty) \typearrow \vbone\\
  \isnamed(\tty) \typearrow \vbtwo\\
  \tstruct(\tenv, \vt) \typearrow \vtone \OrTypeError\\\\
  \isbuiltinsingular(\vtone) \typearrow \vbthree
}{
\issingular(\tenv, \tty) \typearrow \vbone \lor (\vbtwo \land \vbthree)
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identr{GVZK}.

\section{TypingRule.AggregateType \label{sec:TypingRule.AggregateType}}
\hypertarget{def-isbuiltinaggregate}{}
The predicate
\[
  \isaggregate(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \;\aslto\; \Bool \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the type $\tty$ is an \emph{aggregate type} in the static environment $\tenv$.

\subsection{Prose}
A type $\tty$ is aggregate in an environment $\tenv$ if one of the following applies:
\begin{itemize}
\item $\tty$ is a builtin aggregate type;
\item All of the following apply:
  \begin{itemize}
  \item $\tty$ is a named type;
  \item obtaining the \structure\ of $\tty$ in the environment $\tenv$ yields $\vtone$ \ProseOrTypeError;
  \item $\vtone$ is a builtin aggregate.
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following example, the types \texttt{A}, \texttt{B}, and \texttt{C} are all aggregate types:
\begin{verbatim}
type A of (integer, integer);
type B of A;
type C of B;
\end{verbatim}

\CodeSubsection{\AggregateBegin}{\AggregateEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \isbuiltinaggregate(\tty) \typearrow \vbone\\
  \isnamed(\tty) \typearrow \vbtwo\\
  \tstruct(\tenv, \tty) \typearrow \vtone \OrTypeError\\\\
  \isbuiltinaggregate(\vtone) \typearrow \vbthree
}{
  \isaggregate(\tenv, \tty) \typearrow \vbone \lor (\vbtwo \land \vbthree)
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identr{GVZK}.

\section{TypingRule.NonPrimitiveType \label{sec:TypingRule.NonPrimitiveType}}
\hypertarget{def-isnonprimitive}{}
The predicate
\[
  \isnonprimitive(\overname{\ty}{\tty}) \;\aslto\; \overname{\Bool}{\vb}
\]
tests whether the type $\tty$ is a \emph{non-primitive type}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{singular}):
  \begin{itemize}
  \item $\tty$ is a builtin singular type;
  \item $\vb$ is $\False$.
  \end{itemize}
  \item All of the following apply (\textsc{named}):
  \begin{itemize}
    \item $\tty$ is a named type;
    \item $\vb$ is $\True$.
  \end{itemize}
  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\tty$ is a tuple type $\vli$;
    \item $\vb$ is $\True$ if and only if there exists a non-primitive type in $\vli$.
  \end{itemize}
  \item All of the following apply (\textsc{array}):
    \begin{itemize}
    \item $\tty$ is an array of type $\tty'$
    \item $\vb$ is $\True$ if and only if $\tty'$ is non-primitive.
    \end{itemize}
  \item All of the following apply (\textsc{structured}):
    \begin{itemize}
    \item $\tty$ is a record or exception with fields $\fields$;
    \item $\vb$ is $\True$ if and only if there exists a non-primitive type in $\fields$.
    \end{itemize}
\end{itemize}

\subsection{Example}
The following types are non-primitive:

\begin{tabular}{ll}
\textbf{Type definition} & \textbf{Reason for being non-primitive}\\
\hline
\texttt{type A of integer}  & Named types are non-primitive\\
\texttt{(integer, A)}       & The second component, \texttt{A}, has non-primitive type\\
\texttt{array[6] of A}      & Element type \texttt{A} has a non-primitive type\\
\verb|record { a : A }|     & The field \texttt{a} has a non-primitive type
\end{tabular}

\CodeSubsection{\NonPrimitiveBegin}{\NonPrimitiveEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
The cases \textsc{tuple} and \textsc{structured} below, use the notation $\vb_\vt$ to name
Boolean variables by using the types denoted by $\vt$ as a subscript.
\begin{mathpar}
  \inferrule[singular]{
    \astlabel(\tty) \in \{\TReal, \TString, \TBool, \TBits, \TEnum, \TInt\}
  }
  {
    \isnonprimitive(\tty) \typearrow \False
  }
  \and
  \inferrule[named]{\astlabel(\tty) = \TNamed}{\isnonprimitive(\tty) \typearrow \True}
  \and
  \inferrule[tuple]{
    \vt \in \vli: \isnonprimitive(\vt) \typearrow \vb_{\vt}\\
    \vb \eqdef \bigvee_{\vt \in \vli} \vb_{\vt}
  }{
    \isnonprimitive(\TTuple(\vli)) \typearrow \vb
  }
  \and
  \inferrule[array]{
    \isnonprimitive(\tty') \typearrow \vb
  }{
    \isnonprimitive(\TArray(\Ignore, \tty')) \typearrow \vb
  }
  \and
  \inferrule[structured]{
    L \in \{\TRecord, \TException\}\\
    (\Ignore,\vt) \in \fields : \isnonprimitive(\vt) \typearrow \vb_\vt\\
    \vb \eqdef \bigvee_{\vt \in \vli} \vb_{\vt}
  }{
    \isnonprimitive(L(\fields)) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identd{GWXK}.

\section{TypingRule.PrimitiveType \label{sec:TypingRule.PrimitiveType}}
\hypertarget{def-isprimitive}{}
The predicate
\[
  \isprimitive(\overname{\ty}{\tty}) \;\aslto\; \Bool
\]
tests whether the type $\tty$ is a \emph{primitive type}.

\subsection{Prose}
A type $\tty$ is primitive if it is not non-primitive.

\subsection{Example}
The following types are primitive:

\begin{tabular}{ll}
\textbf{Type definition} & \textbf{Reason for being non-primitive}\\
\hline
\texttt{integer} & Integers are primitive\\
\texttt{(integer, integer)} & All tuple elements are primitive\\
\texttt{array[5] of integer} & The array element type is primitive\\
\verb|record {ticks : integer}| & The single field \texttt{ticks} has a primitive type
\end{tabular}

\CodeSubsection{\PrimitiveBegin}{\PrimitiveEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \isnonprimitive(\tty) \typearrow \vb
}{
  \isprimitive(\tty) \typearrow \neg\vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identd{GWXK}.

\section{TypingRule.Structure \label{sec:structure}}
\hypertarget{def-structure}{}
The function
\[
  \tstruct(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \aslto \overname{\ty}{\vt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
assigns a type to its \hypertarget{def-tstruct}{\emph{\structure}}, which is the type formed by
recursively replacing named types by their type definition in the static environment $\tenv$.
If a named type is not associated with a declared type in $\tenv$, a type error is returned.

TypingRule.Specification ensures the absence of circular type definitions,
which ensures that TypingRule.Structure terminates\footnote{In mathematical terms,
this ensures that TypingRule.Structure is a proper \emph{structural induction.}}.

\subsection{Prose}
One of the following applies:
\begin{itemize}
\item All of the following apply (\textsc{named}):
  \begin{itemize}
  \item $\tty$ is a named type $\vx$;
  \item obtaining the declared type associated with $\vx$ in the static environment $\tenv$ yields $\vtone$ \ProseOrTypeError;
  \item obtaining the structure of $\vtone$ static environment $\tenv$ yields $\vt$ \ProseOrTypeError;
  \end{itemize}
\item All of the following apply (\textsc{builtin\_singular}):
  \begin{itemize}
  \item $\tty$ is a builtin singular type;
  \item $\vt$ is $\tty$.
  \end{itemize}
\item All of the following apply (\textsc{tuple}):
  \begin{itemize}
  \item $\tty$ is a tuple type with list of types $\tys$;
  \item the types in $\tys$ are indexed as $\vt_i$, for $i=1..k$;
  \item obtaining the structure of each type $\vt_i$, for $i=1..k$, in $\tys$ in the static environment $\tenv$,
  yields $\vtp_i$ \ProseOrTypeError;
  \item $\vt$ is a tuple type with the list of types $\vtp_i$, for $i=1..k$.
  \end{itemize}
\item All of the following apply (\textsc{array}):
  \begin{itemize}
    \item $\tty$ is an array type of length $\ve$ with element type $\vt$;
    \item obtaining the structure of $\vt$ yields $\vtone$ \ProseOrTypeError;
    \item $\vt$ is is an array type with of length $\ve$ with element type $\vtone$.
  \end{itemize}
\item All of the following apply (\textsc{structured}):
  \begin{itemize}
  \item $\tty$ is either a record or an exception with fields $\fields$;
  \item obtaining the structure for each type $\vt$ associated with field $\id$ yields a type $\vt_\id$ \ProseOrTypeError;
  \item $\vt$ is a record or an exception, in correspondence to $\tty$, with the list of pairs $(\id, \vt\_\id)$;
  \end{itemize}
\end{itemize}

\subsection{Example}
In this example:
\texttt{type T1 of integer;} is the named type \texttt{T1}
whose structure is \texttt{integer}.

In this example:
\texttt{type T2 of (integer, T1);}
is the named type \texttt{T2} whose structure is (integer, integer). In this
example, \texttt{(integer, T1)} is non-primitive since it uses \texttt{T1}, which is builtin aggregate.

In this example:
\texttt{var x: T1;}
the type of $\vx$ is the named (hence non-primitive) type \texttt{T1}, whose structure
is \texttt{integer}.

In this example:
\texttt{var y: integer;}
the type of \texttt{y} is the anonymous primitive type \texttt{integer}.

In this example:
\texttt{var z: (integer, T1);}
the type of \texttt{z} is the anonymous non-primitive type
\texttt{(integer, T1)} whose structure is \texttt{(integer, integer)}.

\CodeSubsection{\StructureBegin}{\StructureEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[named]{
  \declaredtype(\tenv, \vx) \typearrow \vtone \OrTypeError\\\\
  \tstruct(\tenv, \vtone)\typearrow\vt \OrTypeError
}{
  \tstruct(\tenv, \TNamed(\vx)) \typearrow \vt
}
\and
\inferrule[builtin\_singular]{
  \isbuiltinsingular(\tty) \typearrow \True
}{
  \tstruct(\tenv, \tty) \typearrow \tty
}
\and
\inferrule[tuple]{
  \tys \eqname \vt_{1..k}\\
  i=1..k: \tstruct(\tenv, \vt_i) \typearrow \vtp_i \OrTypeError
}{
  \tstruct(\tenv, \TTuple(\tys)) \typearrow  \TTuple(i=1..k: \vtp_i)
}
\and
\inferrule[array]{
  \tstruct(\tenv, \vt) \typearrow \vtone \OrTypeError
}{
  \tstruct(\tenv, \TArray(\ve, \vt)) \typearrow \TArray(\ve, \vtone)
}
\and
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\\\
  (\id,\vt) \in \fields : \tstruct(\tenv, \vt) \typearrow \vt_\id \OrTypeError
}{
  \tstruct(\tenv, L(\fields)) \typearrow
 L([ (\id,\vt) \in \fields : (\id,\vt_\id) ])
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identd{FXQV}.

\section{TypingRule.Anonymize \label{sec:anonymize}}
\hypertarget{def-makeanonymous}{}
\hypertarget{def-underlyingtype}{}
The function
\[
  \makeanonymous(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}) \aslto \overname{\ty}{\vt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the \emph{\underlyingtype} --- $\vt$ --- of the type $\tty$ in the static environment $\tenv$ or a type error.
Intuitively, $\tty$ is the first non-named type that is used to define $\tty$. Unlike $\tstruct$,
$\makeanonymous$ replaces named types by their definition until the first non-named type is found but
does not recurse further.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{named}):
  \begin{itemize}
    \item $\tty$ is a named type $\vx$;
    \item obtaining the type declared for $\vx$ yields $\vtone$ \ProseOrTypeError;
    \item the \underlyingtype\ of $\vtone$ is $\vt$.
  \end{itemize}

  \item All of the following apply (\textsc{non-named}):
  \begin{itemize}
    \item $\tty$ is not a named type $\vx$;
    \item $\vt$ is $\tty$.
  \end{itemize}
\end{itemize}

\subsection{Example}
Consider the following example:
\begin{verbatim}
type T1 of integer;
type T2 of T1;
type T3 of (integer, T2);
\end{verbatim}

The underlying types of \texttt{integer}, \texttt{T1}, and \texttt{T2} is \texttt{integer}.

The underlying type of \texttt{(integer, T2)} and \texttt{T3} is
\texttt{(integer, T2)}.  Notice how the underlying type does not replace
\texttt{T2} with its own underlying type, in contrast to the structure of
\texttt{T2}, which is \texttt{(integer, integer)}.

\CodeSubsection{\AnonymizeBegin}{\AnonymizeEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[named]{
  \tty \eqname \TNamed(\vx) \\
  \declaredtype(\tenv, \vx) \typearrow \vtone \OrTypeError \\\\
  \makeanonymous(\tenv, \vtone) \typearrow \vt
}{
  \makeanonymous(\tenv, \tty) \typearrow \vt
}
\and
\inferrule[non-named]{
  \astlabel(\tty) \neq \TNamed
}{
  \makeanonymous(\tenv, \tty) \typearrow \tty
}
\end{mathpar}
\end{emptyformal}
\subsection{Comments}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Relations Over Types \label{chap:relationsovertypes}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We define the following relations over types and operators:
\begin{itemize}
  \item Subtype (\secref{TypingRule.Subtype})
  \item Structural Subtype Satisfaction (\secref{TypingRule.StructuralSubtypeSatisfaction})
  \item Domain Subtype Satisfaction (\secref{TypingRule.DomainSubtypeSatisfaction})
  \item Subtype Satisfaction (\secref{TypingRule.SubtypeSatisfaction})
  \item Type Satisfaction (\secref{TypingRule.TypeSatisfaction})
  \item Type Clash (\secref{TypingRule.TypeClash})
  \item Lowest Common Ancestor (\secref{TypingRule.LowestCommonAncestor})
  \item Checking adequacy of a unary operator for a type (\secref{TypingRule.CheckUnop})
  \item Checking adequacy of a binary operator for a pair of types (\secref{TypingRule.CheckBinop})
\end{itemize}

\section{TypingRule.Subtype\label{sec:TypingRule.Subtype}}
The \emph{subtype} relation is a partial order over \underline{named types}.
The \emph{supertype} is the symmetric relation. That is, \tty\ is a supertype of \tsy\ if and only if \tsy\ is a subtype of \tty.

\hypertarget{def-subtypesrel}{}
The predicate
\[
  \subtypesrel(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\Bool}{\vb}
\]
(not to be confused with the static environment field $\subtypes$ --- notice the use of different font)
tests whether a type $\vtone$ is a \emph{subtype} of a type $\vttwo$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item all of the following apply (\textsc{reflexive}):
  \begin{itemize}
    \item $\vtone$ and $\vttwo$ are both the same named type;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item all of the following apply (\textsc{transitive}):
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the global static environment maintains that $\idone$ is a subtype of $\idthree$;
    \item testing whether the type named $\idthree$ is a subtype of $\vttwo$ in the static environment $\tenv$
    gives $\vb$.
  \end{itemize}

  \item all of the following apply (\textsc{no\_supertype}):
  \begin{itemize}
    \item $\vtone$ is a named type with name $\idone$, that is $\TNamed(\idone)$;
    \item $\vttwo$ is a named type with name $\idtwo$, that is $\TNamed(\idtwo)$, such that $\idone$ is different from $\idtwo$;
    \item the global static environment maintains that $\idone$ does subtype any named type;
    \item $\vb$ is $\False$.
  \end{itemize}

  \item all of the following apply (\textsc{not\_named}):
  \begin{itemize}
    \item at least one of $\vtone$ and $\vttwo$ is not a named type;
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}
\subsection{Example}
In the following example \texttt{subInt} is a subtype of itself and of \texttt{superInt}:
\begin{verbatim}
type superInt of integer;
type subInt of integer subtypes superInt;
\end{verbatim}

\CodeSubsection{\SubtypeBegin}{\SubtypeEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[reflexive]{}{
    \subtypesrel(\tenv, \TNamed(\id), \TNamed(\id)) \typearrow \True
  }
  \and
  \inferrule[transitive]{
    \idone \neq \idtwo\\
    G^\tenv.\subtypes(\idone) = \idthree\\
    \subtypesrel(\tenv, \TNamed(\idthree), \vttwo) \typearrow \vb
  }{
    \subtypesrel(\tenv, \TNamed(\idone), \TNamed(\idtwo)) \typearrow \vb
  }
  \and
  \inferrule[no\_supertype]{
    \idone \neq \idtwo\\
    G^\tenv.\subtypes(\idone) = \bot
  }{
    \subtypesrel(\tenv, \TNamed(\idone), \TNamed(\idtwo)) \typearrow \False
  }
  \and
  \inferrule[not\_named]{
    (\astlabel(\vtone) \neq \TNamed \lor \astlabel(\vttwo) \neq \TNamed)
  }{
    \subtypesrel(\tenv, \vtone, \vttwo) \typearrow \False
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
% Since the subtype relation is a partial order, it is reflexive, viz,
% every type is also a subtype of itself.

% Since the subtype relation is a partial order, it is transitive, viz, if A is
% a subtype of B and B is a subtype of C then A is a subtype of C.

% As a consequence, there is no need to declare the reflexive and transitive
% subtype relations explicitly. All other subtype relations must be explicitly
% declared.

% Since the subtype relation is a partial order, it is antisymmetric. Therefore
% it is an error if all of the following apply:
% \begin{itemize}
% \item \texttt{id1} is a subtype of \texttt{id2};
% \item \texttt{id2} is a subtype of \texttt{id1}.
% \end{itemize}
This is related to \identr{NXRX}, \identi{KGKS}, \identi{MTML}, \identi{JVRM}, \identi{CHMP}.

\section{TypingRule.StructuralSubtypeSatisfaction\label{sec:TypingRule.StructuralSubtypeSatisfaction}}
\hypertarget{def-structsubtypesat}{}
The predicate
\[
  \structsubtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{structurally-subtype-satisfies} a type $\vs$ is environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
\item All of the following apply (\textsc{error1}):
  \begin{itemize}
  \item obtaining the \underlyingtype\ of $\vt$ gives a type error;
  \item the rule results in a type error.
  \end{itemize}

\item All of the following apply (\textsc{error2}):
  \begin{itemize}
    \item obtaining the \underlyingtype\ of $\vt$ gives a type $\vttwo$;
    \item obtaining the \underlyingtype\ of $\vs$ gives a type error;
    \item the rule results in a type error.
    \end{itemize}

\item All of the following apply (\textsc{different\_labels}):
  \begin{itemize}
  \item the underlying types of $\vt$ and $\vs$ have different AST labels
  (for example, \texttt{integer} and \texttt{real});
  \item $\vb$ is $\False$.
  \end{itemize}

\item All of the following apply (\textsc{simple}):
  \begin{itemize}
  \item the \underlyingtype\ of $\vt$, $\vttwo$, is either \texttt{integer} (any kind), \texttt{real}, \texttt{string}, or \texttt{bool};
  \item the \underlyingtype\ of $\vs$, $\vstwo$, is either \texttt{integer} (any kind), \texttt{real}, \texttt{string}, or \texttt{bool};
  \item $\vb$ is $\True$ if and only if both $\vttwo$ and $\vstwo$ have the same ASL label.
  \end{itemize}

\item All of the following apply (\textsc{t\_enum}):
  \begin{itemize}
  \item the \underlyingtype\ of $\vt$, $\vttwo$, is an enumeration type;
  \item the \underlyingtype\ of $\vs$ is $\vstwo$;
  \item $\vb$ is $\True$ if and only if $\vttwo$ is equal to $\vstwo$.
  \end{itemize}

\item All of the following apply (\textsc{t\_bits}):
  \begin{itemize}
  \item the \underlyingtype\ of $\vs$ is a bitvector type with width $\ws$ and bit fields $\bfss$, that is $\TBits(\ws, \bfss)$;
  \item the \underlyingtype\ of $\vt$ is a bitvector type with width $\wt$ and bit fields $\bfst$, that is $\TBits(\wt, \bfst)$;
  \item $\vbone$ is $\True$ if and only if bitwidth $\ws$ is determined to be equivalent to $\wt$ in $\tenv$;
  \item determining whether the bit fields $\bfss$ are included in the bit fields $\bfst$ in $\tenv$ yields $\vbtwo$ \ProseOrTypeError;
  \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
  \end{itemize}

\item All of the following apply (\textsc{t\_array\_expr}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtype\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are equaivalent in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array length expression with $\vlengthexprs$, that is \\ $\ArrayLengthExpr(\vlengthexprs)$;
  \item $\vlengtht$ is an array length expression with $\vlengthexprt$, that is \\ $\ArrayLengthExpr(\vlengthexprt)$;
  \item determining whether expressions $\vlengthexprs$ and $\vlengthexprt$ are equivalent gives $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array\_enum}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of an array with index $\vlengths$ and element type $\vtys$, that is $\TArray(\vlengths, \vtys)$;
  \item $\vt$ has the \underlyingtype\ of an array with index $\vlengtht$ and element type $\vtyt$, that is $\TArray(\vlengtht, \vtyt)$;
  \item determining whether $\vtys$ and $\vtyt$ are equaivalent in $\tenv$ is either $\True$
  or $\False$, which short-circuits the entire rule with $\vb=\False$;
  \item either the AST labels of $\vlengths$ and $\vlengtht$ are the same or the rule short-circuits with $\vb=\False$;
  \item $\vlengths$ is an array with indices taken from the enumeration $\vnames$, that is $\ArrayLengthEnum(\vnames, \Ignore)$;
  \item $\vlengtht$ is an array with indices taken from the enumeration $\vnamet$, that is $\ArrayLengthEnum(\vnamet, \Ignore)$;
  \item $\vb$ is $\True$ if and only if $\vnames$ and $\vnamet$ are the same.
  \end{itemize}

\item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ of a tuple with type list $\vlis$, that is $\TTuple(\vlis)$;
  \item $\vt$ has the \underlyingtype\ of a tuple with type list $\vlit$, that is $\TTuple(\vlit)$;
  \item equating the lengths of $\vlis$ and $\vlit$ is either $\True$ or $\False$, which short-circuits
  the entire rule with $\vb=\False$;
  \item checking at each index $\vi$ of the list $\vlis$ whether the type $\vlit[\vi]$ \typesatisfies\ the type $\vlis[\vi]$
  yields $\vb_\vi$ \ProseOrTypeError;
  \item $\vb$ is $\True$ if and only if all $\vb_\vi$ are $\True$;
  \end{itemize}

\item All of the following apply (\textsc{structured}):
  \begin{itemize}
  \item $\vs$ has the \underlyingtype\ $L(\vfieldss)$, which is either a record type or an exception type;
  \item $\vt$ has the \underlyingtype\ $L(\vfieldst)$, which is either a record type or an exception type;
  \item since both underlying types have the same AST label they are either both record types or both exception types;
  \item $\vb$ is $\True$ if and only if for each field in $\vfieldss$ with type $\vtys$
  there exists a field in $\vfieldst$ with type $\vtyt$ such that both $\vtys$ and $\vtyt$
  are determined to be \typeequivalent\ in $\tenv$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\StructuralSubtypeSatisfactionBegin}{\StructuralSubtypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[error1]{
    \makeanonymous(\tenv, \vt) \typearrow \TypeErrorConfig
  }
  {
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
  }
  \and
  \inferrule[error2]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \TypeErrorConfig
  }
  {
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
  }
  \and
  \inferrule[different\_labels]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \astlabel(\vttwo) \neq \astlabel(\vstwo)
  }
  {
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \False
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[simple]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \astlabel(\vttwo) \in \{\TInt, \TReal, \TString, \TBool\}\\
    \vb \eqdef \astlabel(\vstwo) = \astlabel(\vttwo)
  }{
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[t\_enum]{
    \makeanonymous(\tenv, \vt) \typearrow \vttwo\\
    \astlabel(\vttwo) = \TEnum\\
    \makeanonymous(\tenv, \vs) \typearrow \vstwo\\
    \vb \eqdef \vstwo = \vttwo
  }{
    \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{
  \makeanonymous(\tenv, \vs) \typearrow \TBits(\ws, \bfss)\\
  \makeanonymous(\tenv, \vt) \typearrow \TBits(\wt, \bfst)\\
  \bitwidthequal(\tenv, \ws, \wt) \typearrow \vbone\\
  \bitfieldsincluded(\tenv, \bfss, \bfst) \typearrow \vbtwo \OrTypeError\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array\_expr]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True \terminateas \False\\
  \booltrans{\astlabel(\vlengths) = \astlabel(\vlengtht)} \booltransarrow \True \terminateas \False\\
  \vlengths \eqname \ArrayLengthExpr(\vlengthexprs)\\
  \vlengtht \eqname \ArrayLengthExpr(\vlengthexprt)\\
  \exprequal(\tenv, \vlengthexprs, \vlengthexprt) \typearrow \vb
}
{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\and
\inferrule[t\_array\_enum]{
  \makeanonymous(\tenv, \vs) \typearrow \TArray(\vlengths,\vtys) \\
  \makeanonymous(\tenv, \vt) \typearrow \TArray(\vlengtht,\vtyt) \\
  \typeequal(\tenv, \vtys, \vtyt) \typearrow \True\\
  \booltrans{\astlabel(\vlengths) = \astlabel(\vlengtht)} \typearrow \True\\
  \vlengths \eqname \ArrayLengthEnum(\vnames, \Ignore)\\
  \vlengtht \eqname \ArrayLengthEnum(\vnamet, \Ignore)\\
  \vb \eqdef \vnames = \vnamet
}
{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]
{ \makeanonymous(\tenv, \vs) \typearrow\TTuple(\vlis)\\
  \makeanonymous(\tenv, \vt) \typearrow\TTuple(\vlit)\\
  \equallength(\vlis, \vlit) \typearrow\True \terminateas \False\\
  \vi\in\listrange(\vlis): \typesat(\tenv, \vlit[\vi], \vlis[\vi]) \typearrow \vb_i \terminateas \TTypeError\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_\vi
}{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\hypertarget{def-fieldnames}{}
For a list of typed fields $\fields$, we define the set of its field identifiers as:
\[
  \fieldnames(\fields) \triangleq \{ \id \;|\; (\id, \vt) \in \fields\}
\]
\hypertarget{def-fieldtype}{}
We define the type associated with the field name $\id$ in a list of typed fields $\fields$,
if there is one, as follows:
\[
  \fieldtype(\fields, \id) \triangleq
  \begin{cases}
  \vt  & \text{ if }(\id,\vt) \in \fields\\
  \bot & \text{ otherwise}
  \end{cases}
\]

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}\\
  \makeanonymous(\tenv, \vs)\typearrow L(\vfieldss) \\
  \makeanonymous(\tenv, \vt)\typearrow L(\vfieldst) \\
  \vnamess \eqdef \fieldnames(\vfieldss)\\
  \vnamest \eqdef \fieldnames(\vfieldst)\\
  \booltrans{\vnamess \subseteq \vnamest} \booltransarrow \True \terminateas \False\\
  {
    \begin{array}{rl}
      (\id,\vtys)\in\vfieldss: \vb_\id \eqdef & \fieldtype(\vfieldst, \id)=\vtyt\ \land \\
                                            & \typeequal(\tenv, \vtys, \vtyt) \typearrow \True
    \end{array}
  }\\
  \vb \eqdef \bigwedge_{\id \in \vnamess} \vb_\id
}{
  \structsubtypesat(\tenv, \vs, \vt) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identd{TRVR}, \identi{SJDC}, \identi{MHYB}, \identi{TWTZ}, \identi{GYSK}, \identi{KXSD}.

\section{TypingRule.DomainSubtypeSatisfaction\label{sec:TypingRule.DomainSubtypeSatisfaction}}
\hypertarget{def-domsubtypesat}{}
The predicate
\[
  \domsubtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{domain-subtype-satisfies} a type $\vs$ is environment $\tenv$,\\
\underline{assuming that $\vt$ structurally-subtype-satisfies $\vs$},
returning the result $\vb$ or a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{error1}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type error;
    \item the rule gives a type error.
  \end{itemize}

  \item All of the following apply (\textsc{error2}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type $\vsstruct$;
    \item obtaining the \structure\ of $\vt$ results in a type error;
    \item the rule gives a type error.
  \end{itemize}

  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type $\vsstruct$;
    \item the AST label of $\vsstruct$ is either $\TTuple$, $\TArray$, $\TRecord$, or $\TException$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{symbolic}):
  \begin{itemize}
    \item obtaining the \structure\ of $\vs$ results in a type $\vsstruct$;
    \item obtaining the \structure\ of $\vt$ results in a type $\vtstruct$;
    \item the AST label of $\vsstruct$ is either $\TReal$, $\TString$, $\TBool$, $\TEnum$, or $\TInt$;
    \item determining whether $\vs$ subsumes $\vt$ in $\tenv$ via symbolic reasoning results in $\vb$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\DomainSubtypeSatisfactionBegin}{\DomainSubtypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[error1]{
  \tstruct(\tenv, \vs) \typearrow \TypeErrorConfig\\
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\and
\inferrule[error2]{
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \tstruct(\tenv, \vt) \typearrow \TypeErrorConfig\\
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \TypeErrorConfig
}
\and
\inferrule[simple]{
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \astlabel(\vsstruct) \in \{\TTuple, \TArray, \TRecord, \TException\}
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[symbolic]{
  \tstruct(\tenv, \vs) \typearrow \vsstruct\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct\\
  \astlabel(\vsstruct) \in \{\TReal, \TString, \TBool, \TEnum, \TInt\}\\
  \symsubsumes(\tenv, \vsstruct, \vtstruct) \typearrow \vb
}{
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identd{TRVR}.

\section{TypingRule.SubtypeSatisfaction\label{sec:TypingRule.SubtypeSatisfaction}}
\hypertarget{def-subtypesatisfies}{}
The predicate
\[
  \subtypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{subtype-satisfies} a type $\vs$ is environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item determining whether $\vt$ structurally-subtype-satisfies $\vs$ yields $\vbone$ \ProseOrTypeError;
  \item determining whether $\vt$ domain-subtype-satisfies $\vs$ yields $\vbtwo$;
  \item $\vb$ is $\True$ if and only if both $\vbone$ and $\vbtwo$ are $\True$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SubtypeSatisfactionBegin}{\SubtypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
\begin{mathpar}
\inferrule{
  \structsubtypesat(\tenv, \vt, \vs) \typearrow \vbone \OrTypeError\\
  \domsubtypesat(\tenv, \vt, \vs) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}{
  \subtypesat(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\end{emptyformal}

\subsection{Comments}
    This is related to \identd{TRVR}, \identi{KNXJ}.

\section{TypingRule.TypeSatisfaction \label{sec:TypingRule.TypeSatisfaction}}
\hypertarget{def-typesatisfies}{}
The predicate
\[
  \typesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{\typesatisfies} a type $\vs$ is environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.

\hypertarget{def-checktypesat}{}
We also define
\[
  \checktypesat(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \True \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
which is the same as $\typesat$, but yields a type error when \\ $\typesat(\tenv, \vt, \vs)$ is $\False$.

\subsection{Prose}
One of the following applies:
 \begin{itemize}
  \item All of the following apply (\textsc{subtypes}):
    \begin{itemize}
    \item $\vt$ subtypes $\vs$ in $\tenv$ ;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{anonymous1}, \textsc{anonymous2}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item at least one of $\vt$ and $\vs$ is an anonymous type in $\tenv$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\True$ \ProseOrTypeError;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item neither one of $\vt$ and $\vs$ is an anonymous type in $\tenv$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\False$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a bitvector type of length $\widtht$ \ProseOrTypeError;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a bitvector type of length $\widths$ \ProseOrTypeError;
    \item determining whether $\widtht$ and $\widths$ are \bitwidthequivalent\ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{otherwise}):
  \begin{itemize}
    \item $\vt$ does not subtype $\vs$ in $\tenv$;
    \item neither one of $\vt$ and $\vs$ is an anonymous type in $\tenv$;
    \item determining whether $\vt$ \subtypesatisfies\ $\vs$ in $\tenv$ yields $\False$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a type $\vtone$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a type $\vsone$;
    \item at least one of $\vtone$ and $\vsone$ is not a bitvector type;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a bitvector type of length $\widths$ \ProseOrTypeError;
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}

\subsection{Example: TypingRule.TypeSatisfaction1.asl}
In the specification:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction1.asl}
\texttt{var pair: pairT = (1, dataT1)} is legal since the right-hand-side has
anonymous, non-primitive type \texttt{(integer, T1)}.

\subsection{Example: TypingRule.TypeSatisfaction2.asl}
In the specification:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction2.asl}
\texttt{pair = (1, dataAsInt);} is legal since the right-hand-side has anonymous,
primitive type \texttt{(integer, integer)}.

\subsection{Example: TypingRule.TypeSatisfaction3.asl}
In the specification:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction3.asl}
\texttt{pair = (1, dataT2);} is illegal since the right-hand-side has anonymous,
non-primitive type \texttt{(integer, T2)} which does not subtype-satisfy named
type \texttt{pairT}.

\CodeSubsection{\TypeSatisfactionBegin}{\TypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[subtypes]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \True
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[anonymous1]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \True\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \True \OrTypeError
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[anonymous2]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vs) \typearrow \True\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \True
}{
  \typesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[t\_bits]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \False\\
  \isanonymous(\tenv, \vs) \typearrow \False\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \TBits(\widtht, \Ignore) \OrTypeError\\
  \tstruct(\tenv, \vs) \typearrow \TBits(\widths, \Ignore) \OrTypeError\\
  \bitwidthequal(\tenv, \widtht, \widths) \typearrow \vb
}{
  \typesat(\tenv, \vt, \vs) \typearrow \vb
}
\and
\inferrule[otherwise]{
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \isanonymous(\tenv, \vt) \typearrow \False\\
  \isanonymous(\tenv, \vs) \typearrow \False\\
  \subtypesat(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \vtone\\
  \tstruct(\tenv, \vs) \typearrow \vsone\\
  \astlabel(\vtone) \neq \TBits \lor \astlabel(\vsone) \neq \TBits
}{
  \typesat(\tenv, \vt, \vs) \typearrow \False
}
\end{mathpar}

The rules for the checked type-satisfy predicate are:
\begin{mathpar}
\inferrule[true]{
  \typesat(\tenv, \vt, \vs) \typearrow \True \OrTypeError\\
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[error]{
  \typesat(\tenv, \vt, \vs) \typearrow \False
}{
  \checktypesat(\tenv, \vt, \vs) \typearrow \TypeErrorVal{TypeConflict}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
Since the subtype relation is a partial order, it is reflexive. Therefore
every type $\vt$ is a subtype of itself, and as a consequence, every type $\vt$
\typesatisfies\  itself.

This is related to \identr{FMXK} and \identi{NLFD}.

\section{TypingRule.TypeClash\label{sec:TypingRule.TypeClash}}
\hypertarget{def-typeclashes}{}
The predicate
\[
  \typeclashes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether a type $\vt$ \emph{type-clashes} with a type $\vs$ is environment $\tenv$,
returning the result $\vb$ or a type error, if one is detected.

\subsection{Prose}
 One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{subtype1}, \textsc{subtype2}):
  \begin{itemize}
    \item either $\vs$ subtypes $\vt$ or $\vt$ subtypes $\vs$;
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$ \ProseOrTypeError;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields $\vsstruct$ \ProseOrTypeError;
    \item both $\vtstruct$ and $\vsstruct$ are of the following types: \\ \texttt{integer}, \texttt{real}, \texttt{string};
    \item $\vb$ is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_enum}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields an enumeration type with labels $\vlit$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields an enumeration type with labels $\vlis$;
    \item $\vb$ is $\True$ if and only if $\vlis$ and $\vlit$ are equal.
  \end{itemize}

  \item All of the following apply (\textsc{t\_array}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields an array type with element type $\vtyt$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields an array type with element type $\vtys$;
    \item $\vb$ is $\True$ if and only if $\vtyt$ and $\vtys$ type-clash.
  \end{itemize}

  \item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a tuple type with element types $\vt_{1..k}$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a tuple type with element types $\vs_{1..n}$;
    \item if $n \neq k$ the rule short-circuits with $\vb=\False$;
    \item $\vb$ is $\True$ if and only if $\vt_i$ type-clashes with $\vs_i$, for all $i=1..k$.
  \end{itemize}

  \item All of the following apply (\textsc{otherwise}):
  \begin{itemize}
    \item neither $\vs$ subtypes $\vt$ nor $\vt$ subtypes $\vs$;
    \item obtaining the \structure\ of $\vt$ in $\tenv$ yields a tuple type with element types $\vt_{1..k}$;
    \item obtaining the \structure\ of $\vs$ in $\tenv$ yields a tuple type with element types $\vs_{1..n}$;
    \item either $\vsstruct$ and $\vtstruct$ have different AST labels or one of their labels
    is $\TRecord$ or $\TException$;
    \item $\vb$ is $\False$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\TypeClashBegin}{\TypeClashEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[subtype1]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \True
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \True
}
\and
\inferrule[subtype2]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \True
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[simple]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \OrTypeError \\
  \astlabel(\vtstruct)=\astlabel(\vsstruct) \in \{\TInt, \TReal, \TString, \TBits\}
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_enum]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \TEnum(\Ignore, \vlis) \\
  \tstruct(\tenv, \vs) \typearrow \TEnum(\Ignore, \vlit) \\
  \vb \eqdef \vlis = \vlit
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_array]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \TArray(\Ignore, \vtyt) \\
  \tstruct(\tenv, \vs) \typearrow \TArray(\Ignore, \vtys) \\
  \typeclashes(\tenv, \vtyt, \vtys) \typearrow \vb
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) \typearrow \TTuple(\vs_{1..n}) \\
  \booltrans{n = k} \booltransarrow \True \terminateas \False\\
  i=1..k: \typeclashes(\tenv, \vt_i, \vs_i) \typearrow \vb_i\\
  \vb \eqdef \bigwedge_{\vi=1}^k \vb_i
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[otherwise]{
  \subtypesrel(\tenv, \vs, \vt) \typearrow \False\\
  \subtypesrel(\tenv, \vt, \vs) \typearrow \False\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \\
  \tstruct(\tenv, \vs) \typearrow \vsstruct \\
  \booltrans{\astlabel(\vtstruct) \neq \astlabel(\vsstruct)} \booltransarrow \True \terminateas \False\\
  \vb \eqdef \astlabel(\vtstruct) \not\in \{\TRecord, \TException\}\\
}{
  \typeclashes(\tenv, \vt, \vs) \typearrow \False
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
Note that if $\vt$ subtype-satisfies $\vs$ then $\vt$ and $\vs$ type-clash, but not the other
way around.

Note that type-clashing is an equivalence relation. Therefore if $\vt$
type-clashes with \texttt{A} and \texttt{B} then it is also the case that \texttt{A} and \texttt{B} type-clash.

This is related to \identd{VPZZ}, \identi{PQCT} and \identi{WZKM}.

\section{TypingRule.LowestCommonAncestor \label{sec:TypingRule.LowestCommonAncestor}}
Annotating a conditional expression (see \secref{TypingRule.ECond}),
requires finding a single type that can be used to annotate the results of both sub-expressions.
The function
\[
  \lca(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\ty}{\tty}
\]
returns the \emph{lowest common ancestor} of types $\vt$ and $\vs$ in $\tenv$ --- $\tty$.

\subsection{Prose}
The lowest common ancestor of types $\vs$ and $\vt$ is $\tty$ and one of the following applies:
  \begin{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item $\vs$ and $\vt$ are the same type;
    \item $\tty$ is $\vs$.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item $\vs$ and $\vt$ are both named types;
    \item $\tty$ is a common supertype of $\vs$ and $\vt$;
    \item $\tty$ is a subtype of all other common supertypes of $\vs$ and $\vt$.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item $\vs$ and $\vt$ both have the structure of array types with the same index type
      and the same element types;

    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is a named type;
        \item $\vt$ is an anonymous type;
        \item $\tty$ is $\vs$.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is an anonymous type;
        \item $\vt$ is a named type;
        \item $\tty$ is $\vt$.
        \end{itemize}
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item $\vs$ and $\vt$ both have the structure of tuple types with the same number of elements;
    \item The types of the elements of $\vs$ type-satisfy the types of the elements of $\vt$;
    \item The types of the elements of $\vt$ type-satisfy the types of the elements of $\vs$;
    \item One of the following applies:

      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is a named type;
        \item $\vt$ is an anonymous type;
        \item $\tty$ is $\vs$.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is an anonymous type;
        \item $\vt$ is a named type;
        \item $\tty$ is $\vt$.
        \end{itemize}

     \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is an anonymous type;
        \item $\vt$ is an anonymous type;
	\item $\tty$ is the tuple type where the type of each element is the lowest common
	  ancestor of the types of the corresponding elements of $\vs$ and $\vt$.
        \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item $\vs$ and $\vt$ both have the structure of well-constrained integer types;
    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is a named type;
        \item $\vt$ is an anonymous type;
        \item $\tty$ is $\vs$.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is an anonymous type;
        \item $\vt$ is a named type;
        \item $\tty$ is $\vt$.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is an anonymous type;
        \item $\vt$ is an anonymous type;
	\item $\tty$ is the well-constrained integer type whose runtime domain is the union of the
	  runtime domains of $\vs$ and $\vt$, for every dynamic environment.
        \end{itemize}
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item Either $\vs$ or $\vt$ have the structure of an unconstrained integer type;
    \item One of the following applies:

      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is a named type;
        \item $\vs$ has the structure of an unconstrained integer type;
        \item $\vt$ is an anonymous type;
        \item $\tty$ is $\vs$.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is an anonymous type;
        \item $\vt$ is a named type;
        \item $\vt$ has the structure of an unconstrained integer type;
        \item $\tty$ is $\vt$.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item $\vs$ is an anonymous type;
        \item $\vt$ is an anonymous type;
	\item $\tty$ is the unconstrained integer type.
        \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item Either $\vs$ or $\vt$ have the structure of an under-constrained integer type;
    \item $\tty$ is the under-constrained integer type.
    \end{itemize}

  \item $\tty$ is undefined.
  \end{itemize}

\subsection{Example}

\CodeSubsection{\LowestCommonAncestorBegin}{\LowestCommonAncestorEnd}{../types.ml}

\begin{emptyformal}
\subsection{Formally}
Since we do not impose a canonical representation on types (e.g., \texttt{Integer {1, 2}} is equivalence to \texttt{integer {1..2}}),
the lowest common ancestor is not unique.
We define $\lca(\tenv, \vt, \vs)$ to be any type $\vtp$ that is type-equivalent to the lowest common ancestor of $\vt$ and $\vs$:
\[
  \typeequal(\tenv, \vtp, \lca(\tenv, \vt, \vs)) \enspace.
\]

\begin{mathpar}
\inferrule[Lowest common ancestor reflexivity]{}{\lca(\tenv, \vt, \vt) = \vt}
\and
\inferrule[(The least common subtype, if one exists.)]{
  \astlabel(\vt)=\astlabel(\vs)=\TNamed \\\\
  \Supers(\vs) = \{\vsp \;|\; \subtypesrel(\tenv, \vs, \vsp)\}\\
  \Supers(\vt) = \{\vtp \;|\; \subtypesrel(\tenv, \vt, \vtp)\}\\\\
  \Supers(\vs) \cap \Supers(\vt) \neq \emptyset
}
{\lca(\tenv, \vt, \vs) = \min_{\subtypes} (\Supers(\vs) \cap \Supers(\vt))}
\end{mathpar}

Rules for arrays:
\begin{mathpar}
\inferrule{\tstruct(\tenv, \vt) = \TArray(\vlt, \vtt) \\
  \tstruct(\tenv, \vs) = \TArray(\vls, \vts) \\
  \typeequal(\tenv, \vlt, \vls) \\
  \typeequal(\tenv, \vtt, \vts) \\
  \astlabel(\tstruct(\tenv, \vt)) = \TNamed \\
  \isanonymous(\vs)
}
{\lca(\tenv, \vt, \vs) = \vt}
\and
\inferrule{\tstruct(\tenv, \vt) = \TArray(\vlt, \vtt) \\
  \tstruct(\tenv, \vs) = \TArray(\vls, \vts) \\
  \typeequal(\tenv, \vlt, \vls) \\
  \typeequal(\tenv, \vtt, \vts) \\
  \astlabel(\tstruct(\tenv, \vs)) = \TNamed \\
  \isanonymous(\vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\end{mathpar}

Rules for tuples:
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) = \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) = \TTuple(\vs_{1..k}) \\
  i=1..k:\typesat(\tenv, \vs_i, \vt_i) \\
  i=1..k:\typesat(\tenv, \vt_i, \vs_i) \\
  \astlabel(\vt) = \TNamed \\
  \isanonymous(\vs)
}
{\lca(\tenv, \vt, \vs) = \vt}
\and
\inferrule{
  \tstruct(\tenv, \vt) = \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) = \TTuple(\vs_{1..k}) \\
  i=1..k:\typesat(\tenv, \vs_i, \vt_i) \\
  i=1..k:\typesat(\tenv, \vt_i, \vs_i) \\
  \astlabel(\vs) = \TNamed \\
  \isanonymous(\vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\and
\inferrule{
  \tstruct(\tenv, \vt) = \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) = \TTuple(\vs_{1..k}) \\
  i=1..k:\typesat(\tenv, \vs_i, \vt_i) \\
  i=1..k:\typesat(\tenv, \vt_i, \vs_i) \\
  \isanonymous(\vt)\\
  \isanonymous(\vs)\\
  i=1..k: \lca(\tenv, \vt_i, \vs_i)=\vz_i
}
{\lca(\tenv, \vt, \vs) = \TTuple(\vz_{1..k})}
\end{mathpar}

Rules for well-constrained integers:
\begin{mathpar}
\inferrule{
  \iswellconstrainedinteger(\tstruct(\tenv, \vt))  \\
  \iswellconstrainedinteger(\tstruct(\tenv, \vs))  \\
  \astlabel(\vt) = \TNamed\\
  \isanonymous(\vs)
}
{\lca(\tenv, \vt, \vs) = \vt}
\and
\inferrule{
  \iswellconstrainedinteger(\tstruct(\tenv, \vt))  \\
  \iswellconstrainedinteger(\tstruct(\tenv, \vs))  \\
  \astlabel(\vs) = \TNamed\\
  \isanonymous(\vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\and
\inferrule{
  \iswellconstrainedinteger(\tstruct(\tenv, \vt))  \\
  \iswellconstrainedinteger(\tstruct(\tenv, \vs))  \\
  \astlabel(\vs) = \TNamed\\
  \isanonymous(\vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\and
\inferrule[(We use + to denote the list concatenation.)]
{
  \tstruct(\tenv, \vt) = \TInt(\langle \cst \rangle) \\
  \tstruct(\tenv, \vs) = \TInt(\langle \css \rangle) \\
  \isanonymous(\vt)\\
  \isanonymous(\vs)}
{\lca(\tenv, \vt, \vs) = \TInt(\langle \cst + \css \rangle)}
\end{mathpar}

Rules for unconstrained integers:
\begin{mathpar}
\inferrule{
  \astlabel(\vs) = \TNamed \\
  \tstruct(\tenv, \vs) = \isunconstrainedinteger \\
  \tstruct(\tenv, \vt) = \TInt(\Ignore) \\
  \isanonymous(\tenv, \vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\and
\inferrule{
  \astlabel(\vt) = \TNamed \\
  \tstruct(\tenv, \vt) = \isunconstrainedinteger \\
  \tstruct(\tenv, \vs) = \TInt(\Ignore) \\
  \isanonymous(\tenv, \vs)
}
{\lca(\tenv, \vt, \vs) = \vt}
\and
\inferrule{
  \isanonymous(\tenv, \vs) \\
  \isanonymous(\tenv, \vt) \\
  \tstruct(\tenv, \vt) = \TInt(\Ignore) \\
  \tstruct(\tenv, \vt) = \TInt(\Ignore) \\
  \tstruct(\tenv, \vs) = \isunconstrainedinteger \\
}
{\lca(\tenv, \vt, \vs) = \unconstrainedinteger}
\and
\inferrule{
  \isanonymous(\tenv, \vs) \\
  \isanonymous(\tenv, \vt) \\
  \tstruct(\tenv, \vs) = \TInt(\Ignore) \\
  \tstruct(\tenv, \vt) = \isunconstrainedinteger \\
}
{\lca(\tenv, \vt, \vs) = \unconstrainedinteger}
\end{mathpar}

Rules for underconstrained integers:
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) = \isunderconstrainedinteger \\
  \tstruct(\tenv, \vs) = \TInt(\Ignore) \\
}
{\lca(\tenv, \vt, \vs) = \isunderconstrainedinteger}
\and
\inferrule{
  \tstruct(\tenv, \vs) = \isunderconstrainedinteger \\
  \tstruct(\tenv, \vt) = \TInt(\Ignore) \\
}
{\lca(\tenv, \vt, \vs) = \isunderconstrainedinteger}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{YZHM}.

\section{TypingRule.CheckUnop \label{sec:TypingRule.CheckUnop}}
\hypertarget{def-checkunop}{}
The function
\[
  \CheckUnop(\overname{\staticenvs}{\tenv} \aslsep \overname{\unop}{\op} \aslsep \overname{\ty}{\vt})
  \aslto \overname{\ty}{\vs}
\]
determines the result type of applying a unary operator when the type of its operand is known.
Similarly, we determine the negation of integer constraints.

\subsection{Prose}
  $\vt$ is the result of checking compatibility of a unary operator $\op$ with
  type $\vtone$ and one of the following applies:
  \begin{itemize}
  \item All of the following apply (\textsc{bnot\_t\_bool}):
    \begin{itemize}
      \item $\op$ is $\BNOT$;
      \item determining whether $\vtone$ \checkedtypesatisfies\ $\TBool$ yields $\True$ \ProseOrTypeError;
      \item $\vt$ is $\TBool$;
    \end{itemize}

  \item All of the following apply (\textsc{neg\_t\_rel}):
  \begin{itemize}
    \item $\op$ is $\NEG$;
    \item determining whether $\vtone$ \checkedtypesatisfies\ $\TReal$ yields $\True$ \ProseOrTypeError;
    \item $\vt$ is $\TReal$;
  \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item $\op$ is $\NEG$;
    \item One of the following applies:
      \begin{itemize}
      \item $\vtone$ \typesatisfies\  $\TInt$;
      \item $\vtone$ \typesatisfies\  $\TReal$;
      \end{itemize}
     \item One of the following applies:
       \begin{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item $\vtone$ has the structure of an unconstrained integer;
         \item $\vt$ is an unconstrained integer;
         \end{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item $\vtone$ has the structure of a constrained integer;
         \item $\vt$ is a constrained integer whose constraint is ;
         \end{itemize}
       \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item $\op$ is $\NEG$;
    \item One of the following applies:
      \begin{itemize}
      \item $\vtone$ \typesatisfies\  $\TInt$;
      \item $\vtone$ \typesatisfies\  $\TReal$;
      \end{itemize}
     \item One of the following applies:
       \begin{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item $\vtone$ has the structure of an unconstrained integer;
         \item $\vt$ is an unconstrained integer;
         \end{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item $\vtone$ has the structure of a constrained integer;
         \item $\vt$ is a constrained integer whose constraint is ;
         \end{itemize}
       \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item $\op$ is $\NOT$;
    \item $\vtone$ has the structure of a bitvector;
    \item $\vt$ is $\vtone$.
    \end{itemize}
  \end{itemize}

\subsection{Example}

\CodeSubsection{\CheckUnopBegin}{\CheckUnopEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[bnot\_t\_bool]{
  \checktypesat(\tenv, \vt, \TBool) \typearrow \True \OrTypeError\\
}{
  \CheckUnop(\tenv, \BNOT, \vt) \typearrow \TBool
}
\and
\inferrule[neg\_t\_real]{
  \checktypesat(\tenv, \vt, \TReal) \typearrow \True \OrTypeError\\
}{
  \CheckUnop(\tenv, \NEG, \vt) \typearrow \TReal
}
\and
\inferrule[neg\_t\_int\_unconstrained]{
  \typesat(\tenv, \vt, \unconstrainedinteger)
}{
  \CheckUnop(\tenv, \NEG, \vt) \typearrow \unconstrainedinteger
}
\end{mathpar}

We define the following helper relations for negating integer constraints:
\begin{mathpar}
\inferrule[constraint\_exact]{}{\CheckUnop(\tenv, \NEG, \ConstraintExact(\ve)) \typearrow \ConstraintExact(\EUnop(\NEG, \ve))}
\and
\inferrule[constraint\_range]{}{\CheckUnop(\tenv, \NEG, \ConstraintRange(\ve1,\ve2)) \typearrow \\
 \ConstraintRange(\EUnop(\NEG, \ve2),\EUnop(\NEG, \ve1))}
\end{mathpar}

We now apply these relations to handle well-constrained integers:
\begin{mathpar}
\inferrule[neg\_t\_int\_well\_constrained]{
  \typesat(\tenv, \vt, \TInt(\langle [c_{1..k}] \rangle)) \\
  i=1..k: \CheckUnop(\NEG, c_i) : d_i
}{
  \CheckUnop(\tenv, \NEG, \vt) \typearrow \TInt(\langle [d_{1..k}] \rangle)
}
\end{mathpar}

\begin{mathpar}
\inferrule[not\_t\_bits]{
    \astlabel(\tstruct(\tenv, \vt)) \typearrow \TBits
}{
  \CheckUnop(\tenv, \NOT, \vt) \typearrow \vt
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.CheckBinop \label{sec:TypingRule.CheckBinop}}
\hypertarget{def-checkbinop}{}
The function
\[
  \CheckBinop(\overname{\staticenvs}{\tenv} \aslsep \overname{\binop}{\op} \aslsep \overname{\ty}{\vtone}
  \aslsep \overname{\ty}{\vttwo})
  \aslto \overname{\ty}{\vt}
\]
determines the result type $\vt$ of applying the binary operator $\op$
to operands of type $\vtone$ and $\vttwo$ in the static environment $\tenv$,
returning a type error, if one is detected.

\subsection{Goal}
Determine the result type of a binary operator, given the types of its operands.

\subsection{Prose}
  $\vt$ is the result of checking compatibility of a binary operator $\op$ with
  types $\vtone$ and $\vttwo$ and one of the following applies:
\begin{itemize}
  \item All of the following apply:
  \begin{itemize}
    \item $\op$ is $\AND$, $\OR$, $\EQOP$ or $\IMPL$;
    \item $\vtone$ \typesatisfies\  $\TBool$;
    \item $\vttwo$ \typesatisfies\  $\TBool$;
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\op$ is $\AND$, $\OR$, or $\EOR$;
    \item $\vtone$ has the structure of a bitvector;
    \item $\vttwo$ has the structure of a bitvector;
    \item $\vtone$ and $\vttwo$ have the same bitvector width $\vw$;
    \item $\vt$ is the bitvector type of width $\vw$.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\op$ is $\PLUS$ or $\MINUS$;
    \item $\vtone$ has the structure of a bitvector of width $\vw$;
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item $\vttwo$ has the structure of a bitvector;
        \item $\vtone$ and $\vttwo$ have the same bitvector width $\vw$;
        \item $\vt$ is the bitvector type of width $\vw$.
      \end{itemize}
      \item $\vttwo$ \typesatisfies\  $\TInt$;
    \end{itemize}
    \item $\vt$ is the bitvector type of width $\vw$.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\op$ is \EQOP\ or \NEQ;
    \item One of the following applies:
    \begin{itemize}
      \item $\vtone$ is equal to $\vttwo$;
      \item All of the following apply:
      \begin{itemize}
        \item $\vtone$ \typesatisfies\  $\TInt$;
        \item $\vttwo$ \typesatisfies\  $\TInt$;
      \end{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item $\vtone$ has the structure of a bitvector;
        \item $\vttwo$ has the structure of a bitvector;
        \item $\vtone$ and $\vttwo$ have the same bitvector width;
      \end{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item $\vtone$ \typesatisfies\  $\TBool$;
        \item $\vttwo$ \typesatisfies\  $\TBool$;
      \end{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item $\vtone$ enumerates local declarations $\vlione$;
        \item $\vttwo$ enumerates local declarations $\vlitwo$;
        \item $\vlione$ equals $\vlitwo$;
      \end{itemize}
    \end{itemize}
    \item $\vt$ is $\TBool$.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\op$ is \LEQ, \GEQ, \GT\ or \LT;
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item $\vtone$ \typesatisfies\  $\TInt$;
        \item $\vttwo$ \typesatisfies\  $\TInt$;
      \end{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item $\vtone$ \typesatisfies\  $\TReal$;
        \item $\vttwo$ \typesatisfies\  $\TReal$;
      \end{itemize}
    \end{itemize}
    \item $\vt$ is boolean.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\op$ is $\MUL$, $\DIV$, $\DIVRM$, $\MOD$, $\SHL$, $\SHR$, $\POW$, $\PLUS$ or $\MINUS$;
    \item $\structone$ is the structure of $\vtone$;
    \item $\structtwo$ is the structure of $\vttwo$;
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item $\vtone$ has the structure of an unconstrained integer;
        \item $\vttwo$ has the structure of an integer;
        \item $\vt$ is an unconstrained integer;
      \end{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item $\vtone$ has the structure of an integer;
        \item $\vttwo$ has the structure of an unconstrained integer;
        \item $\vt$ is an unconstrained integer;
      \end{itemize}
      \item One of the following applies:
      \begin{itemize}
        \item One of the following applies:
        \begin{itemize}
          \item All of the following apply:
          \begin{itemize}
            \item $\vtone$ has the structure of an under-constrained integer;
            \item $\vttwo$ has the structure of a constrained integer;
            \item $\vt$ is an under-constrained integer;
          \end{itemize}
          \item All of the following apply:
          \begin{itemize}
            \item $\vtone$ has the structure of a constrained integer;
            \item $\vttwo$ has the structure of an under-constrained integer;
            \item $\vt$ is an under-constrained integer;
          \end{itemize}
        \end{itemize}
        \item All of the following apply:
        \begin{itemize}
          \item $\vtone$ has the structure of a well-constrained integer;
          \item $\vttwo$ has the structure of a well-constrained integer;
	        \item $\vt$ is a constrained integer whose constraint is calculated by
	        applying the operation $\op$ to all possible value pairs;
        \end{itemize}
        \item All of the following apply:
        \begin{itemize}
          \item $\vtone$ has the structure of $\TReal$;
          \item $\vttwo$ has the structure of $\TReal$;
          \item $\op$ is $\PLUS$, $\MINUS$ or $\MUL$;
          \item $\vt$ is $\TReal$;
        \end{itemize}
        \item All of the following apply:
        \begin{itemize}
          \item $\vtone$ has the structure of $\TReal$;
          \item $\vttwo$ has the structure of $\TInt$;
          \item $\op$ is $\POW$;
          \item $\vt$ is $\TReal$;
        \end{itemize}
      \end{itemize}
    \end{itemize}

    \item All of the following apply:
    \begin{itemize}
      \item $\op$ is $\RDIV$;
      \item $\vtone$ \typesatisfies\  $\TReal$;
      \item $\vttwo$ \typesatisfies\  $\TReal$;
      \item $\vt$ is $\TReal$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\CheckBinopBegin}{\CheckBinopEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \op \in  \{\BAND, \BOR, \IMPL, \EQOP\}\\
  \typesat(\tenv, \vt1, \TBool) \\
  \typesat(\tenv, \vttwo, \TBool)
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool}
\and
\inferrule{
  \op \in  \{\AND, \OR, \EOR\}\\
  \tstruct(\tenv, \vtone) \typearrow \TBits(\vw, \Ignore) \\
  \tstruct(\tenv, \vttwo) \typearrow \TBits(\vw', \Ignore) \\
  \bitwidthequal(\tenv, \vw, \vw')
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBits(w_1, \emptylist)}
\and
\inferrule{
  \op \in  \{\PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \TBits(\vw, \Ignore) \\
  \tstruct(\tenv, \vttwo) \typearrow \TBits(\vw', \Ignore) \\
  \bitwidthequal(\tenv, \vw, \vw')
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBits(w_1, \emptylist)}
\and
\inferrule{
  \op \in  \{\PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \TBits(\vw, \Ignore) \\
  \typesat(\tenv, \vttwo, \unconstrainedinteger)
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBits(\vw, \emptylist)}
\end{mathpar}

\begin{mathpar}
\inferrule[(This rule also handles the case of enumeration types.)]
{\op \in  \{\EQOP, \NEQ\}}
{\CheckBinop(\tenv, \op, \vt, \vt) \typearrow \TBool}
\and
\inferrule{
  \op \in  \{\EQOP, \NEQ\}\\
  \typesat(\tenv, \vtone, \unconstrainedinteger)\\
  \typesat(\tenv, \vttwo, \unconstrainedinteger)
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool}
\and
\inferrule{
  \op \in  \{\EQOP, \NEQ\}\\
  \tstruct(\tenv, \vtone)\typearrow\TBits(\vw, \Ignore)\\
  \tstruct(\tenv, \vttwo)\typearrow\TBits(\vw', \Ignore)\\
  \bitwidthequal(\tenv, \vw, \vw')
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TBool}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \op \in  \{\LT, \LEQ, \GT, \GEQ\}\\
  \typesat(\tenv, \vtone, \unconstrainedinteger)\\
  \typesat(\tenv, \vttwo, \unconstrainedinteger)
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \unconstrainedinteger}
\and
\inferrule{
  \op \in  \{\LT, \LEQ, \GT, \GEQ\}\\
  \typesat(\tenv, \vtone, \TReal)\\
  \typesat(\tenv, \vttwo, \TReal)
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TReal}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \unconstrainedinteger\\
  \astlabel(\tstruct(\tenv, \vttwo)) \typearrow \TInt
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \unconstrainedinteger}
\and
\inferrule{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}\\
  \astlabel(\tstruct(\tenv, \vtone)) \typearrow \TInt\\
  \tstruct(\tenv, \vttwo) \typearrow \unconstrainedinteger
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \unconstrainedinteger}
\and
\inferrule{
  \op \in  \{\MUL, \DIV, \DIVRM, \MOD, \SHL,  \SHR, \POW, \PLUS, \MINUS\}\\
  \tstruct(\tenv, \vtone) \typearrow \TInt(\langle \csone \rangle) \\
  \tstruct(\tenv, \vttwo) \typearrow \TInt(\langle \cstwo \rangle)\\
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TInt(\constraintbinop(\csone, \cstwo))}
\and
\inferrule{
  \op \in  \{\PLUS, \MINUS, \MUL\}\\
  \tstruct(\tenv, \vtone) \typearrow \TReal\\
  \tstruct(\tenv, \vttwo) \typearrow \TReal
}
{\CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \TReal}
\and
\inferrule{
  \tstruct(\tenv, \vtone) \typearrow \TReal\\
  \astlabel(\tstruct(\tenv, \vttwo)) \typearrow \TInt
}
{\CheckBinop(\tenv, \POW, \vtone, \vttwo) \typearrow \TReal}
\and
\inferrule{
  \typesat(\tenv, \vtone, \TReal)\\
  \typesat(\tenv, \vttwo, \TReal)\\
}
{\CheckBinop(\tenv, \RDIV, \vtone, \vttwo) \typearrow \TReal}
\end{mathpar}

\end{emptyformal}

\subsection{Comments}
  This is related to \identr{BKNT}, \identr{ZYWY}, \identr{BZKW},
  \identr{KFYS}, \identr{KXMR}, \identr{SQXN}, \identr{MRHT}, \identr{JGWF},
  \identr{TTGQ}, \identi{YHML}, \identi{YHRP}, \identi{VMZF}, \identi{YXSY},
  \identi{LGHJ}, \identi{RXLG}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatetype}{}
The function
\[
  \annotatetype{\overname{\Bool}{\decl} \aslsep \overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}}
  \aslto \overname{\ty}{\vt} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a type $\tty$, in the context of a declaration indicated by $\decl$,
in an environment $\tenv$, resulting in a
annotated type $\newty$ and one of the following applies:
\begin{itemize}
  \item TypingRule.TString (see \secref{TypingRule.TString});
  \item TypingRule.TReal (see \secref{TypingRule.TReal});
  \item TypingRule.TBool (see \secref{TypingRule.TBool});
  \item TypingRule.TNamed (see \secref{TypingRule.TNamed});
  \item TypingRule.TInt (see \secref{TypingRule.TInt});
  \item TypingRule.TBits (see \secref{TypingRule.TBits});
  \item TypingRule.TTuple (see \secref{TypingRule.TTuple});
  \item TypingRule.TArray (see \secref{TypingRule.TArray});
  \item TypingRule.TEnumDecl (see \secref{TypingRule.TEnumDecl});
  \item TypingRule.TRecordExceptionDecl (see
    \secref{TypingRule.TRecordExceptionDecl});
  \item TypingRule.TNonDecl (see \secref{TypingRule.TNonDecl});
\end{itemize}
A type error is returned, if one is detected.

\section{TypingRule.TString \label{sec:TypingRule.TString}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the string type \TString.
  \item $\newty$ is the string type \TString.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{string} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TString.asl}

\CodeSubsection{\TStringBegin}{\TStringEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\Ignore, \tenv, \TString} \typearrow \TString
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TReal \label{sec:TypingRule.TReal}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the real type \TReal.
  \item $\newty$ is the real type \TReal.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{real} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TReal.asl}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\Ignore, \tenv, \TReal} \typearrow \TReal
}
\end{mathpar}
\end{emptyformal}

\CodeSubsection{\TRealBegin}{\TRealEnd}{../Typing.ml}

\isempty{\subsection{Comments}}

\section{TypingRule.TBool \label{sec:TypingRule.TBool}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the boolean type, \TBool;
  \item $\newty$ is the boolean type, \TBool.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{boolean} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBool.asl}

\CodeSubsection{\TBoolBegin}{\TBoolEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\Ignore, \tenv, \TBool} \typearrow \TBool
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TNamed \label{sec:TypingRule.TNamed}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the named type $\vx$, that is $\TNamed(\vx)$;
  \item retrieving the type associated with $\vx$ from the static environment $\tenv$ (via $\declaredtype$) yields $\vt$ \ProseOrTypeError;
  \item $\newty$ is $\tty$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{MyType} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TNamed.asl}

\CodeSubsection{\TNamedBegin}{\TNamedEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \declaredtype(\tenv, \vx) \typearrow \vt \OrTypeError
}{
  \annotatetype{\Ignore, \tenv, \TNamed(\vx)} \typearrow \TNamed(\vx)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TInt \label{sec:TypingRule.TInt}}

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item $\tty$ is the unconstrained integer type;
      \item $\newty$ is the unconstrained integer type.
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item $\tty$ is a under-constrained integer type;
      \item $\newty$ is the under-constrained integer type $\tty$.
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item $\tty$ is the well-constrained integer type constrained by
        constraints $\vc_i$, for $u=1..k$;
      \item annotating each constraint $\vc_i$, for $i=1..k$,
      yields $\newc_i$ \ProseOrTypeError;
      \item $\newconstraints$ is the list of annotated constraints $\newc_i$,
      for $i=1..k$;
      \item $\newty$ is the well-constrained integer type constrained
        by $\newconstraints$.
    \end{itemize}
\end{itemize}

\subsection{Example}

In the following examples, all the uses of integer types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntUnConstrained.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntWellConstrained.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntUnderConstrained.asl}

\CodeSubsection{\TIntBegin}{\TIntEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[unconstrained]{
  \tty \eqname \TInt(\unconstrained)\\
}{
  \annotatetype{\Ignore, \tenv, \tty} \typearrow \tty
}
\and
\inferrule[underconstrained]{
  \tty \eqname \TInt(\underconstrained(\Ignore))\\
}{
  \annotatetype{\Ignore, \tenv, \tty} \typearrow \tty
}
\and
\inferrule[well\_constrained]{
  \constraints \eqname \vc_{1..k}\\
  i=1..k: \tododefine{annotate\_constraint}(\vc_i) \newc_i \OrTypeError\\\\
  \newconstraints \eqdef \newc_{1..k}
}{
  \annotatetype{\Ignore, \tenv, \TInt(\wellconstrained(\constraints))} \typearrow \\ \TInt(\wellconstrained(\newconstraints))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TBits \label{sec:TypingRule.TBits}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the bit-vector type with width given by the expression
    $\ewidth$ and the bitfields given by $\bitfields$, that is, $\TBits(\ewidth, \bitfields)$;
  \item annotating the statically-evaluable integer expression $\ewidth$ yields $\ewidthp$ \ProseOrTypeError;
  \item annotating the bitfields $\bitfields$ yields $\bitfieldsp$ \ProseOrTypeError;
  \item $\newty$ is the bit-vector type with width given by the expression
    $\ewidthp$ and the bitfields given by $\bitfieldsp$, that is, $\TBits(\ewidthp, \bitfieldsp)$
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBits.asl}

In the following example, all the uses of bitvector types are valid:
\CodeSubsection{\TBitsBegin}{\TBitsEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tododefine{annotate\_static\_constrained\_integer}(\tenv, \ewidth) \typearrow \ewidthp \OrTypeError\\
  \annotatebitfield(\tenv, \ewidthp) \typearrow \bitfieldsp \OrTypeError
}{
  \annotatetype{\Ignore, \tenv, \TBits(\ewidth, \bitfields)} \typearrow \TBits(\ewidthp, \bitfieldsp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TTuple \label{sec:TypingRule.TTuple}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the tuple type with member types $\tys$, that is, $\TTuple(\tys)$;
  \item $\tys$ is the list $\tty_i$, for $i=1..k$;
  \item annotating each type $\tty_i$ in $\tenv$, for $i=1..k$,
  yields $\ttyp_i$ \ProseOrTypeError;
  \item $\newty$ is the tuple type with member types $\ttyp$, for $i=1..k$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of tuple types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TTuple.asl}

\CodeSubsection{\TTupleBegin}{\TTupleEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \tys \eqname \tty_{1..k}\\
  i=1..k: \annotatetype{\False, \tenv, \tty_i} \typearrow \ttyp_i \OrTypeError
}{
  \annotatetype{\Ignore, \tenv, \TTuple(\tys)} \typearrow \TTuple(\tysp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TArray \label{sec:TypingRule.TArray}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the array type indexed by integer bounded by the
    expression $\ve$ and of elements of type $\vt$;
  \item Annotating the type $\vt$ in $\tenv$ yields $\vtp$ \ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{expr\_is\_enum}):
    \begin{itemize}
      \item determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via \\ $\tododefine{get\_variable\_enum}$ yields the enumeration variable
      name $\vs$ of size $\vi$, that is, $\langle \vs, \vi \rangle$;
      \item $\newty$ is the array type indexed by an enumeration type
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$.
    \end{itemize}

    \item All of the following apply (\textsc{expr\_not\_enum}):
    \begin{itemize}
      \item determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via \\ $\tododefine{get\_variable\_enum}$ yields $\None$ (meaning it does not
      correspond to an enumeration);
      \item annotating the statically evaluable integer expression $\ve$ yields
      $\vep$ \ProseOrTypeError;
      \item $\newty$ the array type indexed by integer bounded by
      the expression $\vep$ and of elements of type $\vtp$, that is,
      $\TArray(\ArrayLengthExpr(\vep), \vtp)$.
    \end{itemize}

    \item All of the following apply (\textsc{index\_enum}):
    \begin{itemize}
      \item $\ve$ is an enumeration type index with variable $\vs$ and size $\vi$,
      that is, \\ $\ArrayLengthEnum(\vs, \vi)$;
      \item let $\tty$ be the named type defined for $\vs$, that is, $\TNamed(\vs)$;
      \item determining the \underlyingtype\ of $\tty$ yields $\vt$ \ProseOrTypeError;
      \item checking whether $\vt$ is an enumeration type yields $\True$ \ProseOrTypeError;
      \item $\vt$ is an enumeration with labels $\vli$;
      \item checking whether $\vli$ has the same length as $\vi$ yields $\True$ \ProseOrTypeError;
      \item $\newty$ is the array type indexed by an enumeration type
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following example, all the uses of array types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TArray.asl}

\CodeSubsection{\TArrayBegin}{\TArrayEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[expr\_is\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \tododefine{get\_variable\_enum}(\tenv, \ve) \typearrow \langle \vs, \vi \rangle
}{
  \annotatetype{\Ignore, \tenv, \TArray(\ArrayLengthExpr(\ve), \vt)} \typearrow \TArray(\ArrayLengthEnum(\vs, \vi), \vtp)
}
\and
\inferrule[expr\_not\_enum]{
  \annotatetype{\tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \tododefine{get\_variable\_enum}(\tenv, \ve) \typearrow \None\\
  \tododefine{annotate\_static\_integer}(\tenv, \ve) \typearrow \vep \OrTypeError
}{
  \annotatetype{\Ignore, \tenv, \TArray(\ArrayLengthExpr(\ve), \vt)} \typearrow \TArray(\ArrayLengthExpr(\vep), \vtp)
}
\and
\inferrule[index\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow \vtp \OrTypeError\\\\
  \tty \eqdef \TNamed(\vs)\\
  \makeanonymous(\tenv, \tty) \typearrow \vt \OrTypeError\\\\
  \checktrans{\astlabel(\vt) = \TEnum} \typearrow \True \OrTypeError\\\\
  \vt \eqname \TEnum((\vli))\\
  \checktrans{\equallength(\vli, \vi)} \typearrow \True \OrTypeError
}{
  \annotatetype{\Ignore, , \tenv, \TArray(\ArrayLengthEnum(\vs, \vi), \vt)} \typearrow \\
  \TArray(\ArrayLengthEnum(\vs, \vi), \vtp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TEnumDecl \label{sec:TypingRule.TEnumDecl}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is the enumeration type with enumeration literals
    $\vli$, that is, $\TEnum(\vli)$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item determining that $\vli$ does not contain duplicates yields $\True$ \ProseOrTypeError;
  \item determining that none of the labels in $\vli$ is declared in the global environment
  yields $\True$ \ProseOrTypeError;
  \item $\newty$ is the enumeration type $\tty$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of enumeration types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TEnumDecl.asl}

\CodeSubsection{\TEnumDeclBegin}{\TEnumDeclEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checknoduplicates(\vli) \typearrow \True \OrTypeError\\
  \vl \in \vli: \tododefine{check\_var\_not\_in\_genv}(\tenv, \vl) \typearrow \True \OrTypeError
}{
  \annotatetype{\True, \tenv, \TEnum(\vli)} \typearrow \TEnum(\vli)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TRecordExceptionDecl \label{sec:TypingRule.TRecordExceptionDecl}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is either a record type or an exception type, corresponding to its AST label $L$;
  \item the list of fields of $\tty$ is $\fields$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item $\fields$ is a list of pairs where the first element is an identifier and the second is a type --- $(\vx_i, \vt_i)$, for $i=1..k$;
  \item checking that the list of field identifiers $\vx_{1..k}$ does not contain duplicates
  yields $\True$ \ProseOrTypeError;
  \item annotating each field type $\vt_i$, for $i=1..k$, yields an annotated type $\vtp_i$
  \ProseOrTypeError;
  \item $\fieldsp$ is the list with $(\vx_i, \vtp_i)$, for $i=1..k$;
  \item $\newty$ is the AST node with AST label $L$ (either record type or exception type,
  corresponding to the type $\tty$) and fields $\fieldsp$.
\end{itemize}

\subsection{Example}
In the following example, all the uses of record or exception types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TRecordExceptionDecl.asl}

\CodeSubsection{\TRecordExceptionDeclBegin}{\TRecordExceptionDeclEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \fields \eqname [i=1..k: (\vx_i, \vt_i)]\\
  \checknoduplicates(\vx_{1..k}) \typearrow \True \OrTypeError\\
  i=1..k: \annotatetype{\False, \tenv, \vt_i} \typearrow \vtp_i \OrTypeError\\
  \fieldsp \eqdef [i=1..k: (\vx_i, \vtp_i)]
}{
  \annotatetype{\True, \tenv, L(\fields)} \typearrow L(\fieldsp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.TNonDecl \label{sec:TypingRule.TNonDecl}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tty$ is either a record type, an exception type, or an enumeration type;
  \item $\decl$ is $\False$, indicating that $\tty$ should be considered to be outside the context of a declaration
  of $\tty$;
  \item a type error is returned, indicating that the use of anonymous form of enumerations, record,
  and exceptions types is not allowed here.
\end{itemize}

\subsection{Example}

In the following example, the use of a record type outside of a declaration is erroneous:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TNonDecl.asl}

\CodeSubsection{\TNonDeclBegin}{\TNonDeclEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \astlabel(\tty) \in \{\TEnum, \TRecord, \TException\}
}{
  \annotatetype{\False, \tenv, \tty} \typearrow \TypeErrorVal{AnnonymousFormNotAllowedHere}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Bitfields}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We define rules for annotating a single bitfield and a list of bitfields:
\begin{itemize}
  \item TypingRule.TBitField (see \secref{TypingRule.TBitField});
  \item TypingRule.TBitFields (see \secref{TypingRule.TBitFields});
\end{itemize}

\section{TypingRule.TBitField \label{sec:TypingRule.TBitField}}
\hypertarget{def-annotatebitfield}{}
The function
\[
  \annotatebitfield(\overname{\staticenvs}{\tenv} \aslsep \overname{\Z}{\width} \aslsep \overname{\bitfield}{\field})
  \aslto \overname{\bitfield}{\newfield} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a bitfield --- $\field$ --- with an integer --- $\width$ --- indicating the number of bits in $\field$,
in an environment $\tenv$, resulting in an
annotated bitfield --- $\newfield$ --- or a type error, if one is detected.

\subsection{Prose}
\begin{itemize}
  \item Annotating the slices $\slices$ yields $\slicesone$ \ProseOrTypeError;
  One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{simple}):
    \begin{itemize}
      \item checking whether the range of positions in $\slicesone$ fit inside $0..\width$ yields $\True$ \ProseOrTypeError;
      \item $\newfield$ is a bitfield named $\name$ with list of slices $\slicesone$, that is, $\BitFieldSimple(\name, \sliceone)$.
    \end{itemize}

    \item All of the following apply (\textsc{nested}):
    \begin{itemize}
      \item converting the $\slicesone$ into a list of positions with $\width$ and static environment $\tenv$
      yields $\positions$ \ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields $\True$ \ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item annotating the bitfields $\bitfieldsp$ with $\widthp$ in static environment $\tenv$ yields $\bitfieldspp$ \ProseOrTypeError;
      \item $\newfields$ is the nested bitfield with $\slicesone$ and bitfields $\bitfieldspp$, that is, $\BitFieldNested(\slicesone, \bitfieldspp)$.
    \end{itemize}

    \item All of the following apply (\textsc{type}):
    \begin{itemize}
      \item Annotating the type $\vt$ yields $\vtp$ \ProseOrTypeError;
      \item checking whether the range of positions in $\slicesone$ fit inside $0..\width$ yields $\True$ \ProseOrTypeError;
      \item converting the list of slices $\slicesone$ into a list of positions in $\tenv$ yields $\positions$ \ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields $\True$ \ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item checking whether the $\vt$ and the bitvector with $\widthp$ bits have the same width yields $\True$ \ProseOrTypeError
      \item $\newfield$ is the typed-bitfield with name $\name$, list of slices $\slicesone$ and type $\vtp$, that is, \BitFieldType(\name, \slicesone, \vtp).
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following example, all the uses of bitvector types with bitfields are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBitField.asl}

\CodeSubsection{\TBitFieldBegin}{\TBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[simple]{
  \annotateslices(\tenv, \slices) \typearrow \slicesone \OrTypeError\\
  \tododefine{check\_slices\_in\_width}(\tenv, \width, \slicesone) \typearrow \True \OrTypeError
}{
  \annotatebitfield(\tenv, \width, \BitFieldSimple(\name, \slices)) \typearrow \\
  \BitFieldSimple(\name, \sliceone)
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested]{
  \annotateslices(\tenv, \slices) \typearrow \slicesone \OrTypeError\\
  \tododefine{disjoint\_slices\_to\_positions}(\tenv, \width, \slicesone) \typearrow \positions \OrTypeError\\\\
  \tododefine{check\_positions\_in\_width}(\tenv, \width, \positions) \typearrow \True \OrTypeError\\
  \widthp \eqdef |\positions|\\
  \annotatebitfields(\tenv, \widthp, \bitfieldsp) \typearrow \bitfieldspp \OrTypeError\\
}{
  \annotatebitfield(\tenv, \width, \BitFieldNested(\name, \slices, \bitfieldsp)) \typearrow \\
  \BitFieldNested(\slicesone, \bitfieldspp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[type]{
  \annotateslices(\tenv, \slices) \typearrow \slicesone \OrTypeError\\
  \annotatetype{\tenv, \vt} \typearrow \vtp \OrTypeError\\
  \tododefine{check\_slices\_in\_width}(\tenv, \width, \slicesone) \typearrow \True \OrTypeError\\
  \tododefine{disjoint\_slices\_to\_positions}(\tenv, \slicesone) \typearrow \positions \OrTypeError\\\\
  \tododefine{check\_positions\_in\_width}(\tenv, \slicesone, \width, \positions) \typearrow \True \OrTypeError\\
  \widthp \eqdef |\positions|\\
  \tododefine{check\_bits\_equal\_width}(\TBits(\widthp, \emptylist), \vt) \typearrow \True \OrTypeError
}{
  \annotatebitfield(\tenv, \width, \BitFieldType(\name, \slices, \vt)) \typearrow \\
  \BitFieldType(\name, \slicesone, \vtp)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.TBitFields \label{sec:TypingRule.TBitFields}}
\hypertarget{def-annotatebitfields}{}
The function
\[
  \annotatebitfields(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ewidth} \aslsep \overname{\bitfields}{\fields})
  \aslto \overname{\bitfields}{\newfields} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of bitfields --- $\fields$ --- with an expression denoting the overall number of bits --- $\ewidth$,
in an environment $\tenv$, resulting in an
annotated list of bitfields --- $\newfields$ or a type error, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that the list of bitfield names in $\bitfields$ does not contain duplicates yields $\True$ \ProseOrTypeError;
  \item symbolically reducing $\ewidth$ in $\tenv$ yields the literal integer for $\vi$ \ProseOrTypeError;
  \item annotating each bitfield $\field$ in $\fields$ with width $\width$ in $\tenv$ yields the corresponding annotated
  bitfield $\newfield$ \ProseOrTypeError;
  \item $\newfields$ is the list of annotated bitfields.
\end{itemize}

\isempty{\subsection{Example}}

\CodeSubsection{\TBitFieldsBegin}{\TBitFieldsEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\newcommand\getbitfieldname[0]{\texttt{get\_bitfield\_name}}
We first define the helper function $\getbitfieldname : \bitfield \aslto \identifier$,
which extracts the name of a bitfield:
\begin{mathpar}
  \inferrule[simple]{}{
    \getbitfieldname(\BitFieldSimple(\name, \Ignore)) \typearrow \name
  }
  \and
  \inferrule[nested]{}{
    \getbitfieldname(\BitFieldNested(\name, \Ignore, \Ignore)) \typearrow \name
  }
  \and
  \inferrule[type]{}{
    \getbitfieldname(\BitFieldType(\name, \Ignore, \Ignore)) \typearrow \name
  }
\end{mathpar}

Now the rule for annotating a list of bitfields is
\begin{mathpar}
\inferrule{
  \names \eqdef [\field\in\fields: \getbitfieldname(\field)]\\
  \checknoduplicates(\names) \typearrow \True \OrTypeError\\
  \reduceconstants{\tenv, \ewidth} \typearrow \lint(\vi) \OrTypeError\\
  \field\in\fields: \annotatebitfield(\tenv, \width, \field) \typearrow \newfield \OrTypeError\\
  \newfields \eqdef [\field\in\fields: \newfield]
}
{
  \annotatebitfields(\tenv, \ewidth, \fields) \typearrow \newfields
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotateexpr}{}
The function
\[
  \annotateexpr{\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}}
  \aslto (\overname{\ty}{\vt} \times \overname{\expr}{\newe})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
specifies how to annotate an expression $\ve$ in
an environment \tenv.  Formally, the result of annotating the expression
$\ve$ in \tenv\ is either the pair $(\vt, \newe)$, where $\vt$ is a type and
$\newe$ is an annotated expression, or a type error, and one of the following applies:
\begin{itemize}
\item TypingRule.ELit (see \secref{TypingRule.ELit});
\item TypingRule.ELocalVarConstant (see \secref{TypingRule.ELocalVarConstant})
\item TypingRule.ELocalVar (see \secref{TypingRule.ELocalVar})
\item TypingRule.EGlobalVarConstant (see \secref{TypingRule.EGlobalVarConstant})
\item TypingRule.EGlobalVar (see \secref{TypingRule.EGlobalVar})
\item TypingRule.EUndefIdent (see \secref{TypingRule.EUndefIdent})
\item TypingRule.Binop (see \secref{TypingRule.Binop})
\item TypingRule.Unop (see \secref{TypingRule.Unop})
\item TypingRule.ECond (see \secref{TypingRule.ECond})
\item TypingRule.ESlice (see \secref{TypingRule.ESlice})
\item TypingRule.ESetter (see \secref{TypingRule.ESetter})
\item TypingRule.ECall (see \secref{TypingRule.ECall})
\item TypingRule.EGetArray (see \secref{TypingRule.EGetArray})
\item TypingRule.ESliceOrEGetArrayError (see \secref{TypingRule.ESliceOrEGetArrayError})
\item TypingRule.EStructuredNotStructured (see \secref{TypingRule.EStructuredNotStructured})
\item TypingRule.EStructuredMissingField (see \secref{TypingRule.EStructuredMissingField})
\item TypingRule.ERecord (see \secref{TypingRule.ERecord})
\item TypingRule.EGetRecordField (see \secref{TypingRule.EGetRecordField})
\item TypingRule.EGetBadRecordField (see \secref{TypingRule.EGetBadRecordField})
\item TypingRule.EGetBadBitField (see \secref{TypingRule.EGetBadBitField})
\item TypingRule.EGetBadField (see \secref{TypingRule.EGetBadField})
\item TypingRule.EGetBitField (see \secref{TypingRule.EGetBitField})
\item TypingRule.EGetBitFieldNested (see \secref{TypingRule.EGetBitFieldNested})
\item TypingRule.EGetBitFieldTyped (see \secref{TypingRule.EGetBitFieldTyped})
\item TypingRule.EConcatEmpty (see \secref{TypingRule.EConcatEmpty})
\item TypingRule.EConcat (see \secref{TypingRule.EConcat})
\item TypingRule.ETuple (see \secref{TypingRule.ETuple})
\item TypingRule.EUnknown (see \secref{TypingRule.EUnknown})
\item TypingRule.EPattern (see \secref{TypingRule.EPattern})
\item TypingRule.ATC (see \secref{TypingRule.ATC})
\end{itemize}

The annotation rewrites the input expression in the following cases, making the annotation of statements simpler:
\begin{itemize}
  \item Variables with constant values are substituted by their constant values.
  \item Slicing expressions that correspond to calling a getter are replaced with respective call expressions.
  \item Slicing expressions that correspond to array accesses are replaced with array access expressions.
\end{itemize}

We also define the following helper rules:
\begin{itemize}
  \item TypingRule.Lit (\secref{TypingRule.Lit})
  \item TypingRule.ExpressionList (\secref{TypingRule.ExpressionList})
  \item TypingRule.TypingRule.ReduceSlicesToCall (\secref{TypingRule.ReduceSlicesToCall})
\end{itemize}

\section{TypingRule.ELit \label{sec:TypingRule.ELit}}
\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ is a literal expression $\vv$;
\item $\vt$ is the type of the literal $\vv$;
\item $\newe$ is $\ve$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ELitBegin}{\ELitEnd}{../Typing.ml}
\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{\annotateliteral{\vv} \typearrow \vt}
{\annotateexpr{\tenv, \ELiteral(\vv)} \typearrow (\vt, \ELiteral(\vv))}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ELocalVarConstant \label{sec:TypingRule.ELocalVarConstant}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a local variable $\vx$;
\item $\vx$ is bound to a local constant $\vv$ of type $\tty$ in the local environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is the Literal $\vv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ELocalVarConstantBegin}{\ELocalVarConstantEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\constantvalues(\vx) = \vv\\
  L^\tenv.\localstoragetypes(\vx) = (\tty, \LDKConstant)
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \eliteral{\vv})}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ELocalVar \label{sec:TypingRule.ELocalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a local variable $\vx$;
\item $\vx$ is not bound to a constant in the local environment given by $\tenv$;
\item $\vx$ has type $\tty$ in the local environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is $\ve$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ELocalVarBegin}{\ELocalVarEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\constantvalues(\vx) = \bot\\
  L^\tenv.\localstoragetypes(\vx) =  (\tty, k) \\
  k \in \{\LDKVar, \LDKLet\}
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \EVar(\vx))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVarConstantVal \label{sec:TypingRule.EGlobalVarConstant}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a global variable $\vx$;
\item $\vx$ is bound to a constant $\vv$ of type $\tty$ in the global environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is the Literal $\vv$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGlobalVarConstantBegin}{\EGlobalVarConstantEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \vv
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \eliteral{\vv})}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVarConstantNoVal \label{sec:TypingRule.EGlobalVarConstantNoVal}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a global variable $\vx$;
\item $\vx$ is not bound to constant in the global environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is $\ve$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGlobalVarConstantNoValBegin}{\EGlobalVarConstantNoValEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \bot
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \EVar(\vx))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVar \label{sec:TypingRule.EGlobalVar}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a global variable $\vx$;
\item $\vx$ is not bound to a global constant;
\item $\vx$ has type $\tty$ in the global environment given by $\tenv$;
\item $\vt$ is $\tty$;
\item $\newe$ is $\ve$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGlobalVarBegin}{\EGlobalVarEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\constantvalues(\vx) = \bot\\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, k)\\
  k \neq \GDKConstant
  }
{\annotateexpr{\tenv, \EVar(\vx)} \typearrow (\tty, \EVar(\vx))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EUndefIdent \label{sec:TypingRule.EUndefIdent}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ is a variable $\vx$;
\item $\vx$ is not bound in $\tenv$;
\item the result is a type error indicating that $\vx$ is an undefined identifier.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EUndefIdentBegin}{\EUndefIdentEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\globalstoragetypes(\vx) = \bot\\
  L^\tenv.\globalstoragetypes(\vx) = \bot\\
}{
  \annotateexpr{\tenv, \EVar(\vx)} \typearrow \TypeErrorVal{UndefinedIdentifier}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.Binop \label{sec:TypingRule.Binop}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a binary operation $\op$ over two expressions $\veone$ and $\vetwo$, that is, $\EBinop(\op, \veone, \vetwo)$;
  \item the result of annotating $\veone$ in $\tenv$ is $(\vtone, \veonep)$ \ProseOrTypeError;
  \item the result of annotating $\vetwo$ in $\tenv$ is $(\vttwo, \vetwop)$ \ProseOrTypeError;
  \item the result of checking compatibility of $\op$ with $\vtone$ and $\vttwo$ as per \secref{TypingRule.CheckBinop}
  is $\vt$ \ProseOrTypeError;
  \item $\newenv$ denotes $\op$ over $\veonep$ and $\vetwop$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\BinopBegin}{\BinopEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veone') \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwo') \OrTypeError\\\\
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError
  }
{\annotateexpr{\tenv, \EBinop(\op, \veone, \vetwo)} \typearrow (\vt, \EBinop(\op, \veone', \vetwo'))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.Unop \label{sec:TypingRule.Unop}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a unary operation $\op$ over an expression $\vep$, that is $\EUnop(\op, \vep)$;
  \item annotating $\vep$ in $\tenv$ yields $(\vtpp, \vepp)$ \ProseOrTypeError;
  \item checking compatibility of $\op$ with $\vtpp$ as per \secref{TypingRule.CheckUnop} yields $\vt$ \ProseOrTypeError;
  \item $\newe$ denotes $\op$ over $\vepp$, that is, $\EUnop(\op, \vepp)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\UnopBegin}{\UnopEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vtpp, \vepp) \OrTypeError\\
  \CheckUnop(\tenv, \op, \vtpp) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\tenv, \EUnop(\op, \vep)} \typearrow (\vt, \EUnop(\op, \vepp))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ECond \label{sec:TypingRule.ECond}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a conditional expression with condition $\econd$ with two options $\etrue$ and $\efalse$;
  \item annotating $\econd$ in $\tenv$ results in $(\tcond, \econdp)$ \ProseOrTypeError;
  \item annotating $\etrue$ in $\tenv$ results in $(\ttrue, \etruep)$ \ProseOrTypeError;
  \item annotating $\efalse$ in $\tenv$ results in $(\tfalse, \efalsep)$;
  \item obtaining the lowest common ancestor of $\ttrue$ and $\tfalse$ results in $\vt$ \ProseOrTypeError;
  \item $\newe$ is the condition $\econdp$ with two options $\etruep$ and $\efalsep$, that is, $\ECond(\econdp, \etruep, \efalsep)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ECondBegin}{\ECondEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \econd} \typearrow (\tcond, \econd') \OrTypeError\\
  \annotateexpr{\tenv, \etrue} \typearrow (\ttrue, \etrue') \OrTypeError\\
  \annotateexpr{\tenv, \efalse} \typearrow (\tfalse, \efalse') \OrTypeError\\
  \lca(\ttrue, \tfalse) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\ECond(\econd, \etrue, \efalse)} \typearrow (\vt, \ECond(\econdp, \etruep, \efalsep))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{XZVT}.

\section{TypingRule.ESlice \label{sec:TypingRule.ESlice}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
  $\ESlice(\vep, \slices)$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a negative answer --- $\None$ \ProseOrTypeError;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\tep,\vepp)$ \ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\structtep$ \ProseOrTypeError;
  \item $\structtep$ is either a bitvector or an integer;
  \item obtaining the width of $\slices$ in $\tenv$ via $\sliceswidth$ yields $\vw$ \ProseOrTypeError;
  \item $\slicesp$ is the result of annotating $\slices$ in $\tenv$;
  \item $\vt$ is the bitvector type of width $\vw$, that is, $\TBits(\vw, \emptylist)$;
  \item $\newe$ is the slicing of expression $\vepp$ by the slices $\slicesp$, that is, \\
  $\ESlice(\vepp, \slicesp)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ESliceBegin}{\ESliceEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \vep} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \structtep \OrTypeError\\\\
  \astlabel(\structtep) \in \{\TInt, \TBits\}\\
  \sliceswidth(\tenv, \slices) \typearrow \vw \OrTypeError\\\\
  \annotateslices(\tenv, \slices) \typearrow \slicesp \OrTypeError
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow (\TBits(\vw, \emptylist), \ESlice(\vepp, \slicesp))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  The width of \slices\ might be a symbolic expression if one of the
  widths references a \texttt{let} identifier with a non-compile-time-constant
  initialiser expression.

  This is related to \identi{MJWM}.

\section{TypingRule.ESetter \label{sec:TypingRule.ESetter}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
  $\ESlice(\vep, \slices)$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a positive answer --- $\langle (\name, \vargs)\rangle$ \ProseOrTypeError;
  \item annotating a call with $(\tenv, \name, \vargs, \emptylist, \STSetter)$
  (that is, an empty list of parameters) yields $(\nameone, \vargsone, \eqs, \langle\tty\rangle)$ \ProseOrTypeError;
  \item $vt$ is $\tty$;
  \item $\newe$ is the call expression $\ECall(\nameone, \vargsone, \eqs)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ESetterBegin}{\ESetterEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotatecall{\tenv, \name, \vargs, \emptylist, \STSetter} \typearrow (\nameone, \vargsone, \eqs, \langle\tty\rangle) \OrTypeError\\
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow (\tty, \ECall(\nameone, \vargsone, \eqs))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}

\section{TypingRule.ECall \label{sec:TypingRule.ECall}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a call to a subprogram named $\name$ with arguments $\vargs$ and
    parameters $\eqs$, that is, $\ECall(\name, \vargs, \eqs)$;
  \item annotating the call of that subprogram in $\tenv$ (annotating calls is defined in Chapter~\ref{chap:TypingSubprogramCalls})
  yields $(\namep, \vargsp, \eqsp, \langle \vt \rangle)$ \ProseOrTypeError;
  \item $\newe$ is the call to the subprogram named $\namep$ with arguments $\vargsp$
    and parameters $\eqsp$, that is, $\ECall(\name, \vargsp, \eqsp)$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ECallBegin}{\ECallEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatecall{\tenv, \name, \vargs, \eqs, \STFunction} \typearrow (\namep, \vargsp, \eqsp, \langle \vt \rangle) \OrTypeError
}{
  \annotateexpr{\tenv, \ECall(\name, \vargs, \eqs)} \typearrow (\vt, \ECall(\name, \vargsp, \eqsp))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identd{CFYP}, \identr{BQJG}.

\section{TypingRule.EGetArray \label{sec:TypingRule.EGetArray}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a negative answer --- $\None$ \ProseOrTypeError;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure of an array with index $\size$ and element type $\tty$';
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{okay}):
    \begin{itemize}
      \item $\slices$ consists of a single slice $\SliceSingle(\eindex)$;
      \item annotating the expression $\eindex$ in $\tenv$ yields $(\tindexp, \eindexp)$ \ProseOrTypeError;
      \item determing the type of the array index for $\size$ in $\tenv$ via \\ $\typeofarraylength$
      yields $\wantedtindex$;
      \item determining whether $\tindexp$ \typesatisfies\ $\wantedtindex$ yields $\True$ \ProseOrTypeError;
      \item $\vt$ is $\ttyp$;
      \item $\newe$ is the array access expression for $\vepp$ and index $\eindexp$, that is, $\EGetArray(\vepp, \eindexp)$.
    \end{itemize}

    \item All of the following apply (\textsc{error}):
    \begin{itemize}
      \item $\slices$ consists of a single slice $\SliceSingle(\eindex)$;
      \item the result is a type error indicating that an array must be accessed with a slice corresponding to a single index
      expression.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\EGetArrayBegin}{\EGetArrayEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \ve} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \TArray(\size, \ttyp) \OrTypeError\\\\
  \slices = [ \SliceSingle(\eindex) ]\\
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp) \OrTypeError\\
  \typeofarraylength(\tenv, \size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow (\ttyp, \EGetArray(\vepp, \eindexp))
}
\and
\inferrule[error]{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \ve} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \TArray(\size, \ttyp) \OrTypeError\\\\
  \slices \neq [ \SliceSingle(\Ignore) ]\\
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow \TypeErrorVal{IllegalArraySlice}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ESliceOrEGetArrayError \label{sec:TypingRule.ESliceOrEGetArrayError}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item determining whether $\vep$ together with $\slices$ corresponds to a subprogram call
  in $\tenv$ via $\reduceslicestocall$ yields a negative answer --- $\None$ \ProseOrTypeError;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure $\vtp$;
  \item $\vtp$ is neither an integer type, a bitvector type, or an array type;
  \item the result is an error indicating that the type of $\vep$ is inappropriate for slicing.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ESliceOrEGetArrayErrorBegin}{\ESliceOrEGetArrayErrorEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \reduceslicestocall(\tenv, \vep, \slices) \typearrow \None \OrTypeError\\\\
  \annotateexpr{\tenv, \ve} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \vtp\\
  \astlabel(\vtp) \not\in \{\TInt, \TBits, \TArray\}
}{
  \annotateexpr{\tenv, \ESlice(\vep, \slices)} \typearrow \TypeErrorVal{IllegalSliceType}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EStructuredNotStructured \label{sec:TypingRule.EStructuredNotStructured}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes the record expression or an exception expression of type $\tty$ with fields $\fields$;
\item determining whether $\tty$ is a named type yields $\True$ \ProseOrTypeError;
\item determining the \structure\ of $\tty$ yields $\vtp$ \ProseOrTypeError;
\item $\vtp$ is neither a record nor an exception type;
\item the result is an error indicating that $\tty$ is not appropriate for constructing a record.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EStructuredNotStructuredBegin}{\EStructuredNotStructuredEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed} \typearrow \True \OrTypeError\\
  \tstruct{\tenv, \tty} \typearrow\vtp \OrTypeError\\
  \astlabel(\vtp) \not\in \{\TRecord, \TException\}
}
{
  \annotateexpr{\tenv, \ERecord(\tty, \fields)} \typearrow \TypeErrorVal{NonStructuredType}
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

  This is related to \identr{WBCQ}.

\section{TypingRule.EStructuredMissingField \label{sec:TypingRule.EStructuredMissingField}}

\subsection{Prose}
A§ll of the following apply:
\begin{itemize}
  \item $\ve$ denotes the record expression or an exception expression of type $\tty$ with fields $\fields$;
  \item $\tty$ is the name of a record or exception type with fields $\fieldtypes$;
  \item there exists a field in $\fieldtypes$ that is not initialised by $\fields$;
  \item the result is an error indicating that a field is missing initialization.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EStructuredMissingFieldBegin}{\EStructuredMissingFieldEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed} \typearrow \True \OrTypeError\\
  \tstruct{\tenv, \tty} \typearrow L(\fieldtypes) \OrTypeError\\
  L \in \{\TRecord, \TException\}\\
  (\name, \vtp)\in\fieldtypes: \vb_\name \eqdef (\name, \vtp) \in \fields\\
  \vb = \bigwedge{(\name, \vtp)\in\fieldtypes} \vb_\name\\
  \vb = \False
}
{
  \annotateexpr{\tenv, \ERecord(\tty, \fields)} \typearrow \TypeErrorVal{MissingField}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WBCQ}.

\section{TypingRule.ERecord \label{sec:TypingRule.ERecord}}

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the record expression or an exception expression of type $\tty$ with fields $\fields$;
  \item $\tty$ is the name of a record or exception type with fields $\fieldtypes$;
  \item every field in $\fieldtypes$ is initialised by $\fields$;
  \item annotating the field initializations via $\tododefine{annotate\_field\_init}$
  yields $\fieldsp$ \ProseOrTypeError;
  \item $\vt$ is $\tty$;
  \item $\newe$ is the record expression with type $\tty$ and field initializers $\fieldsp$, that is, $\ERecord(\tty, \fieldsp)$;

  % \item For each field named $\name$ associated with the expression $\vep$ in
  %   $\fieldtypes$, all of the following apply:
  %   \begin{itemize}
  %   \item $(\vtp,\vepp)$ is the result of annotating $\vep$ in $\tenv$;
  %   \item $\tspecp$ is the type associated to $\name$ in $\fieldtypes$;
  %   \item $\vtp$ \typesatisfies\  $\tspecp$ as per \secref{TypingRule.TypeSatisfaction};
  %   \item $\fieldsp$ associates $\name$ to $\vepp$;
  %   \end{itemize}
  % \item $\vt$ is $\tty$;
  % \item $\newe$ is the record expression of type $\tty$ with fields $\fieldsp$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\ERecordBegin}{\ERecordEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed} \typearrow \True \OrTypeError\\
  \tstruct{\tenv, \tty} \typearrow L(\fieldtypes) \OrTypeError\\
  L \in \{\TRecord, \TException\}\\
  (\name, \vtp)\in\fieldtypes: \vb_\name \eqdef (\name, \vtp) \in \fields\\
  \vb = \bigwedge{(\name, \vtp)\in\fieldtypes} \vb_\name\\
  \vb = \True\\
  \tododefine{annotate\_field\_init}(\tenv, \fields, \fieldtypes) \typearrow \fieldsp
}
{
  \annotateexpr{\tenv, \ERecord(\tty, \fields)} \typearrow (\tty, \ERecord(\tty, \fieldsp))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WBCQ}.

\section{TypingRule.EGetRecordField \label{sec:TypingRule.EGetRecordField}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes the access of field \texttt{field\_name} on expression $\veone$;
  \item \texttt{t\_e1, e2} is the result of annotating $\veone$ in $\tenv$;
  \item \texttt{t\_e1} has an \underlyingtype\ of an exception or record type with fields $\fields$;
  \item \texttt{field\_name} is declared in $\fields$;
  \item $\vt$ is the type corresponding to \texttt{field\_name} in $\fields$;
  \item $\newe$ is the access of field \texttt{field\_name} on expression \vetwo.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetRecordFieldBegin}{\EGetRecordFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\begin{mathpar}
\inferrule{
\annotateexpr{\tenv, \veone} \typearrow (\texttt{t\_e1}, \vetwo)\\
\makeanonymous(\tenv, \texttt{t\_e1}) \typearrow L(\fields)\\
L \in \{\TRecord, \TException\}\\
(\fieldname,\vt) \in \fields
}
{\annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow (\vt, \EGetField(\fieldname, \vetwo))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadRecordField \label{sec:TypingRule.EGetBadRecordField}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes the access of field \texttt{field\_name} on expression $\veone$;
  \item \texttt{t\_e1, e2} is the result of annotating $\veone$ in $\tenv$;
  \item \texttt{t\_e1} has the structure of an exception or record type with fields $\fields$;
  \item \texttt{t\_e2} has the structure of an exception or record type with fields $\fields$;
  \item \texttt{t\_e2} is an Exception or a Record type with fields $\fields$;
  \item \texttt{field\_name} is not declared in $\fields$;
  \item an error ``\texttt{Bad Field}'' is raised.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBadRecordFieldBegin}{\EGetBadRecordFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadBitField \label{sec:TypingRule.EGetBadBitField}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes the access of field \texttt{field\_name} on expression $\veone$;
  \item \texttt{t\_e1} has the structure a bitvector type with bitfields $\bitfields$;
  \item \texttt{t\_e2} has the structure a bitvector type with bitfields $\bitfields$;
  \item \texttt{field\_name} is not declared in $\bitfields$;
  \item an error ``\texttt{Bad Field}'' is raised.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBadBitFieldBegin}{\EGetBadBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadField \label{sec:TypingRule.EGetBadField}}

 \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
   \begin{itemize}
   \item $\ve$ denotes the access of field \texttt{field\_name} on expression $\veone$;
   \item \texttt{t\_e1, e2} is the result of annotating $\veone$ in $\tenv$;
   \item \texttt{t\_e1} does not have the structure of a record or an exception or a bitvector type;
   \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

 \subsection{Example}


    \CodeSubsection{\EGetBadFieldBegin}{\EGetBadFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitField \label{sec:TypingRule.EGetBitField}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes the access of field \texttt{field\_name} on expression $\veone$;
  \item \texttt{t\_e1, e2} is the result of annotating $\veone$ in $\tenv$;
  \item the \underlyingtype\ of \texttt{t\_e1} is a bitvector type with bitfields $\bitfields$;
  \item \texttt{field\_name} is declared in $\bitfields$;
  \item $\slices$ gives the slices corresponding to the bitfield \texttt{field\_name}
    in \\ $\bitfields$;
  \item \texttt{e3} denotes the slicing of the expression \vetwo by the slices $\slices$;
  \item $(\vt, \newe)$ is the result of annotating \texttt{e3}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBitFieldBegin}{\EGetBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
\annotateexpr{\tenv, \veone} \typearrow (\texttt{t\_e1}, \vetwo)\\
\makeanonymous(\tenv, \texttt{t\_e1}) \typearrow \TBits(\Ignore, \bitfields)\\
\fieldname = \texttt{BitField\_Simple}(\Ignore, \slices) \in \bitfields\\
\texttt{e3} = \ESlice(\vetwo, \slices)\\
\annotateexpr{\tenv, \texttt{e3}} \typearrow (\vt, \newe)
}
{\annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow (\vt, \newe)}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldNested \label{sec:TypingRule.EGetBitFieldNested}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes the access of field \texttt{field\_name} on expression $\veone$;
  \item \texttt{t\_e1, e2} is the result of annotating $\veone$ in $\tenv$;
  \item \texttt{t\_e1} has the structure of a bitvector type with bitfields $\bitfields$;
  \item \texttt{field\_name} is declared in $\bitfields$;
  \item $\slices$ gives the slices corresponding to the bitfield \texttt{field\_name} in \\
    $\bitfields$;
  \item \texttt{e3} denotes the slicing of the expression \vetwo by the slices $\slices$;
  \item \texttt{t4, e4} is the result of annotating \texttt{e3} in $\tenv$;
  \item $\bitfieldsp$ gives the bitfields corresponding to the bitfield \texttt{field\_name}
    in $\bitfields$;
  \item $\vt$ is the bitvector type with the width of \texttt{t4} and the bitfields $\bitfieldsp$
  \item $\newe$ is \texttt{e4}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBitFieldNestedBegin}{\EGetBitFieldNestedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldTyped \label{sec:TypingRule.EGetBitFieldTyped}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes \texttt{e1, field\_name};
  \item \texttt{t\_e1, e2} is the result of annotating $\veone$ in $\tenv$;
  \item \texttt{t\_e1} has the \underlyingtype\ of a bitvector with bitfields $\bitfields$;
  \item \texttt{field\_name} is declared in $\bitfields$;
  \item $\slices$ gives the slices corresponding to the bitfield \texttt{field\_name} in \\
    $\bitfields$;
  \item $\vt$ is the type associated with \texttt{field\_name} in $\bitfields$;
  \item \texttt{t\_e3,e3} is the result of annotating \texttt{e2,slices} in $\tenv$;
  \item $\vt$ is the type corresponding to the bitfield \texttt{field\_name} in $\bitfields$;
  \item \texttt{t\_e3} \typesatisfies\  $\vt$ in $\tenv$;
  \item $\newe$ is \texttt{e3}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBitFieldTypedBegin}{\EGetBitFieldTypedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\texttt{t\_e1}, \vetwo)\\
  \makeanonymous(\tenv, \texttt{t\_e1}) \typearrow \TBits(\Ignore, \bitfields)\\
  \fieldname = \texttt{BitField\_Type}(\Ignore, \slices, \vt) \in \bitfields\\
  \annotateexpr{\ESlice(\vetwo, \slices)} \typearrow (\texttt{t\_e3}, \texttt{e3})\\
  \typesat(\tenv, \texttt{t\_e3}, \vt)
}
{\annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow (\vt, \texttt{e3})}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EConcatEmpty \label{sec:TypingRule.EConcatEmpty}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes the empty concatenation;
  \item $\vt$ is \texttt{bits(0)};
  \item $\newe$ is $\ve$.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EConcatEmptyBegin}{\EConcatEmptyEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{\ve = \EConcat(\emptylist)}
{
\annotateexpr{\tenv, \ve} \typearrow (\TBits(\texttt{BitWidth\_SingleExpr}(\Elit{0}, \emptylist)), \ve)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EConcat \label{sec:TypingRule.EConcat}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes the concatenation of a non-empty list of expressions $\vli$;
  \item \texttt{ts, es} is the list of types and the list of corresponding expressions resulting from annotating each element of $\vli$ in $\tenv$;
  \item all elements of \texttt{ts} have the structure of a bitvector type;
  \item $\vw$ is the sum of the widths of the bitvector types in \texttt{ts};
  \item $\vt$ is \texttt{bits(w)};
  \item $\newe$ is the concatenation expression for \texttt{es}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EConcatBegin}{\EConcatEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\[
\inferrule{
\vli = [i=1..k: \texttt{el}_i]\\
[\annotateexpr{\tenv, \texttt{el}_i} \typearrow (\ve_i, \vt_i)\;|\; i=1..k]\\
\texttt{ts} = [i=1..k: \vt_i]\\
\texttt{es} = [i=1..k: \ve_i]\\
i=1..k: \astlabel(\tstruct(\tenv, \vt_i)) \typearrow \TBits\\
\getbitvectorwidth(\tenv, \texttt{ts}) \typearrow \vw
}
{
\annotateexpr{\tenv, \EConcat(\vli)} \typearrow (\TBits(w, \emptylist)),
\EConcat(\texttt{es}, \None)
}
\]
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{NYNK} and \identr{KCZS}.

  The sum of the widths of the bitvector types~\texttt{ts} might be a symbolic
expression that is unresolvable to an integer. For example:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.EConcatUnresolvableToInteger.asl}


\section{TypingRule.ETuple \label{sec:TypingRule.ETuple}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes a tuple $\vli$;
  \item \texttt{ts, es} is the result of annotating in $\tenv$ each expression in $\vli$;
  \item $\vt$ is \texttt{ts};
  \item $\newe$ is \texttt{es}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\ETupleBegin}{\ETupleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule[Empty Tuple Expression]{}
  {
  \annotateexpr{\tenv, \ETuple([])} \typearrow (\TTuple([]), \ETuple([]))
  }
\and
\inferrule{
  \vli = [i=1..k: \texttt{el}_i]\\
  [\annotateexpr{\tenv, \texttt{el}_i} \typearrow (\ve_i, \vt_i)\;|\; i=1..k]\\
  \texttt{ts} = [i=1..k: \vt_i]\\
  \texttt{es} = [i=1..k: \ve_i]
}
{
\annotateexpr{\tenv, \ETuple(\vli)} \typearrow (\TTuple(\texttt{ts}), \ETuple(\texttt{es}))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EUnknown \label{sec:TypingRule.EUnknown}}

  \subsection{Prose}
  The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes an expression \UNKNOWN\  of type $\tty$;
  \item $\ttyp$ is the structure of $\tty$ in $\tenv$;
  \item $\vt$ is $\tty$;
  \item $\newe$ is an expression \UNKNOWN\  of type $\ttyp$.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EUnknownBegin}{\EUnknownEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \tty) \typearrow \tty'
}
{\annotateexpr{\tenv, \EUnknown(\tty)} \typearrow (\tty, \EUnknown(\tty'))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EPattern \label{sec:TypingRule.EPattern}}

\subsection{Prose}
The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ and all of the following apply:
\begin{itemize}
  \item $\ve$ denotes whether the expression $\vep$ matches \texttt{patterns};
  \item $(\tep, \vepp)$ is the result of annotating $\vep$ in $\tenv$;
  \item \texttt{patterns'} is the result of annotating $()\texttt{patterns}, \tep)$ in $\tenv$;
  \item $\vt$ is $\TBool$;
  \item $\newe$ denotes whether the expression $\vepp$ matches \texttt{patterns'}.
\end{itemize}

\subsection{Example}

\CodeSubsection{\EPatternBegin}{\EPatternEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ATC \label{sec:TypingRule.ATC}}

\subsection{Prose}
The result of annotating the expression $\ve$ in $\tenv$ is
$(\vt, \newe)$ or a type error, and all of the following apply:
  \begin{itemize}
  \item $\ve$ denotes an asserting type conversion with expression $\vep$ and type $\tty$, that is $\EATC(\vep, \tty)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vt, \vepp)$ \ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$ \ProseOrTypeError;
  \item annotating the type $\tty$ in $\tenv$ yields $\tty'$ \ProseOrTypeError;
  \item obtaining the \structure\ of $\tty'$ in $\tenv$ yields $\vtystruct$ \ProseOrTypeError;
  \item One of the following applies:
    \begin{itemize}
    \item All of the following apply (\textsc{type\_equal}):
    \begin{itemize}
      \item determining whether $\vtstruct$ is equivalent to $\vtystruct$ in $\tenv$ \\ yields $\True$;
      \item $\vt$ is $\tty'$ and $\newe$ is $\vepp$.
    \end{itemize}
    \item All of the following apply (\textsc{dynamic}):
      \begin{itemize}
        \item determining whether $\vtstruct$ is equivalent to $\vtystruct$ in $\tenv$ \\ yields $\False$,
        meaning that an execution-time check that the expression $\vep$ evaluates to a value in the
        dynamic domain of $\tty$ is required;
        \item both $\vtstruct$ and $\vtystruct$ are bitevector types or integer types.
        \item $\vt$ is $\vtp$ and $\newe$ is the asserting type conversion expression over $\vepp$ \\ and
        $\vtystruct$, that is, $\EATC(\vepp, \vtystruct)$.
     \end{itemize}
   \item All of the following apply:
     \begin{itemize}
      \item determining whether $\vtstruct$ is equivalent to $\vtystruct$ in $\tenv$ \\ yields $\False$;
      \item $\vtstruct$ and $\vtystruct$ are not both bitevector types or integer types.
      \item a type error indicating the conflicting types is returned.
     \end{itemize}
   \end{itemize}
  \end{itemize}

  \subsection{Example}

  \CodeSubsection{\ATCBegin}{\ATCEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[type\_equal]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \annotatetype{\tenv, \tty} \typearrow \tty' \OrTypeError\\
  \tstruct(\tenv, \tty') \typearrow \vtystruct \OrTypeError\\
  \typeequal(\tenv, \vtstruct, \vtystruct) \typearrow \True
}
{
  \annotateexpr{\tenv, \EATC(\vep, \tty)} \typearrow (\tty', \vepp)
}
\end{mathpar}

\begin{mathpar}
\inferrule[dynamic]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \annotatetype{\tenv, \tty} \typearrow \tty' \OrTypeError\\
  \tstruct(\tenv, \tty') \typearrow \vtystruct \OrTypeError\\
  \typeequal(\tenv, \vtstruct, \vtystruct) \typearrow \False\\
  \vb \eqdef \astlabel(\vtstruct) = \astlabel(\vtystruct) \land
  \astlabel(\vtstruct) \in \{\TBits, \TInt \}\\
  \vb = \True
}
{
  \annotateexpr{\tenv, \EATC(\vep, \tty)} \typearrow (\vtp, \EATC(\vepp, \vtystruct))
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp) \OrTypeError\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\
  \annotatetype{\tenv, \tty} \typearrow \tty' \OrTypeError\\
  \tstruct(\tenv, \tty') \typearrow \vtystruct \OrTypeError\\
  \typeequal(\tenv, \vtstruct, \vtystruct) \typearrow \False\\
  \vb \eqdef \astlabel(\vtstruct) = \astlabel(\vtystruct) \land
  \astlabel(\vtstruct) \in \{\TBits, \TInt \}\\
  \vb = \False
}
{
  \annotateexpr{\tenv, \EATC(\vep, \tty)} \typearrow \TypeErrorVal{ATC}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{VBLL}, \identi{KRLL}, \identg{PFRQ}, \identi{XVBG},
  \identr{GYJZ}, \identi{SZVF}, \identr{PZZJ}, \identr{YCPX}, \identi{ZLBW},
  \identi{TCST}, \identi{CGRH}, \identi{YJBB}.

\hypertarget{def-annotateliteral}{}
\section{TypingRule.Lit \label{sec:TypingRule.Lit}}

Annotating literals is done via the helper function
\[
  \annotateliteral{\overname{\literal}{\vl}} \aslto \overname{\ty}{\vt}
\]
which we use in this chapter for TypingRule.ELit as well as in subsequent chapters.
\subsection{Prose}
The result of annotating a literal $\vl$ is $\vt$ and one of the following applies:
\begin{itemize}
\item $\vl$ is an integer literal $\vn$ and $\vt$ is the well-constrained integer type, constraining
its set to the single value $\vn$;
\item $\vl$ is a Boolean literal and $\vt$ is the Boolean type;
\item $\vl$ is a real literal and $\vt$ is the real type;
\item $\vl$ is a string literal and $\vt$ is the string type;
\item $\vl$ is a string literal and $\vt$ is the string type;
\item $\vl$ is a bitvector literal of length $\vn$ and $\vt$ is the bitvector type of fixed width $\vn$.
\end{itemize}

\subsection{Example: TypingRule.Lit.asl}
In the following example, we show several literals and their corresponding types in comments:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.Lit.asl}

\CodeSubsection{\LitBegin}{\LitEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{}{\annotateliteral{\Elit{n}}\typearrow \TInt(\langle[\ConstraintExact(\Elit{n})]\rangle)}
    \and
    \inferrule{}{\annotateliteral{\eliteral{\lbool(\Ignore)}}\typearrow \TBool}
    \and
    \inferrule{}{\annotateliteral{\eliteral{\lreal(\Ignore)}}\typearrow \TReal}
    \and
    \inferrule{}{\annotateliteral{\eliteral{\lstring(\Ignore)}}\typearrow \TString}
    \and
    \inferrule{
      \vl = \eliteral{\lbitvector(\bits)}\\
      n \eqdef |\bits|
    }{
      \annotateliteral{\vl}\typearrow \TBits(\Elit{n}, \emptylist)
    }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.ExpressionList \label{sec:TypingRule.ExpressionList}}
\hypertarget{def-annotateexprs}{}
The function
\[
  \annotateexprlist{\overname{\staticenvs}{\tenv} \aslsep \overname{\expr^*}{\exprs}}
  \aslto \overname{(\ty \times \expr)^*}{\typedexprs}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of expressions in from left to right.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\exprs$ is empty;
    \item $\typedexprs$ is empty.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\exprs$ has $\ve$ as its head expression and $\exprsone$ as its tail;
    \item annotating $\ve$ in $\tenv$ yields the pair $\typedexpr$ consisting of a type and an expression
     \ProseOrTypeError;
    \item annotating the expression list $\exprsone$ in $\tenv$ yields
    $\typedexprs$ \ProseOrTypeError;
    \item $\typedexprs$ is the list with $\typedexpr$ as its head
    and $\typedexprs$ as its tail.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \annotateexprlist{\tenv, \emptylist} \typearrow \emptylist
}
\and
\inferrule[non\_empty]{
  \annotateexpr{\tenv, \ve} \typearrow \typedexpr \OrTypeError\\
  \annotateexprlist{\tenv, \exprsone} \typearrow \typedexprs \OrTypeError\\
  \typedexprs \eqdef [\typedexpr] + \typedexprsone
}
{
  \annotateexprlist{\tenv, [\ve] + \exprsone} \typearrow \typedexprs
}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ReduceSlicesToCall \label{sec:TypingRule.ReduceSlicesToCall}}
\hypertarget{def-reduceslicestocall}{}
The function
\[
  \reduceslicestocall(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve} \aslsep \overname{\slice^*}{\slices})
  \aslto
  \langle (\overname{\identifier}{\name} \times \overname{\expr^*}{\vargs})\rangle
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the expression $\ve$ together with the list of slices $\slices$ constitute
a call to a subprogram in $\tenv$.
If so, it returns a pair consisting of the name of the called subprogram --- $\name$ ---
and the list of actual arguments --- $\vargs$. Otherwise, it returns $\None$.
The result is a type error, if one is detected.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{yes}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is a subprogram name with $\slices$ as its actual arguments
    via $\tododefine{should\_slices\_reduce\_to\_call}$
    yields a list of actual argument expressions $\vargs$ \ProseOrTypeError;
    \item $\name$ is $\vx$;
    \item the result is $\langle (\name, \vle)\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{no}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item determining whether $\vx$ is a subprogram name with $\slices$ as its actual arguments
    via $\tododefine{should\_slices\_reduce\_to\_call}$
    yields $\None$;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_var}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\ReduceSlicesToCallBegin}{\ReduceSlicesToCallEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[yes]{
  \tododefine{should\_slices\_reduce\_to\_call}(\tenv, \vx, \slices) \typearrow \langle \vargs \rangle\\
  \name \eqdef \vx
}
{
  \reduceslicestocall(\tenv, \EVar(\vx), \slices) \typearrow \langle (\name, \vargs)\rangle
}
\and
\inferrule[no]{
  \tododefine{should\_slices\_reduce\_to\_call}(\tenv, \vx, \slices) \typearrow \None
}
{
  \reduceslicestocall(\tenv, \EVar(\vx), \slices) \typearrow \None
}
\and
\inferrule[non\_var]{
  \astlabel(\ve) \neq \EVar
}
{
  \reduceslicestocall(\tenv, \ve, \slices) \typearrow \None
}
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Left-Hand-Side Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a left-hand side expression~\texttt{le} in an environment $\tenv$, assuming \texttt{t\_e}
to be the type of the corresponding right-hand-side (\texttt{annotate\_lexpr env le t\_e}),
results in an annotated expression \texttt{new\_le} and one of the following applies:
\begin{itemize}
\item TypingRule.LEDiscard (see \secref{TypingRule.LEDiscard}),
\item TypingRule.LELocalVar (see \secref{TypingRule.LELocalVar}),
\item TypingRule.LEGlobalVar (see \secref{TypingRule.LEGlobalVar}),
\item TypingRule.LEDestructuring (see \secref{TypingRule.LEDestructuring}),
\item TypingRule.LESlice (see \secref{TypingRule.LESlice}),
\item TypingRule.LESetArray (see \secref{TypingRule.LESetArray}),
\item TypingRule.LESetBadStructuredField (see \secref{TypingRule.LESetBadStructuredField}),
\item TypingRule.LESetStructuredField (see \secref{TypingRule.LESetStructuredField}),
\item TypingRule.LESetBadBitField (see \secref{TypingRule.LESetBadBitField}),
\item TypingRule.LESetBitField (see \secref{TypingRule.LESetBitField}),
\item TypingRule.LESetBitFieldNested (see \secref{TypingRule.LESetBitFieldNested}),
\item TypingRule.LESetBitFieldTyped (see \secref{TypingRule.LESetBitFieldTyped}),
\item TypingRule.LESetBadField (see \secref{TypingRule.LESetBadField}),
\item TypingRule.LEConcat (see \secref{TypingRule.LEConcat}).
\end{itemize}

Some of the rules require viewing left-hand-side expressions as their corresponding right-hand side expressions.
The correspondence is defined in the ASL Syntax Reference~\cite[Chapter 5]{ASLAbstractSyntaxReference}
and given by the function $\torexpr : \lexpr \rightarrow \expr$.

\section{TypingRule.LEDiscard \label{sec:TypingRule.LEDiscard}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes an expression which can be discarded;
   \item \texttt{new\_le} is \texttt{le}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LEDiscardBegin}{\LEDiscardEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \texttt{LE\_Discard}\\
  \newle \eqdef \vle
}
{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LELocalVar \label{sec:TypingRule.LELocalVar}}

   \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes a local variable $\vx$;
   \item $\vx$ is locally declared as a mutable variable of type $\tty$ in $\tenv$;
   \item $\tty$ \typesatisfies\  \texttt{t\_e};
   \item \texttt{new\_le} is \texttt{le}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LELocalVarBegin}{\LELocalVarEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \texttt{LE\_Var}(\id)\\
  L^\tenv.\localstoragetypes(\id) = (\tty, \LDKVar)\\
  \typesat(\tenv, \vte, \tty)\\
  \newle \eqdef \vle
}
{ \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle }
\end{mathpar}

\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WDGQ}, \identr{GNTS}, \identi{MMKF},
  \identi{DGWJ}, \identi{KKCC} and \identr{LXQZ}.

\section{TypingRule.LEGlobalVar \label{sec:TypingRule.LEGlobalVar}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes a global variable $\vx$;
   \item $\vx$ is globally declared as a variable of type $\tty$ in $\tenv$;
   \item \texttt{t\_e} \typesatisfies\  $\tty$;
   \item \texttt{new\_le} is \texttt{le}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LEGlobalVarBegin}{\LEGlobalVarEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \texttt{LE\_Var}(\id)\\
  G^\tenv.\globalstoragetypes(\id) = (\vtp, \Ignore)\\
  \typesat(\tenv, \vtp, \vte)\\
  \newle = \vle
}
{ \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WDGQ}.

\section{TypingRule.LEDestructuring \label{sec:TypingRule.LEDestructuring}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes a tuple \texttt{les};
   \item \texttt{t\_e} has the structure of a tuple type \texttt{sub\_tys};
   \item the elements of \texttt{sub\_tys} \typesatisfies\  the type of the elements of \texttt{les};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{les} and \texttt{sub\_tys} have the same length;
       \item \texttt{new\_le} is the result of annotating \texttt{les} with \texttt{sub\_tys} in $\tenv$
       \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{les} and \texttt{sub\_tys} do not have the same length;
       \item an error ``\texttt{Bad Arity LEDestructuring}'' is raised.
       \end{itemize}
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LEDestructuringBegin}{\LEDestructuringEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \texttt{LE\_Destructuring}(\les)\\
  \vte = \TTuple(\subtys)\\
  \les = [\ve_{1..k}]\\
  \subtys = [\vt_{1..k}]\\
  i=1..k: \annotateexpr{\tenv, \ve_i,\vt_i} \typearrow \vep_i\\
  \les' = [i=1..k: \vep_i]\\
  \newle = \texttt{LE\_Destructuring}(\les')
}
{ \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESlice \label{sec:TypingRule.LESlice}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the slicing of a left-hand-side expression \texttt{le1} by the slices $\slices$;
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in $\tenv$;
   \item \texttt{t\_le1} has the structure of a bitvector type;
   \item \texttt{le2} is the result of annotating \texttt{le1} in $\tenv$;
   \item \texttt{width} is the width of the slices $\slices$ in $\tenv$;
   \item $\vt$ is the bitvector type of width \texttt{width};
   \item \texttt{te} \typesatisfies\  $\vt$;
   \item \texttt{slices2} is the result of annotating $\slices$ in $\tenv$;
   \item \texttt{new\_le} is the slicing of \texttt{le2} by \texttt{slices2}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESliceBegin}{\LESliceEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \leslice(\vleone, \slices)\\
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore)\\
  \astlabel(\tstruct(\tenv, \vtleone)) \typearrow \TBits\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow \vletwo\\
  \sliceswidth(\tenv, \slices) \typearrow \vwidth\\
  \vt = \TBits(\texttt{BitWidth\_SingleExpr}(\vwidth, \emptylist))\\
  \typesat(\tenv, \vt, \vte)\\
  \texttt{slices2} = [\annotateslices(\tenv, \vs) \;|\; \vs \in \slices]\\
  \newle = \leslice(\vletwo, \texttt{slices2})
}
{ \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetArray \label{sec:TypingRule.LESetArray}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the slicing of a left-hand-side expression \texttt{le1} by the slices $\slices$;
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in $\tenv$;
   \item \texttt{t\_le1} has the structure of an array type of size $\size$ and item type $\vt$;
   \item \texttt{te} \typesatisfies\  $\vt$;
   \item \texttt{le2} is the result of annotating \texttt{le1} in $\tenv$;
  % ROMAN: The following is not what the code does so I replaced it with subsequent item.
  %  \item One of the following applies:
  %    \begin{itemize}
  %    \item $\wantedtindex$ is an enumeration type of name $\size$;
  %    \item $\wantedtindex$ is the type \texttt{integer {0..size-1}};
  %    \end{itemize}
  \item the expression $\size$ can be annotated with the type $\wantedtindex$;
  \item $\slices$ is a single expression $\eindex$;
   \item $(\tindexp, \eindexp)$ is the result of annotating $\eindex$ in $\tenv$;
   \item $\wantedtindex$ \typesatisfies\  $\tindexp$, which guarantees that the index
   is within the bounds of the array;
   \item \texttt{new\_le} is an access to array \texttt{le2} at index $\eindexp$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetArrayBegin}{\LESetArrayEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \leslice(\vleone, \slices)\\
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore)\\
  \tstruct(\tenv, \vtleone) \typearrow \TArray(\size, \vt)\\
  \typesat(\tenv, \vte, \vt)\\
  \annotatelexpr{\tenv, \vleone} \typearrow \vletwo\\
  \annotatearrayindex(\tenv, \size) \typearrow \wantedtindex\\
  \slices = [\SliceSingle(\eindex)]\\
  \annotateexpr{\tenv, \eindex} \typearrow (\tindex', \eindex')\\
  \typesat(\tenv, \tindex', \wantedtindex)\\
  \newle = \texttt{LS\_SetArray}(\vletwo, \eindex')
}
{\annotatelexpr{\tenv, \vle, \vte} \typearrow \newle}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadStructuredField \label{sec:TypingRule.LESetBadStructuredField}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in $\tenv$;
   \item \texttt{le2} is the result of annotating \texttt{le1} in $\tenv$;
   \item \texttt{t\_le1} has the structure of an exception or a record type with fields $\fields$;
   \item \texttt{field} is not declared in $\fields$;
   \item an error ``\texttt{Bad Field}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBadStructuredFieldBegin}{\LESetBadStructuredFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetStructuredField \label{sec:TypingRule.LESetStructuredField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in $\tenv$;
   \item \texttt{le2} is the result of annotating \texttt{le1} in $\tenv$;
   \item \texttt{t\_le1} has the structure of an exception or a record type with fields $\fields$;
   \item \texttt{field} is bound to type $\vt$ in $\fields$;
   \item $\vt$ \typesatisfies\  \texttt{t\_e};
   \item \texttt{new\_le} is the access to the field \texttt{field} in \texttt{le2}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetStructuredFieldBegin}{\LESetStructuredFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \texttt{LE\_SetField}(\vleone, \vfield)\\
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore)\\
  \annotatelexpr{\tenv, \vleone} \typearrow \vletwo\\
  L \in \{\TRecord, \TException\}\\
  \tstruct(\tenv, \vtleone) \typearrow L(\{\vfield:t, \ldots\})\\
  \typesat(\tenv, \vte, \vt)\\
  \newle = \texttt{LE\_SetField}(\vletwo, \vfield)
}
{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadBitField \label{sec:TypingRule.LESetBadBitField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in $\tenv$;
   \item \texttt{le2} is the result of annotating \texttt{le1} in $\tenv$;
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields $\bitfields$;
   \item \texttt{field} is not declared in $\bitfields$;
   \item an error ``\texttt{Bad Field}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBadBitFieldBegin}{\LESetBadBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitField \label{sec:TypingRule.LESetBitField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in $\tenv$;
   \item \texttt{le2} is the result of annotating \texttt{le1} in $\tenv$;
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields $\bitfields$;
   \item \texttt{field} is declared in $\bitfields$;
   \item $\slices$ gives the slices corresponding to the bitfield \texttt{field} in
      $\bitfields$;
   \item $\vw$ is the width of $\slices$;
   \item $\vt$ is the bitvector type of width $\vw$;
   \item $\vt$ \typesatisfies\  \texttt{t\_e};
   \item \texttt{le2} is the slicing of \texttt{le1} by $\slices$;
   \item \texttt{new\_le} is the result of annotating \texttt{le2} in $\tenv$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBitFieldBegin}{\LESetBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vle \typearrow \texttt{LE\_SetField}(\vleone, \vfield)\\
    \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore)\\
    \annotatelexpr{\tenv, \vleone} \typearrow \vletwo\\
    \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields)\\
    \texttt{BitField\_Simpled}(\vfield, \vslices) \in \bitfields\\
    \sliceswidth(\tenv, \vslices) \typearrow \vw\\
    \vt = \TBits(\texttt{BitWidth\_SingleExpr(\vw), \bitfields})\\
    \typesat(\tenv, \vte, \vt)\\
    \vletwo = \texttt{LE\_Slice}(\vleone, \vslices)\\
    \annotatelexpr{\vletwo, \vslices} \typearrow \newle
  }
  {
    \annotatelexpr{\tenv, \vle, \vte} = \newle
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldNested \label{sec:TypingRule.LESetBitFieldNested}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in $\tenv$;
   \item \texttt{le2} is the result of annotating \texttt{le1} in $\tenv$;
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields $\bitfields$;
   \item $\slices$ gives the slices corresponding to the bitfield \texttt{field} in
      $\bitfields$;
   \item $\vw$ is the width of $\slices$;
   \item $\bitfieldsp$ gives the bitfields corresponding to \texttt{field} in $\bitfields$;
   \item $\vt$ is the bitvector type of width $\vw$ and bitfields $\bitfieldsp$;
   \item $\vt$ \typesatisfies\  \texttt{t\_e};
   \item \texttt{le2} is the slicing of \texttt{le1} by $\slices$;
   \item \texttt{new\_le} is the result of annotating \texttt{le2} in $\tenv$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBitFieldNestedBegin}{\LESetBitFieldNestedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vle = \texttt{LE\_SetField}(\vleone, \vfield)\\
    \annotateexpr{\tenv, \torexpr(\vleone)} = (\vtleone, \Ignore)\\
    \annotatelexpr{\tenv, \vleone} = \vletwo\\
    \tstruct(\tenv, \vtleone) = \TBits(\Ignore, \bitfields)\\
    \texttt{BitField\_Nested}(\vfield, \vslices, \bitfields') \in \bitfields\\
    \sliceswidth(\tenv, \vslices) = \vw\\
    \vt = \TBits(\texttt{BitWidth\_SingleExpr(w), \bitfields'})\\
    \typesat(\tenv, \vte, \vt)\\
    \vletwo = \texttt{LE\_Slice}(\vleone, \vslices)\\
    \annotatelexpr{\vletwo, \vslices} \typearrow \newle
  }
  {
    \annotatelexpr{\tenv, \vle, \vte} = \newle
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldTyped \label{sec:TypingRule.LESetBitFieldTyped}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in $\tenv$;
   \item \texttt{le2} is the result of annotating \texttt{le1} in $\tenv$;
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields $\bitfields$;
   \item $\slices$ gives the slices corresponding to the bitfield \texttt{field} in
      $\bitfields$;
   \item $\vw$ is the width of $\slices$;
   \item \texttt{t'} is the bitvector type of width $\vw$;
   \item $\vt$ gives the type corresponding to the bitfield \texttt{field} in
      $\bitfields$;
   \item $\vt$ \typesatisfies\  \texttt{t'};
   \item $\vt$ \typesatisfies\  \texttt{t\_e};
   \item \texttt{le2} is the slicing of \texttt{le1} by $\slices$;
   \item \texttt{new\_le} is the result of annotating \texttt{le2} in $\tenv$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBitFieldTypedBegin}{\LESetBitFieldTypedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vle = \texttt{LE\_SetField}(\vleone, \vfield)\\
    \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore)\\
    \annotatelexpr{\tenv, \vleone} \typearrow \vletwo\\
    \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields)\\
    \texttt{BitField\_Type}(\vfield, \vslices, \vt) \in \bitfields\\
    \sliceswidth(\tenv, \vslices) \typearrow \vw\\
    \vtp = \TBits(\texttt{BitWidth\_SingleExpr(w), \emptylist})\\
    \typesat(\tenv, \vtp, \vt)\\
    \typesat(\tenv, \vte, \vt)\\
    \vletwo = \texttt{LE\_Slice}(\vleone, \vslices)\\
    \annotatelexpr{\vletwo, \vslices} \typearrow \newle
  }
  {
    \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadField \label{sec:TypingRule.LESetBadField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in $\tenv$;
   \item \texttt{le2} is the result of annotating \texttt{le1} in $\tenv$;
   \item \texttt{t\_le1} does not have the structure of a record, or an exception or a bitvector type;
   \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBadFieldBegin}{\LESetBadFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LEConcat \label{sec:TypingRule.LEConcat}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment $\tenv$, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:

  \subsection{Example}


    \CodeSubsection{\LEConcatBegin}{\LEConcatEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Slices \label{chap:typingslices}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a slice~\texttt{slice} in an environment $\tenv$
(\texttt{annotate\_slice env slice}) results in the slicing of the pair \texttt{(offset,length)} and one of the following applies:
\begin{itemize}
\item TypingRule.SliceSingle (see \secref{TypingRule.SliceSingle}),
\item TypingRule.SliceLength (see \secref{TypingRule.SliceLength}),
\item TypingRule.SliceRange (see \secref{TypingRule.SliceRange}),
\item TypingRule.SliceStar (see \secref{TypingRule.SliceStar}).
\end{itemize}

\section{TypingRule.SliceSingle \label{sec:TypingRule.SliceSingle}}

  \subsection{Prose}
   Annotating a slice~\texttt{slice} in an environment $\tenv$
(\texttt{annotate\_slice env slice}) results in the pair \texttt{(offset, length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slice} gives an index \texttt{i};
   \item \texttt{(offset, length)} is the result of applying TypingRule.SliceLength to \texttt{i, i+:1}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SliceSingleBegin}{\SliceSingleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    \identr{GXKG}: The notation \texttt{b[i]} is syntactic sugar for \texttt{b[i +: 1]}.

\section{TypingRule.SliceLength \label{sec:TypingRule.SliceLength}}

  \subsection{Prose}
   Annotating a slice~\texttt{slice} in an environment $\tenv$
(\texttt{annotate\_slice env slice}) results in the pair \texttt{(offset,length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slice} gives \texttt{offset} and \texttt{length};
   \item \texttt{t\_offset, offset'} is the result of annotating \texttt{offset} in $\tenv$;
   \item \texttt{t\_length, length'} is the result of annotating \texttt{length} in $\tenv$;
   \item \texttt{t\_offset} has the structure of an integer type;
   \item \texttt{t\_length} has the structure of an integer type;
   \item \texttt{length} is statically evaluable.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SliceLengthBegin}{\SliceLengthEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\newcommand\eoffset[0]{\texttt{offset}}
\newcommand\elength[0]{\texttt{length}}
\newcommand\toffset[0]{\texttt{t\_offset}}
\newcommand\tlength[0]{\texttt{t\_length}}
\begin{mathpar}
\inferrule{
\annotateexpr{\tenv, \eoffset} \typearrow (\toffset, \eoffset')\\
\annotateexpr{\tenv, \elength} \typearrow (\tlength, \elength')\\
\tstruct(\tenv, \toffset) \typearrow \TInt(\Ignore)\\
\tstruct(\tenv, \tlength) \typearrow \TInt(\Ignore)\\
\isstaticallyevaluable(\tenv, \elength)
}
{
\annotateslices(\tenv, \texttt{Slice\_Length}(\eoffset, \elength)) \typearrow \texttt{Slice\_Length}(\eoffset, \elength')
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SliceRange \label{sec:TypingRule.SliceRange}}

  \subsection{Prose}
      Annotating a slice~\texttt{slice} in an environment $\tenv$
(\texttt{annotate\_slice env slice}) results in the pair \texttt{(offset,
length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slice} gives a range \texttt{(j, i)};
   \item \texttt{pre\_length} is \texttt{i +: j-i+1};
   \item \texttt{offset, length} is the result of applying the rule TypingRule.SliceLength to \texttt{i,pre\_length}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SliceRangeBegin}{\SliceRangeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    \identr{GXKG}: The notation \texttt{b[j:i]} is syntactic sugar for \texttt{b[i +: j-i+1]}.

\section{TypingRule.SliceStar \label{sec:TypingRule.SliceStar}}

  \subsection{Prose}
      Annotating a slice~\texttt{slice} in an environment $\tenv$
(\texttt{annotate\_slice env slice}) results in the pair \texttt{(offset,
length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slice} gives \texttt{(factor, pre\_length)};
   \item \texttt{pre\_offset} is \texttt{factor * pre\_length};
   \item \texttt{offset, length} is the result of applying the rule TypingRule.SliceLength to \texttt{(pre\_offset, pre\_length)}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SliceStarBegin}{\SliceStarEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    \identr{GXQG}: The notation \texttt{b[i *: n]} is syntactic sugar for \texttt{b[i*n +: n]}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Patterns}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and one of the following applies:
\begin{itemize}
\item TypingRule.PAll (see \secref{TypingRule.PAll}),
\item TypingRule.PAny (see \secref{TypingRule.PAny}),
\item TypingRule.PGeq (see \secref{TypingRule.PGeq}),
\item TypingRule.PLeq (see \secref{TypingRule.PLeq}),
\item TypingRule.PNot (see \secref{TypingRule.PNot}),
\item TypingRule.PRange (see \secref{TypingRule.PRange}),
\item TypingRule.PSingle (see \secref{TypingRule.PSingle}),
\item TypingRule.PMask (see \secref{TypingRule.PMask}),
\item TypingRule.PTupleBadArity (see \secref{TypingRule.PTupleBadArity}),
\item TypingRule.PTuple (see \secref{TypingRule.PTuple}),
\item TypingRule.PTupleConflict (see \secref{TypingRule.PTupleConflict}),
\end{itemize}

\section{TypingRule.PAll \label{sec:TypingRule.PAll}}

  \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern matching everything;
   \item \texttt{new\_p} is \texttt{p}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PAllBegin}{\PAllEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PAny\label{sec:TypingRule.PAny}}

  \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything in a list $\vli$;
   \item \texttt{new\_li} is the result of mapping the result of annotating \texttt{p} in $\tenv$ onto $\vli$;
   \item \texttt{new\_p} is the pattern which matches anything in \texttt{new\_li}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PAnyBegin}{\PAnyEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PGeq \label{sec:TypingRule.PGeq}}

  \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything greater than or equal to an expression $\ve$;
   \item \texttt{t\_e, \vep} is the result of annotating $\ve$ in $\tenv$;
   \item $\vep$ is a compile-time constant expression;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both $\vt$ and \texttt{t\_e} have the structure of an integer;
           \item \texttt{new\_p} is the pattern which matches anything greater than or equal to $\vep$.
           \end{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both $\vt$ and \texttt{t\_e} have the structure of a real;
           \item \texttt{new\_p} is the pattern which matches anything greater than or equal to $\vep$.
           \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PGeqBegin}{\PGeqEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

 \section{TypingRule.PLeq \label{sec:TypingRule.PLeq}}

  \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything lesser than or equal to an expression $\ve$;
   \item \texttt{t\_e, \vep} is the result of annotating $\ve$ in $\tenv$;
   \item $\vep$ is a compile-time constant expression;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both $\vt$ and \texttt{t\_e} have the structure of an integer;
           \item \texttt{new\_p} is the pattern which matches anything lesser than or equal to $\vep$.
           \end{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both $\vt$ and \texttt{t\_e} have the structure of a real;
           \item \texttt{new\_p} is the pattern which matches anything lesser than or equal to $\vep$.
           \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PLeqBegin}{\PLeqEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PNot \label{sec:TypingRule.PNot}}

  \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches the negation of a pattern \texttt{q};
   \item \texttt{new\_q} is the result of annotating \texttt{q} in $\tenv$;
   \item \texttt{new\_p} is pattern which matches the negation of \texttt{new\_q}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PNotBegin}{\PNotEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PRange \label{sec:TypingRule.PRange}}

    \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything within the range given by
      expressions $\veone$ and \vetwo;
   \item \texttt{t\_e1, e1'} is the result of annotating $\veone$ in $\tenv$;
   \item \texttt{t\_e2, e2'} is the result of annotating \vetwo in $\tenv$;
   \item e1' and e2' are compile-time constant expressions;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t\_e1} and \texttt{t\_e2} have the structure of an integer;
           \item \texttt{new\_p} is the pattern which matches anything within the range given by
      expressions $\veonep$ and $\vetwop$.
           \end{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t\_e1} and \texttt{t\_e2} have the structure of a real;
           \item \texttt{new\_p} is the pattern which matches anything within the range given by
      expressions $\veonep$ and $\vetwop$.
           \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PRangeBegin}{\PRangeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PSingle \label{sec:TypingRule.PSingle}}

    \subsection{Prose}
      Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
      \begin{itemize}
        \item \texttt{p} is the pattern that matches the expression $\ve$;
        \item \texttt{t\_e, \vep} is the result of annotating the expression $\ve$ in $\tenv$;
        \item One of the following applies:
          \begin{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of the real type;
                \item $\vt$ has the structure of the real type;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of the boolean type;
                \item $\vt$ has the structure of the boolean type;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of an integer type;
                \item $\vt$ has the structure of an integer type;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of a bitvector type;
                \item $\vt$ has the structure of a bitvector type;
                \item the bitvector types \texttt{t\_e} and $\vt$ have the same length;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of an enumeration type;
                \item $\vt$ has the structure of an enumeration type;
                \item the enumeration types \texttt{t\_e} and $\vt$ have the same literals;
              \end{itemize}
          \end{itemize}
        \item \texttt{new\_p} is \texttt{p};
      \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PSingleBegin}{\PSingleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PMask \label{sec:TypingRule.PMask}}

  \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a mask \texttt{m};
   \item $\vt$ has the structure of a bitvector type;
   \item $\vn$ is the length of mask \texttt{m};
   \item \texttt{t\_m} is the bitvector type of width $\vn$;
   \item One of the following applies:
     \item All of the following apply:
       \begin{itemize}
       \item $\vt$ \typesatisfies\  \texttt{t\_m};
       \item \texttt{new\_p} is \texttt{p}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PMaskBegin}{\PMaskEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This is related to \identi{VMKF}.

\section{TypingRule.PTupleBadArity \label{sec:TypingRule.PTupleBadArity}}

  \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a tuple $\vli$;
   \item $\vt$ has the type structure of a tuple type \texttt{ts};
   \item \texttt{ts} is a list of different size to the size of $\vli$;
   \item an error ``\texttt{Bad Arity}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PTupleBadArityBegin}{\PTupleBadArityEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.PTuple \label{sec:TypingRule.PTuple}}

  \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a tuple $\vli$;
   \item $\vt$ has the type structure of a tuple type \texttt{ts};
   \item \texttt{ts} is a list of the same size as $\vli$;
   \item \texttt{new\_li} is the result of annotating $\vli$ with \texttt{ts};
   \item \texttt{new\_p} is the pattern which matches the tuple \texttt{new\_li}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PTupleBegin}{\PTupleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.PTupleConflict \label{sec:TypingRule.PTupleConflict}}

  \subsection{Prose}
   Annotating a pattern $\vt$ in an environment $\tenv$ given a type $\vt$ (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a tuple $\vli$;
   \item $\vt$ has the type structure of a tuple type \texttt{ts};
   \item \texttt{t\_struct} is not a tuple type;
   \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PTupleConflictBegin}{\PTupleConflictEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Local Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a local declaration~\texttt{ldi} with a local declaration keyword \texttt{ldk}, given a type $\tty$, in an
environment $\tenv$ (\annotatelocaldeclitem{\ldk, \ldi, \tty}) results in \texttt{new\_env, new\_ldi} and one of the following applies:
\begin{itemize}
\item TypingRule.LDDiscard (see \secref{TypingRule.LDDiscard}),
\item TypingRule.LDVar (see \secref{TypingRule.LDVar}),
\item TypingRule.LDTyped (see \secref{TypingRule.LDTyped}),
\item TypingRule.LDTuple (see \secref{TypingRule.LDTuple}).
\end{itemize}

This is related to \identr{YSPM}.

\section{TypingRule.LDDiscard \label{sec:TypingRule.LDDiscard}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi} with a local declaration keyword \texttt{ldk}, given a type $\tty$, in
an environment $\tenv$ results in \texttt{new\_env, new\_ldi} and all of
the following apply:
   \begin{itemize}
   \item \texttt{ldi} is a local declaration which can be discarded;
   \item $\newenv$ is $\tenv$;
   \item \texttt{new\_ldi} is \texttt{ldi}.
   \end{itemize}

  \subsection{Example}
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDDiscard.asl}


    \CodeSubsection{\LDDiscardBegin}{\LDDiscardEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \ldi = \texttt{LDI\_Discard}(\None)\\
  }
  {\annotatelocaldeclitem{\tenv, \ldi, \ldk, \tty} \typearrow (\tenv, \ldi)}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LDVar \label{sec:TypingRule.LDVar}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi} with a local declaration keyword \texttt{ldk}, given a type $\tty$, in
an environment $\tenv$ results in \texttt{new\_env, new\_ldi} and all of
the following apply:
   \begin{itemize}
   \item \texttt{ldi} denotes a variable $\vx$;
   \item $\vx$ is not declared in $\tenv$;
   \item $\newenv$ is $\tenv$ modified so that $\vx$ is locally declared of type $\tty$;
   \item \texttt{new\_ldi} is the declaration of variable $\vx$ with type $\tty$.
   \end{itemize}

  \subsection{Example}
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDVar.asl}


    \CodeSubsection{\LDVarBegin}{\LDVarEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \ldi = \texttt{LDI\_Var}(\vx)\\
    L^\tenv.\localstoragetypes(\vx) = \bot\\
    \newtenv = (G^\tenv, L^\tenv.\localstoragetypes[\vx \mapsto (\tty, \ldk)])
  }
  {
    \annotatelocaldeclitem{\tenv, \ldi, \ldk, \tty} \typearrow (\newtenv, \texttt{LDI\_Var}(\vx))
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
This is related to \identr{YSPM}, \identd{FXST}.

\section{TypingRule.LDTyped\label{sec:TypingRule.LDTyped}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi} with a local declaration
    keyword \texttt{ldk}, given a type $\tty$, in an
    environment $\tenv$ results in \texttt{new\_env, new\_ldi} and all of
    the following apply:
    \begin{itemize}
      \item \texttt{ldi} denotes a local declaration item \texttt{ldi'} and a type $\vt$;
      \item $\vt$ can be initialized with $\tty$ in $\tenv$;
      \item $\newenv$, \texttt{new\_ldi'} is the result of the annotation of
        \texttt{ldi'} with the local declaration keyword \texttt{ldk}, given
        the type $\vt$, in the environment $\tenv$;
      \item \texttt{new\_ldi} is the local declaration denoting \texttt{new\_ldi'} and the type $\vt$.
    \end{itemize}

    \subsection{Example}
      \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDTyped.asl}


      \CodeSubsection{\LDTypedBegin}{\LDTypedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \ldi = \texttt{LDI\_Typed}(\ldi', \vt)\\
  \canbeinitializedwith(\tenv, \vt, \tty)\\
  \annotatelocaldeclitem{\tenv, \ldi', \ldk, \vt} \typearrow (\newtenv, \newldi')\\
  \newldi = \texttt{LDI\_Typed}(\newldi', \vt)\\
}
{
  \annotatelocaldeclitem{\tenv, \ldi, \ldk, \tty} \typearrow (\newtenv, \newldi)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LDTuple\label{sec:TypingRule.LDTuple}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi} with a local declaration keyword \texttt{ldk}, given a type $\tty$, in
an environment $\tenv$ results in \texttt{new\_env, new\_ldi} and all of
the following apply:
  \begin{itemize}
  \item \texttt{ldi} denotes a list \texttt{ldis};
  \item $\tty$ has the structure of a tuple type of the same length as~\texttt{ldis};
  \item $\newenv$ is $\tenv$ modified so that each element in \texttt{ldis} is annotated with the corresponding type in $\tty$;
  \item \texttt{new\_ldi} is \texttt{ldis} where each element is declared with
the corresponding type in  $\tty$.
  \end{itemize}

  \subsection{Example}
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDTuple.asl}


    \CodeSubsection{\LDTupleBegin}{\LDTupleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \ldi = \texttt{LDI\_Tuple}(\ldis, \None)\\
  \ldis = [\ldi_{1..k}]\\
  \tstruct(\tenv, \tty) \typearrow \TTuple([\vt_{1..k}])\\
  \newtenv_0 = \tenv\\
  \annotatelocaldeclitem{\newtenv_0, \ldi_1, \ldk, \vt_1} \typearrow (\newtenv_1, \ldi_1)\\
  \ldots\\
  \annotatelocaldeclitem{\newtenv_{k-1}, \ldi_{k-1}, \ldk, \vt_{k-1}} \typearrow (\newtenv_k, \ldi_k)\\
  \newtenv = \newtenv_k\\
  \newldi = [\ldi_{1..k}]
}
{
  \annotatelocaldeclitem{\tenv, \ldi, \ldk, \tty} \typearrow (\newtenv, \texttt{LDI\_Tuple}(\newldi, \None))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Statements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and one of the following applies:
\begin{itemize}
\item TypingRule.SPass (see \secref{TypingRule.SPass}),
\item TypingRule.SAssign (see \secref{TypingRule.SAssign}),
\item TypingRule.SReturnNone (see \secref{TypingRule.SReturnNone}),
\item TypingRule.SReturnOne (see \secref{TypingRule.SReturnOne}),
\item TypingRule.SReturnSome (see \secref{TypingRule.SReturnSome}),
\item TypingRule.SSeq (see \secref{TypingRule.SSeq}),
\item TypingRule.SCall (see \secref{TypingRule.SCall}),
\item TypingRule.SCond (see \secref{TypingRule.SCond}),
\item TypingRule.SCase (see \secref{TypingRule.SCase}),
\item TypingRule.SAssert (see \secref{TypingRule.SAssert}),
\item TypingRule.SWhile (see \secref{TypingRule.SWhile}),
\item TypingRule.SRepeat (see \secref{TypingRule.SRepeat}),
\item TypingRule.SFor (see \secref{TypingRule.SFor}),
\item TypingRule.SThrowNone (see \secref{TypingRule.SThrowNone}),
\item TypingRule.SThrowSome (see \secref{TypingRule.SThrowSome}),
\item TypingRule.STry (see \secref{TypingRule.STry}).
\item TypingRule.SDeclSome (see \secref{TypingRule.SDeclSome}),
\item TypingRule.SDeclNone (see \secref{TypingRule.SDeclNone}),
\end{itemize}

\section{TypingRule.SPass \label{sec:TypingRule.SPass}}

    \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
    \begin{itemize}
    \item $\vs$ is a pass statement;
    \item $\news$ is $\vs$;
    \item $\newenv$ is $\tenv$.
    \end{itemize}

    \subsection{Example}


    \CodeSubsection{\SPassBegin}{\SPassEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{}{\annotatestmt{\tenv, \SPass} \typearrow (\SPass,\tenv)}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SAssign \label{sec:TypingRule.SAssign}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is an assignment \texttt{le = re} under language version \texttt{ver};
   \item \texttt{t\_e, e1} is the result of annotating \texttt{re} in $\tenv$;
   \item \texttt{reduced} is the result of inlining a setter call in \texttt{le};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{reduced} gives a statement $\vs$;
       \item $\news$ is $\vs$;
       \item $\newenv$ is $\tenv$.
       \end{itemize}

     \item All of the following apply:
       \begin{itemize}
       \item \texttt{reduced} does not give a statement $\vs$;
       \item One of the following applies:
         \begin{itemize}
         \item All of the following apply:
           \begin{itemize}
           \item \texttt{ver} is ASLv1;
           \item \texttt{env1} is $\tenv$;
           \end{itemize}
         \item All of the following apply:
           \begin{itemize}
           \item \texttt{ver} is ASLv0;
	   \item \texttt{env1} is the result of annotating undeclared variables by using
	      the first assignments to such variables as declarations;
           \end{itemize}
         \end{itemize}

       \item \texttt{le1} is the result of annotating \texttt{le} with \texttt{t\_e} in \texttt{env1};
       \item $\news$ is the assignment \texttt{le1 = e1};
       \item $\newenv$ is \texttt{env1}.
       \end{itemize}
    \end{itemize}
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\SAssignBegin}{\SAssignEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Assign}(\vle, \vre)\\
    \annotateexpr{\tenv, \vre} = (\vte, \veone)\\
    \inlinesetter{\tenv, \vle, \veone} = \reduced = \langle \vs \rangle\\
    \news = \vs\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news,\newtenv)
  }
\and
\inferrule{
  \vs = \texttt{S\_Assign}(\vle, \vre)\\
  \annotateexpr{\tenv, \vre} \typearrow (\vte, \veone)\\
  \inlinesetter{\tenv, \vle, \veone} = \reduced = \langle \rangle\\
  \version = \texttt{ASLv1}\\
  \tenvone = \tenv\\
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \vleone\\
  \news = \texttt{S\_Assign}(\vleone, \veone)
  \newtenv = \tenvone
}
{
  \annotatestmt{\tenv, \vs} \typearrow (\news,\newtenv)
}
\and
\inferrule{
  \vs = \texttt{S\_Assign}(\vle, \vre)\\
  \annotateexpr{\tenv, \vre} \typearrow (\vte, \veone)\\
  \inlinesetter{\tenv, \vle, \veone} = \reduced = \langle \rangle\\
  \version = \texttt{ASLv0}\\
  \tenvone = \tenv'\\
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \vleone\\
  \news = \texttt{S\_Assign}(\vleone, \veone)
  \newtenv = \tenvone
}
{
  \annotatestmt{\tenv, \vs} \typearrow (\news,\newtenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SReturnNone \label{sec:TypingRule.SReturnNone}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a \texttt{return} statement with no value and no return type;
   \item $\news$ is a \texttt{return} statement with no value;
   \item the enclosing subprogram does not have a \texttt{return} type (it is either a setter
      or a procedure);
   \item $\newenv$ is $\tenv$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SReturnNoneBegin}{\SReturnNoneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vs = \texttt{S\_Return}(\None)\\
  L^\tenv.\returntype = \None\\
  \newtenv = \tenv
}
{\annotatestmt{\tenv, \vs} \typearrow (\texttt{S\_Return}(\None), \newtenv)}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{FTPK}.


\section{TypingRule.SReturnOne \label{sec:TypingRule.SReturnOne}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item $\vs$ is a \texttt{return} statement with some value;
       \item the enclosing subprogram does not have a return type;
       \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item $\vs$ is a \texttt{return} statement with no value;
       \item the enclosing subprogram has a \texttt{return} type;
       \end{itemize}
     \end{itemize}
   \item an error ``\texttt{Bad Return Statement}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SReturnOneBegin}{\SReturnOneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{FTPK}.

\section{TypingRule.SReturnSome \label{sec:TypingRule.SReturnSome}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a \texttt{return} statement with some value $\ve$;
   \item the enclosing subprogram has a return type $\vt$;
   \item $(\tep,\vep)$ is the result of annotating $\ve$ in $\tenv$;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item $\tep$ \typesatisfies\  $\vt$;
       \item $\news$ is a \texttt{return} statement with value $\vep$;
       \item $\newenv$ is $\tenv$.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SReturnSomeBegin}{\SReturnSomeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Return}(\langle \ve \rangle)\\
    L^\tenv.\returntype = \langle \vt \rangle\\
    \annotateexpr{\tenv, \ve} \typearrow (\vte', \vep)\\
    \typesat(\tenv, \vte', \vt)\\
    \news = \texttt{S\_Return}(\langle \vep \rangle)\\
    \newtenv = \tenv
  }
  {\annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identr{FTPK}.

\section{TypingRule.SSeq \label{sec:TypingRule.SSeq}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a statement \texttt{s1; s2};
   \item \texttt{new\_s1, env1} is the result of annotating \texttt{s1} in $\tenv$;
   \item \texttt{new\_s2, env2} is the result of annotating \texttt{s2} in \texttt{env1};
   \item $\news$ is a then statement over two statements \texttt{new\_s1} and \texttt{new\_s2};
   \item $\newenv$ is \texttt{env2}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SSeqBegin}{\SSeqEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vs = \SSeq(\vsone, \vstwo)\\
  \annotatestmt{\tenv, \vs1} \typearrow (\newsone, \tenvone)\\
  \annotatestmt{\tenvone, \vs2} \typearrow (\newstwo, \tenvtwo)\\
  \news = \SSeq(\newsone, \newstwo)\\
  \newtenv = \tenvtwo
}
{
  \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SCall \label{sec:TypingRule.SCall}}

    \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a call to a subprogram named $\name$ with arguments $\vargs$ and parameters $\eqs$;
   \item \texttt{new\_name, new\_args, new\_eqs} is the result of annotating the call
      to the procedure $\name$ with arguments $\vargs$ and parameters
$\eqs$;
   \item $\news$ is the call to a subprogram named \texttt{new\_name} with arguments
      \texttt{new\_args} and parameters \texttt{new\_eqs};
   \item $\newenv$ is $\tenv$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SCallBegin}{\SCallEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Call}(\name, \vargs, \eqs)\\
    \annotatecall{\tenv, \name, \vargs, \eqs} \typearrow (\newname, \newargs, \neweqs)\\
    \news = \texttt{S\_Call}(\newname, \newargs, \neweqs)
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \tenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identd{VXKM}.

\section{TypingRule.SCond \label{sec:TypingRule.SCond}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a condition $\ve$ with two statements \texttt{s1} and \texttt{s2};
   \item $(\tcond, e\_cond)$ is the result of annotating $\ve$ in $\tenv$;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item $\texttt{\tcond}$ \typesatisfies\  $\texttt{t\_bool}$;
       \item $\texttt{s1'}$ is the result of annotating \texttt{s1} in $\tenv$;
       \item $\texttt{s2'}$ is the result of annotating \texttt{s2} in $\tenv$;
       \item $\news$ is the condition $\econd$ with two statements $\texttt{s1'}$ and $\texttt{s2'}$;
       \item $\newenv$ is $\tenv$.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SCondBegin}{\SCondEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Cond}(\ve, \vsone, \vstwo)\\
    \annotateexpr{\tenv, \ve} \typearrow (\tcond, \econd)\\
    \typesat(\tenv, \tcond, \TBool)\\
    \annotatestmt{\tenv, \vsone} \typearrow (\vsone', \Ignore)\\
    \annotatestmt{\tenv, \vstwo} \typearrow (\vstwo', \Ignore)\\
    \news = \texttt{S\_Cond}(\econd, \vsone', \vstwo')\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{NBDJ}.

\section{TypingRule.SCase \label{sec:TypingRule.SCase}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a case statement with expression $\ve$ and cases \texttt{cases};
   \item \texttt{t\_e, e1} is the result of annotating $\ve$ in $\tenv$;
   \item \texttt{cases1, env1} is the result of annotating each case in \texttt{cases} given \texttt{t\_e};
   \item $\news$ is a case statement with expression $\veone$ and cases \texttt{cases1};
   \item $\newenv$ is \texttt{env1}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SCaseBegin}{\SCaseEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{WGSY}.

\section{TypingRule.SAssert \label{sec:TypingRule.SAssert}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is an assert statement with expression $\ve$;
   \item $(\tep,\vep)$ is the result of annotating $\ve$ in $\tenv$;
   \item One of the following applies:
     \item All of the following apply:
       \begin{itemize}
       \item $\tep$ \typesatisfies\  \texttt{t\_bool};
       \item $\news$ is an assert statement with expression $\vep$;
       \item $\newenv$ is $\tenv$.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SAssertBegin}{\SAssertEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Assert}(\ve)\\
    \annotateexpr{\tenv, \ve} \typearrow (\vte', \vep)\\
    \typesat(\tenv, \vte', \TBool)\\
    \news = \texttt{S\_Assert}(\vep)\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{JQYF}.


\section{TypingRule.SWhile \label{sec:TypingRule.SWhile}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a \texttt{while} statement with expression $\veone$ and statement block \texttt{s1};
   \item \texttt{t, e2} is the result of annotating $\veone$ in $\tenv$;
   \item One of the following applies:
     \item All of the following apply:
       \begin{itemize}
       \item $\vt$ \typesatisfies\  \texttt{t\_bool};
       \item \texttt{s2} is the result of annotating \texttt{s1} in $\tenv$;
       \item $\news$ is a \texttt{while} statement with expression \vetwo and statement block \texttt{s2};
       \item $\newenv$ is $\tenv$.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SWhileBegin}{\SWhileEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_While}(\veone, \vsone)\\
    \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo)\\
    \typesat(\tenv, \vte, \TBool)\\
    \annotateblock{\tenv, \vsone} \typearrow \vstwo\\
    \news = \texttt{S\_While}(\vetwo, \vstwo)\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{FTVN}.

\section{TypingRule.SRepeat \label{sec:TypingRule.SRepeat}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a \texttt{repeat} statement with expression $\veone$ and statement block \texttt{s1};
   \item \texttt{s2} is the result of annotating \texttt{s1} in $\tenv$;
   \item \texttt{t, e2} is the result of annotating $\veone$ in $\tenv$;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item $\vt$ \typesatisfies\  \texttt{t\_bool};
       \item $\news$ is a \texttt{repeat} statement with expression \vetwo and statement block \texttt{s2};
       \item $\newenv$ is $\tenv$.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SRepeatBegin}{\SRepeatEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Repeat}(\veone, \vsone)\\
    \annotateexpr{\tenv, \veone} \typearrow (\vt, \vetwo)\\
    \typesat(\tenv, \vte, \TBool)\\
    \annotateblock{\tenv, \vsone} \typearrow \vstwo\\
    \news = \texttt{S\_Repeat}(\vetwo, \vstwo)\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{FTVN}.

\section{TypingRule.SFor \label{sec:TypingRule.SFor}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a \texttt{for} statement with index \texttt{id}, direction \texttt{dir}, two expressions
      $\veone$ and \vetwo and a statement block \texttt{s'};
   \item \texttt{t1,e1'} is the result of annotating $\veone$ in $\tenv$;
   \item \texttt{t2,e2'} is the result of annotating \vetwo in $\tenv$;
   \item an error is raised: ``\texttt{ASL Typing Error : A subtype of integer was expected, t1 was provided}'' or $\vtone$ has the structure of an integer type and all of the following apply:
   \item an error is raised: ``\texttt{ASL Typing Error : A subtype of integer was expected, t2 was provided}'' or $\vttwo$ has the structure of an integer type and all of the following apply:
   \item One of the following applies:
     \begin{itemize}
       \item All of the following apply:
         \begin{itemize}
           \item $\vtone$ has the structure of an unconstrained integer type;
           \item $\tty$ is the unconstrained integer type;
         \end{itemize}
       \item All of the following apply:
         \begin{itemize}
           \item $\vttwo$ has the structure of an unconstrained integer type;
           \item $\tty$ is the unconstrained integer type;
         \end{itemize}
       \item All of the following apply:
         \begin{itemize}
           \item $\vtone$ has the structure of a constrained integer type with constraint \texttt{cs1};
           \item $\vttwo$ has the structure of a constrained integer type with constraint \texttt{cs2};
           \item One of the following applies:
             \begin{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{dir} is \texttt{to};
                   \item \texttt{bot\_cs} is \texttt{cs1};
                   \item \texttt{top\_cs} is \texttt{cs2};
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{dir} is \texttt{down to};
                   \item \texttt{bot\_cs} is \texttt{cs2};
                   \item \texttt{top\_cs} is \texttt{cs1};
                 \end{itemize}
             \end{itemize}
           \item One of the following applies:
             \begin{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{bot\_cs} contains a an expression that is not evaluable at compile-time;
                   \item \texttt{cs} is the empty constraint;
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{top\_cs} contains a an expression that is not evaluable at compile-time;
                   \item \texttt{cs} is the empty constraint;
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{bot} is the minimum of the constraints \texttt{bot\_cs};
                   \item \texttt{top} is the maximum of the constraints \texttt{top\_cs};
                   \item \texttt{bot} is less or equal than \texttt{top};
                   \item \texttt{cs} is the constraint \texttt{bot .. top};
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{bot} is the minimum of the constraints \texttt{bot\_cs};
                   \item \texttt{top} is the maximum of the constraints \texttt{top\_cs};
                   \item \texttt{top} is strictly less than \texttt{bot}
                   \item \texttt{cs} is \texttt{cs1};
                 \end{itemize}
             \end{itemize}
           \item $\tty$ is the constrained integer type with constraint \texttt{cs};
         \end{itemize}
     \end{itemize}
   \item an error is raised ``\texttt{ASL Typing Error: cannot declare already \\ declared element "id".}'' or \texttt{id} is not bound in $\tenv$ and all of the following apply:
   \item $\tenvp$ is $\tenv$ modified so that \texttt{id} is locally declared of type $\tty$;
   \item \texttt{s''} is the result of annotating \texttt{s'} in $\tenvp$;
   \item $\news$ is a for statement with index \texttt{id}, direction \texttt{dir}, two expressions $\veonep$ and $\vetwop$ and statement \texttt{s''};
   \item $\newenv$ is $\tenv$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SForBegin}{\SForEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
% \[
%   \inferrule{
%     \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veone')\\
%     \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwo')\\
%     \tstruct(\tenv, \vtone) \typearrow \TInt(\Ignore)\\
%     \tstruct(\tenv, \vttwo) \typearrow \TInt(\Ignore)\\
%     \news = \texttt{S\_For}(..., ...)\\
%     \newtenv = \tenv
%   }
%   {
%     \annotatestmt{\tenv, \texttt{S\_For}(\id, \dir, \veone, \vetwo, \vsp)} \typearrow (\news, \newtenv)
%   }
% \]
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{VTJW}.


\section{TypingRule.SThrowNone \label{sec:TypingRule.SThrowNone}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a throw statement with no expression;
   \item $\news$ is $\vs$;
   \item $\newenv$ is $\tenv$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SThrowNoneBegin}{\SThrowNoneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Throw}(\None)\\
    \news = \vs\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  Note that \identr{BRCJ} is done in~\cite[SemanticsRule.TopLevel]{ASLSemanticsReference}.

\section{TypingRule.SThrowSome \label{sec:TypingRule.SThrowSome}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a throw statement with expression $\ve$;
   \item \texttt{t\_e,\vep} is the result of annotating $\ve$ in $\tenv$;
   \item \texttt{t\_e} has the structure of an exception type;
   \item $\news$ is a throw statement with expression $\vep$ and type \texttt{t\_e};
   \item $\newenv$ is $\tenv$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SThrowSomeBegin}{\SThrowSomeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Throw}(\langle (\ve, \Ignore) \rangle)\\
    \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep)\\
    \astlabel(\tstruct(\tenv, \vte)) = \TException\\
    \news = \texttt{S\_Throw}(\langle (\vep, \langle\vte\rangle) \rangle)\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{NXRC}.


\section{TypingRule.STry \label{sec:TypingRule.STry}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a try statement with statement \texttt{s'}, catchers \texttt{catchers} and block \texttt{otherwise};
   \item \texttt{s''} is the result of annotating \texttt{s'} in $\tenv$;
   \item \texttt{otherwise'} is the result of annotating \texttt{otherwise} in $\tenv$;
   \item \texttt{catchers'} is the result of annotating \texttt{catchers} in $\tenv$;
   \item $\news$ is a try statement with statement \texttt{s''}, catchers \texttt{catchers'} and block \texttt{otherwise'};
   \item $\newenv$ is $\tenv$.
   \end{itemize}

  \subsection{Example}

\CodeSubsection{\STryBegin}{\STryEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \STry(\vsp, \catchers, \otherwise)\\
    \annotatestmt{\tenv, \vsp} \typearrow \vspp\\
    \catchers = [\annotatecatcher{\tenv, \vc} \;|\; \vc \in \catchers]\\
    \otherwise = \langle \annotateblock{\tenv, \vo} \;|\; \vo \in \otherwise\rangle\\
    \news = \STry(\vspp, \catchers', \otherwise')\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{WVXS}.

\section{TypingRule.SDeclSome \label{sec:TypingRule.SDeclSome}}

\subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a declaration with local identifiers \texttt{ldi} and an expression $\ve$;
   \item \texttt{t\_e,\vep} is the result of annotating $\ve$ in $\tenv$;
   \item \texttt{env', ldi'} is the result of declaring the local identifiers of \texttt{ldi} in $\tenv$;
   \item $\news$ is a declaration with \texttt{ldk}, \texttt{ldi'} and an expression $\vep$;
   \item $\newenv$ is $\tenvp$.
   \end{itemize}

\subsection{Example}

\CodeSubsection{\SDeclSomeBegin}{\SDeclSomeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \SDecl(\LDKConstant, \ldi, \langle\ve\rangle)\\
    \annotateexpr{\tenv, \ve} \typearrow (\vte, \vep)\\
    \reduceconstants{\tenv, \ve} \typearrow \vv\\
    \declarelocalconstant{\tenv, \ldi} \typearrow (\tenv', \vte, \vv, \ldi')\\
    \news = \SDecl(\LDKConstant, \ldi', \langle\vep\rangle)\\
    \newtenv = \tenv'
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
This is related to \identr{YSPM}.

\section{TypingRule.SDeclNone \label{sec:TypingRule.SDeclNone}}

  \subsection{Prose}
Annotating statement $\vs$ in an environment $\tenv$
(\texttt{annotate\_stmt env s}) results in a statement $\news$ and an
environment $\newenv$ and all of the following apply:
   \begin{itemize}
   \item $\vs$ is a declaration statement with local identifiers \texttt{ldi} and no initial expression;
   \item \texttt{env', s'} is the result of annotating uninitialised local declarations \texttt{ldi} in $\tenv$;
   \item $\news$ is \texttt{s'};
   \item $\newenv$ is $\tenvp$.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SDeclNoneBegin}{\SDeclNoneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \SDecl(\LDKConstant, \ldi, \None)\\
    \annotatelocaldeclitemuninit{\tenv, \ldi} \typearrow (\tenv', \vsp)\\
    \news = \vsp\\
    \newtenv = \tenv'
  }
  {
    \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Blocks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TypingRule.Block \label{sec:TypingRule.Block}}

  \subsection{Prose}
    Annotating a block $\vs$ in an environment $\tenv$, given a type
\texttt{return\_type} \\ (\texttt{annotate\_block env return\_type s}), is the
result of annotating the statement $\vs$ in $\tenv$.

  \subsection{Example: TypingRule.Block0.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.Block0.asl}


    \CodeSubsection{\BlockBegin}{\BlockEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \annotatestmt{\tenv, \vs} \typearrow (\vsp, \Ignore)
  }
  {
    \annotateblock{\tenv, \vs, \texttt{return\_type}} \typearrow \vsp
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    A local identifier declared with var, let or constant is in scope
from the point immediately after its declaration until the end of the
immediately enclosing block.

    From that follows that we can discard the environment at the end of
an enclosing block.

    This is related to \identr{JBXQ}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Catchers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating catchers \texttt{(name\_opt, ty, stmt)} in an environment
$\tenv$ given a type \texttt{return\_type} (\texttt{annotate\_catchers env
return\_type (name\_opt, ty, stmt)}) results in \texttt{(name\_opt, ty,
new\_stmt)} and one of the following applies:
\begin{itemize}
\item TypingRule.CatcherNone (see \secref{TypingRule.CatcherNone}),
\item TypingRule.CatcherSome (see \secref{TypingRule.CatcherSome}).
\end{itemize}

\section{TypingRule.CatcherNone \label{sec:TypingRule.CatcherNone}}

  \subsection{Prose}
   Annotating catcher \texttt{(name\_opt, ty, stmt)} in an environment
$\tenv$ given a type \texttt{return\_type} (\texttt{annotate\_catchers env
return\_type (name\_opt, ty, stmt)}) results in \texttt{(name\_opt, ty,
new\_stmt)} and all of the following apply:
   \begin{itemize}
   \item $\tty$ has the structure of an exception type;
   \item $\newopt$ gives no name;
   \item $\tenvp$ is $\tenv$;
   \item $\newstmt$ is the result of annotating $\vstmt$ in $\tenvp$ with \texttt{return\_type}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\CatcherNoneBegin}{\CatcherNoneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \astlabel(\tstruct(\tty)) = \TException\\
    \newopt = \None\\
    \tenv' = \tenv\\
    \annotateblock{\tenv', \vstmt} \typearrow \newstmtp
  }
  {
    \annotatecatcher{\tenv, \newopt, \tty, \vstmt} \typearrow (\newopt, \tty, \newstmtp)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{SDJK}.

\section{TypingRule.CatcherSome \label{sec:TypingRule.CatcherSome}}

  \subsection{Prose}
   Annotating catcher \texttt{(name\_opt, ty, stmt)} in an environment
$\tenv$ given a type \texttt{return\_type} (\texttt{annotate\_catchers env return\_type (name\_opt, ty, stmt)})
results in \texttt{(name\_opt, ty, new\_stmt)} and all of the following apply:
   \begin{itemize}
   \item $\tty$ has the structure of an exception type;
   \item $\newopt$ gives a name $\name$;
   \item $\name$ is not already declared in $\tenv$;
   \item $\name$ has type $\tty$ in $\tenv$; \todocomment{ROMAN: doesn't appear in the code}
   \item $\tenvp$ is $\tenv$ modified to have $\name$ locally declared as immutable of type $\tty$;
   \item $\newstmt$ is the result of annotating $\vstmt$ in $\tenvp$ with \texttt{return\_type}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\CatcherSomeBegin}{\CatcherSomeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    L^\tenv.\localstoragetypes(\id) = G^\tenv.\globalstoragetypes(\id) = G^\tenv.\subprograms(\id) = \bot
  }
  {
    \checkvarnotinenv{\tenv, \id}
  }
  \and
  \inferrule{
    \astlabel(\tstruct(\tty)) = \TException\\
    \newopt = \langle\name\rangle\\
    \checkvarnotinenv{\tenv, \name}\\
    \tenv' = (G^\tenv, L^\tenv.\localstoragetypes[\name \mapsto (\tty, \LDKLet)])\\
    \annotateblock{\tenv', \vstmt} \typearrow \newstmtp
  }
  {
    \annotatecatcher{\tenv, \newopt, \tty, \vstmt} \typearrow (\newopt, \tty, \newstmtp)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{SDJK}, \identr{WVXS}, \identi{FCGK}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Subprogram Calls \label{chap:TypingSubprogramCalls}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatecall}
The function
\[
  \begin{array}{rl}
  \annotatecall{ &
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\expr^*}{\vargs} \aslsep
    \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
    \overname{\subprogramtype}{\calltype}
  } \aslto \\ &
  (\overname{\identifier}{\nameone} \aslsep
  \overname{\expr^*}{\vargsone} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqsone} \aslsep
  \overname{\langle \ty \rangle}{\rettyone})
\end{array}
\]

Annotates the call to subprogram $\name$ with arguments $\vargs$,
parameters $\eqs$, and call type $\calltype$, resulting in values for an annotated call ---
$\nameone$, $\vargsone$, $\eqstwo$, $\rettyone$ --- or a type error if one is detected.

The rule TypingRule.FCall (see \secref{TypingRule.FCall}) applies.

We also define helper functions via respective rules:
\begin{itemize}
  \item TypingRule.FindCheckDeduce (see \secref{TypingRule.FindCheckDeduce}),
  which finds a subprogram that matches the call, checks for type errors, and infers expressions
  for parameters.
  % \item TypingRule.FindSubprogram (see \secref{TypingRule.FindSubprogram}),
  % which finds a subprogram that clashes with the subprogram
  % \item TypingRule.SubprogramFinder (see \secref{TypingRule.SubprogramFinder}),
  % \item TypingRule.HasArgClash (see \secref{TypingRule.HasArgClash}),
  % \item TypingRule.DeduceEquations (see \secref{TypingRule.DeduceEquations}),
  % \item TypingRule.RenameTypeEquations (see \secref{TypingRule.RenameTypeEquations}),
\end{itemize}

\section{TypingRule.FCall \label{sec:TypingRule.FCall}}
\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{function\_or\_getter}):
  \begin{itemize}
    \item Applying $\findcheckdeduce$ to $\tenv$, $\name$, $\exprs$, $\eqs$, and $\calltype$
    yields $(\nameone, \vargsone, \eqsone, \langle \tty \rangle)$ \ProseOrTypeError;
    \item $\calltype$ is either a function $\STFunction$ or a getter $\STGetter$;
    \item substituting the variables appearing in $\tty$ by the corresponding expressions,
    according to $\eqsone$ yields $\retty$;
    \item $\rettyone$ is $\langle\retty\rangle$.
  \end{itemize}

  \item All of the following apply (\textsc{procedure\_or\_setter}):
  \begin{itemize}
    \item Applying $\findcheckdeduce$ to $\tenv$, $\name$, $\exprs$, $\eqs$, and $\calltype$
    yields $(\nameone, \vargsone, \eqsone, \None)$;
    \item $\calltype$ is either a procedure $\STProcedure$ or a setter $\STSetter$;
    \item $\rettyone$ is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{mismatch}):
  \begin{itemize}
    \item Applying $\findcheckdeduce$ to $\tenv$, $\name$, $\exprs$, $\eqs$, and $\calltype$
    yields $(\nameone, \vargsone, \eqsone, \retty)$;
    \item the following condition does not hold:
    $\retty$ is $\None$ if and only if $\calltype$ is one of $\STProcedure$ or $\STSetter$;
    \item a type error is returned indicating that the existence of a return value does not match
    the kind of subprogram.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\FCallBegin}{\FCallEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[function\_or\_getter]{
  \findcheckdeduce(\tenv, \name, \exprs, \eqs, \calltype) \typearrow \\
  (\nameone, \vargsone, \eqsone, \langle \tty \rangle) \OrTypeError\\\\
  \calltype \in \{\STFunction, \STGetter, \STEmptyGetter\}\\
  \tododefine{rename\_ty\_eqs}(\tenv, \eqsone, \tty) \typearrow \retty
}
{
  \annotatecall{\tenv, \name, \exprs, \eqs, \calltype} \typearrow (\nameone, \vargsone, \eqsone, \langle\retty\rangle)
}
\and
\inferrule[procedure\_or\_setter]{
  \findcheckdeduce(\tenv, \name, \exprs, \eqs, \calltype) \typearrow \\
  (\nameone, \vargsone, \eqsone, \None) \\\\
  \calltype \in \{\STProcedure, \STSetter, \STEmptySetter\}
}
{
  \annotatecall{\tenv, \name, \exprs, \eqs, \calltype} \typearrow (\nameone, \vargsone, \eqsone, \None)
}
\and
\inferrule[mismatch]{
  \findcheckdeduce(\tenv, \name, \exprs, \eqs, \calltype) \typearrow \\
  (\nameone, \vargsone, \eqsone, \retty) \\\\
  \neg(\calltype \in \{\STProcedure, \STSetter\} \leftrightarrow \retty=\None)
}
{
  \annotatecall{\tenv, \name, \exprs, \eqs, \calltype} \typearrow \TypeErrorVal{CallMismatch}
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identi{VFDP}, \identd{TRFW}, \identr{KMDB},
  \identi{YMHX}, \identr{CCVD}, \identr{QYBH}, \identr{PFWQ}, \identr{ZLWD},
  \identi{FLKF}, \identd{PMBL}, \identr{MWBN}, \identr{TZSP}, \identr{SBWR},
  \identi{CMLP}, \identr{BQJG}, \identr{RTCF}.

\section{TypingRule.FindCheckDeduce \label{sec:TypingRule.FindCheckDeduce}}
\hypertarget{def-findcheckdeduce}{}
The function
\[
  \begin{array}{rl}
    \findcheckdeduce( &
      \overname{\staticenvs}{\tenv} \aslsep
      \overname{\identifier}{\name} \aslsep
      \overname{\expr^*}{\vargs} \aslsep
      \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
      \overname{\subprogramtype}{\calltype}
     ) \aslto \\ &
    \overname{\identifier}{\nameone} \aslsep
    \overname{\expr^*}{\vargsone} \aslsep
    \overname{(\identifier\times\expr)^*}{\eqsone} \aslsep
    \overname{\subprogramtype}{\retty}
  \end{array}
\]
performs three tasks:
\begin{itemize}
  \item Resolving the correct subprogram from the rule arguments. That is, finding a subprogram
  that with the same name and argument types that \typeclash\ with the actual argument types;
  \item Deducing from the actual arguments and formal parameters ``equations'' ---
  the expressions associated with parameter names;
  \item Checking that the call expression matches the subprogram declaration.
\end{itemize}
The function takes a static environment $\tenv$, a subprogram $\name$,
a list of actual arguments $\vargs$,
parameters $\eqs$ arguments, and call type $\calltype$.
It returns a unique name $\nameone$, annotated actual arguments $\vargsone$,
parameter arguments $\eqsfour$, and an optional return type $\retty$.
A type error is returned, if one is detected.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item Annotating the list of actual argument expressions $\vargs$ in $\tenv$ yields $\callerargtyped$ \ProseOrTypeError;
  \item $\callerargtyped$ is a list of pairs where the first element is a type and the second is an expression;
  \item splitting $\callerargtyped$ yields a list of types --- $\callerargtypes$ --- and a list of expressions ---
  $\vargsone$, respectively;
  \item finding the subprogram matching the name $\name$ and argument types $\callerargtypes$ in $\tenv$
  yields a tuple $(\extranargs, \nameone, \calleeargtypes, \retty, \calleeparams)$ \ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{bad\_arity}):
    \begin{itemize}
      \item the length of the actual list of arguments is not the same as the list of arguments of the matched
      subprogram;
      \item a type error is returned.
    \end{itemize}

    \item All of the following apply (\textsc{okay}):
    \begin{itemize}
      \item The list of parameter arguments $\eqs$ is reversed and pre-pended to the list of parameter arguments
      i$\extranargs$, yielding $\eqstwo$;
      \item annotating static constrained integers in $\eqstwo$ in $\tenv$ yields $\eqsthree$ \ProseOrTypeError;
      \item annotating the callee parameters using $\calleeargtypes$ and $\callerargtypes$ in $\tenv$
      yields $\eqsfour'$;
      \item $\eqsfour$ is $\eqsfour'$ concatenated with $\eqsthree$;
      \item checking that $\callerargtypes$ \typesatisfies\ $\calleeargtypes$ in $\tenv$ yields
      $\True$ \ProseOrTypeError;
      \item checking that each callee parameter in $\calleeparams$ is defined by the call
      parameters $\eqsfour$ yields $\True$ \ProseOrTypeError.
    \end{itemize}
  \end{itemize}
\end{itemize}

\CodeSubsection{\FindCheckDeduceBegin}{\FindCheckDeduceEnd}{../Typing.ml}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
\inferrule[bad\_arity]{
  \annotateexprlist{\tenv, \vargs} \typearrow \callerargtyped \OrTypeError\\
  \splitlist(\callerargtyped) = (\callerargtypes, \vargsone)\\
  \findsubprogram(\tenv, \name, \callerargtypes) \typearrow \\
  (\Ignore, \Ignore, \calleeargtypes, \Ignore, \Ignore) \OrTypeError\\\\
  \equallength(\calleeargtypes, \vargsone) \typearrow \False
}
{
  \findcheckdeduce(\tenv, \name, \vargs, \eqs, \calltype) \typearrow \\
  \TypeErrorVal{CallBadArity}
}
\and
\inferrule[okay]{
  \annotateexprlist{\tenv, \vargs} \typearrow \callerargtyped \OrTypeError\\
  \splitlist(\callerargtyped) = (\callerargtypes, \defpoint{\vargsone})\\
  \findsubprogram(\tenv, \name, \callerargtypes) \typearrow \\
  (\extranargs, \defpoint{\nameone}, \calleeargtypes, \defpoint{\retty}, \calleeparams) \OrTypeError\\\\
  \equallength(\calleeargtypes, \vargsone) \typearrow \True\\
  \eqs \eqname \veq_{1..k}\\
  \eqstwo \eqdef [i=k..1: \veq_i] + \extranargs\\
  % \tododefine{apply\_eqs}(\tenv, \calleeargtypes, \callerargtyped) \typearrow \eqstwo' \OrTypeError\\
  % \eqstwo \eqdef \eqstwo' + \eqsone\\
  \tododefine{annotate\_static\_constrained\_integers}(\tenv, \eqstwo) \typearrow \eqsthree \OrTypeError\\
  \tododefine{annotate\_callee\_params}(\tenv, \calleeargtypes, \callerargtypes) \typearrow \eqsfour' \OrTypeError\\
  \defpoint{\eqsfour} \eqdef \eqsfour' + \eqsthree\\
  \tododefine{check\_args\_typesat}(\tenv, \calleeargtypes, \callerargtypes) \typearrow \True \OrTypeError\\
  \tododefine{check\_callee\_params}(\tenv, \calleeparams, \eqsfour) \typearrow \True \OrTypeError\\
}
{
  \findcheckdeduce(\tenv, \name, \vargs, \eqs, \calltype) \typearrow
  (\nameone, \vargsone, \eqsfour, \retty)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.FindSubprogram \label{sec:TypingRule.FindSubprogram}}
\hypertarget{def-findsubprogram}{}
The function
\[
  \begin{array}{rl}
    \findsubprogram( &
      \overname{\staticenvs}{\tenv} \aslsep
      \overname{\identifier}{\name} \aslsep
      \overname{\ty^*}{\callerargtypes}
     ) \aslto \\ &
    (
      \overname{(\identifier\times\expr)^*}{\extranargs} \aslsep
      \overname{\identifier}{\nameone} \aslsep
      \overname{(\identifier\times\ty)^*}{\calleeargtypes} \aslsep
      \overname{\langle\ty\rangle}{\retty} \aslsep
      \overname{(\identifier \times \langle\ty\rangle)}{\calleeparams}
    )
  \end{array}
\]
takes the name of a subprogram --- $\name$ --- and a list argument types --- $\calleeargtypes$,
and determines whether:
\begin{itemize}
  \item there is no declared subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is exactly one subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is more than one subprogram that matches ($\name$ and $\calleeargtypes$);
\end{itemize}
The first and last cases indicate a type error.
If the second case holds, the function returns:
\begin{itemize}
\item $\extranargs$ --- a list matching parameters to their caller expressions based on bitvector parameters;
\item $\identifier$ --- an identifier that uniquely matches this subprogram;
\item $\calleeargtypes$ --- the list of formal argument types of the matched subprogram;
\item $\retty$ --- the type of the returned value, in case of a function or a getter;
\item $\calleeparams$ --- parameters declared in the matched subprogram.
\end{itemize}
A type error is returned, if one is detected.

\begin{emptyformal}
\subsection{Formally}
% \begin{mathpar}
% \inferrule{
% }
% {
%   \findsubprogram(\tenv, \name, \callerargtypes) \typearrow \\
%   (\extranargs, \nameone, \calleeargtypes, \retty, \calleeparams)
% }
% \end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Subprograms}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a subprogram $\vf$ in an environment $\tenv$
(\texttt{annotate\_subprogram}) results in \texttt{f'}.

\section{TypingRule.Subprogram \label{sec:TypingRule.Subprogram}}

  \subsection{Prose}
Annotating a subprogram $\vf$ in an environment $\tenv$
(\texttt{annotate\_subprogram}) results in $\vf$, \texttt{new\_body} and all of
the following apply:
 \begin{itemize}
   \item \texttt{env1} is $\tenv$ modified to have an empty local
     environment and a return type given by $\vf$;
   \item \texttt{env2} is \texttt{env1} with every formal argument given by
     $\vf$ declared as immutable with its type;
   \item \texttt{env3} is \texttt{env2} modified to add explicit parameters
     given by $\vf$;
   \item \texttt{env4} is \texttt{env3} modified to resolve dependently typed
     identifiers in the arguments given by $\vf$;
   \item \texttt{env5} is \texttt{env4} modified to resolve dependently typed
     identifiers in the result type given by $\vf$;
   \item \texttt{body} is the body given by $\vf$;
   \item \texttt{new\_body} is the result of annotating \texttt{body} in
     \texttt{env5}.
   \item \texttt{f'} is the function $\vf$ with \texttt{new\_body} substituted for \texttt{body}.
 \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SubprogramBegin}{\SubprogramEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{}{ \texttt{param\_type}(\None) = \isunconstrainedinteger }
  \and
  \inferrule{}{ \texttt{param\_type}(\langle\tty\rangle) = \tty }
  \and
  \inferrule{
    \texttt{env1} = (G^\tenv, [\constantvalues \mapsto \lambda \id.\ \bot, \localstoragetypes \mapsto \lambda \id.\ \bot, \returntype = \vf.\returntype])\\
    \vf.\text{args} = [i=1..k: (\va_i, \tty_i)]\\
    i=1..k: \checkvarnotinenv{\texttt{env1}, \va_i}\\
    \texttt{env2} = (G^\texttt{env1}, \texttt{env1}[\localstoragetypes \mapsto [i=1..k: \va_i \mapsto (\LDKLet, \tty_i)] )]\\
    \vf.\text{parameters} = [j=1..n: (\vp_j, \tyopt_j)]\\
    j=1..k: \checkvarnotinenv{\texttt{env2}, \vp_j}\\
    \texttt{env3} = (G^\texttt{env2}, \texttt{env2}[\localstoragetypes \mapsto [j=1..n: \vp_i \mapsto (\LDKLet, \texttt{param\_type}(\tyopt_j))] )]\\
    \texttt{env4} = \texttt{add\_dependently\_typed}(\texttt{env3}, \vf.\text{args})\\
    \texttt{env5} = \texttt{resolve\_dependently\_typed\_in\_res}(\texttt{env4}, \vf.\text{return\_type})\\
    \vf.\text{return\_type} = \texttt{SB\_ASL} \vs\\
    \annotateblock{\texttt{env4}, \vs} \typearrow \texttt{new\_body}\\
    (\Ignore, \name, \Ignore, \Ignore) \in G^\texttt{env5}.\subprogramrenamings(\vf.\name, [i=1..k: \tty_i])\\
    \vf' = \vf[\text{body}\mapsto \texttt{new\_body}]
  }
  {
    \annotatesubprogram{\tenv, \vf} \typearrow \vf'
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identi{GHGK}, \identr{HWTV}, \identr{SCHV}, \identr{VDPC},
\identr{TJKQ}, \identi{LFJZ}, \identi{BZVB}, \identi{RQQB}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Global Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Declaring a global declaration $\vd$ in an environment $\tenv$ ($\declaredecl{\tenv, \vd}$)
results in a new environment $\tenvp$, which contains the declared element, and one of the following applies:
\begin{itemize}
  \item TypingRule.DeclareOneFunc (see \secref{TypingRule.DeclareOneFunc}).
  \item TypingRule.DeclareGlobalStorage (see \secref{TypingRule.DeclareGlobalStorage}).
  \item TypingRule.DeclareType (see \secref{TypingRule.DeclareType}).
\end{itemize}

\section{TypingRule.DeclareOneFunc \label{sec:TypingRule.DeclareOneFunc}}
\subsection{Prose}
Declaring a subprogram $\funcsig$ in a given environment $\tenv$ results
in $\newenv$ and all of the following apply:
\begin{itemize}
  \item $\name$ is the identifier associated with the subprogram declaration;
  \item $\tenv$ does not contain another subprogram declaration for $\name$ that clashes with $\funcsig$;
  \item $\newenv$ is $\tenv$ where
  $\funcsig$ has been added to the set of subprograms declared with $\name$ (\subprogramrenamings)
  and $\name$ is associated with $\funcsig$.
\end{itemize}

\subsection{Example}

\CodeSubsection{\DeclareOneFuncBegin}{\DeclareOneFuncEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}

We define the helper rules \hassubprogramtypeclash, \argsclash, and subprogramclash\ to determined whether
two subprogram clash in terms of their subprogram types and their lists of argument types,
and then use them to annotate a subprogram declaration.

\begin{mathpar}
\inferrule{}{\hassubprogramtypeclash(\tenv, \STFunction, \Ignore)}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \Ignore, \STFunction)}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \STProcedure, \Ignore)}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \Ignore, \STProcedure)}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \STGetter, \STGetter)}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \STSetter, \STSetter)}
\and
\inferrule{
  \texttt{t\_args1} = [i=1..k: (\Ignore, \vt_i)]\\
  \texttt{s\_args1} = [i=1..k: (\Ignore, \vs_i)]\\
  j \in 1..k\\
  \typeclashes(\tenv, \vt_j, \vs_j)
}
{\argsclash(\tenv, \texttt{t\_args}, \texttt{s\_args})}
\and
\inferrule{
  \argsclash(\vf.\subprogramtype, \texttt{g}.\subprogramtype)\\
  \argsclash(\vf.\vargs, \texttt{g}.\vargs)\\
}
{ \subprogramclash(\vf, \texttt{g}) }
\and
\inferrule{
  \name = \funcsig.\name\\
  \texttt{same\_named} = G^\tenv.\subprogramrenamings(\name)\\
  \texttt{fo} \in \texttt{same\_named}: \neg\subprogramclash(\tenv, \funcsig, \texttt{fo})\\
  G' = G^\tenv.\subprogramrenamings[\name \mapsto \texttt{same\_named} \cup \{\funcsig\}]\\
  G'' = G'.\subprograms[\name \mapsto \funcsig]\\
  \newenv = (G'', L^\tenv)
}
{
  \declaredecl{\tenv, \funcsig} \typearrow G''
}
\end{mathpar}
\end{emptyformal}
\subsection{Comments}

This relates to \identi{HJRD}, \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}, and \identr{PGFC}.

\section{TypingRule.DeclareGlobalStorage \label{sec:TypingRule.DeclareGlobalStorage}}
\subsection{Prose}
Annotating a global storage declaration $\vd$ in a given environment $\tenv$ results
in $\newenv$ and one of the following applies:
\begin{itemize}
  \item All of the following apply:
  \begin{itemize}
    \item $\vd$ declares a global constant named \name, with initial value expression $\ve$, and without a type annotation.
    \item $\vv$ is the literal computed in \tenv\ by evaluating $\ve$.
    \item $\vt$ is the type inferred for $\vv$
    \item $\newenv$ is \tenv\ extended with a declaration of the constant \name, with initial value $\vv$ and type $\vt$.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\vd$ declares a global constant named \name, with initial value expression $\ve$, and type annotation $\tty$.
    \item $\vv$ is the literal computed in \tenv\ by evaluating $\ve$.
    \item $\vt$ is the type inferred for $\vv$.
    \item $\vt$ \typesatisfies\  $\tty$ in \tenv.
    \item $\newenv$ is \tenv\ extended with a declaration of the constant \name, with initial value $\vv$ and type $\tty$.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\vd$ declares a global constant or global let with no initial value expression.
    \item An error ``\texttt{Constants or let-bindings must be initialized}'' is raised.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\vd$ declares a global variable or config named \name, with no initial value expression, and type annotation $\tty$.
    \item One of the following applies:
    \begin{itemize}
      \item An error ``\texttt{identifier already declared}'' is raised and all of the following apply:
      \begin{itemize}
        \item $\name$ is not yet declared in the global environment.
        \item $\newenv$ is \tenv\ extended with a declaration of the global storage element named \name, and type $\tty$.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\vd$ declares a global storage element with named \name, with initial value expression $\ve$, and no type.
    \item $\vt$ is the type resulting from annotating the expression $\ve$ in \tenv.
    \item $\newenv$ is \tenv\ extended with a declaration of the global storage element named \name\ and type $\tty$.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item $\vd$ declares a global storage element with named \name, with initial value expression $\ve$, and type annotation $\tty$.
    \item \texttt{t, \vep} is the result of annotating the expression $\ve$ in \tenv.
    \item One of the following applies:
    \begin{itemize}
      \item $\vt$ does not type-satisfy $\tty$ in \tenv.
      \item A ``Conflicting types'' error is raised.
    \end{itemize}
    \item $\newenv$ is \tenv\ extended with a declaration of the global storage element named \name\ and type $\tty$.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\DeclareGlobalStorageBegin}{\DeclareGlobalStorageEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule[Case 1]{
    \gsd = \{\textsf{keyword} : \GDKConstant, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \None, \textsf{name}:\name \}\\
    \texttt{reduce\_constants}(\tenv, \ve) \typearrow \vv\\
    \annotateliteral{\vv} \typearrow \vt\\
    \texttt{declare\_const}(\tenv, \name, \vt, \vv) \typearrow \newtenv
  }
  { \declaredecl{\tenv, \gsd} \typearrow \newtenv }
  \and
  \inferrule[Case 2]{
    \gsd = \{\textsf{keyword} : \GDKConstant, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \langle\tty\rangle, \textsf{name}:\name \}\\
    \texttt{reduce\_constants}(\tenv, \ve) \typearrow \vv\\
    \annotateliteral{\vv} \typearrow \vt\\
    \typesat(\tenv, \vt, \tty)\\
    \texttt{declare\_const}(\tenv, \name, \tty, \vv) \typearrow \newtenv
  }
  { \declaredecl{\tenv, \gsd} \typearrow \newtenv }
  \and
  \inferrule[Case 4]{
    \gsd = \{\textsf{keyword} : \vk, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \langle \tty \rangle, \textsf{name}:\name \}\\
    \vk \in \{\GDKConfig, \GDKVar\}\\
    G^\tenv.\globalstoragetypes(\name) = \bot\\
    \newtenv = (G^\tenv.\globalstoragetypes[\name \mapsto (\tty, \vk)], L^\tenv)
  }
  { \declaredecl{\tenv, \gsd} \typearrow \newtenv }
  \and
  \inferrule[Case 5]{
    \gsd = \{\textsf{keyword} : \vk, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \None, \textsf{name}:\name \}\\
    G^\tenv.\globalstoragetypes(\name) = \bot\\
    \annotateexpr{\tenv, \ve} \typearrow (\vt, \Ignore)\\
    \newtenv = (G^\tenv.\globalstoragetypes[\name \mapsto (\vt, \vk)], L^\tenv)
  }
  { \declaredecl{\tenv, \gsd} \typearrow \newtenv }
  \and
  \inferrule[Case 6]{
    \gsd = \{\textsf{keyword} : \vk, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \langle\tty\rangle, \textsf{name}:\name \}\\
    G^\tenv.\globalstoragetypes(\name) = \bot\\
    \annotateexpr{\tenv, \ve} \typearrow (\vt, \vep)\\
    \typesat(\tenv, \vt, \tty)\\
    \newtenv = (G^\tenv.\globalstoragetypes[\name \mapsto (\tty, \vk)], L^\tenv)
  }
  { \declaredecl{\tenv, \gsd} \typearrow \newtenv }
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
This relates to \identr{YSPM} and \identr{FWQM}.

\section{TypingRule.DeclareType \label{sec:TypingRule.DeclareType}}
\subsection{Prose}
Declaring a type named $\name$ with a type specification $\tty$,
optionally a supertype $\sup$ and extra fields $\fields$, in a given environment $\tenv$ results
in $\tenvp$ and one of the following applies:
\begin{enumerate}
  \item All of the following apply:
  \begin{itemize}
    \item \name\ is already declared in \tenv.
    \item An error ``identifier already declared'' is raised.
  \end{itemize}
  \item All of the following apply:
  \begin{itemize}
    \item \name\ is not declared in \tenv.
    \item  \tenv',\tty' are the result of attempting to add $\name$ as a subtype of $\sup$ and
    constructing the type \tty' as \tty\ with the added fields $\fields$ in \tenv.
    \item \tty' is a valid type.
    \item \tenv'' is \tenv' extended with \tty'.
    \item If \tty' has the structure of an enumeration than \newtenv\ is \tenv'' extended with the declarations of constants for each identifier,
    and otherwise \newtenv\ is \tenv''.
  \end{itemize}
\end{enumerate}

\subsection{Example}

\CodeSubsection{\DeclareTypeBegin}{\DeclareTypeEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}
\newcommand\attemptaddsubtype[0]{\texttt{attempt\_add\_subtype}}
\newcommand\attemptaddenum[0]{\texttt{attempt\_add\_enum}}
\newcommand\checkisvalidtype[0]{\texttt{check\_is\_valid\_type}}

\begin{mathpar}
  % \inferrule{ \astlabel(\tty) \not\in \{\TRecord, \TException, \TBits\} }
  % { \checkisvalidtype(\tenv, \tty) }
  % \and
  \inferrule{
    \checkvarnotinenv{\tenv, \name}\\
    \attemptaddsubtype(\tenv, \tty, \vs) \typearrow (\tenv', \tty')\\
    \checkisvalidtype(\tenv, \tty')\\
    \tenv'' = (G^{\tenv'}.\globalstoragetypes[\name\mapsto \tty'], L^{\tenv'})\\
    \attemptaddenum(\tenv'', \tty') \typearrow \newtenv
  }
  { \declaredecl{\name, \tty, \vs} \typearrow \newtenv }
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
This is related to \identr{DHRC}, \identd{YZBQ}, \identr{DWSP}, \identi{MZXL}, \identr{MDZD}, \identr{CHKR}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Specifications}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An ASL specification consists of a list of declarations.
Type checking the specification is considered successful if all declarations can be successfully annotated.

\section{TypingRule.Specification \label{sec:TypingRule.Specification}}
\subsection{Prose}
Annotating an ASL specification $\decls$ in an environment $\tenv$ results in an annotated specification $\declsp$
and a new environment $\newenv$ and all of the following apply:
\begin{itemize}
  \item $\ordereddecls$ is the result of topologically ordering $\decls$ according to their
  mutual dependencies.
  \item \newtenv\ is the result of declaring all global declarations in $\ordereddecls$ in \tenv.
  \item $\declsp$ is the result of annotating every declaration in $\decls$ in the environment \newtenv.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SpecificationBegin}{\SpecificationEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \texttt{order\_topologically}(\tenv, \decls) \typearrow \ordereddecls\\
    \ordereddecls = [i=1..k: \vd_i]\\
    \tenv_0 = \tenv\\
    i=1..k: \declaredecl{\tenv_{i-1}, \vd_{i-1}} \typearrow \tenv_{i}\\
    \newtenv = \tenv_{k}\\
    \decls' = [i=1..k: \texttt{annotate\_decl}(\newtenv, \vd_i) ]
  }
  { \annotatespec{\tenv, \decls} \typearrow (\decls', \newtenv) }
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
This relates to \identi{LWQQ}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Static Evaluation}
\label{chap:staticevaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hypertarget{def-staticeval}{}
\section{TypingRule.StaticEval}
The partial function
\[
  \staticeval(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \;\aslto\;
  \overname{\literals}{\vv} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
evaluates an expression $\ve$, from a subset of the set of all expressions, in environment $\tenv$, returning a literal $\vv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[e\_literal]{}
  {
    \staticeval(\tenv, \ELiteral(\vv)) \typearrow \vv
  }
  \and
  \inferrule[e\_var]{
    \tododefine{lookup\_constant}(\tenv, \vx) \typearrow \vv
  }
  {
    \staticeval(\tenv, \EVar(\vx)) \typearrow \vv
  }
  \and
  \inferrule[e\_binop]{
    \staticeval(\tenv, \veone) \typearrow \vvone\\
    \staticeval(\tenv, \vetwo) \typearrow \vvtwo\\
    \binop(\op, \vvone, \vvtwo) \typearrow \vv
  }
  {
    \staticeval(\tenv, \EBinop(\op, \veone, \vetwo)) \typearrow \vv
  }
  \and
  \inferrule[e\_unop]{
    \staticeval(\tenv, \veone) \typearrow \vvone\\
    \unop(\op, \vvone) \typearrow \vv
  }
  {
    \staticeval(\tenv, \EUnop(\op, \veone)) \typearrow \vv
  }
  \and
  \inferrule[e\_slice\_int]{
    \tododefine{slices\_to\_positions}(\tenv, \slices) \typearrow \positions\\
    \staticeval(\tenv, \veone) \typearrow \vvone\\
    \posmax \eqdef \max(\positions)\\
    \bv \eqdef \tododefine{bitvector\_of\_z}(\posmax + 1, \vi)\\
    \vv \eqdef \lbitvector(\tododefine{extract\_slice}(\bv, \positions))
  }
  {
    \staticeval(\tenv, \ESlice(\lint(\vi), \slices)) \typearrow \vv
  }
  \and
  \inferrule[e\_slice\_bitvector]{
    \tododefine{slices\_to\_positions}(\tenv, \slices) \typearrow \positions\\
    \staticeval(\tenv, \veone) \typearrow \vvone\\
    \tododefine{bitvector\_length}(\bv) > \posmax\\
    \vv \eqdef \lbitvector(\tododefine{extract\_slice}(\bv, \positions))
  }
  {
    \staticeval(\tenv, \ESlice(\lbitvector(\bv), \slices)) \typearrow \vv
  }
  \and
  \inferrule[e\_slice\_type\_error]{
    \astlabel(\veone) \not\in \{\lint, \lbitvector\}
  }
  {
    \staticeval(\tenv, \ESlice(\veone, \slices)) \typearrow \TypeError(\texttt{TypeMismatch}(\veone, [\TInt, \TBits]))
  }
  \and
  \inferrule[e\_cond]{
    \staticeval(\tenv, \econd) \typearrow \vcond\\
    \vcond \eqname \lbool(\vb)\\
    \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\
    \staticeval(\tenv, \vep) \typearrow \vv
  }
  {
    \staticeval(\tenv, \ECond(\econd, \veone, \vetwo)) \typearrow \vv
  }
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Symbolic Subsumption Testing \label{chap:symbolicsubsumptiontesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-symbolicdomain}{}
The symbolic reasoning operates by first transforming types into expressions in a \emph{symbolic domain} AST
(defined next, reusing $\intconstraint$ from the parsed AST) over which it then operates:
\hypertarget{def-symdom}{}
\hypertarget{def-dbool}{}
\[
  \begin{array}{rcl}
    \symdom &::=& \DBool                    \hypertarget{def-dstring}{}\\
            &|  & \DString                  \hypertarget{def-dreal}{}\\
            &|  & \DReal                    \hypertarget{def-dsymbols}{}\\
            &|  & \DSymbols(\identifier^+)  \hypertarget{def-dint}{}\\
            &|  & \DInt(\intset)            \hypertarget{def-dbits}{}\\
            &|  & \DBits(\intset)           \hypertarget{def-intset}{} \hypertarget{def-finite}{}\\
    \intset &::=& \Finite(\Z^+)             \hypertarget{def-top}{}\\
            &|  & \Top                      \hypertarget{def-fromsymtax}{}\\
            &|  & \FromSyntax(\syntax)      \hypertarget{def-syntax}{}\\
    \syntax &::=& \intconstraint^*
  \end{array}
\]

\section{TypingRule.SymSubsumes}
\hypertarget{def-symsubsumes}{}
The predicate
\[
  \symsubsumes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb}
\]
soundly approximates $\subsumes(\tenv, \vt, \vs)$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \symdomoftype(\tenv, \vt) \typearrow \dt\\
    \symdomoftype(\tenv, \vs) \typearrow \ds\\
    \symdomissubset(\tenv, \dt, \ds) \typearrow \vb
  }
  {
    \symsubsumes(\tenv, \vt, \vs) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SymDomOfType}
\hypertarget{def-symdomoftype}{}
The partial function
\[
  \symdomoftype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto \overname{\symdom}{\vd}
\]
transforms a type $\vt$ in a static environment $\tenv$ into a symbolic domain $\vd$.

% | T_Bits (width, _) -> (
%     try
%       match of_expr env width with
%       | D_Int (Finite int_set as d) ->
%           if Z.equal (IntSet.cardinal int_set) Z.one then D_Bits d
%           else raise StaticEvaluationTop
%       | D_Int (FromSyntax [ Constraint_Exact _ ] as d) -> D_Bits d
%       | _ -> raise StaticEvaluationTop
%     with StaticEvaluationTop ->
%       D_Bits (FromSyntax [ Constraint_Exact width ]))
% | T_Array _ | T_Exception _ | T_Record _ | T_Tuple _ ->
%     failwith "Unimplemented: domain of a non singular type."
% | T_Named _ -> assert false (* make anonymous *)

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TBool) \typearrow \DBool }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TString) \typearrow \DString }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TReal) \typearrow \DReal }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TEnum(\vli)) \typearrow \DSymbols(\vli) }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TInt(\unconstrained)) \typearrow \DInt(\Top) }
  \and
  \inferrule{}{ \symdomoftype(\tenv, \vt, \TInt(\underconstrained(\id))) \typearrow \\
  \DInt(\FromSyntax([\ConstraintExact(\EVar(\id))])) }
  \and
  \inferrule{
    \intsetofintconstraints(\tenv, \vcs) \typearrow \vis
  }{ \symdomoftype(\tenv, \vt, \TInt(\wellconstrained(\vcs))) \typearrow \DInt(\vis)}
\end{mathpar}

\begin{mathpar}
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\Finite([n]))
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \DBits(\Finite([n]))
  }
  \and
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\Finite([n_{1..k}]))\\
    k > 1
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \\ \DBits(\FromSyntax([\ConstraintExact(\EVar(\width))]))
  }
  \and
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\FromSyntax([\ConstraintExact(\vv)]))
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \\ \DBits(\FromSyntax([\ConstraintExact(\vv)]))
  }
  \and
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\FromSyntax(\vc))\\
    \vc \neq [\ConstraintExact(\vv)]
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \\ \DBits(\FromSyntax([\ConstraintExact(\EVar(\width))]))
  }
  \and
  \inferrule{
    \symdomofexpr(\tenv, \width) \typearrow \DInt(\Top)
  }{
    \symdomoftype(\tenv, \vt, \TBits(\width)) \typearrow \\ \DBits(\FromSyntax([\ConstraintExact(\EVar(\width))]))
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.SymDomOfExpr}
\hypertarget{def-symdomofexpr}{}

\section{TypingRule.SymDomOfLiteral}
\hypertarget{def-symdomofliteral}{}

\section{TypingRule.SymIntSetOfConstraints}
\hypertarget{def-intsetofintconstraintse}{}

\section{TypingRule.SymDomIsSubset}
\hypertarget{def-symdomissubset}{}

% | D_Bool, D_Bool | D_String, D_String | D_Real, D_Real -> true
% | D_Symbols s1, D_Symbols s2 -> ISet.subset s1 s2
% | D_Bits is1, D_Bits is2 | D_Int is1, D_Int is2 ->
%     int_set_is_subset env is1 is2

\begin{mathpar}
  \inferrule[bool]{}{ \symdomissubset(\tenv, \DBool, \DBool) \typearrow \True }
  \and
  \inferrule[string]{}{ \symdomissubset(\tenv, \DString, \DString) \typearrow \True }
  \and
  \inferrule[real]{}{ \symdomissubset(\tenv, \DReal, \DReal) \typearrow \True }
  \and
  \inferrule[symbols]{
    \vb \eqdef \{\vsone\} = \{\vstwo\}
  }{ \symdomissubset(\tenv, \DSymbols(\vsone), \DSymbols(\vstwo)) \typearrow \vb }
  \and
  \inferrule[bits]{
    \symintsetsubset(\tenv, \isone, \istwo) \typearrow \vb
  }{ \symdomissubset(\tenv, \DBits(\isone), \DBits(\istwo)) \typearrow \vb }
  \and
  \inferrule[int]{
    \symintsetsubset(\tenv, \isone, \istwo) \typearrow \vb
  }{ \symdomissubset(\tenv, \DInt(\isone), \DInt(\istwo)) \typearrow \vb }
  \and
  \inferrule[different\_labels]{
    \astlabel(\dt) \neq \astlabel(\ds)
  }{ \symdomissubset(\tenv, \dt, \ds) \typearrow \False }
\end{mathpar}

\section{TypingRule.SymIntSetSubset}
\hypertarget{def-symintsetsubset}{}

\section{TypingRule.SymSyntaxSubset}
\hypertarget{def-symsyntaxsubset}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Symbolic Equivalence Testing \label{chap:symbolicequivalencetesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we define \emph{conservative} equivalence tests for expressions and types.
By conservative, we mean that if a test returns $\True$ then the expressions or types being
compared are indeed equivalent, but if the test returns $\False$ then
there are two possibilities:
\begin{itemize}
  \item the expressions or types are not equivalent;
  \item the expressions or types are equivalent, but the reasoning power of our rules
  is not enough to prove it, and so we ``conservatively'' answer negatively.
\end{itemize}
In proof-theoretic terms, we can say that our equivalence tests are \emph{sound} but \emph{incomplete}.

Notice that for a conservative test, it is always correct to return $\False$.

\section{TypingRule.Equal}
\hypertarget{def-equal}{}
The parametric function $\equal$ equates two values of the same mathematical type and returns
the respective Boolean value:
\begin{mathpar}
    \inferrule[equal-true]{a = b}
    {
        \equal(a, b) \rightarrow \True
    }
    \and
    \inferrule[equal-false]{a \neq b}
    {
        \equal(a, b) \rightarrow \False
    }
\end{mathpar}
The reason we define equality via rules is to allow using it as a short-circuiting premise.

\section{TypingRule.ExprEqual}
The function
\[
  \exprequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo}) \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively checks whether the expression $\veone$ is equivalent to the expression $\vetwo$ in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \False \terminateas \True\\\\
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
  {
    \exprequal(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ExprEqualCase}

The function
\[
  \exprequalcase(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
specializes the expression equivalence test for the different types of expressions.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[different\_labels]{
    \astlabel(\veone) \neq \astlabel(\vetwo)
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_binop]{
    \veone \eqname \EBinop(\opone, \veoneone, \veonetwo)\\
    \vetwo \eqname \EBinop(\optwo, \vetwoone, \vetwotwo)\\\\
    \exprequal(\veoneone, \vetwoone) \typearrow \vbone\\
    \exprequal(\veonetwo, \vetwotwo) \typearrow \vbtwo\\\\
    \vb \eqdef (\opone = \optwo) \land \vbone \land \vbtwo
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

Recall that a conjunction over an empty set equals $\True$.
\begin{mathpar}
  \inferrule[e\_call]{
    \veone \eqname \ECall(\nameone, \vargsone, \Ignore)\\
    \vetwo \eqname \ECall(\nametwo, \vargstwo, \Ignore)\\\\
    \equal(\nameone, \nametwo) \equalarrow \True \terminateas \False\\\\
    \equallength(\vargsone, \vargstwo) \typearrow \True \terminateas \False\\\\
    i \in \listrange(\vargsone): \exprequal(\tenv, \vargsone[i], \vargstwo[i]) \typearrow \vb_i\\
    \vb \eqdef \bigwedge_{i \in \listrange(\vargsone)} \vb_i
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
    \inferrule[e\_concat]{
    \veone \eqname \EConcat(\vlone)\\
    \vetwo \eqname \EConcat(\vltwo)\\\\
    \equallength(\vlone, \vltwo) \typearrow \True \terminateas \False\\\\
    i \in \listrange(\vlone): \exprequal(\tenv, \vlone[i], \vltwo[i]) \typearrow \vb_i\\
    \vb \eqdef \bigwedge_{i \in \listrange(\vlone)} \vb_i
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
    \inferrule[e\_cond]{
    \veone \eqname \ECond(\veoneone, \veonetwo, \veonethree)\\
    \vetwo \eqname \ECond(\vetwoone, \vetwotwo, \vetwothree)\\\\
    \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
    \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo\\
    \exprequal(\tenv, \veonethree, \vetwothree) \typearrow \vbthree\\
    \vb \eqdef \vbone \land \vbtwo \land \vbthree
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_slice]{
  \veone \eqname \ESlice(\veoneone, \slicesone)\\
  \vetwo \eqname \ESlice(\vetwoone, \slicestwo)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getarray]{
  \veone \eqname \EGetArray(\veoneone, \veonetwo)\\
  \vetwo \eqname \EGetArray(\vetwoone, \vetwotwo)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
  \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getfield]{
  \veone \eqname \EGetField(\veoneone, \vfieldone)\\
  \vetwo \eqname \EGetField(\vetwoone, \vfieldtwo)\\\\
  \vbone \eqdef \vfieldone = \vfieldtwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getfields]{
  \veone \eqname \EGetFields(\veoneone, \vfieldsone)\\
  \vetwo \eqname \EGetFields(\vetwoone, \vfieldstwo)\\\\
  \vbone \eqdef \vfieldsone = \vfieldstwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_literal]{
  \veone \eqname \ELiteral(\vvone)\\
  \vetwo \eqname \ELiteral(\vvtwo)\\\\
  \literalequal(\vvone, \vvtwo) \typearrow \vb
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern1]{
  \astlabel(\veone) = \EPattern
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\and
\inferrule[e\_pattern2]{
  \astlabel(\vetwo) = \EPattern
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record1]{
  \astlabel(\veone) = \ERecord
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\and
\inferrule[e\_record2]{
  \astlabel(\vetwo) = \ERecord
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_tuple]{
  \veone \eqname \ETuple(\vlone)\\
  \vetwo \eqname \ETuple(\vltwo)\\
  \equallength(\vlone, \vltwo) \typearrow \True \terminateas \False\\\\
  i \in \listrange(\vlone): \exprequal(\tenv, \vlone[i], \vltwo[i]) \typearrow \vb_i\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vlone)} \vb_i
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_unop]{
    \veone \eqname \EUnop(\opone, \veoneone)\\
    \vetwo \eqname \EUnop(\optwo, \vetwoone)\\\\
    \exprequal(\veoneone, \vetwoone) \typearrow \vbone\\
    \vb \eqdef (\opone = \optwo) \land \vbone
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_unknown1]{
    \astlabel(\veone) = \EUnknown
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
  }
  \and
  \inferrule[e\_unknown2]{
    \astlabel(\vetwo) = \EUnknown
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_ctc]{
    \veone \eqname \EATC(\veoneone, \vtone)\\
    \vetwo \eqname \EATC(\vetwoone, \vttwo)\\
    \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
    \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo\\
    \vb \eqdef \vbone \land \vbtwo
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_var]{
    \veone \eqname \EVar(\nameone)\\
    \vetwo \eqname \EVar(\nametwo)\\\\
    \vb \eqdef \nameone = \nametwo
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\end{emptyformal}
%   | E_Pattern _, _ | E_Record _, _ -> assert false

\section{TypingRule.ExprEqualNorm}

The function
\[
  \exprequalnorm(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the expression $\veone$ is equivalent to the expression $\vetwo$ in environment $\tenv$
by attempting to transform both expressions to their \emph{normal form} representation
and, if successful, comparing the resulting normal forms for equality.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{all\_supported}):
  \begin{itemize}
    \item $\veone$ can be transformed into the intermediate representation $\irone$;
    \item $\vetwo$ can be transformed into the intermediate representation $\irtwo$;
    \item $\vb$ is the result of equating $\irone$ and $\irtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{unsupported1}):
  \begin{itemize}
    \item $\veone$ can not be transformed into an intermediate representation.
    \item $\vb$ is $\False$;
  \end{itemize}

  \item All of the following apply (\textsc{unsupported2}):
  \begin{itemize}
    \item $\vetwo$ can not be transformed into an intermediate representation.
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[all\_supported]{
    \toir(\veone) \typearrow \irone\\
    \toir(\vetwo) \typearrow \irtwo\\
    \vb \eqdef \irone = \irtwo
  }
  {
    \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \vb
  }
  \and
  \inferrule[unsupported1]{
    \toir(\veone) \not\typearrow \irone
  }
  {
    \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \False
  }
  \and
  \inferrule[unsupported2]{
    \toir(\vetwo) \not\typearrow \irtwo
  }
  {
    \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \False
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ToIR}
The function
\[
  \toir(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \partialto \overname{\exprir}{\vp}
\]
transforms a subset of ASL expressions into
an intermediate representation $\exprir$, which is essentially polynomials in reduced form.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{case\_success}):
  \begin{itemize}
    \item the expression $\ve$ can be transformed into the intermediate representation form as $\vp$;
    \item the result is $\vp$;
  \end{itemize}

  \item All of the following apply (\textsc{static\_eval\_success}):
  \begin{itemize}
    \item the expression $\ve$ cannot be transformed into the intermediate representation form as $\vp$;
    \item the expression $\ve$ can be statically evaluated to yield an integer value $\vv$;
    \item $\vp$ is the reduced polynomial representing the value $\vv$.
  \end{itemize}

  \item Neither case above holds, and $\vp$ is $\bot$
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
The meaning of each element of $\exprir$ can be interpreted as a mathematical formula,
which we define via the interpretation function $\alpha$.

\begin{definition}[Monomial]
  \emph{Monomials} are partial functions from variables to positive integers:
  $\monomials : \Prod(\identifier \partialto \{0, 1, \ldots\})$.
  %
  A monomial $\Prod(\vm)\in\monomials$ can be interpreted as follows:
  \[
    \alpha(\Prod(\vm)) \triangleq \prod_{\vx \in \dom(\vm)} \vx^{\vm(\vx)}
  \]
\end{definition}
For example, the monomial $\Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\})$ can be interpreted as the term $x^3 \cdot y \cdot z^2$.

The function
\[
  \mulmonomials(\overname{\monomials}{\vmone} \aslsep \overname{\monomials}{\vmtwo}) \rightarrow \overname{\monomials}{\vm}
\]
multiplies two monomials and returns a monomial
\begin{mathpar}
  \inferrule{
    \vmone \eqname \Prod(\vfone)\\
    \vmtwo \eqname \Prod(\vftwo)\\
    {
      \vf \eqdef \lambda \vx\in\identifier.\
      \left\{
      \begin{array}{ll}
        \vfone(\vx) & \text{if } \vx \in \dom(\vfone) \setminus \dom(\vftwo)\\
        \vfone(\vx) & \text{if } \vx \in \dom(\vftwo) \setminus \dom(\vfone)\\
        \vfone(\vx)+\vftwo(\vx) & \text{else } \vx \in \dom(\vfone) \cap \dom(\vftwo)\\
      \end{array}
      \right.
    }\\\\
    \vm \eqdef \Prod(\vf)
  }
  {
    \mulmonomials(\vmone, \vmtwo) \typearrow \vm
  }
\end{mathpar}
For example,
\[
  \begin{array}{ll}
  \mulmonomials( & \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\}),\\
                 & \Prod(\{\vx\mapsto 1, \vw\mapsto 2\}) ) =\\
                 & \Prod(\{\vx\mapsto 4, \vy\mapsto 1, \vz\mapsto2, \vw\mapsto2\})
  \end{array}
\]

\begin{definition}[Polynomial]
  \emph{Polynomials} are partial functions from monomials to integers:
  $\polynomials: \Sum(\monomials \partialto \Z)$.
  Intuitively, each monomial is mapped to its factor.
  A polynomial $\Sum(\vp)$ can be interpreted as follows:
  %
\[
  \alpha(\Sum(\vp)) \triangleq \sum_{\vm \in \dom(\vp)} \vp(\vm)\cdot\alpha(\vm)
\]
\end{definition}
For example, the polynomial
\[
    \begin{array}{rlcl}
      \Sum(\{ & \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\}) &\mapsto& -1,\\
              & \Prod(\{\vx\mapsto 2, \vy\mapsto 1\}) &\mapsto& 3\\
          \}) & & &
    \end{array}
\]
can be interpreted as
$-1\cdot x^3 \cdot y \cdot z^2 + 3 \cdot \vx^2\cdot \vy$.

We define the intermediate representation to be polynomials. That is, $\exprir \triangleq \polynomials$.

The function
\[
  \addpolynomials : \polynomials \times \polynomials \rightarrow \polynomials
\]
adds two polynomials.
\begin{mathpar}
  \inferrule{
    \vpone \eqname \Sum(\vfone)\\
    \vptwo \eqname \Sum(\vftwo)\\
    {
      \vf \eqdef \lambda \vm\in\monomials.\
      \left\{
      \begin{array}{ll}
        \vfone(\vm) & \text{if } \vm \in \dom(\vfone) \setminus \dom(\vftwo)\\
        \vfone(\vm) & \text{if } \vm \in \dom(\vftwo) \setminus \dom(\vfone)\\
        \vfone(\vm)+\vftwo(\vm) & \text{else } \vm \in \dom(\vfone) \cap \dom(\vftwo)\\
      \end{array}
      \right.
    }\\
    \vp \eqdef \Sum(\vf)
  }
  {
    \addpolynomials(\vpone, \vptwo) \typearrow \vp
  }
\end{mathpar}

The function
\[
  \mulpolynomials : \polynomials \times \polynomials \rightarrow \polynomials
\]
multiplies two polynomials.
\begin{mathpar}
  \inferrule{
    \vpone \eqname \Sum(\vfone)\\
    \vptwo \eqname \Sum(\vftwo)\\
    {
      \vps \eqdef \{ \Sum(\{\mulmonomials(\vmone, \vmtwo) \mapsto \vcone\times\vctwo\})
        \;|\; \vfone(\vmone)=\vcone, \vftwo(\vmtwo)=\vctwo\}
    }\\
    \vps \eqname \{ i=1..k: \vp[i] \}\\
    \vp \eqdef \addpolynomials(\addpolynomials(\vp[1], \vp[2]), \ldots, \vp[k]\ldots)\\
  }
  {
    \mulpolynomials(\vpone, \vptwo) \typearrow \vp
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[case\_success]{
    \toircase(\tenv, \ve) \typearrow \vp
  }
  {
    \toir(\tenv, \ve) \typearrow \vp
  }
  \and
  \inferrule[static\_eval\_success]{
    \toircase(\tenv, \ve) \not\typearrow \Ignore\\
    \staticeval(\tenv, \ve) \typearrow \vv\\
    \vp \eqdef \Sum( \{ \Prod(\emptyfunc)\mapsto \vv \} )
  }
  {
    \toir(\tenv, \ve) \typearrow \vp
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ToIRCase}

\begin{mathpar}
  \inferrule[literal\_int]{}
  {
    \toircase(\tenv, \ELiteral(\lint(\vi))) \typearrow \Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )
  }
  \and
  \inferrule[int\_constant]{
    \tododefine{lookup\_constant}(\tenv, \vs) = \ELiteral(\lint(\vi))
  }
  {
    \toircase(\tenv, \EVar(\vs)) \typearrow \Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )
  }
  \and
  \inferrule[int\_exact\_constraint]{
    \tododefine{type\_of}(\vs) = \vt\\
    \makeanonymous(\vt) = \TInt(\wellconstrained([\ConstraintExact(\ve)]))\\
    \toir(\ve) \typearrow \vp
  }
  {
    \toircase(\tenv, \EVar(\vs)) \typearrow \vp
  }
  \and
  \inferrule[int\_var]{
    \tododefine{type\_of}(\vs) = \vt\\
    \makeanonymous(\vt) = \TInt(\vc)\\
    \neg(\exists \ve \in \expr.\ \vc = \wellconstrained([\ConstraintExact(\ve)]))
  }
  {
    \toircase(\tenv, \EVar(\vs)) \typearrow \Sum( \{ \Prod(\{\vs\mapsto 1\})\mapsto 1 \} )
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[ebinop\_plus]{
    \toir(\tenv, \veone) \typearrow \irone\\
    \toir(\tenv, \vetwo) \typearrow \irtwo\\
    \vp \eqdef \addpolynomials(\irone, \irtwo)
  }
  {
    \toircase(\tenv, \EBinop(\PLUS, \veone, \vetwo)) \typearrow \vp
  }
  \and
  \inferrule[ebinop\_minus]{
    \toir(\tenv, \EBinop(\PLUS, \veone, \EBinop(\MINUS, \vetwo))) \typearrow \vp
  }
  {
    \toircase(\tenv, \EBinop(\MINUS, \veone, \vetwo)) \typearrow \vp
  }
  \and
  \inferrule[ebinop\_mul]{
    \toir(\tenv, \veone) \typearrow \irone\\
    \toir(\tenv, \vetwo) \typearrow \irtwo\\
    \vp \eqdef \mulpolynomials(\irone, \irtwo)
  }
  {
    \toircase(\tenv, \EBinop(\MUL, \veone, \vetwo)) \typearrow \vp
  }
  \and
  \inferrule[ebinop\_shl]{
    k \eqdef 2^{\vitwo}\\
    \toir(\tenv, \EBinop(\MUL, \veone, \ELiteral(\lint(k)))) \typearrow \vp
  }
  {
    \toircase(\tenv, \EBinop(\SHL, \veone, \ELiteral(\lint(\vitwo)))) \typearrow \vp
  }
  \and
  \inferrule[ebinop\_literals]{
    \binop(\op, \vlone, \vltwo) \typearrow k\\
    \vp \eqdef \Sum( \{ \Prod(\emptyfunc)\mapsto k \} )
  }
  {
    \toircase(\tenv, \EBinop(\op, \ELiteral(\lint(\vione)), \ELiteral(\lint(\vitwo)))) \typearrow \vp
  }
  \and
  \inferrule[eunop\_neg]{
    \toir(\tenv, \EBinop(\MUL, \ELiteral(\lint(-1)),\veone )) \typearrow \vp
  }
  {
    \toircase(\tenv, \EUnop(\NEG, \veone)) \typearrow \vp
  }
\end{mathpar}

% let rec to_ir env (e : expr) : ir_expr =
%     | E_Binop (SHL, e1, { desc = E_Literal (L_Int i2); _ }) ->
%         let ir1 = to_ir env e1 and f2 = Z.pow Z.one (Z.to_int i2) in
%         map_num
%           (fun (Sum monos) -> Sum (MMap.map (fun c -> Z.mul c f2) monos))
%           ir1
%     | E_Binop (op, { desc = E_Literal l1; _ }, { desc = E_Literal l2; _ }) ->
%         binop_values e op l1 l2 |> poly_of_val |> always
%     | E_Unop (NEG, e0) -> e0 |> to_ir env |> map_num poly_neg
%     | E_Cond (cond, e1, e2) ->
%         let Disjunction ctnts, Disjunction nctnts = to_cond env cond
%         and (Disjunction ir1) = to_ir env e1
%         and (Disjunction ir2) = to_ir env e2 in
%         let restrict ctnts (ctnts', p) = (ctnts_and ctnts ctnts', p) in
%         let ir1' = ASTUtils.list_cross restrict ctnts ir1
%         and ir2' = ASTUtils.list_cross restrict nctnts ir2 in
%         Disjunction (ir1' @ ir2')
%     | _ -> (
%         let v =
%           try static_eval env e
%           with Error.ASLException { desc = UnsupportedExpr _; _ } ->
%             raise NotYetImplemented
%         in
%         match v with
%         | L_Int i -> poly_of_z i |> always
%         | _ -> raise NotYetImplemented)

\section{TypingRule.TypeEqual}
\hypertarget{def-typeequal}{}
The function
\[
  \typeequal(\overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo}) \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the type $\vtone$ is equivalent to the type $\vttwo$ in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[different\_labels]{
    \astlabel(\vtone) \neq \astlabel(\vttwo)
  }
  {
    \typeequal(\tenv, \vtone, \vttwo) \typearrow \False
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[TBool]{}
  {
    \typeequal(\tenv, \TBool, \TBool) \typearrow \True
  }
  \and
  \inferrule[TReal]{}
  {
    \typeequal(\tenv, \TReal, \TReal) \typearrow \True
  }
  \and
  \inferrule[TString]{}
  {
    \typeequal(\tenv, \TString, \TString) \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tint\_unconstrained]{}
  {
    \typeequal(\tenv, \TInt(\unconstrained), \TInt(\unconstrained)) \typearrow \True
  }
  \and
  \inferrule[tint\_underconstrained]{
    \vb \eqdef \vione = \vitwo
  }
  {
    \typeequal(\tenv, \TInt(\underconstrained(\vione, \Ignore)), \TInt(\underconstrained(\vitwo, \Ignore))) \typearrow \vb
  }
  \and
  \inferrule[tint\_wellonstrained]{
    \constraintsequal(\tenv, \vcone, \vctwo) \typearrow \vb
  }
  {
    \typeequal(\tenv, \TInt(\wellconstrained(\vcone)), \TInt(\wellconstrained(\vctwo))) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tbits]{
    \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vbone\\
    \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \vbtwo\\
    \vb \eqdef \vbone \land \vbtwo
  }
  {
    \typeequal(\tenv, \TBits(\vwone, \bfone), \TBits(\vwtwo, \bftwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tarray]{
    \exprequal(\tenv, \vlone, \vltwo) \typearrow \vbone\\
    \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo\\
    \vb \eqdef \vbone \land \vbtwo
  }
  {
    \typeequal(\tenv, \TArray(\vlone, \vtone), \TArray(\vltwo, \vttwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tnamed]{
    \vb \eqdef \vsone = \vstwo
  }
  {
    \typeequal(\tenv, \TNamed(\vsone), \TArray(\vstwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tenum]{
    \vb \eqdef \vlone = \vltwo
  }
  {
    \typeequal(\tenv, \TEnum(\vlone), \TEnum(\vltwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[trecord]{
    \equal(\dom(\vfone), \dom(\vftwo)) \equalarrow \True \terminateas \False\\\\
    \vf \in \dom(\vfone): \typeequal(\tenv, \vfone(\vf), \vftwo(\vf)) \typearrow \vb_\vf\\
    \vb \eqdef \bigwedge_{\vf \in \dom(\vfone)} \vb_\vf
  }
  {
    \typeequal(\tenv, \TRecord(\vfone), \TRecord(\vftwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[texception]{
    \equal(\dom(\vfone), \dom(\vftwo)) \equalarrow \True \terminateas \False\\\\
    \vf \in \dom(\vfone): \typeequal(\tenv, \vfone(\vf), \vftwo(\vf)) \typearrow \vb_\vf\\
    \vb \eqdef \bigwedge_{\vf \in \dom(\vfone)} \vb_\vf
  }
  {
    \typeequal(\tenv, \TException(\vfone), \TException(\vftwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[ttuple]{
    \equallength(\vtsone, \vtstwo) \typearrow \True \terminateas \False\\
    i \in \listrange(\vtsone): \typeequal(\tenv, \vtsone[i], \vtstwo[i]) \typearrow \vb_i\\
    \vb \eqdef \bigwedge_{i \in \listrange(\vtsone)} \vb_i
  }
  {
    \typeequal(\tenv, \TTuple(\vtsone), \TTuple(\vtstwo)) \typearrow \vb
  }
\end{mathpar}
% | T_Int (UnderConstrained (i1, _)), T_Int (UnderConstrained (i2, _)) ->
%     i1 == i2
\end{emptyformal}

\section{TypingRule.BitwidthEqual}
\hypertarget{def-bitwidthequal}{}
The function
\[
  \bitwidthequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\vwone} \aslsep \overname{\expr}{\vwtwo})
  \rightarrow\overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the bitwidth expression $\vwone$ is equivalent to the bitwidth expression $\vwtwo$
in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \exprequal(\tenv, \vwone, \vwtwo) \typearrow \vb
  }
  {
    \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.BitFieldsEqual}
\hypertarget{def-bitfieldequal}{}
The function
\[
  \bitfieldsequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield^*}{\bfone} \aslsep \overname{\bitfield^*}{\bftwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the list of bitfields $\bfone$ is equivalent to the list of bitfields $\bftwo$
in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \equallength(\bfone, \bftwo) \typearrow \True \terminateas \False\\\\
      i\in\listrange(\bfone): \bitfieldequal(\tenv, \bfone[i], \bftwo[i]) \typearrow \vb_i\\\\
      \vb \eqdef \bigwedge_{i\in\listrange(\bfone)} \vb_i
    }
    {
      \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.BitFieldEqual}

The function
\[
  \bitfieldequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield}{\bfone} \aslsep \overname{\bitfield}{\bftwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the bitfield $\bfone$ is equivalent to the bitfield $\bftwo$ in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
    \inferrule[different\_labels]{
      \astlabel(\bfone) \neq \astlabel(\bftwo)
    }
    {
      \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \False
    }
    \and
    \inferrule[bitfield\_simple]{
      \bfone \eqname \BitFieldSimple(\nameone, \slicesone)\\
      \bftwo \eqname \BitFieldSimple(\nametwo, \slicestwo)\\\\
      \equal(\nameone, \nametwo) \equalarrow \True \terminateas \False\\\\
      \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vb
    }
    {
      \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
    }
    \and
    \inferrule[bitfield\_nested]{
      \bfone \eqname \BitFieldNested(\nameone, \slicesone, \bfoneone)\\
      \bftwo \eqname \BitFieldNested(\nametwo, \slicestwo, \bftwoone)\\
      \equal(\nameone, \nametwo) \equalarrow \True \terminateas \False\\\\
      \slicesequal(\tenv, \slicesone, \slicestwo) \True \terminateas \False\\\\
      \bitfieldsequal(\tenv, \bfoneone, \bftwoone) \typearrow \vb
    }
    {
      \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}
% What about BitField_Type?

\section{TypingRule.ConstraintsEqual}
\hypertarget{def-constraintsequal}{}
The function
\[
  \constraintsequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraints}{\csone} \aslsep \overname{\intconstraints}{\cstwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the constraint list $\csone$ is equivalent to the constraint list $\cstwo$ in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \equallength(\csone, \cstwo) \typearrow \True \terminateas \False\\
    i\in\listrange(\csone): \constraintequal(\tenv, \csone[i], \cstwo[i]) \typearrow \vb_i\\
    \vb \eqdef \bigwedge_{i\in\listrange(\csone)} \vb_i
  }
  {
    \constraintsequal(\tenv, \csone, \cstwo) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ConstraintEqual}
\hypertarget{def-constraintequal}{}
The function
\[
  \constraintequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vstwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the constraint $\vcone$ is equivalent to the constraint $\vctwo$ in environment $\tenv$.

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule[different\_labels]{
      \astlabel(\vcone) \neq \astlabel(\vctwo)
    }
    {
      \constraintequal(\tenv, \vcone, \vctwo) \typearrow \False
    }
    \and
    \inferrule[constraint\_exact]{
      \vcone \eqname \ConstraintExact(\veone)\\
      \vctwo \eqname \ConstraintExact(\vetwo)\\\\
      \exprequal(\tenv, \veone, \vetwo) \typearrow \vb
    }
    {
      \constraintequal(\tenv, \vcone, \vctwo) \typearrow \vb
    }
    \and
    \inferrule[constraint\_range]{
      \bfone \eqname \ConstraintRange(\veoneone, \veonetwo)\\
      \bftwo \eqname \ConstraintRange(\vetwoone, \vetwotwo)\\
      \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
      \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo\\
      \vb \eqdef \vbone \land \vbtwo
    }
    {
      \constraintequal(\tenv, \bfone, \bftwo) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.SlicesEqual}
\hypertarget{def-slicesequal}{}
The function
\[
  \slicesequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slicesone} \aslsep \overname{\slice^*}{\slicestwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the list of slices $\slicesone$ is equivalent to the list of slices $\slicestwo$
in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \equallength(\slicesone, \slicestwo) \typearrow \True \terminateas \False\\
      i\in\listrange(\slicesone): \sliceequal(\tenv, \slicesone[i], \slicestwo[i]) \typearrow \vb_i\\
      \vb \eqdef \bigwedge_{i\in\listrange(\slicesone)} \vb_i
    }
    {
      \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.SliceEqual}
\hypertarget{def-sliceequal}{}
The function
\[
  \sliceequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\sliceone} \aslsep \overname{\slice}{\slicetwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the slice $\sliceone$ is equivalent to the slice $\slicetwo$
in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
    \inferrule[different\_label]{
      \astlabel(\sliceone) \neq \astlabel(\slicetwo)
    }
    {
      \slicesequal(\tenv, \sliceone, \slicetwo) \typearrow \False
    }
    \and
    \inferrule[slice\_single]{
      \exprequal(\tenv, \veone, \vetwo) \typearrow \vb
    }
    {
      \slicesequal(\tenv, \SliceSingle(\veone), \SliceSingle(\vetwo)) \typearrow \vb
    }
    \and
    \inferrule[slice\_range]{
      \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
      \exprequal(\tenv, \vetwoone, \vetwotwo) \typearrow \vbtwo\\
      \vb \eqdef \vbone \land \vbtwo
    }
    {
      \slicesequal(\tenv, \SliceRange(\veoneone, \veonetwo), \SliceRange(\vetwoone, \vetwotwo)) \typearrow \vb
    }
    \and
    \inferrule[slice\_length]{
      \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
      \exprequal(\tenv, \vetwoone, \vetwotwo) \typearrow \vbtwo\\
      \vb \eqdef \vbone \land \vbtwo
    }
    {
      \slicesequal(\tenv, \SliceLength(\veoneone, \veonetwo), \SliceLength(\vetwoone, \vetwotwo)) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.LiteralEqual}
\hypertarget{def-literalequal}{}
The function
\[
  \literalequal(\overname{\literal}{\vvone} \aslsep \overname{\literal}{\vvtwo}) \rightarrow \overname{\{\True, \False\}}{\vb}
\]
tests whether literal $\vvone$ is $\vvtwo$ by equating them.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vb \eqdef \vvone= \vvtwo
  }
  {
    \literalequal(\vvone, \vvtwo) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Utility Relations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Checked Transitions}
\hypertarget{def-checktrans}{}
We define the following rules to allow us asserting that a condition holds,
returning a type error otherwise:
\begin{mathpar}
  \inferrule[check\_trans\_true]{}{ \checktrans{\True} \typearrow\True }
  \and
  \inferrule[check\_trans\_false]{}{ \checktrans{\False} \typearrow\TypeErrorVal{CheckFailed} }
\end{mathpar}

\hypertarget{def-checknoduplicates}{}
\section{TypingRule.CheckNoDuplicates \label{sec:TypingRule.CheckNoDuplicates}}
The function
\[
  \checknoduplicates(\overname{\identifier^*}{\id_{1..k}}) \aslto \True \cup \TTypeError
\]
checks whether a non-empty list of identifiers contains a duplicate identifier. If it does not, the result
is $\True$ and otherwise the result is a type error.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item the set containing all identifiers in the list has the same cardinality as the length of the list;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item there exist two different positions in the list where the identifier is the same;
    \item the result is a type error indicating the existence of a duplicate identifier.
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\begin{mathpar}
  \inferrule[okay]{
    |\{\id_{1..k}\}| = k
  }
  {
    \checknoduplicates(\id_{1..k}) \typearrow \True
  }
\and
\inferrule[error]{
  i,j \in 1..k\\
  i \neq j\\
  \id_i = \id_j
}
{
  \checknoduplicates(\id_{1..k}) \typearrow \TypeErrorVal{DuplicateIdentifier}
}
\end{mathpar}
\end{emptyformal}

\hypertarget{def-declaredtype}{}
\section{TypingRule.DeclaredType \label{sec:TypingRule.DeclaredType}}

The function
\[
  \declaredtype(\overname{\staticenvs}{\tenv} \aslsep \overname{\identifier}{\id}) \aslto \overname{\ty}{\vt} \cup \TTypeError
\]
retrieves the type associated with the identifier $\id$ in the static environment $\tenv$.
If the identifier is not associated with a declared type, a type error is returned.

\subsection{Prose}

\subsection{Formally}
\begin{mathpar}
  \inferrule[exists]{
    G^\tenv.\declaredtypes(\id) = \vt
  }
  {
    \declaredtype(\tenv, \id) \typearrow \vt
  }
  \and
  \inferrule[type\_not\_declared]{
    G^\tenv.\declaredtypes(\id) = \bot
  }
  {
    \declaredtype(\tenv, \id) \typearrow \TypeErrorVal{TypeNotDeclared}
  }
\end{mathpar}

\section{TypingRule.BitFieldsIncluded}
\hypertarget{def-bitfieldsincluded}{}

The predicate
\[
  \bitfieldsincluded(\overname{\staticenvs}{\tenv}, \overname{\bitfield^*}{\bfsone} \aslsep \overname{\bitfield^*}{\bfstwo})
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the set of bit fields $\bfsone$ is included in the set of bit fields $\bfstwo$ in environment $\tenv$,
returning a type error, if one is detected.

\hypertarget{def-typeofarraylength}{}
\section{TypingRule.TypeOfArrayLength \label{sec:TypingRule.TypeOfArrayLength}}
The function
\[
  \typeofarraylength(\overname{\staticenvs}{\tenv} \aslsep \overname{\arrayindex}{\size}) \aslto
  \overname{\ty}{\vt}
\]
returns the type for the array index $\size$ in the static environment $\tenv$.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{enum}):
  \begin{itemize}
    \item $\size$ is an enumeration index over the enumeration $\vs$, that is, $\ArrayLengthEnum(\vs, \Ignore)$;
    \item $\vt$ is the named type for $\vs$, that is, $\TNamed(\vs)$.
  \end{itemize}

  \item All of the following apply (\textsc{expr}):
  \begin{itemize}
    \item $\size$ is an expression index for $\ve$, that is, $\ArrayLengthExpr(\ve)$;
    \item symbolically reducing the expression corresponding to $\ve - 1$ via \tododefine{reduce\_expr} in $\tenv$
    yields the expression $\vm$;
    \item $\vc$ is the range constraint for $0..\vm$, that is, $\ConstraintRange(\eliteral{0}, \vm)$;
    \item $\vt$ is the well-constrained integer with the single constraint $\vc$.
  \end{itemize}
\end{itemize}

\CodeSubsection{\TypeOfArrayLengthBegin}{\TypeOfArrayLengthEnd}{../types.ml}
\subsection{Formally}
\begin{mathpar}
\inferrule[enum]{}
{
  \typeofarraylength(\tenv, \ArrayLengthEnum(\vs, \Ignore)) \typearrow \TNamed(\vs)
}
\and
\inferrule[expr]{
  \tododefine{reduce\_expr}(\EBinop(\MINUS, \ve, \eliteral{1})) \typearrow \vm\\
  \vc \eqdef \ConstraintRange(\eliteral{0}, \vm)
}
{
  \typeofarraylength(\tenv, \ArrayLengthExpr(\ve)) \typearrow \TInt(\wellconstrained([\vc]))
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{ASL}

\end{document}
