\chapter{Expressions\label{chap:Expressions}}

Expressions calculate values.
Expressions can have side effects and can raise exceptions and, therefore, there are constraints on the evaluation
order and on the side-effects/exceptions to avoid surprising or unpredictable behavior (see \secref{PriorityAndAssociativity}).

Expressions are grammatically derived from $\Nexpr$ and represented as ASTs by $\expr$.
We will often refer to expressions defined in this chapter as \rhsexpressions\ to distinguish them
from \assignableexpressions, which are defined in \chapref{AssignableExpressions}.

\hypertarget{build-expr}{}
The function
\[
  \buildexpr(\overname{\parsenode{\Nexpr}}{\vparsednode}) \;\aslto\; \overname{\expr}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms an expression parse node $\vparsednode$ into an expression AST node $\vastnode$.
\ProseOtherwiseBuildError

All expressions have a unique type (which can be a tuple type).
\hypertarget{def-annotateexpr}{}
The function
\[
  \annotateexpr{\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}}
  \aslto (\overname{\ty}{\vt} \times \overname{\expr}{\newe} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
specifies how to annotate an expression $\ve$ in
an environment \tenv.  The result of annotating the expression
$\ve$ in \tenv\ is the tuple $(\vt, \newe, \vses)$, where $\vt$ is the type inferred
for $\ve$,
$\newe$ is the \typedast\ for $\ve$, also known as the \emph{annotated expression}, and
$\vses$ is the \sideeffectsetterm\ inferred for $\ve$.
\ProseOtherwiseTypeError

The annotation rewrites the input expression in the following case, making the annotation of statements simpler:
variables with constant values are substituted by their constant values.

The relation
\hypertarget{def-evalexpr}{}
\[
  \evalexpr{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
            \Normal((\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg}) \aslsep \overname{\envs}{\newenv}) \cup
            \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the expression $\ve$ in an environment $\env$ and one of the following applies:
\begin{itemize}
  \item the evaluation terminates normally, returning a \nativevalue\  $\vv$, a concurrent execution graph $\vg$,
  and a modified environment $\newenv$;
  \item the evaluation terminates abnormally.
\end{itemize}

\section{Evaluation Order}
It is an error for an expression’s meaning to rely on evaluation order except that conditional expressions, and uses
of the boolean operators $\Tband$, $\Tbor$, $\Timpl$, are guaranteed to evaluate from left to right.
\lrmcomment{\identr{XKGC}}

An implementation could enforce this rule by performing a global analysis of all functions to determine whether a
function can throw an exception and the set of global variables read and written by a function.
\lrmcomment{\identi{YMRT}}

For any function call $F(e_1,\ldots,e_m)$, tuple $(e_1,\ldots, e_m)$, or operation $e_1 \op e_2$
(with the exception of $\Tband$, $\Tbor$, and$\Timpl$),
it is an error if the subexpressions conflict with each other by:
\begin{itemize}
  \item both writing to the same variable.
  \item one writing to a variable and the other reading from that same variable.
  \item one writing to a variable and the other throwing an exception.
  \item both throwing exceptions.
\end{itemize}
\lrmcomment{\identi{QJTN}}

These conditions are sufficient but not necessary to ensure that evaluation order does not affect the result of an
expression, including any side-effects.
\lrmcomment{\identi{GFZT}}

Conditional expressions and the operations $\Tband$, $\Tbor$, and$\Timpl$ have short-circuit evaluation.
\lrmcomment{\identi{QRXP}}

We now define the syntax, abstract syntax, typing, and semantics of the following kinds of expressions:
\begin{itemize}
  \item Literal expressions (see \secref{LiteralExpressions})
  \item Variable expressions (see \secref{VariablExpressions})
  \item Binary expressions (see \secref{BinaryExpressions})
  \item Unary expressions (see \secref{UnaryExpressions})
  \item Conditional expressions (see \secref{ConditionalExpressions})
  \item Call expressions (see \secref{CallExpressions})
  \item Slicing expressions (see \secref{SlicingExpressions})
  \item Array access expressions (see \secref{ArrayAccessExpressions})
  \item Field reading expressions (see \secref{FieldReadingExpressions})
  \item Multi-field reading expressions (see \secref{MultiFieldReadingExpressions})
  \item Asserting type conversion expressions (see \secref{AssertingTypeConversionExpressions})
  \item Pattern matching expressions (see \secref{PatternMatchingExpressions})
  \item Arbitrary value expressions (see \secref{ArbitraryValueExpressions})
  \item Structured type construction expressions (see \secref{StructuredTypeConstructionExpressions})
  \item Tuple expressions (see \secref{TupleExpressions})
  \item Parenthesized expressions (see \secref{ParenthesizedExpressions})
  \item Array construction expressions (see \secref{ArrayConstructionExpressions})
\end{itemize}

Finally, we define side-effect-free expressions (see \secref{SideEffectFreeExpressions})
and define how to evaluate a list of expressions (see \secref{ExprList}).

\section{Literal Expressions\label{sec:LiteralExpressions}}
A literal expression represents a literal as an expression.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nvalue &\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ELiteral(\literal) &
\end{flalign*}

\subsubsection{ASTRule.ELit\label{sec:ASTRule.ELit}}
\begin{mathpar}
\inferrule{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Nvalue})}{\vparsednode}) \astarrow
  \overname{\ELiteral(\astof{\vvalue})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.ELit\label{sec:TypingRule.ELit}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ is the literal expression $\vv$;
\item $\vt$ is the type of the literal $\vv$;
\item define $\newe$ as $\ve$;
\item define $\vses$ as the empty set.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateliteral{\tenv, \vv} \typearrow \vt
}{
  \annotateexpr{\tenv, \overname{\ELiteral(\vv)}{\ve}} \typearrow (\vt, \overname{\ELiteral(\vv)}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\ELitBegin}{\ELitEnd}{../Typing.ml}

\subsection{Semantics}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.Lit.asl}
each of the expressions \texttt{3} evaluates to the \nativevalue\  $\nvint(3)$.

\subsubsection{SemanticsRule.ELit \label{sec:SemanticsRule.ELit}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ is the literal expression for $\vl$, that is, $\ELiteral(\vl)$
\item $\vv$ is the \nativevalue\ corresponding to $\vl$;
\item $\vg$ is the empty graph, as literals do not yield any Read and Write Effects;
\item $\newenv$ is $\env$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \evalexpr{\env, \overname{\ELiteral(\vl)}{\ve}} \evalarrow \Normal((\overname{\nvliteral{\vl}}{\vv},\overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalELitBegin}{\EvalELitEnd}{../Interpreter.ml}

\section{Variable Expressions\label{sec:VariablExpressions}}
A variable expression represents consists of an identifier.
The identifier stands for either a storage element or the name of a getter with no arguments.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EVar(\overtext{\identifier}{variable name}) &
\end{flalign*}

\subsubsection{ASTRule.EVAR}
\begin{mathpar}
  \inferrule{}{
  \buildexpr(\overname{\Nexpr(\Tidentifier(\id))}{\vparsednode}) \astarrow
  \overname{\EVar(\id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.EVar \label{sec:TypingRule.EVar}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{local\_constant}):
    \begin{itemize}
    \item $\vx$ is bound to the type $\vt$ and local declaration keyword $\LDKConstant$
          via the $\localstoragetypes$ map of the local environment component of $\tenv$;
    \item $\vx$ is bound to the literal $\vv$ via the $\constantvalues$ map of the local environment of $\tenv$;
    \item define $\newe$ as the literal expression for $\vv$, that is $\eliteral{\vv}$;
    \item define $\vses$ as the empty set.
    \end{itemize}

    \item All of the following apply (\textsc{local\_non\_constant}):
    \begin{itemize}
    \item $\vx$ is bound to the type $\vt$ and local declaration keyword $k$
          via the \\
          $\localstoragetypes$ map of the local environment component of $\tenv$;
    \item either $k$ is different from $\LDKConstant$ or
          $\vx$ is not bound in the \\
          $\constantvalues$ map of the local environment of $\tenv$;
    \item define $\newe$ as $\ve$;
    \item define $\vses$ as the singleton set for the \ReadLocalTerm\ for $\vx$ the \timeframeterm\ of
          $k$ ($\timeframeofldk$) and the immutability status of $k$ ($\ldkisimmutable$).
    \end{itemize}

    \item All of the following apply (\textsc{global\_constant}):
    \begin{itemize}
    \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
    \item $\vx$ is bound to $(\tty, \GDKConstant)$ via the $\globalstoragetypes$ map of the global component of $\tenv$;
    \item $\vx$ is bound to $\vv$ via the $\constantvalues$ map of the global component of $\tenv$;
    \item define $newe$ as the literal expression for $\vv$;
    \item define $\vses$ as the empty set.
    \end{itemize}

    \item All of the following apply (\textsc{global\_non\_constant}):
    \begin{itemize}
      \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
      \item $\vx$ is bound to $(\tty, k)$ via the $\globalstoragetypes$ map of the global component of $\tenv$;
      \item either $\vx$ is not bound in the $\constantvalues$ map of the global component of $\tenv$ or $k$ is not $\GDKConstant$;
      \item define $newe$ as $\ve$;
      \item define $\vses$ as the singleton set for the \ReadGlobalTerm\ for $\vx$ the \timeframeterm\ of
            $k$ ($\timeframeofgdk$) and the immutability status of $k$ ($\gdkisimmutable$).
    \end{itemize}

    \item All of the following apply (\textsc{error\_undefined}):
    \begin{itemize}
      \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
      \item $\vx$ is not bound via the $\globalstoragetypes$ map of the local component of $\tenv$;
      \item the result is a type error indicating that $\vx$ is an undefined identifier ($\UndefinedIdentifier$).
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[local\_constant]{
  L^\tenv.\localstoragetypes(\vx) = (\vt, \LDKConstant)\\
  L^\tenv.\constantvalues(\vx) = \vv
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\vt, \overname{\eliteral{\vv}}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[local\_non\_constant]{
  L^\tenv.\localstoragetypes(\vx) =  (\vt, k) \\
  L^\tenv.\constantvalues(\vx) = \bot \lor k \neq \LDKConstant\\
  \vses \eqdef \{\ \ReadLocal(\vx, \timeframeofldk(k), \ldkisimmutable(k))\  \}
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\vt, \overname{\EVar(\vx)}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[global\_constant]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \vv
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\tty, \overname{\eliteral{\vv}}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global\_non\_constant]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, k)\\
  G^\tenv.\constantvalues(\vx) = \bot \lor k \neq \GDKConstant\\
  \vses \eqdef \{\ \ReadGlobal(\vx, \timeframeofgdk(k), \gdkisimmutable(k))\  \}
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\tty, \overname{\EVar(\vx)}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[error\_undefined]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = \bot
}{
  \annotateexpr{\tenv,\overname{\EVar(\vx)}{\ve}} \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\subsubsection{Comments}
Our type system does not currently address assignments of non-constant expressions (for example,
function calls) to global constant variables.
\CodeSubsection{\EUndefIdentBegin}{\EUndefIdentEnd}{../Typing.ml}

\subsection{Semantics}
\subsubsection{SemanticsRule.EVar\label{sec:SemanticsRule.EVar}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a variable expression, that is, $\EVar(\vx)$;
  \item view $\env$ as an environment where $\denv$ is the dynamic environment;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{local}):
    \begin{itemize}
      \item $\vx$ is bound locally in $\env$;
      \item $\vv$ is the value of $\vx$ in the local component of $\env$;
    \end{itemize}

    \item All of the following apply (\textsc{global}):
    \begin{itemize}
      \item $\vx$ is bound in the storage map of $\denv$;
      \item $\vv$ is the value of $\vx$ in the global component of $\env$;
    \end{itemize}
  \end{itemize}
  \item $\newenv$ is $\env$;
  \item $\vg$ is the graph containing a single Read Effect for $\vx$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[local]{
  \env \eqname (\Ignore, \denv)\\
  \vx \in \dom(L^\denv)
}{
  \evalexpr{\env, \EVar(\vx)} \evalarrow \Normal((\overname{L^\denv(\vx)}{\vv}, \overname{\ReadEffect(\vx)}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  \env \eqname (\Ignore, \denv)\\
  \vx \in \dom(G^\denv.\storage)
}{
  \evalexpr{\env, \EVar(\vx)} \evalarrow \Normal((\overname{G^\denv.\storage(\vx)}{\vv}, \overname{\ReadEffect(\vx)}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalEVarBegin}{\EvalEVarEnd}{../Interpreter.ml}

\subsubsection{Comments}
When there exists a global variable $\vx$, the type system
forbids having $\vx$ as a local variable.
This is enforced by \nameref{sec:TypingRule.LDVar} in the Chapter ``Typing of Local Declarations'',
and
\nameref{sec:TypingRule.DeclareGlobalStorage} and \nameref{sec:TypingRule.DeclareOneFunc},
both in the Chapter ``Typing of Global Declarations''.

\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.ELocalVar.asl}
the evaluation of \texttt{x} within \texttt{assert x == 3;} uses SemanticsRule.EVar.LOCAL.

\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.EGlobalVar.asl}
the evaluation of~\texttt{global\_x} within~\texttt{assert global\_x == 3;}
uses the rule \\ SemanticsRule.EVar.GLOBAL.

\section{Binary Expressions\label{sec:BinaryExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Nbinop \parsesep \Nexpr &\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EBinop(\binop, \expr, \expr) &
\end{flalign*}

\subsubsection{ASTRule.Binop}
The following rule constructs a binary expression AST
when a property on \emph{associative operators} holds (see \nameref{sec:ASTRule.CheckNotSamePrec}).

\begin{mathpar}
  \inferrule{
    \buildexpr(\veone) \astarrow \astversion{\veone} \OrBuildError\\\\
    \buildexpr(\vetwo) \astarrow \astversion{\vetwo} \OrBuildError\\\\
    \checknotsameprec(\astof{\vbinop}, \astversion{\veone}) \astarrow \True \OrBuildError\\\\
    \checknotsameprec(\astof{\vbinop}, \astversion{\vetwo}) \astarrow \True \OrBuildError
  }{
    {
      \begin{array}{r}
  \buildexpr(\overname{\Nexpr(\namednode{\veone}{\Nexpr}, \punnode{\Nbinop}, \namednode{\vetwo}{\Nexpr})}{\vparsednode}) \astarrow\\
  \overname{\EBinop(\astversion{\veone}, \astof{\vbinop}, \astversion{\vetwo})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\subsubsection{ASTRule.CheckNotSamePrec\label{sec:ASTRule.CheckNotSamePrec}}
The set of \emph{associative binary operators} consists of the following:
$\BOR$,
$\BAND$,
$\IMPL$,
$\BEQ$,
$\EQOP$,
$\NEQ$,
$\PLUS$,
$\MINUS$,
$\OR$,
$\XOR$,
$\AND$,
$\MUL$,
$\DIV$,
$\DIVRM$,
$\RDIV$,
$\MOD$,
$\SHL$,
$\SHR$,
$\POW$.

\hypertarget{build-binopprec}{}
We define the helper function
\[
  \binopprec(\overname{\binop}{\op}) \aslto \N
\]
which assigns a precedence level to an associative binary operator $\op$,
as defined below:
\begin{mathpar}
\inferrule{}{
  {
  \binopprec(\op) \astarrow
  \begin{cases}
    5 & \text{if }\op = \POW\\
    4 & \text{if }\op \in \{\MUL, \DIV, \DIVRM, \RDIV, \MOD, \SHL, \SHR\}\\
    3 & \text{if }\op \in \{\PLUS, \MINUS, \OR, \XOR, \AND\}\\
    2 & \text{if }\op \in \{\EQOP, \NEQ\}\\
    1 & \text{if }\op \in \{\BOR, \BAND, \IMPL, \BEQ \}\\
    0 & \text{else}
  \end{cases}
  }
}
\end{mathpar}

\hypertarget{build-checknotsameprec}{}
The helper function
\[
\checknotsameprec(\overname{\binop}{\op} \aslsep \overname{\expr}{\ve})
\aslto \{\True\} \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
checks whether the expression AST node $\ve$ is a binary operator of the same
\emph{precedence} as that of the binary operator $\op$. If so, it is considered
an error. Surrounding $\ve$ by parenthesis fixes the error.

For example, \texttt{a + b + c} is considered legal, since the same binary operator (\texttt{+})
is used, whereas \texttt{a + b - c} is considered illegal, since $\PLUS$ and $\MINUS$ have the
same precedence ($3$). To fix this, we can surround one of the subexpressions with parenthesis,
for example: \texttt{(a + b) - c}.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{not\_binop}):
  \begin{itemize}
    \item $\ve$ is not a binary operation expression;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{binop}):
  \begin{itemize}
    \item $\ve$ is a binary operation expression for the operator $\opp$;
    \item checking whether $\op$ is different from $\opp$ implies that $\op$ and $\opp$ have different precedence levels
          yields $\True$\ProseTerminateAs{\BinopPrecedence}.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[not\_binop]{
  \astlabel(\ve) \neq \EBinop
}{
  \checknotsameprec(\op, \ve) \astarrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[binop]{
  \checktrans{\op \neq \opp \Longrightarrow \binopprec(\op) \neq \binopprec(\opp)}{\BinopPrecedence} \checktransarrow \True \OrBuildError
}{
  \checknotsameprec(\op, \overname{\EBinop(\opp, \Ignore, \Ignore)}{\ve}) \astarrow \True
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.Binop\label{sec:TypingRule.Binop}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a binary operation $\op$ over two expressions $\veone$ and $\vetwo$, that is, \\ $\EBinop(\op, \veone, \vetwo)$;
  \item \Proseannotateexpr{$\tenv$}{$\veone$}{\\ $(\vtone, \veonep, \vsesone)$\ProseOrTypeError};
  \item \Proseannotateexpr{$\tenv$}{$\vetwo$}{\\ $(\vttwo, \vetwop, \vsestwo)$\ProseOrTypeError};
  \item \Proseapplybinoptypes{$\tenv$}{\op}{\vtone}{\vttwo}{$\vt$\ProseOrTypeError};
  \item define $\newe$ as the binary expression $\op$ over $\veonep$ and $\vetwop$;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following applies (\textsc{ordered}):
    \begin{itemize}
      \item $\op$ is one of $\BAND$, $\BOR$, or $\IMPL$;
      \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
    \end{itemize}

    \item All of the following applies (\textsc{unordered}):
    \begin{itemize}
      \item $\op$ is not one of $\BAND$, $\BOR$, or $\IMPL$;
      \item \Prosenonconflictingunion{consisting of $\vsesone$ and $\vsestwo$}{$\vses$}.
    \end{itemize}
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[ordered]{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veonep, \vsesone) \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwop, \vsestwo) \OrTypeError\\\\
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError\\\\
  \op \in \{\BAND, \BOR, \IMPL\}\\\\
  \commonprefixline\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateexpr{\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}} \typearrow (\vt, \overname{\EBinop(\op, \veone', \vetwo')}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[unordered]{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veonep, \vsesone) \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwop, \vsestwo) \OrTypeError\\\\
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError\\\\
  \op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \commonprefixline\\\\
  \nonconflictingunion([\vsesone, \vsestwo]) \typearrow \vses \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}} \typearrow (\vt, \overname{\EBinop(\op, \veone', \vetwo')}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\BinopBegin}{\BinopEnd}{../Typing.ml}

\subsection{Semantics}
\subsubsection{SemanticsRule.BinopAnd \label{sec:SemanticsRule.BinopAnd}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a conjunction over two expressions,
      $\EBinop(\BAND, \veone, \vetwo)$;
\item $C$ is the result of the evaluation of the expression
      \texttt{if e1 then e2 else false} (see \secref{SemanticsRule.ECond}).
\end{itemize}

\subsubsection{Example}
\ASLExample{\semanticstests/SemanticsRule.EBinopAndFalse.asl}
the expression \texttt{FALSE \&\& fail()} evaluates to the value \texttt{FALSE}. Notice that the function \texttt{fail} is never called.

\CodeSubsection{\EvalBinopAndBegin}{\EvalBinopAndEnd}{../Interpreter.ml}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \falsep \eqdef \ELiteral(\lbool(\False))\\
  \evalexpr{\env, \ECond(\veone, \vetwo, \falsep)} \evalarrow C
}{
\evalexpr{\env, \EBinop(\BAND, \veone, \vetwo)} \evalarrow C
}
\end{mathpar}

\subsubsection{Comments}
The evaluation via the rule above ensures that $\veone$ is evaluated first and
only if it evaluates to $\True$ is $\vetwo$ evaluated.

\lrmcomment{This is related to \identr{BKNT}: add table}

\lrmcomment{This is related to \identr{XKGC}:}

It is an error for an expression’s meaning to rely on evaluation order except
that conditional expressions, and uses of the boolean operators \texttt{\&\&},
\texttt{||},\texttt{-->}, are guaranteed to evaluate from left to right.

\lrmcomment{This is related to \identi{YMRT}:}

An implementation could enforce this rule by performing a global analysis of
all functions to determine whether a function can throw an exception and the
set of global variables read and written by a function.

\lrmcomment{This is related to \identi{QRXP}:}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{-->} provide a short-circuit evaluation mechanism:

\lrmcomment{This is related to the note under \identr{LRHD}:}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\subsubsection{SemanticsRule.BinopOr \label{sec:SemanticsRule.BinopOr}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a disjunction of two expressions, $\EBinop(\BOR, \veone, \vetwo)$;
\item $C$ is the result of the evaluation of
      \texttt{if e1 then true else e2} (see \secref{SemanticsRule.ECond}).
\end{itemize}

\subsubsection{Example}
\ASLExample{\semanticstests/SemanticsRule.EBinopOrTrue.asl}
The expression \texttt{(0 == 1) || (1 == 1)} evaluates to the value \True.

\CodeSubsection{\EvalBinopOrBegin}{\EvalBinopOrEnd}{../Interpreter.ml}

\begin{mathpar}
\inferrule{
  \truep \eqdef \ELiteral(\lbool(\True))\\
  \evalexpr{\env, \ECond(\veone, \truep, \vetwo)} \evalarrow C
}{
\evalexpr{\env, \EBinop(\BOR, \veone, \vetwo)} \evalarrow C
}
\end{mathpar}
The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
it evaluates to $\False$, is $\vetwo$ evaluated.

\subsubsection{Comments}
\lrmcomment{This is related to \identr{BKNT}: add table}

\lrmcomment{This is related to \identr{XKGC}:}

It is an error for an expression’s meaning to rely on
evaluation order except that conditional expressions, and uses of the boolean
operators \texttt{\&\&}, \texttt{||}, \texttt{-->}, are guaranteed to evaluate
from left to right.

\lrmcomment{This is related to \identi{YMRT}:}

An implementation could enforce this rule by performing a global analysis of
all functions to determine whether a function can throw an exception and the
set of global variables read and written by a function.

\lrmcomment{This is related to \identi{QRXP}:}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{-->} provide a short-circuit evaluation mechanism:

\lrmcomment{This is related to the note under \identr{LRHD}:}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\subsubsection{SemanticsRule.BinopImpl \label{sec:SemanticsRule.BinopImpl}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes an implication over two expressions, $\EBinop(\IMPL, \veone, \vetwo)$;
  \item $\ve$ is evaluated as \texttt{if e1 then e2 else true}.
\end{itemize}

\subsubsection{Example}
\ASLExample{\semanticstests/SemanticsRule.EBinopImplExFalso.asl}
the expression \texttt{(0 == 1) --> (1 == 0)} evaluates to the value \True, according to the definition of implication.

  \CodeSubsection{\EvalBinopImplBegin}{\EvalBinopImplEnd}{../Interpreter.ml}

  \begin{mathpar}
    \inferrule{
      \truep \eqdef \ELiteral(\lbool(\True))\\
      \evalexpr{\env, \ECond(\veone, \vetwo, \truep)} \evalarrow C
    }
    {
    \evalexpr{\env, \EBinop(\IMPL, \veone, \vetwo)} \evalarrow C
    }
  \end{mathpar}
  The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
  it evaluates to \True, is $\vetwo$ evaluated.


\lrmcomment{This is related to \identr{BKNT}: add table}

\lrmcomment{This is related to \identi{QRXP}:}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{-->} provide a short-circuit evaluation mechanism:

\lrmcomment{This is related to the note under \identr{LRHD}:}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\subsubsection{SemanticsRule.Binop \label{sec:SemanticsRule.Binop}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a Binary Operator $\op$ over two expressions, $\EBinop(\op, \veone, \vetwo)$;
  \item the operator $\op$ is not one of $\BAND$, $\BOR$, or $\IMPL$.
        These operators are handled by rules
        SemanticsRule.BinopAnd (\secref{SemanticsRule.BinopAnd}),
        SemanticsRule.BinopOr \\ (\secref{SemanticsRule.BinopOr}), and
        SemanticsRule.BinopImpl (\secref{SemanticsRule.BinopImpl});
  \item the evaluation of the expression $\veone$ in $\env$ is the configuration \\
        $\Normal(\vmone, \envone)$\ProseOrAbnormal;
  \item the evaluation of the expression $\vetwo$ in $\envone$ is the configuration \\
        $\Normal(\vmtwo, \newenv)$\ProseOrAbnormal;
  \item $\vmone$ consists of the value $\vvone$ and the execution graph $\vgone$;
  \item $\vmtwo$ consists of the value $\vvtwo$ and the execution graph $\vgtwo$;
  \item applying the Binary Operator $\op$ to $\vvone$ and $\vvtwo$ results in $\vv$\ProseOrError;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\subsubsection{Example}
In this specification:
\ASLExample{\semanticstests/SemanticsRule.EBinopPlusAssert.asl}
the expression \texttt{3 + 2} evaluates to the value \texttt{5}.

\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.EBinopDIVBackendDefinedError.asl}
the expression \texttt{3 DIV 0} results in a type error.

\CodeSubsection{\EvalBinopBegin}{\EvalBinopEnd}{../Interpreter.ml}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\
  \evalexpr{ \env, \veone} \evalarrow \Normal(\vmone, \envone) \OrAbnormal \\\\
  \evalexpr{ \envone, \vetwo } \evalarrow \Normal(\vmtwo, \newenv) \OrAbnormal \\\\
  \vmone \eqname (\vvone, \vgone) \\
  \vmtwo \eqname (\vvtwo, \vgtwo) \\
  \binoprel(\op, \vvone, \vvtwo) \evalarrow \vv \OrDynError\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr{ \env, \overname{\EBinop(\op, \veone, \vetwo)}{\ve} } \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}

The rule above applies to many binary operators, including $\EQOP$ (which is used for \texttt{<->}
as well as \texttt{==}).

\subsubsection{Comments}
\lrmcomment{This is related to \identr{BKNT}: add table}

\lrmcomment{This is related to \identr{XKGC}:}

The semantics takes a semantic transition over the left subexpression before
the right subexpression.

This is an arbitrary choice as the type-checker must ensure that either order
of evaluation of the operands yields the same result.

In other words, it it is an error for an expression’s meaning to rely on
evaluation order except that conditional expressions, and uses of the boolean
operators \texttt{\&\&}, \texttt{||}, \texttt{-->}, are guaranteed to evaluate
from left to right.

\lrmcomment{This is related to \identi{YMRT}:}

An implementation could enforce this rule by performing a global analysis of
all functions to determine whether a function can throw an exception and the
set of global variables read and written by a function.

\lrmcomment{This is related to \identi{QJTN}:}

Notice that when one of the subexpressions terminates exceptionally,
the other expression must be side effect-free and non-throwing.

In other words, for any function call \texttt{F (e1, ..., em)}, tuple
\texttt{(e1, ..., em)}, or operation \texttt{e1 op e2} (with the exception of
\texttt{\&\&}, \texttt{||} and \texttt{-->}), it is an error if the
subexpressions conflict with each other by:
\begin{itemize}
\item both writing to the same variable.
\item one writing to a variable and the other reading from that same variable
\item one writing to a variable and the other throwing an exception
\item both throwing exceptions
\end{itemize}

\lrmcomment{This is related to \identi{GFZT}:}
These conditions are sufficient but not necessary to ensure that evaluation
order does not affect the result of an expression, including any side-effects.

\section{Unary Expressions\label{sec:UnaryExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nunop \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EUnop(\unop, \expr) &
\end{flalign*}

\subsubsection{ASTRule.Unop}
\begin{mathpar}
  \inferrule{
    \buildexpr(\vexpr) \astarrow \astversion{\vexpr} \OrBuildError
  }{
  \buildexpr(\overname{\Nexpr(\punnode{\Nunop}, \vexpr : \Nexpr)}{\vparsednode}) \astarrow
  \overname{\EUnop(\astof{\vunop}, \astversion{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.Unop\label{sec:TypingRule.Unop}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a unary operation $\op$ over an expression $\vep$, that is $\EUnop(\op, \vep)$;
  \item annotating $\vep$ in $\tenv$ yields $(\vtpp, \vepp, \vses)$\ProseOrTypeError;
  \item checking compatibility of $\op$ with $\vtpp$ as per \secref{TypingRule.ApplyUnopType} yields $\vt$\ProseOrTypeError;
  \item define $\newe$ as $\op$ over $\vepp$, that is, $\EUnop(\op, \vepp)$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vtpp, \vepp, \vses) \OrTypeError\\\\
  \applyunoptype(\tenv, \op, \vtpp) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\tenv, \EUnop(\op, \vep)} \typearrow (\vt, \EUnop(\op, \vepp), \vses)
}
\end{mathpar}
\CodeSubsection{\UnopBegin}{\UnopEnd}{../Typing.ml}

\subsection{Semantics}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.EUnopAssert.asl}
the expression \texttt{NOT '1010'} evaluates to the value \texttt{'0101'}.

\subsubsection{SemanticsRule.Unop\label{sec:SemanticsRule.Unop}}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a unary operator $\op$ over an expression, $\EUnop(\op, \veone)$;
\item the evaluation of the expression $\veone$ in $\env$ yields \\ $\Normal((\vvone, \vg), \newenv)$\ProseOrAbnormal;
\item applying the unary operator $\op$ to $\vvone$ is $\vv$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{ \env, \veone} \evalarrow \Normal((\vvone,\vg), \newenv) \OrAbnormal\\\\
  \unoprel(\op, \vvone) \evalarrow \vv
}
{
  \evalexpr{ \env, \EUnop(\op, \veone) } \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalUnopBegin}{\EvalUnopEnd}{../Interpreter.ml}

\section{Conditional Expressions\label{sec:ConditionalExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nexpr \parsesep \Neelse &\\
\Neelse \derives\ & \Telse \parsesep \Nexpr &\\
|\ & \Telseif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nexpr \parsesep \Neelse &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ECond(\overtext{\expr}{condition}, \overtext{\expr}{then}, \overtext{\expr}{else})
\end{flalign*}

\subsubsection{ASTRule.ECond}
\begin{mathpar}
  \inferrule{
    \buildexpr(\vcondexpr) \astarrow \astversion{\vcondexpr} \OrBuildError\\\\
    \buildexpr(\vthenexpr) \astarrow \astversion{\vthenexpr} \OrBuildError\\\\
    \buildeelse(\veelse) \astarrow \astversion{\veelse} \OrBuildError\\\\
  }{
    {
      \begin{array}{r}
  \buildexpr\left(\overname{\Nexpr\left(
    \begin{array}{l}
    \Tif, \namednode{\vcondexpr}{\Nexpr}, \Tthen, \\
    \wrappedline\ \namednode{\vthenexpr}{\Nexpr}, \veelse: \Neelse
    \end{array}
    \right)}{\vparsednode}\right) \astarrow\\
  \overname{\ECond(\astversion{\vcondexpr}, \astversion{\vthenexpr}, \astversion{\veelse})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\subsubsection{ASTRule.EElse \label{sec:ASTRule.EElse}}
\hypertarget{build-eelse}{}
The function
\[
  \buildeelse(\overname{\parsenode{\Nfieldassign}}{\vparsednode}) \;\aslto\; \overname{\expr}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[else]{}{
  \buildeelse(\Neelse(\Telse, \punnode{\Nexpr})) \astarrow
  \overname{\astof{\vexpr}}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[else\_if]{
  \buildexpr(\vcondexpr) \astarrow \astversion{\vcondexpr} \OrBuildError\\\\
  \buildexpr(\vthenexpr) \astarrow \astversion{\vthenexpr} \OrBuildError
}{
  {
    \begin{array}{r}
  \buildeelse\left(\Neelse\left(
    \begin{array}{l}
    \Telseif, \namednode{\vcondexpr}{\Nexpr},  \\
    \wrappedline\ \Tthen, \namednode{\vthenexpr}{\Nexpr}, \punnode{\Neelse}
  \end{array}
    \right)\right) \astarrow\\
  \overname{\ECond(\astversion{\vcondexpr}, \astversion{\vthenexpr}, \astof{\veelse})}{\vastnode}
\end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.ECond \label{sec:TypingRule.ECond}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a conditional expression with condition $\econd$ with two options $\etrue$ and $\efalse$;
  \item annotating $\econd$ in $\tenv$ results in $(\tcond, \econdp, \vsescond)$\ProseOrTypeError;
  \item annotating $\etrue$ in $\tenv$ results in $(\ttrue, \etruep, \vsestrue)$\ProseOrTypeError;
  \item annotating $\efalse$ in $\tenv$ results in $(\tfalse, \efalsep, \vsesfalse)$;
  \item obtaining the lowest common ancestor of $\ttrue$ and $\tfalse$ results in $\vt$\ProseOrTypeError;
  \item $\newe$ is the condition $\econdp$ with two options $\etruep$ and $\efalsep$, that is, $\ECond(\econdp, \etruep, \efalsep)$;
  \item define $\vses$ as the union of $\vsescond$, $\vsestrue$, and $\vsesfalse$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \econd} \typearrow (\tcond, \econd', \vsescond) \OrTypeError\\\\
  \annotateexpr{\tenv, \etrue} \typearrow (\ttrue, \etrue', \vsestrue) \OrTypeError\\\\
  \annotateexpr{\tenv, \efalse} \typearrow (\tfalse, \efalse', \vsesfalse) \OrTypeError\\\\
  \lca(\ttrue, \tfalse) \typearrow \vt \OrTypeError\\\\
  \vses \eqdef \vsescond \cup \vsestrue \cup \vsesfalse
}{
  {
    \begin{array}{r}
  \annotateexpr{\ECond(\econd, \etrue, \efalse)} \typearrow \\
  (\vt, \ECond(\econdp, \etruep, \efalsep), \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\ECondBegin}{\ECondEnd}{../Typing.ml}
\lrmcomment{This is related to \identr{XZVT}.}

\subsection{Semantics}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.ECondFalse.asl}
the expression \texttt{if FALSE then Return42() else 3} evaluates to the value \texttt{3}.

\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.ECondARBITRARY3or42.asl}
the expression \texttt{if ARBITRARY: boolean then 3 else Return42()} will
evaluate either \texttt{3} or \texttt{Return42()} depending on how
\texttt{ARBITRARY} is implemented.

\subsubsection{SemanticsRule.ECond \label{sec:SemanticsRule.ECond}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a conditional expression $\econd$ with two options $\veone$ and $\vetwo$,
        that is, $\ECond(\econd, \veone, \vetwo)$;
  \item the evaluation of the conditional expression $\econd$ in $\env$ yields \\
        $\Normal(\mcond, \envone)$\ProseOrAbnormal;
  \item $\mcond$ consists of a native Boolean for $\vb$ and execution graph $\vgone$;
  \item $\vep$ is $\veone$ if $\vb$ is $\True$ and $\vetwo$ otherwise;
  \item the evaluation of $\vep$ in $\envone$ yields $\Normal((\vvtwo, \vgtwo), \newenv)$\ProseOrAbnormal;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \econd} \evalarrow \Normal(\mcond, \envone) \OrAbnormal\\\\
    \mcond \eqname (\nvbool(\vb), \vgone)\\
    \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\\\
    \evalexpr{\envone, \vep} \evalarrow \Normal((\vv, \vgtwo), \newenv)  \OrAbnormal\\\\
    \vg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
  }
  {
    \evalexpr{\env, \overname{\ECond(\econd, \veone, \vetwo)}{\ve}} \evalarrow
    \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\CodeSubsection{\EvalECondBegin}{\EvalECondEnd}{../Interpreter.ml}

\subsubsection{Comments}
\lrmcomment{This is related to \identr{YCDB}:}

A conditional expression evaluates to its \texttt{then} expression if the
condition expression evaluates to $\True$. If the condition expression
evaluates to $\False$ each \texttt{elsif} condition expression is evaluated
sequentially until an \texttt{elsif} condition expression evaluates to $\True$;
the conditional expression evaluates to the corresponding \texttt{elsif}
expression. If no \texttt{elsif} expression evaluates to $\True$ the
conditional expression evaluates to the \texttt{else} expression.

\section{Call Expressions\label{sec:CallExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Ncall &
\end{flalign*}

\begin{flalign*}
\Ncall \derives \
     & \Tidentifier \parsesep \Plist{\Nexpr} &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \NClist{\Nexpr} \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \NClist{\Nexpr} \parsesep \Trbrace \parsesep \Plist{\Nexpr} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ECall(\call) &
\end{flalign*}

\begin{flalign*}
\call \derives\ &
{
\left\{
  \begin{array}{rcl}
 \callname &:& \Strings, \\
 \callparams &:& \expr, \\
 \callargs &:& \expr, \\
 \callcalltype &:& \subprogramtype
\end{array}
\right\}
} &
\end{flalign*}

\subsubsection{ASTRule.Call}
\hypertarget{build-call}{}
\begin{mathpar}
\inferrule{
  \buildplist[\buildexpr](\vargs) \astarrow \vargasts
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \namednode{\vargs}{\Plist{\Nexpr}})}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
        \callname &:& \id,\\
        \callparams &:& \emptylist,\\
        \callargs &:& \vargasts,\\
        \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\and
\inferrule{
  \buildlist[\buildexpr](\vparams) \astarrow \astversion{\vparams} \\
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \Tlbrace, \namednode{\vparams}{\NClist{\Nexpr}}, \Trbrace)}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
              \callname &:& \id,\\
              \callparams &:& \astversion{\vparams},\\
              \callargs &:& \emptylist,\\
              \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\and
\inferrule{
  \buildplist[\buildexpr](\vargs) \astarrow \vargasts \\
  \buildlist[\buildexpr](\vparams) \astarrow \astversion{\vparams} \\
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \Tlbrace, \namednode{\vparams}{\NClist{\Nexpr}}, \Trbrace, \namednode{\vargs}{\Plist{\Nexpr}})}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
              \callname &:& \id,\\
              \callparams &:& \astversion{\vparams},\\
              \callargs &:& \vargasts,\\
              \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\end{mathpar}

\subsubsection{ASTRule.SetCallType}
\hypertarget{def-setcalltype}{}
Above, $\STFunction$ is inserted as a default call type for any parsed $\call$.
The helper function
\[
  \setcalltype(\overname{\call}{\vcall} \aslsep \overname{\subprogramtype}{\texttt{call\_type}}) \aslto \overname{\call}{\vcallp}
\]
changes the call type of $\vcall$ to $\texttt{call\_type}$.

\begin{mathpar}
\inferrule{}{
  \setcalltype(\vcall, \texttt{call\_type}) \aslto
  \overname{\vcall[\callcalltype\mapsto\texttt{call\_type}]}{\vcallp}
}
\end{mathpar}

\subsubsection{ASTRule.ECall}
\begin{mathpar}
\inferrule{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Ncall})}{\vparsednode}) \astarrow
  \overname{\ECall(\astof{\vcall})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.ECall\label{sec:TypingRule.ECall}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a call to a subprogram, that is, $\ECall(\vcall)$;
  \item applying $\annotatecall$ to $\vcall$ and in $\tenv$
        annotates the call of the subprogram in $\tenv$ as a function (see Chapter~\ref{chap:SubprogramCalls})
        and yields $(\vcallp, \langle \vt \rangle, \vses)$\ProseOrTypeError.
  \item $\newe$ is the call using $\vcallp$, that is, $\ECall(\vcallp)$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatecall(\vcall) \typearrow (\vcallp, \langle \vt \rangle, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ECall(\vcall)}{\ve}} \typearrow (\vt, \overname{\ECall(\vcallp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ECallBegin}{\ECallEnd}{../Typing.ml}
\lrmcomment{This is related to \identd{CFYP}, \identr{BQJG}.}

\subsection{Semantics}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.ECall.asl}
the expression \texttt{Return42()} evaluates to the value \texttt{42} because the
subprogram \texttt{Return42()} is implemented to return the value \texttt{42}.

\subsubsection{SemanticsRule.ECall \label{sec:SemanticsRule.ECall}}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a subprogram call, $\ECall(\vcall)$;
  \item the evaluation of that subprogram call in $\env$ is either
  $\Normal(\vms, \newenv)$\ProseOrAbnormal;
  \item one of the following applies:
  \begin{itemize}
    \item all of the following apply (\textsc{single\_returned\_value}):
    \begin{itemize}
      \item $\vms$ consists of a single returned value $(\vv,\vg)$,
      which goes into the output configuration $\Normal((\vv, \vg), \newenv)$.
    \end{itemize}

    \item all of the following apply (\textsc{multiple\_returned\_values}):
    \begin{itemize}
      \item $\vms$ consists of a list of returned value $(\vv_i,\vg_i)$, for $i=1..k$;
      \item $\vg$ is the parallel composition of $\vg_i$, for $i=1..k$;
      \item $\vv$ is the \nativevalue\  vector of values $\vv_i$, for $i=1..k$;
      \item the resulting configuration is $\Normal((\vv, \vg), \newenv)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[single\_returned\_value]{
  \evalcall{\env, \vcall.\name, \vcall.\params, \vcall.\args} \evalarrow \Normal(\vms, \newenv) \OrAbnormal\\
  \vms \eqname [(\vv, \vg)]
}{
  \evalexpr{\env, \ECall(\vcall)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[multiple\_returned\_values]{
  \evalcall{\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs} \evalarrow \Normal(\vms, \newenv) \OrAbnormal\\
  \vms \eqname [i=1..k: (\vv_i, \vg_i)]\\
  \vg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k \\
  \vv \eqdef \nvvector{\vv_{1..k}}
}{
  \evalexpr{\env, \ECall(\vcall)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalECallBegin}{\EvalECallEnd}{../Interpreter.ml}

\section{Slicing Expressions\label{sec:SlicingExpressions}}
This section details the high-level form of the syntax and abstract syntax of slicing expressions,
and defines the semantics of bitvector slices.
The details of the various types of bitvector slices is deferred to \chapref{BitvectorSlicing}.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Nexpr \parsesep \Nslices &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ESlice(\expr, \slice^{*}) &
\end{flalign*}

\subsubsection{ASTRule.ESlice}
\begin{mathpar}
\inferrule{
  \buildexpr(\vexpr) \astarrow \astversion{\vexpr} \OrBuildError\\\\
  \buildslice(\vslice) \astarrow \astversion{\vslice} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\vexpr: \Nexpr, \vslice: \Nslice)}{\vparsednode}) \astarrow
  \overname{\ESlice(\astversion{\vexpr}, \astversion{\vslice})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.ESlice\label{sec:TypingRule.ESlice}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
        $\ESlice(\vep, \slices)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\tep,\vepp, \vsesone)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\tep$ in $\tenv$ yields $\structtep$\ProseOrTypeError;
  \item $\structtep$ is either a bitvector or an integer;
  \item checking that $\slices$ is not empty yields $\True$\ProseTerminateAs{\EmptySlice};
  \item annotating $\slices$ in $\tenv$ yields $(\slicesp, \vsestwo)$\ProseOrTypeError;
  \item obtaining the width of $\slices$ in $\tenv$ via $\sliceswidth$ yields $\vw$\ProseOrTypeError;
  \item $\vt$ is the bitvector type of width $\vw$, that is, $\TBits(\vw, \emptylist)$;
  \item define $\newe$ as the slicing of expression $\vepp$ by the slices $\slicesp$, that is, \\
        $\ESlice(\vepp, \slicesp)$;
  \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\tep, \vepp, \vsesone) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \structtep \OrTypeError\\\\
  \astlabel(\structtep) \in \{\TInt, \TBits\}\\
  \checktrans{\slices \neq \emptylist}{\EmptySlice} \typearrow \True \OrTypeError\\\\
  \annotateslices(\tenv, \slices) \typearrow (\slicesp, \vsestwo) \OrTypeError\\\\
  \sliceswidth(\tenv, \slices) \typearrow \vw \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateexpr{\tenv, \overname{\ESlice(\vep, \slices)}{\ve}} \typearrow
  (\overname{\TBits(\vw, \emptylist)}{\vt}, \overname{\ESlice(\vepp, \slicesp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ESliceBegin}{\ESliceEnd}{../Typing.ml}
\subsubsection{Comments}
The width of \slices\ might be a symbolic expression if one of the
widths references a \texttt{let} identifier with a non-compile-time-constant
initializer expression.
\lrmcomment{This is related to \identi{MJWM}.}

\subsubsection{TypingRule.ESliceError\label{sec:TypingRule.ESliceError}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure $\vtp$;
  \item $\vtp$ is neither an integer type or a bitvector type;
  \item the result is an error indicating that the type of $\vep$ is inappropriate for slicing.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \vtp\\
  \astlabel(\vtp) \not\in \{\TInt, \TBits\}
}{
  \annotateexpr{\tenv, \overname{\ESlice(\vep, \slices)}{\ve}} \typearrow \TypeErrorVal{IllegalSliceType}
}
\end{mathpar}
\CodeSubsection{\ESliceError}{\ESliceErrorEnd}{../Typing.ml}

\subsection{Semantics}
\subsubsection{SemanticsRule.ESlice\label{sec:SemanticsRule.ESlice}}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.ESlice.asl}
the expression \texttt{'11110000'[6:3]} evaluates to the value \texttt{'1110'}.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a slicing expression, $\ESlice(\ebv, \slices)$;
\item the evaluation of $\ebv$ in $\env$ yields $\Normal(\mbv, \envone)$\ProseOrAbnormal;
\item the evaluation of $\slices$ in $\env$ yields $\Normal(\mpositions, \newenv)$\ProseOrAbnormal;
\item $\mpositions$ consists of $\positions$ --- all the indices that need to be added to the
resulting bitvector --- and the execution graph $\vgone$;
\item reading from $\vbv$ as a bitvector at the indices indicated by $\positions$
      (see \secref{SemanticsRule.ReadFromBitvector}) results in the bitvector $\vv$,
      which concatenates all of the values from the indicates indices\ProseOrError;
\item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ebv} \evalarrow \Normal(\mbv, \envone)  \OrAbnormal\\\\
  \mbv \eqname (\vbv,\vgone) \\
  \evalslices(\envone, \slices) \evalarrow \Normal(\mpositions, \newenv)  \OrAbnormal \\
  \mpositions \eqname (\positions, \vgtwo) \\
  \readfrombitvector(\vbv, \positions) \evalarrow \vv \OrDynError\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr{\env, \ESlice(\ebv, \slices)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalESliceBegin}{\EvalESliceEnd}{../Interpreter.ml}

\section{Array Access Expressions\label{sec:ArrayAccessExpressions}}
This section details the syntax, abstract syntax, semantics, and typing of array read expressions.
In the untyped AST, a read from either an integer-indexed array or an enumeration-indexed arrays is represented
the same way. They type system infers the kind of array and outputs a typed AST node differentiating
the two kinds of arrays, either a $\EGetArray$ or a $\EGetEnumArray$, via \nameref{sec:TypingRule.EGetArray}.
The semantics utilizes a rule matching the corresponding type of array ---
\nameref{sec:SemanticsRule.EGetArray} for integer-indexed arrays and
\nameref{sec:SemanticsRule.EGetEnumArray} for enumeration-indexed arrays.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Nexpr \parsesep \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EGetArray(\expr, \expr) &
\end{flalign*}

\subsubsection{ASTRule.EGetArray}
\begin{mathpar}
\inferrule{
  \buildexpr(\veone) \astarrow \astversion{\veone} \OrBuildError\\\\
  \buildexpr(\vetwo) \astarrow \astversion{\vetwo} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\namednode{\veone}{\Nexpr}, \Tllbracket, \namednode{\vetwo}{\Nexpr}, \Trrbracket)}{\vparsednode}) \astarrow
  \overname{\EGetArray(\astversion{\veone}, \astversion{\vetwo})}{\vastnode}
}
\end{mathpar}

\subsubsection{TypingRule.EGetArray\label{sec:TypingRule.EGetArray}}
\hypertarget{def-arrayaccess}{}
\begin{definition}[Array Access]
We refer to a right-hand-side expression of the form \texttt{b[[i]]},
where $b, i$ are subexpressions, as an \arrayaccess\ expression.
We refer to $b$ and $i$ as the \emph{base}
and the $\emph{index}$ subexpressions, respectively.
\end{definition}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the \arrayaccess{} expression with base $\ebase$ and index $\eindex$;
  \item \Proseannotateexpr{$\tenv$}{$\ebase$}{\\ $(\tbase,\ebasep, \vsesbase)$}\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\tbase$ in $\tenv$ yields $\tanonbase$\ProseOrTypeError;
  \item checking whether $\tanonbase$ is an array type yields $\True$\ProseOrTypeError;
  \item view $\tanonbase$ as the array type with size expression $\size$ and element type $\telem$,
        that is, $\TArray(\size, \telem)$;
  \item applying $\annotategetarray$ to $(\size, \telem)$ and \\
        $(\ebasep, \vsesbase, \eindex)$ yields
        $(\vt, \newe, \vses)$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ebase} \typearrow (\tbase, \ebasep, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tanonbase \OrTypeError\\\\
  \checktrans{\astlabel(\tanonbase) = \TArray}{ExpectedArrayType} \typearrow \True \OrTypeError\\\\
  \tanonbase \eqname \TArray(\size, \telem)\\
  {
    \begin{array}{r}
  \annotategetarray(\tenv, (\size, \telem), (\ebasep, \vsesbase, \eindex)) \typearrow \\ (\vt, \newe, \vses)
    \end{array}
  }
}{
  \annotateexpr{\tenv, \overname{\EGetArray(\ebase, \eindex)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\EGetArrayBegin}{\EGetArrayEnd}{../Typing.ml}

\subsubsection{TypingRule.AnnotateGetArray\label{sec:TypingRule.AnnotateGetArray}}
\hypertarget{def-annotategetarray}{}
The helper function
\[
\begin{array}{r}
\annotategetarray(
  \overname{\staticenvs}{\tenv} \aslsep
  (\overname{\expr}{\size} \times \overname{\ty}{\telem}) \aslsep
  (\overname{\expr}{\ebase} \times \overname{\TSideEffectSet}{\vsesbase} \times \overname{\expr}{\eindex})
)
\aslto \\
(\overname{\ty}{\vt} \times \overname{\expr}{\newe} \times \overname{\TSideEffectSet}{\vses})
\end{array}
\]
annotates an array access expression with the following elements:
$\size$ is the expression representing the array size,
$\telem$ is the type of array elements,
$\ebase$ is the annotated expression for the array base,
$\eindex$ is the index expression.
The function returns the type of the annotated expression in $\vt$,
the annotated expression $\newe$, and the inferred \sideeffectdescriptorterm\ $\vses$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item \Proseannotateexpr{$\tenv$}{$\eindex$}{(\tindexp, \eindexp, \vsesindex)}\ProseOrTypeError;
  \item applying $\typeofarraylength$ to $\size$, to obtain the type of the array length, yields
        $\wantedtindex$;
  \item checking that $\tindexp$ \typesatisfies\ $\wantedtindex$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item \Prosenonconflictingunion{$\vsesindex$ and $\vsesbase$}{$\vses$};
  \item \Proseeqdef{$\newe$}{
    an access to an integer-indexed array for $\ebase$ and $\eindexp$, that is, $\EGetArray(\ebase, \eindexp)$ if $\size$ is an integer-typed array index,
    and an access to an enumeration-indexed array for $\ebase$ and $\eindexp$, that is,\\
    $\EGetEnumArray(\ebase, \eindexp)$ if $\size$ is an enumeration-typed array index.
  }
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp, \vsesindex) \OrTypeError\\\\
  \typeofarraylength(\size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\\\
  \nonconflictingunion([\vsesindex, \vsesbase]) \typearrow \vses \OrTypeError\\\\
  {
    \newe \eqdef \begin{cases}
      \EGetArray(\ebase, \eindexp)     & \text{if }\astlabel(\size) = \ArrayLengthExpr\\
      \EGetEnumArray(\ebase, \eindexp) & \text{if }\astlabel(\size) = \ArrayLengthEnum
    \end{cases}
  }
}{
  {
  \begin{array}{r}
  \annotategetarray(\tenv, (\size, \telem), (\ebase, \vsesbase, \eindex)) \typearrow\\
  (\overname{\telem}{\vt}, \newe, \vses)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\AnnotateGetArrayBegin}{\AnnotateGetArrayEnd}{../Typing.ml}

\subsubsection{SemanticsRule.EGetArray\label{sec:SemanticsRule.EGetArray}}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.EGetArray.asl}
the expression \texttt{my\_array[2]} appearing in the assertion evaluates to the value \texttt{42} since the element
indexed by \texttt{2} in \texttt{my\_array} is \texttt{42}.

\subsubsection{Example}
The specification:
\ASLExample{\semanticstests/SemanticsRule.EGetArrayTooSmall.asl}
results in a typing error since we are trying to access index \texttt{3} of an array
which has indexes \texttt{0}, \texttt{1} and \texttt{2} only.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes an array access expression, $\EGetArray(\earray, \eindex)$;
  \item the evaluation of $\earray$ in $\env$ is $\Normal(\marray, \envone)$\ProseOrAbnormal;
  \item the evaluation of $\eindex$ in $\env$ is  $\Normal(\mindex, \newenv)$\ProseOrAbnormal
  \item $\marray$ consists of the native vector $\varray$ and execution graph $\vgone$;
  \item $\mindex$ consists of the native integer $\vindex$ and execution graph $\vgtwo$;
  \item $\vindex$ is the native integer for $\vi$;
  \item evaluating the value at index $\vi$ of $\varray$ is $\vv$;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \earray} \evalarrow \Normal(\marray, \envone)  \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \newenv)  \OrAbnormal\\
  \marray \eqname (\varray, \vgone)\\
  \mindex \eqname (\vindex, \vgtwo)\\
  \vindex \eqname \nvint(\vi)\\
  \getindex(\vi, \varray) \evalarrow \vv\\
  \vg \eqdef \vgone \parallelcomp \vgtwo\\
}{
  \evalexpr{\env, \EGetArray(\earray, \eindex)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetArrayBegin}{\EvalEGetArrayEnd}{../Interpreter.ml}

\subsubsection{SemanticsRule.EGetEnumArray\label{sec:SemanticsRule.EGetEnumArray}}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.EGetEnumArray.asl}
the enumeration-typed array \texttt{Arr} is accessed for reading and writing
with indices taken from the enumeration type \texttt{Enum}.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes an array access expression, $\EGetArray(\earray, \eindex)$;
  \item the evaluation of $\earray$ in $\env$ is $\Normal(\marray, \envone)$\ProseOrAbnormal;
  \item the evaluation of $\eindex$ in $\env$ is  $\Normal(\mindex, \newenv)$\ProseOrAbnormal
  \item $\marray$ consists of the native value $\varray$ and execution graph $\vgone$;
  \item $\mindex$ consists of the native value $\vindex$ and execution graph $\vgtwo$;
  \item $\vindex$ is the native literal for the label $\vl$;
  \item accessing the field $\vl$ of $\varray$, which is a native record value, yields $\vv$;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \earray} \evalarrow \Normal(\marray, \envone)  \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \newenv)  \OrAbnormal\\
  \marray \eqname (\varray, \vgone)\\
  \mindex \eqname (\vindex, \vgtwo)\\
  \vindex \eqname \nvlabel(\vl)\\
  \getfield(\vl, \varray) \evalarrow \vv\\
  \vg \eqdef \vgone \parallelcomp \vgtwo\\
}{
  \evalexpr{\env, \EGetEnumArray(\earray, \eindex)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetEnumArrayBegin}{\EvalEGetEnumArrayEnd}{../Interpreter.ml}

\section{Field Reading Expressions\label{sec:FieldReadingExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tdot \parsesep \Tidentifier&
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EGetField(\overtext{\expr}{record}, \overtext{\identifier}{field name}) &
\end{flalign*}

\subsubsection{ASTRule.EGetField}
\begin{mathpar}
  \inferrule{
    \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError
  }{
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tdot, \Tidentifier(\id))}{\vparsednode}) \astarrow
  \overname{\EGetField(\astversion{\ve}, \id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.EGetRecordField\label{sec:TypingRule.EGetRecordField}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a \structuredtype\ with fields $\fields$;
  \item the field $\fieldname$ is associated with the type $\vt$ in $\fields$
  \item define $\newe$ as the access of field $\fieldname$ on the record or exception object $\vetwo$, that is, $\EGetField(\vetwo, \fieldname)$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \langle \vt\rangle
}{
  {
    \begin{array}{r}
      \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow \\
      (\vt, \EGetField(\vetwo, \fieldname), \overname{\vsesone}{\vses})
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EGetRecordFieldBegin}{\EGetRecordFieldEnd}{../Typing.ml}

\subsubsection{TypingRule.EGetBadRecordField \label{sec:TypingRule.EGetBadRecordField}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a \structuredtype\ with fields $\fields$;
  \item the field $\fieldname$ is not associated with any type in $\fields$
  \item the result is a type error indicating the missing field.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow \TypeErrorVal{FieldDoesNotExist}
}
\end{mathpar}
\CodeSubsection{\EGetBadRecordFieldBegin}{\EGetBadRecordFieldEnd}{../Typing.ml}

\subsubsection{TypingRule.EGetBadBitField\label{sec:TypingRule.EGetBadBitField}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item the field $\fieldname$ is not found in $\bitfields$
  \item the result is a type error indicating the missing field.
\end{itemize}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow \TypeErrorVal{FieldDoesNotExist}
}
\end{mathpar}
\CodeSubsection{\EGetBadBitFieldBegin}{\EGetBadBitFieldEnd}{../Typing.ml}

\subsubsection{TypingRule.EGetBitField\label{sec:TypingRule.EGetBitField}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$, that is, \\ $\BitFieldSimple(\Ignore, \slices)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vt, \newe, \vses)$\ProseOrTypeError.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \langle \BitFieldSimple(\Ignore, \slices)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldBegin}{\EGetBitFieldEnd}{../Typing.ml}

\subsubsection{TypingRule.EGetBitFieldNested\label{sec:TypingRule.EGetBitFieldNested}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and nested bitfields $\bitfieldsp$, that is,
        $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe, \vsesnew)$\ProseOrTypeError;
  \item $\vtefour$ is a bitvector type with length expression $\width$, that is, $\TBits(\width, \Ignore)$;
  \item define $\vt$ as a bitvector type with length expression $\width$ and bitfields $\bitfieldsp$;
  \item define $\vses$ as $\vsesnew$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  {
    \begin{array}{r}
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \\ \langle \BitFieldNested(\Ignore, \slices, \bitfieldsp)\rangle
    \end{array}
  }\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe, \vsesnew) \OrTypeError\\\\
  \vtefour \eqname \TBits(\width, \Ignore)\\
  \vt \eqdef \TBits(\width, \bitfieldsp)
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \overname{\vses}{\vsesnew})
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldNestedBegin}{\EGetBitFieldNestedEnd}{../Typing.ml}

\subsubsection{TypingRule.EGetBitFieldTyped\label{sec:TypingRule.EGetBitFieldTyped}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and typed bitfield with type $\vt$ that is,
        $\BitFieldType(\Ignore, \slices, \vt)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe, \vsesnew)$\ProseOrTypeError;
  \item determining whether $\vtefour$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item define $\vses$ as $\vsesnew$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \langle \BitFieldType(\Ignore, \slices, \vt)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe, \vsesnew) \OrTypeError\\\\
  \checktypesat(\tenv, \vtefour, \vt) \typearrow \True \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \overname{\vses}{\vsesnew})
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldTypedBegin}{\EGetBitFieldTypedEnd}{../Typing.ml}

\subsubsection{TypingRule.EGetTupleItem\label{sec:TypingRule.EGetTupleItem}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is tuple type with list of types $\tys$, that is, $\TTuple(\tys)$;
  \item $\fieldname$ is an identifier with the prefix \texttt{item} and the suffix $\num$;
  \item $\num$ is lexically an integer token with the integer value $\vindex$;
  \item determining whether $\vindex$ is between $0$ and the number of types in $\tys$, inclusive, yields $\True$\ProseOrTypeError;
  \item $\vt$ is the type at position $\vindex$ of $\tys$;
  \item $\newe$ is the expression for obtaining the item at index $\vindex$ from the expression $\vetwo$, that is, $\EGetItem(\vetwo, \vindex)$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TTuple(\tys)\\
  \fieldname \eqname \texttt{"item"}\num\\
  \num \in \Lang(\REintlit)\\
  \decimaltolit(\num) = \Tintlit(\vindex)\\
  \checktrans{0 \leq \vindex \leq \listlen{\tys}}{IndexOutOfRange} \checktransarrow \True \OrTypeError\\\\
  \vt \eqdef \tys[\vindex]\\
  \newe \eqdef \EGetItem(\vetwo, \vindex)
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \overname{\vsesone}{\vses})
}
\end{mathpar}
\CodeSubsection{\EGetTupleItemBegin}{\EGetTupleItemEnd}{../Typing.ml}

\subsubsection{TypingRule.EGetBadField\label{sec:TypingRule.EGetBadField}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is neither one of the following types: record, exception, bitvector, or tuple;
  \item the result is an error indicating that the type of $\veone$ is inappropriate for accessing the field $\fieldname$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \astlabel(\vtetwo) \not\in \{\TRecord, \TException, \TBits, \TTuple\}
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow \TypeErrorVal{ConflictingTypes}
}
\end{mathpar}
\CodeSubsection{\EGetBadFieldBegin}{\EGetBadFieldEnd}{../Typing.ml}

\subsection{Semantics}
\subsubsection{SemanticsRule.EGetField\label{sec:SemanticsRule.EGetField}}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.ERecord.asl}
the expression \texttt{my\_record.a} evaluates to the value \texttt{3}.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a field access expression, $\EGetField(\erecord, \fieldname)$;
\item the evaluation of $\erecord$ in $\env$ is $\Normal((\vrecord, \vg), \newenv)$\ProseOrAbnormal;
\item $\vv$ is the value mapped by $\fieldname$ in the native record $\vrecord$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \erecord} \evalarrow \Normal((\vrecord, \vg), \newenv)  \OrAbnormal\\
  \getfield(\fieldname, \vrecord) \evalarrow \vv
}{
  \evalexpr{\env, \EGetField(\erecord, \fieldname)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetFieldBegin}{\EvalEGetFieldEnd}{../Interpreter.ml}

\subsubsection{SemanticsRule.EGetItem\label{sec:SemanticsRule.EGetItem}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ is an expression for accessing the component given by the index $\vindex$ of the tuple
        given by the expression $\etuple$, that is, $\EGetItem(\etuple, \vindex)$;
  \item evaluating the expression $\etuple$ yields $\Normal((\vvtuple, \vg), \newenv)$\ProseOrAbnormal;
  \item accessing the native tuple value $\vvtuple$ at index $\vindex$ via $\getindex$, yields
        the native value $\vv$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \etuple} \evalarrow \Normal((\vvtuple, \vg), \newenv) \OrAbnormal\\\\
  \getindex(\vvtuple, \vindex) \evalarrow \vv
}{
  \evalexpr{\env, \overname{\EGetItem(\etuple, \vindex)}{\ve}} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetTupleItemBegin}{\EvalEGetTupleItemEnd}{../Interpreter.ml}

\section{Multi-field Reading Expressions\label{sec:MultiFieldReadingExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tdot \parsesep \Tlbracket \parsesep \NClist{\Tidentifier} \parsesep \Trbracket &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EGetFields(\overtext{\expr}{record}, \overtext{\identifier^{*}}{field names}) &
\end{flalign*}

\subsubsection{ASTRule.EGetFields}
\begin{mathpar}
  \inferrule{
    \buildclist[\buildidentity](\vids) \astarrow \vidasts\\
    \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError
  }{
    {
      \begin{array}{r}
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tdot, \Tlbracket, \namednode{\vids}{\NClist{\Tidentifier}}, \Trbracket)}{\vparsednode}) \astarrow\\
  \overname{\EGetFields(\astversion{\ve}, \vidasts)}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.EGetFields}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ is a multi-field access expression for the base expression $\veone$ and list of fields $\vfields$,
      that is, $\EGetFields(\veone, \vfields)$;
  \item \Proseannotateexpr{$\tenv$}{$\veone$}{\\ $(\vtetwo, \vetwo, \vsesone)$}\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{bits}):
    \begin{itemize}
      \item obtaining the \underlyingtype\ of $\vtetwo$ in $\tenv$ yields a bitvector type with list of bitfields $\vbitfields$\ProseOrTypeError;
      \item applying $\findbitfieldsslices$ to each field name $\name$ in $\vfields$ yields \\
            $\vslices_\name$\ProseOrTypeError;
      \item define $\vep$ as the slicing expression for $\veone$ and lists of slices $\vslices_\name$, for each $\name$ in $\vfields$;
      \item \Proseannotateexpr{$\tenv$}{$\vep$}{\\ $(\vt, \newe, \vses)$}\ProseOrTypeError.
    \end{itemize}

    \item All of the following apply (\textsc{record}):
    \begin{itemize}
      \item obtaining the \underlyingtype\ of $\vtetwo$ in $\tenv$ yields a record type with list of field initializers $\tfields$\ProseOrTypeError;
      \item applying $\getbitfieldwidth$ to $\vf$ in $\tfields$ and $\tfields$, for each $\vf$ in $\tfields$, in $\tenv$ yields $\ewidth_\vf$\ProseOrTypeError;
      \item applying $\widthplus$ to the list of expressions $\ewidth_\vf$, for each $\vf$ in $\tfields$, yields $\vw$\ProseOrTypeError;
      \item define $\vt$ as the bitvector type with width $\vw$ and an empty list of bitfields;
      \item define $\ve$ as the multi-field access for $\vetwo$ and list of fields $\tfields$;
      \item define $\vses$ as $\vsesone$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[bits]{
  \annotateexpr{\tenv, \veone} \typearrow (\vtetwo, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtetwo) \typearrow \TBits(\Ignore, \vbitfields) \OrTypeError\\\\
  \name\in\vfields: \findbitfieldsslices(\name) \typearrow \vslices_\name \OrTypeError\\\\
  \vep \eqdef \ESlice(\veone, [\name\in\vfields: \vslices_\name])\\
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EGetFields(\veone, \vfields)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[record]{
  \annotateexpr{\tenv, \veone} \typearrow (\vtetwo, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtetwo) \typearrow \TRecord(\tfields) \OrTypeError\\\\
  \vf \in \tfields: \getbitfieldwidth(\tenv, \vf, \tfields) \typearrow \ewidth_\vf \OrTypeError\\\\
  \widthplus(\tenv, [\vf \in \tfields: \ewidth_\vf]) \typearrow \vw\OrTypeError
}{
  {
  \begin{array}{r}
    \annotateexpr{\tenv, \overname{\EGetFields(\veone, \vfields)}{\ve}} \typearrow \\
    (\overname{\TBits(\vw, \emptylist)}{\vt}, \overname{\EGetFields(\vetwo, \vfields)}{\newe}, \overname{\vsesone}{\vses})
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \annotateexpr{\tenv, \veone} \typearrow (\vtetwo, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \veone) \typearrow \vtetwoanon \OrTypeError\\\\
  \astlabel(\vtetwoanon) \not\in \{\TBits, \TRecord\}
}{
  \annotateexpr{\tenv, \overname{\EGetFields(\veone, \vfields)}{\ve}} \typearrow \TypeErrorVal{}
}
\end{mathpar}
\CodeSubsection{\EGetFieldsBegin}{\EGetFieldsEnd}{../Typing.ml}

\subsubsection{TypingRule.FindBitFieldsSlices}
\hypertarget{def-findbitfieldsslices}{}
% Transliteration note: The implementation returns an optional, but all of its uses raise a type error if the result is None.
The helper function
\[
  \findbitfieldsslices(\overname{\identifier}{\name} \aslsep \overname{\bitfield^*}{\vbitfields})
  \aslto \overname{\slice^*}{\vslices} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the slices associated with the bitfield named $\name$ in the list of bitfields $\vbitfields$
in $\vslices$.
\ProseOtherwiseTypeError

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{found}):
  \begin{itemize}
    \item $\vbitfields$ is a list with \head\ $\vfield$ and \tail\ $\vbitfieldsone$;
    \item applying $\bitfieldgetname$ to $\vfield$ yields $\name$;
    \item applying $\bitfieldgetslices$ to $\vfield$ yields $\vslices$.
  \end{itemize}

  \item All of the following apply (\textsc{tail}):
  \begin{itemize}
    \item $\vbitfields$ is a list with \head\ $\vfield$ and \tail\ $\vbitfieldsone$;
    \item applying $\bitfieldgetname$ to $\vfield$ yields $\namep$, which is different to $\name$;
    \item applying $\findbitfieldsslices$ to $\name$ and $vbitfieldsone$ yields $\vslices$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item $\vbitfields$ is an empty list;
    \item the result is a type error indicating that a bitfield named $\name$ does not exist in $\vbitfields$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[found]{
  \bitfieldgetname(\vfield) \typearrow \name\\
  \bitfieldgetslices(\vfield) \typearrow \vslices
}{
  \findbitfieldsslices(\name, \overname{[\vfield] \concat \vbitfieldsone}{\vbitfields}) \typearrow \vslices
}
\end{mathpar}

\begin{mathpar}
\inferrule[tail]{
  \bitfieldgetname(\vfield) \typearrow \namep\\
  \namep \neq \name\\
  \findbitfieldsslices(\name, \vbitfieldsone) \typearrow \vslices \OrTypeError
}{
  \findbitfieldsslices(\name, \overname{[\vfield] \concat \vbitfieldsone}{\vbitfields}) \typearrow \vslices
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty]{}{
  \findbitfieldsslices(\name, \overname{\emptylist}{\vbitfields}) \typearrow \TypeErrorVal{BitfieldNotFound}
}
\end{mathpar}

\subsubsection{TypingRule.GetBitfieldWidth}
\hypertarget{def-getbitfieldwidth}{}
The helper function
\[
  \getbitfieldwidth(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\field^*}{\tfields})
  \aslto \overname{\expr}{\ewidth} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the expression $\ewidth$ that describes the width of the bitfield named $\name$
in the list of fields $\tfields$.
\ProseOtherwiseTypeError

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item applying $\assocopt$ to find the type associated with $\name$ in $\tfields$ yields the type $\vt$;
    \item applying $\getbitvectorwidth$ to $\vt$ in $\tenv$ yields $\ewidth$.
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item applying $\assocopt$ to find the type associated with $\name$ in $\tfields$ yields $\None$;
    \item the result is a type error indicating that $\name$ is not associated with any field in $\tfields$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \assocopt(\name, \tfields) \typearrow \langle\vt\rangle\\
  \getbitvectorwidth(\tenv, \vt) \typearrow \ewidth
}{
  \getbitfieldwidth(\tenv, \name, \tfields) \typearrow \ewidth
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \assocopt(\name, \tfields) \typearrow \None
}{
  \getbitfieldwidth(\tenv, \name, \tfields) \typearrow \TypeErrorVal{BitFieldNotFound}
}
\end{mathpar}

\subsubsection{TypingRule.WidthPlus}
\hypertarget{def-widthplus}{}
% NOTE: the implementation handles just two expressions, here we fold over a list.
The helper function
\[
  \widthplus(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr^*}{\exprs}) \typearrow \overname{\expr}{\ewidth}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
generates the expression $\ewidth$, which represents the summation of all expressions in the list $\exprs$,
normalized in the static environment $\tenv$.
\ProseOrTypeError

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\exprs$ is an empty list;
    \item $\ewidth$ is the literal expression for $0$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\exprs$ is the list with \head\ $\ve$ and \tail\ $\exprsone$;
    \item applying $\widthplus$ to $\exprsone$ yields $\ewidthone$;
    \item applying $\normalize$ to the binary operation for $\PLUS$ and $\ve$ and $\ewidthone$ yields $\ewidth$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \widthplus(\tenv, \overname{\emptylist}{\exprs}) \typearrow \overname{\ELInt{0}}{\ewidth}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \widthplus(\exprsone) \typearrow \ewidthone\\
  \normalize(\tenv, \EBinop(\PLUS, \ve, \ewidthone)) \typearrow \ewidth \OrTypeError
}{
  \widthplus(\tenv, \overname{[\ve] \concat \exprsone}{\exprs}) \typearrow \ewidth
}
\end{mathpar}

\subsection{Semantics}
\subsubsection{SemanticsRule.EGetfields{\label{sec:SemanticsRule.EGetfields}}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ is the multi-field access expression for the expression $\erecord$ and list of field names
        $\vfieldnames$;
  \item evaluating the expression $\erecord$ in $\env$ yields $((\vrecord, \vg), \newenv)$\ProseOrAbnormal;
  \item obtaining the value associated with the field $\fieldname$ in $\vv$, for each $\fieldname$ in $\vfieldnames$,
        yields $\vv_\fieldname$;
  \item define $\vv$ as the concatenation of $\vv_\fieldname$, for each $\fieldname$ in $\vfieldnames$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \erecord} \evalarrow ((\vrecord, \vg), \newenv) \OrAbnormal\\\\
  \fieldname\in\vfieldnames: \getfield(\fieldname, \vv) \evalarrow \vv_\fieldname\\
  \concatbitvectors([\fieldname\in\vfieldnames: \vv_\fieldname]) \typearrow \vv
}{
  \evalexpr{\env, \overname{\EGetFields(\erecord, \vfieldnames)}{\ve}} \evalarrow
  ((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetFieldsBegin}{\EvalEGetFieldsEnd}{../interpreter.ml}

\section{Asserting Type Conversion Expressions\label{sec:AssertingTypeConversionExpressions}}
\lrmcomment{This is related to \identi{TCST}:}
The rule about domains in the definitions of subtype-satisfaction and
type-satisfaction means that it is illegal to use the unconstrained integer
where a constrained integer is expected. An asserting type conversion (ATC) can
be used to overcome this.

\lrmcomment{This is related to \identi{CGRH}:}
An ATC allows code to explicitly mark places where uses of constrained types
would otherwise be a static type-checking error. The intent is to reduce the
incidence of unintended errors by making such uses fail type-checking unless
the asserting type conversion is provided.

\lrmcomment{This is related to \identr{WZVX}:}
Note that ATCs are execution-time checks. An execution-time check is a
condition that is evaluated during the evaluation of an execution-time
initializer expression or subprogram. If the condition evaluates to $\False$ it
is a dynamic error.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tas \parsesep \Nty &\\
                    |\  & \Nexpr \parsesep \Tas \parsesep \Nconstraintkind &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \overtext{\EATC}{Type assertion}(\expr, \overtext{\ty}{asserted type}) &
\end{flalign*}

\subsubsection{ASTRule.ATC}
\begin{mathpar}
\inferrule[type]{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildty(\vt) \astarrow \astversion{\vt} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tas, \vt : \Nty)}{\vparsednode}) \astarrow
  \overname{\EATC(\astversion{\ve}, \astversion{\vt})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_constraints]{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildconstraintkind(\vics) \astarrow \astversion{\vics} \OrBuildError
}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tas, \vics : \Nconstraintkind)}{\vparsednode}) \astarrow\\
      \overname{\EATC(\astversion{\ve}, \TInt(\astversion{\vics}))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.ATC\label{sec:TypingRule.ATC}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes an asserting type conversion with expression $\vep$ and type $\tty$, that is $\EATC(\vep, \tty)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vt, \vepp, \\vsese)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyp, \vsesty)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\tty'$ in $\tenv$ yields $\vtystruct$\ProseOrTypeError;
  \item applying $\checkatc$ to $\vtstruct$ and $\vtystruct$ in $\tenv$ to check whether the type assertion
        will always fail yields $\True$\ProseOrTypeError;
  \item define $\vsesp$ as the union of $\vsesty$, $\vsese$, and the singleton set for \PerformsAssertions;
  \item checking whether $\vtstruct$ \subtypesatisfies\ $\vtystruct$ in $\tenv$ yields \\
        $\vallwayssucceeds$\ProseOrTypeError\
        (if $\vallwayssucceeds$ holds then the type assertion will always succeed dynamically, and therefore can be omitted);
  \item $\newe$ is $\vepp$ if $\vallwayssucceeds$ is $\True$ and $\EATC(\ttyp, \vepp)$ otherwise;
  \item $\vses$ is $\vsese$ if $\vallwayssucceeds$ is $\True$ and $\vses$ otherwise;
  \item $\vt$ is $\ttyp$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[type\_equal]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp, \vsese) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \annotatetype{\tenv, \tty} \typearrow (\ttyp, \vsesty) \OrTypeError\\\\
  \tstruct(\tenv, \ttyp) \typearrow \vtystruct \OrTypeError\\\\
  \checkatc(\tenv, \vtstruct, \vtystruct) \typearrow \True \OrTypeError\\\\
  \vsesp \eqdef \vsesty \cup \vsese \cup \{\PerformsAssertions\}\\
  \subtypesat(\tenv, \vtstruct, \vtystruct) \typearrow \vallwayssucceeds \OrTypeError\\\\
  (\newe, \vses) \eqdef \choice{\vallwayssucceeds}{(\vepp, \vsese)}{(\EATC(\ttyp, \vepp), \vsesp)}
}{
  \annotateexpr{\tenv, \overname{\EATC(\vep, \tty)}{\ve}} \typearrow (\overname{\ttyp}{\vt}, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\ATCBegin}{\ATCEnd}{../Typing.ml}
\lrmcomment{
  This is related to \identr{VBLL}, \identi{KRLL}, \identg{PFRQ}, \identi{XVBG},
  \identr{GYJZ}, \identi{SZVF}, \identr{PZZJ}, \identr{YCPX}, \identi{ZLBW},
  \identi{TCST}, \identi{CGRH}, \identi{YJBB}.
}

\subsubsection{TypingRule.CheckATC \label{sec:TypingRule.CheckATC}}
\hypertarget{def-checkatc}{}
The helper function
\[
  \checkatc(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo}) \aslto
  \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the types $\vtone$ and $\vttwo$, which are assumed to not be named types,
are compatible for a typing assertion in the static environment $\tenv$, yielding $\True$.
\ProseOtherwiseTypeError

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{equal}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{different\_labels\_error}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are different;
    \item the result is a type error indicating that the type assertion will always fail.
  \end{itemize}

  \item All of the following apply (\textsc{int\_bits}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is either $\TInt$ or $\TBits$;
    \item the result is $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item $\vtone$ is a tuple type with list of tuples $\vlone$, that is, $\TTuple(\vlone)$;
    \item $\vtone$ is a tuple type with list of tuples $\vltwo$, that is, $\TTuple(\vltwo)$;
    \item checking whether $\vlone$ and $\vltwo$ have the same length yields $\True$\ProseTerminateAs{\TypeErrorVal{\TypeAsssertionFails}};
    \item applying $\checkatc$ to $\vlone[\vi]$ and $\vltwo[\vi]$ in $\tenv$ for every $\vi\in\listrange(\vlone)$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$;
  \end{itemize}

  \item All of the following apply (\textsc{other\_error}):
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is neither $\TInt$, nor $\TBits$, nor $\TTuple$;
    \item the result is a type error indicating that the type assertion will always fail ($\TypeAsssertionFails$).
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[equal]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[different\_labels\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) \neq \astlabel(\vttwo)
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\TypeAsssertionFails}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_bits]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \in \{\TInt, \TBits\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \vtone = \TTuple(\vlone)\\
  \vttwo = \TTuple(\vltwo)\\
  \checktrans{|\vlone|=|\vltwo|}{\TypeAsssertionFails} \typearrow \True\OrTypeError\\\\
  \vi\in\listrange(\vlone): \checkatc(\vlone[\vi], \vltwo[\vi]) \typearrow \True\OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[other\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \not\in \{\TInt, \TBits, \TTuple\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\TypeAsssertionFails}
}
\end{mathpar}

\subsection{Semantics}
\subsubsection{SemanticsRule.ATC\label{sec:SemanticsRule.ATC}}
\subsubsection{Example}
\ASLExample{\semanticstests/SemanticsRule.ATCValue.asl}

\subsubsection{Example}
\ASLExample{\semanticstests/SemanticsRule.ATCError.asl}

\subsubsection{Example}
\lrmcomment{This is related to \identr{YCPX}:}

Dynamic error conditions only hold if the asserting type conversion is
evaluated.

In the example below, the asserting type conversion on \texttt{y} is
not a dynamic error if the invocation of \texttt{f1} returns $\False$ when
evaluated:
\ASLExample{\semanticstests/SemanticsRule.ATCNotDynamicErrorIfFalse.asl}

\subsubsection{Example}
The following excerpts indicates several points where various static and
dynamic errors can occur:
\ASLExample{\semanticstests/SemanticsRule.ATCVariousErrors.asl}

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes an asserted type conversion expression, $\EATC(\veone, \vt)$;
\item evaluating $\veone$ in $\env$ results in $\Normal((\vv, \vgone), \newenv)$\ProseOrAbnormal;
\item evaluating whether $\vv$ has type $\vt$ in $\env$ results in $(\vb, \vgtwo)$\ProseTerminateAs{\DynErrorConfig};
\item one of the following applies:
      \begin{itemize}
      \item all of the following apply (\textsc{okay}):
            \begin{itemize}
            \item $\vb$ is the native Boolean for \True;
            \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
            \end{itemize}
      \item all of the following apply (\textsc{error}):
            \begin{itemize}
            \item $\vb$ is the native Boolean for \True;
            \item the result is a dynamic error indicating that the type assertion failed
                  (\DynamicTypeAssertionFailure).
            \end{itemize}
      \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[okay]{
  \evalexpr{\env, \veone} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vgtwo) \OrDynError\\\\
  \vb \eqname \nvbool(\True)\\
  \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalexpr{\env, \EATC(\veone, \vt)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\and
\inferrule[error]{
  \evalexpr{\env, \veone} \evalarrow \Normal((\vv, \Ignore), \Ignore)\\
  \neg\isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \Ignore)\\
  \vb \eqname \nvbool(\False)
}{
  \evalexpr{\env, \EATC(\veone, \vt)} \evalarrow \DynamicErrorVal{\DynamicTypeAssertionFailure}
}
\end{mathpar}
\CodeSubsection{\EvalATCBegin}{\EvalATCEnd}{../Interpreter.ml}

\subsubsection{SemanticsRule.IsValOfType}
\subsubsection{Prose}
\hypertarget{def-isvaloftype}{}
The relation
\[
  \isvaloftype(\overname{\envs}{\env} \aslsep \overname{\vals}{\vv} \aslsep \overname{\ty}{\vt}) \;\aslrel\;
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg}) \cup \overname{\TDynError}{\DynErrorConfig}
\]
checks whether the value $\vv$ can be stored in a variable of type $\vt$ in the environment $\env$,
resulting in a Boolean value $\vb$ and execution graph $\vg$ or a dynamic error.

This relation is used in the context of a asserted type conversion,
which means the type-checker rule \nameref{sec:TypingRule.ATC} was already applied,
thus filtering cases where the type inferred for the converted expression
does not type-satisfy $\vt$. The semantics takes this into account and
only returns \False\ in cases where dynamic information is required.

One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{type\_equal}):
  \begin{itemize}
    \item the AST label of $\vt$ is not $\TInt$, $\TBits$, or $\TTuple$;
    \item $\vb$ is \True (since \nameref{sec:TypingRule.ATC}
    succeeds in these cases only if the \structure\ of the type of the expression and the \structure\ of the type asserted against are \typeequivalent);
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item All of the following apply (\textsc{int\_unconstrained}):
  \begin{itemize}
    \item $\vt$ has the structure of the unconstrained integer;
    \item $\vb$ is \True;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item All of the following apply (\textsc{int\_wellconstrained}):
  \begin{itemize}
    \item $\vt$ has the structure of a well-constrained integer with constraints $\vc_{1..k}$;
    \item $\vv$ is the \nativevalue\  integer for $n$;
    \item the evaluation of every constraint $\vc_i$ with $n$ in environment $\env$
    yields a Boolean value $\vb_i$ and an execution graph $\vg_i$\ProseOrError;
    \item $\vb$ is the Boolean disjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\vt$ is a tuple with types $\vt_i$, for $i=1..k$;
    \item the value at every index $i=1..k$ of $\vv$ is $\vu_i$, for $i=1..k$,
    \item the evaluation of $\isvaloftype$ for every value $\vu_i$
    and corresponding type $\vt_i$, for $i=1..k$,
    results in a Boolean $\vb_i$ and execution graph $\vg_i$\ProseOrError;
    \item $\vb$ is the Boolean conjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
    of the constraints.
  \end{itemize}
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule[type\_equal]{
  \astlabel(\vt) \not\in \{\TInt, \TBits\}
}{
  \isvaloftype(\env, \vv, \vt) \evalarrow (\overname{\True}{\vb}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_unconstrained]{}{
  \isvaloftype(\env, \vv, \overname{\TInt(\unconstrained)}{\vt}) \evalarrow (\overname{\True}{\vb}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\hypertarget{def-integerconstraintsatisfied}{}
To handle \emph{well-constrained integers} (integers with a non-empty list of constraints),
we introduce the helper relation
\[
  \integerconstraintsatisfied(\overname{\envs}{\env} \aslsep \overname{\intconstraint}{\vc} \aslsep \overname{\Z}{n}) \;\aslrel\;
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg})
\]
which checks whether the integer value $n$ \emph{meets the constraint} $\vc$
(that is, whether $n$ is within the range of values defined by $\vc$) in the environment $\env$
and returns a Boolean answer $\vb$ and the execution graph $\vg$ resulting from evaluating
the expressions appearing in $\vc$:
\begin{mathpar}
\inferrule[Constraint\_Exact\_Sat]{
  \evalexprsef{\env, \ve} \evalarrow (\nvint(m), \vg) \OrDynError\\\\
  \vb \eqdef m = n
}
{
  \integerconstraintsatisfied(\env, \constraintexact(\ve), n) \evalarrow (\vb, \vg)
}
\and
\inferrule[Constraint\_Range\_Sat]{
  \evalexprsef{\env, \veone} \evalarrow (\nvint(a), \vgone) \OrDynError\\\\
  \evalexprsef{\env, \vetwo} \evalarrow (\nvint(b), \vgtwo) \OrDynError\\\\
  \vb \eqdef \choice{a \leq n \wedge n \leq b}{\True}{\False}\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}
{
  \integerconstraintsatisfied(\env, \constraintrange(\veone, \vetwo), n) \evalarrow (\vb, \vg)
}
\end{mathpar}

The use of $\evalexprsef$ is justified by checks in $\annotatetype$ verifying
that expressions in types are side-effect-free.

Finally, we can check whether an integer value satisfies any of the constraints:
\begin{mathpar}
\inferrule[int\_wellconstrained]{
  \vv \eqname \nvint(n)\\
  i=1..k: \integerconstraintsatisfied(\env, \vc_i, n) \evalarrow (\vb_i, \vg_i) \OrDynError\\\\
  \vb \eqdef \bigvee_{i=1}^k \vb_i\\
  \vg \eqdef \parallel_{i=1}^k \vg_i
}{
  \isvaloftype(\env, \vv, \overname{\TInt(\wellconstrained(\vc_{1..k}))}{\vt}) \evalarrow (\vb, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  i=1..k: \getindex(i, \vv) \evalarrow \vu_i\\
  i=1..k: \isvaloftype(\env, \vu_i, \vt_i) \evalarrow (\vb_i, \vg_i) \OrDynError\\\\
  \vb \eqdef \bigwedge_{i=1}^k \vb_i \\
  \vg \eqdef \parallel_{i=1}^k \vg_i
}{
  \isvaloftype(\env, \vv, \overname{\TTuple(i=1..k: \vt_i)}{\vt}) \evalarrow (\vb, \vg)
}
\end{mathpar}
\CodeSubsection{\EvalValOfTypeBegin}{\EvalValOfTypeEnd}{../Interpreter.ml}

Notice that these rules cover all types, including named types ($\TNamed$),
since the \typedast\ returned from \nameref{sec:TypingRule.ATC} is the \structure\ of the type
given in the specification.
%
Parameterized integers (integers with an empty set of constraints)
cannot appear as a type, since ASL syntax does not allow the following:
\begin{itemize}
\item Declaring an parameterized integer as a variable,
\item Declaring an alias to an parameterized integer type, and
\item Declaring an parameterized integer in a compound type.
\end{itemize}

\section{Pattern Matching Expressions\label{sec:PatternMatchingExpressions}}
The binary operator $\Tin$ tests whether a value (referred to as the discriminant) matches any item from a $\Npatternset$.
Patterns can also be used to test whether an expression matches a bitmask (via $\Teq$) or does not match a bitmask (via $\Tneq$).
Lists of patterns are also used in case statements.
%
\chapref{PatternMatching} goes into the details of the various types of patterns that can be matched against.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tin \parsesep \Npatternset &\\
              |\  & \Nexpr \parsesep \Teqop \parsesep \Tmasklit &\\
              |\  & \Nexpr \parsesep \Tneq \parsesep \Tmasklit &\\
\Npatternset \derives \  & \Tbnot \parsesep \Tlbrace \parsesep \Npatternlist \parsesep \Trbrace &\\
                  |\    & \Tlbrace \parsesep \Npatternlist \parsesep \Trbrace &\\
\Npatternlist \derives \ & \NClist{\Npattern} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EPattern(\expr, \pattern) &
\end{flalign*}

\subsubsection{ASTRule.EPattern}
\begin{mathpar}
\inferrule{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildpatternset(\vps) \astarrow \astversion{\vps} \OrBuildError
}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tin, \vps : \Npatternset)}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astversion{\ve}, \astversion{\vps})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq]{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Nexpr}, \Teq, \Tmasklit(\vm))}{\vparsednode}) \astarrow
  \overname{\EPattern(\astof{\vexpr}, \PatternMask(\vm))}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neq]{}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\punnode{\Nexpr}, \Tneq, \Tmasklit(\vm))}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astof{\vexpr}, \PatternNot(\PatternMask(\vm)))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsubsection{ASTRule.PatternSet\label{sec:ASTRule.PatternSet}}
\hypertarget{build-patternset}{}
The function
\[
  \buildpatternset(\overname{\parsenode{\Npatternset}}{\vparsednode}) \;\aslto\; \overname{\pattern}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[not]{}{
  {
    \begin{array}{r}
  \buildpatternset(\Npatternset(\Tbnot, \Tlbrace, \punnode{\Npatternlist}, \Trbrace)) \astarrow\\
  \overname{\PatternNot(\astof{\vpatternlist})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[list]{}{
  \buildpatternset(\Npatternset(\Tlbrace, \punnode{\Npatternlist}, \Trbrace)) \astarrow
  \overname{\astof{\vpatternlist}}{\vastnode}
}
\end{mathpar}

\subsubsection{ASTRule.PatternList \label{sec:ASTRule.PatternList}}
\hypertarget{build-patternlist}{}
The function
\[
  \buildpatternlist(\overname{\parsenode{\Npatternlist}}{\vparsednode}) \;\aslto\; \overname{\pattern}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildclist[\buildpattern](\vpatterns) \astarrow \vpatternasts
}{
  {
    \begin{array}{r}
  \buildpatternlist(\Npatternlist(\namednode{\vpatterns}{\NClist{\Npattern}})) \astarrow\\
  \overname{\PatternAny(\vpatternasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.EPattern\label{sec:TypingRule.EPattern}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a pattern expression to test whether $\veone$ matches the pattern $\vpat$, that is, \\ $\EPattern(\veone, \vpat)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vtetwo, \vetwo, \vsese)$\ProseOrTypeError;
  \item applying $\annotatepattern$ to $\vtetwo$ and $\vpat$ in $\tenv$ yields $(\vpatp, \vsespat)$\ProseOrTypeError;
  \item define $\vt$ as $\TBool$;
  \item define $\newe$ as the pattern expression for $\vetwo$ and the pattern $\vpatp$, that is, \\
        $\EPattern(\vetwo, \vpatp)$;
  \item define $\vses$ as the union of $\vsese$ and $\vsespat$ (there is no need to check for conflicts,
        since the $\veone$ is evaluated before $\vpat$, see \nameref{sec:SemanticsRule.EPattern}).
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtetwo, \vetwo, \vsese) \OrTypeError\\\\
  \annotatepattern(\tenv, \vtetwo, \vpat) \typearrow (\vpatp, \vsespat) \OrTypeError\\\\
  \vses \eqdef \vsese \cup \vsespat
}{
  \annotateexpr{\tenv, \overname{\EPattern(\veone, \vpat)}{\ve}} \typearrow (\overname{\TBool}{\vt}, \overname{\EPattern(\vetwo, \vpatp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\EPatternBegin}{\EPatternEnd}{../Typing.ml}

\subsection{Semantics}
\subsubsection{SemanticsRule.EPattern \label{sec:SemanticsRule.EPattern}}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.EPatternFALSE.asl}
the expression \texttt{42 IN \{0..3, -4\}} evaluates to the value $\nvbool(\False)$.

\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.EPatternTRUE.asl}
the expression \texttt{42 IN \{0..3, 42\}} evaluates to $\nvbool(\True)$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a pattern expression, $\EPattern(\ve, \vp)$;
  \item evaluating the expression $\ve$ in an environment $\env$ results in \\
  $\Normal((\vvone, \vgone), \newenv)$\ProseOrAbnormal;
  \item evaluating whether the pattern $\vp$ matches the value $\vvone$ in $\env$
  results in $\Normal(\vv, \vgtwo)$ where is a native Boolean that determines
  whether the is indeed a match;
  \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \newenv) \OrAbnormal\\
  \evalpattern{\env, \vvone, \vp} \evalarrow \Normal(\vv, \vgtwo)\\
  \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalexpr{\env, \EPattern(\ve, \vp)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEPatternBegin}{\EvalEPatternEnd}{../Interpreter.ml}

\section{Arbitrary Value Expressions\label{sec:ArbitraryValueExpressions}}
An expression of the form \texttt{ARBITRARY: ty} evaluates to an arbitrary value in the
domain of \texttt{ty}.
Each evaluation can produce a different arbitrary value, but (as always) once a particular expression is evaluated, its arbitrary value cannot change.
This is because evaluation produces native values, and \ARBITRARY{} is not a valid native value---so once evaluated, it becomes an unchanging native value like any other.

Note that there are two important consequences of producing an arbitrary value when evaluating expressions of the form \texttt{ARBITRARY: ty}:
\begin{enumerate}
  \item The arbitrary value depends only on \texttt{ty}, and no other ASL storage elements.
  \item The only guarantee of the resulting value is that it is a valid member of \texttt{ty}.
    In particular, the language does not define which valid member it is, and ASL specifications must not rely on the value (for example, there is no way to test whether a value was produced by evaluating \ARBITRARY{}).
\end{enumerate}


\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tarbitrary \parsesep \Tcolon \parsesep \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EArbitrary(\ty) &
\end{flalign*}

\subsubsection{ASTRule.EArbitrary}
\begin{mathpar}
\inferrule{
  \buildty(\vt) \astarrow \astversion{\vt} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\Tarbitrary, \Tcolon, \vt : \Nty)}{\vparsednode}) \astarrow
  \overname{\EArbitrary(\astversion{\vt})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.EArbitrary \label{sec:TypingRule.EArbitrary}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes an expression \ARBITRARY\ of type $\tty$, that is, $\EArbitrary(\tty)$;
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyone, \vsesty)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\ttyone$ in $\tenv$ yields $\ttytwo$\ProseOrTypeError;
  \item $\vt$ is $\ttyone$;
  \item define $\newe$ as an expression \ARBITRARY\ of type $\ttytwo$, that is, $\EArbitrary(\ttytwo)$;
  \item define $\vses$ as the union of $\vsesty$ and the singleton set for the \NonDeterministicTerm.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \tty} \typearrow (\ttyone, \vsesty) \OrTypeError\\\\
  \tstruct(\tenv, \ttyone) \typearrow \ttytwo \OrTypeError\\\\
  \vses \eqdef \vsesty \cup \{ \NonDeterministic \}
}{
  \annotateexpr{\tenv, \EArbitrary(\tty)} \typearrow (\ttyone, \EArbitrary(\ttytwo), \vses)
}
\end{mathpar}
\CodeSubsection{\EArbitraryBegin}{\EArbitraryEnd}{../Typing.ml}

\subsection{Semantics}
\subsubsection{SemanticsRule.EArbitrary\label{sec:SemanticsRule.EArbitrary}}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.EArbitraryInteger3.asl}
the expression \texttt{[ARBITRARY : integer]} evaluates to an integer value.

\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.EArbitraryIntegerRange3-42-3.asl}
the expression \verb|ARBITRARY : integer {3, 42}| evaluates to either $\nvint(3)$ or $\nvint(42)$.

\subsubsection{Example}
The specification:
\ASLExample{\semanticstests/SemanticsRule.EArbitraryArray.asl}
demonstrates how to obtain an arbitrary integer-indexed array, \texttt{int\_array},
and how to obtain an arbitrary enumeration-indexed array, \texttt{enum\_array}.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the \texttt{ARBITRARY} expression annotated with type $\vt$;
  \item $\vv$ is an arbitrary value in the domain of $\vt$ in $\env$ (see \secref{DynDomain});
  \item $\newenv$ is $\env$.
  \item $\vg$ is the empty execution graph.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \vv \in \dynamicdomain(\env, \vt)
}{
  \evalexpr{\env, \overname{\EArbitrary (\vt)}{\ve}} \evalarrow \Normal((\vv, \overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalEArbitraryBegin}{\EvalEArbitraryEnd}{../Interpreter.ml}

\subsubsection{Comments}
Notice that this rule introduces non-determinism.
\lrmcomment{This is related to \identr{WLCH}:}

\section{Structured Type Construction Expressions\label{sec:StructuredTypeConstructionExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tidentifier \parsesep \Tlbrace \parsesep \Trbrace &\\
	       |\ & \Tidentifier \parsesep \Tlbrace \parsesep \NClist{\Nfieldassign} \parsesep \Trbrace &\\
\Nfieldassign \derives \ & \Tidentifier \parsesep \Teq \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ERecord(\overtext{\ty}{record type}, \overtext{(\identifier, \expr)^{*}}{field initializers}) &
\end{flalign*}

\subsubsection{ASTRule.ERecord}
\begin{mathpar}
  \inferrule[empty]{}{
    {
      \begin{array}{r}
    \buildexpr(\overname{\Nexpr(
    \begin{array}{l}
    \Tidentifier(\vt), \Tlbrace, \Trbrace
    \end{array}
    )}{\vparsednode}) \\
    \astarrow\ \overname{\ERecord(\TNamed(\vt), \emptylist)}{\vastnode}
\end{array}
}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_empty]{
    \buildclist[\buildfieldassign](\vfieldassigns) \astarrow \vfieldassignasts
  }{
    {
      \begin{array}{r}
  \buildexpr\left(\overname{\Nexpr\left(
    \begin{array}{l}
    \Tidentifier(\vt), \Tlbrace, \\
    \wrappedline\ \namednode{\vfieldassigns}{\NClist{\Nfieldassign}}, \\
    \wrappedline\ \Trbrace
    \end{array}
    \right)}{\vparsednode}\right) \\
    \astarrow\ \overname{\ERecord(\TNamed(\vt), \vfieldassignasts)}{\vastnode}
\end{array}
}
}
\end{mathpar}

\subsubsection{ASTRule.FieldAssign\label{sec:ASTRule.FieldAssign}}
\hypertarget{build-fieldassign}{}
The function
\[
  \buildfieldassign(\overname{\parsenode{\Nfieldassign}}{\vparsednode}) \;\aslto\; \overname{(\identifier\times\expr)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildfieldassign(\Nfieldassign(\Tidentifier(\id), \Teq, \punnode{\Nexpr})) \astarrow
  \overname{(\id, \astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.ERecord\label{sec:TypingRule.ERecord}}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes the record construction expression (which is also used for creating exceptions) of type $\tty$ with fields $\fields$,
        that is, $\ERecord(\tty, \vfields)$;
  \item obtaining the \underlyingtype\ of $\tty$ in $\tenv$ yields $\ttyanon$\ProseOrTypeError;
  \item checking that $\ttyanon$ is a \structuredtype\ yields $\True$\ProseOrTypeError;% \ProseTerminateAs{\TypeErrorVal{\ExpectedStructuredType}};
  \item $\ttyanon$ is a \structuredtype\ with a list of $\field$ elements (consisting of a field name and a field type);
  \item obtaining the list of field names from $\vfields$ yields the list of identifiers \\
        $\initializedfields$;
  \item obtaining the list of field names from $\fieldtypes$ yields the list of identifiers $\names$;
  \item checking whether the set of identifiers in $\names$ is equal to the set of identifiers in $\initializedfields$
        yields $\True$\ProseOrTypeError;
  \item checking that the list $\initializedfields$ does not contain duplicates yields \\
        $\True$\ProseOrTypeError;
  \item applying $\annotatefieldinit$ to annotate each $\field$ element $(\name,\vep)$ of \\
        $\vfields$ in $\tenv$ yields $(\name,\ve_\name,\vxs_\name)$\ProseOrTypeError;
  \item define $\fieldsp$ as the list containing $(\name,\ve_\name)$ for each $\field$ element $(\name,\vep)$ of $\vfields$;
  \item $\vt$ is $\tty$;
  \item define $\newe$ as the record expression with type $\tty$ and field initializers $\fieldsp$, that is, $\ERecord(\tty, \fieldsp)$;
  \item define $\vsess$ as the list of \sideeffectdescriptorsetsterm\ given by $\vxs_\name$ for each $\field$ element $(\name,\Ignore)$ of $\vfields$;
  \item \Prosenonconflictingunion{$\vsess$}{$\vses$}.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed}{NamedTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \tty) \typearrow \ttyanon \OrTypeError\\\\
  \checktrans{\astlabel(\ttyanon) \in \{\TRecord, \TException\}}{\ExpectedStructuredType} \typearrow \True\OrTypeError\\\\
  \ttyanon \eqname L(\fieldtypes)\\
  \initializedfields \eqdef \{\name \;|\; (\name, \Ignore)\in\vfields\}\\
  \names \eqdef \fieldnames(\fieldtypes)\\
  \checktrans{\{\names\} = \{\initializedfields\}}{\MissingFieldInitializer} \typearrow \True \OrTypeError\\\\
  \checknoduplicates(\initializedfields) \typearrow \True \OrTypeError\\\\
  {
    \begin{array}{r}
  (\name, \vep) \in \vfields: \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow \\
  (\name, \ve_\name, \vxs_\name) \OrTypeError
    \end{array}
  }\\
  \fieldsp \eqdef [(\name, \vep) \in \fields : (\name, \ve_\name)]\\
  \vsess \eqdef [(\name, \Ignore) \in \fields : \vxs_\name]\\
  \nonconflictingunion(\vsess) \typearrow \vses \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ERecord(\tty, \vfields)}{\ve}} \typearrow
  (\overname{\tty}{\vt}, \overname{\ERecord(\tty, \fieldsp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ERecordBegin}{\ERecordEnd}{../Typing.ml}
\lrmcomment{This is related to \identr{WBCQ}.}

\hypertarget{def-annotatefieldinit}{}
\subsubsection{TypingRule.AnnotateFieldInit}
The function
\[
\begin{array}{r}
  \annotatefieldinit(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\identifier\times\expr)}{(\name, \vep)} \aslsep
    \overname{\field^*}{\fieldtypes}
  ) \aslto \\
  (\overname{\identifier}{\name} \times \overname{\expr}{\vepp} \times \overname{\TSideEffectSet}{\vses})
\end{array}
\]
annotates a field initializers $(\name, \vep)$ in a record expression
with list of fields \\ $\fieldtypes$ and returns the annotated initializing expression $\vepp$
and its \sideeffectdescriptorterm\ $\vses$. \ProseOtherwiseTypeError

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vtp, \vepp, \vses)$\ProseOrTypeError;
  \item checking whether there exists a type associated with $\name$ in $\fieldtypes$ yields $\True$\ProseOrTypeError;
  \item the unique type associated with $\name$ in $\fieldtypes$ is $\tspecp$;
  \item determining whether $\vtp$ \typesatisfies\ $\tspecp$ in $\tenv$ yields $\True$\ProseOrTypeError;
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vtp, \vepp, \vses) \OrTypeError\\\\
  \checktrans{\fieldtype(\fieldtypes, \name) \neq \bot}{MissingFieldInitializer} \typearrow \True \OrTypeError\\\\
  \fieldtype(\fieldtypes, \name) = \tspecp\\
  \checktypesat(\tenv, \vtp, \tspecp) \typearrow \True \OrTypeError
}{
  \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow (\name, \vepp, \vses)
}
\end{mathpar}

\subsection{Semantics}
\subsubsection{SemanticsRule.ERecord \label{sec:SemanticsRule.ERecord}}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.ERecord.asl}
the expression \verb|MyRecordType{a=3, b=42}| evaluates to the native record value \\
$\nvrecord{\va\mapsto\nvint(3), \vb\mapsto\nvint(42)}$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
\item $\ve$ denotes a record creation expression, $\ERecord(\names, \efields)$;
\item the names of the fields are $\id_{1..k}$;
\item the expressions associated with the fields are $\ve_{1..k}$;
\item evaluating the expressions of $\fields$ in order yields \\
      $\Normal((\vvfields,\vg), \newenv)$\ProseOrAbnormal;
\item $\vvfields$ is a list of \nativevalues\ $\vv_{1..k}$;
\item $\vv$ is the native record that maps $\id_i$ to $\vv_i$, for $i=1..k$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \efields \eqname [i=1..k: (\id_i, \ve_i)]\\
  \names \eqdef \id_{1..k} \\
  \fields \eqdef \ve_{1..k} \\
  \evalexprlist{\env, \fields} \evalarrow \Normal((\vvfields,\vg), \newenv)  \OrAbnormal\\
  \vvfields \eqname \vv_{1..k}\\
  \vv \eqdef \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}}
}{
  \evalexpr{\env, \ERecord(\Ignore, \efields)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalERecordBegin}{\EvalERecordEnd}{../Interpreter.ml}

\section{Tuple Expressions\label{sec:TupleExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Plisttwo{\Nexpr} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ETuple(\expr^{+}) &
\end{flalign*}

\subsubsection{ASTRule.ETuple}
\begin{mathpar}
\inferrule[tuple]{
  \buildplist[\buildexpr](\vexprs) \astarrow \vexprasts
}{
  \buildexpr(\overname{\Nexpr(\namednode{\vexprs}{\Plisttwo{\Nexpr}})}{\vparsednode}) \astarrow
  \overname{\ETuple(\vexprasts)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\subsubsection{TypingRule.ETuple \label{sec:TypingRule.ETuple}}
\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{parenthesized}):
  \begin{itemize}
    \item $\ve$ denotes a tuple expression with list of expressions consisting solely of $\vep$, that is, $\ETuple([\vep])$,
          meaning it represents a parenthesized expression (see \nameref{sec:ASTRule.ParenExpr});
    \item annotating $\vep$ in $\tenv$ yields $(\vt, \newe, \vses)$\ProseOrTypeError.
  \end{itemize}

  \item All of the following apply (\textsc{list}):
  \begin{itemize}
    \item $\ve$ denotes a tuple expression with list of expressions $\vli$, that is, $ \ETuple(\vli)$;
    \item $\vli$ consists of at least two expressions;
    \item annotating each expression $\vle[i]$ in $\tenv$, for $i=1..k$, yields $(\vt_i, \ve_i, \vxs_i$)\ProseOrTypeError;
    \item $\vt$ is the tuple type with list of types $\vt_i$, for $i=1..k$;
    \item $\newe$ is tuple expression over list of expressions $\ve_i$, for $i=1..k$;
    \item \Prosenonconflictingunion{consisting of $\vxs_i$, for $i=1..k$,}{$\vses$}\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[parenthesized]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ETuple(\vep)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[list]{
  |\vli| > 1\\
  i=1..k: \annotateexpr{\tenv, \vle[i]} \typearrow (\vt_i, \ve_i, \vxs_i) \OrTypeError\\\\
  \nonconflictingunion(i=1..k: \vxs_i) \typearrow \vses \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ETuple(\vli)}{\ve}} \typearrow (\overname{\TTuple(\vt_{1..k})}{\vt}, \overname{\ETuple(\ve_{1..k})}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ETupleBegin}{\ETupleEnd}{../Typing.ml}

\subsection{Semantics}
\subsubsection{SemanticsRule.ETuple \label{sec:SemanticsRule.ETuple}}
\subsubsection{Example}
In the specification:
\ASLExample{\semanticstests/SemanticsRule.ETuple.asl}
the expression \texttt{(3, Return42())} evaluates to the value \texttt{(3, 42)}.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ denotes a tuple expression, $\ETuple(\elist)$;
  \item the evaluation of $\elist$ in $\env$ is $\Normal((\vlist, \vg), \newenv)$\ProseOrAbnormal;
  \item $\vv$ is the native vector constructed from the values in $\vlist$.
\end{itemize}
\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \newenv) \OrAbnormal\\
  \vv \eqdef \nvvector{\vlist}
}{
  \evalexpr{\env, \ETuple(\elist)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalETupleBegin}{\EvalETupleEnd}{../Interpreter.ml}

\section{Parenthesized Expressions\label{sec:ParenthesizedExpressions}}
A single expression inside parentheses is not considered to be a tuple, but rather the element
inside the parenthesis.
Parenthesizing an expression can be used to improve readability, enforce an order of evaluation,
and avoid binary operator precedence errors (see \nameref{sec:ASTRule.CheckNotSamePrec}).

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tlpar \parsesep \Nexpr \parsesep \Trpar &
\end{flalign*}

\subsection{Abstract Syntax}
We represent a parenthesized expression as a single element tuple for the technical
reason of enabling \nameref{sec:ASTRule.CheckNotSamePrec} by distinguishing parenthesized
expressions from non-parenthesized expressions. However, upon typing such expressions,
we ignore the parenthesis (see \nameref{sec:TypingRule.ETuple}.\textsc{PARENTHESIZED}).

\subsubsection{ASTRule.ParenExpr\label{sec:ASTRule.ParenExpr}}
\begin{mathpar}
  \inferrule[sub\_expr]{}{
  \buildexpr(\overname{\Nexpr(\Tlpar, \punnode{\Nexpr}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\ETuple([\ \astof{\vexpr}\ ])}{\vastnode}
}
\end{mathpar}

\section{Array Construction Expressions\label{sec:ArrayConstructionExpressions}}
Array construction expression are used by the type system to express the initialization
of array-typed variables. Since there is no syntax to initialize arrays, there are also
no rules for building the AST for such expressions nor rules for type-checking them.

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EArray\{\EArrayLength: \expr, \EArrayValue: \expr\} &\\
             |\ & \EEnumArray \{\EArrayLabels: \identifier^+, \EArrayValue: \expr\}
\end{flalign*}

\subsection{Semantics}

The Semantic Rules use $\evalexprsef\empty$ because the type-checker in
$\annotatetype$ guarantees that expressions in types are side-effect-free.

\subsubsection{SemanticsRule.EArray}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ is an array construction expression with length expression $\elength$ and value expression $\evalue$,
        that is, $\EArray\{\EArrayLength: \elength, \EArrayValue: \evalue\}$;
  \item evaluating the expression $\evalue$ in $\env$ yields $\Normal((\vvalue, \vgone), \newenv)$\ProseOrAbnormal;
  \item evaluating the side-effect-free expression $\elength$ in $\env$ yields \\
        $\Normal((\vlength, \vgtwo))$\ProseOrError;
  \item $\vlength$ is a native integer value for $\nlength$;
  \item define $\vv$ as the native vector of length $\nlength$ where each position has the value $\vvalue$;
  \item define $\vg$ as the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \evalue} \evalarrow \Normal((\vvalue, \vgone), \newenv) \OrAbnormal\\\\
  \evalexprsef{\env, \elength} \evalarrow \Normal((\vlength, \vgtwo)) \OrDynError\\\\
  \vlength \eqname \nvint(\nlength)\\
  \vv \eqdef \nvvector{i=1..\nlength: \vvalue}\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr{\env, \overname{\EArray\{\EArrayLength: \elength, \EArrayValue: \evalue\}}{\ve}} \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEArrayBegin}{\EvalEArrayEnd}{../Typing.ml}

\subsubsection{SemanticsRule.EEnumArray}
\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\ve$ is an array construction expression for an enumerated-index array with
        list of labels $\vlabels$ and value expression $\evalue$,
        that is, \\
        $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \evalue\}$;
  \item evaluating the expression $\evalue$ in $\env$ yields $\Normal((\vvalue, \vg), \newenv)$\ProseOrAbnormal;
  \item \Proseeqdef{$\vv$}{the native record mapping each label $\vl\in\vlabels$ to $\vvalue$}.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \evalue} \evalarrow \Normal((\vvalue, \vg), \newenv) \OrAbnormal\\\\
  \vv \eqdef \nvrecord{\vl\in\vlabels: [\vl\mapsto \vvalue]}
}{
  {
  \begin{array}{r}
    \evalexpr{\env, \overname{\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \evalue\}}{\ve}} \evalarrow\\
    \Normal((\vv, \vg), \newenv)
  \end{array}
  }
}
\end{mathpar}

\CodeSubsection{\EvalEEnumArrayBegin}{\EvalEEnumArrayEnd}{../Typing.ml}

\section{Side-effect-free Expressions\label{sec:SideEffectFreeExpressions}}
\subsection{Typing}
An expression $\ve$ is considered to be side-effect-free in the static environment $\tenv$
if $\annotateexpr{\tenv, \ve} \typearrow (\Ignore, \Ignore, \vses)$
and $\vses$ only contains \sideeffectdescriptorsterm\ for reading storage (\ReadLocal\ and \ReadGlobal).

\subsection{Semantics}
\subsubsection{SemanticsRule.ESideEffectFreeExpr\label{sec:SemanticsRule.ESideEffectFreeExpr}}
\subsubsection{Prose}
The helper relation
\hypertarget{def-evalexprsef}{}
\[
  \evalexprsef{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
  \Normal(\overname{\vals}{\vv}\aslsep\overname{\XGraphs}{\vg}) \cup
  \overname{\TDynError}{\DynErrorConfig}
\]
specializes the expression evaluation relation for side-effect-free expressions
by omitting throwing configurations as possible output configurations.

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv,\vg), \env) \OrDynError
}{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\vv, \vg)
}
\end{mathpar}
Notice that the output configuration does not contain an environment,
since side-effect-free expressions do not modify the environment.

\section{Evaluating a List of Expressions\label{sec:ExprList}}
\subsubsection{SemanticsRule.EExprList\label{sec:SemanticsRule.EExprList}}
\subsubsection{Prose}
The relation
\hypertarget{def-evalexprlist}{}
\[
  \evalexprlist{\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vle}} \;\aslrel\;
  \Normal((\overname{\vals^*}{\vv} \times \overname{\XGraphs}{\vg})\aslsep \overname{\envs}{\newenv}) \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the list of expressions $\vle$ in left-to-right order in the initial environment $\env$
and returns the resulting value $\vv$, the parallel composition of the execution graphs
generated from evaluating each expression, and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.

\subsubsection{Formally}
\begin{mathpar}
\inferrule[empty]{}
{
  \evalexprlist{\env, \emptylist} \evalarrow \Normal((\emptylist, \emptygraph), \env)
}
\end{mathpar}

\begin{mathpar}
\inferrule[nonempty]{
  \texttt{le} \eqname [\ve] \concat \vle1\\
  \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \envone) \OrAbnormal\\
  \evalexprlist{\envone, \vle1} \evalarrow \Normal((\vvs, \vgtwo), \newenv) \OrAbnormal\\
  \vg \eqdef \vgone \parallelcomp \vgtwo \\
  \vv \eqdef [\vvone] \concat \vvs
}{
  \evalexprlist{\env, \vle} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
