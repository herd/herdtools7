\chapter{Expressions\label{chap:Expressions}}

\hypertarget{def-rhsexpression}{}
Expressions calculate values.
Expressions can have side effects and can raise exceptions.
Therefore, ASL specifies an evaluation order to ensure that the side-effects/exceptions are predictable (see \secref{EvaluationOrder}).

Expressions are grammatically derived from $\Nexpr$ and represented as ASTs by $\expr$.
We will often refer to expressions defined in this chapter as \rhsexpressions\ to distinguish them
from \assignableexpressions, which are defined in \chapref{AssignableExpressions}.

\hypertarget{build-expr}{}
The function
\[
  \buildexpr(\overname{\parsenode{\Nexpr}}{\vparsednode}) \;\aslto\; \overname{\expr}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms an expression parse node $\vparsednode$ into an expression AST node $\vastnode$.
\ProseOtherwiseBuildError

All expressions have a unique type (which can be a \tupletypeterm{}).
\hypertarget{def-annotateexpr}{}
The function
\[
  \annotateexpr{\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}}
  \aslto (\overname{\ty}{\vt} \times \overname{\expr}{\newe} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
specifies how to annotate an expression $\ve$ in
an environment \tenv.  The result of annotating the expression
$\ve$ in \tenv\ is the tuple $(\vt, \newe, \vses)$, where $\vt$ is the type inferred
for $\ve$,
$\newe$ is the \typedast\ for $\ve$, also known as the \emph{annotated expression}, and
$\vses$ is the \sideeffectsetterm\ inferred for $\ve$.
\ProseOtherwiseTypeError

The annotation rewrites the input expression in the following case, making the annotation of statements simpler:
variables with constant values are substituted by their constant values.

The relation
\hypertarget{def-evalexpr}{}
\[
  \evalexpr{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
            \Normal((\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg}) \aslsep \overname{\envs}{\newenv}) \cup
            \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the expression $\ve$ in an environment $\env$ and terminates normally with
a \nativevalue{} $\vv$, an \executiongraph{} $\vg$, and a modified environment $\newenv$.
Otherwise, the evaluation terminates abnormally.

The rest of this chapter defines the syntax, abstract syntax, typing,
and semantics of the following kinds of expressions:
\begin{itemize}
  \item Literal expressions (see \secref{LiteralExpressions})
  \item Variable expressions (see \secref{VariablExpressions})
  \item Binary expressions (see \secref{BinaryExpressions})
  \item Unary expressions (see \secref{UnaryExpressions})
  \item Conditional expressions (see \secref{ConditionalExpressions})
  \item Call expressions (see \secref{CallExpressions})
  \item Slicing expressions (see \secref{SlicingExpressions})
  \item Array access expressions (see \secref{ArrayAccessExpressions})
  \item Field reading expressions (see \secref{FieldReadingExpressions})
  \item Multi-field reading expressions (see \secref{MultiFieldReadingExpressions})
  \item Asserting type conversion expressions (see \secref{AssertingTypeConversionExpressions})
  \item Pattern matching expressions (see \secref{PatternMatchingExpressions})
  \item Arbitrary value expressions (see \secref{ArbitraryValueExpressions})
  \item Structured type construction expressions (see \secref{StructuredTypeConstructionExpressions})
  \item Tuple expressions (see \secref{TupleExpressions})
  \item Parenthesized expressions (see \secref{ParenthesizedExpressions})
  \item Array construction expressions (see \secref{ArrayConstructionExpressions})
\end{itemize}

Finally, we define side-effect-free expressions (see \secref{SideEffectFreeExpressions})
and define how to evaluate a list of expressions (see \secref{ExprList}).

\hypertarget{def-literalexpressionterm}{}
\section{Literal Expressions\label{sec:LiteralExpressions}}
A literal expression represents a literal as an expression.

\ASLListing{Literal Expressions}{literalssemantics}{\semanticstests/SemanticsRule.Lit.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nvalue &\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ELiteral(\literal) &
\end{flalign*}

\ASTRuleDef{ELit}
\begin{mathpar}
\inferrule{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Nvalue})}{\vparsednode}) \astarrow
  \overname{\ELiteral(\astof{\vvalue})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ELit}
\ExampleDef{Typing of Literal Expressions}
In \listingref{literalssemantics}, each of the expressions \texttt{3}
is annotated with the type \verb|integer{3}|.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ is the literal expression $\vv$;
\item $\vt$ is the type of the literal $\vv$;
\item define $\newe$ as $\ve$;
\item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateliteral{\tenv, \vv} \typearrow \vt
}{
  \annotateexpr{\tenv, \overname{\ELiteral(\vv)}{\ve}} \typearrow (\vt, \overname{\ELiteral(\vv)}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\ELitBegin}{\ELitEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{ELit}
\ExampleDef{Evaluation of Literal Expressions}
In \listingref{literalssemantics}, each of the expressions \texttt{3} evaluates to the \nativevalue\ $\nvint(3)$.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ is the literal expression for $\vl$, that is, $\ELiteral(\vl)$
\item $\vv$ is the \nativevalue\ corresponding to $\vl$;
\item $\vg$ is the empty graph, as literals do not yield any Read and Write Effects;
\item $\newenv$ is $\env$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \evalexpr{\env, \overname{\ELiteral(\vl)}{\ve}} \evalarrow \Normal((\overname{\nvliteral{\vl}}{\vv},\overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalELitBegin}{\EvalELitEnd}{../Interpreter.ml}

\hypertarget{def-variableexpressionterm}{}
\section{Variable Expressions\label{sec:VariablExpressions}}
A variable expression consists of an identifier for a storage element.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EVar(\overtext{\identifier}{variable name}) &
\end{flalign*}

\ASTRuleDef{EVAR}
\begin{mathpar}
  \inferrule{}{
  \buildexpr(\overname{\Nexpr(\Tidentifier(\id))}{\vparsednode}) \astarrow
  \overname{\EVar(\id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EVar}
\ExampleDef{Typing Variable Expressions}
All of the variable expressions in \listingref{expressions-evar}
are well-typed.
\ASLListing{Variable expressions}{expressions-evar}{\typingtests/TypingRule.EVar.asl}

The type system annotates the expression \verb|LOCAL_CONSTANT| as the literal for \verb|7|,
since it is declared as a \verb|constant|, whereas the expression \verb|var_x|
on the right-hand-side of the assignment \verb|var y = var_x;| is annotated as \verb|var_x|,
since \verb|var_x| is not declared as a \verb|constant|.

The variable \texttt{t} in \listingref{expressions-evar-undefined} is undefined.
\ASLListing{An undefined variable}{expressions-evar-undefined}{\typingtests/TypingRule.EVar.undefined.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{local\_constant}
    \begin{itemize}
    \item $\vx$ is bound to the type $\vt$ and local declaration keyword $\LDKConstant$
          via the $\localstoragetypes$ map of the local environment component of $\tenv$;
    \item $\vx$ is bound to the literal $\vv$ via the $\constantvalues$ map of the local environment of $\tenv$;
    \item define $\newe$ as the literal expression for $\vv$, that is $\eliteral{\vv}$;
    \item define $\vses$ as the empty set.
    \end{itemize}

    \item \AllApplyCase{local\_non\_constant}
    \begin{itemize}
    \item $\vx$ is bound to the type $\vt$ and local declaration keyword $k$
          via the \\
          $\localstoragetypes$ map of the local environment component of $\tenv$;
    \item either $k$ is different from $\LDKConstant$ or
          $\vx$ is not bound in the \\
          $\constantvalues$ map of the local environment of $\tenv$;
    \item define $\newe$ as $\ve$;
    \item define $\vses$ as the singleton set for the \ReadLocalTerm\ for $\vx$ the \timeframeterm\ of
          $k$ ($\timeframeofldk$) and the immutability status of $k$ ($\ldkisimmutable$).
    \end{itemize}

    \item \AllApplyCase{global\_constant}
    \begin{itemize}
    \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
    \item $\vx$ is bound to $(\tty, \GDKConstant)$ via the $\globalstoragetypes$ map of the global component of $\tenv$;
    \item $\vx$ is bound to $\vv$ via the $\constantvalues$ map of the global component of $\tenv$;
    \item define $newe$ as the literal expression for $\vv$;
    \item define $\vses$ as the empty set.
    \end{itemize}

    \item \AllApplyCase{global\_non\_constant}
    \begin{itemize}
      \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
      \item $\vx$ is bound to $(\tty, k)$ via the $\globalstoragetypes$ map of the global component of $\tenv$;
      \item either $\vx$ is not bound in the $\constantvalues$ map of the global component of $\tenv$ or $k$ is not $\GDKConstant$;
      \item define $newe$ as $\ve$;
      \item define $\vses$ as the singleton set for the \ReadGlobalTerm\ for $\vx$ the \timeframeterm\ of
            $k$ ($\timeframeofgdk$) and the immutability status of $k$ ($\gdkisimmutable$).
    \end{itemize}

    \item \AllApplyCase{error\_undefined}
    \begin{itemize}
      \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
      \item $\vx$ is not bound via the $\globalstoragetypes$ map of the local component of $\tenv$;
      \item the result is a \typingerrorterm{} indicating that $\vx$ is an undefined identifier ($\UndefinedIdentifier$).
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local\_constant]{
  L^\tenv.\localstoragetypes(\vx) = (\vt, \LDKConstant)\\
  L^\tenv.\constantvalues(\vx) = \vv
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\vt, \overname{\eliteral{\vv}}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[local\_non\_constant]{
  L^\tenv.\localstoragetypes(\vx) =  (\vt, k) \\
  L^\tenv.\constantvalues(\vx) = \bot \lor k \neq \LDKConstant\\
  \vses \eqdef \{\ \ReadLocal(\vx, \timeframeofldk(k), \ldkisimmutable(k))\  \}
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\vt, \overname{\EVar(\vx)}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[global\_constant]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \vv
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\tty, \overname{\eliteral{\vv}}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global\_non\_constant]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, k)\\
  G^\tenv.\constantvalues(\vx) = \bot \lor k \neq \GDKConstant\\
  \vses \eqdef \{\ \ReadGlobal(\vx, \timeframeofgdk(k), \gdkisimmutable(k))\  \}
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\tty, \overname{\EVar(\vx)}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[error\_undefined]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = \bot
}{
  \annotateexpr{\tenv,\overname{\EVar(\vx)}{\ve}} \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{EVar}

\ExampleDef{Evaluation of a Local Variable Expression}
In \listingref{localvarsemantics}, the evaluation of \texttt{x} within \texttt{assert x == 3;}
uses \\ \SemanticsRuleRef{EVar}.LOCAL.
\ASLListing{Semantics of local variables}{localvarsemantics}{\semanticstests/SemanticsRule.ELocalVar.asl}

\ExampleDef{Evaluation of a Global Variable Expression}
In \listingref{globalvarsemantics}, the evaluation of~\texttt{global\_x} within~\texttt{assert global\_x == 3;}
uses the rule \SemanticsRuleRef{EVar}.GLOBAL.
\ASLListing{Semantics of global variables}{globalvarsemantics}{\semanticstests/SemanticsRule.EGlobalVar.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a variable expression, that is, $\EVar(\vx)$;
  \item view $\env$ as an environment where $\denv$ is the dynamic environment;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{local}
    \begin{itemize}
      \item $\vx$ is bound locally in $\env$;
      \item $\vv$ is the value of $\vx$ in the local component of $\env$;
    \end{itemize}

    \item \AllApplyCase{global}
    \begin{itemize}
      \item $\vx$ is bound in the storage map of $\denv$;
      \item $\vv$ is the value of $\vx$ in the global component of $\env$;
    \end{itemize}
  \end{itemize}
  \item $\newenv$ is $\env$;
  \item $\vg$ is the graph containing a single Read Effect for $\vx$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local]{
  \env \eqname (\Ignore, \denv)\\
  \vx \in \dom(L^\denv)
}{
  \evalexpr{\env, \EVar(\vx)} \evalarrow \Normal((\overname{L^\denv(\vx)}{\vv}, \overname{\ReadEffect(\vx)}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  \env \eqname (\Ignore, \denv)\\
  \vx \in \dom(G^\denv.\storage)
}{
  \evalexpr{\env, \EVar(\vx)} \evalarrow \Normal((\overname{G^\denv.\storage(\vx)}{\vv}, \overname{\ReadEffect(\vx)}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalEVarBegin}{\EvalEVarEnd}{../Interpreter.ml}

\subsubsection{Comments}
When there exists a global variable $\vx$, the type system
forbids having $\vx$ as a local variable.
This is enforced by \TypingRuleRef{LDVar} in the Chapter ``Typing of Local Declarations'',
and
\TypingRuleRef{DeclareGlobalStorage} and \TypingRuleRef{DeclareOneFunc},
both in the Chapter ``Typing of Global Declarations''.

\section{Binary Expressions\label{sec:BinaryExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Nbinop \parsesep \Nexpr &\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EBinop(\binop, \expr, \expr) &
\end{flalign*}

\ASTRuleDef{EBinop}
The following rule constructs a binary expression AST
and checks that a requirement on \emph{associative operators} holds (see \ASTRuleRef{CheckNotSamePrec}).

\begin{mathpar}
  \inferrule{
    \buildexpr(\veone) \astarrow \astversion{\veone} \OrBuildError\\\\
    \buildexpr(\vetwo) \astarrow \astversion{\vetwo} \OrBuildError\\\\
    \checknotsameprec(\astof{\vbinop}, \astversion{\veone}) \astarrow \True \OrBuildError\\\\
    \checknotsameprec(\astof{\vbinop}, \astversion{\vetwo}) \astarrow \True \OrBuildError
  }{
    {
      \begin{array}{r}
  \buildexpr(\overname{\Nexpr(\namednode{\veone}{\Nexpr}, \punnode{\Nbinop}, \namednode{\vetwo}{\Nexpr})}{\vparsednode}) \astarrow\\
  \overname{\EBinop(\astversion{\veone}, \astof{\vbinop}, \astversion{\vetwo})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\ASTRuleDef{CheckNotSamePrec}
The set of \emph{associative binary operators} consists of the following:
$\BOR$,
$\BAND$,
$\IMPL$,
$\BEQ$,
$\EQOP$,
$\NEQ$,
$\PLUS$,
$\MINUS$,
$\OR$,
$\XOR$,
$\AND$,
$\MUL$,
$\DIV$,
$\DIVRM$,
$\RDIV$,
$\MOD$,
$\SHL$,
$\SHR$,
$\POW$.

\hypertarget{build-binopprec}{}
We define the helper function
\[
  \binopprec(\overname{\binop}{\op}) \aslto \N
\]
which assigns a precedence level to each binary operator $\op$, as defined below:
\begin{mathpar}
\inferrule{}{
  {
  \binopprec(\op) \astarrow
  \begin{cases}
    0 & \text{if }\op \in \{\GT, \GEQ, \LT, \LEQ\}\\
    1 & \text{if }\op \in \{\BOR, \BAND, \IMPL, \BEQ \}\\
    2 & \text{if }\op \in \{\EQOP, \NEQ\}\\
    3 & \text{if }\op \in \{\PLUS, \MINUS, \OR, \XOR, \AND\}\\
    4 & \text{if }\op \in \{\MUL, \DIV, \DIVRM, \RDIV, \MOD, \SHL, \SHR\}\\
    5 & \text{if }\op = \POW\\
  \end{cases}
  }
}
\end{mathpar}

\hypertarget{build-checknotsameprec}{}
The function
\[
\checknotsameprec(\overname{\binop}{\op} \aslsep \overname{\expr}{\ve})
\aslto \{\True\} \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
checks whether the expression AST node $\ve$ is a binary operator of the same
\emph{precedence} as that of the binary operator $\op$. If so, it is considered
an error. Surrounding $\ve$ by parenthesis fixes the error.

For example, \texttt{a + b + c} is considered legal, since the same binary operator (\texttt{+})
is used, whereas \texttt{a + b - c} is considered illegal, since $\PLUS$ and $\MINUS$ have the
same precedence ($3$). To fix this, we can surround one of the subexpressions with parenthesis,
for example: \texttt{(a + b) - c}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{not\_binop}
  \begin{itemize}
    \item $\ve$ is not a binary operation expression;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{binop}
  \begin{itemize}
    \item $\ve$ is a binary operation expression for the operator $\opp$;
    \item checking whether $\op$ is different from $\opp$ implies that $\op$ and $\opp$ have different precedence levels
          yields $\True$\ProseTerminateAs{\BinopPrecedence}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_binop]{
  \astlabel(\ve) \neq \EBinop
}{
  \checknotsameprec(\op, \ve) \astarrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[binop]{
  \checktrans{\op \neq \opp \Longrightarrow \binopprec(\op) \neq \binopprec(\opp)}{\BinopPrecedence} \checktransarrow \True \OrBuildError
}{
  \checknotsameprec(\op, \overname{\EBinop(\opp, \Ignore, \Ignore)}{\ve}) \astarrow \True
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EBinop}
\ExampleDef{Typing of Binary Expressions}
In \listingref{typing-binoperror},
the expression \texttt{3 DIV 0} results in a \typingerrorterm{}.
\ASLListing{Evaluating a binary expression resulting in a typing error}{typing-binoperror}
{\semanticstests/SemanticsRule.EBinopDIVBackendDefinedError.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a binary operation $\op$ over two expressions $\veone$ and $\vetwo$, that is, \\ $\EBinop(\op, \veone, \vetwo)$;
  \item \Proseannotateexpr{$\tenv$}{$\veone$}{\\ $(\vtone, \veonep, \vsesone)$\ProseOrTypeError};
  \item \Proseannotateexpr{$\tenv$}{$\vetwo$}{\\ $(\vttwo, \vetwop, \vsestwo)$\ProseOrTypeError};
  \item \Proseapplybinoptypes{$\tenv$}{\op}{\vtone}{\vttwo}{$\vt$\ProseOrTypeError};
  \item define $\newe$ as the binary expression $\op$ over $\veonep$ and $\vetwop$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{ordered}
    \begin{itemize}
      \item $\op$ is one of $\BAND$, $\BOR$, or $\IMPL$;
      \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
    \end{itemize}

    \item \AllApplyCase{unordered}
    \begin{itemize}
      \item $\op$ is not one of $\BAND$, $\BOR$, or $\IMPL$;
      \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
    \end{itemize}
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[ordered]{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veonep, \vsesone) \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwop, \vsestwo) \OrTypeError\\\\
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError\\\\
  \op \in \{\BAND, \BOR, \IMPL\}\\\\
  \commonprefixline\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateexpr{\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}} \typearrow (\vt, \overname{\EBinop(\op, \veone', \vetwo')}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[unordered]{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veonep, \vsesone) \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwop, \vsestwo) \OrTypeError\\\\
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError\\\\
  \op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \commonprefixline\\\\
  \vses \eqdef \vsesone \cup \vsestwo \\
}{
  \annotateexpr{\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}} \typearrow (\vt, \overname{\EBinop(\op, \veone', \vetwo')}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\BinopBegin}{\BinopEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{BinopAnd}
\ExampleDef{Evaluation of Binary And Expressions}
In \listingref{andsemantics},
the expression \texttt{FALSE \&\& fail()} evaluates to the value \texttt{FALSE}. Notice that the function \texttt{fail} is never called.
\ASLListing{Semantics of conjunction}{andsemantics}{\semanticstests/SemanticsRule.EBinopAndFalse.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a conjunction over two expressions,
      $\EBinop(\BAND, \veone, \vetwo)$;
\item $C$ is the result of the evaluation of the expression
      \texttt{if e1 then e2 else false} (see \SemanticsRuleRef{ECond}).
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \falsep \eqdef \ELiteral(\lbool(\False))\\
  \evalexpr{\env, \ECond(\veone, \vetwo, \falsep)} \evalarrow C
}{
\evalexpr{\env, \EBinop(\BAND, \veone, \vetwo)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalBinopAndBegin}{\EvalBinopAndEnd}{../Interpreter.ml}

\subsubsection{Comments}
The evaluation via the rule above ensures that $\veone$ is evaluated first and
only if it evaluates to $\True$ is $\vetwo$ evaluated.

\identr{BKNT} % TODO: add table

\identi{QRXP}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{-->} provide a short-circuit evaluation mechanism:

% This is related to the note under \identr{LRHD}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\SemanticsRuleDef{BinopOr}
\ExampleDef{Evaluation of Binary Or Expressions}
In \listingref{semantics-binopor}, the expression \texttt{(0 == 1) || (1 == 1)} evaluates to the value \True.
\ASLListing{Evaluating a disjunction expression}{semantics-binopor}{\semanticstests/SemanticsRule.EBinopOrTrue.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a disjunction of two expressions, $\EBinop(\BOR, \veone, \vetwo)$;
\item $C$ is the result of the evaluation of
      \texttt{if e1 then true else e2} (see \SemanticsRuleRef{ECond}).
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \truep \eqdef \ELiteral(\lbool(\True))\\
  \evalexpr{\env, \ECond(\veone, \truep, \vetwo)} \evalarrow C
}{
\evalexpr{\env, \EBinop(\BOR, \veone, \vetwo)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalBinopOrBegin}{\EvalBinopOrEnd}{../Interpreter.ml}

The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
it evaluates to $\False$, is $\vetwo$ evaluated.

\subsubsection{Comments}
\identr{BKNT} % TODO: add table

\identi{QRXP}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{-->} provide a short-circuit evaluation mechanism:

% This is related to the note under \identr{LRHD}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\SemanticsRuleDef{BinopImpl}
\ExampleDef{Evaluation of Implication Expressions}
In \listingref{semantics-binopimpl},
the expression \texttt{(0 == 1) --> (1 == 0)} evaluates to the value \True, according to the definition of implication.
\ASLListing{Evaluating an implication expression}{semantics-binopimpl}{\semanticstests/SemanticsRule.EBinopImplExFalso.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an implication over two expressions, $\EBinop(\IMPL, \veone, \vetwo)$;
  \item $\ve$ is evaluated as \texttt{if e1 then e2 else true}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \truep \eqdef \ELiteral(\lbool(\True))\\
  \evalexpr{\env, \ECond(\veone, \vetwo, \truep)} \evalarrow C
}{
\evalexpr{\env, \EBinop(\IMPL, \veone, \vetwo)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalBinopImplBegin}{\EvalBinopImplEnd}{../Interpreter.ml}
The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
it evaluates to \True, is $\vetwo$ evaluated.

\lrmcomment{This is related to \identr{BKNT}: add table}

\identi{QRXP}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{-->} provide a short-circuit evaluation mechanism:

\lrmcomment{This is related to the note under \identr{LRHD}:}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\hypertarget{def-binopexpressionterm}{}
\SemanticsRuleDef{Binop}
\ExampleDef{Evaluation of Binary Expressions}
In \listingref{semantics-binopassert},
the expression \texttt{3 + 2} evaluates to the value \texttt{5}.
\ASLListing{Evaluating a binary expression}{semantics-binopassert}{\semanticstests/SemanticsRule.EBinopPlusAssert.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a Binary Operator $\op$ over two expressions, $\EBinop(\op, \veone, \vetwo)$;
  \item the operator $\op$ is not one of $\BAND$, $\BOR$, or $\IMPL$.
        These operators are handled by rules
        \SemanticsRuleRef{BinopAnd},
        \SemanticsRuleRef{BinopOr}, and
        \SemanticsRuleRef{BinopImpl};
  \item the evaluation of the expression $\veone$ in $\env$ is the configuration \\
        $\Normal(\vmone, \envone)$\ProseOrAbnormal;
  \item the evaluation of the expression $\vetwo$ in $\envone$ is the configuration \\
        $\Normal(\vmtwo, \newenv)$\ProseOrAbnormal;
  \item $\vmone$ consists of the value $\vvone$ and the execution graph $\vgone$;
  \item $\vmtwo$ consists of the value $\vvtwo$ and the execution graph $\vgtwo$;
  \item applying the Binary Operator $\op$ to $\vvone$ and $\vvtwo$ results in $\vv$\ProseOrError;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\
  \evalexpr{ \env, \veone} \evalarrow \Normal(\vmone, \envone) \OrAbnormal \\\\
  \evalexpr{ \envone, \vetwo } \evalarrow \Normal(\vmtwo, \newenv) \OrAbnormal \\\\
  \vmone \eqname (\vvone, \vgone) \\
  \vmtwo \eqname (\vvtwo, \vgtwo) \\
  \binoprel(\op, \vvone, \vvtwo) \evalarrow \vv \OrDynError\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr{ \env, \overname{\EBinop(\op, \veone, \vetwo)}{\ve} } \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalBinopBegin}{\EvalBinopEnd}{../Interpreter.ml}

The rule above applies to many binary operators, including $\EQOP$ (which is used for \texttt{<->}
as well as \texttt{==}).

\subsubsection{Comments}
\lrmcomment{This is related to \identr{BKNT}: add table}

\hypertarget{def-unopexpressionterm}{}
\section{Unary Expressions\label{sec:UnaryExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nunop \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EUnop(\unop, \expr) &
\end{flalign*}

\ASTRuleDef{EUnop}
\begin{mathpar}
  \inferrule{
    \buildexpr(\vexpr) \astarrow \astversion{\vexpr} \OrBuildError
  }{
  \buildexpr(\overname{\Nexpr(\punnode{\Nunop}, \vexpr : \Nexpr)}{\vparsednode}) \astarrow
  \overname{\EUnop(\astof{\vunop}, \astversion{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{Unop}
\ExampleRef{Applying Unary Operations to Types} shows examples
of well-typed unary operation expressions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a unary operation $\op$ over an expression $\vep$, that is $\EUnop(\op, \vep)$;
  \item annotating $\vep$ in $\tenv$ yields $(\vtpp, \vepp, \vses)$\ProseOrTypeError;
  \item checking compatibility of $\op$ with $\vtpp$ as per \TypingRuleRef{ApplyUnopType} yields $\vt$\ProseOrTypeError;
  \item define $\newe$ as $\op$ over $\vepp$, that is, $\EUnop(\op, \vepp)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vtpp, \vepp, \vses) \OrTypeError\\\\
  \applyunoptype(\tenv, \op, \vtpp) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\tenv, \EUnop(\op, \vep)} \typearrow (\vt, \EUnop(\op, \vepp), \vses)
}
\end{mathpar}
\CodeSubsection{\UnopBegin}{\UnopEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{Unop}
\ExampleDef{Evaluation of a Unary Operation Expression}
In \listingref{semantics-unopassert},
the expression \texttt{NOT '1010'} evaluates to the value \texttt{'0101'}.
\ASLListing{Evaluating a unary operation expression}{semantics-unopassert}{\semanticstests/SemanticsRule.EUnopAssert.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a unary operator $\op$ over an expression, $\EUnop(\op, \veone)$;
\item the evaluation of the expression $\veone$ in $\env$ yields \\ $\Normal((\vvone, \vg), \newenv)$\ProseOrAbnormal;
\item applying the unary operator $\op$ to $\vvone$ is $\vv$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{ \env, \veone} \evalarrow \Normal((\vvone,\vg), \newenv) \OrAbnormal\\\\
  \unoprel(\op, \vvone) \evalarrow \vv
}
{
  \evalexpr{ \env, \EUnop(\op, \veone) } \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalUnopBegin}{\EvalUnopEnd}{../Interpreter.ml}

\hypertarget{def-conditionexpressionterm}{}
\section{Conditional Expressions\label{sec:ConditionalExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nexpr \parsesep \Telse \parsesep \Nexpr &\\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ECond(\overtext{\expr}{condition}, \overtext{\expr}{then}, \overtext{\expr}{else})
\end{flalign*}

\ASTRuleDef{ECond}
\begin{mathpar}
  \inferrule{
    \buildexpr(\vcondexpr) \astarrow \astversion{\vcondexpr} \OrBuildError\\\\
    \buildexpr(\vthenexpr) \astarrow \astversion{\vthenexpr} \OrBuildError\\\\
    \buildexpr(\velseexpr) \astarrow \astversion{\velseexpr} \OrBuildError\\\\
  }{
    {
      \begin{array}{r}
  \buildexpr\left(\overname{\Nexpr\left(
    \begin{array}{l}
    \Tif, \namednode{\vcondexpr}{\Nexpr}, \Tthen, \\
    \wrappedline\ \namednode{\vthenexpr}{\Nexpr}, \Telse, \namednode{\velseexpr}{\Nexpr}
    \end{array}
    \right)}{\vparsednode}\right) \astarrow\\
  \overname{\ECond(\astversion{\vcondexpr}, \astversion{\vthenexpr}, \astversion{\velseexpr})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ECond}
\ExampleRef{Lowest Common Ancestor} shows examples of typing conditional expressions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a conditional expression with condition $\econd$ with two options $\etrue$ and $\efalse$;
  \item annotating $\econd$ in $\tenv$ results in $(\tcond, \econdp, \vsescond)$\ProseOrTypeError;
  \item annotating $\etrue$ in $\tenv$ results in $(\ttrue, \etruep, \vsestrue)$\ProseOrTypeError;
  \item annotating $\efalse$ in $\tenv$ results in $(\tfalse, \efalsep, \vsesfalse)$;
  \item obtaining the lowest common ancestor of $\ttrue$ and $\tfalse$ results in $\vt$\ProseOrTypeError;
  \item $\newe$ is the condition $\econdp$ with two options $\etruep$ and $\efalsep$, that is, $\ECond(\econdp, \etruep, \efalsep)$;
  \item define $\vses$ as the union of $\vsescond$, $\vsestrue$, and $\vsesfalse$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \econd} \typearrow (\tcond, \econd', \vsescond) \OrTypeError\\\\
  \annotateexpr{\tenv, \etrue} \typearrow (\ttrue, \etrue', \vsestrue) \OrTypeError\\\\
  \annotateexpr{\tenv, \efalse} \typearrow (\tfalse, \efalse', \vsesfalse) \OrTypeError\\\\
  \lca(\ttrue, \tfalse) \typearrow \vt \OrTypeError\\\\
  \vses \eqdef \vsescond \cup \vsestrue \cup \vsesfalse
}{
  {
    \begin{array}{r}
  \annotateexpr{\ECond(\econd, \etrue, \efalse)} \typearrow \\
  (\vt, \ECond(\econdp, \etruep, \efalsep), \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\ECondBegin}{\ECondEnd}{../Typing.ml}
\identr{XZVT}

\subsection{Semantics}
\SemanticsRuleDef{ECond}
\ExampleDef{Evaluation of Conditional Expressions}
In \listingref{semantics-econdfalse},
the expression \texttt{if FALSE then Return42() else 3} evaluates to the value \texttt{3}.
\ASLListing{Evaluating a conditional expression yielding the result of the \texttt{else} subexpression}
{semantics-econdfalse}{\semanticstests/SemanticsRule.ECondFalse.asl}

\ExampleDef{Evaluation of a Non-deterministic Conditional Expression}
In \listingref{semantics-econdarbitrary},
the expression \texttt{if ARBITRARY: boolean then 3 else Return42()} will
evaluate to either \texttt{3} or \texttt{Return42()}, depending on the
(non-deterministic) result of \\
\texttt{ARBITRARY: boolean}.
\ASLListing{Evaluating a conditional expression with non-determinic choice}{semantics-econdarbitrary}
{\semanticstests/SemanticsRule.ECondARBITRARY3or42.asl}

% Transliteration note: the code uses an optimized semantics for the case where
% true and false sub-expressions do not contain function calls. Since this is an
% optimization, we do not document it.
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a conditional expression $\econd$ with two options $\veone$ and $\vetwo$,
        that is, $\ECond(\econd, \veone, \vetwo)$;
  \item the evaluation of the conditional expression $\econd$ in $\env$ yields \\
        $\Normal(\mcond, \envone)$\ProseOrAbnormal;
  \item $\mcond$ consists of a native Boolean for $\vb$ and execution graph $\vgone$;
  \item $\vep$ is $\veone$ if $\vb$ is $\True$ and $\vetwo$ otherwise;
  \item the evaluation of $\vep$ in $\envone$ yields $\Normal((\vvtwo, \vgtwo), \newenv)$\ProseOrAbnormal;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \econd} \evalarrow \Normal(\mcond, \envone) \OrAbnormal\\\\
  \mcond \eqname (\nvbool(\vb), \vgone)\\
  \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\\\
  \evalexpr{\envone, \vep} \evalarrow \Normal((\vv, \vgtwo), \newenv)  \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
}{
  \evalexpr{\env, \overname{\ECond(\econd, \veone, \vetwo)}{\ve}} \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalECondBegin}{\EvalECondEnd}{../Interpreter.ml}

\subsubsection{Comments}
\identr{YCDB}

A conditional expression evaluates to its \texttt{then} expression if the
condition expression evaluates to $\True$. If the condition expression
evaluates to $\False$ each \texttt{elsif} condition expression is evaluated
sequentially until an \texttt{elsif} condition expression evaluates to $\True$;
the conditional expression evaluates to the corresponding \texttt{elsif}
expression. If no \texttt{elsif} expression evaluates to $\True$ the
conditional expression evaluates to the \texttt{else} expression.

\hypertarget{def-callexpressionterm}{}
\section{Call Expressions\label{sec:CallExpressions}}
\ASLListing{Call expressions}{semantics-ecall}{\semanticstests/SemanticsRule.ECall.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Ncall &
\end{flalign*}

\begin{flalign*}
\Ncall \derives \
     & \Tidentifier \parsesep \PlistZero{\Nexpr} &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace \parsesep \PlistZero{\Nexpr} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ECall(\call) &
\end{flalign*}

\begin{flalign*}
\call \derives\ &
{
\left\{
  \begin{array}{rcl}
 \callname &:& \Strings, \\
 \callparams &:& \expr, \\
 \callargs &:& \expr, \\
 \callcalltype &:& \subprogramtype
\end{array}
\right\}
} &
\end{flalign*}

\ASTRuleDef{Call}
\hypertarget{build-call}{}
\begin{mathpar}
\inferrule{
  \buildplist[\buildexpr](\vargs) \astarrow \vargasts
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \namednode{\vargs}{\PlistZero{\Nexpr}})}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
        \callname &:& \id,\\
        \callparams &:& \emptylist,\\
        \callargs &:& \vargasts,\\
        \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\and
\inferrule{
  \buildlist[\buildexpr](\vparams) \astarrow \astversion{\vparams} \\
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \Tlbrace, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace)}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
              \callname &:& \id,\\
              \callparams &:& \astversion{\vparams},\\
              \callargs &:& \emptylist,\\
              \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\and
\inferrule{
  \buildplist[\buildexpr](\vargs) \astarrow \vargasts \\
  \buildlist[\buildexpr](\vparams) \astarrow \astversion{\vparams} \\
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \Tlbrace, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}})}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
              \callname &:& \id,\\
              \callparams &:& \astversion{\vparams},\\
              \callargs &:& \vargasts,\\
              \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\end{mathpar}

\ASTRuleDef{SetCallType}
\hypertarget{def-setcalltype}{}
Above, $\STFunction$ is inserted as a default call type for any parsed $\call$.
The helper function
\[
  \setcalltype(\overname{\call}{\vcall} \aslsep \overname{\subprogramtype}{\calltype}) \aslto \overname{\call}{\vcallp}
\]
changes the call type of $\vcall$ to $\calltype$.

\begin{mathpar}
\inferrule{}{
  \setcalltype(\vcall, \calltype) \aslto
  \overname{\vcall[\callcalltype\mapsto\calltype]}{\vcallp}
}
\end{mathpar}

\ASTRuleDef{ECall}
\begin{mathpar}
\inferrule{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Ncall})}{\vparsednode}) \astarrow
  \overname{\ECall(\astof{\vcall})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ECall}
\ExampleDef{Typing Call Expressions}
\listingref{semantics-ecall} shows call expressions (on the right-hand-side of assignments)
and the inferred types of the expressions, as type annotations on the left-hand-side variables.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a call to a subprogram, that is, $\ECall(\vcall)$;
  \item applying $\annotatecall$ to $\vcall$ and in $\tenv$
        annotates the call of the subprogram in $\tenv$ as a function (see Chapter~\ref{chap:SubprogramCalls})
        and yields $(\vcallp, \langle \vt \rangle, \vses)$\ProseOrTypeError.
  \item $\newe$ is the call using $\vcallp$, that is, $\ECall(\vcallp)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatecall(\vcall) \typearrow (\vcallp, \langle \vt \rangle, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ECall(\vcall)}{\ve}} \typearrow (\vt, \overname{\ECall(\vcallp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ECallBegin}{\ECallEnd}{../Typing.ml}
\identd{CFYP} \identr{BQJG}

\subsection{Semantics}
\SemanticsRuleDef{ECall}
\ExampleDef{Evaluation of Call Expressions}
\listingref{semantics-ecall} shows call expressions (on the right-hand-side of assignments)
and the values they evaluate to, as assertions on the values assigned.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a subprogram call, $\ECall(\vcall)$;
  \item the evaluation of that subprogram call in $\env$ is either
  $\Normal(\vms, \newenv)$\ProseOrAbnormal;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{single\_returned\_value}
    \begin{itemize}
      \item $\vms$ consists of a single returned value $(\vv,\vg)$,
      which goes into the output configuration $\Normal((\vv, \vg), \newenv)$.
    \end{itemize}

    \item \AllApplyCase{multiple\_returned\_values}
    \begin{itemize}
      \item $\vms$ consists of a list of returned value $(\vv_i,\vg_i)$, for $i=1..k$;
      \item $\vg$ is the parallel composition of $\vg_i$, for $i=1..k$;
      \item $\vv$ is the \nativevalue\  vector of values $\vv_i$, for $i=1..k$;
      \item the resulting configuration is $\Normal((\vv, \vg), \newenv)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[single\_returned\_value]{
  \evalcall(\env, \vcall.\name, \vcall.\params, \vcall.\args) \evalarrow \Normal(\vms, \newenv) \OrAbnormal\\
  \vms \eqname [(\vv, \vg)]
}{
  \evalexpr{\env, \ECall(\vcall)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[multiple\_returned\_values]{
  \evalcall(\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs) \evalarrow \Normal(\vms, \newenv) \OrAbnormal\\
  \vms \eqname [i=1..k: (\vv_i, \vg_i)]\\
  \vg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k \\
  \vv \eqdef \nvvector{\vv_{1..k}}
}{
  \evalexpr{\env, \ECall(\vcall)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalECallBegin}{\EvalECallEnd}{../Interpreter.ml}

\section{Slicing Expressions\label{sec:SlicingExpressions}}
\hypertarget{def-sliceexpressionterm}{}
This section details the high-level form of the syntax and abstract syntax of slicing expressions,
and defines the semantics of bitvector slices.
The details of the various types of bitvector slices are deferred to \chapref{BitvectorSlicing}.

\ASLListing{Slicing Expressions}{semantics-eslice}{\semanticstests/SemanticsRule.ESlice.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Nexpr \parsesep \Nslices &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ESlice(\expr, \slice^{*}) &
\end{flalign*}

\ASTRuleDef{ESlice}
\begin{mathpar}
\inferrule{
  \buildexpr(\vexpr) \astarrow \astversion{\vexpr} \OrBuildError\\\\
  \buildslices(\vslices) \astarrow \astversion{\vslices} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\vexpr: \Nexpr, \vslices: \Nslices)}{\vparsednode}) \astarrow
  \overname{\ESlice(\astversion{\vexpr}, \astversion{\vslices})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ESlice}
\ExampleDef{Typing of Slicing Expressions}
\listingref{semantics-eslice} the type inferred for the
slicing expression \verb|'1 1110 000'[6:3, 7]| is \\
\verb|bits(5){}|.
That is, a bitvector of width \verb|5| without any bitfields.
%
The same type is inferred for the slicing expressions
\verb|240[6:3, 7]| and \verb|496[6:3, 7]|
(\verb|240| is equivalent to \verb|'1 111 0 000'|
and \verb|496| is equivalent to \verb|'11 111 0 000'|).

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
        $\ESlice(\vep, \slices)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\tep,\vepp, \vsesone)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\tep$ in $\tenv$ yields $\structtep$\ProseOrTypeError;
  \item $\structtep$ is either a bitvector or an integer;
  \item checking that $\slices$ is not empty yields $\True$\ProseTerminateAs{\BadSlices};
  \item annotating $\slices$ in $\tenv$ yields $(\slicesp, \vsestwo)$\ProseOrTypeError;
  \item obtaining the width of $\slices$ in $\tenv$ via $\sliceswidth$ yields $\vw$\ProseOrTypeError;
  \item $\vt$ is the bitvector type of width $\vw$, that is, $\TBits(\vw, \emptylist)$;
  \item define $\newe$ as the slicing of expression $\vepp$ by the slices $\slicesp$, that is, \\
        $\ESlice(\vepp, \slicesp)$;
  \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\tep, \vepp, \vsesone) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \structtep \OrTypeError\\\\
  \astlabel(\structtep) \in \{\TInt, \TBits\}\\
  \checktrans{\slices \neq \emptylist}{\BadSlices} \typearrow \True \OrTypeError\\\\
  \annotateslices(\tenv, \slices) \typearrow (\slicesp, \vsestwo) \OrTypeError\\\\
  \sliceswidth(\tenv, \slices) \typearrow \vw \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateexpr{\tenv, \overname{\ESlice(\vep, \slices)}{\ve}} \typearrow
  (\overname{\TBits(\vw, \emptylist)}{\vt}, \overname{\ESlice(\vepp, \slicesp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ESliceBegin}{\ESliceEnd}{../Typing.ml}
\subsubsection{Comments}
The width of \slices\ might be a symbolic expression if one of the
widths references a \texttt{let} identifier with a non-compile-time-constant
initializer expression.
\identi{MJWM}

\TypingRuleDef{ESliceError}
\ExampleDef{Ill-typed Slicing Expressions}
The expression \verb|5.0[2:0]| is ill-typed, since the type of \verb|5.0|
is an \integertypeterm{} nor a \bitvectortypeterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure $\vtp$;
  \item $\vtp$ is neither an integer type or a bitvector type;
  \item the result is an error indicating that the type of $\vep$ is inappropriate for slicing.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \vtp\\
  \astlabel(\vtp) \not\in \{\TInt, \TBits\}
}{
  \annotateexpr{\tenv, \overname{\ESlice(\vep, \slices)}{\ve}} \typearrow \TypeErrorVal{\BadSlices}
}
\end{mathpar}
\CodeSubsection{\ESliceError}{\ESliceErrorEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{ESlice}
\ExampleDef{Evaluation of Slicing Expressions}
\listingref{semantics-eslice} the slicing expression \verb|'1 1110 000'[6:3, 7]|
evaluates to the bitvector value \texttt{'1110 1'},
same as the slicing expressions
\verb|240[6:3, 7]| and \verb|496[6:3, 7]|.

Note that in the following definition,
the function $\readfrombitvector$ takes care of converting integers to bitvectors.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a slicing expression, $\ESlice(\ebv, \slices)$;
\item the evaluation of $\ebv$ in $\env$ yields $\Normal(\mbv, \envone)$\ProseOrAbnormal;
\item the evaluation of $\slices$ in $\env$ yields $\Normal(\mpositions, \newenv)$\ProseOrAbnormal;
\item $\mpositions$ consists of $\positions$ --- all the indices that need to be added to the
resulting bitvector --- and the execution graph $\vgone$;
\item reading from $\vbv$ as a bitvector at the indices indicated by $\positions$
      (see \SemanticsRuleRef{ReadFromBitvector}) results in the bitvector $\vv$,
      which concatenates all of the values from the indicates indices\ProseOrError;
\item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ebv} \evalarrow \Normal(\mbv, \envone)  \OrAbnormal\\\\
  \mbv \eqname (\vbv,\vgone) \\
  \evalslices(\envone, \slices) \evalarrow \Normal(\mpositions, \newenv)  \OrAbnormal \\
  \mpositions \eqname (\positions, \vgtwo) \\
  \readfrombitvector(\vbv, \positions) \evalarrow \vv \OrDynError\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr{\env, \ESlice(\ebv, \slices)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalESliceBegin}{\EvalESliceEnd}{../Interpreter.ml}

\section{Array Access Expressions\label{sec:ArrayAccessExpressions}}
\hypertarget{def-getarrayexpressionterm}{}
\hypertarget{def-getenumarrayexpression}{}
This section details the syntax, abstract syntax, semantics, and typing of array read expressions.
In the untyped AST, a read from either an integer-indexed array or an enumeration-indexed arrays is represented
the same way. The type system infers the kind of array and outputs a typed AST node differentiating
the two kinds of arrays, either a $\EGetArray$ or a $\EGetEnumArray$, via \TypingRuleRef{EGetArray}.
The semantics utilizes a rule matching the corresponding type of array ---
\SemanticsRuleRef{EGetArray} for integer-indexed arrays and
\SemanticsRuleRef{EGetEnumArray} for enumeration-indexed arrays.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Nexpr \parsesep \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EGetArray(\expr, \expr) &
\end{flalign*}

\ASTRuleDef{EGetArray}
\begin{mathpar}
\inferrule{
  \buildexpr(\veone) \astarrow \astversion{\veone} \OrBuildError\\\\
  \buildexpr(\vetwo) \astarrow \astversion{\vetwo} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\namednode{\veone}{\Nexpr}, \Tllbracket, \namednode{\vetwo}{\Nexpr}, \Trrbracket)}{\vparsednode}) \astarrow
  \overname{\EGetArray(\astversion{\veone}, \astversion{\vetwo})}{\vastnode}
}
\end{mathpar}

\TypingRuleDef{EGetArray}
\hypertarget{def-arrayaccess}{}
\begin{definition}[Array Access]
We refer to a right-hand-side expression of the form \verb|b[[i]]|,
where $b, i$ are subexpressions, as an \arrayaccess\ expression.
We refer to $b$ and $i$ as the \emph{base}
and the $\emph{index}$ subexpressions, respectively.
\end{definition}

\ExampleDef{Array Access Expressions}
\listingref{typing-tarray} shows examples of well-typed
array access expressions on the right-hand-side of the
assignments to \verb|int_arr| and \verb|big_little_arr|
and the types inferred for them via the added \verb|as <inferred-type>|.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the \arrayaccess{} expression with base $\ebase$ and index $\eindex$;
  \item \Proseannotateexpr{$\tenv$}{$\ebase$}{\\ $(\tbase,\ebasep, \vsesbase)$}\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\tbase$ in $\tenv$ yields $\tanonbase$\ProseOrTypeError;
  \item checking whether $\tanonbase$ is an array type yields $\True$\ProseOrTypeError;
  \item view $\tanonbase$ as the array type with size expression $\size$ and element type $\telem$,
        that is, $\TArray(\size, \telem)$;
  \item applying $\annotategetarray$ to $(\size, \telem)$ and \\
        $(\ebasep, \vsesbase, \eindex)$ yields
        $(\vt, \newe, \vses)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ebase} \typearrow (\tbase, \ebasep, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tanonbase \OrTypeError\\\\
  \checktrans{\astlabel(\tanonbase) = \TArray}{ExpectedArrayType} \typearrow \True \OrTypeError\\\\
  \tanonbase \eqname \TArray(\size, \telem)\\
  {
    \begin{array}{r}
  \annotategetarray(\tenv, (\size, \telem), (\ebasep, \vsesbase, \eindex)) \typearrow \\ (\vt, \newe, \vses)
    \end{array}
  }
}{
  \annotateexpr{\tenv, \overname{\EGetArray(\ebase, \eindex)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\EGetArrayBegin}{\EGetArrayEnd}{../Typing.ml}

\TypingRuleDef{AnnotateGetArray}
\hypertarget{def-annotategetarray}{}
The helper function
\[
\begin{array}{r}
\annotategetarray(
  \overname{\staticenvs}{\tenv} \aslsep
  (\overname{\expr}{\size} \times \overname{\ty}{\telem}) \aslsep
  (\overname{\expr}{\ebase} \times \overname{\TSideEffectSet}{\vsesbase} \times \overname{\expr}{\eindex})
)
\aslto \\
(\overname{\ty}{\vt} \times \overname{\expr}{\newe} \times \overname{\TSideEffectSet}{\vses})
\end{array}
\]
annotates an array access expression with the following elements:
$\size$ is the expression representing the array size,
$\telem$ is the type of array elements,
$\ebase$ is the annotated expression for the array base,
$\eindex$ is the index expression.
The function returns the type of the annotated expression in $\vt$,
the annotated expression $\newe$, and the inferred \sideeffectdescriptorterm\ $\vses$.

See \ExampleRef{Array Access Expressions}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseannotateexpr{$\tenv$}{$\eindex$}{(\tindexp, \eindexp, \vsesindex)}\ProseOrTypeError;
  \item applying $\typeofarraylength$ to $\size$, to obtain the type of the array length, yields
        $\wantedtindex$;
  \item checking that $\tindexp$ \typesatisfies\ $\wantedtindex$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item define $\vses$ as the union of $\vsesindex$ and $\vsesbase$;
  \item \Proseeqdef{$\newe$}{
    an access to an integer-indexed array for $\ebase$ and $\eindexp$, that is, $\EGetArray(\ebase, \eindexp)$ if $\size$ is an integer-typed array index,
    and an access to an enumeration-indexed array for $\ebase$ and $\eindexp$, that is,\\
    $\EGetEnumArray(\ebase, \eindexp)$ if $\size$ is an enumeration-typed array index.
  }
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp, \vsesindex) \OrTypeError\\\\
  \typeofarraylength(\size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesindex \cup \vsesbase \\
  {
    \newe \eqdef \begin{cases}
      \EGetArray(\ebase, \eindexp)     & \text{if }\astlabel(\size) = \ArrayLengthExpr\\
      \EGetEnumArray(\ebase, \eindexp) & \text{if }\astlabel(\size) = \ArrayLengthEnum
    \end{cases}
  }
}{
  {
  \begin{array}{r}
  \annotategetarray(\tenv, (\size, \telem), (\ebase, \vsesbase, \eindex)) \typearrow\\
  (\overname{\telem}{\vt}, \newe, \vses)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\AnnotateGetArrayBegin}{\AnnotateGetArrayEnd}{../Typing.ml}

\SemanticsRuleDef{EGetArray}
\ExampleDef{Evaluation of Array Reading Expressions}
In \listingref{semantics-egetarray},
the expression \verb|my_array[[2]]| appearing in the assertion evaluates to the value \texttt{42} since the element
indexed by \texttt{2} in \texttt{my\_array} is \texttt{42}.
\ASLListing{Evaluating an array access expression}{semantics-egetarray}{\semanticstests/SemanticsRule.EGetArray.asl}

\ExampleDef{Evaluation of an Illegal Array Read}
In \listingref{semantics-egetarrayerror},
evaluating the array access expression \verb|my_array[[3]]| results in a dynamic error,
since we are trying to access index \texttt{3} of an array
which has indexes \texttt{0}, \texttt{1} and \texttt{2} only.
\ASLListing{Evaluating an illegal array access}{semantics-egetarrayerror}{\semanticstests/SemanticsRule.EGetArrayTooSmall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an array access expression, $\EGetArray(\earray, \eindex)$;
  \item the evaluation of $\earray$ in $\env$ is $\Normal(\marray, \envone)$\ProseOrAbnormal;
  \item the evaluation of $\eindex$ in $\env$ is  $\Normal(\mindex, \newenv)$\ProseOrAbnormal
  \item $\marray$ consists of the native vector $\varray$ and execution graph $\vgone$;
  \item $\mindex$ consists of the native integer $\vindex$ and execution graph $\vgtwo$;
  \item $\vindex$ is the native integer for $\vi$;
  \item evaluating the value at index $\vi$ of $\varray$ is $\vv$;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \earray} \evalarrow \Normal(\marray, \envone)  \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \newenv)  \OrAbnormal\\
  \marray \eqname (\varray, \vgone)\\
  \mindex \eqname (\vindex, \vgtwo)\\
  \vindex \eqname \nvint(\vi)\\
  \getindex(\vi, \varray) \evalarrow \vv\\
  \vg \eqdef \vgone \parallelcomp \vgtwo\\
}{
  \evalexpr{\env, \EGetArray(\earray, \eindex)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetArrayBegin}{\EvalEGetArrayEnd}{../Interpreter.ml}

\SemanticsRuleDef{EGetEnumArray}
\ExampleDef{Evaluation of Reading from an Enumeration-indexed Array}
In \listingref{semantics-egetenumarray},
the enumeration-typed array \texttt{Arr} is accessed for reading and writing
with indices taken from the \enumerationtypeterm{} \texttt{Enum}.
\ASLListing{Evaluating an access to an enumeration-indexed array}{semantics-egetenumarray}
{\semanticstests/SemanticsRule.EGetEnumArray.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an array access expression, $\EGetArray(\earray, \eindex)$;
  \item the evaluation of $\earray$ in $\env$ is $\Normal(\marray, \envone)$\ProseOrAbnormal;
  \item the evaluation of $\eindex$ in $\env$ is  $\Normal(\mindex, \newenv)$\ProseOrAbnormal
  \item $\marray$ consists of the native value $\varray$ and execution graph $\vgone$;
  \item $\mindex$ consists of the native value $\vindex$ and execution graph $\vgtwo$;
  \item $\vindex$ is the native literal for the label $\vl$;
  \item accessing the field $\vl$ of $\varray$, which is a native record value, yields $\vv$;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \earray} \evalarrow \Normal(\marray, \envone)  \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \newenv)  \OrAbnormal\\
  \marray \eqname (\varray, \vgone)\\
  \mindex \eqname (\vindex, \vgtwo)\\
  \vindex \eqname \nvlabel(\vl)\\
  \getfield(\vl, \varray) \evalarrow \vv\\
  \vg \eqdef \vgone \parallelcomp \vgtwo\\
}{
  \evalexpr{\env, \EGetEnumArray(\earray, \eindex)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetEnumArrayBegin}{\EvalEGetEnumArrayEnd}{../Interpreter.ml}

\hypertarget{def-getfieldexpressionterm}{}
\section{Field Reading Expressions\label{sec:FieldReadingExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tdot \parsesep \Tidentifier&
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EGetField(\overtext{\expr}{record}, \overtext{\identifier}{field name}) &
\end{flalign*}

\ASTRuleDef{EGetField}
\begin{mathpar}
  \inferrule{
    \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError
  }{
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tdot, \Tidentifier(\id))}{\vparsednode}) \astarrow
  \overname{\EGetField(\astversion{\ve}, \id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EGetRecordField}
\ExampleDef{Typing Record Field Expressions}
\listingref{eget-record-field} shows field reading expressions
as the right-hand-side expressions of assignments
and the types inferred for them via the added \verb|as <inferred-type>|.
\ASLListing{Typing record field expressions}{eget-record-field}{\typingtests/TypingRule.EGetRecordField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a record or exception type with fields $\fields$;
  \item the field $\fieldname$ is associated with the type $\vt$ in $\fields$
  \item define $\newe$ as the access of field $\fieldname$ on the record or exception object $\vetwo$, that is, $\EGetField(\vetwo, \fieldname)$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \langle \vt\rangle
}{
  {
    \begin{array}{r}
      \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow \\
      (\vt, \EGetField(\vetwo, \fieldname), \overname{\vsesone}{\vses})
    \end{array}
  }
}
\end{mathpar}

\CodeSubsection{\EGetRecordFieldBegin}{\EGetRecordFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBadRecordField}
\ExampleDef{Ill-typed Record Field Expressions}
\listingref{eget-bad-record-field} shows an ill-typed field expression.
\ASLListing{An ill-typed record field expression}{eget-bad-record-field}{\typingtests/TypingRule.EGetBadRecordField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a record or exception type with fields $\fields$;
  \item the field $\fieldname$ is not associated with any type in $\fields$
  \item the result is a \typingerrorterm{} indicating the missing field.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}
\CodeSubsection{\EGetBadRecordFieldBegin}{\EGetBadRecordFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBadBitField}
\ExampleDef{Ill-typed Bitfield Expressions}
\listingref{eget-bad-bitfield} shows an ill-typed bitfield expression.
\ASLListing{An ill-typed bitfield expression}{eget-bad-bitfield}{\typingtests/TypingRule.EGetBadBitfield.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item the field $\fieldname$ is not found in $\bitfields$
  \item the result is a \typingerrorterm{} indicating the missing field.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}
\CodeSubsection{\EGetBadBitFieldBegin}{\EGetBadBitFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetCollectionField}

\ExampleDef{Typing Collection Field Expressions}
All of the collection field expressions in
\listingref{typing-lesetcollectionfields} are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vetwo$ is a variable expression for $\vbase$, that is, $\EVar(\vbase)$;
  \item $\vtetwo$ is a collection type with fields $\fields$;
  \item the field $\fieldname$ is associated with the type $\vt$ in $\fields$
  \item define $\newe$ as the access of field $\fieldname$ on the collection object $\vbase$, that is, $\EGetCollectionFields(\vbase, [\fieldname])$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vetwo = \EVar(\vbase) \\
  \vtetwo = \TCollection(\fields)\\
  \assocopt(\fields, \fieldname) \typearrow \langle \vt\rangle
}{
  {
    \begin{array}{r}
      \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow \\
      (\vt, \EGetCollectionFields(\vbase, [\fieldname]), \overname{\vsesone}{\vses})
    \end{array}
  }
}
\end{mathpar}

\CodeSubsection{\EGetCollectionFieldBegin}{\EGetCollectionFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBitField}
\ExampleDef{Well-typed Bitfield Expressions}
\listingref{eget-bitfield} shows well-typed bitfield expressions
as the right-hand-side expressions of assignment statements,
and the types inferred for them via the added \verb|as <inferred-type>|.
\ASLListing{Well-typed bitfield expressions}{eget-bitfield}{\typingtests/TypingRule.EGetBitfield.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$, that is, \\ $\BitFieldSimple(\Ignore, \slices)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vt, \newe, \vses)$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \langle \BitFieldSimple(\Ignore, \slices)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldBegin}{\EGetBitFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBitFieldNested}
\ExampleDef{Nested Bitfield Expressions}
\listingref{eget-bitfield} shows the expression \verb|p.detailed_data.info|,
which refers to the bitfield \verb|info|, which is nested in the bitfield
\verb|detailed_data|.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and nested bitfields $\bitfieldsp$, that is,
        $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe, \vsesnew)$\ProseOrTypeError;
  \item $\vtefour$ is a bitvector type with length expression $\width$, that is, $\TBits(\width, \Ignore)$;
  \item define $\vt$ as a bitvector type with length expression $\width$ and bitfields $\bitfieldsp$;
  \item define $\vses$ as $\vsesnew$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TBits(\Ignore, \bitfields)\\\\
  {
    \begin{array}{r}
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \\ \langle \BitFieldNested(\Ignore, \slices, \bitfieldsp)\rangle
    \end{array}
  }\\\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe, \vsesnew) \OrTypeError\\\\
  \vtefour \eqname \TBits(\width, \Ignore)\\
  \vt \eqdef \TBits(\width, \bitfieldsp)
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \overname{\vses}{\vsesnew})
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldNestedBegin}{\EGetBitFieldNestedEnd}{../Typing.ml}

\TypingRuleDef{EGetBitFieldTyped}
\ExampleDef{Typed Bitfield Expressions}
\listingref{eget-bitfield} shows the expression \verb|p.detailed_data.info|,
which includes the type annotation \verb|bits(4)|.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and typed bitfield with type $\vt$ that is,
        $\BitFieldType(\Ignore, \slices, \vt)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe, \vsesnew)$\ProseOrTypeError;
  \item determining whether $\vtefour$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item define $\vses$ as $\vsesnew$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \langle \BitFieldType(\Ignore, \slices, \vt)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe, \vsesnew) \OrTypeError\\\\
  \checktypesat(\tenv, \vtefour, \vt) \typearrow \True \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \overname{\vses}{\vsesnew})
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldTypedBegin}{\EGetBitFieldTypedEnd}{../Typing.ml}

\TypingRuleDef{EGetTupleItem}
\ExampleDef{Typing of a Tuple Item Expression}
In \listingref{semantics-egetitem}, the type of the expression \verb|t.item0|
is the \integertypeterm.

In the following rule definition, we use $\itemprefix$ to stand
for its verbatim string.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is \tupletypeterm{} with list of types $\tys$, that is, $\TTuple(\tys)$;
  \item $\fieldname$ is an identifier consisting of the prefix \itemprefix{} and the suffix $\num$;
  \item $\num$ is lexically an integer numeral with the integer value $\vindex$;
  \item determining whether $\vindex$ is between $0$ and the number of types in $\tys$, inclusive, yields $\True$\ProseOrTypeError;
  \item $\vt$ is the type at position $\vindex$ of $\tys$;
  \item $\newe$ is the expression for obtaining the item at index $\vindex$ from the expression $\vetwo$, that is, $\EGetItem(\vetwo, \vindex)$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TTuple(\tys)\\
  \fieldname = \itemprefix \stringconcat \num\\
  \num \in \Lang(\REintlit)\\
  \decimaltolit(\num) = \Tintlit(\vindex)\\
  \checktrans{0 \leq \vindex \leq \listlen{\tys}}{\BadTupleIndex} \checktransarrow \True \OrTypeError\\\\
  \vt \eqdef \tys[\vindex]\\
  \newe \eqdef \EGetItem(\vetwo, \vindex)
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \overname{\vsesone}{\vses})
}
\end{mathpar}
\CodeSubsection{\EGetTupleItemBegin}{\EGetTupleItemEnd}{../Typing.ml}

\TypingRuleDef{EGetBadField}
\ExampleDef{An Ill-typed Field Expression}
\listingref{eget-bad-field} shows an example of an ill-typed field expression
\verb|a.f|.
\ASLListing{An ill-typed field expression}{eget-bad-field}{\typingtests/TypingRule.EGetBadBitField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is neither one of the following types: record, exception, bitvector, or tuple;
  \item the result is an error indicating that the type of $\veone$ is inappropriate for accessing the field $\fieldname$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \astlabel(\vtetwo) \not\in \{\TRecord, \TException, \TBits, \TTuple\}
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\EGetBadFieldBegin}{\EGetBadFieldEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EGetField}
\ExampleDef{Evaluation of a Field Read Expression}
In \listingref{semantics-egetfield},
the expression \verb|my_record.a| evaluates to the value \texttt{3}.
\ASLListing{Evaluating a field access expression}{semantics-egetfield}{\semanticstests/SemanticsRule.ERecord.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a field access expression, $\EGetField(\erecord, \fieldname)$;
\item the evaluation of $\erecord$ in $\env$ is $\Normal((\vrecord, \vg), \newenv)$\ProseOrAbnormal;
\item $\vv$ is the value mapped by $\fieldname$ in the native record $\vrecord$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \erecord} \evalarrow \Normal((\vrecord, \vg), \newenv)  \OrAbnormal\\
  \getfield(\fieldname, \vrecord) \evalarrow \vv
}{
  \evalexpr{\env, \EGetField(\erecord, \fieldname)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetFieldBegin}{\EvalEGetFieldEnd}{../Interpreter.ml}

\SemanticsRuleDef{EGetItem}
\ExampleDef{Evaluation of a Tuple Item Expression}
In \listingref{semantics-egetitem},
the expression \verb|t.item0| evaluates to the value \texttt{1}
and
the expression \verb|t.item1| evaluates to the value \texttt{2}.
\ASLListing{Evaluating a tuple item access expression}{semantics-egetitem}{\semanticstests/SemanticsRule.EGetItem.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is an expression for accessing the component given by the index $\vindex$ of the tuple
        given by the expression $\etuple$, that is, $\EGetItem(\etuple, \vindex)$;
  \item evaluating the expression $\etuple$ yields $\Normal((\vvtuple, \vg), \newenv)$\ProseOrAbnormal;
  \item accessing the native tuple value $\vvtuple$ at index $\vindex$ via $\getindex$, yields
        the native value $\vv$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \etuple} \evalarrow \Normal((\vvtuple, \vg), \newenv) \OrAbnormal\\\\
  \getindex(\vvtuple, \vindex) \evalarrow \vv
}{
  \evalexpr{\env, \overname{\EGetItem(\etuple, \vindex)}{\ve}} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetTupleItemBegin}{\EvalEGetTupleItemEnd}{../Interpreter.ml}

\hypertarget{def-getfieldsexpressionterm}{}
\section{Multi-field Reading Expressions\label{sec:MultiFieldReadingExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tdot \parsesep \Tlbracket \parsesep \ClistOne{\Tidentifier} \parsesep \Trbracket &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EGetFields(\overtext{\expr}{record}, \overtext{\identifier^{*}}{field names}) &
\end{flalign*}

\ASTRuleDef{EGetFields}
\begin{mathpar}
  \inferrule{
    \buildclist[\buildidentity](\vids) \astarrow \vidasts\\
    \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError
  }{
    {
      \begin{array}{r}
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tdot, \Tlbracket, \namednode{\vids}{\ClistOne{\Tidentifier}}, \Trbracket)}{\vparsednode}) \astarrow\\
  \overname{\EGetFields(\astversion{\ve}, \vidasts)}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EGetFields}
\ExampleDef{Typing Multi-field Expressions}
\pagebreak
\listingref{egetfields} shows examples of well-typed multi-field expressions.
\ASLListing{Typing multi-field expressions}{egetfields}{\typingtests/TypingRule.EGetFields.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is a multi-field access expression for the base expression $\ebase$ and list of fields $\vfields$,
        that is, $\EGetFields(\ebase, \vfields)$;
  \item \Proseannotateexpr{$\tenv$}{$\ebase$}{\\ $(\tbaseannot, \vetwo, \vsesbase)$}\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\tbaseannot$ in $\tenv$ yields \\
        $\tbaseannotanon$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{bits}
    \begin{itemize}
      \item $\tbaseannotanon$ is a bitvector type with list of bitfields $\vbitfields$\ProseOrTypeError;
      \item applying $\findbitfieldsslices$ to each field name $\name$ and list of bitfields $\vbitfields$ in $\vfields$ yields \\
            $\vslices_\name$\ProseOrTypeError;
      \item define $\veslice$ as the slicing expression for $\ebase$ and lists of slices $\vslices_\name$, for each $\name$ in $\vfields$;
      \item \Proseannotateexpr{$\tenv$}{$\veslice$}{\\ $(\vt, \newe, \vses)$}\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{record}
    \begin{itemize}
      \item $\tbaseannotanon$ is a record or exception type with list of fields $\vbasefields$\ProseOrTypeError;
      \item applying $\getbitfieldwidth$ to $\vf$ in $\vbasefields$ and $\vbasefields$, for each $\vf$ in $\vbasefields$, in $\tenv$ yields $\ewidth_\vf$\ProseOrTypeError;
      \item applying $\widthplus$ to the list of expressions $\ewidth_\vf$,
            for each $\vf$ in $\vbasefields$, yields $\veslicewidth$\ProseOrTypeError;
      \item define $\vt$ as the bitvector type with width $\veslicewidth$ and an empty list of bitfields;
      \item define $\ve$ as the multi-field access for $\ebaseannot$ and list of fields \\
            $\vbasefields$;
      \item define $\vses$ as $\vsesbase$.
    \end{itemize}

    \item \AllApplyCase{collection}
    \begin{itemize}
      \item $\tbaseannotanon$ is a collection type with list of fields $\vbasefields$\ProseOrTypeError;
      \item $\ebaseannot$ denotes a variable expression for $\vbase$, that is, $\EVar(\vbase)$;
      \item applying $\getbitfieldwidth$ to $\vf$ in $\vbasefields$ and $\vbasefields$, for each $\vf$ in $\vbasefields$, in $\tenv$ yields $\ewidth_\vf$\ProseOrTypeError;
      \item applying $\widthplus$ to the list of expressions $\ewidth_\vf$,
            for each $\vf$ in $\vbasefields$, yields $\veslicewidth$\ProseOrTypeError;
      \item define $\vt$ as the bitvector type with width $\veslicewidth$ and an empty list of bitfields;
      \item define $\ve$ as the collection multi-field access for $\vbase$ and list of fields \\
            $\vbasefields$, that is, $\EGetCollectionFields(\vbase, \vbasefields)$;
      \item define $\vses$ as $\vsesbase$.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item $\tbaseannotanon$ is neither a bitvector type nor a record type;
      \item the result is a \typingerrorterm{} indicating an unexpected type.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[bits]{
  \annotateexpr{\tenv, \ebase} \typearrow (\tbaseannot, \ebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \TBits(\Ignore, \vbitfields) \OrTypeError\\\\
  \name\in\vfields: \findbitfieldsslices(\name, \vbitfields) \typearrow \vslices_\name \OrTypeError\\\\
  \veslice \eqdef \ESlice(\ebase, [\name\in\vfields: \vslices_\name])\\
  \annotateexpr{\tenv, \veslice} \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EGetFields(\ebase, \vfields)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[record]{
  \annotateexpr{\tenv, \ebase} \typearrow (\tbaseannot, \ebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \TRecord(\vbasefields) \OrTypeError\\\\
  \vf \in \vbasefields: \getbitfieldwidth(\tenv, \vf, \tfields) \typearrow \ewidth_\vf \OrTypeError\\\\
  \widthplus(\tenv, [\vf \in \vbasefields: \ewidth_\vf]) \typearrow \veslicewidth\OrTypeError
}{
  {
  \begin{array}{r}
    \annotateexpr{\tenv, \overname{\EGetFields(\ebase, \vfields)}{\ve}} \typearrow \\
    (\overname{\TBits(\veslicewidth, \emptylist)}{\vt}, \overname{\EGetFields(\ebaseannot, \vfields)}{\newe}, \overname{\vsesbase}{\vses})
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[collection]{
  \annotateexpr{\tenv, \ebase} \typearrow (\tbaseannot, \ebaseannot, \vsesbase) \OrTypeError\\\\
  \ebaseannot = \EVar(\vbase)\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \TRecord(\vbasefields) \OrTypeError\\\\
  \vf \in \vbasefields: \getbitfieldwidth(\tenv, \vf, \tfields) \typearrow \ewidth_\vf \OrTypeError\\\\
  \widthplus(\tenv, [\vf \in \vbasefields: \ewidth_\vf]) \typearrow \veslicewidth\OrTypeError
}{
  {
  \begin{array}{r}
    \annotateexpr{\tenv, \overname{\EGetFields(\ebase, \vfields)}{\ve}} \typearrow \\
    (\overname{\TBits(\veslicewidth, \emptylist)}{\vt}, \overname{\EGetCollectionFields(\vbase, \vfields)}{\newe}, \overname{\vsesbase}{\vses})
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \annotateexpr{\tenv, \veone} \typearrow (\tbaseannot, \ebaseannot, \Ignore) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \tbaseannotanon \OrTypeError\\\\
  \astlabel(\tbaseannotanon) \not\in \{\TBits, \TRecord\}
}{
  \annotateexpr{\tenv, \overname{\EGetFields(\veone, \vfields)}{\ve}} \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\EGetFieldsBegin}{\EGetFieldsEnd}{../Typing.ml}

\TypingRuleDef{FindBitFieldsSlices}
\hypertarget{def-findbitfieldsslices}{}
% Transliteration note: The implementation returns an optional, but all of its uses raise a \typingerrorterm{} if the result is None.
The helper function
\[
  \findbitfieldsslices(\overname{\identifier}{\name} \aslsep \overname{\bitfield^*}{\vbitfields})
  \aslto \overname{\slice^*}{\vslices} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the slices associated with the bitfield named $\name$ in the list of bitfields $\vbitfields$
in $\vslices$.
\ProseOtherwiseTypeError

\ExampleDef{Finding the Slices of a Bitfield}
In \listingref{eget-bitfield},
given the list of bitfields of the \verb|Packet| type,
the list of slices associated with
\verb|data| is \verb|7:1|.
Attempting to obtain the list of slices associated with
\verb|crc|, given the list of bitfields of the \verb|Packet| type,
yields a \typingerrorterm, since it is a nested bitfield.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{found}
  \begin{itemize}
    \item $\vbitfields$ is a list with \head\ $\vfield$ and \tail\ $\vbitfieldsone$;
    \item applying $\bitfieldgetname$ to $\vfield$ yields $\name$;
    \item applying $\bitfieldgetslices$ to $\vfield$ yields $\vslices$.
  \end{itemize}

  \item \AllApplyCase{tail}
  \begin{itemize}
    \item $\vbitfields$ is a list with \head\ $\vfield$ and \tail\ $\vbitfieldsone$;
    \item applying $\bitfieldgetname$ to $\vfield$ yields $\namep$, which is different to $\name$;
    \item applying $\findbitfieldsslices$ to $\name$ and $vbitfieldsone$ yields $\vslices$\ProseOrTypeError.
  \end{itemize}

  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vbitfields$ is an empty list;
    \item the result is a \typingerrorterm{} indicating that a bitfield named $\name$ does not exist in $\vbitfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[found]{
  \bitfieldgetname(\vfield) \typearrow \name\\
  \bitfieldgetslices(\vfield) \typearrow \vslices
}{
  \findbitfieldsslices(\name, \overname{[\vfield] \concat \vbitfieldsone}{\vbitfields}) \typearrow \vslices
}
\end{mathpar}

\begin{mathpar}
\inferrule[tail]{
  \bitfieldgetname(\vfield) \typearrow \namep\\
  \namep \neq \name\\
  \findbitfieldsslices(\name, \vbitfieldsone) \typearrow \vslices \OrTypeError
}{
  \findbitfieldsslices(\name, \overname{[\vfield] \concat \vbitfieldsone}{\vbitfields}) \typearrow \vslices
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty]{}{
  \findbitfieldsslices(\name, \overname{\emptylist}{\vbitfields}) \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}

\TypingRuleDef{GetBitfieldWidth}
\hypertarget{def-getbitfieldwidth}{}
The helper function
\[
  \getbitfieldwidth(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\Field^*}{\tfields})
  \aslto \overname{\expr}{\ewidth} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the expression $\ewidth$ that describes the width of the bitfield named $\name$
in the list of fields $\tfields$.
\ProseOtherwiseTypeError

\ExampleDef{Obtaining the Width of a Bitfield}
In \listingref{egetfields},
obtaining the width of the field \verb|bits3_2|,
given the list of fields of the type \verb|RecordWithBits|
yields the literal expression for \verb|2|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item applying $\assocopt$ to find the type associated with $\name$ in $\tfields$ yields the type $\vt$;
    \item applying $\getbitvectorwidth$ to $\vt$ in $\tenv$ yields $\ewidth$\ProseOrTypeError.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item applying $\assocopt$ to find the type associated with $\name$ in $\tfields$ yields $\None$;
    \item the result is a \typingerrorterm{} indicating that $\name$ is not associated with any field in $\tfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \assocopt(\name, \tfields) \typearrow \langle\vt\rangle\\
  \getbitvectorwidth(\tenv, \vt) \typearrow \ewidth \OrTypeError
}{
  \getbitfieldwidth(\tenv, \name, \tfields) \typearrow \ewidth
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \assocopt(\name, \tfields) \typearrow \None
}{
  \getbitfieldwidth(\tenv, \name, \tfields) \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}

\TypingRuleDef{WidthPlus}
\hypertarget{def-widthplus}{}
% NOTE: the implementation handles just two expressions, here we fold over a list.
The helper function
\[
  \widthplus(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr^*}{\exprs}) \typearrow \overname{\expr}{\ewidth}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
generates the expression $\ewidth$, which represents the summation of all expressions in the list $\exprs$,
normalized in the static environment $\tenv$.
\ProseOrTypeError

\ExampleDef{Summing Widths}
Summing the list of expression \verb|2, 3|,
yields the expression \verb|2+3|,
(in AST terms, \\
$\AbbrevEBinop{\PLUS}{\ELInt{2}}{\ELInt{2}}$).

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\exprs$ is an empty list;
    \item $\ewidth$ is the literal expression for $0$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\exprs$ is the list with \head\ $\ve$ and \tail\ $\exprsone$;
    \item applying $\widthplus$ to $\exprsone$ yields $\ewidthone$;
    \item applying $\normalize$ to the binary operation for $\PLUS$ and $\ve$ and $\ewidthone$ yields $\ewidth$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \widthplus(\tenv, \overname{\emptylist}{\exprs}) \typearrow \overname{\ELInt{0}}{\ewidth}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \widthplus(\exprsone) \typearrow \ewidthone\\
  \normalize(\tenv, \EBinop(\PLUS, \ve, \ewidthone)) \typearrow \ewidth \OrTypeError
}{
  \widthplus(\tenv, \overname{[\ve] \concat \exprsone}{\exprs}) \typearrow \ewidth
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{EGetfields}
\ExampleDef{Evaluating Multi-field Expressions}
In \listingref{egetfields},
evaluating the multi-field expression \\
\verb|bits_var.[bits3_2, bit1, bit0, info_and_bits]|
yields the bitvector value \\
\verb|'00101010'|,
and evaluating the multi-field expression \\
\verb|record_var.[bits3_2, bit1, bit0, info]|
yields the bitvector value \verb|'001010'|.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is the multi-field access expression for the expression $\erecord$ and list of field names
        $\vfieldnames$;
  \item evaluating the expression $\erecord$ in $\env$ yields $((\vrecord, \vg), \newenv)$\ProseOrAbnormal;
  \item obtaining the value associated with the field $\fieldname$ in $\vv$, for each $\fieldname$ in $\vfieldnames$,
        yields $\vv_\fieldname$;
  \item define $\vv$ as the concatenation of $\vv_\fieldname$, for each $\fieldname$ in $\vfieldnames$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \erecord} \evalarrow ((\vrecord, \vg), \newenv) \OrAbnormal\\\\
  \fieldname\in\vfieldnames: \getfield(\fieldname, \vv) \evalarrow \vv_\fieldname\\
  \concatbitvectors([\fieldname\in\vfieldnames: \vv_\fieldname]) \typearrow \vv
}{
  \evalexpr{\env, \overname{\EGetFields(\erecord, \vfieldnames)}{\ve}} \evalarrow
  ((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetFieldsBegin}{\EvalEGetFieldsEnd}{../interpreter.ml}

\SemanticsRuleDef{EGetCollectionFields}

\ExampleDef{Typing Collection Fields Expressions}
All of the collection field expressions in
\listingref{typing-lesetcollectionfields} are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is the collection multi-field access expression for the
    collection global storage element $\vbase$ and list of field names
    $\vfieldnames$;
  \item $\vbase$ is bound in the storage map of $\denv$;
  \item $\vv$ is the value of $\vbase$ in the global component of $\env$;
  \item obtaining the value associated with the field $\fieldname$ in $\vv$,
    for each $\fieldname$ in $\vfieldnames$, yields $\vv_\fieldname$;
  \item define $\vv$ as the concatenation of $\vv_\fieldname$, for each
    $\fieldname$ in $\vfieldnames$.
  \item $\vg$ is the graph containing a Read Effect for each field $\fieldname$
    in $\vfieldnames$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqname (\Ignore, \denv)\\
  \vbase \in \dom(G^\denv.\storage) \\
  \vv \eqdef G^\denv.\storage(\vbase) \\
  \fieldname\in\vfieldnames: \getfield(\fieldname, \vv) \evalarrow \vv_\fieldname \\
  \vg \eqdef \left\{ \fieldname\in\vfieldnames: \ReadEffect(\vbase + \ttdotstr + \fieldname) \right\} \\
  \concatbitvectors([\fieldname\in\vfieldnames: \vv_\fieldname]) \evalarrow \vv \\
}{
  \evalexpr{\env, \overname{\EGetCollectionFields(\vbase, \vfieldnames)}{\ve}} \evalarrow
  ((\vv, \vg), \newenv)
}
\end{mathpar}

\CodeSubsection{\EvalEGetCollectionFieldsBegin}{\EvalEGetCollectionFieldsEnd}{../interpreter.ml}

\hypertarget{def-atceexpressionterm}{}
\section{Asserting Type Conversion Expressions\label{sec:AssertingTypeConversionExpressions}}
\identi{TCST}
The rule about domains in the definitions of subtype-satisfaction and
type-satisfaction means that it is illegal to use the unconstrained integer
where a constrained integer is expected.
An asserting type conversion, ATC for short, can be used to overcome this.

\identi{CGRH}
An ATC allows code to explicitly mark places where uses of constrained types
would otherwise be a static typechecking error. The intent is to reduce the
incidence of unintended errors by making such uses fail typechecking unless
the asserting type conversion is provided.

\identr{WZVX}
Note that ATCs are execution-time checks. An execution-time check is a
condition that is evaluated during the evaluation of an execution-time
initializer expression or subprogram. If the condition evaluates to $\False$ it
is a dynamic error.

\ASLListing{ATC expressions}{typing-atc}{\typingtests/TypingRule.ATC.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tas \parsesep \Nty &\\
                    |\  & \Nexpr \parsesep \Tas \parsesep \Nconstraintkind &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \overtext{\EATC}{Type assertion}(\expr, \overtext{\ty}{asserted type}) &
\end{flalign*}

\ASTRuleDef{ATC}
\begin{mathpar}
\inferrule[type]{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildty(\vt) \astarrow \astversion{\vt} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tas, \vt : \Nty)}{\vparsednode}) \astarrow
  \overname{\EATC(\astversion{\ve}, \astversion{\vt})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_constraints]{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildconstraintkind(\vics) \astarrow \astversion{\vics} \OrBuildError
}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tas, \vics : \Nconstraintkind)}{\vparsednode}) \astarrow\\
      \overname{\EATC(\astversion{\ve}, \TInt(\astversion{\vics}))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ATC}
\ExampleDef{Well-typed Asserting Type Conversion Expressions}
\listingref{typing-atc} shows examples of ATC expressions
and the corresponding annotated expressions in comments.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an asserting type conversion with expression $\vep$ and type $\tty$, that is $\EATC(\vep, \tty)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vt, \vepp, \vsese)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyp, \vsesty)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\tty'$ in $\tenv$ yields $\vtystruct$\ProseOrTypeError;
  \item applying $\checkatc$ to $\vtstruct$ and $\vtystruct$ in $\tenv$ to check whether the type assertion
        will always fail yields $\True$\ProseOrTypeError;
  \item define $\vsesp$ as the union of $\vsesty$, $\vsese$, and the singleton set for \PerformsAssertions;
  \item checking whether $\vtstruct$ \subtypesatisfies\ $\vtystruct$ in $\tenv$ yields \\
        $\vallwayssucceeds$\ProseOrTypeError\
        (if $\vallwayssucceeds$ holds then the type assertion will always succeed dynamically, and therefore can be omitted);
  \item $\newe$ is $\vepp$ if $\vallwayssucceeds$ is $\True$ and $\EATC(\ttyp, \vepp)$ otherwise;
  \item $\vses$ is $\vsese$ if $\vallwayssucceeds$ is $\True$ and $\vses$ otherwise;
  \item $\vt$ is $\ttyp$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp, \vsese) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \annotatetype{\tenv, \tty} \typearrow (\ttyp, \vsesty) \OrTypeError\\\\
  \tstruct(\tenv, \ttyp) \typearrow \vtystruct \OrTypeError\\\\
  \checkatc(\tenv, \vtstruct, \vtystruct) \typearrow \True \OrTypeError\\\\
  \vsesp \eqdef \vsesty \cup \vsese \cup \{\PerformsAssertions\}\\
  \subtypesat(\tenv, \vtstruct, \vtystruct) \typearrow \vallwayssucceeds \OrTypeError\\\\
  (\newe, \vses) \eqdef \choice{\vallwayssucceeds}{(\vepp, \vsese)}{(\EATC(\vepp, \ttyp), \vsesp)}
}{
  \annotateexpr{\tenv, \overname{\EATC(\vep, \tty)}{\ve}} \typearrow (\overname{\ttyp}{\vt}, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\ATCBegin}{\ATCEnd}{../Typing.ml}
\lrmcomment{
  This is related to \identr{VBLL} \identi{KRLL} \identg{PFRQ} \identi{XVBG},
  \identr{GYJZ} \identi{SZVF} \identr{PZZJ} \identr{YCPX} \identi{ZLBW},
  \identi{TCST} \identi{CGRH} \identi{YJBB}.
}

\TypingRuleDef{CheckATC}
\hypertarget{def-checkatc}{}
The helper function
\[
  \checkatc(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo}) \aslto
  \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the types $\vtone$ and $\vttwo$, which are assumed to not be named types,
are compatible for a typing assertion in the static environment $\tenv$, yielding $\True$.
\ProseOtherwiseTypeError

\ExampleDef{Ill-typed ATC Expressions}
\listingref{checkatc} shows examples of ill-typed ATC expressions.
\ASLListing{Ill-typed ATC expressions}{checkatc}{\typingtests/TypingRule.CheckATC.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{equal}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{different\_labels\_error}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are different;
    \item the result is a \typingerrorterm{} indicating that the type assertion will always fail.
  \end{itemize}

  \item \AllApplyCase{int\_bits}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is either $\TInt$ or $\TBits$;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item $\vtone$ is a \tupletypeterm{} with list of tuples $\vlone$, that is, $\TTuple(\vlone)$;
    \item $\vtone$ is a \tupletypeterm{} with list of tuples $\vltwo$, that is, $\TTuple(\vltwo)$;
    \item checking whether $\vlone$ and $\vltwo$ have the same length yields $\True$\ProseTerminateAs{\TypeAssertionFailure};
    \item applying $\checkatc$ to $\vlone[\vi]$ and $\vltwo[\vi]$ in $\tenv$ for every $\vi\in\listrange(\vlone)$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$;
  \end{itemize}

  \item \AllApplyCase{other\_error}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is neither $\TInt$, nor $\TBits$, nor $\TTuple$;
    \item the result is a \typingerrorterm{} indicating that the type assertion will always fail ($\TypeAssertionFailure$).
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[equal]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[different\_labels\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) \neq \astlabel(\vttwo)
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\TypeAssertionFailure}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_bits]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \in \{\TInt, \TBits\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \vtone = \TTuple(\vlone)\\
  \vttwo = \TTuple(\vltwo)\\
  \checktrans{|\vlone|=|\vltwo|}{\TypeAssertionFailure} \typearrow \True\OrTypeError\\\\
  \vi\in\listrange(\vlone): \checkatc(\vlone[\vi], \vltwo[\vi]) \typearrow \True\OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[other\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \not\in \{\TInt, \TBits, \TTuple\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\TypeAssertionFailure}
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{ATC}
\ExampleDef{Evaluation of an Asserting Type Conversion Expressions}
In \listingref{semantics-atcvalue}, both type assertions ---
\verb|3 as integer| and \verb|3 as integer{3..5}| --- succeed.
\ASLListing{Evaluating a successful type assertion expression}{semantics-atcvalue}{\semanticstests/SemanticsRule.ATCValue.asl}

\ExampleDef{An Unevaluated Asserting Type Conversion}
\identr{YCPX}
In \listingref{semantics-atcnotevaluated}, the asserting type conversion on \texttt{y}
does not yield a dynamic error, since the invocation of \texttt{f1} returns $\False$ when
evaluated:
\ASLListing{A asserting type conversion that is never evaluated}{semantics-atcnotevaluated}
{\semanticstests/SemanticsRule.ATCNotDynamicErrorIfFalse.asl}

\ExampleDef{Asserting Type Conversions with Typing Errors and Dynamic Errors}
\listingref{semantics-variousatcs} shows various type errors and dynamic errors:
\ASLListing{Various type errors and dynamic errors}{semantics-variousatcs}{\semanticstests/SemanticsRule.ATCVariousErrors.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes an asserted type conversion expression, $\EATC(\veone, \vt)$;
\item evaluating $\veone$ in $\env$ results in $\Normal((\vv, \vgone), \newenv)$\ProseOrAbnormal;
\item evaluating whether $\vv$ has type $\vt$ in $\env$ results in $(\vb, \vgtwo)$\ProseTerminateAs{\DynErrorConfig};
\item \OneApplies
      \begin{itemize}
      \item \AllApplyCase{okay}
            \begin{itemize}
            \item $\vb$ is the native Boolean for \True;
            \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
            \end{itemize}
      \item \AllApplyCase{error}
            \begin{itemize}
            \item $\vb$ is the native Boolean for \False;
            \item the result is a dynamic error indicating that the type assertion failed
                  (\DynamicTypeAssertionFailure).
            \end{itemize}
      \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \evalexpr{\env, \veone} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vgtwo) \OrDynError\\\\
  \vb \eqname \nvbool(\True)\\
  \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalexpr{\env, \EATC(\veone, \vt)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\and
\inferrule[error]{
  \evalexpr{\env, \veone} \evalarrow \Normal((\vv, \Ignore), \Ignore)\\
  \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \Ignore)\\
  \vb \eqname \nvbool(\False)
}{
  \evalexpr{\env, \EATC(\veone, \vt)} \evalarrow \DynamicErrorVal{\DynamicTypeAssertionFailure}
}
\end{mathpar}
\CodeSubsection{\EvalATCBegin}{\EvalATCEnd}{../Interpreter.ml}

\SemanticsRuleDef{IsValOfType}
\ProseParagraph
\hypertarget{def-isvaloftype}{}
The relation
\[
  \isvaloftype(\overname{\envs}{\env} \aslsep \overname{\vals}{\vv} \aslsep \overname{\ty}{\vt}) \;\aslrel\;
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg}) \cup \overname{\TDynError}{\DynErrorConfig}
\]
tests whether the value $\vv$ can be stored in a variable of type $\vt$ in the environment $\env$,
resulting in a Boolean value $\vb$ and execution graph $\vg$ or a dynamic error.

This relation is used in the context of a asserted type conversion,
which means the typechecker rule \TypingRuleRef{ATC} was already applied,
thus filtering cases where the type inferred for the converted expression
does not type-satisfy $\vt$. The semantics takes this into account and
only returns \False\ in cases where dynamic information is required.

Recall that the $\vt$ is the result of $\annotatetype$, which ensures that
all sub-expressions appearing in $\vt$ are side-effect-free.

\ExampleDef{Checking Whether a Value Belongs to a Type}
In \listingref{semantics-variousatcs},
checking whether the value \verb|2| is a member of the type \verb|integer{1,2,3}|
succeeds whereas checking whether the value \verb|2| is a member
of the type \verb|integer{4, 5, 6}| fails.

\OneApplies
\begin{itemize}
  \item \AllApplyCase{type\_equal}
  \begin{itemize}
    \item the AST label of $\vt$ is not $\TInt$, $\TBits$, or $\TTuple$;
    \item $\vb$ is $\True$ (since \TypingRuleRef{ATC}
    succeeds in these cases only if the \structure\ of the type of the expression and the \structure\ of the type asserted against are \typeequivalent);
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item \AllApplyCase{int\_unconstrained}
  \begin{itemize}
    \item $\vt$ has the structure of the unconstrained integer;
    \item $\vb$ is \True;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item \AllApplyCase{int\_wellconstrained}
  \begin{itemize}
    \item $\vt$ has the structure of a well-constrained integer with constraints $\vc_{1..k}$;
    \item $\vv$ is the \nativevalue\  integer for $n$;
    \item the evaluation of every constraint $\vc_i$ with $n$ in environment $\env$
    yields a Boolean value $\vb_i$ and an execution graph $\vg_i$\ProseOrError;
    \item $\vb$ is the Boolean disjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
  \end{itemize}

  \item \AllApplyCase{bits}
  \begin{itemize}
    \item $\vt$ is a bitvector type with expression $\ve$, that is, $\TBits(\ve, \Ignore)$;
    \item $\vv$ is a native bitvector value for the sequence of bits $\vbits$, that is, \\ $\nvbitvector(\vbits)$;
    \item evaluating the side-effect-free expression $\ve$ in $\env$ yields $\Normal(\vvp, \vg)$\ProseOrError;
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vvp$ is equal to the number of bits in $\vbits$}.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\vt$ is a tuple with types $\vt_i$, for $i=1..k$;
    \item the value at every index $i=1..k$ of $\vv$ is $\vu_i$, for $i=1..k$,
    \item the evaluation of $\isvaloftype$ for every value $\vu_i$
    and corresponding type $\vt_i$, for $i=1..k$,
    results in a Boolean $\vb_i$ and execution graph $\vg_i$\ProseOrError;
    \item $\vb$ is the Boolean conjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
    of the constraints.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[type\_equal]{
  \astlabel(\vt) \not\in \{\TInt, \TBits\}
}{
  \isvaloftype(\env, \vv, \vt) \evalarrow (\overname{\True}{\vb}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_unconstrained]{}{
  \isvaloftype(\env, \vv, \overname{\TInt(\unconstrained)}{\vt}) \evalarrow (\overname{\True}{\vb}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_wellconstrained]{
  \vv \eqname \nvint(n)\\
  i=1..k: \isconstaintsat(\env, \vc_i, n) \evalarrow (\vb_i, \vg_i) \OrDynError\\\\
  \vb \eqdef \bigvee_{i=1}^k \vb_i\\
  \vg \eqdef \parallel_{i=1}^k \vg_i
}{
  \isvaloftype(\env, \vv, \overname{\TInt(\wellconstrained(\vc_{1..k}))}{\vt}) \evalarrow (\vb, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\vvp, \vg) \OrDynError
}{
  \isvaloftype(\env, \overname{\nvbitvector(\vbits)}{\vv}, \overname{\TBits(\ve, \Ignore)}{\vt}) \evalarrow
  (\overname{\vvp = |\vbits|}{\vb}, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  i=1..k: \getindex(i, \vv) \evalarrow \vu_i\\
  i=1..k: \isvaloftype(\env, \vu_i, \vt_i) \evalarrow (\vb_i, \vg_i) \OrDynError\\\\
  \vb \eqdef \bigwedge_{i=1}^k \vb_i \\
  \vg \eqdef\ \parallelcomp_{i=1}^k \vg_i
}{
  \isvaloftype(\env, \vv, \overname{\TTuple(i=1..k: \vt_i)}{\vt}) \evalarrow (\vb, \vg)
}
\end{mathpar}
\CodeSubsection{\EvalValOfTypeBegin}{\EvalValOfTypeEnd}{../Interpreter.ml}

\subsubsection{Comments}
Notice that these rules cover all types, including named types ($\TNamed$),
since the \typedast\ returned from \TypingRuleRef{ATC} is the \structure\ of the type
given in the specification.
%
Parameterized integers (integers with an empty set of constraints)
cannot appear as a type, since ASL syntax does not allow the following:
\begin{itemize}
\item Declaring an parameterized integer as a variable,
\item Declaring an alias to an parameterized integer type, and
\item Declaring an parameterized integer in a compound type.
\end{itemize}

\SemanticsRuleDef{IsConstraintSat}
\hypertarget{def-isconstraintsat}{}
The helper relation
\[
  \isconstaintsat(\overname{\envs}{\env} \aslsep \overname{\intconstraint}{\vc} \aslsep \overname{\Z}{n}) \;\aslrel\;
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg})
\]
tests whether the integer value $n$ \emph{satisfies the constraint} $\vc$
(that is, whether $n$ is within the range of values defined by $\vc$) in the environment $\env$
and returns a Boolean answer $\vb$ and the execution graph $\vg$ resulting from evaluating
the expressions appearing in $\vc$.

See \ExampleRef{Checking Whether a Value Belongs to a Type}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{Constraint\_Exact\_Sat}
  \begin{itemize}
    \item $\vc$ is a constraint for the expression $\ve$;
    \item evaluating the side-effect-free expression $\ve$ in $\env$ yields the \concurrentnativevalue\ given
          by the native integer value for $m$ and the \executiongraph\ $\vg$\ProseOrError.
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $m$ is equal to $n$}.
  \end{itemize}

  \item \AllApplyCase{Constraint\_Range\_Sat}
  \begin{itemize}
    \item $\vc$ is a constraint for the expressions $\veone$ and $\vetwo$;
    \item evaluating the side-effect-free expression $\veone$ in $\env$ yields the \concurrentnativevalue\ given
          by the native integer value for $a$ and the \executiongraph\ $\vgone$\ProseOrError.
    \item evaluating the side-effect-free expression $\vetwo$ in $\env$ yields the \concurrentnativevalue\ given
          by the native integer value for $b$ and the \executiongraph\ $\vgtwo$\ProseOrError.
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $n$ is greater or equal to $a$ and less than or equal to $b$};
    \item \Proseeqdef{$\vg$}{the parallel composition of $\vgone$ and $\vgtwo$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
The use of $\evalexprsef$ is justified by checks in $\annotatetype$, verifying
that expressions appearing in types are all side-effect-free.

\begin{mathpar}
\inferrule[Constraint\_Exact\_Sat]{
  \evalexprsef{\env, \ve} \evalarrow (\nvint(m), \vg) \OrDynError
}{
  \isconstaintsat(\env, \overname{\constraintexact(\ve)}{\vc}, n) \evalarrow (\overname{m = n}{\vb}, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[Constraint\_Range\_Sat]{
  \evalexprsef{\env, \veone} \evalarrow (\nvint(a), \vgone) \OrDynError\\\\
  \evalexprsef{\env, \vetwo} \evalarrow (\nvint(b), \vgtwo) \OrDynError\\\\
  \vb \eqdef \choice{a \leq n \wedge n \leq b}{\True}{\False}\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \isconstaintsat(\env, \overname{\constraintrange(\veone, \vetwo)}{\vc}, n) \evalarrow (\vb, \vg)
}
\end{mathpar}

\hypertarget{def-patternexpressionterm}{}
\section{Pattern Matching Expressions\label{sec:PatternMatchingExpressions}}
The binary operator $\Tin$ tests whether a value (referred to as the discriminant) matches any item from a $\Npatternset$.
Patterns can also be used to test whether an expression matches a bitmask (via $\Teq$) or does not match a bitmask (via $\Tneq$).
Lists of patterns are also used in case statements.
%
\chapref{PatternMatching} goes into the details of the various types of patterns that can be matched against.

\ASLListing{Pattern expressions}{semantics-epattern}{\semanticstests/SemanticsRule.EPattern.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tin \parsesep \Npatternset &\\
              |\  & \Nexpr \parsesep \Teqop \parsesep \Tmasklit &\\
              |\  & \Nexpr \parsesep \Tneq \parsesep \Tmasklit &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EPattern(\expr, \pattern) &
\end{flalign*}

\ASTRuleDef{EPattern}
\begin{mathpar}
\inferrule{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildpatternset(\vps) \astarrow \astversion{\vps} \OrBuildError
}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tin, \vps : \Npatternset)}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astversion{\ve}, \astversion{\vps})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq]{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Nexpr}, \Teq, \Tmasklit(\vm))}{\vparsednode}) \astarrow
  \overname{\EPattern(\astof{\vexpr}, \PatternMask(\vm))}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neq]{}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\punnode{\Nexpr}, \Tneq, \Tmasklit(\vm))}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astof{\vexpr}, \PatternNot(\PatternMask(\vm)))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EPattern}
\listingref{semantics-epattern} shows examples of pattern expressions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a pattern expression to test whether $\veone$ matches the pattern $\vpat$, that is, \\ $\EPattern(\veone, \vpat)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vtetwo, \vetwo, \vsese)$\ProseOrTypeError;
  \item applying $\annotatepattern$ to $\vtetwo$ and $\vpat$ in $\tenv$ yields $(\vpatp, \vsespat)$\ProseOrTypeError;
  \item define $\vt$ as $\TBool$;
  \item define $\newe$ as the pattern expression for $\vetwo$ and the pattern $\vpatp$, that is, \\
        $\EPattern(\vetwo, \vpatp)$;
  \item define $\vses$ as the union of $\vsese$ and $\vsespat$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtetwo, \vetwo, \vsese) \OrTypeError\\\\
  \annotatepattern(\tenv, \vtetwo, \vpat) \typearrow (\vpatp, \vsespat) \OrTypeError\\\\
  \vses \eqdef \vsese \cup \vsespat
}{
  \annotateexpr{\tenv, \overname{\EPattern(\veone, \vpat)}{\ve}} \typearrow (\overname{\TBool}{\vt}, \overname{\EPattern(\vetwo, \vpatp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\EPatternBegin}{\EPatternEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EPattern}
\ExampleDef{Evaluation of Pattern Expressions}
In \listingref{semantics-epattern},
the expression \texttt{42 IN \{0..3, 42\}} evaluates to $\nvbool(\True)$
whereas the expression \texttt{42 IN \{0..3, -4\}} evaluates to $\nvbool(\False)$.
%
In addition, all assertions, which demonstrate pattern expression involving bitmasks,
succeed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a pattern expression, $\EPattern(\ve, \vp)$;
  \item evaluating the expression $\ve$ in an environment $\env$ results in \\
  $\Normal((\vvone, \vgone), \newenv)$\ProseOrAbnormal;
  \item evaluating whether the pattern $\vp$ matches the value $\vvone$ in $\env$
  results in $\Normal(\vv, \vgtwo)$ where is a native Boolean that determines
  whether the is indeed a match;
  \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \newenv) \OrAbnormal\\
  \evalpattern{\env, \vvone, \vp} \evalarrow \Normal(\vv, \vgtwo)\\
  \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalexpr{\env, \EPattern(\ve, \vp)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEPatternBegin}{\EvalEPatternEnd}{../Interpreter.ml}

\hypertarget{def-arbitraryexpressionterm}{}
\section{Arbitrary Value Expressions\label{sec:ArbitraryValueExpressions}}
An expression of the form \texttt{ARBITRARY: ty} evaluates to an arbitrary value in the
domain of \texttt{ty}.
Each evaluation can produce a different arbitrary value, but (as always) once a particular expression is evaluated, its arbitrary value cannot change.
This is because evaluation produces native values, and \ARBITRARY{} is not a valid native value---so once evaluated, it becomes an unchanging native value like any other.

Note that there are two important consequences of producing an arbitrary value when evaluating expressions of the form \texttt{ARBITRARY: ty}:
\begin{enumerate}
  \item The arbitrary value depends only on \texttt{ty}, and no other ASL storage elements.
  \item The only guarantee of the resulting value is that it is a valid member of \texttt{ty}.
    In particular, the language does not define which valid member it is, and ASL specifications must not rely on the value (for example, there is no way to test whether a value was produced by evaluating \ARBITRARY{}).
\end{enumerate}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tarbitrary \parsesep \Tcolon \parsesep \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EArbitrary(\ty) &
\end{flalign*}

\ASTRuleDef{EArbitrary}
\begin{mathpar}
\inferrule{
  \buildty(\vt) \astarrow \astversion{\vt} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\Tarbitrary, \Tcolon, \vt : \Nty)}{\vparsednode}) \astarrow
  \overname{\EArbitrary(\astversion{\vt})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EArbitrary}
\ExampleDef{Well-typed Arbitrary Value Expressions}
\listingref{typing-arbitrary} show examples of well-typed arbitrary value expressions.
\ASLListing{Well-typed arbitrary value expressions}{typing-arbitrary}{\typingtests/TypingRule.EArbitrary.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an expression \ARBITRARY\ of type $\tty$, that is, $\EArbitrary(\tty)$;
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyone, \vsesty)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\ttyone$ in $\tenv$ yields $\ttytwo$\ProseOrTypeError;
  \item \Prosecheckisnotcollection{$\tenv$}{$\ttytwo$};
  \item $\vt$ is $\ttyone$;
  \item define $\newe$ as an expression \ARBITRARY\ of type $\ttytwo$, that is, $\EArbitrary(\ttytwo)$;
  \item define $\vses$ as the union of $\vsesty$ and the singleton set for the \NonDeterministicTerm.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \tty} \typearrow (\ttyone, \vsesty) \OrTypeError\\\\
  \tstruct(\tenv, \ttyone) \typearrow \ttytwo \OrTypeError\\\\
  \checkisnotcollection(\tenv, \ttytwo) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesty \cup \{ \NonDeterministic \}
}{
  \annotateexpr{\tenv, \EArbitrary(\tty)} \typearrow (\ttyone, \EArbitrary(\ttytwo), \vses)
}
\end{mathpar}
\CodeSubsection{\EArbitraryBegin}{\EArbitraryEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EArbitrary}
\ExampleDef{Evaluation of ARBITRARY for an Unconstrained Integer Type}
In \listingref{semantics-earbitraryunconstrained},
the expression \verb|ARBITRARY : integer| evaluates to an arbitrary integer value.
\ASLListing{Evaluating an \texttt{ARBITRARY} expression for an unconstrained integer}{semantics-earbitraryunconstrained}
{\semanticstests/SemanticsRule.EArbitraryInteger3.asl}

\subsubsection{Evaluation of ARBITRARY for a Constrained Integer Type}
In \listingref{semantics-earbitraryconstrained},
the expression \verb|ARBITRARY : integer {3, 42}| evaluates to either \\
$\nvint(3)$ or $\nvint(42)$.
\ASLListing{Evaluating an \texttt{ARBITRARY} expression for a constrained integer}{semantics-earbitraryconstrained}
{\semanticstests/SemanticsRule.EArbitraryIntegerRange3-42-3.asl}

\subsubsection{Evaluation of ARBITRARY for an Integer-indexed Array}
\listingref{semantics-earbitraryarray}
demonstrates how to obtain an arbitrary integer-indexed array, \texttt{int\_array},
and how to obtain an arbitrary enumeration-indexed array, \texttt{enum\_array}.
\ASLListing{Evaluating an \texttt{ARBITRARY} expression for array types}{semantics-earbitraryarray}
{\semanticstests/SemanticsRule.EArbitraryArray.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the \texttt{ARBITRARY} expression annotated with type $\vt$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{okay}
    \begin{itemize}
      \item the domain of $\vt$ in $\env$ (see \secref{DynDomain}) is not empty;
      \item $\vv$ is an arbitrary value in the domain of $\vt$ in $\env$;
      \item $\newenv$ is $\env$.
      \item $\vg$ is the empty execution graph.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item the domain of $\vt$ in $\env$ is empty;
      \item the result is a dynamic error (\ArbitraryEmptyType) indicating that the type $\vt$ has an empty
            domain in $\env$ and therefore no value can be returned.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \dynamicdomain(\env, \vt) \neq \emptyset\\
  \vv \in \dynamicdomain(\env, \vt)
}{
  \evalexpr{\env, \overname{\EArbitrary (\vt)}{\ve}} \evalarrow \Normal((\vv, \overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
  \inferrule[error]{
  \dynamicdomain(\env, \vt) = \emptyset
}{
  \evalexpr{\env, \overname{\EArbitrary (\vt)}{\ve}} \evalarrow \DynamicErrorVal{\ArbitraryEmptyType}
}
\end{mathpar}
\CodeSubsection{\EvalEArbitraryBegin}{\EvalEArbitraryEnd}{../Interpreter.ml}

\subsubsection{Comments}
Notice that this rule introduces non-determinism.
\identr{WLCH}

\section{Structured Type Construction Expressions\label{sec:StructuredTypeConstructionExpressions}}
\hypertarget{def-recordexpressionterm}{}
\ASLListing{Record construction expression}{semantics-erecord}{\semanticstests/SemanticsRule.ERecord.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tidentifier \parsesep \Tlbrace \parsesep \Tminus \parsesep \Trbrace &\\
	       |\ & \Tidentifier \parsesep \Tlbrace \parsesep \ClistOne{\Nfieldassign} \parsesep \Trbrace &\\
\Nfieldassign \derives \ & \Tidentifier \parsesep \Teq \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ERecord(\overtext{\ty}{record type}, \overtext{(\identifier, \expr)^{*}}{field initializers}) &
\end{flalign*}

\ASTRuleDef{ERecord}
\begin{mathpar}
  \inferrule[empty]{}{
    {
      \begin{array}{r}
    \buildexpr(\overname{\Nexpr(
    \begin{array}{l}
    \Tidentifier(\vt), \Tlbrace, \Tminus, \Trbrace
    \end{array}
    )}{\vparsednode}) \\
    \astarrow\ \overname{\ERecord(\TNamed(\vt), \emptylist)}{\vastnode}
\end{array}
}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_empty]{
    \buildclist[\buildfieldassign](\vfieldassigns) \astarrow \vfieldassignasts
  }{
    {
      \begin{array}{r}
  \buildexpr\left(\overname{\Nexpr\left(
    \begin{array}{l}
    \Tidentifier(\vt), \Tlbrace, \\
    \wrappedline\ \namednode{\vfieldassigns}{\ClistOne{\Nfieldassign}}, \\
    \wrappedline\ \Trbrace
    \end{array}
    \right)}{\vparsednode}\right) \\
    \astarrow\ \overname{\ERecord(\TNamed(\vt), \vfieldassignasts)}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{FieldAssign}
\hypertarget{build-fieldassign}{}
The function
\[
  \buildfieldassign(\overname{\parsenode{\Nfieldassign}}{\vparsednode}) \;\aslto\; \overname{(\identifier\times\expr)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildfieldassign(\Nfieldassign(\Tidentifier(\id), \Teq, \punnode{\Nexpr})) \astarrow
  \overname{(\id, \astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ERecord}
\listingref{semantics-erecord} shows an example of a well-typed record construction expression
and an example (in comment) where the same field is initialized twice, which is incalid..

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the record construction expression (which is also used for creating exceptions) of type $\tty$ with fields $\fields$,
        that is, $\ERecord(\tty, \vfields)$;
  \item obtaining the \underlyingtype\ of $\tty$ in $\tenv$ yields $\ttyanon$\ProseOrTypeError;
  \item checking that $\ttyanon$ is a \structuredtype\ yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item $\ttyanon$ is a \structuredtype\ with a list of $\field$ elements (consisting of a field name and a field type);
  \item obtaining the list of field names from $\vfields$ yields the list of identifiers \\
        $\initializedfields$;
  \item obtaining the list of field names from $\fieldtypes$ yields the list of identifiers $\names$;
  \item checking whether the set of identifiers in $\names$ is equal to the set of identifiers in $\initializedfields$
        yields $\True$\ProseOrTypeError;
  \item checking that the list $\initializedfields$ does not contain duplicates yields \\
        $\True$\ProseOrTypeError;
  \item applying $\annotatefieldinit$ to annotate each $\field$ element $(\name,\vep)$ of \\
        $\vfields$ in $\tenv$ yields $(\name,\ve_\name,\vxs_\name)$\ProseOrTypeError;
  \item define $\fieldsp$ as the list containing $(\name,\ve_\name)$ for each $\field$ element $(\name,\vep)$ of $\vfields$;
  \item $\vt$ is $\tty$;
  \item define $\newe$ as the record expression with type $\tty$ and field initializers $\fieldsp$, that is, $\ERecord(\tty, \fieldsp)$;
  \item define $\vsess$ as the union of the \sideeffectdescriptorsetsterm\ given by $\vxs_\name$ for each $\field$ element $(\name,\Ignore)$ of $\vfields$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed}{NamedTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \tty) \typearrow \ttyanon \OrTypeError\\\\
  \checktrans{\astlabel(\ttyanon) \in \{\TRecord, \TException\}}{\UnexpectedType} \typearrow \True\OrTypeError\\\\
  \ttyanon \eqname L(\fieldtypes)\\
  \initializedfields \eqdef \{\name \;|\; (\name, \Ignore)\in\vfields\}\\
  \names \eqdef \fieldnames(\fieldtypes)\\
  \checktrans{\{\names\} = \{\initializedfields\}}{\BadField} \typearrow \True \OrTypeError\\\\
  \checknoduplicates(\initializedfields) \typearrow \True \OrTypeError\\\\
  {
    \begin{array}{r}
  (\name, \vep) \in \vfields: \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow \\
  (\name, \ve_\name, \vxs_\name) \OrTypeError
    \end{array}
  }\\
  \fieldsp \eqdef [(\name, \vep) \in \fields : (\name, \ve_\name)]\\
  \vses \eqdef \bigcup_{(\name, \Ignore) \in \fields} \vxs_\name\\
}{
  \annotateexpr{\tenv, \overname{\ERecord(\tty, \vfields)}{\ve}} \typearrow
  (\overname{\tty}{\vt}, \overname{\ERecord(\tty, \fieldsp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ERecordBegin}{\ERecordEnd}{../Typing.ml}
\identr{WBCQ}

\hypertarget{def-annotatefieldinit}{}
\TypingRuleDef{AnnotateFieldInit}
The function
\[
\begin{array}{r}
  \annotatefieldinit(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\identifier\times\expr)}{(\name, \vep)} \aslsep
    \overname{\field^*}{\fieldtypes}
  ) \aslto \\
  (\overname{\identifier}{\name} \times \overname{\expr}{\vepp} \times \overname{\TSideEffectSet}{\vses})
\end{array}
\]
annotates a field initializers $(\name, \vep)$ in a record expression
with list of fields \\ $\fieldtypes$ and returns the annotated initializing expression $\vepp$
and its \sideeffectdescriptorterm\ $\vses$.
\ProseOtherwiseTypeError

See \listingref{semantics-erecord} for an example.

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vtp, \vepp, \vses)$\ProseOrTypeError;
  \item checking whether there exists a type associated with $\name$ in $\fieldtypes$ yields $\True$\ProseOrTypeError;
  \item the unique type associated with $\name$ in $\fieldtypes$ is $\tspecp$;
  \item determining whether $\vtp$ \typesatisfies\ $\tspecp$ in $\tenv$ yields $\True$\ProseOrTypeError;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vtp, \vepp, \vses) \OrTypeError\\\\
  \checktrans{\fieldtype(\fieldtypes, \name) \neq \bot}{\BadField} \typearrow \True \OrTypeError\\\\
  \fieldtype(\fieldtypes, \name) = \tspecp\\
  \checktypesat(\tenv, \vtp, \tspecp) \typearrow \True \OrTypeError
}{
  \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow (\name, \vepp, \vses)
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{ERecord}
\ExampleDef{Evaluation of Record Construction Expressions}
In \listingref{semantics-erecord},
the expression \verb|MyRecordType{a=3, b=42}| evaluates to the native record value \\
$\nvrecord{\va\mapsto\nvint(3), \vb\mapsto\nvint(42)}$.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a record creation expression, $\ERecord(\names, \efields)$;
\item the names of the fields are $\id_{1..k}$;
\item the expressions associated with the fields are $\ve_{1..k}$;
\item evaluating the expressions of $\fields$ in order yields \\
      $\Normal((\vvfields,\vg), \newenv)$\ProseOrAbnormal;
\item $\vvfields$ is a list of \nativevalues\ $\vv_{1..k}$;
\item $\vv$ is the native record that maps $\id_i$ to $\vv_i$, for $i=1..k$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \efields \eqname [i=1..k: (\id_i, \ve_i)]\\
  \names \eqdef \id_{1..k} \\
  \fields \eqdef \ve_{1..k} \\
  \evalexprlist{\env, \fields} \evalarrow \Normal((\vvfields,\vg), \newenv)  \OrAbnormal\\
  \vvfields \eqname \vv_{1..k}\\
  \vv \eqdef \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}}
}{
  \evalexpr{\env, \ERecord(\Ignore, \efields)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalERecordBegin}{\EvalERecordEnd}{../Interpreter.ml}

\section{Tuple Expressions\label{sec:TupleExpressions}}
\hypertarget{def-tupleexpressionterm}{}

\ASLListing{Tuple expression}{semantics-etuple}{\semanticstests/SemanticsRule.ETuple.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Plisttwo{\Nexpr} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ETuple(\expr^{+}) &
\end{flalign*}

\ASTRuleDef{ETuple}
\begin{mathpar}
\inferrule[tuple]{
  \buildplist[\buildexpr](\vexprs) \astarrow \vexprasts
}{
  \buildexpr(\overname{\Nexpr(\namednode{\vexprs}{\Plisttwo{\Nexpr}})}{\vparsednode}) \astarrow
  \overname{\ETuple(\vexprasts)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ETuple}
\listingref{semantics-etuple} shows an example of a well-typed tuple expressions.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{parenthesized}
  \begin{itemize}
    \item $\ve$ denotes a tuple expression with list of expressions consisting solely of $\vep$, that is, $\ETuple([\vep])$,
          meaning it represents a parenthesized expression (see \ASTRuleRef{ParenExpr});
    \item annotating $\vep$ in $\tenv$ yields $(\vt, \newe, \vses)$\ProseOrTypeError.
  \end{itemize}

  \item \AllApplyCase{list}
  \begin{itemize}
    \item $\ve$ denotes a tuple expression with list of expressions $\vli$, that is, $ \ETuple(\vli)$;
    \item $\vli$ consists of at least two expressions;
    \item annotating each expression $\vle[i]$ in $\tenv$, for $i=1..k$, yields $(\vt_i, \ve_i, \vxs_i$)\ProseOrTypeError;
    \item $\vt$ is the \tupletypeterm{} with list of types $\vt_i$, for $i=1..k$;
    \item $\newe$ is tuple expression over list of expressions $\ve_i$, for $i=1..k$;
    \item defining $\vses$ as the union of $\vxs_i$ for $i=1..k$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[parenthesized]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ETuple(\vep)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[list]{
  |\vli| > 1\\
  i=1..k: \annotateexpr{\tenv, \vle[i]} \typearrow (\vt_i, \ve_i, \vxs_i) \OrTypeError\\\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotateexpr{\tenv, \overname{\ETuple(\vli)}{\ve}} \typearrow (\overname{\TTuple(\vt_{1..k})}{\vt}, \overname{\ETuple(\ve_{1..k})}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ETupleBegin}{\ETupleEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{ETuple}
\ExampleDef{Evaluation of Tuple Expressions}
In \listingref{semantics-etuple},
the expression \texttt{(3, Return42())} evaluates to the value \texttt{(3, 42)}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a tuple expression, $\ETuple(\elist)$;
  \item the evaluation of $\elist$ in $\env$ is $\Normal((\vlist, \vg), \newenv)$\ProseOrAbnormal;
  \item $\vv$ is the native vector constructed from the values in $\vlist$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \newenv) \OrAbnormal\\
  \vv \eqdef \nvvector{\vlist}
}{
  \evalexpr{\env, \ETuple(\elist)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalETupleBegin}{\EvalETupleEnd}{../Interpreter.ml}

\section{Parenthesized Expressions\label{sec:ParenthesizedExpressions}}
A single expression inside parentheses is not considered to be a tuple, but rather the element
inside the parenthesis.
Parenthesizing an expression can be used to improve readability, enforce an order of evaluation,
and avoid binary operator precedence errors (see \ASTRuleRef{CheckNotSamePrec}).

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tlpar \parsesep \Nexpr \parsesep \Trpar &
\end{flalign*}

\subsection{Abstract Syntax}
We represent a parenthesized expression as a single element tuple for the technical
reason of enabling \ASTRuleRef{CheckNotSamePrec} by distinguishing parenthesized
expressions from non-parenthesized expressions. However, upon typing such expressions,
we ignore the parenthesis (see \TypingRuleRef{ETuple}.\textsc{PARENTHESIZED}).

\ASTRuleDef{ParenExpr}
\begin{mathpar}
  \inferrule[sub\_expr]{}{
  \buildexpr(\overname{\Nexpr(\Tlpar, \punnode{\Nexpr}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\ETuple([\ \astof{\vexpr}\ ])}{\vastnode}
}
\end{mathpar}

\section{Array Construction Expressions\label{sec:ArrayConstructionExpressions}}
Array construction expression are used by the type system to express the initialization
of array-typed variables. Since there is no syntax to initialize arrays, there are also
no rules for building the AST for such expressions nor rules for typechecking them.

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EArray\{\EArrayLength: \expr, \EArrayValue: \expr\} &\\
             |\ & \EEnumArray \{\EArrayLabels: \identifier^+, \EArrayValue: \expr\}
\end{flalign*}

\subsection{Semantics}

The Semantic Rules use $\evalexprsef\empty$ because the typechecker in
$\annotatetype$ guarantees that expressions in types are side-effect-free.

\SemanticsRuleDef{EArray}
In \listingref{typing-tarray},
the variable \verb|int_arr| is initialized with an array construction expression
(which is not expressible in ASL text, only in \typedast, but conceptually could be
represented as \verb|array[[4]] of 0|),
which evaluates to
\[
\nvvector{[\nvint(0), \nvint(0), \nvint(0), \nvint(0)]} \enspace.
\]

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is an array construction expression with length expression $\elength$ and value expression $\evalue$,
        that is, $\EArray\{\EArrayLength: \elength, \EArrayValue: \evalue\}$;
  \item evaluating the expression $\evalue$ in $\env$ yields $\Normal((\vvalue, \vgone), \newenv)$\ProseOrAbnormal;
  \item evaluating the side-effect-free expression $\elength$ in $\env$ yields \\
        $\Normal((\vlength, \vgtwo))$\ProseOrError;
  \item $\vlength$ is a native integer value for $\nlength$;
  \item checking that $\nlength$ is non-negative yields $\True$\ProseTerminateAs{\NegativeArrayLength};
  \item define $\vv$ as the native vector of length $\nlength$ where each position has the value $\vvalue$;
  \item define $\vg$ as the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \evalue} \evalarrow \Normal((\vvalue, \vgone), \newenv) \OrAbnormal\\\\
  \evalexprsef{\env, \elength} \evalarrow \Normal((\vlength, \vgtwo)) \OrDynError\\\\
  \vlength \eqname \nvint(\nlength)\\
  \checktrans{\nlength \geq 0}{\NegativeArrayLength} \checktransarrow \True \OrDynError\\\\
  \vv \eqdef \nvvector{i=1..\nlength: \vvalue}\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr{\env, \overname{\EArray\{\EArrayLength: \elength, \EArrayValue: \evalue\}}{\ve}} \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEArrayBegin}{\EvalEArrayEnd}{../Typing.ml}

\SemanticsRuleDef{EEnumArray}
In \listingref{typing-tarray},
the variable \verb|big_little_arr| is initialized with an array construction expression
(which is not expressible in ASL text, only in \typedast, but conceptually could be
represented as \verb|array[[Labels]] of '0000'|),
which evaluates to
\[
\nvrecord{\{\vBIG\mapsto\nvbitvector(0000), \vLITTLE\mapsto\nvbitvector(0000)\}} \enspace.
\]

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is an array construction expression for an enumerated-index array with
        list of labels $\vlabels$ and value expression $\evalue$,
        that is, \\
        $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \evalue\}$;
  \item evaluating the expression $\evalue$ in $\env$ yields $\Normal((\vvalue, \vg), \newenv)$\ProseOrAbnormal;
  \item \Proseeqdef{$\vv$}{the native record mapping each label $\vl\in\vlabels$ to $\vvalue$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \evalue} \evalarrow \Normal((\vvalue, \vg), \newenv) \OrAbnormal\\\\
  \vv \eqdef \nvrecord{\vl\in\vlabels: [\vl\mapsto \vvalue]}
}{
  {
  \begin{array}{r}
    \evalexpr{\env, \overname{\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \evalue\}}{\ve}} \evalarrow\\
    \Normal((\vv, \vg), \newenv)
  \end{array}
  }
}
\end{mathpar}

\CodeSubsection{\EvalEEnumArrayBegin}{\EvalEEnumArrayEnd}{../Typing.ml}

\section{Side-effect-free Expressions\label{sec:SideEffectFreeExpressions}}
\subsection{Typing}
An expression $\ve$ is considered to be side-effect-free in the static environment $\tenv$
if $\annotateexpr{\tenv, \ve} \typearrow (\Ignore, \Ignore, \vses)$
and $\vses$ only contains \sideeffectdescriptorsterm\ for reading storage (\ReadLocal\ and \ReadGlobal).

\subsection{Semantics}
\SemanticsRuleDef{ESideEffectFreeExpr}
\ProseParagraph
The helper relation
\hypertarget{def-evalexprsef}{}
\[
  \evalexprsef{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
  \Normal(\overname{\vals}{\vv}\aslsep\overname{\XGraphs}{\vg}) \cup
  \overname{\TDynError}{\DynErrorConfig}
\]
specializes the expression evaluation relation for side-effect-free expressions
by omitting throwing configurations as possible output configurations.

\ExampleDef{Evaluating a Side-effect-free Expression}
Evaluating the literal expression $\lint(1)$ in any environment $\env$,
yields \\
$\Normal(\nvint(1), \emptygraph)$.

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv,\vg), \env) \OrDynError
}{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\vv, \vg)
}
\end{mathpar}
Notice that the output configuration does not contain an environment,
since side-effect-free expressions do not modify the environment.

\section{Evaluating a List of Expressions\label{sec:ExprList}}
\SemanticsRuleDef{EExprList}
\hypertarget{def-evalexprlist}{}
The relation
\[
  \evalexprlist{\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vle}} \;\aslrel\;
  \Normal((\overname{\vals^*}{\vv} \times \overname{\XGraphs}{\vg})\aslsep \overname{\envs}{\newenv}) \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the list of expressions $\vle$ in left-to-right order in the initial environment $\env$
and returns the resulting value $\vv$, the parallel composition of the execution graphs
generated from evaluating each expression, and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.

\ExampleDef{Evaluating a List of Expressions}
In \listingref{semantics-erecord},
evaluating the expression \verb|MyRecordType{a=3, b=42}| entails evaluating
the expression list \verb|3, 42|, which yields
the list of values $[\nvint(3), \nvint(42)]$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item \Proseemptylist{$\vle$};
    \item \Proseemptylist{$\vv$};
    \item \Proseemptygraph{$\vg$};
    \item \Proseeqdef{$\newenv$}{$\env$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vle$ is a \Proselist{$\ve$}{$\vle1$};
    \item \Proseevalexpr{$\env$}{$\ve$}{\\ $\Normal((\vvone, \vgone), \envone)$}\ProseOrAbnormal;
    \item evaluating the list of expressions $\vle1$ in the environment $\envone$ yields $\Normal((\vvs, \vgtwo), \envtwo)$\ProseOrAbnormal;
    \item \Proseeqdef{$\vg$}{the parallel composition of $\vgone$ and $\vgtwo$};
    \item \Proseeqdef{$\vv$}{the list with \head{} $\vvone$ and \tail{} $\vvs$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \evalexprlist{\env, \overname{\emptylist}{\vle}} \evalarrow
  \Normal((\overname{\emptylist}{\vv}, \overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vle = [\ve] \concat \vle1\\
  \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \envone) \OrAbnormal\\\\
  \evalexprlist{\envone, \vle1} \evalarrow \Normal((\vvs, \vgtwo), \newenv) \OrAbnormal\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo \\
  \vv \eqdef [\vvone] \concat \vvs
}{
  \evalexprlist{\env, \vle} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
