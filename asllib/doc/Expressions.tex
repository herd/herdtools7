\chapter{Expressions\label{chap:Expressions}}

\hypertarget{def-rhsexpression}{}
Expressions calculate \nativevaluesterm{} from other \nativevaluesterm{}.
We will often refer to expressions defined in this chapter as \rhsexpressions{} to distinguish them
from \assignableexpressions, which are defined in \chapref{AssignableExpressions}.

Expressions can have side effects and can raise exceptions.
Therefore, ASL specifies an evaluation order to ensure that the side-effects/exceptions are predictable (see \secref{EvaluationOrder}).

\ExampleDef{Expressions}
\listingref{Expressions} shows some examples of expressions.
\ASLListing{Examples of expressions}{Expressions}{\definitiontests/Expressions.asl}

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Expressions} defines the formal relations for expressions;
  \item \secref{LiteralExpressions} defines \literalexpressionsterm;
  \item \secref{VariablExpressions} defines \variableexpressionsterm;
  \item \secref{BinaryExpressions} defines \binopexpressionsterm;
  \item \secref{UnaryExpressions} defines \unopexpressionsterm;
  \item \secref{ConditionalExpressions} defines \condexpressionsterm;
  \item \secref{CallExpressions} defines \callexpressionsterm;
  \item \secref{SlicingExpressions} defines \slicingexpressionsterm;
  \item \secref{ArrayAccessExpressions} defines \arrayaccessexpressionsterm;
  \item \secref{FieldReadingExpressions} defines field reading expressions;
  \item \secref{MultiFieldReadingExpressions} defines multi-field reading expressions;
  \item \secref{AssertingTypeConversionExpressions} defines asserting type conversion expressions;
  \item \secref{PatternMatchingExpressions} defines pattern matching expressions;
  \item \secref{ArbitraryValueExpressions} defines arbitrary value expressions;
  \item \secref{StructuredTypeConstructionExpressions} defines structured type construction expressions;
  \item \secref{TupleExpressions} defines tuple expressions;
  \item \secref{ParenthesizedExpressions} defines parenthesized expressions;
  \item \secref{ArrayConstructionExpressions} defines array construction expressions;
  \item \secref{SideEffectFreeExpressions} defines side-effect-free expressions;
  \item \secref{ExprList} defines the dynamic semantics of a list of expressions.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Expressions}
\paragraph{Syntax:} Expressions are grammatically derived from $\Nexpr$.

\paragraph{Abstract Syntax:} Expressions are derived in the abstract syntax from $\expr$,
and generated by $\buildexpr$.
\MarkedIgnoredRelationDefinition{
\hypertarget{build-expr}{}
The function
\[
  \buildexpr(\overname{\parsenode{\Nexpr}}{\vparsednode}) \;\aslto\; \overname{\expr}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms an expression parse node $\vparsednode$ into an expression AST node $\vastnode$.
\ProseOtherwiseBuildError
} % END_OF_IGNORED_RELATION


\paragraph{Typing:}
All expressions have a unique type (which can be a \tupletypeterm{}).
\RenderRelation{annotate_expr}
\BackupOriginalRelation{
The relation
\[
\annotateexpr(\overname{\staticenvs}{\texttt{tenv}}, \overname{\expr}{\texttt{e}})
\;\bigtimes\;
\left(\begin{array}{ll}
(\overname{\ty}{\texttt{t}}, \overname{\expr}{\texttt{new\_e}}, \overname{\pow{\TSideEffect}}{\texttt{ses}}) & \cup \\
 \typeerror & \\
\end{array}\right)
\]
annotates the expression $\texttt{e}$ in the
\staticenvironmentterm{} $\texttt{tenv}$,
 resulting in the following:
 $\texttt{t}$ is the type inferred for $\texttt{e}$;
 $\texttt{new\_e}$ is the \typedast{} for $\texttt{e}$, also known as the
\emph{annotated expression};
 and $\texttt{ses}$ is the \sideeffectsetterm{} inferred for $\texttt{e}$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION
The annotation rewrites the input expression in the following case, making the annotation of statements simpler:
variables with constant values are substituted by their constant values.

\paragraph{Semantics:}
\RenderRelation{eval_expr}
\BackupOriginalRelation{
The relation
\[
  \evalexpr(\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}) \;\aslrel\;
  \left(
  \begin{array}{ll}
  \ResultExpr((\overname{\nativevalue}{\vv} \times \overname{\XGraphs}{\vg}) \aslsep \overname{\envs}{\newenv}) & \cup\\
  \overname{\TThrowing}{\ThrowingConfig} & \cup \\
  \overname{\TDynError}{\DynErrorConfig} & \cup \\
  \overname{\TDiverging}{\DivergingConfig} & \\
  \end{array}
  \right)
\]
evaluates the expression $\ve$ in an environment $\env$ and terminates normally with
a \nativevalueterm{} $\vv$, an \executiongraphterm{} $\vg$, and a modified environment $\newenv$.
\ProseOtherwiseAbnormal
} % END_OF_BACKUP_RELATION
\hypertarget{def-literalexpressionterm}{}
\section{Literal Expressions\label{sec:LiteralExpressions}}
A literal expression represents a literal as an expression.

\ASLListing{Literal Expressions}{literalssemantics}{\semanticstests/SemanticsRule.Lit.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nvalue &\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_literal}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \ELiteral(\literal) &
\end{flalign*}
}

\ASTRuleDef{ELit}
\begin{mathpar}
\inferrule{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Nvalue})}{\vparsednode}) \astarrow
  \overname{\ELiteral(\astof{\vvalue})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ELit}
\ExampleDef{Typing of Literal Expressions}
In \listingref{literalssemantics}, each of the expressions \texttt{3}
is annotated with the type \verb|integer{3}|.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ is the literal expression $\vv$;
\item annotating the literal $\vv$ in the \staticenvironmentterm{} $\tenv$ yields is the type $\vt$;
\item \Proseeqdef{$\newe$}{$\ve$};
\item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \ve = \ELiteral(\vv)\\
  \annotateliteral(\tenv, \vv) \typearrow \vt
}{
  \annotateexpr(\tenv, \ve) \typearrow (\vt, \overname{\ve}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\ELitBegin}{\ELitEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{ELit}
\ExampleDef{Evaluation of Literal Expressions}
In \listingref{literalssemantics}, each of the expressions \texttt{3} evaluates to the \nativevalueterm{} $\nvint(3)$.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ is the literal expression for $\vl$, that is, $\ELiteral(\vl)$
\item $\vv$ is the \nativevalueterm{} corresponding to $\vl$;
\item $\vg$ is the empty graph, as literals do not yield any Read and Write Effects;
\item $\newenv$ is $\env$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \evalexpr(\env, \overname{\ELiteral(\vl)}{\ve}) \evalarrow \ResultExpr((\overname{\NVLiteral(\vl)}{\vv},\overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalELitBegin}{\EvalELitEnd}{../Interpreter.ml}

\hypertarget{def-variableexpressionterm}{}
\section{Variable Expressions\label{sec:VariablExpressions}}
A variable expression consists of an identifier for a storage element.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_var}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EVar(\overtext{\Identifier}{variable name}) &
\end{flalign*}
}

\ASTRuleDef{EVAR}
\begin{mathpar}
  \inferrule{}{
  \buildexpr(\overname{\Nexpr(\Tidentifier(\id))}{\vparsednode}) \astarrow
  \overname{\EVar(\id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EVar}
\ExampleDef{Typing Variable Expressions}
All of the variable expressions in \listingref{expressions-evar}
are well-typed.
\ASLListing{Variable expressions}{expressions-evar}{\typingtests/TypingRule.EVar.asl}

The variable \texttt{t} in \listingref{expressions-evar-undefined} is undefined.
\ASLListing{An undefined variable}{expressions-evar-undefined}{\typingtests/TypingRule.EVar.undefined.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{local}
    \begin{itemize}
    \item $\vx$ is bound to the type $\vt$ and local declaration keyword $k$
          via the \\
          $\localstoragetypes$ map of the local environment component of $\tenv$;
    \item define $\newe$ as $\ve$;
    \item define $\vses$ as the \sideeffectsetterm\ produced from $k$ by $\sesldk$.
    \end{itemize}

    \item \AllApplyCase{global\_constant}
    \begin{itemize}
    \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
    \item $\vx$ is bound to $(\tty, \GDKConstant)$ via the $\globalstoragetypes$ map of the global component of $\tenv$;
    \item $\vx$ is bound to $\vv$ via the $\constantvalues$ map of the global component of $\tenv$;
    \item define $newe$ as the literal expression for $\vv$;
    \item define $\vses$ as the empty set.
    \end{itemize}

    \item \AllApplyCase{global\_non\_constant}
    \begin{itemize}
      \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
      \item $\vx$ is bound to $(\tty, k)$ via the $\globalstoragetypes$ map of the global component of $\tenv$;
      \item either $\vx$ is not bound in the $\constantvalues$ map of the global component of $\tenv$ or $k$ is not $\GDKConstant$;
      \item define $newe$ as $\ve$;
      \item define $\vses$ as the \sideeffectsetterm\ produced from $k$ by $\sesgdk$.
    \end{itemize}

    \item \AllApplyCase{error\_undefined}
    \begin{itemize}
      \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
      \item $\vx$ is not bound via the $\globalstoragetypes$ map of the local component of $\tenv$;
      \item the result is a \typingerrorterm{} indicating that $\vx$ is an undefined identifier ($\UndefinedIdentifier$).
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\localstoragetypes(\vx) =  (\vt, k) \\
  \sesldk(k) \typearrow \vses
}{
  \annotateexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow (\vt, \overname{\EVar(\vx)}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[global\_constant]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \vv
}{
  \annotateexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow (\tty, \overname{\eliteral{\vv}}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global\_non\_constant]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, k)\\
  G^\tenv.\constantvalues(\vx) = \bot \lor k \neq \GDKConstant\\
  \sesgdk(k) \typearrow \vses
}{
  \annotateexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow (\tty, \overname{\EVar(\vx)}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[error\_undefined]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = \bot
}{
  \annotateexpr(\tenv,\overname{\EVar(\vx)}{\ve}) \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{EVar}

\ExampleDef{Evaluation of a Local Variable Expression}
In \listingref{localvarsemantics}, the evaluation of \texttt{x} within \texttt{assert x == 3;}
uses \\ \SemanticsRuleRef{EVar}.LOCAL.
\ASLListing{Semantics of local variables}{localvarsemantics}{\semanticstests/SemanticsRule.ELocalVar.asl}

\ExampleDef{Evaluation of a Global Variable Expression}
In \listingref{globalvarsemantics}, the evaluation of~\texttt{global\_x} within~\texttt{assert global\_x == 3;}
uses the rule \SemanticsRuleRef{EVar}.GLOBAL.
\ASLListing{Semantics of global variables}{globalvarsemantics}{\semanticstests/SemanticsRule.EGlobalVar.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a variable expression, that is, $\EVar(\vx)$;
  \item view $\env$ as an environment where $\denv$ is the dynamic environment;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{local}
    \begin{itemize}
      \item $\vx$ is bound locally in $\env$;
      \item $\vv$ is the value of $\vx$ in the local component of $\env$;
    \end{itemize}

    \item \AllApplyCase{global}
    \begin{itemize}
      \item $\vx$ is bound in the storage map of $\denv$;
      \item $\vv$ is the value of $\vx$ in the global component of $\env$;
    \end{itemize}
  \end{itemize}
  \item $\newenv$ is $\env$;
  \item $\vg$ is the graph containing a single Read Effect for $\vx$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local]{
  \env \eqname (\Ignore, \denv)\\
  \vx \in \dom(L^\denv)
}{
  \evalexpr(\env, \EVar(\vx)) \evalarrow \ResultExpr((\overname{L^\denv(\vx)}{\vv}, \overname{\ReadEffect(\vx)}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  \env \eqname (\Ignore, \denv)\\
  \vx \in \dom(G^\denv.\storage)
}{
  \evalexpr(\env, \EVar(\vx)) \evalarrow \ResultExpr((\overname{G^\denv.\storage(\vx)}{\vv}, \overname{\ReadEffect(\vx)}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalEVarBegin}{\EvalEVarEnd}{../Interpreter.ml}

\subsubsection{Comments}
When there exists a global variable $\vx$, the type system
forbids having $\vx$ as a local variable.
This is enforced by \TypingRuleRef{LDVar} in the Chapter ``Typing of Local Declarations'',
and
\TypingRuleRef{DeclareGlobalStorage} and \TypingRuleRef{DeclareOneFunc},
both in the Chapter ``Typing of Global Declarations''.

\hypertarget{def-binopexpressionterm}{}
\section{Binary Expressions\label{sec:BinaryExpressions}}
Binary expressions apply a binary operator to two sub-expressions.

\RequirementDef{OperatorPrecedence}
Operator precedence is used to disambiguate binary expressions.

Given two binary operators $\opone$ and $\optwo$, an expression of the form
$x\ \opone\ y\ \optwo\ z$, is interpreted as
$(x\ \opone\ y)\ \optwo\ z$
if $\opone$ has higher precedence than $\optwo$ and as $x\ \opone\ (y\ \optwo\ z)$ if $\opone$ has lower precedence than $\optwo$.
If $\opone$ is associative and $\opone$ = $\optwo$ then the expression may be interpreted as either
$(x\ \opone\ y)\ \optwo\ z$ or as $x\ \opone\ (y\ \optwo\ z)$ since there is no difference.
Otherwise it is a static operator precedence error (\BinopPrecedence).
See \ASTRuleRef{EBinop} for the formal details.

The operator classes and precedence order is defined by the following table
(a subset of the table in \secref{PriorityAndAssociativity},
which contains tokens that are not operators, but are needed for parsing disambiguation):

\begin{center}
\begin{tabular}{lll}
\hline
\textbf{Precedence} & \textbf{Class} & \textbf{Operators}\\
\hline
7 (Highest) & \textbf{Membership} & \Tin\\
6 & \textbf{Unary}                & \Tminus, \Tnot, \Tbnot\\
5 & \textbf{Power}                & \Tpow\\
4 & \textbf{Mul-Div-Shift}        & \Tmul, \Tdiv, \Tdivrm, \Trdiv, \Tmod, \Tshl, \Tshr\\
3 & \textbf{Add-Sub-Logic}        & \Tplus, \Tminus, \Tor, \Tand, \Txor, \Tcoloncolon, \Tplusplus\\
2 & \textbf{Relational}           & \Tgt, \Tgeq, \Tlt, \Tleq\\
1 & \textbf{(In-)Equality}        & \Teqop, \Tneq\\
0 & \textbf{Boolean}              & \Tbor, \Tband, \Timpl, \Tbeq\\
\hline
\end{tabular}
\end{center}

The set of \emph{associative binary operators} consists of the following:
$\ADD$,
$\MUL$,
$\BAND$,
$\BOR$,
$\AND$,
$\OR$,
$\XOR$,
$\BEQ$,
$\BVCONCAT$,
$\STRCONCAT$.

The specification in \listingref{BinaryExpressions} shows examples of binary expressions
and the effect of operator precedence.
\ASLListing{Binary expressions and operator precedence}{BinaryExpressions}{\definitiontests/Guide.OperatorPrecedence.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Nbinop \parsesep \Nexpr &\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_binop}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EBinop(\binop, \expr, \expr) &
\end{flalign*}
}

\ASTRuleDef{EBinop}
The following rule constructs a binary expression AST
and ensures that\\
\RequirementRef{OperatorPrecedence} holds.

The specification in \listingref{BinaryExpressions}
shows examples where \RequirementRef{OperatorPrecedence} holds.
%
The specifications in
\listingref{EBinop-bad1},
\listingref{EBinop-bad2},
\listingref{EBinop-bad3},
\listingref{EBinop-bad4}, and
\listingref{EBinop-bad5}
show examples that violate \RequirementRef{OperatorPrecedence},
which results in a \builderrorterm.
\ASLListing{Violation of operator precedence}{EBinop-bad1}{\syntaxtests/ASTRule.EBinop.bad1.asl}
\ASLListing{Violation of operator precedence}{EBinop-bad2}{\syntaxtests/ASTRule.EBinop.bad2.asl}
\ASLListing{Violation of operator precedence}{EBinop-bad3}{\syntaxtests/ASTRule.EBinop.bad3.asl}
\ASLListing{Violation of operator precedence}{EBinop-bad4}{\syntaxtests/ASTRule.EBinop.bad4.asl}
\ASLListing{Violation of operator precedence}{EBinop-bad5}{\syntaxtests/ASTRule.EBinop.bad5.asl}

\begin{mathpar}
  \inferrule{
    \buildexpr(\veone) \astarrow \astversion{\veone} \OrBuildError\\\\
    \buildexpr(\vetwo) \astarrow \astversion{\vetwo} \OrBuildError\\\\
    \checknotsameprec(\astof{\vbinop}, \astversion{\veone}) \astarrow \True \OrBuildError\\\\
    \checknotsameprec(\astof{\vbinop}, \astversion{\vetwo}) \astarrow \True \OrBuildError
  }{
    {
      \begin{array}{r}
  \buildexpr(\overname{\Nexpr(\namednode{\veone}{\Nexpr}, \punnode{\Nbinop}, \namednode{\vetwo}{\Nexpr})}{\vparsednode}) \astarrow\\
  \overname{\EBinop(\astversion{\veone}, \astof{\vbinop}, \astversion{\vetwo})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\ASTRuleDef{CheckNotSamePrec}
\hypertarget{build-binopprec}{}
We define the helper function
\[
  \binopprec(\overname{\binop}{\op}) \aslto \N
\]
which assigns a precedence level to each binary operator $\op$, as defined below:
\begin{mathpar}
\inferrule{}{
  {
  \binopprec(\op) \astarrow
  \begin{cases}
    5 & \text{if }\op = \POW\\
    4 & \text{if }\op \in \{\MUL, \DIV, \DIVRM, \RDIV, \MOD, \SHL, \SHR\}\\
    3 & \text{if }\op \in \left\{
        \begin{array}{l}
          \ADD, \SUB, \OR, \XOR, \\
          \AND, \BVCONCAT, \STRCONCAT
        \end{array}
        \right\}\\
    2 & \text{if }\op \in \{\EQ, \NE\}\\
    1 & \text{if }\op \in \{\BOR, \BAND, \IMPL, \BEQ \}\\
    0 & \text{if }\op \in \{\GT, \GE, \LT, \LE\}\\
  \end{cases}
  }
}
\end{mathpar}

\MarkedIgnoredRelationDefinition{
\hypertarget{build-checknotsameprec}{}
The function
\[
\checknotsameprec(\overname{\binop}{\op} \aslsep \overname{\expr}{\ve})
\aslto \{\True\} \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
checks whether the expression AST node $\ve$ is a binary operator, either with a different operator to $\op$ but the same \emph{precedence}, or the same non-associative operator $\op$.
In either case, it is considered an error.
Surrounding $\ve$ by parenthesis fixes the error.
} % END_OF_IGNORED_RELATION


For example, \texttt{a + b + c} is considered legal, since the same binary operator (\texttt{+})
is used, whereas \texttt{a - b - c} and \texttt{a + b - c} are considered illegal.
For the first, this is because $\SUB$ is not associative.
For the second, this is because $\ADD$ and $\SUB$ have the
same precedence ($3$). To fix these, we can surround one of the subexpressions with parenthesis,
for example: \texttt{(a - b) - c} and \texttt{(a + b) - c}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{not\_binop}
  \begin{itemize}
    \item $\ve$ is not a binary operation expression;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{binop\_same}
  \begin{itemize}
    \item $\ve$ is a binary operation expression for the operator $\opp$;
    \item $\opp$ is the same operator as $\op$;
    \item checking whether $\op$ is an associative operator yields $\True$\ProseTerminateAs{\BinopPrecedence}.
  \end{itemize}

  \item \AllApplyCase{binop\_different}
  \begin{itemize}
    \item $\ve$ is a binary operation expression for the operator $\opp$;
    \item $\opp$ is not the same operator as $\op$;
    \item checking whether $\op$ and $\opp$ have different precedence levels yields $\True$\ProseTerminateAs{\BinopPrecedence}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_binop]{
  \astlabel(\ve) \neq \EBinop
}{
  \checknotsameprec(\op, \ve) \astarrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[binop\_same]{
  \op = \opp \\
  {
  \checktrans{\op \in \left\{
    \begin{array}{l}
      \ADD, \MUL, \BAND, \BOR, \AND, \OR, \\
      \XOR, \BEQ, \BVCONCAT, \STRCONCAT
    \end{array}
    \right\}}{\BinopPrecedence} \checktransarrow \True \OrBuildError
  }
}{
  \checknotsameprec(\op, \overname{\EBinop(\opp, \Ignore, \Ignore)}{\ve}) \astarrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[binop\_different]{
  \op \neq \opp \\
  \checktrans{\binopprec(\op) \neq \binopprec(\opp)}{\BinopPrecedence} \checktransarrow \True \OrBuildError
}{
  \checknotsameprec(\op, \overname{\EBinop(\opp, \Ignore, \Ignore)}{\ve}) \astarrow \True
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EBinop}
\ExampleDef{An ill-typed Binary Expression}
The specification in \listingref{typing-binoperror} is ill-typed, since,
according to the signature of $\divint$, \Tdiv{} can only be applied to \integertypesterm{}
whereas \verb|0.0| is a \realtypeterm.
\ASLListing{An ill-typed binary expression}{typing-binoperror}{\typingtests/TypingRule.EBinop.bad.asl}

\ExampleDef{Comparing Well-constrained Integers}
The specification in \listingref{EBinop} is well-typed.
Specifically, it is legal to compare \wellconstrainedintegertypesterm{}
with different lists of constraints and a \wellconstrainedintegertypeterm{} to an \unconstrainedintegertypeterm{}.
\ASLListing{Comparing well-constrained integers}{EBinop}{\typingtests/TypingRule.EBinop.asl}

\ExampleDef{Typing Bitvector Concatenation}
The specification in \listingref{EBinop-2} is well-typed, since
the sum of widths of the two concatenated \bitvectortypesterm{}
is equal to the width of the \bitvectortypeterm{} of the return type.
\ASLListing{Concatenating bitvectors}{EBinop-2}{\typingtests/TypingRule.EBinop2.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a binary operation $\op$ over two expressions $\veone$ and $\vetwo$, that is, \\ $\EBinop(\op, \veone, \vetwo)$;
  \item \Proseannotateexpr{$\tenv$}{$\veone$}{\\ $(\vtone, \veonep, \vsesone)$\ProseOrTypeError};
  \item \Proseannotateexpr{$\tenv$}{$\vetwo$}{\\ $(\vttwo, \vetwop, \vsestwo)$\ProseOrTypeError};
  \item \Proseapplybinoptypes{$\tenv$}{\op}{\vtone}{\vttwo}{$\vt$\ProseOrTypeError};
  \item define $\newe$ as the binary expression $\op$ over $\veonep$ and $\vetwop$;
  \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vtone, \veonep, \vsesone) \OrTypeError\\\\
  \annotateexpr(\tenv, \vetwo) \typearrow (\vttwo, \vetwop, \vsestwo) \OrTypeError\\\\
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateexpr(\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow (\vt, \overname{\EBinop(\op, \veone', \vetwo')}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\BinopBegin}{\BinopEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{BinopAnd}
\ExampleDef{Evaluation of Boolean And Expressions}
In \listingref{andsemantics},
the expression \texttt{FALSE \&\& fail()} evaluates to the value \texttt{FALSE}. Notice that the function \texttt{fail} is never called.
\ASLListing{Semantics of conjunction}{andsemantics}{\semanticstests/SemanticsRule.EBinopAndFalse.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a conjunction over two expressions,
      $\EBinop(\BAND, \veone, \vetwo)$;
\item $C$ is the result of the evaluation of the expression
      \texttt{if e1 then e2 else false} (see \SemanticsRuleRef{ECond}).
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \falsep \eqdef \ELiteral(\LBool(\False))\\
  \evalexpr(\env, \ECond(\veone, \vetwo, \falsep)) \evalarrow C
}{
\evalexpr(\env, \EBinop(\BAND, \veone, \vetwo)) \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalBinopAndBegin}{\EvalBinopAndEnd}{../Interpreter.ml}

\subsubsection{Comments}
The evaluation via the rule above ensures that $\veone$ is evaluated first and
only if it evaluates to $\True$ is $\vetwo$ evaluated.

\identr{BKNT} % TODO: add table

\identi{QRXP}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{==>} provide a short-circuit evaluation mechanism:

% This is related to the note under \identr{LRHD}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\SemanticsRuleDef{BinopOr}
\ExampleDef{Evaluation of Boolean Or Expressions}
In \listingref{semantics-binopor}, the expression \texttt{(0 == 1) || (1 == 1)} evaluates to the value \True.
\ASLListing{Evaluating a disjunction expression}{semantics-binopor}{\semanticstests/SemanticsRule.EBinopOrTrue.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a disjunction of two expressions, $\EBinop(\BOR, \veone, \vetwo)$;
\item $C$ is the result of the evaluation of
      \texttt{if e1 then true else e2} (see \SemanticsRuleRef{ECond}).
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \truep \eqdef \ELiteral(\LBool(\True))\\
  \evalexpr(\env, \ECond(\veone, \truep, \vetwo)) \evalarrow C
}{
\evalexpr(\env, \EBinop(\BOR, \veone, \vetwo)) \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalBinopOrBegin}{\EvalBinopOrEnd}{../Interpreter.ml}

The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
it evaluates to $\False$, is $\vetwo$ evaluated.

\subsubsection{Comments}
\identr{BKNT} % TODO: add table

\identi{QRXP}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{==>} provide a short-circuit evaluation mechanism:

% This is related to the note under \identr{LRHD}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\SemanticsRuleDef{BinopImpl}
\ExampleDef{Evaluation of Implication Expressions}
In \listingref{semantics-binopimpl},
the expression \texttt{(0 == 1) ==> (1 == 0)} evaluates to the value \True, according to the definition of implication.
\ASLListing{Evaluating an implication expression}{semantics-binopimpl}{\semanticstests/SemanticsRule.EBinopImplExFalso.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an implication over two expressions, $\EBinop(\IMPL, \veone, \vetwo)$;
  \item $\ve$ is evaluated as \texttt{if e1 then e2 else true}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \truep \eqdef \ELiteral(\LBool(\True))\\
  \evalexpr(\env, \ECond(\veone, \vetwo, \truep)) \evalarrow C
}{
\evalexpr(\env, \EBinop(\IMPL, \veone, \vetwo)) \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalBinopImplBegin}{\EvalBinopImplEnd}{../Interpreter.ml}
The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
it evaluates to \True, is $\vetwo$ evaluated.

\lrmcomment{This is related to \identr{BKNT}: add table}

\identi{QRXP}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{==>} provide a short-circuit evaluation mechanism:

\lrmcomment{This is related to the note under \identr{LRHD}:}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\SemanticsRuleDef{Binop}
\ExampleDef{Evaluation of Binary Expressions}
In \listingref{semantics-binopassert},
the expression \texttt{3 + 2} evaluates to the value \texttt{5}.
\ASLListing{Evaluating a binary expression}{semantics-binopassert}{\semanticstests/SemanticsRule.EBinopPlusAssert.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a Binary Operator $\op$ over two expressions, $\EBinop(\op, \veone, \vetwo)$;
  \item the operator $\op$ is not one of $\BAND$, $\BOR$, or $\IMPL$.
        These operators are handled by rules
        \SemanticsRuleRef{BinopAnd},
        \SemanticsRuleRef{BinopOr}, and
        \SemanticsRuleRef{BinopImpl};
  \item the evaluation of the expression $\veone$ in $\env$ is the configuration \\
        $\ResultExpr(\vmone, \envone)$\ProseOrAbnormal;
  \item the evaluation of the expression $\vetwo$ in $\envone$ is the configuration \\
        $\ResultExpr(\vmtwo, \newenv)$\ProseOrAbnormal;
  \item $\vmone$ consists of the value $\vvone$ and the execution graph $\vgone$;
  \item $\vmtwo$ consists of the value $\vvtwo$ and the execution graph $\vgtwo$;
  \item applying the Binary Operator $\op$ to $\vvone$ and $\vvtwo$ results in $\vv$\ProseOrError;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\
  \evalexpr( \env, \veone) \evalarrow \ResultExpr(\vmone, \envone) \OrAbnormal \\\\
  \evalexpr( \envone, \vetwo ) \evalarrow \ResultExpr(\vmtwo, \newenv) \OrAbnormal \\\\
  \vmone \eqname (\vvone, \vgone) \\
  \vmtwo \eqname (\vvtwo, \vgtwo) \\
  \evalbinop(\op, \vvone, \vvtwo) \evalarrow \vv \OrDynError\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr( \env, \overname{\EBinop(\op, \veone, \vetwo)}{\ve} ) \evalarrow
  \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalBinopBegin}{\EvalBinopEnd}{../Interpreter.ml}

The rule above applies to many binary operators, including $\EQ$ (which is used for \texttt{<=>}
as well as \texttt{==}).

\subsubsection{Comments}
\lrmcomment{This is related to \identr{BKNT}: add table}

\hypertarget{def-unopexpressionterm}{}
\section{Unary Expressions\label{sec:UnaryExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nunop \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_unop}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EUnop(\unop, \expr) &
\end{flalign*}
}

\ASTRuleDef{EUnop}
\begin{mathpar}
  \inferrule{
    \buildexpr(\vexpr) \astarrow \astversion{\vexpr} \OrBuildError
  }{
  \buildexpr(\overname{\Nexpr(\punnode{\Nunop}, \vexpr : \Nexpr)}{\vparsednode}) \astarrow
  \overname{\EUnop(\astof{\vunop}, \astversion{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EUnop}
\ExampleRef{Applying Unary Operations to Types} shows examples
of well-typed unary operation expressions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a unary operation $\op$ over an expression $\vep$, that is $\EUnop(\op, \vep)$;
  \item annotating $\vep$ in $\tenv$ yields $(\vtpp, \vepp, \vses)$\ProseOrTypeError;
  \item checking compatibility of $\op$ with $\vtpp$ as per \TypingRuleRef{ApplyUnopType} yields $\vt$\ProseOrTypeError;
  \item define $\newe$ as $\op$ over $\vepp$, that is, $\EUnop(\op, \vepp)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \vep) \typearrow (\vtpp, \vepp, \vses) \OrTypeError\\\\
  \applyunoptype(\tenv, \op, \vtpp) \typearrow \vt \OrTypeError
}{
  \annotateexpr(\tenv, \EUnop(\op, \vep)) \typearrow (\vt, \EUnop(\op, \vepp), \vses)
}
\end{mathpar}
\CodeSubsection{\UnopBegin}{\UnopEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{Unop}
\ExampleDef{Evaluation of a Unary Operation Expression}
In \listingref{semantics-unopassert},
the expression \texttt{NOT '1010'} evaluates to the value \texttt{'0101'}.
\ASLListing{Evaluating a unary operation expression}{semantics-unopassert}{\semanticstests/SemanticsRule.EUnopAssert.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a unary operator $\op$ over an expression, $\EUnop(\op, \veone)$;
\item the evaluation of the expression $\veone$ in $\env$ yields \\ $\ResultExpr((\vvone, \vg), \newenv)$\ProseOrAbnormal;
\item applying the unary operator $\op$ to $\vvone$ is $\vv$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr( \env, \veone) \evalarrow \ResultExpr((\vvone,\vg), \newenv) \OrAbnormal\\\\
  \evalunop(\op, \vvone) \evalarrow \vv
}
{
  \evalexpr( \env, \EUnop(\op, \veone) ) \evalarrow
  \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalUnopBegin}{\EvalUnopEnd}{../Interpreter.ml}

\hypertarget{def-conditionexpressionterm}{}
\section{Conditional Expressions\label{sec:ConditionalExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nexpr \parsesep \Telse \parsesep \Nexpr &\\
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_cond}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \ECond(\overtext{\expr}{condition}, \overtext{\expr}{then}, \overtext{\expr}{else})
\end{flalign*}
}

\ASTRuleDef{ECond}
\begin{mathpar}
  \inferrule{
    \buildexpr(\vcondexpr) \astarrow \astversion{\vcondexpr} \OrBuildError\\\\
    \buildexpr(\vthenexpr) \astarrow \astversion{\vthenexpr} \OrBuildError\\\\
    \buildexpr(\velseexpr) \astarrow \astversion{\velseexpr} \OrBuildError\\\\
  }{
    {
      \begin{array}{r}
  \buildexpr\left(\overname{\Nexpr\left(
    \begin{array}{l}
    \Tif, \namednode{\vcondexpr}{\Nexpr}, \Tthen, \\
    \wrappedline\ \namednode{\vthenexpr}{\Nexpr}, \Telse, \namednode{\velseexpr}{\Nexpr}
    \end{array}
    \right)}{\vparsednode}\right) \astarrow\\
  \overname{\ECond(\astversion{\vcondexpr}, \astversion{\vthenexpr}, \astversion{\velseexpr})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ECond}
\ExampleDef{Typing Conditional Expressions}
The specification in \listingref{ECond} is well-typed and shows
an example of typing a conditional expression.
\ASLListing{Typing conditional expressions}{ECond}{\typingtests/TypingRule.ECond.asl}

\ExampleRef{Lowest Common Ancestor Examples} shows more examples of typing conditional expressions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a conditional expression with condition $\econd$ with two options $\etrue$ and $\efalse$;
  \item annotating $\econd$ in $\tenv$ results in $(\tcond, \econdp, \vsescond)$\ProseOrTypeError;
  \item annotating $\etrue$ in $\tenv$ results in $(\ttrue, \etruep, \vsestrue)$\ProseOrTypeError;
  \item annotating $\efalse$ in $\tenv$ results in $(\tfalse, \efalsep, \vsesfalse)$;
  \item obtaining the lowest common ancestor of $\ttrue$ and $\tfalse$ results in $\vt$\ProseOrTypeError;
  \item $\newe$ is the condition $\econdp$ with two options $\etruep$ and $\efalsep$, that is, $\ECond(\econdp, \etruep, \efalsep)$;
  \item define $\vses$ as the union of $\vsescond$, $\vsestrue$, and $\vsesfalse$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \econd) \typearrow (\tcond, \econd', \vsescond) \OrTypeError\\\\
  \annotateexpr(\tenv, \etrue) \typearrow (\ttrue, \etrue', \vsestrue) \OrTypeError\\\\
  \annotateexpr(\tenv, \efalse) \typearrow (\tfalse, \efalse', \vsesfalse) \OrTypeError\\\\
  \lca(\ttrue, \tfalse) \typearrow \vt \OrTypeError\\\\
  \vses \eqdef \vsescond \cup \vsestrue \cup \vsesfalse
}{
  {
    \begin{array}{r}
  \annotateexpr(\ECond(\econd, \etrue, \efalse)) \typearrow \\
  (\vt, \ECond(\econdp, \etruep, \efalsep), \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\ECondBegin}{\ECondEnd}{../Typing.ml}
\identr{XZVT}

\subsection{Semantics}
\SemanticsRuleDef{ECond}
\ExampleDef{Evaluation of Conditional Expressions}
In \listingref{semantics-econdfalse},
the expression \texttt{if FALSE then Return42() else 3} evaluates to the value \texttt{3}.
\ASLListing{Evaluating a conditional expression yielding the result of the \texttt{else} subexpression}
{semantics-econdfalse}{\semanticstests/SemanticsRule.ECondFalse.asl}

\ExampleDef{Evaluation of a Non-deterministic Conditional Expression}
In \listingref{semantics-econdarbitrary},
the expression \texttt{if ARBITRARY: boolean then 3 else Return42()} will
evaluate to either \texttt{3} or \texttt{Return42()}, depending on the
(non-deterministic) result of \\
\texttt{ARBITRARY: boolean}.
\ASLListing{Evaluating a conditional expression with non-determinic choice}{semantics-econdarbitrary}
{\semanticstests/SemanticsRule.ECondARBITRARY3or42.asl}

% Transliteration note: the code uses an optimized semantics for the case where
% true and false sub-expressions do not contain function calls. Since this is an
% optimization, we do not document it.
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a conditional expression $\econd$ with two options $\veone$ and $\vetwo$,
        that is, $\ECond(\econd, \veone, \vetwo)$;
  \item the evaluation of the conditional expression $\econd$ in $\env$ yields \\
        $\ResultExpr(\mcond, \envone)$\ProseOrAbnormal;
  \item $\mcond$ consists of a native Boolean for $\vb$ and execution graph $\vgone$;
  \item $\vep$ is $\veone$ if $\vb$ is $\True$ and $\vetwo$ otherwise;
  \item the evaluation of $\vep$ in $\envone$ yields $\ResultExpr((\vvtwo, \vgtwo), \newenv)$\ProseOrAbnormal;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \econd) \evalarrow \ResultExpr(\mcond, \envone) \OrAbnormal\\\\
  \mcond \eqname (\nvbool(\vb), \vgone)\\
  \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\\\
  \evalexpr(\envone, \vep) \evalarrow \ResultExpr((\vv, \vgtwo), \newenv)  \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
}{
  \evalexpr(\env, \overname{\ECond(\econd, \veone, \vetwo)}{\ve}) \evalarrow
  \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalECondBegin}{\EvalECondEnd}{../Interpreter.ml}

\subsubsection{Comments}
\identr{YCDB}

A conditional expression evaluates to its \texttt{then} expression if the
condition expression evaluates to $\True$. If the condition expression
evaluates to $\False$ each \texttt{elsif} condition expression is evaluated
sequentially until an \texttt{elsif} condition expression evaluates to $\True$;
the conditional expression evaluates to the corresponding \texttt{elsif}
expression. If no \texttt{elsif} expression evaluates to $\True$ the
conditional expression evaluates to the \texttt{else} expression.

\hypertarget{def-callexpressionterm}{}
\section{Call Expressions\label{sec:CallExpressions}}
\ASLListing{Call expressions}{semantics-ecall}{\semanticstests/SemanticsRule.ECall.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Ncall &
\end{flalign*}

\begin{flalign*}
\Ncall \derives \
     & \Tidentifier \parsesep \PlistZero{\Nexpr} &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace \parsesep \PlistZero{\Nexpr} &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_call}
\BackupOriginalAST{
\hypertarget{ast-expr}{}\hypertarget{ast-ECall}{}
\begin{flalign*}
\expr \derives\ & \ECall(\overtext{\call}{call descriptor})
\hypertarget{ast-call}{}\\
\call \derives\ & \left\{\begin{array}{lll}
\text{name} &:& \Strings\\
\text{params} &:& \KleeneStar{\expr}\\
\text{args} &:& \KleeneStar{\expr}\\
\text{call\_type} &:& \subprogramtype
\end{array}\right\}
\end{flalign*}
}

\ASTRuleDef{Call}
\hypertarget{build-call}{}
\begin{mathpar}
\inferrule{
  \buildplist[\buildexpr](\vargs) \astarrow \vargasts
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \namednode{\vargs}{\PlistZero{\Nexpr}})}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
        \callname &:& \id,\\
        \callparams &:& \emptylist,\\
        \callargs &:& \vargasts,\\
        \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\and
\inferrule{
  \buildlist[\buildexpr](\vparams) \astarrow \astversion{\vparams} \\
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \Tlbrace, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace)}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
              \callname &:& \id,\\
              \callparams &:& \astversion{\vparams},\\
              \callargs &:& \emptylist,\\
              \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\and
\inferrule{
  \buildplist[\buildexpr](\vargs) \astarrow \vargasts \\
  \buildlist[\buildexpr](\vparams) \astarrow \astversion{\vparams} \\
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \Tlbrace, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}})}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
              \callname &:& \id,\\
              \callparams &:& \astversion{\vparams},\\
              \callargs &:& \vargasts,\\
              \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\end{mathpar}

\ASTRuleDef{SetCallType}
\hypertarget{def-setcalltype}{}
Above, $\STFunction$ is inserted as a default call type for any parsed $\call$.
The function
\[
  \setcalltype(\overname{\call}{\vcall} \aslsep \overname{\subprogramtype}{\calltype}) \aslto \overname{\call}{\vcallp}
\]
changes the call type of $\vcall$ to $\calltype$.

\begin{mathpar}
\inferrule{}{
  \setcalltype(\vcall, \calltype) \aslto
  \overname{\vcall[\callcalltype\mapsto\calltype]}{\vcallp}
}
\end{mathpar}

\ASTRuleDef{ECall}
\begin{mathpar}
\inferrule{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Ncall})}{\vparsednode}) \astarrow
  \overname{\ECall(\astof{\vcall})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ECall}
\ExampleDef{Typing Call Expressions}
\listingref{semantics-ecall} shows call expressions (on the right-hand-side of assignments)
and the inferred types of the expressions, as type annotations on the left-hand-side variables.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a call to a subprogram, that is, $\ECall(\vcall)$;
  \item applying $\annotatecall$ to $\vcall$ and in $\tenv$
        annotates the call of the subprogram in $\tenv$ as a function (see Chapter~\ref{chap:SubprogramCalls})
        and yields $(\vcallp, \some{ \vt }, \vses)$\ProseOrTypeError.
  \item $\newe$ is the call using $\vcallp$, that is, $\ECall(\vcallp)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatecall(\vcall) \typearrow (\vcallp, \some{ \vt }, \vses) \OrTypeError
}{
  \annotateexpr(\tenv, \overname{\ECall(\vcall)}{\ve}) \typearrow (\vt, \overname{\ECall(\vcallp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ECallBegin}{\ECallEnd}{../Typing.ml}
\identd{CFYP} \identr{BQJG}

\subsection{Semantics}
\SemanticsRuleDef{ECall}
\ExampleDef{Evaluation of Call Expressions}
\listingref{semantics-ecall} shows call expressions (on the right-hand-side of assignments)
and the values they evaluate to, as assertions on the values assigned.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a subprogram call, $\ECall(\vcall)$;
  \item the evaluation of that subprogram call in $\env$ is either\\
  $\ResultExpr(\vms, \newenv)$\ProseOrAbnormal;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{single\_returned\_value}
    \begin{itemize}
      \item $\vms$ consists of a single returned value $(\vv,\vg)$,
      which goes into the output configuration $\ResultExpr((\vv, \vg), \newenv)$.
    \end{itemize}

    \item \AllApplyCase{multiple\_returned\_values}
    \begin{itemize}
      \item $\vms$ consists of a list of returned value $(\vv_i,\vg_i)$, for $i=1..k$;
      \item $\vg$ is the parallel composition of $\vg_i$, for $i=1..k$;
      \item $\vv$ is the \nativevalueterm{}  vector of values $\vv_i$, for $i=1..k$;
      \item the resulting configuration is $\ResultExpr((\vv, \vg), \newenv)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[single\_returned\_value]{
  \evalcall(\env, \vcall.\name, \vcall.\params, \vcall.\args) \evalarrow \ResultExpr(\vms, \newenv) \OrAbnormal\\
  \vms \eqname [(\vv, \vg)]
}{
  \evalexpr(\env, \ECall(\vcall)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[multiple\_returned\_values]{
  \evalcall(\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs) \evalarrow \ResultExpr(\vms, \newenv) \OrAbnormal\\
  \vms \eqname [i=1..k: (\vv_i, \vg_i)]\\
  \vg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k \\
  \vv \eqdef \NVVector(\vv_{1..k})
}{
  \evalexpr(\env, \ECall(\vcall)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalECallBegin}{\EvalECallEnd}{../Interpreter.ml}

\hypertarget{def-slicingexpressionsterm}{}
\section{Slicing Expressions\label{sec:SlicingExpressions}}
This section details the high-level form of the syntax and abstract syntax of slicing expressions,
and defines the semantics of bitvector slices.
The details of the various types of bitvector slices are deferred to \chapref{BitvectorSlicing}.

The well-typed specification in \listingref{Bitvector_slices2} shows examples of bitvector slices.
\ASLListing{Slicing Expressions}{Bitvector_slices2}{\definitiontests/Bitvector_slices2.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Nexpr \parsesep \Nslices &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_slice}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \ESlice(\expr, \slice^{*}) &
\end{flalign*}
}

\ASTRuleDef{ESlice}
\begin{mathpar}
\inferrule{
  \buildexpr(\vexpr) \astarrow \astversion{\vexpr} \OrBuildError\\\\
  \buildslices(\vslices) \astarrow \astversion{\vslices} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\vexpr: \Nexpr, \vslices: \Nslices)}{\vparsednode}) \astarrow
  \overname{\ESlice(\astversion{\vexpr}, \astversion{\vslices})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ESlice}
\ExampleDef{Typing of Slicing Expressions}
\listingref{semantics-eslice} the type inferred for the
slicing expression \verb|'1 1110 000'[6:3, 7]| is \\
\verb|bits(5){}|.
That is, a bitvector of width \verb|5| without any bitfields.
%
The same type is inferred for the slicing expressions
\verb|240[6:3, 7]| and \verb|496[6:3, 7]|
(\verb|240| is equivalent to \verb|'1 111 0 000'|
and \verb|496| is equivalent to \verb|'11 111 0 000'|).

The specifications in \listingref{ESlice-bad1}
and \listingref{ESlice-bad2} show examples of ill-typed bitvector slicing expressions.
\ASLListing{Ill-typed slicing expressions}{ESlice-bad1}{\typingtests/TypingRule.ESlice.bad1.asl}
\ASLListing{Ill-typed slicing expressions}{ESlice-bad2}{\typingtests/TypingRule.ESlice.bad2.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
        $\ESlice(\vep, \slices)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\tep,\vepp, \vsesone)$\ProseOrTypeError;
  \item obtaining the \structureterm\ of $\tep$ in $\tenv$ yields $\structtep$\ProseOrTypeError;
  \item $\structtep$ is either a bitvector or an integer;
  \item checking that $\slices$ is not empty yields $\True$\ProseTerminateAs{\BadSlices};
  \item annotating $\slices$ in $\tenv$ yields $(\slicesp, \vsestwo)$\ProseOrTypeError;
  \item obtaining the width of $\slices$ in $\tenv$ via $\sliceswidth$ yields $\vw$\ProseOrTypeError;
  \item $\vt$ is the bitvector type of width $\vw$, that is, $\TBits(\vw, \emptylist)$;
  \item define $\newe$ as the slicing of expression $\vepp$ by the slices $\slicesp$, that is, \\
        $\ESlice(\vepp, \slicesp)$;
  \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \vep) \typearrow (\tep, \vepp, \vsesone) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \structtep \OrTypeError\\\\
  \astlabel(\structtep) \in \{\TInt, \TBits\}\\
  \checktrans{\slices \neq \emptylist}{\BadSlices} \typearrow \True \OrTypeError\\\\
  \annotateslices(\tenv, \slices) \typearrow (\slicesp, \vsestwo) \OrTypeError\\\\
  \sliceswidth(\tenv, \slices) \typearrow \vw \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateexpr(\tenv, \overname{\ESlice(\vep, \slices)}{\ve}) \typearrow
  (\overname{\TBits(\vw, \emptylist)}{\vt}, \overname{\ESlice(\vepp, \slicesp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ESliceBegin}{\ESliceEnd}{../Typing.ml}
\subsubsection{Comments}
The width of \slices\ might be a symbolic expression if one of the
widths references a \texttt{let} identifier with a non-compile-time-constant
initializer expression.
\identi{MJWM}

\TypingRuleDef{ESliceError}
\ExampleDef{Ill-typed Slicing Expressions}
The expression \verb|5.0[2:0]| is ill-typed, since the type of \verb|5.0|
is an \integertypeterm{} nor a \bitvectortypeterm.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure $\vtp$;
  \item $\vtp$ is neither an integer type or a bitvector type;
  \item the result is an error indicating that the type of $\vep$ is inappropriate for slicing.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \vep) \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \vtp\\
  \astlabel(\vtp) \not\in \{\TInt, \TBits\}
}{
  \annotateexpr(\tenv, \overname{\ESlice(\vep, \slices)}{\ve}) \typearrow \TypeErrorVal{\BadSlices}
}
\end{mathpar}
\CodeSubsection{\ESliceError}{\ESliceErrorEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{ESlice}
\ExampleDef{Evaluation of Slicing Expressions}
\listingref{semantics-eslice} the slicing expression \verb|'1 1110 000'[6:3, 7]|
evaluates to the bitvector value \texttt{'1110 1'},
same as the slicing expressions
\verb|240[6:3, 7]| and \verb|496[6:3, 7]|.

\ASLListing{Slicing Expressions}{semantics-eslice}{\semanticstests/SemanticsRule.ESlice.asl}

Note that in the following definition,
the function $\readfrombitvector$ takes care of converting integers to bitvectors.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a slicing expression, $\ESlice(\ebv, \slices)$;
\item the evaluation of $\ebv$ in $\env$ yields $\ResultExpr(\mbv, \envone)$\ProseOrAbnormal;
\item the evaluation of $\slices$ in $\env$ yields $\ResultExpr(\mpositions, \newenv)$\ProseOrAbnormal;
\item $\mpositions$ consists of $\positions$ --- all the indices that need to be added to the
resulting bitvector --- and the execution graph $\vgone$;
\item reading from $\vbv$ as a bitvector at the indices indicated by $\positions$
      (see \SemanticsRuleRef{ReadFromBitvector}) results in the bitvector $\vv$,
      which concatenates all of the values from the indicates indices\ProseOrError;
\item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \ebv) \evalarrow \ResultExpr(\mbv, \envone)  \OrAbnormal\\\\
  \mbv \eqname (\vbv,\vgone) \\
  \evalslices(\envone, \slices) \evalarrow \ResultSlices(\mpositions, \newenv)  \OrAbnormal \\
  \mpositions \eqname (\positions, \vgtwo) \\
  \readfrombitvector(\vbv, \positions) \evalarrow \vv \OrDynError\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr(\env, \ESlice(\ebv, \slices)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalESliceBegin}{\EvalESliceEnd}{../Interpreter.ml}

\hypertarget{def-arrayaccessexpressionsterm}{}
\hypertarget{def-getarrayexpressionterm}{}
\hypertarget{def-getenumarrayexpression}{}
\section{Array Access Expressions\label{sec:ArrayAccessExpressions}}
This section details the syntax, abstract syntax, semantics, and typing of array read expressions.
In the untyped AST, a read from either an integer-indexed array or an enumeration-indexed arrays is represented
the same way. The type system infers the kind of array and outputs a typed AST node differentiating
the two kinds of arrays, either a $\EGetArray$ or a $\EGetEnumArray$, via \TypingRuleRef{EGetArray}.
The semantics utilizes a rule matching the corresponding type of array ---
\SemanticsRuleRef{EGetArray} for integer-indexed arrays and
\SemanticsRuleRef{EGetEnumArray} for enumeration-indexed arrays.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Nexpr \parsesep \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_getarray}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EGetArray(\expr, \expr) &
\end{flalign*}
}

\ASTRuleDef{EGetArray}
\begin{mathpar}
\inferrule{
  \buildexpr(\veone) \astarrow \astversion{\veone} \OrBuildError\\\\
  \buildexpr(\vetwo) \astarrow \astversion{\vetwo} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\namednode{\veone}{\Nexpr}, \Tllbracket, \namednode{\vetwo}{\Nexpr}, \Trrbracket)}{\vparsednode}) \astarrow
  \overname{\EGetArray(\astversion{\veone}, \astversion{\vetwo})}{\vastnode}
}
\end{mathpar}

\TypingRuleDef{EGetArray}
\hypertarget{def-arrayaccess}{}
\begin{definition}[Array Access]
We refer to a \rhsexpression{} of the form \verb|b[[i]]|,
where $b, i$ are subexpressions, as an \arrayaccessterm\ expression.
We refer to $b$ and $i$ as the \emph{base}
and the $\emph{index}$ subexpressions, respectively.
\end{definition}

\ExampleDef{Array Access Expressions}
\listingref{typing-tarray} shows examples of well-typed
array access expressions on the right-hand-side of the
assignments to \verb|int_arr| and \verb|big_little_arr|
and the types inferred for them via the added \verb|as <inferred-type>|.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the \arrayaccessterm{} expression with base $\ebase$ and index $\eindex$;
  \item \Proseannotateexpr{$\tenv$}{$\ebase$}{\\ $(\tbase,\ebasep, \vsesbase)$}\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\tbase$ in $\tenv$ yields $\tanonbase$\ProseOrTypeError;
  \item checking whether $\tanonbase$ is an array type yields $\True$\ProseOrTypeError;
  \item view $\tanonbase$ as the array type with size expression $\size$ and element type $\telem$,
        that is, $\TArray(\size, \telem)$;
  \item applying $\annotategetarray$ to $(\size, \telem)$ and \\
        $(\ebasep, \vsesbase, \eindex)$ yields
        $(\vt, \newe, \vses)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \ebase) \typearrow (\tbase, \ebasep, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tanonbase \OrTypeError\\\\
  \checktrans{\astlabel(\tanonbase) = \TArray}{ExpectedArrayType} \typearrow \True \OrTypeError\\\\
  \tanonbase \eqname \TArray(\size, \telem)\\
  {
    \begin{array}{r}
  \annotategetarray(\tenv, (\size, \telem), (\ebasep, \vsesbase, \eindex)) \typearrow \\ (\vt, \newe, \vses)
    \end{array}
  }
}{
  \annotateexpr(\tenv, \overname{\EGetArray(\ebase, \eindex)}{\ve}) \typearrow (\vt, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\EGetArrayBegin}{\EGetArrayEnd}{../Typing.ml}

\TypingRuleDef{AnnotateGetArray}
\RenderRelation{annotate_get_array}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\annotategetarray(
  \overname{\staticenvs}{\tenv} \aslsep
  (\overname{\expr}{\size} \times \overname{\ty}{\telem}) \aslsep
  (\overname{\expr}{\ebase} \times \overname{\TSideEffectSet}{\vsesbase} \times \overname{\expr}{\eindex})
)
\aslto \\
(\overname{\ty}{\vt} \times \overname{\expr}{\newe} \times \overname{\TSideEffectSet}{\vses})
\end{array}
\]
annotates an array access expression with the following elements:
$\size$ is the expression representing the array size,
$\telem$ is the type of array elements,
$\ebase$ is the annotated expression for the array base,
$\eindex$ is the index expression.
The function returns the type of the annotated expression in $\vt$,
the annotated expression $\newe$, and the inferred \sideeffectdescriptorterm\ $\vses$.
} % END_OF_BACKUP_RELATION

See \ExampleRef{Array Access Expressions}.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseannotateexpr{$\tenv$}{$\eindex$}{(\tindexp, \eindexp, \vsesindex)}\ProseOrTypeError;
  \item applying $\typeofarraylength$ to $\size$, to obtain the type of the array length, yields
        $\wantedtindex$;
  \item checking that $\tindexp$ \typesatisfiesterm\ $\wantedtindex$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item define $\vses$ as the union of $\vsesindex$ and $\vsesbase$;
  \item \Proseeqdef{$\newe$}{
    an access to an integer-indexed array for $\ebase$ and $\eindexp$, that is, $\EGetArray(\ebase, \eindexp)$ if $\size$ is an integer-typed array index,
    and an access to an enumeration-indexed array for $\ebase$ and $\eindexp$, that is,\\
    $\EGetEnumArray(\ebase, \eindexp)$ if $\size$ is an enumeration-typed array index.
  }
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \eindex) \typearrow (\tindexp, \eindexp, \vsesindex) \OrTypeError\\\\
  \typeofarraylength(\size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesindex \cup \vsesbase \\
  {
    \newe \eqdef \begin{cases}
      \EGetArray(\ebase, \eindexp)     & \text{if }\astlabel(\size) = \ArrayLengthExpr\\
      \EGetEnumArray(\ebase, \eindexp) & \text{if }\astlabel(\size) = \ArrayLengthEnum
    \end{cases}
  }
}{
  {
  \begin{array}{r}
  \annotategetarray(\tenv, (\size, \telem), (\ebase, \vsesbase, \eindex)) \typearrow\\
  (\overname{\telem}{\vt}, \newe, \vses)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\AnnotateGetArrayBegin}{\AnnotateGetArrayEnd}{../Typing.ml}

\SemanticsRuleDef{EGetArray}
\ExampleDef{Evaluation of Array Reading Expressions}
In \listingref{semantics-egetarray},
the expression \verb|my_array[[2]]| appearing in the assertion evaluates to the value \texttt{42} since the element
indexed by \texttt{2} in \texttt{my\_array} is \texttt{42}.
\ASLListing{Evaluating an array access expression}{semantics-egetarray}{\semanticstests/SemanticsRule.EGetArray.asl}

\ExampleDef{Evaluation of an Illegal Array Read}
In \listingref{semantics-egetarrayerror},
evaluating the array access expression \verb|my_array[[3]]| results in a \DynamicErrorConfigurationTerm{},
since we are trying to access index \texttt{3} of an array
which has indexes \texttt{0}, \texttt{1} and \texttt{2} only.
\ASLListing{Evaluating an illegal array access}{semantics-egetarrayerror}{\semanticstests/SemanticsRule.EGetArrayTooSmall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an array access expression, $\EGetArray(\earray, \eindex)$;
  \item the evaluation of $\earray$ in $\env$ is $\ResultExpr(\marray, \envone)$\ProseOrAbnormal;
  \item the evaluation of $\eindex$ in $\env$ is  $\ResultExpr(\mindex, \newenv)$\ProseOrAbnormal
  \item $\marray$ consists of the native vector $\varray$ and execution graph $\vgone$;
  \item $\mindex$ consists of the native integer $\vindex$ and execution graph $\vgtwo$;
  \item $\vindex$ is the native integer for $\vi$;
  \item evaluating the value at index $\vi$ of $\varray$ yields $\vv$\ProseOrError;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \earray) \evalarrow \ResultExpr(\marray, \envone)  \OrAbnormal\\
  \evalexpr(\envone, \eindex) \evalarrow \ResultExpr(\mindex, \newenv)  \OrAbnormal\\
  \marray \eqname (\varray, \vgone)\\
  \mindex \eqname (\vindex, \vgtwo)\\
  \vindex \eqname \nvint(\vi)\\
  \getindex(\vi, \varray) \evalarrow \vv \OrDynError\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo\\
}{
  \evalexpr(\env, \EGetArray(\earray, \eindex)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetArrayBegin}{\EvalEGetArrayEnd}{../Interpreter.ml}

\SemanticsRuleDef{EGetEnumArray}
\ExampleDef{Evaluation of Reading from an Enumeration-indexed Array}
In \listingref{semantics-egetenumarray},
the enumeration-typed array \texttt{Arr} is accessed for reading and writing
with indices taken from the \enumerationtypeterm{} \texttt{Enum}.
\ASLListing{Evaluating an access to an enumeration-indexed array}{semantics-egetenumarray}
{\semanticstests/SemanticsRule.EGetEnumArray.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an array access expression, $\EGetArray(\earray, \eindex)$;
  \item the evaluation of $\earray$ in $\env$ is $\ResultExpr(\marray, \envone)$\ProseOrAbnormal;
  \item the evaluation of $\eindex$ in $\env$ is  $\ResultExpr(\mindex, \newenv)$\ProseOrAbnormal
  \item $\marray$ consists of the native value $\varray$ and execution graph $\vgone$;
  \item $\mindex$ consists of the native value $\vindex$ and execution graph $\vgtwo$;
  \item $\vindex$ is the native literal for the label $\vl$;
  \item accessing the field $\vl$ of $\varray$, which is a native record value, yields $\vv$;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \earray) \evalarrow \ResultExpr(\marray, \envone)  \OrAbnormal\\
  \evalexpr(\envone, \eindex) \evalarrow \ResultExpr(\mindex, \newenv)  \OrAbnormal\\
  \marray \eqname (\varray, \vgone)\\
  \mindex \eqname (\vindex, \vgtwo)\\
  \vindex \eqname \nvlabel(\vl)\\
  \getfield(\vl, \varray) \evalarrow \vv\\
  \vg \eqdef \vgone \parallelcomp \vgtwo\\
}{
  \evalexpr(\env, \EGetEnumArray(\earray, \eindex)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetEnumArrayBegin}{\EvalEGetEnumArrayEnd}{../Interpreter.ml}

\hypertarget{def-getfieldexpressionterm}{}
\section{Field Reading Expressions\label{sec:FieldReadingExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tdot \parsesep \Tidentifier&
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_getfield}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EGetField(\overtext{\expr}{record}, \overtext{\Identifier}{field name}) &
\end{flalign*}
}

\ASTRuleDef{EGetField}
\begin{mathpar}
  \inferrule{
    \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError
  }{
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tdot, \Tidentifier(\id))}{\vparsednode}) \astarrow
  \overname{\EGetField(\astversion{\ve}, \id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EGetRecordField}
\ExampleDef{Typing Record Field Expressions}
\listingref{eget-record-field} shows field reading expressions
as the \rhsexpressions{} of assignments
and the types inferred for them via the added \verb|as <inferred type>|.
\ASLListing{Typing record field expressions}{eget-record-field}{\typingtests/TypingRule.EGetRecordField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a record or exception type with fields $\fields$;
  \item the field $\fieldname$ is associated with the type $\vt$ in $\fields$
  \item define $\newe$ as the access of field $\fieldname$ on the record or exception object $\vetwo$, that is, $\EGetField(\vetwo, \fieldname)$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \some{ \vt}
}{
  {
    \begin{array}{r}
      \annotateexpr(\tenv, \EGetField(\veone, \fieldname)) \typearrow \\
      (\vt, \EGetField(\vetwo, \fieldname), \overname{\vsesone}{\vses})
    \end{array}
  }
}
\end{mathpar}

\CodeSubsection{\EGetRecordFieldBegin}{\EGetRecordFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBadRecordField}
\ExampleDef{Ill-typed Record Field Expressions}
\listingref{eget-bad-record-field} shows an ill-typed field expression.
\ASLListing{An ill-typed record field expression}{eget-bad-record-field}{\typingtests/TypingRule.EGetBadRecordField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a record or exception type with fields $\fields$;
  \item the field $\fieldname$ is not associated with any type in $\fields$
  \item the result is a \typingerrorterm{} indicating the missing field.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \None
}{
  \annotateexpr(\tenv, \EGetField(\veone, \fieldname)) \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}
\CodeSubsection{\EGetBadRecordFieldBegin}{\EGetBadRecordFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBadBitField}
\ExampleDef{Ill-typed Bitfield Expressions}
\listingref{eget-bad-bitfield} shows an ill-typed bitfield expression.
\ASLListing{An ill-typed bitfield expression}{eget-bad-bitfield}{\typingtests/TypingRule.EGetBadBitfield.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item the field $\fieldname$ is not found in $\bitfields$
  \item the result is a \typingerrorterm{} indicating the missing field.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \None
}{
  \annotateexpr(\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}) \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}
\CodeSubsection{\EGetBadBitFieldBegin}{\EGetBadBitFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetCollectionField}

\ExampleDef{Typing Collection Field Expressions}
All of the collection field expressions in
\listingref{typing-lesetcollectionfields} are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vetwo$ is a variable expression for $\vbase$, that is, $\EVar(\vbase)$;
  \item $\vtetwo$ is a collection type with fields $\fields$;
  \item the field $\fieldname$ is associated with the type $\vt$ in $\fields$
  \item define $\newe$ as the access of field $\fieldname$ on the collection object $\vbase$, that is, $\EGetCollectionFields(\vbase, [\fieldname])$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vetwo = \EVar(\vbase) \\
  \vtetwo = \TCollection(\fields)\\
  \assocopt(\fields, \fieldname) \typearrow \some{ \vt}
}{
  {
    \begin{array}{r}
      \annotateexpr(\tenv, \EGetField(\veone, \fieldname)) \typearrow \\
      (\vt, \EGetCollectionFields(\vbase, [\fieldname]), \overname{\vsesone}{\vses})
    \end{array}
  }
}
\end{mathpar}

\CodeSubsection{\EGetCollectionFieldBegin}{\EGetCollectionFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBitField}
\ExampleDef{Well-typed Bitfield Expressions}
\listingref{eget-bitfield} shows well-typed bitfield expressions
as the \rhsexpressions{} of assignment statements,
and the types inferred for them via the added \verb|as <inferred-type>|.
\ASLListing{Well-typed bitfield expressions}{eget-bitfield}{\typingtests/TypingRule.EGetBitfield.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$, that is, \\ $\BitFieldSimple(\Ignore, \slices)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vt, \newe, \vses)$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \some{ \BitFieldSimple(\Ignore, \slices)}\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr(\tenv, \vethree) \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr(\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}) \typearrow (\vt, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldBegin}{\EGetBitFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBitFieldNested}
\ExampleDef{Nested Bitfield Expressions}
\listingref{eget-bitfield} shows the expression \verb|p.detailed_data.info|,
which refers to the bitfield \verb|info|, which is nested in the bitfield
\verb|detailed_data|.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and nested bitfields $\bitfieldsp$, that is,
        $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe, \vsesnew)$\ProseOrTypeError;
  \item $\vtefour$ is a bitvector type with length expression $\width$, that is, $\TBits(\width, \Ignore)$;
  \item define $\vt$ as a bitvector type with length expression $\width$ and bitfields $\bitfieldsp$;
  \item define $\vses$ as $\vsesnew$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TBits(\Ignore, \bitfields)\\\\
  {
    \begin{array}{r}
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \\ \some{ \BitFieldNested(\Ignore, \slices, \bitfieldsp)}
    \end{array}
  }\\\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr(\tenv, \vethree) \typearrow (\vtefour, \newe, \vsesnew) \OrTypeError\\\\
  \vtefour \eqname \TBits(\width, \Ignore)\\
  \vt \eqdef \TBits(\width, \bitfieldsp)
}{
  \annotateexpr(\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}) \typearrow (\vt, \newe, \overname{\vses}{\vsesnew})
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldNestedBegin}{\EGetBitFieldNestedEnd}{../Typing.ml}

\TypingRuleDef{EGetBitFieldTyped}
\ExampleDef{Typed Bitfield Expressions}
\listingref{eget-bitfield} shows the expression \verb|p.detailed_data.info|,
which includes the type annotation \verb|bits(4)|.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and typed bitfield with type $\vt$ that is,
        $\BitFieldType(\Ignore, \slices, \vt)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe, \vsesnew)$\ProseOrTypeError;
  \item determining whether $\vtefour$ \typesatisfiesterm\ $\vt$ yields $\True$\ProseOrTypeError;
  \item define $\vses$ as $\vsesnew$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \some{ \BitFieldType(\Ignore, \slices, \vt)}\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr(\tenv, \vethree) \typearrow (\vtefour, \newe, \vsesnew) \OrTypeError\\\\
  \checktypesat(\tenv, \vtefour, \vt) \typearrow \True \OrTypeError
}{
  \annotateexpr(\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}) \typearrow (\vt, \newe, \overname{\vses}{\vsesnew})
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldTypedBegin}{\EGetBitFieldTypedEnd}{../Typing.ml}

\TypingRuleDef{EGetTupleItem}
\ExampleDef{Typing of a Tuple Item Expression}
In \listingref{semantics-egetitem}, the type of the expression \verb|t.item0|
is the \integertypeterm.

In the following rule definition, we use $\itemprefix$ to stand
for its verbatim string.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is \tupletypeterm{} with list of types $\tys$, that is, $\TTuple(\tys)$;
  \item $\fieldname$ is an identifier consisting of the prefix \itemprefix{} and the suffix $\num$;
  \item $\num$ is lexically an integer numeral with the integer value $\vindex$;
  \item determining whether $\vindex$ is between $0$ and the number of types in $\tys$, inclusive, yields $\True$\ProseOrTypeError;
  \item $\vt$ is the type at position $\vindex$ of $\tys$;
  \item $\newe$ is the expression for obtaining the item at index $\vindex$ from the expression $\vetwo$, that is, $\EGetItem(\vetwo, \vindex)$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo = \TTuple(\tys)\\
  \fieldname = \itemprefix \stringconcat \num\\
  \num \in \Lang(\REintlit)\\
  \decimaltolit(\num) = \Tintlit(\vindex)\\
  \checktrans{0 \leq \vindex \leq \listlen{\tys}}{\BadTupleIndex} \checktransarrow \True \OrTypeError\\\\
  \vt \eqdef \tys[\vindex]\\
  \newe \eqdef \EGetItem(\vetwo, \vindex)
}{
  \annotateexpr(\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}) \typearrow (\vt, \newe, \overname{\vsesone}{\vses})
}
\end{mathpar}
\CodeSubsection{\EGetTupleItemBegin}{\EGetTupleItemEnd}{../Typing.ml}

\TypingRuleDef{EGetBadField}
\ExampleDef{An Ill-typed Field Expression}
\listingref{eget-bad-field} shows an example of an ill-typed field expression
\verb|a.f|.
\ASLListing{An ill-typed field expression}{eget-bad-field}{\typingtests/TypingRule.EGetBadBitField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is neither one of the following types: record, exception, bitvector, or tuple;
  \item the result is an error indicating that the type of $\veone$ is inappropriate for accessing the field $\fieldname$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \astlabel(\vtetwo) \not\in \{\TRecord, \TException, \TBits, \TTuple\}
}{
  \annotateexpr(\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\EGetBadFieldBegin}{\EGetBadFieldEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EGetField}
\ExampleDef{Evaluation of a Field Read Expression}
In \listingref{semantics-egetfield},
the expression \verb|my_record.a| evaluates to the value \texttt{3}.
\ASLListing{Evaluating a field access expression}{semantics-egetfield}{\semanticstests/SemanticsRule.ERecord.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a field access expression, $\EGetField(\erecord, \fieldname)$;
\item the evaluation of $\erecord$ in $\env$ is $\ResultExpr((\vrecord, \vg), \newenv)$\ProseOrAbnormal;
\item $\vv$ is the value mapped by $\fieldname$ in the native record $\vrecord$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \erecord) \evalarrow \ResultExpr((\vrecord, \vg), \newenv)  \OrAbnormal\\
  \getfield(\fieldname, \vrecord) \evalarrow \vv
}{
  \evalexpr(\env, \EGetField(\erecord, \fieldname)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetFieldBegin}{\EvalEGetFieldEnd}{../Interpreter.ml}

\SemanticsRuleDef{EGetItem}
\ExampleDef{Evaluation of a Tuple Item Expression}
In \listingref{semantics-egetitem},
the expression \verb|t.item0| evaluates to the value \texttt{1}
and
the expression \verb|t.item1| evaluates to the value \texttt{2}.
\ASLListing{Evaluating a tuple item access expression}{semantics-egetitem}{\semanticstests/SemanticsRule.EGetItem.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is an expression for accessing the component given by the index $\vindex$ of the tuple
        given by the expression $\etuple$, that is, $\EGetItem(\etuple, \vindex)$;
  \item evaluating the expression $\etuple$ yields $\ResultExpr((\vvtuple, \vg), \newenv)$\ProseOrAbnormal;
  \item accessing the native tuple value $\vvtuple$ at index $\vindex$ via $\getindex$, yields
        the native value $\vv$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \etuple) \evalarrow \ResultExpr((\vvtuple, \vg), \newenv) \OrAbnormal\\\\
  \getindex(\vvtuple, \vindex) \evalarrow \vv
}{
  \evalexpr(\env, \overname{\EGetItem(\etuple, \vindex)}{\ve}) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetTupleItemBegin}{\EvalEGetTupleItemEnd}{../Interpreter.ml}

\hypertarget{def-getfieldsexpressionterm}{}
\section{Multi-field Reading Expressions\label{sec:MultiFieldReadingExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tdot \parsesep \Tlbracket \parsesep \ClistOne{\Tidentifier} \parsesep \Trbracket &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_getfields}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EGetFields(\overtext{\expr}{record}, \overtext{\Identifier^{*}}{field names}) &
\end{flalign*}
}

\ASTRuleDef{EGetFields}
\begin{mathpar}
  \inferrule{
    \buildclist[\buildidentity](\vids) \astarrow \vidasts\\
    \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError
  }{
    {
      \begin{array}{r}
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tdot, \Tlbracket, \namednode{\vids}{\ClistOne{\Tidentifier}}, \Trbracket)}{\vparsednode}) \astarrow\\
  \overname{\EGetFields(\astversion{\ve}, \vidasts)}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EGetFields}
\ExampleDef{Typing Multi-field Expressions}
\pagebreak
\listingref{egetfields} shows examples of well-typed multi-field expressions.
\ASLListing{Typing multi-field expressions}{egetfields}{\typingtests/TypingRule.EGetFields.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is a multi-field access expression for the base expression $\ebase$ and list of fields $\vfields$,
        that is, $\EGetFields(\ebase, \vfields)$;
  \item \Proseannotateexpr{$\tenv$}{$\ebase$}{\\ $(\tbaseannot, \vetwo, \vsesbase)$}\ProseOrTypeError;
  \item obtaining the \underlyingtypeterm\ of $\tbaseannot$ in $\tenv$ yields \\
        $\tbaseannotanon$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{bits}
    \begin{itemize}
      \item $\tbaseannotanon$ is a bitvector type with list of bitfields $\vbitfields$\ProseOrTypeError;
      \item applying $\findbitfieldsslices$ to each field name $\name$ and list of bitfields $\vbitfields$ in $\vfields$ yields \\
            $\vslices_\name$\ProseOrTypeError;
      \item define $\veslice$ as the slicing expression for $\ebase$ and lists of slices $\vslices_\name$, for each $\name$ in $\vfields$;
      \item \Proseannotateexpr{$\tenv$}{$\veslice$}{\\ $(\vt, \newe, \vses)$}\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{record}
    \begin{itemize}
      \item $\tbaseannotanon$ is a record or exception type with list of fields $\vbasefields$\ProseOrTypeError;
      \item applying $\getbitfieldwidth$ to $\vf$ in $\vbasefields$ and $\vbasefields$, for each $\vf$ in $\vbasefields$, in $\tenv$ yields $\ewidth_\vf$\ProseOrTypeError;
      \item applying $\widthplus$ to the list of expressions $\ewidth_\vf$,
            for each $\vf$ in $\vbasefields$, yields $\veslicewidth$\ProseOrTypeError;
      \item define $\vt$ as the bitvector type with width $\veslicewidth$ and an empty list of bitfields;
      \item define $\ve$ as the multi-field access for $\ebaseannot$ and list of fields \\
            $\vbasefields$;
      \item define $\vses$ as $\vsesbase$.
    \end{itemize}

    \item \AllApplyCase{collection}
    \begin{itemize}
      \item $\tbaseannotanon$ is a collection type with list of fields $\vbasefields$\ProseOrTypeError;
      \item $\ebaseannot$ denotes a variable expression for $\vbase$, that is, $\EVar(\vbase)$;
      \item applying $\getbitfieldwidth$ to $\vf$ in $\vbasefields$ and $\vbasefields$, for each $\vf$ in $\vbasefields$, in $\tenv$ yields $\ewidth_\vf$\ProseOrTypeError;
      \item applying $\widthplus$ to the list of expressions $\ewidth_\vf$,
            for each $\vf$ in $\vbasefields$, yields $\veslicewidth$\ProseOrTypeError;
      \item define $\vt$ as the bitvector type with width $\veslicewidth$ and an empty list of bitfields;
      \item define $\ve$ as the collection multi-field access for $\vbase$ and list of fields \\
            $\vbasefields$, that is, $\EGetCollectionFields(\vbase, \vbasefields)$;
      \item define $\vses$ as $\vsesbase$.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item $\tbaseannotanon$ is neither a bitvector type nor a record type;
      \item the result is a \typingerrorterm{} indicating an unexpected type.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[bits]{
  \annotateexpr(\tenv, \ebase) \typearrow (\tbaseannot, \ebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \TBits(\Ignore, \vbitfields) \OrTypeError\\\\
  \name\in\vfields: \findbitfieldsslices(\name, \vbitfields) \typearrow \vslices_\name \OrTypeError\\\\
  \veslice \eqdef \ESlice(\ebase, [\name\in\vfields: \vslices_\name])\\
  \annotateexpr(\tenv, \veslice) \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr(\tenv, \overname{\EGetFields(\ebase, \vfields)}{\ve}) \typearrow (\vt, \newe, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[record]{
  \annotateexpr(\tenv, \ebase) \typearrow (\tbaseannot, \ebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \TRecord(\vbasefields) \OrTypeError\\\\
  \vf \in \vbasefields: \getbitfieldwidth(\tenv, \vf, \tfields) \typearrow \ewidth_\vf \OrTypeError\\\\
  \widthplus(\tenv, [\vf \in \vbasefields: \ewidth_\vf]) \typearrow \veslicewidth\OrTypeError
}{
  {
  \begin{array}{r}
    \annotateexpr(\tenv, \overname{\EGetFields(\ebase, \vfields)}{\ve}) \typearrow \\
    (\overname{\TBits(\veslicewidth, \emptylist)}{\vt}, \overname{\EGetFields(\ebaseannot, \vfields)}{\newe}, \overname{\vsesbase}{\vses})
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[collection]{
  \annotateexpr(\tenv, \ebase) \typearrow (\tbaseannot, \ebaseannot, \vsesbase) \OrTypeError\\\\
  \ebaseannot = \EVar(\vbase)\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \TRecord(\vbasefields) \OrTypeError\\\\
  \vf \in \vbasefields: \getbitfieldwidth(\tenv, \vf, \tfields) \typearrow \ewidth_\vf \OrTypeError\\\\
  \widthplus(\tenv, [\vf \in \vbasefields: \ewidth_\vf]) \typearrow \veslicewidth\OrTypeError
}{
  {
  \begin{array}{r}
    \annotateexpr(\tenv, \overname{\EGetFields(\ebase, \vfields)}{\ve}) \typearrow \\
    (\overname{\TBits(\veslicewidth, \emptylist)}{\vt}, \overname{\EGetCollectionFields(\vbase, \vfields)}{\newe}, \overname{\vsesbase}{\vses})
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \annotateexpr(\tenv, \veone) \typearrow (\tbaseannot, \ebaseannot, \Ignore) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \tbaseannotanon \OrTypeError\\\\
  \astlabel(\tbaseannotanon) \not\in \{\TBits, \TRecord\}
}{
  \annotateexpr(\tenv, \overname{\EGetFields(\veone, \vfields)}{\ve}) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\EGetFieldsBegin}{\EGetFieldsEnd}{../Typing.ml}

\TypingRuleDef{FindBitFieldsSlices}
\hypertarget{def-findbitfieldsslices}{}
% Transliteration note: The implementation returns an optional, but all of its uses raise a \typingerrorterm{} if the result is None.
The function
\[
  \findbitfieldsslices(\overname{\Identifier}{\name} \aslsep \overname{\KleeneStar{\bitfield}}{\vbitfields})
  \aslto \overname{\KleeneStar{\slice}}{\vslices} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
returns the slices associated with the bitfield named $\name$ in the list of bitfields $\vbitfields$
in $\vslices$.
\ProseOtherwiseTypeError

\ExampleDef{Finding the Slices of a Bitfield}
In \listingref{eget-bitfield},
given the list of bitfields of the \verb|Packet| type,
the list of slices associated with
\verb|data| is \verb|7:1|.
Attempting to obtain the list of slices associated with
\verb|crc|, given the list of bitfields of the \verb|Packet| type,
yields a \typingerrorterm, since it is a nested bitfield.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{found}
  \begin{itemize}
    \item $\vbitfields$ is a list with \head\ $\vfield$ and \tail\ $\vbitfieldsone$;
    \item applying $\bitfieldgetname$ to $\vfield$ yields $\name$;
    \item applying $\bitfieldgetslices$ to $\vfield$ yields $\vslices$.
  \end{itemize}

  \item \AllApplyCase{tail}
  \begin{itemize}
    \item $\vbitfields$ is a list with \head\ $\vfield$ and \tail\ $\vbitfieldsone$;
    \item applying $\bitfieldgetname$ to $\vfield$ yields $\namep$, which is different to $\name$;
    \item applying $\findbitfieldsslices$ to $\name$ and $vbitfieldsone$ yields $\vslices$\ProseOrTypeError.
  \end{itemize}

  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vbitfields$ is an empty list;
    \item the result is a \typingerrorterm{} indicating that a bitfield named $\name$ does not exist in $\vbitfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[found]{
  \bitfieldgetname(\vfield) \typearrow \name\\
  \bitfieldgetslices(\vfield) \typearrow \vslices
}{
  \findbitfieldsslices(\name, \overname{[\vfield] \concat \vbitfieldsone}{\vbitfields}) \typearrow \vslices
}
\end{mathpar}

\begin{mathpar}
\inferrule[tail]{
  \bitfieldgetname(\vfield) \typearrow \namep\\
  \namep \neq \name\\
  \findbitfieldsslices(\name, \vbitfieldsone) \typearrow \vslices \OrTypeError
}{
  \findbitfieldsslices(\name, \overname{[\vfield] \concat \vbitfieldsone}{\vbitfields}) \typearrow \vslices
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty]{}{
  \findbitfieldsslices(\name, \overname{\emptylist}{\vbitfields}) \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}

\TypingRuleDef{GetBitfieldWidth}
\RenderRelation{get_bitfield_width}
\BackupOriginalRelation{
The function
\[
  \getbitfieldwidth(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Identifier}{\name} \aslsep
    \overname{\KleeneStar{\field}}{\tfields})
  \aslto \overname{\expr}{\ewidth} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
returns the expression $\ewidth$ that describes the width of the bitfield named $\name$
in the list of fields $\tfields$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Obtaining the Width of a Bitfield}
In \listingref{egetfields},
obtaining the width of the field \verb|bits3_2|,
given the list of fields of the type \verb|RecordWithBits|
yields the literal expression for \verb|2|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item applying $\assocopt$ to find the type associated with $\name$ in $\tfields$ yields the type $\vt$;
    \item applying $\getbitvectorwidth$ to $\vt$ in $\tenv$ yields $\ewidth$\ProseOrTypeError.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item applying $\assocopt$ to find the type associated with $\name$ in $\tfields$ yields $\None$;
    \item the result is a \typingerrorterm{} indicating that $\name$ is not associated with any field in $\tfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \assocopt(\name, \tfields) \typearrow \some{\vt}\\
  \getbitvectorwidth(\tenv, \vt) \typearrow \ewidth \OrTypeError
}{
  \getbitfieldwidth(\tenv, \name, \tfields) \typearrow \ewidth
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \assocopt(\name, \tfields) \typearrow \None
}{
  \getbitfieldwidth(\tenv, \name, \tfields) \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}

\TypingRuleDef{WidthPlus}
\hypertarget{def-widthplus}{}
% NOTE: the implementation handles just two expressions, here we fold over a list.
The function
\[
  \widthplus(\overname{\staticenvs}{\tenv} \aslsep \overname{\KleeneStar{\expr}}{\exprs}) \typearrow \overname{\expr}{\ewidth}
  \cup \overname{\typeerror}{\TypeErrorConfig}
\]
generates the expression $\ewidth$, which represents the summation of all expressions in the list $\exprs$,
normalized in the \staticenvironmentterm{} $\tenv$.
\ProseOrTypeError

\ExampleDef{Summing Widths}
Summing the list of expression \verb|2, 3|,
yields the expression \verb|2+3|,
(in AST terms, \\
$\AbbrevEBinop{\ADD}{\ELInt{2}}{\ELInt{2}}$).

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\exprs$ is an empty list;
    \item $\ewidth$ is the literal expression for $0$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\exprs$ is the list with \head\ $\ve$ and \tail\ $\exprsone$;
    \item applying $\widthplus$ to $\exprsone$ yields $\ewidthone$;
    \item applying $\normalize$ to the binary operation for $\ADD$ and $\ve$ and $\ewidthone$ yields $\ewidth$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \widthplus(\tenv, \overname{\emptylist}{\exprs}) \typearrow \overname{\ELInt{0}}{\ewidth}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \widthplus(\exprsone) \typearrow \ewidthone\\
  \normalize(\tenv, \EBinop(\ADD, \ve, \ewidthone)) \typearrow \ewidth \OrTypeError
}{
  \widthplus(\tenv, \overname{[\ve] \concat \exprsone}{\exprs}) \typearrow \ewidth
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{EGetfields}
\ExampleDef{Evaluating Multi-field Expressions}
In \listingref{egetfields},
evaluating the multi-field expression \\
\verb|bits_var.[bits3_2, bit1, bit0, info_and_bits]|
yields the bitvector value \\
\verb|'00101010'|,
and evaluating the multi-field expression \\
\verb|record_var.[bits3_2, bit1, bit0, info]|
yields the bitvector value \verb|'001010'|.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is the multi-field access expression for the expression $\erecord$ and list of field names
        $\vfieldnames$;
  \item evaluating the expression $\erecord$ in $\env$ yields $((\vrecord, \vg), \newenv)$\ProseOrAbnormal;
  \item obtaining the value associated with the field $\fieldname$ in $\vv$, for each $\fieldname$ in $\vfieldnames$,
        yields $\vv_\fieldname$;
  \item define $\vv$ as the concatenation of $\vv_\fieldname$, for each $\fieldname$ in $\vfieldnames$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \erecord) \evalarrow ((\vrecord, \vg), \newenv) \OrAbnormal\\\\
  \fieldname\in\vfieldnames: \getfield(\fieldname, \vv) \evalarrow \vv_\fieldname\\
  \concatbitvectors([\fieldname\in\vfieldnames: \vv_\fieldname]) \typearrow \vv
}{
  \evalexpr(\env, \overname{\EGetFields(\erecord, \vfieldnames)}{\ve}) \evalarrow
  ((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetFieldsBegin}{\EvalEGetFieldsEnd}{../interpreter.ml}

\SemanticsRuleDef{EGetCollectionFields}

\ExampleDef{Typing Collection Fields Expressions}
All of the collection field expressions in
\listingref{typing-lesetcollectionfields} are well-typed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is the collection multi-field access expression for the
    collection global storage element $\vbase$ and list of field names
    $\vfieldnames$;
  \item $\vbase$ is bound in the storage map of $\denv$;
  \item $\vv$ is the value of $\vbase$ in the global component of $\env$;
  \item obtaining the value associated with the field $\fieldname$ in $\vv$,
    for each $\fieldname$ in $\vfieldnames$, yields $\vv_\fieldname$;
  \item define $\vv$ as the concatenation of $\vv_\fieldname$, for each
    $\fieldname$ in $\vfieldnames$.
  \item $\vg$ is the graph containing a Read Effect for each field $\fieldname$
    in $\vfieldnames$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqname (\Ignore, \denv)\\
  \vbase \in \dom(G^\denv.\storage) \\
  \vv \eqdef G^\denv.\storage(\vbase) \\
  \fieldname\in\vfieldnames: \getfield(\fieldname, \vv) \evalarrow \vv_\fieldname \\
  \vg \eqdef \left\{ \fieldname\in\vfieldnames: \ReadEffect(\vbase + \ttdotstr + \fieldname) \right\} \\
  \concatbitvectors([\fieldname\in\vfieldnames: \vv_\fieldname]) \evalarrow \vv \\
}{
  \evalexpr(\env, \overname{\EGetCollectionFields(\vbase, \vfieldnames)}{\ve}) \evalarrow
  ((\vv, \vg), \newenv)
}
\end{mathpar}

\CodeSubsection{\EvalEGetCollectionFieldsBegin}{\EvalEGetCollectionFieldsEnd}{../interpreter.ml}

\hypertarget{def-atceexpressionterm}{}
\section{Asserting Type Conversion Expressions\label{sec:AssertingTypeConversionExpressions}}
\identi{TCST}
The rule about domains in the definitions of subtype-satisfaction and
type-satisfaction means that it is illegal to use the unconstrained integer
where a constrained integer is expected.
An asserting type conversion, ATC for short, can be used to overcome this.

\identi{CGRH}
An ATC allows code to explicitly mark places where uses of constrained types
would otherwise be a static typechecking error. The intent is to reduce the
incidence of unintended errors by making such uses fail typechecking unless
the asserting type conversion is provided.

\identr{WZVX}
Note that ATCs are execution-time checks. An execution-time check is a
condition that is evaluated during the evaluation of an execution-time
initializer expression or subprogram. If the condition evaluates to $\False$ it
is a \DynamicErrorConfigurationTerm{}.

\ASLListing{ATC expressions}{typing-atc}{\typingtests/TypingRule.ATC.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tas \parsesep \Nty &\\
                    |\  & \Nexpr \parsesep \Tas \parsesep \Nconstraintkind &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_atc}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \overtext{\EATC}{Type assertion}(\expr, \overtext{\ty}{asserted type}) &
\end{flalign*}
}

\ASTRuleDef{ATC}
\begin{mathpar}
\inferrule[type]{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildty(\vt) \astarrow \astversion{\vt} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tas, \vt : \Nty)}{\vparsednode}) \astarrow
  \overname{\EATC(\astversion{\ve}, \astversion{\vt})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_constraints]{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildconstraintkind(\vics) \astarrow \astversion{\vics} \OrBuildError
}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tas, \vics : \Nconstraintkind)}{\vparsednode}) \astarrow\\
      \overname{\EATC(\astversion{\ve}, \TInt(\astversion{\vics}))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ATC}
\ExampleDef{Well-typed Asserting Type Conversion Expressions}
\listingref{typing-atc} shows examples of ATC expressions
and the corresponding annotated expressions in comments.

\ExampleDef{Asserting Type Conversion of Well-constrained Integers}
The specification in \listingref{typing-atc2} is well-typed,
showing how to convert one \\
\wellconstrainedintegertypeterm{} into another
\wellconstrainedintegertypeterm{}.
\ASLListing{ATC of well-constrained integers}{typing-atc2}{\typingtests/TypingRule.ATC2.asl}

\ExampleDef{Safely Applying Asserting Type Conversion to Bitvectors}
The specification in \listingref{typing-atc3} is well-typed,
showing how a \bitvectortypeterm{} may be safely converted
into another \bitvectortypeterm.
\ASLListing{Safely applying ATC to bitvector types}{typing-atc3}{\typingtests/TypingRule.ATC3.asl}

Similarly, the specification in \listingref{typing-atc4} is well-typed,
showing that even literals may require an asserting type conversion to ensure they meet
type-satisfaction requirements.
\ASLListing{Safely applying ATC to a bitvector literal}{typing-atc4}{\typingtests/TypingRule.ATC4.asl}

\ExampleDef{Ill-typed Asserting Type Conversion}
The specification in \listingref{typing-atc-bad} is ill-typed,
as it is applied to unrelated kinds of types.
\ASLListing{Ill-typed ATC of a bitvector type}{typing-atc-bad}{\typingtests/TypingRule.ATC.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an asserting type conversion with expression $\vep$ and type $\tty$, that is $\EATC(\vep, \tty)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vt, \vepp, \vsese)$\ProseOrTypeError;
  \item obtaining the \structureterm\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyp, \vsesty)$\ProseOrTypeError;
  \item obtaining the \structureterm\ of $\tty'$ in $\tenv$ yields $\vtystruct$\ProseOrTypeError;
  \item applying $\checkatc$ to $\vtstruct$ and $\vtystruct$ in $\tenv$ to check whether the type assertion
        will always fail yields $\True$\ProseOrTypeError;
  \item define $\vsesp$ as the union of $\vsesty$ and $\vsese$;
  \item checking whether $\vtstruct$ \subtypesatisfiesterm\ $\vtystruct$ in $\tenv$ yields \\
        $\vallwayssucceeds$\ProseOrTypeError\
        (if $\vallwayssucceeds$ holds then the type assertion will always succeed dynamically, and therefore can be omitted);
  \item $\newe$ is $\vepp$ if $\vallwayssucceeds$ is $\True$ and $\EATC(\ttyp, \vepp)$ otherwise;
  \item $\vses$ is $\vsese$ if $\vallwayssucceeds$ is $\True$ and $\vses$ otherwise;
  \item $\vt$ is $\ttyp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \vep) \typearrow (\vt, \vepp, \vsese) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \annotatetype(\tenv, \tty) \typearrow (\ttyp, \vsesty) \OrTypeError\\\\
  \tstruct(\tenv, \ttyp) \typearrow \vtystruct \OrTypeError\\\\
  \checkatc(\tenv, \vtstruct, \vtystruct) \typearrow \True \OrTypeError\\\\
  \vsesp \eqdef \vsesty \cup \vsese \\
  \subtypesat(\tenv, \vtstruct, \vtystruct) \typearrow \vallwayssucceeds \OrTypeError\\\\
  (\newe, \vses) \eqdef \choice{\vallwayssucceeds}{(\vepp, \vsese)}{(\EATC(\vepp, \ttyp), \vsesp)}
}{
  \annotateexpr(\tenv, \overname{\EATC(\vep, \tty)}{\ve}) \typearrow (\overname{\ttyp}{\vt}, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\ATCBegin}{\ATCEnd}{../Typing.ml}
\lrmcomment{
  This is related to \identr{VBLL} \identi{KRLL} \identg{PFRQ} \identi{XVBG},
  \identr{GYJZ} \identi{SZVF} \identr{PZZJ} \identr{YCPX} \identi{ZLBW},
  \identi{TCST} \identi{CGRH} \identi{YJBB}.
}

\TypingRuleDef{CheckATC}
\RenderRelation{check_atc}
\BackupOriginalRelation{
The function
\[
  \checkatc(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo}) \aslto
  \{\True\} \cup \overname{\typeerror}{\TypeErrorConfig}
\]
checks whether the types $\vtone$ and $\vttwo$, which are assumed to not be named types,
are compatible for a type assertion in the \staticenvironmentterm{} $\tenv$, yielding $\True$.
\ProseOtherwiseTypeError
} % END_OF_BACKUP_RELATION

\ExampleDef{Ill-typed ATC Expressions}
\listingref{checkatc} shows examples of ill-typed ATC expressions.
\ASLListing{Ill-typed ATC expressions}{checkatc}{\typingtests/TypingRule.CheckATC.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{equal}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalentterm\ to $\vttwo$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{different\_labels\_error}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalentterm\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are different;
    \item the result is a \typingerrorterm{} indicating that the type assertion will always fail.
  \end{itemize}

  \item \AllApplyCase{int\_bits}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalentterm\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is either $\TInt$ or $\TBits$;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalentterm\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item $\vtone$ is a \tupletypeterm{} with list of tuples $\vlone$, that is, $\TTuple(\vlone)$;
    \item $\vtone$ is a \tupletypeterm{} with list of tuples $\vltwo$, that is, $\TTuple(\vltwo)$;
    \item checking whether $\vlone$ and $\vltwo$ have the same length yields $\True$\ProseTerminateAs{\TypeAssertionFailure};
    \item applying $\checkatc$ to $\vlone[\vi]$ and $\vltwo[\vi]$ in $\tenv$ for every $\vi\in\listrange(\vlone)$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$;
  \end{itemize}

  \item \AllApplyCase{other\_error}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalentterm\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is neither $\TInt$, nor $\TBits$, nor $\TTuple$;
    \item the result is a \typingerrorterm{} indicating that the type assertion will always fail ($\TypeAssertionFailure$).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[equal]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[different\_labels\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) \neq \astlabel(\vttwo)
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\TypeAssertionFailure}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_bits]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \in \{\TInt, \TBits\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \vtone = \TTuple(\vlone)\\
  \vttwo = \TTuple(\vltwo)\\
  \checktrans{|\vlone|=|\vltwo|}{\TypeAssertionFailure} \typearrow \True\OrTypeError\\\\
  \vi\in\listrange(\vlone): \checkatc(\vlone[\vi], \vltwo[\vi]) \typearrow \True\OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[other\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \not\in \{\TInt, \TBits, \TTuple\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\TypeAssertionFailure}
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{ATC}
\ExampleDef{Evaluation of an Asserting Type Conversion Expressions}
In \listingref{semantics-atcvalue}, both type assertions ---
\verb|3 as integer| and \verb|3 as integer{3..5}| --- succeed.
\ASLListing{Evaluating a successful type assertion expression}{semantics-atcvalue}{\semanticstests/SemanticsRule.ATCValue.asl}

\ExampleDef{An Unevaluated Asserting Type Conversion}
\identr{YCPX}
In \listingref{semantics-atcnotevaluated}, the asserting type conversion on \texttt{y}
does not yield a \DynamicErrorConfigurationTerm{}, since the invocation of \texttt{f1} returns $\False$ when
evaluated:
\ASLListing{A asserting type conversion that is never evaluated}{semantics-atcnotevaluated}
{\semanticstests/SemanticsRule.ATCNotDynamicErrorIfFalse.asl}

\ExampleDef{Asserting Type Conversions with Dynamic Errors}
\listingref{semantics-variousatcs} shows various \dynamicerrorsterm{}.
Note that the \dynamicerrorterm{} appearing in the statement
\verb|var e: integer{4, 5, 6} = 2 as integer{4, 5, 6};|, \\
which is nested in the \verb|if FALSE then|
will never occur, but it is still classified as a \dynamicerrorterm{}.
\ASLListing{Various dynamic errors}{semantics-variousatcs}{\semanticstests/SemanticsRule.ATCVariousErrors.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes an asserted type conversion expression, $\EATC(\veone, \vt)$;
\item evaluating $\veone$ in $\env$ results in $\ResultExpr((\vv, \vgone), \newenv)$\ProseOrAbnormal;
\item evaluating whether $\vv$ has type $\vt$ in $\env$ results in $(\vb, \vgtwo)$\ProseOrDynErrorDiverging;
\item \OneApplies
      \begin{itemize}
      \item \AllApplyCase{okay}
            \begin{itemize}
            \item $\vb$ is the native Boolean for \True;
            \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
            \end{itemize}
      \item \AllApplyCase{error}
            \begin{itemize}
            \item $\vb$ is the native Boolean for \False;
            \item the result is a \DynamicErrorConfigurationTerm{} indicating that the type assertion failed
                  (\DynamicTypeAssertionFailure).
            \end{itemize}
      \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \evalexpr(\env, \veone) \evalarrow \ResultExpr((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vgtwo) \OrDynErrorDiverging\\\\
  \vb \eqname \nvbool(\True)\\
  \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalexpr(\env, \EATC(\veone, \vt)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\and
\inferrule[error]{
  \evalexpr(\env, \veone) \evalarrow \ResultExpr((\vv, \Ignore), \Ignore)\\
  \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \Ignore)\\
  \vb \eqname \nvbool(\False)
}{
  \evalexpr(\env, \EATC(\veone, \vt)) \evalarrow \DynamicErrorVal{\DynamicTypeAssertionFailure}
}
\end{mathpar}
\CodeSubsection{\EvalATCBegin}{\EvalATCEnd}{../Interpreter.ml}

\SemanticsRuleDef{IsValOfType}
\ProseParagraph
\RenderRelation{is_val_of_type}
\BackupOriginalRelation{
The relation
\[
  \isvaloftype(\overname{\envs}{\env} \aslsep \overname{\nativevalue}{\vv} \aslsep \overname{\ty}{\vt}) \;\aslrel\;
  \left(
  \begin{array}{ll}
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg}) & \cup \\
  \overname{\TDynError}{\DynErrorConfig} & \cup \\
  \overname{\TDiverging}{\DivergingConfig} & \\
  \end{array}
  \right)
\]
tests whether the value $\vv$ can be stored in a variable of type $\vt$ in the environment $\env$,
resulting in a Boolean value $\vb$ and execution graph $\vg$.
\ProseOtherwiseDynamicErrorOrDiverging
} % END_OF_BACKUP_RELATION

This relation is used in the context of a asserted type conversion,
which means the typechecker rule \TypingRuleRef{ATC} was already applied,
thus filtering cases where the type inferred for the converted expression
does not type-satisfy $\vt$. The semantics takes this into account and
only returns \False\ in cases where dynamic information is required.

Recall that the $\vt$ is the result of $\annotatetype$, which ensures that
all \\
sub-expressions appearing in $\vt$ are side-effect-free.

\ExampleDef{Checking Whether a Value Belongs to a Type}
In \listingref{semantics-variousatcs},
checking whether the value \verb|2| is a member of the type \verb|integer{1,2,3}|
succeeds whereas checking whether the value \verb|2| is a member
of the type \verb|integer{4, 5, 6}| fails.

\OneApplies
\begin{itemize}
  \item \AllApplyCase{type\_equal}
  \begin{itemize}
    \item the AST label of $\vt$ is not $\TInt$, $\TBits$, or $\TTuple$;
    \item $\vb$ is $\True$ (since \TypingRuleRef{ATC}
    succeeds in these cases only if the \structureterm\ of the type of the expression and the \structureterm\ of the type asserted against are \typeequivalentterm);
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item \AllApplyCase{int\_unconstrained}
  \begin{itemize}
    \item $\vt$ has the structure of the unconstrained integer;
    \item $\vb$ is \True;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item \AllApplyCase{int\_wellconstrained}
  \begin{itemize}
    \item $\vt$ has the structure of a well-constrained integer with constraints $\vc_{1..k}$;
    \item $\vv$ is the \nativevalueterm{}  integer for $n$;
    \item the evaluation of every constraint $\vc_i$ with $n$ in environment $\env$
          yields a Boolean value $\vb_i$ and an execution graph $\vg_i$\ProseOrDynErrorDiverging;
    \item $\vb$ is the Boolean disjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
  \end{itemize}

  \item \AllApplyCase{bits}
  \begin{itemize}
    \item $\vt$ is a bitvector type with expression $\ve$, that is, $\TBits(\ve, \Ignore)$;
    \item $\vv$ is a native bitvector value for the sequence of bits $\vbits$, that is, \\ $\nvbitvector(\vbits)$;
    \item evaluating the side-effect-free expression $\ve$ in $\env$ yields $\ResultExpr(\vvp, \vg)$\ProseOrDynErrorDiverging;
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vvp$ is equal to the number of bits in $\vbits$}.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\vt$ is a tuple with types $\vt_i$, for $i=1..k$;
    \item the value at every index $i=1..k$ of $\vv$ is $\vu_i$, for $i=1..k$,
    \item the evaluation of $\isvaloftype$ for every value $\vu_i$
          and corresponding type $\vt_i$, for $i=1..k$,
          results in a Boolean $\vb_i$ and execution graph $\vg_i$\ProseOrDynErrorDiverging;
    \item $\vb$ is the Boolean conjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
    of the constraints.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[type\_equal]{
  \astlabel(\vt) \not\in \{\TInt, \TBits\}
}{
  \isvaloftype(\env, \vv, \vt) \evalarrow (\overname{\True}{\vb}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_unconstrained]{}{
  \isvaloftype(\env, \vv, \overname{\TInt(\Unconstrained)}{\vt}) \evalarrow (\overname{\True}{\vb}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_wellconstrained]{
  \vv \eqname \nvint(n)\\
  i=1..k: \isconstaintsat(\env, \vc_i, n) \evalarrow (\vb_i, \vg_i) \OrDynErrorDiverging\\\\
  \vb \eqdef \bigvee_{i=1}^k \vb_i\\
  \vg \eqdef \parallel_{i=1}^k \vg_i
}{
  \isvaloftype(\env, \vv, \overname{\TInt(\WellConstrained(\vc_{1..k}))}{\vt}) \evalarrow (\vb, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits]{
  \evalexprsef(\env, \ve) \evalarrow \ResultExprSEF(\vvp, \vg) \OrDynErrorDiverging
}{
  \isvaloftype(\env, \overname{\nvbitvector(\vbits)}{\vv}, \overname{\TBits(\ve, \Ignore)}{\vt}) \evalarrow
  (\overname{\vvp = |\vbits|}{\vb}, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  i=1..k: \getindex(i, \vv) \evalarrow \vu_i\\
  i=1..k: \isvaloftype(\env, \vu_i, \vt_i) \evalarrow (\vb_i, \vg_i) \OrDynErrorDiverging\\\\
  \vb \eqdef \bigwedge_{i=1}^k \vb_i \\
  \vg \eqdef\ \parallelcomp_{i=1}^k \vg_i
}{
  \isvaloftype(\env, \vv, \overname{\TTuple(i=1..k: \vt_i)}{\vt}) \evalarrow (\vb, \vg)
}
\end{mathpar}
\CodeSubsection{\EvalValOfTypeBegin}{\EvalValOfTypeEnd}{../Interpreter.ml}

\subsubsection{Comments}
Notice that these rules cover all types, including named types ($\TNamed$),
since the \typedast\ returned from \TypingRuleRef{ATC} is the \structureterm\ of the type
given in the specification.
%
Parameterized integers (integers with an empty set of constraints)
cannot appear as a type, since ASL syntax does not allow the following:
\begin{itemize}
\item Declaring an parameterized integer as a variable,
\item Declaring an alias to an parameterized integer type, and
\item Declaring an parameterized integer in a compound type.
\end{itemize}

\SemanticsRuleDef{IsConstraintSat}
\RenderRelation{is_constraint_sat}
\BackupOriginalRelation{
The relation
\[
  \isconstaintsat(\overname{\envs}{\env} \aslsep \overname{\intconstraint}{\vc} \aslsep \overname{\Z}{n}) \;\aslrel\;
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg})
\]
tests whether the integer value $n$ \emph{satisfies the constraint} $\vc$
(that is, whether $n$ is within the range of values defined by $\vc$) in the environment $\env$
and returns a Boolean answer $\vb$ and the execution graph $\vg$ resulting from evaluating
the expressions appearing in $\vc$.
} % END_OF_BACKUP_RELATION

See \ExampleRef{Checking Whether a Value Belongs to a Type}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{Constraint\_Exact\_Sat}
  \begin{itemize}
    \item $\vc$ is a constraint for the expression $\ve$;
    \item evaluating the side-effect-free expression $\ve$ in $\env$ yields the \concurrentnativevalue\ given
          by the native integer value for $m$ and the \executiongraphterm\ $\vg$\ProseOrDynErrorDiverging.
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $m$ is equal to $n$}.
  \end{itemize}

  \item \AllApplyCase{Constraint\_Range\_Sat}
  \begin{itemize}
    \item $\vc$ is a constraint for the expressions $\veone$ and $\vetwo$;
    \item evaluating the side-effect-free expression $\veone$ in $\env$ yields the \concurrentnativevalue\ given
          by the native integer value for $a$ and the \executiongraphterm\ $\vgone$\ProseOrDynErrorDiverging.
    \item evaluating the side-effect-free expression $\vetwo$ in $\env$ yields the \concurrentnativevalue\ given
          by the native integer value for $b$ and the \executiongraphterm\ $\vgtwo$\ProseOrDynErrorDiverging.
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $n$ is greater or equal to $a$ and less than or equal to $b$};
    \item \Proseeqdef{$\vg$}{the parallel composition of $\vgone$ and $\vgtwo$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
The use of $\evalexprsef$ is justified by checks in $\annotatetype$, verifying
that expressions appearing in types are all side-effect-free.

\begin{mathpar}
\inferrule[Constraint\_Exact\_Sat]{
  \evalexprsef(\env, \ve) \evalarrow \ResultExprSEF(\nvint(m), \vg) \OrDynErrorDiverging
}{
  \isconstaintsat(\env, \overname{\ConstraintExact(\ve)}{\vc}, n) \evalarrow (\overname{m = n}{\vb}, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[Constraint\_Range\_Sat]{
  \evalexprsef(\env, \veone) \evalarrow \ResultExprSEF(\nvint(a), \vgone) \OrDynErrorDiverging\\\\
  \evalexprsef(\env, \vetwo) \evalarrow \ResultExprSEF(\nvint(b), \vgtwo) \OrDynErrorDiverging\\\\
  \vb \eqdef \choice{a \leq n \land n \leq b}{\True}{\False}\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \isconstaintsat(\env, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}, n) \evalarrow (\vb, \vg)
}
\end{mathpar}

\hypertarget{def-patternexpressionterm}{}
\section{Pattern Matching Expressions\label{sec:PatternMatchingExpressions}}
The binary operator $\Tin$ tests whether a value (referred to as the discriminant) matches any item from a $\Npatternset$.
Patterns can also be used to test whether an expression matches a bitmask.
Lists of patterns are also used in case statements.
%
\chapref{PatternMatching} goes into the details of the various types of patterns that can be matched against.

\SyntacticSugarDef{MaskEquality}
The syntax \texttt{x == $m$} is \syntacticsugar{} for \texttt{x IN \{$m$\}},
and it is \desugared{} by \ASTRuleCaseRef{EPattern}{eq}.
The syntax \texttt{x != $m$} is \syntacticsugar{} for \texttt{!x IN \{$m$\}},
and it is \desugared{} by \ASTRuleCaseRef{EPattern}{neq}.

\ASLListing{Pattern expressions}{semantics-epattern}{\semanticstests/SemanticsRule.EPattern.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tin \parsesep \Npatternset &\\
              |\  & \Nexpr \parsesep \Teqop \parsesep \Tmasklit &\\
              |\  & \Nexpr \parsesep \Tneq \parsesep \Tmasklit &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_pattern}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EPattern(\expr, \pattern) &
\end{flalign*}
}

\ASTRuleDef{EPattern}
\begin{mathpar}
\inferrule{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildpatternset(\vps) \astarrow \astversion{\vps} \OrBuildError
}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tin, \vps : \Npatternset)}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astversion{\ve}, \astversion{\vps})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq]{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Nexpr}, \Teqop, \Tmasklit(\vm))}{\vparsednode}) \astarrow
  \overname{\EPattern(\astof{\vexpr}, \PatternMask(\vm))}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neq]{}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\punnode{\Nexpr}, \Tneq, \Tmasklit(\vm))}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astof{\vexpr}, \PatternNot(\PatternMask(\vm)))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EPattern}
\listingref{semantics-epattern} shows examples of pattern expressions.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a pattern expression to test whether $\veone$ matches the pattern $\vpat$, that is, \\ $\EPattern(\veone, \vpat)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vtetwo, \vetwo, \vsese)$\ProseOrTypeError;
  \item applying $\annotatepattern$ to $\vtetwo$ and $\vpat$ in $\tenv$ yields $(\vpatp, \vsespat)$\ProseOrTypeError;
  \item define $\vt$ as $\TBool$;
  \item define $\newe$ as the pattern expression for $\vetwo$ and the pattern $\vpatp$, that is, \\
        $\EPattern(\vetwo, \vpatp)$;
  \item define $\vses$ as the union of $\vsese$ and $\vsespat$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \veone) \typearrow (\vtetwo, \vetwo, \vsese) \OrTypeError\\\\
  \annotatepattern(\tenv, \vtetwo, \vpat) \typearrow (\vpatp, \vsespat) \OrTypeError\\\\
  \vses \eqdef \vsese \cup \vsespat
}{
  \annotateexpr(\tenv, \overname{\EPattern(\veone, \vpat)}{\ve}) \typearrow (\overname{\TBool}{\vt}, \overname{\EPattern(\vetwo, \vpatp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\EPatternBegin}{\EPatternEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EPattern}
\ExampleDef{Evaluation of Pattern Expressions}
In \listingref{semantics-epattern},
the expression \texttt{42 IN \{0..3, 42\}} evaluates to $\nvbool(\True)$
whereas the expression \texttt{42 IN \{0..3, -4\}} evaluates to $\nvbool(\False)$.
%
In addition, all assertions, which demonstrate pattern expression involving bitmasks,
succeed.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a pattern expression, $\EPattern(\ve, \vp)$;
  \item evaluating the expression $\ve$ in an environment $\env$ results in \\
  $\ResultExpr((\vvone, \vgone), \newenv)$\ProseOrAbnormal;
  \item evaluating whether the pattern $\vp$ matches the value $\vvone$ in $\env$
        results in \\
        $\ResultPattern(\vv, \vgtwo)$\ProseOrAbnormal,
        where $vv$ is a native Boolean that determines whether there is indeed a match;
  \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vvone, \vgone), \newenv) \OrAbnormal\\\\
  \evalpattern(\env, \vvone, \vp) \evalarrow \ResultPattern(\vv, \vgtwo) \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalexpr(\env, \EPattern(\ve, \vp)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEPatternBegin}{\EvalEPatternEnd}{../Interpreter.ml}

\hypertarget{def-arbitraryexpressionterm}{}
\section{Arbitrary Value Expressions\label{sec:ArbitraryValueExpressions}}
An expression of the form \texttt{ARBITRARY: ty} evaluates to an arbitrary value in the
domain of \texttt{ty}.
Each evaluation can produce a different arbitrary value, but (as always) once a particular expression is evaluated, its arbitrary value cannot change.
This is because evaluation produces native values, and \ARBITRARY{} is not a valid native value---so once evaluated, it becomes an unchanging native value like any other.

Note that there are two important consequences of producing an arbitrary value when evaluating expressions of the form \texttt{ARBITRARY: ty}:
\begin{enumerate}
  \item The arbitrary value depends only on \texttt{ty}, and no other ASL storage elements.
  \item The only guarantee of the resulting value is that it is a valid member of \texttt{ty}.
    In particular, the language does not define which valid member it is, and ASL specifications must not rely on the value (for example, there is no way to test whether a value was produced by evaluating \ARBITRARY{}).
\end{enumerate}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tarbitrary \parsesep \Tcolon \parsesep \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_arbitrary}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EArbitrary(\ty) &
\end{flalign*}
}

\ASTRuleDef{EArbitrary}
\begin{mathpar}
\inferrule{
  \buildty(\vt) \astarrow \astversion{\vt} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\Tarbitrary, \Tcolon, \vt : \Nty)}{\vparsednode}) \astarrow
  \overname{\EArbitrary(\astversion{\vt})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EArbitrary}
\ExampleDef{Well-typed Arbitrary Value Expressions}
\listingref{typing-arbitrary} show examples of well-typed arbitrary value expressions.
\ASLListing{Well-typed arbitrary value expressions}{typing-arbitrary}{\typingtests/TypingRule.EArbitrary.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an expression \ARBITRARY\ of type $\tty$, that is, $\EArbitrary(\tty)$;
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyone, \vsesty)$\ProseOrTypeError;
  \item obtaining the \structureterm\ of $\ttyone$ in $\tenv$ yields $\ttytwo$\ProseOrTypeError;
  \item $\vt$ is $\ttyone$;
  \item define $\newe$ as an expression \ARBITRARY\ of type $\ttytwo$, that is, $\EArbitrary(\ttytwo)$;
  \item define $\vses$ as the union of $\vsesty$ and the set containing an \ImmutabilityTerm{} with immutability $\False$, and a \LocalEffectTerm{} and a \GlobalEffectTerm{}, both with \purity{} $\SEReadonly$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatetype(\tenv, \tty) \typearrow (\ttyone, \vsesty) \OrTypeError\\\\
  \tstruct(\tenv, \ttyone) \typearrow \ttytwo \OrTypeError\\\\
  \vses \eqdef \vsesty \cup \{ \LocalEffect(\SEReadonly), \GlobalEffect(\SEReadonly), \Immutability(\False) \}
}{
  \annotateexpr(\tenv, \EArbitrary(\tty)) \typearrow (\ttyone, \EArbitrary(\ttytwo), \vses)
}
\end{mathpar}
\CodeSubsection{\EArbitraryBegin}{\EArbitraryEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EArbitrary}
\ExampleDef{Evaluation of ARBITRARY for an Unconstrained Integer Type}
In \listingref{semantics-earbitraryunconstrained},
the expression \verb|ARBITRARY : integer| evaluates to an arbitrary integer value.
\ASLListing{Evaluating an \texttt{ARBITRARY} expression for an unconstrained integer}{semantics-earbitraryunconstrained}
{\semanticstests/SemanticsRule.EArbitraryInteger3.asl}

\subsubsection{Evaluation of ARBITRARY for a Constrained Integer Type}
In \listingref{semantics-earbitraryconstrained},
the expression \verb|ARBITRARY : integer {3, 42}| evaluates to either \\
$\nvint(3)$ or $\nvint(42)$.
\ASLListing{Evaluating an \texttt{ARBITRARY} expression for a constrained integer}{semantics-earbitraryconstrained}
{\semanticstests/SemanticsRule.EArbitraryIntegerRange3-42-3.asl}

\subsubsection{Evaluation of ARBITRARY for an Integer-indexed Array}
\listingref{semantics-earbitraryarray}
demonstrates how to obtain an arbitrary integer-indexed array, \texttt{int\_array},
and how to obtain an arbitrary enumeration-indexed array, \texttt{enum\_array}.
\ASLListing{Evaluating an \texttt{ARBITRARY} expression for array types}{semantics-earbitraryarray}
{\semanticstests/SemanticsRule.EArbitraryArray.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the \texttt{ARBITRARY} expression annotated with type $\vt$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{okay}
    \begin{itemize}
      \item the domain of $\vt$ in $\env$ (see \secref{DynDomain}) is not empty;
      \item $\vv$ is an arbitrary value in the domain of $\vt$ in $\env$;
      \item $\newenv$ is $\env$.
      \item $\vg$ is the empty execution graph.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item the domain of $\vt$ in $\env$ is empty;
      \item the result is a \DynamicErrorConfigurationTerm{} (\ArbitraryEmptyType) indicating that the type $\vt$ has an empty
            domain in $\env$ and therefore no value can be returned.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \dynamicdomain(\env, \vt) \neq \emptyset\\
  \vv \in \dynamicdomain(\env, \vt)
}{
  \evalexpr(\env, \overname{\EArbitrary (\vt)}{\ve}) \evalarrow \ResultExpr((\vv, \overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
  \inferrule[error]{
  \dynamicdomain(\env, \vt) = \emptyset
}{
  \evalexpr(\env, \overname{\EArbitrary (\vt)}{\ve}) \evalarrow \DynamicErrorVal{\ArbitraryEmptyType}
}
\end{mathpar}
\CodeSubsection{\EvalEArbitraryBegin}{\EvalEArbitraryEnd}{../Interpreter.ml}

\subsubsection{Comments}
Notice that this rule introduces non-determinism.
\identr{WLCH}

\section{Structured Type Construction Expressions\label{sec:StructuredTypeConstructionExpressions}}
\hypertarget{def-recordexpressionterm}{}
\ASLListing{Record construction expression}{semantics-erecord}{\semanticstests/SemanticsRule.ERecord.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tidentifier \parsesep \Tlbrace \parsesep \Tminus \parsesep \Trbrace &\\
	       |\ & \Tidentifier \parsesep \Tlbrace \parsesep \ClistOne{\Nfieldassign} \parsesep \Trbrace &\\
\Nfieldassign \derives \ & \Tidentifier \parsesep \Teq \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_record}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \ERecord(\overtext{\ty}{record type}, \overtext{(\Identifier, \expr)^{*}}{field initializers}) &
\end{flalign*}
}

\ASTRuleDef{ERecord}
\begin{mathpar}
  \inferrule[empty]{}{
    {
      \begin{array}{r}
    \buildexpr(\overname{\Nexpr(
    \begin{array}{l}
    \Tidentifier(\vt), \Tlbrace, \Tminus, \Trbrace
    \end{array}
    )}{\vparsednode}) \\
    \astarrow\ \overname{\ERecord(\TNamed(\vt), \emptylist)}{\vastnode}
\end{array}
}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_empty]{
    \buildclist[\buildfieldassign](\vfieldassigns) \astarrow \vfieldassignasts
  }{
    {
      \begin{array}{r}
  \buildexpr\left(\overname{\Nexpr\left(
    \begin{array}{l}
    \Tidentifier(\vt), \Tlbrace, \\
    \wrappedline\ \namednode{\vfieldassigns}{\ClistOne{\Nfieldassign}}, \\
    \wrappedline\ \Trbrace
    \end{array}
    \right)}{\vparsednode}\right) \\
    \astarrow\ \overname{\ERecord(\TNamed(\vt), \vfieldassignasts)}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{FieldAssign}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-fieldassign}{}
The function
\[
  \buildfieldassign(\overname{\parsenode{\Nfieldassign}}{\vparsednode}) \;\aslto\; \overname{(\Identifier\times\expr)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule{}{
  \buildfieldassign(\Nfieldassign(\Tidentifier(\id), \Teq, \punnode{\Nexpr})) \astarrow
  \overname{(\id, \astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ERecord}
\listingref{semantics-erecord} shows an example of a well-typed record construction expression
and an example (in comment) where the same field is initialized twice, which is invalid.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the record construction expression (which is also used for creating exceptions) of type $\tty$ with fields $\fields$,
        that is, $\ERecord(\tty, \vfields)$;
  \item obtaining the \underlyingtypeterm\ of $\tty$ in $\tenv$ yields $\ttyanon$\ProseOrTypeError;
  \item checking that $\ttyanon$ is a \structuredtypeterm\ yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item $\ttyanon$ is a \structuredtypeterm\ with a list of $\vfield$ elements (consisting of a field name and a field type);
  \item obtaining the list of field names from $\vfields$ yields the list of identifiers \\
        $\initializedfields$;
  \item obtaining the list of field names from $\fieldtypes$ yields the list of identifiers $\names$;
  \item checking whether the set of identifiers in $\names$ is equal to the set of identifiers in $\initializedfields$
        yields $\True$\ProseOrTypeError;
  \item checking that the list $\initializedfields$ does not contain duplicates yields \\
        $\True$\ProseOrTypeError;
  \item applying $\annotatefieldinit$ to annotate each $\vfield$ element $(\name,\vep)$ of \\
        $\vfields$ in $\tenv$ yields $(\name,\ve_\name,\vxs_\name)$\ProseOrTypeError;
  \item define $\fieldsp$ as the list containing $(\name,\ve_\name)$ for each $\vfield$ element $(\name,\vep)$ of $\vfields$;
  \item $\vt$ is $\tty$;
  \item define $\newe$ as the record expression with type $\tty$ and field initializers $\fieldsp$, that is, $\ERecord(\tty, \fieldsp)$;
  \item define $\vsess$ as the union of the \sideeffectdescriptorsetsterm\ given by $\vxs_\name$ for each $\vfield$ element $(\name,\Ignore)$ of $\vfields$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed}{NamedTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \tty) \typearrow \ttyanon \OrTypeError\\\\
  \checktrans{\astlabel(\ttyanon) \in \{\TRecord, \TException\}}{\UnexpectedType} \typearrow \True\OrTypeError\\\\
  \ttyanon \eqname L(\fieldtypes)\\
  \initializedfields \eqdef \{\name \;|\; (\name, \Ignore)\in\vfields\}\\
  \names \eqdef \fieldnames(\fieldtypes)\\
  \checktrans{\{\names\} = \{\initializedfields\}}{\BadField} \typearrow \True \OrTypeError\\\\
  \checknoduplicates(\initializedfields) \typearrow \True \OrTypeError\\\\
  {
    \begin{array}{r}
  (\name, \vep) \in \vfields: \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow \\
  (\name, \ve_\name, \vxs_\name) \OrTypeError
    \end{array}
  }\\
  \fieldsp \eqdef [(\name, \vep) \in \fields : (\name, \ve_\name)]\\
  \vses \eqdef \bigcup_{(\name, \Ignore) \in \fields} \vxs_\name\\
}{
  \annotateexpr(\tenv, \overname{\ERecord(\tty, \vfields)}{\ve}) \typearrow
  (\overname{\tty}{\vt}, \overname{\ERecord(\tty, \fieldsp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ERecordBegin}{\ERecordEnd}{../Typing.ml}
\identr{WBCQ}

\hypertarget{def-annotatefieldinit}{}
\TypingRuleDef{AnnotateFieldInit}
The function
\[
\begin{array}{r}
  \annotatefieldinit(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\Identifier\times\expr)}{(\name, \vep)} \aslsep
    \overname{\KleeneStar{\vfield}}{\fieldtypes}
  ) \aslto \\
  (\overname{\Identifier}{\name} \times \overname{\expr}{\vepp} \times \overname{\TSideEffectSet}{\vses})
\end{array}
\]
annotates a field initializers $(\name, \vep)$ in a record expression
with list of fields \\ $\fieldtypes$ and returns the annotated initializing expression $\vepp$
and its \sideeffectdescriptorterm\ $\vses$.
\ProseOtherwiseTypeError

See \listingref{semantics-erecord} for an example.

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vtp, \vepp, \vses)$\ProseOrTypeError;
  \item checking whether there exists a type associated with $\name$ in $\fieldtypes$ yields $\True$\ProseOrTypeError;
  \item the unique type associated with $\name$ in $\fieldtypes$ is $\tspecp$;
  \item determining whether $\vtp$ \typesatisfiesterm\ $\tspecp$ in $\tenv$ yields $\True$\ProseOrTypeError;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr(\tenv, \vep) \typearrow (\vtp, \vepp, \vses) \OrTypeError\\\\
  \checktrans{\fieldtype(\fieldtypes, \name) \neq \bot}{\BadField} \typearrow \True \OrTypeError\\\\
  \fieldtype(\fieldtypes, \name) = \tspecp\\
  \checktypesat(\tenv, \vtp, \tspecp) \typearrow \True \OrTypeError
}{
  \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow (\name, \vepp, \vses)
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{ERecord}
\ExampleDef{Evaluation of Record Construction Expressions}
In \listingref{semantics-erecord},
the expression \verb|MyRecordType{a=3, b=42}| evaluates to the native record value \\
$\NVRecord(\va\mapsto\nvint(3), \vb\mapsto\nvint(42))$.

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a record creation expression, $\ERecord(\names, \efields)$;
\item the names of the fields are $\id_{1..k}$;
\item the expressions associated with the fields are $\ve_{1..k}$;
\item evaluating the expressions of $\fields$ in order yields \\
      $\ResultExprList((\vvfields,\vg), \newenv)$\ProseOrAbnormal;
\item $\vvfields$ is a list of \nativevaluesterm{} $\vv_{1..k}$;
\item $\vv$ is the native record that maps $\id_i$ to $\vv_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \efields \eqname [i=1..k: (\id_i, \ve_i)]\\
  \names \eqdef \id_{1..k} \\
  \fields \eqdef \ve_{1..k} \\
  \evalexprlist(\env, \fields) \evalarrow \ResultExprList((\vvfields,\vg), \newenv)  \OrAbnormal\\
  \vvfields \eqname \vv_{1..k}\\
  \vv \eqdef \NVRecord(\{i=1..k: \id_i\mapsto \vv_i\})
}{
  \evalexpr(\env, \ERecord(\Ignore, \efields)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalERecordBegin}{\EvalERecordEnd}{../Interpreter.ml}

\section{Tuple Expressions\label{sec:TupleExpressions}}
\hypertarget{def-tupleexpressionterm}{}

\ASLListing{Tuple expressions}{TupleExpressions}{\definitiontests/TupleExpressions.asl}

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Plisttwo{\Nexpr} &
\end{flalign*}

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_tuple}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \ETuple(\expr^{+}) &
\end{flalign*}
}

\ASTRuleDef{ETuple}
\begin{mathpar}
\inferrule{
  \buildplist[\buildexpr](\vexprs) \astarrow \vexprasts
}{
  \buildexpr(\overname{\Nexpr(\namednode{\vexprs}{\Plisttwo{\Nexpr}})}{\vparsednode}) \astarrow
  \overname{\ETuple(\vexprasts)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ETuple}
\listingref{semantics-etuple} shows an example of a well-typed tuple expressions.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{parenthesized}
  \begin{itemize}
    \item $\ve$ denotes a tuple expression with list of expressions consisting solely of $\vep$, that is, $\ETuple([\vep])$,
          meaning it represents a parenthesized expression (see \ASTRuleRef{ParenExpr});
    \item annotating $\vep$ in $\tenv$ yields $(\vt, \newe, \vses)$\ProseOrTypeError.
  \end{itemize}

  \item \AllApplyCase{list}
  \begin{itemize}
    \item $\ve$ denotes a tuple expression with list of expressions $\vli$, that is, $ \ETuple(\vli)$;
    \item $\vli$ consists of at least two expressions;
    \item annotating each expression $\vle[i]$ in $\tenv$, for $i=1..k$, yields $(\vt_i, \ve_i, \vxs_i$)\ProseOrTypeError;
    \item $\vt$ is the \tupletypeterm{} with list of types $\vt_i$, for $i=1..k$;
    \item $\newe$ is tuple expression over list of expressions $\ve_i$, for $i=1..k$;
    \item defining $\vses$ as the union of $\vxs_i$ for $i=1..k$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[parenthesized]{
  \annotateexpr(\tenv, \vep) \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr(\tenv, \overname{\ETuple(\vep)}{\ve}) \typearrow (\vt, \newe, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[list]{
  |\vli| > 1\\
  i=1..k: \annotateexpr(\tenv, \vle[i]) \typearrow (\vt_i, \ve_i, \vxs_i) \OrTypeError\\\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotateexpr(\tenv, \overname{\ETuple(\vli)}{\ve}) \typearrow (\overname{\TTuple(\vt_{1..k})}{\vt}, \overname{\ETuple(\ve_{1..k})}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ETupleBegin}{\ETupleEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{ETuple}
\ExampleDef{Evaluation of Tuple Expressions}
In \listingref{semantics-etuple},
the expression \texttt{(3, Return42())} evaluates to the value \texttt{(3, 42)}.

\ASLListing{Evaluation of tuple expressions}{semantics-etuple}{\semanticstests/SemanticsRule.ETuple.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a tuple expression, $\ETuple(\elist)$;
  \item the evaluation of $\elist$ in $\env$ is $\ResultExprList((\vlist, \vg), \newenv)$\ProseOrAbnormal;
  \item $\vv$ is the native vector constructed from the values in $\vlist$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexprlist(\env, \elist) \evalarrow \ResultExprList((\vlist, \vg), \newenv) \OrAbnormal\\
  \vv \eqdef \NVVector(\vlist)
}{
  \evalexpr(\env, \ETuple(\elist)) \evalarrow \ResultExpr((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalETupleBegin}{\EvalETupleEnd}{../Interpreter.ml}

\section{Parenthesized Expressions\label{sec:ParenthesizedExpressions}}
A single expression inside parentheses is not considered to be a tuple, but rather the element
inside the parenthesis.
Parenthesizing an expression can be used to improve readability, enforce an order of evaluation,
and avoid binary operator precedence errors (see \ASTRuleRef{CheckNotSamePrec}).

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tlpar \parsesep \Nexpr \parsesep \Trpar &
\end{flalign*}

\subsection{Abstract Syntax}
We represent a parenthesized expression as a single element tuple for the technical
reason of enabling \ASTRuleRef{CheckNotSamePrec} by distinguishing parenthesized
expressions from non-parenthesized expressions. However, upon typing such expressions,
we ignore the parenthesis (see \TypingRuleRef{ETuple}.\textsc{PARENTHESIZED}).

\ASTRuleDef{ParenExpr}
\begin{mathpar}
  \inferrule[sub\_expr]{}{
  \buildexpr(\overname{\Nexpr(\Tlpar, \punnode{\Nexpr}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\ETuple([\ \astof{\vexpr}\ ])}{\vastnode}
}
\end{mathpar}

\section{Array Construction Expressions\label{sec:ArrayConstructionExpressions}}
Array construction expression are used by the type system to express the initialization
of array-typed variables. Since there is no syntax to initialize arrays, there are also
no rules for building the AST for such expressions nor rules for typechecking them.

\subsection{Abstract Syntax}
\RenderTypes[remove_hypertargets]{expr_array}
\BackupOriginalAST{
\begin{flalign*}
\expr \derives\ & \EArray\{\EArrayLength: \expr, \EArrayValue: \expr\} &\\
             |\ & \EEnumArray \{\EArrayLabels: \Identifier^+, \EArrayValue: \expr\}
\end{flalign*}
}

\subsection{Semantics}

The Semantic Rules use $\evalexprsef\empty$ because the typechecker in
$\annotatetype$ guarantees that expressions in types are side-effect-free.

\SemanticsRuleDef{EArray}
In \listingref{typing-tarray},
the variable \verb|int_arr| is initialized with an array construction expression
(which is not expressible in ASL text, only in \typedast, but conceptually could be
represented as \verb|array[[4]] of 0|),
which evaluates to
\[
\NVVector([\nvint(0), \nvint(0), \nvint(0), \nvint(0)]) \enspace.
\]

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is an array construction expression with length expression $\elength$ and value expression $\evalue$,
        that is, $\EArray\{\EArrayLength: \elength, \EArrayValue: \evalue\}$;
  \item evaluating the expression $\evalue$ in $\env$ yields $\ResultExpr((\vvalue, \vgone), \newenv)$\ProseOrAbnormal;
  \item evaluating the side-effect-free expression $\elength$ in $\env$ yields \\
        $\ResultExprSEF((\vlength, \vgtwo))$\ProseOrDynErrorDiverging;
  \item $\vlength$ is a native integer value for $\nlength$;
  \item checking that $\nlength$ is non-negative yields $\True$\ProseTerminateAs{\NegativeArrayLength};
  \item define $\vv$ as the native vector of length $\nlength$ where each position has the value $\vvalue$;
  \item define $\vg$ as the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \evalue) \evalarrow \ResultExpr((\vvalue, \vgone), \newenv) \OrAbnormal\\\\
  \evalexprsef(\env, \elength) \evalarrow \ResultExprSEF((\vlength, \vgtwo)) \OrDynErrorDiverging\\\\
  \vlength \eqname \nvint(\nlength)\\
  \checktrans{\nlength \geq 0}{\NegativeArrayLength} \checktransarrow \True \OrDynError\\\\
  \vv \eqdef \NVVector(i=1..\nlength: \vvalue)\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  {
  \begin{array}{r}
  \evalexpr(\env, \overname{\EArray\{\EArrayLength: \elength, \EArrayValue: \evalue\}}{\ve}) \evalarrow \\
  \ResultExpr((\vv, \vg), \newenv)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EvalEArrayBegin}{\EvalEArrayEnd}{../Typing.ml}

\SemanticsRuleDef{EEnumArray}
In \listingref{typing-tarray},
the variable \verb|big_little_arr| is initialized with an array construction expression
(which is not expressible in ASL text, only in \typedast, but conceptually could be
represented as \verb|array[[Labels]] of '0000'|),
which evaluates to
\[
\NVRecord(\{\vBIG\mapsto\nvbitvector(0000), \vLITTLE\mapsto\nvbitvector(0000)\}) \enspace.
\]

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is an array construction expression for an enumerated-index array with
        list of labels $\vlabels$ and value expression $\evalue$,
        that is, \\
        $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \evalue\}$;
  \item evaluating the expression $\evalue$ in $\env$ yields $\ResultExpr((\vvalue, \vg), \newenv)$\ProseOrAbnormal;
  \item \Proseeqdef{$\vv$}{the native record mapping each label $\vl\in\vlabels$ to $\vvalue$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \evalue) \evalarrow \ResultExpr((\vvalue, \vg), \newenv) \OrAbnormal\\\\
  \vv \eqdef \NVRecord(\vl\in\vlabels: [\vl\mapsto \vvalue])
}{
  {
  \begin{array}{r}
    \evalexpr(\env, \overname{\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \evalue\}}{\ve}) \evalarrow\\
    \ResultExpr((\vv, \vg), \newenv)
  \end{array}
  }
}
\end{mathpar}

\CodeSubsection{\EvalEEnumArrayBegin}{\EvalEEnumArrayEnd}{../Typing.ml}

\section{Side-effect-free Expressions\label{sec:SideEffectFreeExpressions}}
\subsection{Typing}
An expression $\ve$ is considered to be side-effect-free in the \staticenvironmentterm{} $\tenv$
if $\annotateexpr(\tenv, \ve) \typearrow (\Ignore, \Ignore, \vses)$
and $\vses$ is \readonlyterm{}.

\subsection{Semantics}
\SemanticsRuleDef{ESideEffectFreeExpr}
\RenderRelation{eval_expr_sef}
\BackupOriginalRelation{
The relation
\[
  \evalexprsef(\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}) \;\aslrel\;
  \left(
  \begin{array}{ll}
  \ResultExprSEF(\overname{\nativevalue}{\vv}\aslsep\overname{\XGraphs}{\vg}) & \cup \\
  \overname{\TDynError}{\DynErrorConfig} & \cup \\
  \overname{\TDiverging}{\DivergingConfig} & \\
  \end{array}
  \right)
\]
specializes the expression evaluation relation for side-effect-free expressions
by omitting throwing configurations as possible output configurations.
} % END_OF_BACKUP_RELATION

\ExampleDef{Evaluating a Side-effect-free Expression}
Evaluating the literal expression $\LInt(1)$ in any environment $\env$,
yields \\
$\ResultExprSEF(\nvint(1), \emptygraph)$.

\ProseParagraph
Evaluating $\ve$ in $\env$ yields the configuration $\ResultExpr((\vv,\vg), \env)$\ProseOrDynErrorDiverging,
which is then converted to the configuration $\ResultExprSEF(\vv, \vg)$.

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vv,\vg), \env) \OrDynErrorDiverging
}{
  \evalexprsef(\env, \ve) \evalarrow \ResultExprSEF(\vv, \vg)
}
\end{mathpar}
Notice that the output configuration does not contain an environment,
since side-effect-free expressions do not modify the environment.

\section{Evaluating a List of Expressions\label{sec:ExprList}}
\SemanticsRuleDef{EExprList}
\RenderRelation{eval_expr_list}
\BackupOriginalRelation{
The relation
\[
  \evalexprlist(\overname{\envs}{\env} \aslsep \overname{\KleeneStar{\expr}}{\vle}) \;\aslrel\;
  \left(
  \begin{array}{ll}
  \ResultExprList((\overname{\KleeneStar{\nativevalue}}{\vv} \times \overname{\XGraphs}{\vg})\aslsep \overname{\envs}{\newenv}) & \cup\\
  \overname{\TThrowing}{\ThrowingConfig}    & \cup\\
  \overname{\TDynError}{\DynErrorConfig}    & \cup\\
  \overname{\TDiverging}{\DivergingConfig}  & \\
  \end{array}
  \right)
\]
evaluates the list of expressions $\vle$ in left-to-right order in the initial environment $\env$
and returns the resulting list of values $\vv$, the parallel composition of the execution graphs
generated from evaluating each expression, and the new environment $\newenv$.
\ProseOtherwiseAbnormal
} % END_OF_BACKUP_RELATION

\ExampleDef{Evaluating a List of Expressions}
In \listingref{semantics-erecord},
evaluating the expression \verb|MyRecordType{a=3, b=42}| entails evaluating
the expression list \verb|3, 42|, which yields
the list of values $[\nvint(3), \nvint(42)]$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item \Proseemptylist{$\vle$};
    \item \Proseemptylist{$\vv$};
    \item \Proseemptygraph{$\vg$};
    \item \Proseeqdef{$\newenv$}{$\env$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vle$ is a \Proselist{$\ve$}{$\vle1$};
    \item \Proseevalexpr{$\env$}{$\ve$}{\\ $\ResultExpr((\vvone, \vgone), \envone)$}\ProseOrAbnormal;
    \item evaluating the list of expressions $\vle1$ in the environment $\envone$ yields \\
          $\ResultExprList((\vvs, \vgtwo), \envtwo)$\ProseOrAbnormal;
    \item \Proseeqdef{$\vg$}{the parallel composition of $\vgone$ and $\vgtwo$};
    \item \Proseeqdef{$\vv$}{the list with \head{} $\vvone$ and \tail{} $\vvs$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \evalexprlist(\env, \overname{\emptylist}{\vle}) \evalarrow
  \ResultExprList((\overname{\emptylist}{\vv}, \overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vle = [\ve] \concat \vle1\\
  \evalexpr(\env, \ve) \evalarrow \ResultExpr((\vvone, \vgone), \envone) \OrAbnormal\\\\
  \evalexprlist(\envone, \vle1) \evalarrow \ResultExprList((\vvs, \vgtwo), \newenv) \OrAbnormal\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo \\
  \vv \eqdef [\vvone] \concat \vvs
}{
  \evalexprlist(\env, \vle) \evalarrow \ResultExprList((\vv, \vg), \newenv)
}
\end{mathpar}
