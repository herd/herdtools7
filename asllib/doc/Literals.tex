\chapter{Literals\label{chap:Literals}}
ASL allows specifying literal values for the following types:
integers, Booleans, rational numbers, bitvectors, and strings.

Enumeration labels are also considered literal values.
However, they are syntactically indistinguishable from identifiers,
so they cannot be input directly in concrete syntax.
Rather, they are parsed as identifiers, and during typechecking
converted to enumeration label literal values (instances of $\LLabel$).

In the remainder of this reference, we refer to literal values simply as literals.

\ExampleDef{Literals}
\listingref{literals1} shows literals on the right hand side of assignments,
and their corresponding types in comments:
\ASLListing{Examples of literals and their corresponding types}{literals1}{\typingtests/TypingRule.Lit.asl}

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Literals} defines the formal relations for literals;
  \item \SyntaxRef{Literals} defines the syntax for literals;
  \item \AbstractSyntaxRef{Literals} defines the abstract syntax and the abstract syntax builders for literals;
  \item \TypeRulesRef{Literals} defines the typing of literals; and
  \item \SemanticsRulesRef{Literals} defines the semantics of literals.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Literals}
\paragraph{Syntax:} Literals are grammatically derived from $\Nvalue$.
\paragraph{Abstract Syntax:} Literals are derived in abstract syntax from $\literal$,
  and generated by $\buildvalue$.
\paragraph{Typing:} Literals are annotated by $\annotateliteral$.
\paragraph{Semantics:} Literals are represented in the dynamic semantics by \nativevaluesterm{}
  (see \SemanticsRulesRef{Literals}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SyntaxDef{Literals}
\begin{flalign*}
\Nvalue \derives         \ & \Tintlit &\\
                        |\ & \Tboollit &\\
                        |\ & \Treallit &\\
                        |\ & \Tbitvectorlit &\\
                        |\ & \Tstringlit &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\AbstractSyntaxDef{Literals}
\RenderType[remove_hypertargets]{literal}

\subsection{ASTRule.Value \label{sec:ASTRule.Value}}
\MarkedIgnoredRelationDefinition{
\hypertarget{build-value}{}
The function
\[
  \buildvalue(\overname{\parsenode{\Nvalue}}{\vparsednode}) \;\aslto\; \overname{\literal}{\vastnode}
\]
transforms a parse node $\vparsednode$ for $\Nvalue$ into an AST node $\vastnode$ for $\literal$.
} % END_OF_IGNORED_RELATION


\begin{mathpar}
\inferrule[integer]{}{
  \buildvalue(\Nvalue(\Tintlit(\vi))) \astarrow
  \overname{\LInt(\vi)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[boolean]{}{
  \buildvalue(\Nvalue(\Tboollit(\vb))) \astarrow
  \overname{\LBool(\vb)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[real]{}{
  \buildvalue(\Nvalue(\Treallit(\vr))) \astarrow
  \overname{\LReal(\vr)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bitvector]{}{
  \buildvalue(\Nvalue(\Tbitvectorlit(\vb))) \astarrow
  \overname{\LBitvector(\vb)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[string]{}{
  \buildvalue(\Nvalue(\Tstringlit(\vs))) \astarrow
  \overname{\LString(\vs)}{\vastnode}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\TypeRulesDef{Literals}
See \ExampleRef{Literals}.

\TypingRuleDef{Lit}
\RenderRelation{annotate_literal}
\BackupOriginalRelation{
The relation
\[
\annotateliteral(\overname{\staticenvs}{\texttt{tenv}}, \overname{\literal}{\texttt{l}})
\;\bigtimes\;
\overname{\ty}{\texttt{t}}
\]
annotates
a literal $\texttt{l}$ in the \staticenvironmentterm{} $\texttt{tenv}$,
resulting in a type
$\texttt{t}$.
} % END_OF_BACKUP_RELATION
See \ExampleRef{Literals}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{int}
  \begin{itemize}
    \item $\vl$ is an integer literal $\vn$;
    \item \Proseeqdef{$\vt$}{the well-constrained integer type, constraining
          its set to the single value $\vn$}.
  \end{itemize}

  \item \AllApplyCase{bool}
  \begin{itemize}
    \item $\vl$ is a Boolean literal;
    \item \Proseeqdef{$\vt$}{the \booleantypeterm}.
  \end{itemize}

  \item \AllApplyCase{real}
  \begin{itemize}
    \item $\vl$ is real literal;
    \item \Proseeqdef{$\vt$}{the \realtypeterm}.
  \end{itemize}

  \item \AllApplyCase{string}
  \begin{itemize}
    \item $\vl$ is a string literal;
    \item \Proseeqdef{$\vt$}{the \stringtypeterm}.
  \end{itemize}

  \item \AllApplyCase{bits}
  \begin{itemize}
    \item $\vl$ is a bitvector literal of length $\vn$;
    \item \Proseeqdef{$\vt$}{the bitvector type of fixed width $\vn$}.
  \end{itemize}

  \item \AllApplyCase{label}
  \begin{itemize}
    \item $\vl$ is an enumeration label for $\vlabel$;
    \item \Proseeqdef{$\vt$}{the type to which $\vlabel$ is bound in the
        $\declaredtypes$ map of the global environment $\tenv$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \begin{array}{r}
\inferrule[int]{}{\annotateliteral(\Ignore, \LInt(n)) \typearrow\\
\TInt(\WellConstrained([\ConstraintExact(\ELInt{n})]))}
  \end{array}
\end{mathpar}

\begin{mathpar}
\inferrule[bool]{}{\annotateliteral(\Ignore, \LBool(\Ignore))\typearrow \TBool}
\end{mathpar}

\begin{mathpar}
\inferrule[real]{}{\annotateliteral(\Ignore, \LReal(\Ignore))}\typearrow \TReal
\end{mathpar}

\begin{mathpar}
\inferrule[string]{}{\annotateliteral(\Ignore, \LString(\Ignore))\typearrow \TString}
\end{mathpar}

\begin{mathpar}
\inferrule[bits]{
  n \eqdef \listlen{\bits}
}{
  \annotateliteral(\Ignore, \LBitvector(\bits))\typearrow \TBits(\ELInt{n}, \emptylist)
}
\end{mathpar}

\begin{mathpar}
\inferrule[label]{
  G^\tenv.\declaredtypes(\vlabel) = (\vt, \Ignore)
}{
  \annotateliteral(\tenv, \LLabel(\vlabel))\typearrow \vt
}
\end{mathpar}
\CodeSubsection{\LitBegin}{\LitEnd}{../Typing.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SemanticsRulesDef{Literals}
A literal $\vl$ is represented in the dynamic semantics by the \nativevalueterm{} $\NVLiteral(\vl)$.

\ExampleDef{Converting a Literal to a Value}
The literal $\LInt(5)$ can be used as a \nativevalueterm{} $\NVLiteral(\LInt(5))$,
which we will usually abbreviate as $\nvint(5)$.
