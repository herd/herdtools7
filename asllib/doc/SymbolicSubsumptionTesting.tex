\chapter{Symbolic Subsumption Testing\label{chap:SymbolicSubsumptionTesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter is concerned with implementing a \hyperlink{def-soundsubsumptiontest}{sound subsumption test}
for integer types, as defined in \secref{subsumptiontesting} and employed by
TypingRule.SubtypeSatisfaction (see \secref{TypingRule.SubtypeSatisfaction}).

\hypertarget{def-symbolicdomain}{}
The symbolic reasoning operates by first transforming types into expressions in a \emph{symbolic domain} AST
(defined next, reusing $\intconstraint$ from the untyped AST) over which it then operates:
\hypertarget{def-symdom}{}
\hypertarget{def-finite}{}
\[
  \begin{array}{rcl}
    \symdom &::=& \Finite(\powfin{\Z} \setminus \emptyset) \hypertarget{def-top}{}\\
            &|  & \Top                      \hypertarget{def-fromsymtax}{}\\
            &|  & \FromSyntax(\syntax)      \hypertarget{def-syntax}{}\\
    \syntax &::=& \intconstraint^*
  \end{array}
\]

\begin{itemize}
  \item We refer to an element of the form $\Finite(S)$ as a \emph{symbolic finite set integer domain},
        which represents the set of integers $S$;
  \item We refer to an element of the form $\FromSyntax(\vcs)$ as a \emph{symbolic constrained integer domain},
        which represents the set of integers given by the list of constraints $\vcs$; and
  \item We refer to an element of the form $\Top$ as a \emph{symbolic unconstrained integer domain},
        which represents the set of all integers.
\end{itemize}

The main rule is of this chapter is TypingRule.SymSubsumes (see \secref{TypingRule.SymSubsumes}), which defines the function
$\symsubsumes$.

Other helper rules are as follows:
\begin{itemize}
  \item TypingRule.SymDomOfType (see \secref{TypingRule.SymDomOfType})
  \item TypingRule.SymDomOfExpr (see \secref{TypingRule.SymDomOfExpr})
  \item TypingRule.SymDomOfWidth (see \secref{TypingRule.SymDomOfWidth})
  \item TypingRule.IntSetOp (see \secref{TypingRule.IntSetOp})
  \item TypingRule.IntSetToIntConstraints (see \secref{TypingRule.IntSetToIntConstraints})
  \item TypingRule.SymDomOfLiteral (see \secref{TypingRule.SymDomOfLiteral})
  \item TypingRule.SymIntSetOfConstraints (see \secref{TypingRule.SymIntSetOfConstraints})
  \item TypingRule.ConstraintToIntSet (see \secref{TypingRule.ConstraintToIntSet})
  \item TypingRule.NormalizeToInt (see \secref{TypingRule.NormalizeToInt})
  \item TypingRule.SymDomIsSubset (see \secref{TypingRule.SymDomIsSubset})
  \item TypingRule.SymIntSetSubset (see \secref{TypingRule.SymIntSetSubset})
  \item TypingRule.ConstraintBinop (see \secref{TypingRule.ConstraintBinop})
  \item TypingRule.IsRightIncreasing (see \secref{TypingRule.IsRightIncreasing})
  \item TypingRule.IsRightDecreasing (see \secref{TypingRule.IsRightDecreasing})
  \item TypingRule.IsLeftIncreasing (see \secref{TypingRule.IsLeftIncreasing})
\end{itemize}

\subsection{TypingRule.SymSubsumes \label{sec:TypingRule.SymSubsumes}}
\hypertarget{def-symsubsumes}{}
The predicate
\[
  \symsubsumes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb}
\]
soundly approximates $\subsumes(\tenv, \vt, \vs)$ for integer types.
\ProseOtherwiseTypeError

We assume that both $\vt$ and $\vs$ have been successfully annotated to integer types as per \chapref{Types}
(otherwise a typing error prevents us from applying this function).

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\symdomoftype$ to $\vt$ in $\tenv$ yields $\dt$;
  \item applying $\symdomoftype$ to $\vs$ in $\tenv$ yields $\ds$;
  \item applying $\symdomissubset$ to $\dt$ and $\ds$ in $\tenv$ yields $\vb$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \symdomoftype(\tenv, \vt) \typearrow \dt\\
  \symdomoftype(\tenv, \vs) \typearrow \ds\\
  \symdomissubset(\tenv, \dt, \ds) \typearrow \vb
}{
  \symsubsumes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\subsection{TypingRule.SymDomOfType \label{sec:TypingRule.SymDomOfType}}
\hypertarget{def-symdomoftype}{}
The function
\[
  \symdomoftype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto \overname{\symdom}{\vd}
\]
transforms a type $\vt$ in a static environment $\tenv$ into a symbolic domain $\vd$.
It assumes its input type has an \underlyingtype{} which is an integer.
\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{int\_unconstrained}):
  \begin{itemize}
    \item $\vt$ is the unconstrained integer type;
    \item define $\vd$ as $\Top$, which intuitively represents the entire set of integers.
  \end{itemize}

  \item All of the following apply (\textsc{int\_parameterized}):
  \begin{itemize}
    \item $\vt$ is the \parameterizedintegertype\ for the identifier $\id$;
    \item define $\vd$ as the symbolic constrained integer domain with a single constraint for the variable expression for $\id$,
          that is, \\ $\FromSyntax([\ConstraintExact(\EVar(\id))])$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_well\_constrained\_finite}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\intsetofintconstraints$ to $\vcs$ in $\tenv$ yields $\vis$;
    \item $\vis$ is a set of integers, that is, $\astlabel(\vis)$ is $\Finite$;
    \item define $\vd$ as the symbolic finite set integer domain for $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_well\_constrained\_symbolic}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\intsetofintconstraints$ to $\vcs$ in $\tenv$ yields $\vis$;
    \item $\vis$ is not a set of integers, that is, $\astlabel(\vis)$ is not $\Finite$;
    \item define $\vd$ as the symbolic constrained integer domain for the list of constraints $\vcs$, that is, $\FromSyntax(\vcs)$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_named}):
  \begin{itemize}
    \item $\vt$ is the named type for identifier $\id$;
    \item applying $\makeanonymous$ to $\vt$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ in $\tenv$ yields $\vd$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[int\_unconstrained]{}{ \symdomoftype(\tenv, \overname{\unconstrainedinteger}{\vt}) \typearrow \overname{\Top}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[int\_parameterized]{}{
  \symdomoftype(\tenv, \overname{\TInt(\parameterized(\id))}{\vt}) \typearrow \\
  \overname{\FromSyntax([\ConstraintExact(\EVar(\id))])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained\_finite]{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \vis\\
  \astlabel(\vis) = \Finite
}{
  \symdomoftype(\tenv, \overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\vis}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained\_symbolic]{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \vis\\
  \astlabel(\vis) \neq \Finite
}{
  \symdomoftype(\tenv, \overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\FromSyntax(\vcs)}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_named]{
  \vt = \TNamed(\id)\\
  \makeanonymous(\vt) \typearrow \vtone\\
  \symdomoftype(\tenv, \vtone) \typearrow \vd
}{
  \symdomoftype(\tenv, \vt) \typearrow \vd
}
\end{mathpar}

\subsection{TypingRule.SymDomOfExpr \label{sec:TypingRule.SymDomOfExpr}}
\hypertarget{def-symdomofexpr}{}
The function
\[
\symdomofexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto
\overname{\symdom}{\vd}
\]
assigns a symbolic domain $\vd$ to an \underline{integer typed} expression $\ve$ in the static environment $\tenv$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{e\_literal}):
  \begin{itemize}
    \item $\ve$ is a literal expression for the literal $\vv$;
    \item applying $\symdomofliteral$ to $\vv$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vx$;
    \item applying $\lookupconstant$ to $\vx$ in $\tenv$ yields the literal $\vv$;
    \item applying $\symdomofliteral$ to $\vv$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_type}):
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vx$;
    \item applying $\lookupconstant$ to $\vx$ in $\tenv$ yields $\bot$;
    \item applying $\typeof$ to $\vx$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop\_minus}):
  \begin{itemize}
    \item $\ve$ is a unary operation expression for the operation $\MINUS$ and subexpression $\veone$;
    \item applying $\symdomofexpr$ to the binary operation expression with the operation $\MINUS$
          and the literal expression for $0$ and $\veone$ in $\tenv$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop\_unknown}):
  \begin{itemize}
    \item $\ve$ is a unary operation expression for an operation that is not $\MINUS$;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop\_supported}):
  \begin{itemize}
    \item $\ve$ is a binary operation expression for an operation that is one of $\PLUS$, $\MINUS$, or $\MUL$
          and subexpressions $\veone$ and $\vetwo$;
    \item applying $\symdomofexpr$ to $\veone$ in $\tenv$ yields a symbolic domain $\visone$;
    \item applying $\symdomofexpr$ to $\vetwo$ in $\tenv$ yields a symbolic domain $\vistwo$;
    \item applying $\intsetop$ to $\op$ and $\visone$ and $\vistwo$ yields $\vis$;
    \item define $\vd$ as $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop\_unsupported}):
  \begin{itemize}
    \item $\ve$ is a binary operation expression for an operation that is not one of $\PLUS$, $\MINUS$, or $\MUL$;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$
  \end{itemize}

  \item All of the following apply (\textsc{unsupported}):
  \begin{itemize}
    \item $\ve$ is not one of the following expression types a literal expression, a variable expression, a unary operation
          expression, or a binary operation expression;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[e\_literal]{
  \symdomofliteral(\vv) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\ELiteral(\vv)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_constant]{
  \lookupconstant(\tenv, \vx) \typearrow \vv\\
  \symdomofliteral(\vv) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_type]{
  \lookupconstant(\tenv, \vx) \typearrow \bot\\
  \typeof(\tenv, \vx) \typearrow \vtone\\
  \symdomoftype(\vtone) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop\_minus]{
  \symdomofexpr(\EBinop(\MINUS, \ELiteral(\lint(0)), \veone)) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EUnop(\MINUS, \veone)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop\_unknown]{
  \op \neq \MINUS
}{
  \symdomofexpr(\tenv, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop\_supported]{
  \op \in \{\PLUS, \MINUS, \MUL\}\\
  \symdomofexpr(\tenv, \veone) \typearrow \visone\\
  \symdomofexpr(\tenv, \vetwo) \typearrow \vistwo\\
  \intsetop(\op, \visone, \vistwo) \typearrow \vis
}{
  \symdomofexpr(\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \overname{\vis}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop\_unsupported]{
  \op \not\in \{\PLUS, \MINUS, \MUL\}\\
}{
  \symdomofexpr(\tenv, \overname{\EBinop(\op, \Ignore, \Ignore)}{\ve}) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unsupported]{
  \astlabel(\ve) \not\in \{\ELiteral, \EVar, \EUnop, \EBinop\}
}{
  \symdomofexpr(\tenv, \ve) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\subsection{TypingRule.SymDomOfWidth \label{sec:TypingRule.SymDomOfWidth}}
\hypertarget{def-symdomofwidth}{}
The function
\[
\symdomofwidth(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto
\overname{\symdom}{\vd}
\]
assigns a symbolic domain $\vd$ to an \underline{integer typed} expression $\ve$ in the static environment $\tenv$.
In contrast to $\symdomofexpr$, $\symdomofwidth$ should be applied to expressions that represent a bit vector width.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{finite\_one\_width}):
  \begin{itemize}
    \item applying $\symdomofexpr$ to $\ve$ in $\tenv$ yields $\vdone$;
    \item $\vdone$ is a set of integers, that is, $\Finite(s)$;
    \item the cardinality of $s$ is one;
    \item $\vd$ is $\vdone$.
  \end{itemize}

  \item All of the following apply (\textsc{finite\_multiple\_widths}):
  \begin{itemize}
    \item applying $\symdomofexpr$ to $\ve$ in $\tenv$ yields $\vdone$;
    \item $\vdone$ is a set of integers, that is, $\Finite(s)$;
    \item the cardinality of $s$ is \emph{not} one;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_finite}):
  \begin{itemize}
    \item applying $\symdomofexpr$ to $\ve$ in $\tenv$ yields $\vdone$;
    \item $\vdone$ is not a set of integers, that is, $\astlabel(\vdone)$ is not $\Finite$;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[finite\_one\_width]{
  \symdomofexpr(\tenv, \ve) \typearrow \vdone \\
  \vdone = \Finite(s) \\
  \cardinality{s} = 1
}{
  \symdomofwidth(\tenv, \ve) \typearrow \overname{\vdone}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_multiple\_widths]{
  \symdomofexpr(\tenv, \ve) \typearrow \vdone \\
  \vdone = \Finite(s) \\
  \cardinality{s} \neq 1
}{
  \symdomofwidth(\tenv, \ve) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_finite]{
  \symdomofexpr(\tenv, \ve) \typearrow \vdone \\
  \astlabel(\vdone) \neq \Finite
}{
  \symdomofwidth(\tenv, \ve) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\subsection{TypingRule.IntSetOp \label{sec:TypingRule.IntSetOp}}
\hypertarget{def-intsetop}{}
The function
\[
\intsetop(\overname{\binop}{\op} \aslsep \overname{\symdom}{\visone} \aslsep \overname{\symdom}{\vistwo})
\aslto \overname{\symdom}{\vis}
\]
applies the binary operation $\op$ to the symbolic domains $\visone$ and $\vistwo$,
yielding the symbolic domain $\vis$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{top}):
  \begin{itemize}
    \item at least one of $\visone$ and $\vistwo$ is $\Top$;
    \item define $\vis$ as $\Top$.
  \end{itemize}

  \item All of the following apply (\textsc{finite\_finite}):
  \begin{itemize}
    \item $\visone$ is the symbolic finite set integer domain for $\vsone$;
    \item $\vistwo$ is the symbolic finite set integer domain for $\vstwo$;
    \item define $\vis$ as the symbolic finite set domain for the set obtained
          by applying $\op$ to each element of $\vsone$ and each element of $\vstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{finite\_syntax}):
  \begin{itemize}
    \item $\visone$ is the symbolic finite set integer domain for $\vsone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\vstwo$;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item applying $\intsetop$ to $\op$, the symbolic constrained integer domain for $\csone$,
          and $\vistwo$ yields $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{syntax\_finite}):
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic finite set integer domain for $\vstwo$;
    \item applying $\intsettointconstraints$ to $\vstwo$ yields the list of constraints $\cstwo$;
    \item applying $\intsetop$ to $\op$, $\visone$, and the symbolic constrained integer domain
          for $\cstwo$, yields $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{syntax\_syntax\_well\_constrained}):
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\cstwo$;
    \item applying $\constraintbinop$ to $\op$, $\csone$, and $\cstwo$ yields
          a list of constraints $\vcs$;
    \item define $\vis$ as the symbolic constrained integer domain for $\vcs$.
  \end{itemize}

  \item All of the following apply (\textsc{syntax\_syntax\_top}):
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\cstwo$;
    \item applying $\constraintbinop$ to $\op$, $\csone$, and $\cstwo$ yields $\top$;
    \item define $\vis$ as $\Top$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[top]{
  \visone = \Top \lor \vistwo = \Top
}{
  \intsetop(\op, \visone, \vistwo) \typearrow \overname{\Top}{\vis}
}
\and
\inferrule[finite\_finite]{
  \vis \eqdef \Finite(\{ \op(a, b) \;|\; a \in \vsone, b \in \vstwo \})
}{
  \intsetop(\op, \overname{\Finite(\vsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_syntax]{
  \intsettointconstraints(\vsone) \typearrow \vcsone\\
  \intsetop(\op, \FromSyntax(\vcsone), \FromSyntax(\vcstwo)) \typearrow \vis
}{
  \intsetop(\op, \overname{\Finite(\vsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_finite]{
  \intsettointconstraints(\vstwo) \typearrow \vcstwo\\
  \intsetop(\op, \FromSyntax(\vcsone), \FromSyntax(\vcstwo)) \typearrow \vis
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_syntax\_well\_constrained]{
  \constraintbinop(\op, \vcsone, \vcstwo) \typearrow \wellconstrained(\vcs)
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \overname{\FromSyntax(\vcs)}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_syntax\_top]{
  \constraintbinop(\op, \vcsone, \vcstwo) \typearrow \top
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \overname{\Top}{\vis}
}
\end{mathpar}

\subsection{TypingRule.IntSetToIntConstraints \label{sec:TypingRule.IntSetToIntConstraints}}
\hypertarget{def-intsettointconstraints}{}
The function
\[
\intsettointconstraints(\overname{\powfin{\Z}}{\vs})
\aslto \overname{\intconstraint^*}{\cs}
\]
transforms a finite set of integers into the equivalent list of integer constraints.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\vs$ is the empty set;
    \item define $\cs$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{singleton}):
  \begin{itemize}
    \item $\vs$ is the singleton set for $a$;
    \item define $\cs$ as the list containing the single range constraint for the interval starting from $a$
          and ending at $a$, that is, $\ConstraintRange(\ELInt{a}, \ELInt{a})$.
  \end{itemize}

  \item All of the following apply (\textsc{new\_interval}):
  \begin{itemize}
    \item define $a$ as the minimal element of $\vs$;
    \item define $\vsone$ as the set $\vs$ with $a$ removed from it;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item $\csone$ is a list where its \head\ is a range constraint for the interval starting from $b$ and ending at $c$
          and \tail\ $\cstwo$;
    \item $b$ is greater than $a+1$;
    \item define $\cs$ as the list with first element a range constraint for the interval from $a$ to $a$,
          second element a range constraint for the interval from $b$ to $c$, and remaining elements given by $\cstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{merge\_interval}):
  \begin{itemize}
    \item define $a$ as the minimal element of $\vs$;
    \item define $\vsone$ as the set $\vs$ with $a$ removed from it;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item $\csone$ is a list where its \head\ is a range constraint for the interval starting from $b$ and ending at $c$
          and \tail\ $\cstwo$;
    \item $b$ is equal to $a+1$;
    \item define $\cs$ as the list with \head\  a range constraint for the interval from $a$ to $c$
          and \tail\ $\cstwo$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \intsettointconstraints(\overname{\emptyset}{\vs}) \typearrow \overname{\emptylist}{\cs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[singleton]{}{
  \intsettointconstraints(\overname{\{a\}}{\vs}) \typearrow \overname{[\ConstraintRange(\ELInt{a}, \ELInt{a})]}{\cs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[new\_interval]{
  a = \min(\vs)\\
  \vsone \eqdef \vs \setminus \{a\}\\
  \intsettointconstraints(\vsone) \typearrow \csone\\
  \csone = [\ConstraintRange(\ELInt{b}, \ELInt{c})] \concat \cstwo\\
  b > a + 1\\\\
  {
    \begin{array}{rcl}
  \cs  &\eqdef & [\ConstraintRange(\ELInt{a}, \ELInt{a})]\ \concat\\
        &       & [\ConstraintRange(\ELInt{b}, \ELInt{c})]\ \concat \\
        &       & \cstwo
    \end{array}
  }
}{
  \intsettointconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\begin{mathpar}
\inferrule[merge\_interval]{
  a = \min(\vs)\\
  \vsone \eqdef \vs \setminus \{a\}\\
  \intsettointconstraints(\vsone) \typearrow \csone\\
  \csone = [\ConstraintRange(\ELInt{b}, \ELInt{c})] \concat \cstwo\\
  b = a + 1\\
  \cs \eqdef [\ConstraintRange(\ELInt{a}, \ELInt{c})] \concat \cstwo
}{
  \intsettointconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\subsection{TypingRule.SymDomOfLiteral \label{sec:TypingRule.SymDomOfLiteral}}
\hypertarget{def-symdomofliteral}{}
The function
\[
\symdomofliteral(\overname{\literal}{\vv}) \typearrow \overname{\symdom}{\vd}
\]
returns the symbolic domain $\vd$ that corresponds to the literal $\vv$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vv$ is an integer literal for $n$;
  \item define $\vd$ as the symbolic finite set integer domain for the singleton set for $n$, that is, $\Finite(\{n\})$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \symdomofliteral(\overname{\lint(n)}{\vv}) \typearrow \overname{\Finite(\{n\})}{\vd}
}
\end{mathpar}

\subsection{TypingRule.SymIntSetOfConstraints \label{sec:TypingRule.SymIntSetOfConstraints}}
\hypertarget{def-intsetofintconstraintse}{}
The function
\[
  \intsetofintconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\constraints}{\vcs}
  ) \aslto
  \overname{\symdom}{\vis}
\]
returns the symbolic domain $\vis$ for the list of constraints $\vcs$
in the static environment $\tenv$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{finite}):
  \begin{itemize}
    \item applying $\constrainttointset$ to every constraint $\vcs[\vi]$ in $\tenv$, for $\vi$ in \\ $\listrange(\vcs)$,
          yields a finite set of integers $C_\vi$, that is, $\Finite(C_\vi)$;
    \item define $\vis$ as the union of $C_\vi$ for all $\vi$ in $\listrange(\vcs)$.
  \end{itemize}

  \item All of the following apply (\textsc{symbolic}):
  \begin{itemize}
    \item there exists a constraint $\vc$ in $\vcs$ such that applying $\constrainttointset$ to $\vc$
          in $\tenv$ does not yield a finite set of integers;
    \item define $\vis$ as the symbolic constrained integer domain for $\vcs$, that is, \\
          $\FromSyntax(\vcs)$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[finite]{
  \vi\in\listrange(\vcs): \constrainttointset(\tenv, \vcs[\vi]) \typearrow \Finite(C_\vi)\\
  C \eqdef \bigcup_{\vi\in\listrange(\vcs)} C_\vi
}{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \overname{\Finite(C)}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[symbolic]{
  {
    \begin{array}{r}
  \exists \vi\in\listrange(\vcs): \constrainttointset(\tenv, \vcs[\vi]) \typearrow \\
     \visone \land \astlabel(\visone) \neq \Finite
    \end{array}
  }
}{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \overname{\FromSyntax(\vcs)}{\vis}
}
\end{mathpar}

\subsection{TypingRule.ConstraintToIntSet \label{sec:TypingRule.ConstraintToIntSet}}
\hypertarget{def-constrainttointset}{}
The function
\[
  \constrainttointset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\intconstraint}{\vc}
  ) \aslto
  \overname{\symdom}{\vis}
\]
transforms an integer constraint $\vc$ into a symbolic domain $\vis$.
It produces $\Top$ when the expressions involved in the integer constraints cannot be simplified
to integers.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is a single expression constraint for $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\normalizetoint$ to $\ve$ in $\tenv$ yields the integer $n$\ProseTerminateAs{\Top};
    \item define $\vis$ as the singleton set for $n$, that is, $\Finite(\{n\})$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is a range constraint for $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\normalizetoint$ to $\veone$ in $\tenv$ yields the integer $b$\ProseTerminateAs{\Top};
    \item applying $\normalizetoint$ to $\vetwo$ in $\tenv$ yields the integer $t$\ProseTerminateAs{\Top};
    \item define $\vis$ as the set integers that are both greater or equal to $b$ and less than or equal to $t$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[exact]{
  \normalizetoint(\tenv, \ve) \typearrow n \terminateas \Top
}{
  \constrainttointset(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\Finite(\{n\})}{\vis}
}
\and
\inferrule[range]{
  \normalizetoint(\tenv, \veone) \typearrow b \terminateas \Top\\\\
  \normalizetoint(\tenv, \vetwo) \typearrow t \terminateas \Top\\\\
  \vis \eqdef \Finite(\{ n \;|\; b \leq n \leq t\})
}{
  \constrainttointset(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vis
}
\end{mathpar}

\subsection{TypingRule.NormalizeToInt \label{sec:TypingRule.NormalizeToInt}}
\hypertarget{def-normalizetoint}{}
The function
\[
\normalizetoint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\Z}{n} \cup \{\Top\}
\]
\symbolicallysimplifies\ the \underline{integer-typed} expression $\ve$ and returns the resulting integer or $\Top$ if
the result of the simplification is not an integer.

We assume that $\ve$ has been annotated as it is part of the constraint for an integer type,
and therefore applying $\normalize$ to it does not yield a type error.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{integer}):
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the integer literal for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{top}):
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields $\top$.
    \item the result is $\Top$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[integer]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \lint(n)
}{
  \normalizetoint(\tenv, \ve) \typearrow n
}
\and
\inferrule[top]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \top
}{
  \normalizetoint(\tenv, \ve) \typearrow \Top
}
\end{mathpar}

\subsection{TypingRule.SymDomIsSubset\label{sec:TypingRule.SymDomIsSubset}}
\hypertarget{def-symdomissubset}{}
The function
\[
  \symdomissubset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\symdom}{\vdone} \aslsep
    \overname{\symdom}{\vdtwo}
  ) \aslto
  \overname{\Bool}{\vb}
\]
conservatively tests whether the symbolic domain $\vdone$ is subsumed by the symbolic domain $\vdtwo$,
yielding the result $\vb$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\symintsetsubset$ to $\vdone$ and $\vdtwo$ in $\tenv$ yields $\vb$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \symintsetsubset(\tenv, \vdone, \vdtwo) \typearrow \vb
}{
  \symdomissubset(\tenv, \vdone, \vdtwo) \typearrow \vb
}
\end{mathpar}
\CodeSubsection{\SyDomIsSubsetBegin}{\SyDomIsSubsetEnd}{../types.ml}

\subsection{TypingRule.SymIntSetSubset\label{sec:TypingRule.SymIntSetSubset}}
\hypertarget{def-symintsetsubset}{}
The function
\[
\symintsetsubset(\overname{\staticenvs}{\tenv} \aslsep \overname{\symdom}{\visone} \aslsep \overname{\symdom}{\vistwo}) \aslto \overname{\Bool}{\vb}
\]
conservatively tests whether the symbolic integer set $\visone$ is a subset of the symbolic integer set $\vistwo$,
yielding the result in $\vb$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{right\_top}):
  \begin{itemize}
    \item $\vistwo$ is $\Top$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{left\_top\_right\_not\_top}):
  \begin{itemize}
    \item $\visone$ is $\Top$;
    \item $\vistwo$ is not $\Top$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{finite\_finite}):
  \begin{itemize}
    \item $\visone$ is a finite set of integers for $\vsone$, that is, $\Finite(\vsone)$;
    \item $\vistwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item define $\vb$ as $\True$ if and only if $\vsone$ is a subset of $\vstwo$ or both sets are equal.
  \end{itemize}

  \item All of the following apply (\textsc{syntax\_synax}):
  \begin{itemize}
    \item $\visone$ is a set of integers given by the list of constraints $\csone$, that is, \\ $\FromSyntax(\vsone)$;
    \item $\vistwo$ is a set of integers given by the list of constraints $\cstwo$, that is, \\ $\FromSyntax(\vstwo)$;
    \item applying $\constraintsequal$ to $\csone$ and $\cstwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item both $\visone$ and $\vistwo$ are not $\Top$;
    \item the AST labels of $\visone$ and $\vistwo$ are different;
    \item define $\vb$ as $\False$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[right\_top]{}{
  \symintsetsubset(\tenv, \visone, \overname{\Top}{\vistwo}) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[left\_top\_right\_not\_top]{
  \vistwo \neq \Top
}{
  \symintsetsubset(\tenv, \overname{\Top}{\visone}, \vistwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_finite]{}{
  \symintsetsubset(\tenv, \overname{\Finite(\vsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

% | FromSyntax cs1, FromSyntax cs2 ->
% constraints_equal env cs1 cs2
% || Iterators.constraints_for_all env cs1 @@ fun l1 ->
%    Iterators.constraints_exists env cs2 @@ fun l2 -> literal_equal l1 l2
% | Finite ints1, FromSyntax cs2 -> (
% int_set_for_all ints1 @@ fun z1 ->
% Iterators.constraints_exists env cs2 @@ function
% | L_Int z2 -> Z.equal z1 z2
% | _ -> false)
% | FromSyntax cs1, Finite ints2 -> (
% Iterators.constraints_for_all env cs1 @@ function
% | L_Int z1 -> IntSet.mem z1 ints2
% | _ -> false)
\begin{mathpar}
\inferrule[syntax\_syntax]{
  \constraintsequal(\tenv, \csone, \cstwo) \typearrow \vb
}{
  \symintsetsubset(\tenv, \overname{\FromSyntax(\csone)}{\visone}, \overname{\FromSyntax(\cstwo)}{\vistwo}) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \visone \neq \Top \and \vistwo \neq \Top\\
  \astlabel(\visone) \neq \astlabel(\vistwo)
}{
  \symintsetsubset(\tenv, \visone, \vistwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}
\CodeSubsection{\SymIntSetSubsetBegin}{\SymIntSetSubsetEnd}{../types.ml}

\subsection{TypingRule.ConstraintBinop \label{sec:TypingRule.ConstraintBinop}}
\hypertarget{def-constraintbinop}{}
The function
\[
\constraintbinop(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint^*}{\csone} \aslsep
  \overname{\intconstraint^*}{\cstwo}
)
\aslto \overname{\constraintkind}{\vics}
\]
symbolically applies the binary operation $\op$ to the lists of integer constraints $\csone$ and $\cstwo$,
yielding the integer constraints $\vics$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{well\_constrained}):
  \begin{itemize}
    \item for every $\vi$ in $\listrange(\csone)$ and every $\vj$ in $\listrange(\cstwo)$,
          applying \\
          $\constraintbinoppair$ to $\op$, $\csone[\vi]$, and $\cstwo[\vj]$,
          yields the constraint $\vc_{(\vi,\vj)}$;
    \item define $\cs$ as the list consisting of constraints $\vc_{(\vi,\vj)}$,
          for every $\vi$ in $\listrange(\csone)$ and every $\vj$ in $\listrange(\cstwo)$;
    \item $\vics$ is the well-constrained list of constrains $\cs$.
  \end{itemize}

  \item All of the following apply (\textsc{unconstrained}):
  \begin{itemize}
    \item there exist $\vi$ in $\listrange(\csone)$ and $\vj$ in $\listrange(\cstwo)$,
          such that applying
          $\constraintbinoppair$ to $\op$, $\csone[\vi]$, and $\cstwo[\vj]$,
          yields $\top$;
    \item $\vics$ is $\unconstrained$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[well\_constrained]{
  {
    \begin{array}{l}
  \vi\in\listrange(\csone), \vj\in\listrange(\cstwo): \\
  \constraintbinoppair(\op, \csone[\vi], \cstwo[\vj]) \typearrow \vc_{(\vi,\vj)}
    \end{array}
  }\\
  \cs \eqdef [\vi\in\listrange(\csone), \vj\in\listrange(\cstwo): \vc_{(\vi,\vj)}]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \overname{\wellconstrained(\cs)}{\vics}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  {
    \begin{array}{l}
  \exists \vi\in\listrange(\csone).\ \exists \vj\in\listrange(\cstwo).\ \\
  \constraintbinoppair(\op, \csone[\vi], \cstwo[\vj]) \typearrow \top
    \end{array}
  }
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \overname{\unconstrained}{\vics}
}
\end{mathpar}

\subsection{TypingRule.ConstraintBinopPair \label{sec:TypingRule.ConstraintBinopPair}}
\hypertarget{def-constraintbinoppair}{}
The function
\[
\constraintbinoppair(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint}{\vcone} \aslsep
  \overname{\intconstraint}{\vctwo}
)
\aslto \overname{\overname{\intconstraint}{\vc} \cup \{\top\}}{\vres}
\]
symbolically applies the binary operation $\op$ to the pair of integer constraints $\vcone$ and $\vctwo$,
yielding $\vres$ which is an integer constraint $\vc$ or
$\top$, which indicates a failure in representing the result as an integer constraint.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact\_exact}):
  \begin{itemize}
    \item $\vcone$ is an exact constraint for the expression $\veone$, that is, \ConstraintExact(\veone);
    \item $\vctwo$ is an exact constraint for the expression $\vetwo$, that is, \ConstraintExact(\vetwo);
    \item define $\vc$ as the exact constraint for the binary operation expression with $\op$, $\veone$, and $\vetwo$,
          that is, $\ConstraintExact(\EBinop(\op, \veone, \vetwo))$;
  \end{itemize}

  \item All of the following apply (\textsc{exact\_range}):
  \begin{itemize}
    \item $\vcone$ is an exact constraint for the expression $\veone$, that is, $\ConstraintExact(\veone)$;
    \item $\vctwo$ is an range constraint for the expressions $\vetwoone$ and $\vetwotwo$, that is, \\ $\ConstraintRange(\vetwoone, \vetwotwo)$;
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply:
      \begin{itemize}
          \item applying $\isrightincreasing$ to $\op$ yields $\True$;
          \item define $\vc$ as the range constraint for the following two expressions:
          the binary operation expression for $\op$ $\veone$ and $\vetwoone$, and
          the binary operation expression for $\op$ $\veone$ and $\vetwotwo$;
      \end{itemize}

      \item All of the following apply:
      \begin{itemize}
          \item applying $\isrightdecreasing$ to $\op$ yields $\True$;
          \item define $\vc$ as the range constraint for the following two expressions:
          the binary operation expression for $\op$ $\veone$ and $\vetwotwo$, and
          the binary operation expression for $\op$ $\veone$ and $\vetwoone$;
      \end{itemize}

      \item Otherwise, the result is $\Top$;
    \end{itemize}
  \end{itemize}

  \item All of the following apply (\textsc{range\_exact}):
  \begin{itemize}
    \item $\vcone$ is an range constraint for the expressions $\veoneone$ and $\veonetwo$, that is, \\ $\ConstraintRange(\veoneone, \veonetwo)$;
    \item $\vctwo$ is an exact constraint for the expression $\vetwo$, that is, $\ConstraintExact(\vetwo)$;
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item applying $\isleftincreasing$ to $\op$ yields $\True$;
        \item define $\vc$ as the range constraint for the following two expressions:
              the binary operation expression for $\op$ $\veoneone$ and $\vetwo$, and
              the binary operation expression for $\op$ $\veonetwo$ and $\vetwo$;
      \end{itemize}
      \item Otherwise, the result is $\Top$.
    \end{itemize}
  \end{itemize}

  \item All of the following apply (\textsc{range\_range}):
  \begin{itemize}
    \item $\vcone$ is an range constraint for the expressions $\veoneone$ and $\veonetwo$, that is, \\ $\ConstraintRange(\veoneone, \veonetwo)$;
    \item $\vctwo$ is an range constraint for the expressions $\vetwoone$ and $\vetwotwo$, that is, \\ $\ConstraintRange(\vetwoone, \vetwotwo)$;
    \item One of the following applies:
    \begin{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item applying $\isleftincreasing$ to $\op$ yields $\True$;
        \item applying $\isrightincreasing$ to $\op$ yields $\True$;
        \item define $\vc$ as the range constraint for the following two expressions:
              the binary operation expression for $\op$ $\veoneone$ and $\vetwoone$, and
              the binary operation expression for $\op$ $\veonetwo$ and $\vetwotwo$;
      \end{itemize}
      \item All of the following apply:
      \begin{itemize}
        \item applying $\isleftincreasing$ to $\op$ yields $\True$;
        \item applying $\isrightdecreasing$ to $\op$ yields $\True$;
        \item define $\vc$ as the range constraint for the following two expressions:
              the binary operation expression for $\op$ $\veoneone$ and $\vetwotwo$, and
              the binary operation expression for $\op$ $\veonetwo$ and $\vetwoone$;
      \end{itemize}
      \item Otherwise, the result is $\Top$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[exact\_exact]{}{
  \constraintbinoppair(\op, \overname{\AbbrevConstraintExact{\veone}}{\vcone}, \overname{\AbbrevConstraintExact{\vetwo}}{\vctwo}) \typearrow
  \overname{\AbbrevConstraintExact{\AbbrevEBinop{\op}{\veone}{\vetwo}}}{\vc}
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range]{
  \vres \eqdef
  {
    \begin{cases}
      % 2
      \AbbrevConstraintRange{\AbbrevEBinop{\op}{\veone}{\vetwoone}}{\AbbrevEBinop{\op}{\veone}{\vetwotwo}} & \textbf{if }
      (\isrightincreasing(\op) \typearrow \True) \\
      % 3
      \AbbrevConstraintRange{\AbbrevEBinop{\op}{\veone}{\vetwotwo}}{\AbbrevEBinop{\op}{\veone}{\vetwoone}} & \textbf{if }
      (\isrightdecreasing(\op) \typearrow \True) \\
      %
      \Top & \textbf{else}
    \end{cases}
  }
}{
  \constraintbinoppair(\op, \overname{\AbbrevConstraintExact{\veone}}{\vcone}, \overname{\AbbrevConstraintRange{\vetwoone}{\vetwotwo}}{\vctwo}) \typearrow \vres
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact]{
  \vres \eqdef
  {
    \begin{cases}
      % 4
      \AbbrevConstraintRange{\AbbrevEBinop{\op}{\veoneone}{\vetwo}}{\AbbrevEBinop{\op}{\veonetwo}{\vetwo}} & \textbf{if }
      (\isleftincreasing(\op) \typearrow \True)\\
      %
      \Top & \textbf{else}
    \end{cases}
  }
}{
  \constraintbinoppair(\op, \overname{\AbbrevConstraintRange{\veoneone}{\veonetwo}}{\vcone}, \overname{\AbbrevConstraintExact{\vetwo}}{\vctwo}) \typearrow \vres
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range]{
  \vres \eqdef
  {
    \begin{cases}
      % 5
      \AbbrevConstraintRange{\AbbrevEBinop{\op}{\veoneone}{\vetwoone}}{\AbbrevEBinop{\op}{\veonetwo}{\vetwotwo}} & \textbf{if }
      \left(\begin{array}{ll}
      \isleftincreasing(\op) \typearrow \True\ \land\\
      \isrightincreasing(\op) \typearrow \True\\
      \end{array}\right)\\
      % 6
      \AbbrevConstraintRange{\AbbrevEBinop{\op}{\veoneone}{\vetwotwo}}{\AbbrevEBinop{\op}{\veonetwo}{\vetwoone}} & \textbf{if }
      \left(\begin{array}{ll}
      \isleftincreasing(\op) \typearrow \True\ \land\\
      \isrightdecreasing(\op) \typearrow \True
      \end{array}\right)\\
      %
      \Top & \textbf{else}
    \end{cases}
  }
}{
  \constraintbinoppair(\op, \overname{\AbbrevConstraintRange{\veoneone}{\veonetwo}}{\vcone}, \overname{\AbbrevConstraintRange{\vetwoone}{\vetwotwo}}{\vctwo}) \typearrow \vres
}
\end{mathpar}

\subsection{TypingRule.IsRightIncreasing \label{sec:TypingRule.IsRightIncreasing}}
\hypertarget{def-isrightincreasing}{}
The function
\[
\isrightincreasing(\overname{\binop}{\op}) \aslto \overname{\Bool}{\vb} \cup \{\top\}
\]
tests whether the value of binary operation $\op$ increases along with its right-hand-side operand,
yielding the result in $\vb$.
Otherwise, the result is $\top$, which indicates that the answer is not always $\True$ or $\False$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following (\textsc{true}):
  \begin{itemize}
    \item $\op$ is one of $\MUL, \SHL, \SHR, \POW, \PLUS$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following (\textsc{false}):
  \begin{itemize}
    \item $\op$ is one of $\DIV, \DIVRM, \MOD, \MINUS$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following (\textsc{top}):
  \begin{itemize}
    \item $\op$ is $\RDIV$;
    \item define $\vb$ as $\top$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[true]{
  \op \in \{\MUL, \SHL, \SHR, \POW, \PLUS\}
}{
  \isrightincreasing(\op) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[false]{
  \op \in \{\DIV, \DIVRM, \MOD, \MINUS\}
}{
  \isrightincreasing(\op) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[top]{}{
  \isrightincreasing(\overname{\RDIV}{\op}) \typearrow \top
}
\end{mathpar}

\subsection{TypingRule.IsRightDecreasing \label{sec:TypingRule.IsRightDecreasing}}
\hypertarget{def-isrightdecreasing}{}
The function
\[
\isrightdecreasing(\overname{\binop}{\op}) \aslto \overname{\Bool}{\vb} \cup \{\top\}
\]
tests whether the value of binary operation $\op$ decreases along with its right-hand-side operand,
yielding the result in $\vb$.
Otherwise, the result is $\top$, which indicates that the answer is not always $\True$ or $\False$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following (\textsc{true}):
  \begin{itemize}
    \item $\op$ is $\MINUS$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following (\textsc{false}):
  \begin{itemize}
    \item $\op$ is one of $\DIV, \DIVRM, \MUL, \SHL, \SHR, \POW, \PLUS, \MOD$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following (\textsc{top}):
  \begin{itemize}
    \item $\op$ is one of $\AND ,\BAND ,\BEQ ,\BOR ,\XOR ,\EQOP ,\GT ,\GEQ ,\IMPL ,\LT ,\LEQ ,\NEQ ,\OR, \RDIV$;
    \item define $\vb$ as $\top$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[true]{}{
  \isrightdecreasing(\overname{\MINUS}{\op}) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[false]{
  \op \in \{\DIV, \DIVRM, \MUL, \SHL, \SHR, \POW, \PLUS, \MOD\}
}{
  \isrightdecreasing(\op) \typearrow \overname{\False}{\vb}
}
\and
\inferrule[top]{
  \op \in \{\AND ,\BAND ,\BEQ ,\BOR ,\XOR ,\EQOP ,\GT ,\GEQ ,\IMPL ,\LT ,\LEQ ,\NEQ ,\OR, \RDIV\}
}{
  \isrightdecreasing(\op) \typearrow \top
}
\end{mathpar}

\subsection{TypingRule.IsLeftIncreasing \label{sec:TypingRule.IsLeftIncreasing}}
\hypertarget{def-isleftincreasing}{}
The function
\[
\isleftincreasing(\overname{\binop}{\op}) \aslto \overname{\Bool}{\vb} \cup \{\top\}
\]
tests whether the value of binary operation $\op$ increases along with its left-hand-side operand,
yielding $\True$ or $\top$, which indicates that the answer is not always $\True$ or $\False$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following (\textsc{true}):
  \begin{itemize}
    \item $\op$ is one of $\MUL, \DIV, \DIVRM, \MOD, \SHL, \SHR, \POW, \PLUS, \MINUS$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following (\textsc{top}):
  \begin{itemize}
    \item $\op$ is one of $\AND ,\BAND ,\BEQ ,\BOR ,\XOR ,\EQOP ,\GT ,\GEQ ,\IMPL ,\LT ,\LEQ ,\NEQ ,\OR, \RDIV$;
    \item define $\vb$ as $\top$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[true]{
  \op \in \{\MUL, \DIV, \DIVRM, \MOD, \SHL, \SHR, \POW, \PLUS, \MINUS\}
}{
  \isleftincreasing(\op) \typearrow \overname{\True}{\vb}
}
\and
\inferrule[top]{
  \op \in \{\AND ,\BAND ,\BEQ ,\BOR ,\XOR ,\EQOP ,\GT ,\GEQ ,\IMPL ,\LT ,\LEQ ,\NEQ ,\OR, \RDIV\}
}{
  \isleftincreasing(\op) \typearrow \top
}
\end{mathpar}
