\chapter{Symbolic Domain Subset Testing\label{chap:SymbolicDomainSubsetTesting}}

Whether an assignment statement is well-typed depends on whether the dynamic domain of the
right hand side type is contained in the dynamic domain of the left hand side type,
for any given dynamic environment.

\begin{definition}[Domain Subset]
For any given types $\vt$ and $\vs$ and \staticenvironmentterm{} $\tenv$,
we say that $\vt$ is a \emph{domain subset} of $\vs$ in $\tenv$,
if the following condition holds:
\hypertarget{def-domainsubset}{}
\begin{equation}
\begin{array}{l}
\domainsubset(\tenv, \vt, \vs) \triangleq \\
\qquad \forall \denv\in\dynamicenvs.\
\dynamicdomain((\tenv, \denv), \vt) \subseteq \dynamicdomain((\tenv, \denv), \vs) \enspace.
\end{array}
\end{equation}
\end{definition}

For example, consider the assignment
\begin{center}
\texttt{var x : $\overname{\texttt{integer\{1,2,3\}}}{\vs}$ = ARBITRARY : $\overname{\texttt{integer\{1,2\}}}{\vt}$;}
\end{center}

It is well-typed, since the dynamic domain of \verb|integer{1,2,3}| is\\
$\{\nvint(1), \nvint(2), \nvint(3)\}$ in every dynamic environment, which is a superset of
the dynamic domain of \verb|integer{1,2}|, which is $\{\nvint(1), \nvint(2)\}$ in every dynamic environment.

Since dynamic domains are potentially infinite, this requires \emph{symbolic reasoning}.
Furthermore, since any (\symbolicallyevaluableterm{}) expressions may appear inside integer and bitvector
types, domain subset testing is undecidable.
We therefore approximate domain subset testing \emph{conservatively} via the predicate $\symdomsubsettest(\tenv, \vt, \vs)$.

\hypertarget{def-symdomsubsettest}{}
\begin{definition}[Sound Domain Subset Test]
A predicate
\[
  \symdomsubsettest(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs}) \aslto \Bool
\]
is \emph{sound} if the following condition holds:
\begin{equation}
  \begin{array}{l}
  \forall \vt,\vs\in\ty.\ \tenv\in\staticenvs. \\
  \;\;\;\; \symdomsubsettest(\tenv, \vt, \vs) \typearrow \True \;\Longrightarrow\; \domainsubset(\tenv, \vt, \vs)  \enspace.
  \end{array}
\end{equation}
\end{definition}

That is, if a sound domain subset test returns a positive answer, it means that
$\vt$ is definitely a domain subset of $\vs$ in the \staticenvironmentterm{} $\tenv$.
This is referred to as a \emph{true positive}.
However, a negative answer means one of two things:
\begin{description}
  \item[True Negative:] indeed, $\vt$ is not a domain subset of $\vs$ in the \staticenvironmentterm{} $\tenv$; or
  \item[False Negative:] the symbolic reasoning is unable to decide.
\end{description}

In other words, $\symdomsubsettest(\tenv, \vt, \vs)$ errs on the \emph{safe side} ---
it never answers $\True$ when the real answer is $\False$, which would (undesirably)
determine the following statement as well-typed:
\begin{center}
\texttt{var x : $\overname{\texttt{integer\{1,2\}}}{\vs}$ = ARBITRARY : $\overname{\texttt{integer}}{\vt}$;}
\end{center}

A sound but trivial domain subset test is one that always returns $\False$.
However, that would make all assignments be considered as not well-typed.
Indeed, it has the maximal set of false negatives.
Reducing the set of false negatives requires stronger symbolic reasoning algorithms,
which inevitably leads to higher computational complexity.
%
The symbolic domain subset test in \chapref{SymbolicDomainSubsetTesting}
attempts to accept a large enough set of true positives, based on empirical trial and error,
while maintaining the computational complexity of the symbolic reasoning relatively low.
%
In particular, it serves as the definitive domain subset test that must be utilized
by any implementation of the ASL type system.

This chapter is concerned with implementing a \hyperlink{def-symdomsubsettest}{sound domain subset test}
for \integertypesterm{} and \bitvectortypesterm, as defined above and as employed by \\
\TypingRuleRef{SubtypeSatisfaction}.
This is technically achieved by first transforming types (in the case of \integertypesterm{})
and width expressions (in the case of \bitvectortypesterm{}) into symbolic representations
that we refer to as \emph{symbolic domains} and then checking subsumption over the symbolic domains.

\ChapterOutline
\begin{itemize}
  \item \secref{Symbolic Domains} defines a symbolic representation for sets of integers; and
  \item \secref{Symbolic Reasoning} defines the symbolic reasoning used for domain subset
        testing.
\end{itemize}

\section{Symbolic Domains\label{sec:Symbolic Domains}}
\hypertarget{def-symbolicdomain}{}

We define the \emph{symbolic domain} datatype, reusing $\intconstraint$ from the untyped AST,
as follows:

\RenderTypes{symbolic_domains}
\BackupOriginalType{
\[
  \begin{array}{rcl}
  \symdom       &\derives & \Finite(\powfin{\Z} \setminus \emptyset) \\
                &|        & \ConstrainedDom(\intconstraint) \\
  \symdomortop  &\derives & \Top\\
                &|        & \Subdomains(\symdom^+)
  \end{array}
\]
}

\begin{itemize}
  \item We refer to an element of the form $\Finite(S)$ as a \emph{symbolic finite set integer domain},
        which represents the (non-empty) set of integers $S$;
  \item We refer to an element of the form $\ConstrainedDom(\vc)$ as a \emph{symbolic constrained integer domain},
        which represents the set of integers given by the constraint $\vcs$; and
  \item We refer to an element of the form $\Top$ as a \emph{symbolic unconstrained integer domain},
        which represents the set of all integers.
\end{itemize}

\section{Symbolic Reasoning\label{sec:Symbolic Reasoning}}

The main rule in this section is \TypingRuleRef{SymdomSubsetUnions}, which defines the function
$\symdomsubsetunions$.

Other helper rules are as follows:
\begin{itemize}
  \item \TypingRuleRef{SymdomNormalize}
  \item \TypingRuleRef{SymdomOfType}
  \item \TypingRuleRef{SymdomOfWidthExpr}
  \item \TypingRuleRef{SymdomOfConstraint}
  \item \TypingRuleRef{SymdomEval}
  \item \TypingRuleRef{SymdomSubset}
  \item \TypingRuleRef{ApproxConstraints}
  \item \TypingRuleRef{ApproxConstraint}
  \item \TypingRuleRef{ApproxExprMin}
  \item \TypingRuleRef{ApproxExprMax}
  \item \TypingRuleRef{ApproxBottomTop}
  \item \TypingRuleRef{IntsetToConstraints}
  \item \TypingRuleRef{ApproxExpr}
  \item \TypingRuleRef{ApproxType}
  \item \TypingRuleRef{ConstraintBinop}
  \item \TypingRuleRef{ApplyBinopExtremities}
  \item \TypingRuleRef{PossibleExtremitiesLeft}
  \item \TypingRuleRef{PossibleExtremitiesRight}
  \item \TypingRuleRef{ConstraintPow}
  \item \TypingRuleRef{ConstraintMod}
\end{itemize}

\TypingRuleDef{SymdomSubsetUnions}
\RenderRelation{symdom_subset_unions}
\BackupOriginalRelation{
The function
\[
\symdomsubsetunions(
  \overname{\staticenvs}{\tenv},
  \overname{\symdomortop}{\sdone},
  \overname{\symdomortop}{\sdtwo}) \aslto \overname{\Bool}{\vb}
\]
conservatively tests whether the set of integers represented by $\sdone$
is a subset of the set of integers represented by $\sdtwo$,
in the context of the \staticenvironmentterm{} $\tenv$,
yielding the result in $\vb$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Conservatively Testing Subsumption Between Two Lists of Symbolic Domains}
In \listingref{SymdomOfConstraint}, typechecking the assignment \verb|x=y;|
is performed by testing whether each member of
\[
\Subdomains\left(\left[
  \begin{array}{l}
    \Finite(\{2,3,4\}),\\
    \ConstrainedDom(\ConstraintRange(\ELInt{5}, \AbbrevEVar{\vN})),\\
    \ConstrainedDom(\ConstraintExact(\AbbrevEBinop{\ADD}{\AbbrevEVar{\vN}}{\AbbrevEVar{\vN}}))\\
  \end{array}
\right]\right)
\]
is subsumed (that is, represents a subset as defined by $\symdomsubset$) by a member of
\[
\Subdomains\left(\left[
  \begin{array}{l}
    \Finite(\{1,2,3,4,5,6, 9\}),\\
    \ConstrainedDom(\ConstraintRange(\ELInt{5}, \AbbrevEVar{\vN})),\\
    \ConstrainedDom(\ConstraintExact(\AbbrevEBinop{\MUL}{\AbbrevEVar{\vN}}{\ELInt{2}}))\\
  \end{array}
\right]\right) \enspace.
\]
In this example, this is true as the following hold:
\begin{itemize}
  \item $\Finite(\{2,3,4\})$ is subsumed by $\Finite(\{1,2,3,4,5,6, 9\})$,
  \item $\ConstrainedDom(\ConstraintRange(\ELInt{5}, \AbbrevEVar{\vN}))$ (as a constraint for \verb|x|)
        is subsumed by the same element (as a constraint for \verb|y|), and
  \item $\ConstrainedDom(\ConstraintExact(\AbbrevEBinop{\ADD}{\AbbrevEVar{\vN}}{\AbbrevEVar{\vN}}))$
        is subsumed by \\
        $\ConstrainedDom(\ConstraintExact(\AbbrevEBinop{\MUL}{\AbbrevEVar{\vN}}{\ELInt{2}}))$.
\end{itemize}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{right\_top}
  \begin{itemize}
    \item $\sdtwo$ is $\Top$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item \AllApplyCase{left\_top\_right\_not\_top}
  \begin{itemize}
    \item $\sdone$ is $\Top$;
    \item $\sdtwo$ is not $\Top$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item \AllApply
  \begin{itemize}
    \item $\symdomsone$ is a list of symbolic domains $\symdomsone$;
    \item $\symdomstwo$ is a list of symbolic domains $\symdomstwo$;
    \item applying $\symdomnormalize$ to $\symdomsone$ yields $\symdomsonenorm$;
    \item applying $\symdomnormalize$ to $\symdomstwo$ yields $\symdomstwonorm$;
    \item \Proseeqdef{$\vb$}{$\True$ if and only if for every symbolic domain $\vsone$
          in $\symdomsonenorm$ there exists a symbolic domain $\vstwo$ in
          $\symdomstwonorm$ such that \\
          $\symdomsubset$ holds for $\vsone$ and $\vstwo$ in $\tenv$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[right\_top]{}{
  \symdomsubsetunions(\tenv, \sdone, \overname{\Top}{\sdtwo}) \typearrow
  \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[left\_top\_right\_not\_top]{
  \sdone \neq \Top
}{
  \symdomsubsetunions(\tenv, \overname{\Top}{\sdone}, \sdtwo) \typearrow
  \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \symdomnormalize(\symdomsone) \typearrow \symdomsonenorm\\
  \symdomnormalize(\symdomstwo) \typearrow \symdomstwonorm\\
  {
  \begin{array}{rcl}
  \vb &\eqdef& \forall \vsone\in\symdomsonenorm.\ \exists \vstwo\in\symdomstwonorm.\\
      &      & \symdomsubset(\tenv, \vsone, \vstwo)
  \end{array}
  }
}{
  \symdomsubsetunions(\tenv, \overname{\Subdomains(\symdomsone)}{\sdone}, \overname{\Subdomains(\symdomstwo)}{\sdtwo}) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{SymdomNormalize}
\RenderRelation{symdom_normalize}
\BackupOriginalRelation{
The function
\[
\symdomnormalize(\overname{\KleenePlus{\symdom}}{\symdoms}) \aslto \overname{\KleenePlus{\symdom}}{\newsymdoms}
\]
transforms the list of symbolic domain $\symdoms$ into an equivalent list of symbolic domains $\newsymdoms$
(in the sense that they both represent the same set of integers)
where all symbolic finite set integer domains are merged into a single symbolic finite set integer domain
whose set of integers is the union of the sets of integers in the merged symbolic finite set integer domains.
} % END_OF_BACKUP_RELATION

\ExampleDef{Normalizing Symbolic Domains}
In \listingref{SymdomOfConstraint}, normalizing the \symbolicdomainterm{} for the type\\
\verb|integer{1..6, 5..N, 9, N*2}| (see \ExampleRef{The Symbolic Domain of a Type})
merges $\Finite(\{1,2,3,4,5,6\})$ and $\Finite(\{9\})$, yielding the \symbolicdomainterm{}
\[
\Subdomains\left(\left[
  \begin{array}{l}
    \Finite(\{1,2,3,4,5,6, 9\}),\\
    \ConstrainedDom(\ConstraintRange(\ELInt{5}, \AbbrevEVar{\vN})),\\
    \ConstrainedDom(\ConstraintExact(\AbbrevEBinop{\MUL}{\AbbrevEVar{\vN}}{\ELInt{2}}))\\
  \end{array}
\right]\right) \enspace.
\]

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\others$}{the sublist of $\symdoms$ consisting of symbolic domains other than
        symbolic finite set integer domains};
  \item \Proseeqdef{$\vfinitedomains$}{the sublist of $\symdoms$ consisting of symbolic finite set integer domains};
  \item \Proseeqdef{$\vxs$}{the union of sets in each symbolic finite set integer domain of \\
        $\vfinitedomains$};
  \item \Proseeqdef{$\newsymdoms$}{
        the list with \head{} $\Finite(\vxs)$ and \tail{} $\others$, if $\vxs$ is non-empty, and
        $\others$, otherwise}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \others = [\vs \in \symdoms \;|\; \configdomain{\vs} \neq \Finite]\\
  \vfinitedomains = [\vs \in \symdoms \;|\; \configdomain{\vs} = \Finite]\\
  \vxs \eqdef \bigcup_{\Finite(\vs) \in \vfinitedomains} \vs\\\\
  \newsymdoms \eqdef \choice{\vxs \neq \emptyset}{[\Finite(\vxs)] \concat \others}{\others}
}{
  \symdomnormalize(\symdoms) \typearrow \newsymdoms \newsymdoms
}
\end{mathpar}

\TypingRuleDef{SymdomOfType}
\RenderRelation{symdom_of_type}
\BackupOriginalRelation{
The function
\[
  \symdomoftype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto \overname{\symdomortop}{\vd}
\]
transforms a type $\vt$ in a \staticenvironmentterm{} $\tenv$ into a symbolic domain $\vd$.
It assumes its input type has an \underlyingtypeterm{} which is an integer.
} % END_OF_BACKUP_RELATION

\ExampleDef{The Symbolic Domain of a Type}
In \listingref{SymdomOfConstraint}, the \symbolicdomainterm{} for the type
\verb|integer{1..6, 5..N, 9, N*2}|
is
\[
\Subdomains\left(\left[
  \begin{array}{l}
    \Finite(\{1,2,3,4,5,6\}),\\
    \ConstrainedDom(\ConstraintRange(\ELInt{5}, \AbbrevEVar{\vN})),\\
    \Finite(\{9\}),\\
    \ConstrainedDom(\ConstraintExact(\AbbrevEBinop{\MUL}{\AbbrevEVar{\vN}}{\ELInt{2}}))\\
  \end{array}
\right]\right) \enspace.
\]

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{int\_unconstrained}
  \begin{itemize}
    \item $\vt$ is the unconstrained integer type;
    \item \Proseeqdef{$\vd$}{$\Top$, which intuitively represents the entire set of integers}.
  \end{itemize}

  \item \AllApplyCase{int\_parameterized}
  \begin{itemize}
    \item $\vt$ is the \parameterizedintegertypeterm\ for the identifier $\id$;
    \item define $\vd$ as the singleton list consisting of the
          symbolic constrained integer domain with a single constraint for the variable expression for $\id$,
          that is, \\ $\ConstrainedDom(\ConstraintExact(\EVar(\id)))$.
  \end{itemize}

  \item \AllApplyCase{int\_well\_constrained}
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\symdomofconstraint$ to $\tenv$ and $\vc_\vi$, for every \Proselistrange{$\vi$}{$\vcs$},
          yields $\vd_\vi$;
    \item \Proseeqdef{$\vd$}{the list symbolic integer domains consisting of $\vd_\vi$, for every \Proselistrange{$\vi$}{$\vcs$}}.
  \end{itemize}

  \item \AllApplyCase{t\_named}
  \begin{itemize}
    \item $\vt$ is the named type for identifier $\id$;
    \item applying $\makeanonymous$ to $\vt$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ in $\tenv$ yields $\vd$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[int\_unconstrained]{}{ \symdomoftype(\tenv, \overname{\unconstrainedinteger}{\vt}) \typearrow
 \overname{\Top}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[int\_parameterized]{}{
  \symdomoftype(\tenv, \overname{\TInt(\Parameterized(\id))}{\vt}) \typearrow \\
  \overname{\Subdomains([\ConstrainedDom(\ConstraintExact(\EVar(\id)))])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained]{
  \vi\in\listrange(\vcs): \symdomofconstraint(\tenv, \vcs[\vi]) \typearrow \vd_\vi\\
  \vc \eqdef \vi\in\listrange(\vcs) \vd_\vi
}{
  \symdomoftype(\tenv, \overname{\TInt(\WellConstrained(\vcs))}{\vt}) \typearrow \overname{\Subdomains(\vis)}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_named]{
  \vt = \TNamed(\id)\\
  \makeanonymous(\vt) \typearrow \vtone\\
  \symdomoftype(\tenv, \vtone) \typearrow \vd
}{
  \symdomoftype(\tenv, \vt) \typearrow \vd
}
\end{mathpar}

\TypingRuleDef{SymdomOfWidthExpr}
\RenderRelation{symdom_of_width_expr}
\BackupOriginalRelation{
The function
\[
\symdomofwidthexpr(
  \overname{\expr}{\ve}
) \aslto
\overname{\symdomortop}{\vd}
\]
assigns a symbolic domain $\vd$ to an \underline{integer typed} expression $\ve$,
where $\ve$ is assumed to be the expression conveying the width of a \bitvectortypeterm.
} % END_OF_BACKUP_RELATION

\ExampleDef{The Symbolic Domain of a Bitwidth Expression}
The symbolic domain of the bitwidth expression \verb|2 * x|
is:
\[
\Subdomains([\AbbrevConstraintExact{\AbbrevEBinop{*}{\ELInt{2}}{\AbbrevEVar{\vx}}}]) \enspace.
\]
\ASLListing{The symbolic domain of a bitwidth expression}{SymdomOfWidthExpr}{\typingtests/TypingRule.SymdomOfWidthExpr.asl}

\ProseParagraph
\Proseeqdef{$\vd$}{the singleton list for the constrained symbolic integer domain
for the exact constraint for the expression $\ve$}.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \symdomofwidthexpr(\ve) \typearrow \overname{\Subdomains([\ \ConstrainedDom(\ConstraintExact(\ve))\ ])}{\vd}
}
\end{mathpar}

\TypingRuleDef{SymdomOfConstraint}
\RenderRelation{symdom_of_constraint}
\BackupOriginalRelation{
The function
\[
  \symdomofconstraint(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\intconstraint}{\vc}
  ) \aslto
  \overname{\symdom}{\vd}
\]
transforms an integer constraint $\vc$ into a symbolic domain $\vd$
in the context of the \staticenvironmentterm{} $\tenv$.
It produces $\Top$ when the expressions involved in the integer constraints cannot be simplified
to integers.
} % END_OF_BACKUP_RELATION

\ExampleDef{The Symbolic Domain of a Constraint}
In \listingref{SymdomOfConstraint}, considering the type annotation for \verb|x|:
\begin{itemize}
  \item the \symbolicdomainterm{} for the constraint \verb|1..6| is $\Finite(\{1,2,3,4,5,6\})$
  \item the \symbolicdomainterm{} for the constraint \verb|9| is $\Finite(\{9\})$,
  \item the \symbolicdomainterm{} for the constraint \verb|N*2| is \\
        $\ConstrainedDom(\ConstraintExact(\AbbrevEBinop{\MUL}{\AbbrevEVar{\vN}}{\ELInt{2}}))$,
        since the premise \\
        $\symdomeval(\tenv, \AbbrevEBinop{\MUL}{\AbbrevEVar{\vN}}{\ELInt{2}})$ yields $\Top$,
  \item the \symbolicdomainterm{} for the constraint \verb|5..N| is \\
        $\ConstrainedDom(\ConstraintRange(\ELInt{5}, \AbbrevEVar{\vN}))$,
        since the premise \\
        $\symdomeval(\tenv, \AbbrevEVar{\vN})$ yields $\Top$.
\end{itemize}

\ASLListing{The symbolic domain of a constraint}{SymdomOfConstraint}{\typingtests/TypingRule.SymdomOfConstraint.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is a single expression constraint for $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\symdomeval$ to $\ve$ in $\tenv$ yields $\vv$;
    \item define $\vd$ as constrained symbolic integer domain for $\vc$
          ($\ConstrainedDom(\vc)$) if $\vv$ is $\Top$
          and otherwise as the finite symbolic integer domain for the singleton set for $\vv$ ($\Finite(\{n\})$).
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is a range constraint for $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\symdomeval$ to $\veone$ in $\tenv$ yields $\vvone$;
    \item applying $\symdomeval$ to $\vetwo$ in $\tenv$ yields $\vvtwo$;
    \item define $\vd$ as the constrained symbolic integer domain for $\vc$ if either $\vvone$ or $\vvtwo$
          are $\Top$ ($\ConstrainedDom(\vc)$) and otherwise the finite symbolic integer domain for the
          set integers that are both greater or equal to $\vvone$ and less than or equal to $\vvtwo$
          ($\Finite(\{ n \;|\; \vvone \leq n \leq \vvtwo\})$).
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \symdomeval(\tenv, \ve) \typearrow \vv\\
  \vd \eqdef \choice{\vv = \Top}{\ConstrainedDom(\vc)}{\Finite(\{\vv\})}
}{
  \symdomofconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \symdomeval(\tenv, \veone) \typearrow \vvone\\
  \symdomeval(\tenv, \vetwo) \typearrow \vvtwo\\
  \vd \eqdef \choice{\vvone = \Top \lor \vvtwo = \Top}{\ConstrainedDom(\vc)}{\Finite(\{ n \;|\; \vvone \leq n \leq \vvtwo\})}
}{
  \symdomofconstraint(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vd
}
\end{mathpar}

\TypingRuleDef{SymdomEval}
\RenderRelation{symdom_eval}
\BackupOriginalRelation{
The function
\[
\symdomeval(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\Z}{n} \cup \{\Top\}
\]
\symbolicallysimplifiesterm\ the \underline{integer-typed} expression $\ve$ and returns the resulting integer or $\Top$ if
the result of the simplification is not an integer.
} % END_OF_BACKUP_RELATION

We assume that $\ve$ has been annotated as it is part of the constraint for an integer type,
and therefore applying $\normalize$ to it does not yield a \typingerrorterm{}.

\ExampleDef{Evaluating Expressions to Construct Symbolic Domains}
In \listingref{SymdomOfConstraint}, considering the constraints in the type annotation for
\verb|x|,
we have that both
$\symdomeval(\tenv, \AbbrevEBinop{\MUL}{\AbbrevEVar{\vN}}{\ELInt{2}})$
and $\symdomeval(\tenv, \AbbrevEVar{\vN})$ yield $\Top$,
since \verb|N| is a parameter.
On the other hand, $\symdomeval(\tenv, \ELInt{1})$ and $\symdomeval(\tenv, \ELInt{6})$,
yield $1$ and $6$, respectively.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{integer}
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the integer literal for $n$.
  \end{itemize}

  \item \AllApplyCase{top}
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields $\top$.
    \item the result is $\Top$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[integer]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \LInt(n)
}{
  \symdomeval(\tenv, \ve) \typearrow n
}
\and
\inferrule[top]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \top
}{
  \symdomeval(\tenv, \ve) \typearrow \Top
}
\end{mathpar}

\TypingRuleDef{SymdomSubset}
\RenderRelation{symdom_subset}
\BackupOriginalRelation{
The function
\[
  \symdomsubset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\symdom}{\cdone} \aslsep
    \overname{\symdom}{\cdtwo}
  ) \aslto
  \overname{\Bool}{\vb}
\]
conservatively tests whether the values represented by the \symbolicdomainterm\ $\cdone$
is a subset of the values represented by the \symbolicdomainterm\ $\cdtwo$ in any environment
consisting of the \staticenvironmentterm{} $\tenv$, yielding the result in $\vb$.
} % END_OF_BACKUP_RELATION
The test first \emph{overapproximates} $\visone$ by a set of integers $\vsone$.
That is, $\vsone$ represents a superset of the set of numbers represented by $\visone$.
Notice that this can always be done as $\N$ overapproximates any set of integers.
%
Second, the test \emph{underapproximates} $\vistwo$ by a set of integers $\vstwo$.
That is, $\vstwo$ represents a superset of the set of numbers represented by $\visone$.
Notice that this can always be done as the empty set underapproximates any set of integers.
%
The test concludes by checking whether $\vsone$ is a subset of $\vstwo$,
which if true implies that the set of numbers represented by $\visone$ is a subset of the
set of numbers represented by $\vstwo$ (in any environment).
A negative answer on the other hand means that the
test is unable to conclude subsumption.

\ExampleDef{Conservatively Testing Whether One Symbolic Domain is a Subset of Another}
In \listingref{SymdomOfWidthExpr}, typechecking the assignment \verb|x=y;|
involves test whether the \symbolicdomainterm{} for \verb|2..4| is a subset of the
\symbolicdomainterm{} for \verb|1..6|, which $\True$.
Similarly for testing whether the \symbolicdomainterm{} for \verb|N+N|
is a subset of the \symbolicdomainterm{} for \verb|N*2| also yields $\True$.
In contrast, testing whether the \symbolicdomainterm{} for \verb|5..N|
is a subset of the \symbolicdomainterm{} for \verb|N*2| yields $\False$.

\hypertarget{def-approximationdirectionterm}{}
\hypertarget{constant-CannotOverapproximate}{}
\hypertarget{constant-CannotUnderapproximate}{}
In the following rules, we use the symbol \RenderConstant{Over} to stand for \emph{overapproximation},
the symbol \RenderConstant{Under} to stand for \emph{underapproximation},
both defined by the following type: \RenderType{approximation_direction}
We refer such a symbol as an \approximationdirectionterm.
We also use the symbol \RenderConstant[remove_hypertargets]{CannotOverapproximate} to mean that a construct
(like an expression or a constraint) cannot be precisely overapproximated,
and \RenderConstant[remove_hypertargets]{CannotUnderapproximate} to mean that a construct cannot be precisely
underapproximated.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{finite\_finite}
  \begin{itemize}
    \item $\cdone$ is a finite set of integers for $\vsone$, that is, $\Finite(\vsone)$;
    \item $\vstwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item define $\vb$ as $\True$ if and only if $\vsone$ is a subset of $\vstwo$.
  \end{itemize}

  \item \AllApplyCase{constrained\_constrained\_equal}
  \begin{itemize}
    \item $\cdone$ is a symbolic constrained integer domain for the constraint $\vcone$, that is, $\ConstrainedDom(\vcone)$;
    \item $\cdtwo$ is a symbolic constrained integer domain for the constraint $\vctwo$, that is, $\ConstrainedDom(\vctwo)$;
    \item applying $\constraintequal$ to $\tenv$, $\vcone$, and $\vctwo$ yields $\True$;
    \item \Proseeqdef{$\vb$}{$\True$}.
  \end{itemize}

  \item \AllApplyCase{constrained\_constrained\_non\_equal\_sets}
  \begin{itemize}
    \item $\cdone$ is a symbolic constrained integer domain for the constraint $\vcone$, that is, $\ConstrainedDom(\vcone)$;
    \item $\cdtwo$ is a symbolic constrained integer domain for the constraint $\vctwo$, that is, $\ConstrainedDom(\vctwo)$;
    \item applying $\constraintequal$ to $\tenv$, $\vcone$, and $\vctwo$ yields $\False$;
    \item \Proseapproxconstraint{$\tenv$}{$\vcone$}{$\Over$}{$\vsone$};
    \item \Proseapproxconstraint{$\tenv$}{$\vctwo$}{$\Under$}{$\vstwo$};
    \item both $\vsone$ and $\vstwo$ are finite sets of integers;
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vsone$ is a subset of $\vstwo$}.
  \end{itemize}

  \item \AllApplyCase{constrained\_constrained\_non\_equal\_top}
  \begin{itemize}
    \item $\cdone$ is a symbolic constrained integer domain for the constraint $\vcone$, that is, $\ConstrainedDom(\vcone)$;
    \item $\cdtwo$ is a symbolic constrained integer domain for the constraint $\vctwo$, that is, $\ConstrainedDom(\vctwo)$;
    \item applying $\constraintequal$ to $\tenv$, $\vcone$, and $\vctwo$ yields $\False$;
    \item \Proseapproxconstraint{$\tenv$}{$\vcone$}{$\Over$}{$\vsone$};
    \item \Proseapproxconstraint{$\tenv$}{$\vctwo$}{$\Under$}{$\vstwo$};
    \item at least one of $\vsone$ and $\vstwo$ is $\CannotOverapproximate$;
    \item \Proseeqdef{$\vb$}{$\False$}.
  \end{itemize}

  \item \AllApplyCase{finite\_constrained}
  \begin{itemize}
    \item $\visone$ is a finite symbolic integer domain for the set of integers $\vsone$, that is, $\Finite(\vsone)$;
    \item $\cdtwo$ is a symbolic constrained integer domain for the constraint $\vctwo$, that is, $\ConstrainedDom(\vctwo)$;
    \item \ProseapproxconstraintsUnder{$\tenv$}{$\vctwo$}{$\vstwo$};
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vsone$ is a subset of $\vstwo$}.
  \end{itemize}

  \item \AllApplyCase{constrained\_finite\_set}
  \begin{itemize}
    \item $\cdone$ is a symbolic constrained integer domain for the constraint $\vcone$, that is, $\ConstrainedDom(\vcone)$;
    \item $\vistwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item \ProseapproxconstraintsOver{$\tenv$}{$\vcone$}{$\vsone$};
    \item $\vsone$ is not $\CannotOverapproximate$;
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vsone$ is a subset of $\vstwo$}.
  \end{itemize}

  \item \AllApplyCase{constrained\_finite\_top}
  \begin{itemize}
    \item $\cdone$ is a symbolic constrained integer domain for the constraint $\vcone$, that is, $\ConstrainedDom(\vcone)$;
    \item $\vistwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item \ProseapproxconstraintsOver{$\tenv$}{$\vcone$}{$\vsone$};
    \item $\vsone$ is $\CannotOverapproximate$;
    \item \Proseeqdef{$\vb$}{$\False$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[finite\_finite]{}{
  \symdomsubset(\tenv, \overname{\Finite(\vsone)}{\cdone}, \overname{\Finite(\vstwo)}{\cdtwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constrained\_constrained\_equal]{
  \constraintequal(\tenv, \vcone, \vctwo) \typearrow \True
}{
  \symdomsubset(\tenv, \overname{\ConstrainedDom(\vcone)}{\cdone}, \overname{\ConstrainedDom(\vctwo)}{\cdtwo}) \typearrow
  \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constrained\_constrained\_non\_equal\_sets]{
  \constraintequal(\tenv, \vcone, \vctwo) \typearrow \False\\\\
  \approxconstraint(\tenv, \Over, \vcone) \typearrow \vsone\\
  \approxconstraint(\tenv, \Under, \vctwo) \typearrow \vstwo\\
  \vsone \neq \CannotOverapproximate \land \vstwo \neq \CannotOverapproximate\\
}{
  \symdomsubset(\tenv, \overname{\ConstrainedDom(\vcone)}{\cdone}, \overname{\ConstrainedDom(\vctwo)}{\cdtwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constrained\_constrained\_non\_equal\_top]{
  \constraintequal(\tenv, \vcone, \vctwo) \typearrow \False\\\\
  \approxconstraint(\tenv, \Over, \vcone) \typearrow \vsone\\
  \approxconstraint(\tenv, \Under, \vctwo) \typearrow \vstwo\\
  \vsone = \CannotOverapproximate \lor \vstwo = \CannotOverapproximate\\
}{
  \symdomsubset(\tenv, \overname{\ConstrainedDom(\vcone)}{\cdone}, \overname{\ConstrainedDom(\vctwo)}{\cdtwo}) \typearrow
  \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_constrained]{
  \approxconstraints(\tenv, \Under, \vctwo) \typearrow \vstwo
}{
  \symdomsubset(\tenv, \overname{\Finite(\cdone)}{\vsone}, \overname{\ConstrainedDom(\vctwo)}{\cdtwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constrained\_finite\_set]{
  \approxconstraints(\tenv, \Over, \vcone) \typearrow \vsone\\
  \vsone \neq \CannotOverapproximate
}{
  \symdomsubset(\tenv, \overname{\ConstrainedDom(\vcone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[constrained\_finite\_top]{
  \approxconstraints(\tenv, \Over, \vcone) \typearrow \vsone\\
  \vsone = \CannotOverapproximate
}{
  \symdomsubset(\tenv, \overname{\ConstrainedDom(\vcone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow
  \overname{\False}{\vb}
}
\end{mathpar}

\TypingRuleDef{ApproxConstraints}
\RenderRelation{approx_constraints}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\approxconstraints(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\KleenePlus{\intconstraint}}{\cs}) \aslto\\
  \overname{\powfin{\Z}}{\vs} \cup \{\CannotOverapproximate\}
\end{array}
\]
conservatively approximates the non-empty list of constraints $\cs$ by a set of integers $\vs$.
The approximation is over all environments consisting of the \staticenvironmentterm{} $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Approximating Constraint Lists}
The specification in \listingref{ApproxConstraints} is well-typed,
showing how constraint lists are overapproximated.
\ASLListing{Approximating constraints Lists}{ApproxConstraints}{\typingtests/TypingRule.ApproxConstraints.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{over}
  \begin{itemize}
    \item $\vapprox$ is $\Over$;
    \item \Proseapproxconstraint{$\tenv$}{$\vc$}{$\Over$}{$\vs_\vc$}, for every constraint $\vc$ in $\cs$\ProseTerminateAs{\CannotOverapproximate};
    \item \Proseeqdef{$\vs$}{the union of all sets $\vs_\vc$, for every constraint $\vc$ in $\cs$}.
  \end{itemize}

  \item \AllApplyCase{under}
  \begin{itemize}
    \item $\vapprox$ is $\Under$;
    \item \Proseapproxconstraint{$\tenv$}{$\vc$}{$\Under$}{$\vs_\vc$}, for every constraint $\vc$ in $\cs$\ProseTerminateAs{\CannotOverapproximate};
    \item \Proseeqdef{$\vs$}{the intersection of all sets $\vs_\vc$, for every constraint $\vc$ in $\cs$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[over]{
  \vc \in \cs: \approxconstraint(\tenv, \Over, \vc) \typearrow \vs_\vc \terminateas \CannotOverapproximate
}{
  \approxconstraints(\tenv, \overname{\Over}{\vapprox}, \cs) \typearrow
  \overname{\bigcup_{\vc \in \cs} \vs_\vc}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[under]{
  \vc \in \cs: \approxconstraint(\tenv, \vapprox, \vc) \typearrow \vs_\vc \terminateas \CannotOverapproximate
}{
  \approxconstraints(\tenv, \overname{\Under}{\vapprox}, \cs) \typearrow
  \overname{\bigcap_{\vc \in \cs} \vs_\vc}{\vs}
}
\end{mathpar}
\CodeSubsection{\ApproxConstraintsBinopBegin}{\ApproxConstraintsBinopEnd}{../Typing.ml}

\TypingRuleDef{ApproxConstraint}
\RenderRelation{approx_constraint}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\approxconstraint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\intconstraint}{\vc}) \aslto\\
  \overname{\pow{\Z}}{\vs} \cup \{\CannotOverapproximate\}
\end{array}
\]
conservatively approximates the constraint $\vc$ by a set of integers $\vs$.
The approximation is over all environments that consist of the \staticenvironmentterm{} $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.
If $\vc$ cannot be overapproximated, the result is $\CannotOverapproximate$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Approximating Constraints}
The specification in \listingref{ApproxConstraint} is well-typed,
showing how constraints are overapproximated and underapproximated.
\ASLListing{Approximating constraints}{ApproxConstraint}{\typingtests/TypingRule.ApproxConstraint.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an \Proseexactconstraint{\ve};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\ve$}{$\vs$}\ProseTerminateAs{\CannotOverapproximate}.
  \end{itemize}

  \item \AllApplyCase{range\_over1}
  \begin{itemize}
    \item $\vc$ is a \Proserangeconstraint{\veone}{\vetwo};
    \item \Proseapproxexprmin{$\tenv$}{$\veone$}{$\vzone$};
    \item \Proseapproxexprmax{$\tenv$}{$\vetwo$}{$\vztwo$};
    \item both $\vzone$ and $\vztwo$ are different to $\CannotOverapproximate$;
    \item applying $\makeinterval$ to $\Over$, $\vzone$, and $\vztwo$ yields $\vsinterval$;
    \item \Proseeqdef{$\vs$}{$\vsinterval$ if $\vsinterval$ is different to $\CannotOverapproximate$ and
          the result of applying $\approxbottomtop$ to $\Over$, otherwise}.
  \end{itemize}

    \item \AllApplyCase{range\_over2}
  \begin{itemize}
    \item $\vc$ is a \Proserangeconstraint{\veone}{\vetwo};
    \item \Proseapproxexprmin{$\tenv$}{$\veone$}{$\vzone$};
    \item \Proseapproxexprmax{$\tenv$}{$\vetwo$}{$\vztwo$};
    \item either $\vzone$ or $\vztwo$ are $\CannotOverapproximate$;
    \item \Proseeqdef{$\vs$}{the result of applying $\approxbottomtop$ to $\Over$}.
  \end{itemize}

  \item \AllApplyCase{range\_under1}
  \begin{itemize}
    \item $\vc$ is a \Proserangeconstraint{\veone}{\vetwo};
    \item \Proseapproxexprmax{$\tenv$}{$\veone$}{$\vzone$};
    \item \Proseapproxexprmin{$\tenv$}{$\vetwo$}{$\vztwo$};
    \item both $\vzone$ and $\vztwo$ are different to $\CannotOverapproximate$;
    \item applying $\makeinterval$ to $\Under$, $\vzone$, and $\vztwo$ yields $\vsinterval$;
    \item \Proseeqdef{$\vs$}{$\vsinterval$ if $\vsinterval$ is different to $\CannotOverapproximate$ and
          the result of applying $\approxbottomtop$ to $\Under$, otherwise}.
  \end{itemize}

    \item \AllApplyCase{range\_under2}
  \begin{itemize}
    \item $\vc$ is a \Proserangeconstraint{\veone}{\vetwo};
    \item \Proseapproxexprmax{$\tenv$}{$\veone$}{$\vzone$};
    \item \Proseapproxexprmin{$\tenv$}{$\vetwo$}{$\vztwo$};
    \item either $\vzone$ or $\vztwo$ are $\CannotOverapproximate$;
    \item \Proseeqdef{$\vs$}{the result of applying $\approxbottomtop$ to $\Under$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \approxexpr(\tenv, \vapprox, \ve) \typearrow \vs \terminateas \CannotOverapproximate
}{
  \approxconstraint(\tenv, \vapprox, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vs
}
\end{mathpar}

% Transliteration note: I'm splitting the case of ranges based on 'approx' to avoid excessive
% use of conditionals in rules (i.e., choice functions).

\begin{mathpar}
\inferrule[range\_over1]{
  \approxexprmin(\tenv, \veone) \typearrow \vzone\\
  \approxexprmax(\tenv, \vetwo) \typearrow \vztwo\\
  \vzone \neq \CannotOverapproximate \land \vztwo \neq \CannotOverapproximate\\
  \makeinterval(\Over, \vzone, \vztwo) \typearrow \vsinterval \\
  {
  \vs \eqdef \ifthenelse{\vsinterval \neq \CannotOverapproximate}{\vsinterval}{\approxbottomtop(\Over)}
  }
}{
  \approxconstraint(\tenv, \overname{\Over}{\vapprox}, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_over2]{
  \approxexprmin(\tenv, \veone) \typearrow \vzone\\
  \approxexprmax(\tenv, \vetwo) \typearrow \vztwo\\
  \vzone = \CannotOverapproximate \lor \vztwo = \CannotOverapproximate\\
  \approxbottomtop(\Over) \typearrow \vsbottomtop\
}{
  \approxconstraint(\tenv, \overname{\Over}{\vapprox}, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\vsbottomtop}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_under1]{
  \approxexprmax(\tenv, \veone) \typearrow \vzone\\
  \approxexprmin(\tenv, \vetwo) \typearrow \vztwo\\
  \vzone \neq \CannotOverapproximate \land \vztwo \neq \CannotOverapproximate\\
  \makeinterval(\Over, \vzone, \vztwo) \typearrow \vsinterval \\
  {
  \vs \eqdef \ifthenelse{\vsinterval \neq \CannotOverapproximate}{\vsinterval}{\approxbottomtop(\Under)}
  }
}{
  \approxconstraint(\tenv, \overname{\Under}{\vapprox}, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_under2]{
  \approxexprmax(\tenv, \veone) \typearrow \vzone\\
  \approxexprmin(\tenv, \vetwo) \typearrow \vztwo\\
  \vzone = \CannotOverapproximate \lor \vztwo = \CannotOverapproximate\\
  \approxbottomtop(\Under) \typearrow \vsbottomtop\
}{
  \approxconstraint(\tenv, \overname{\Under}{\vapprox}, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\vsbottomtop}{\vs}
}
\end{mathpar}

\TypingRuleDef{MakeInterval}
\RenderRelation{make_interval}
\BackupOriginalRelation{
The function
\[
\makeinterval(
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\Z}{\vzone} \aslsep
  \overname{\Z}{\vztwo}) \aslto \overname{\powfin{\Z} \cup \{ \emptyset, \CannotOverapproximate \}}{\vs}
\]
returns the interval between the integers $\vzone$ and $\vztwo$,
or an approximation based on $\vapprox$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Approximating Intervals}
The following are examples of over- and under-approximating intervals:
\[
\begin{array}{rcl}
\makeinterval(\Over, 1, 3) &\typearrow& \{1, 2, 3\}\\
\makeinterval(\Under, 1, 3) &\typearrow& \{1, 2, 3\}\\
\makeinterval(\Over, 4, 3) &\typearrow& \CannotOverapproximate\\
\makeinterval(\Under, 4, 3) &\typearrow& \CannotUnderapproximate\\
\end{array}
\]

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{interval}
  \begin{itemize}
    \item $\vzone$ is less than or equal to $\vztwo$;
    \item \Proseeqdef{$\vs$}{the integers between $\vzone$ and $\vztwo$, inclusive}.
  \end{itemize}

  \item \AllApplyCase{approx}
  \begin{itemize}
    \item $\vzone$ is greater than $\vztwo$;
    \item \Proseeqdef{$\vs$}{the result of applying $\approxbottomtop$ to $\vapprox$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[interval]{
  \vzone \leq \vztwo
}{
  \makeinterval(\vapprox, \vzone, \vztwo) \typearrow  \overname{\{ \vz \;|\; \vzone \leq \vz \leq \vztwo \}}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[approx]{
  \vzone > \vztwo
}{
  \makeinterval(\vapprox, \vzone, \vztwo) \typearrow  \overname{\approxbottomtop(\vapprox)}{\vs}
}
\end{mathpar}

\TypingRuleDef{ApproxExprMin}
\RenderRelation{approx_expr_min}
\BackupOriginalRelation{
The function
\[
\approxexprmin(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\Z}{\vz} \cup \{\CannotOverapproximate\}
\]
approximates the minimal integer represented by the expression $\ve$
in any environment consisting of the \staticenvironmentterm{}
$\tenv$. The result, yielded in $\vz$ is either an integer or $\CannotOverapproximate$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Approximating the Minimal Value of an Expression}
In \listingref{ApproxExprMin}, approximating the minimal value of
\verb|A DIV 2| for typing the declaration of \verb|y|
yields $\CannotOverapproximate$, since \verb|A| is a parameter with no constraints.
Approximating the minimal value of \verb|a| for the declaration of \verb|b|
yields $12$.
\ASLListing{Approximating the minimal value of an expression}{ApproxExprMin}{\typingtests/TypingRule.ApproxExprMin.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseapproxexpr{$\tenv$}{$\Over$}{$\ve$}{$\vs$}\ProseTerminateAs{\CannotOverapproximate};
  \item \Proseeqdef{$\vz$}{the minimal integer in $\vs$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \approxexpr(\tenv, \Over, \ve) \typearrow \vs \terminateas{\CannotOverapproximate}
}{
  \approxexprmin(\tenv, \ve) \typearrow \overname{\min(\vs)}{\vz}
}
\end{mathpar}

\TypingRuleDef{ApproxExprMax}
\RenderRelation{approx_expr_max}
\BackupOriginalRelation{
The function
\[
\approxexprmax(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\Z}{\vz} \cup \{\CannotOverapproximate\}
\]
approximates the maximal integer represented by the expression $\ve$
in any environment consisting of the \staticenvironmentterm{}
$\tenv$. The result, yielded in $\vz$ is either an integer or $\CannotOverapproximate$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Approximating the Maximal Value of an Expression}
In \listingref{ApproxExprMax}, approximating the maximal value of
\verb|2*N| for typing the declaration of \verb|b|
yields $\CannotOverapproximate$, since \verb|N| is a parameter with no constraints.
Approximating the maximal value of \verb|2*a| for the declaration of \verb|b|
yields $10$.
\ASLListing{Approximating the maximal value of an expression}{ApproxExprMax}{\typingtests/TypingRule.ApproxExprMax.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseapproxexpr{$\tenv$}{$\Over$}{$\ve$}{$\vs$}\ProseTerminateAs{\CannotOverapproximate};
  \item \Proseeqdef{$\vz$}{the maximal integer in $\vs$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \approxexpr(\tenv, \Over, \ve) \typearrow \vs \terminateas{\CannotOverapproximate}
}{
  \approxexprmax(\tenv, \ve) \typearrow \overname{\max(\vs)}{\vz}
}
\end{mathpar}

\TypingRuleDef{ApproxBottomTop}
\RenderRelation{approx_bottom_top}
\BackupOriginalRelation{
The function
\[
\approxbottomtop(\overname{\{\Under, \Over\}}{\vapprox}) \aslto
  \overname{\pow{\Z}}{\vs} \cup \{\CannotOverapproximate\}
\]
returns in $\vs$ either the empty set or the set of all integers,
depending on the \approximationdirectionterm\ $\vapprox$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Approximation Extremes}
In \listingref{ApproxBottomTop}, approximating the constraint \verb|a..b|
with $\Over$ yields \\
$\CannotOverapproximate$.
\ASLListing{Approximation extremes}{ApproxBottomTop}{\typingtests/TypingRule.ApproxBottomTop.asl}

\ProseParagraph
\ProseEqdef{$\vs$}{the empty set if $\vapprox$ is $\Under$ and
$\CannotOverapproximate$ if $\vapprox$ is $\Over$.}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \approxbottomtop(\vapprox) \typearrow \overname{\choice{\vapprox = \Under}{\emptyset}{\CannotOverapproximate}}{\vs}
}
\end{mathpar}

\TypingRuleDef{IntsetToConstraints}
\RenderRelation{intset_to_constraints}
\BackupOriginalRelation{
The function
\[
\intsettoconstraints(\overname{\powfin{\Z}}{\vs}) \aslto \overname{\KleeneStar{\intconstraint}}{\cs}
\]
converts a finite set of integers $\vs$ into an equivalent list of constraints.
} % END_OF_BACKUP_RELATION

\ExampleDef{Transforming Integer Sets to Constraint Lists}
The specification in \listingref{IntsetToConstraints} is well-typed,
showing how an instance of integer sets transformed to constraint lists.
\ASLListing{Transforming Integer Sets to Constraint Lists}{IntsetToConstraints}{\typingtests/TypingRule.IntsetToConstraints.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\intervals$}{the set of maximal intervals in $\vs$};
  \item \Proseeqdef{$\cs$}{the list of constraints where for each interval $a..b$ in $\intervals$,
        there is an exact constraint for $a$ if $a$ is equal to $b$ and a range constraint \\
        $\AbbrevConstraintRange{\ELInt{a}}{\ELInt{b}}$, otherwise}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \intervals \eqdef \{ a..b \;|\; a..b \in \vs \land \forall (c..d) \in \vs.\ a..b \not\subseteq c..d\}\\
  \cs \eqdef [a..b \in \intervals: \choice{a=b}{
    \AbbrevConstraintExact{\ELInt{a}}}{\AbbrevConstraintRange{\ELInt{a}}{\ELInt{b}}}]
}{
  \intsettoconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\TypingRuleDef{ApproxExpr}
\RenderRelation{approx_expr}
\BackupOriginalRelation{
The function
\[
\approxexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\expr}{\ve}) \aslto
  \overname{\pow{\Z}}{\vs} \cup \{\CannotOverapproximate\}
\]
conservatively approximates the expression $\ve$ by a set of integers $\vs$
in the \staticenvironmentterm{} $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Approximating Expressions}
The specification in \listingref{ApproxExpr} is well-typed,
showing how expressions are overapproximated and underapproximated
for the \subtypesatisfiesterm{} check between \verb|bits(M)| and \verb|bits(N)|,
needed to annotate the expression \verb|x as bits(N)|.
\ASLListing{Approximating expressions}{ApproxExpr}{\typingtests/TypingRule.ApproxExpr.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{literal\_int}
  \begin{itemize}
    \item $\ve$ is a literal expression for the integer $\vz$;
    \item \Proseeqdef{$\vs$}{the singleton set for $\vz$}.
  \end{itemize}

  \item \AllApplyCase{literal\_non\_int}
  \begin{itemize}
    \item $\ve$ is a literal expression for a non-integer value;
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vs$\ProseTerminateAs{\CannotOverapproximate}.
  \end{itemize}

  \item \AllApplyCase{var\_over}
  \begin{itemize}
    \item $\ve$ is a \variableexpression{$\vx$};
    \item $\vapprox$ is $\Over$;
    \item \Prosetypeof{$\tenv$}{$\vx$}{\\ $\vt$}\ProseTerminateAs{\CannotOverapproximate};
    \item \Proseapproxtype{$\tenv$}{$\Over$}{$\vt$}{$\vs$}.
  \end{itemize}

  \item \AllApplyCase{var\_under}
  \begin{itemize}
    \item $\ve$ is a \variableexpression{$\vx$};
    \item $\vapprox$ is $\Under$;
    \item \Proseeqdef{$\vs$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{unop}
  \begin{itemize}
    \item $\ve$ is a \unopexpression{$\op$}{$\vep$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vep$}{$\vsp$}\ProseTerminateAs{\CannotOverapproximate};
    \item \Proseeqdef{$\vs$}{the set obtained by applying $\unopliterals$ to $\op$ and
      the integer literal for every integer in $\vsp$}.
  \end{itemize}

  \item \AllApplyCase{binop\_precise}
  \begin{itemize}
    \item $\ve$ is a \binopexpression{$\op$}{$\veone$}{$\vetwo$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\veone$}{$\vsone$}\ProseTerminateAs{\CannotOverapproximate};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vetwo$}{$\vstwo$}\ProseTerminateAs{\CannotOverapproximate};
    \item applying $\annotateconstraintbinop$ to $\vapprox$, $\tenv$, $\vsone$, and $\vstwo$ yields \\
          $(\vsp, \plf)$;
    \item either $\plf$ is $\PrecisionFull$ or $\plf$ is $\PrecisionLost$ and $\vapprox$ is $\Under$;
    \item applying $\approxconstraints$ to $\tenv$, $\vapprox$, and $\vsp$ yields \\
          $\vsapprox$\ProseTerminateAs{\CannotOverapproximate};
    \item \Proseeqdef{$\vs$}{$\vsapprox$}.
  \end{itemize}

  \item \AllApplyCase{binop\_approx}
  \begin{itemize}
    \item $\ve$ is a \binopexpression{$\op$}{$\veone$}{$\vetwo$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\veone$}{$\vsone$}\ProseTerminateAs{\CannotOverapproximate};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vetwo$}{$\vstwo$}\ProseTerminateAs{\CannotOverapproximate};
    \item applying $\annotateconstraintbinop$ to $\vapprox$, $\tenv$, $\vsone$, and $\vstwo$ yields $(\vsp, \plf)$;
    \item $\plf$ is $\PrecisionLost$ and $\vapprox$ is $\Over$;
    \item \Proseeqdef{$\vs$}{$\CannotOverapproximate$}.
  \end{itemize}

  \item \AllApplyCase{cond}
  \begin{itemize}
    \item $\ve$ is a \condexpression{any}{$\vetwo$}{$\vethree$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vetwo$}{$\vstwo$}\ProseTerminateAs{\CannotOverapproximate};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vethree$}{$\vsthree$}\ProseTerminateAs{\CannotOverapproximate};
    \item \Proseeqdef{$\vs$}{the union of $\vstwo$ and $\vsthree$ if $\vapprox$ is $\Over$
    and the intersection of $\vstwo$ and $\vsthree$ if $\vapprox$ is $\Under$}.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\ve$ is an expression that is neither of the following types of expressions:
          \literalexpressionterm, \variableexpressionterm, \unopexpressionterm, \binopexpressionterm,
          or a \condexpressionterm;
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[literal\_int]{}{
  \approxexpr(\tenv, \vapprox, \overname{\ELInt{\vz}}{\ve}) \typearrow \overname{\{\vz\}}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[literal\_non\_int]{
  \astlabel(\vl) \neq \LInt\\
  \approxbottomtop(\vapprox) \typearrow \vs \terminateas \CannotOverapproximate
}{
  \approxexpr(\tenv, \vapprox, \overname{\ELiteral(\vl)}{\ve}) \typearrow \vs
}
\end{mathpar}

In the following inference rule, the application of $\typeof$ is guaranteed not
to result in a \typingerrorterm{}, since $\symdomsubset$ is only applied to annotated
types.
\begin{mathpar}
\inferrule[var\_over]{
  \typeof(\tenv, \vx) \typearrow \vt\\
  \approxtype(\tenv, \Over, \vt) \typearrow \vs \terminateas \CannotOverapproximate
}{
  \approxexpr(\tenv, \overname{\Over}{\vapprox}, \overname{\EVar(\vx)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[var\_under]{}{
  \approxexpr(\tenv, \overname{\Under}{\vapprox}, \overname{\EVar(\vx)}{\ve}) \typearrow \overname{\emptyset}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unop]{
  \approxexpr(\tenv, \vapprox, \vep) \typearrow \vsp \terminateas \CannotOverapproximate\\\\
  \vs \eqdef \{ \unopliterals(\op, \LInt(\vz)) \;|\; \vz \in \vsp\}
}{
  \approxexpr(\tenv, \vapprox, \overname{\EUnop(\op, \vep)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[binop\_precise]{
  \approxexpr(\tenv, \vapprox, \veone) \typearrow \vsone \terminateas \CannotOverapproximate\\\\
  \approxexpr(\tenv, \vapprox, \vetwo) \typearrow \vstwo \terminateas \CannotOverapproximate\\\\
  \approxconstraintbinop(\tenv, \vapprox, \op, \vsone, \vstwo) \typearrow (\vsp, \plf)\\
  \plf = \PrecisionFull \lor (\plf = \PrecisionLost \land \vapprox = \Under)\\
  \approxconstraints(\tenv, \vapprox, \vsp) \typearrow \vsapprox \terminateas \CannotOverapproximate
}{
  \approxexpr(\tenv, \vapprox, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \overname{\vsapprox}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[binop\_approx]{
  \approxexpr(\tenv, \vapprox, \veone) \typearrow \vsone \terminateas \CannotOverapproximate\\\\
  \approxexpr(\tenv, \vapprox, \vetwo) \typearrow \vstwo \terminateas \CannotOverapproximate\\\\
  \approxconstraintbinop(\tenv, \vapprox, \op, \vsone, \vstwo) \typearrow (\vsp, \plf)\\
  \plf = \PrecisionLost \land \vapprox = \Over
}{
  \approxexpr(\tenv, \vapprox, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \CannotOverapproximate
}
\end{mathpar}

\begin{mathpar}
\inferrule[cond]{
  \approxexpr(\tenv, \vapprox, \vetwo) \typearrow \vstwo \terminateas \CannotOverapproximate\\\\
  \approxexpr(\tenv, \vapprox, \vethree) \typearrow \vsthree \terminateas \CannotOverapproximate\\\\
  \vs \eqdef \choice{\vapprox = \Over}{\vstwo \cup \vsthree}{\vstwo \cap \vsthree}
}{
  \approxexpr(\tenv, \vapprox, \overname{\ECond(\Ignore, \vetwo, \vethree)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \not\in \{\ELiteral, \EVar, \EUnop, \EBinop, \ECond\}
}{
  \approxexpr(\tenv, \vapprox, \ve) \typearrow \overname{\approxbottomtop(\vapprox)}{\vs}
}
\end{mathpar}

\TypingRuleDef{ApproxConstraintBinop}
\RenderRelation{approx_constraint_binop}
\BackupOriginalRelation{
The function
\[
\begin{array}{r}
\approxconstraintbinop\left(
  \begin{array}{c}
  \overname{\staticenvs}{\tenv} \aslsep\\
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep\\
  \overname{\binop}{\op} \aslsep\\
  \overname{\KleenePlus{\intconstraint}}{\vsone} \aslsep\\
  \overname{\KleenePlus{\intconstraint}}{\vstwo}
  \end{array}
\right)
\aslto \left(
  \begin{array}{c}
  \overname{\KleenePlus{\intconstraint}}{\vs} \aslsep\\
  \overname{\precisionlossindicator}{\plf}
  \end{array}
  \right)
\end{array}
\]
approximates the application of the binary operator $\op$ to lists of constraints $\vsone$
and $\vstwo$ with the \approximationdirectionterm{} $\vapprox$ in the context of the static
environment $\tenv$, resulting in the list of constraints $\vs$ and \precisionlossindicator{}
$\plf$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Approximating Binary Expressions Over Constraint Lists}
The specification in \listingref{ApproxConstraintBinop} is well-typed.
Typechecking the specification involves checking that the type of
the expression \verb|(x :: x)| \subtypesatisfiesterm{} \verb|bits(2 * N)|.
This in turn requires:
\begin{itemize}
\item overapproximating \verb|2*N| by applying $\approxconstraintbinop$
      to $\Over$, $\MUL$, and the constraint lists $[2]$, and $[4,8]$,
      which yields $([8, 16], \PrecisionFull)$.

\item underapproximating \verb|N|, which yields the empty set,
      and then applying \\
      $\approxconstraintbinop$
      to $\Under$, $\MUL$, and the constraint lists $[2]$, and $\emptylist$,
      which yields $(\emptylist, \PrecisionFull)$.
\end{itemize}
Since this static subtype satisfaction test fails, the test is deferred to
the dynamic semantics.

\ASLListing{Approximating binary expressions over constraint lists}{ApproxConstraintBinop}{\typingtests/TypingRule.ApproxConstraintBinop.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{over}
  \begin{itemize}
    \item $\vapprox$ is $\Over$;
    \item applying $\annotateconstraintbinop$ to $\Over$, $\tenv$, $\op$, $\vsone$, and $\vstwo$
          yields \\
          $(\vs, \plf)$\ProseTerminateAs{\CannotOverapproximate}.
  \end{itemize}

  \item \AllApplyCase{under\_precise}
  \begin{itemize}
    \item $\vapprox$ is $\Under$;
    \item applying $\annotateconstraintbinop$ to $\Under$, $\tenv$, $\op$, $\vsone$, and $\vstwo$
          yields $(\vs, \plf)$\ProseTerminateAs{\CannotOverapproximate}.
  \end{itemize}

  \item \AllApplyCase{under\_approx}
  \begin{itemize}
    \item $\vapprox$ is $\Under$;
    \item applying $\annotateconstraintbinop$ to $\Under$, $\tenv$, $\op$, $\vsone$, and $\vstwo$
          yields $\CannotUnderapproximate$;
    \item \Proseeqdef{$\vs$}{the empty list} and \Proseeqdef{$\plf$}{$\PrecisionLost$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[over]{
  {
  \begin{array}{r}
  \annotateconstraintbinop(\Over, \tenv, \op, \vsone, \vstwo) \typearrow \\
  (\vs, \plf) \terminateas \CannotOverapproximate
  \end{array}
  }
}{
  \approxconstraintbinop(\tenv, \overname{\Over}{\vapprox}, \op, \vsone, \vstwo) \typearrow (\vs, \plf)
}
\end{mathpar}

\begin{mathpar}
\inferrule[under\_precise]{
    \annotateconstraintbinop(\Under, \tenv, \op, \vsone, \vstwo) \typearrow (\vs, \plf)
}{
  \approxconstraintbinop(\tenv, \overname{\Under}{\vapprox}, \op, \vsone, \vstwo) \typearrow (\vs, \plf)
}
\end{mathpar}

\begin{mathpar}
\inferrule[under\_approx]{
    \annotateconstraintbinop(\Under, \tenv, \op, \vsone, \vstwo) \typearrow \CannotUnderapproximate
}{
  \approxconstraintbinop(\tenv, \overname{\Under}{\vapprox}, \op, \vsone, \vstwo) \typearrow
  (\overname{\emptylist}{\vs}, \overname{\PrecisionLost}{\plf})
}
\end{mathpar}

\TypingRuleDef{ApproxType}
\RenderRelation{approx_type}
\BackupOriginalRelation{
The function
\[
\approxtype(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\ty}{\vt}) \aslto
\overname{\pow{\Z}}{\vs} \cup \{\CannotOverapproximate\}
\]
conservatively approximates the type $\vt$ by a set of integers $\vs$
in the \staticenvironmentterm{} $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Approximating Types}
The specification in \listingref{ApproxExpr} is well-typed.
In order to test whether \verb|bits(M)| --- the type of \verb|x| --- \subtypesatisfiesterm{}
\verb|bits(N)|, the typechecker overapproximates \verb|M|.
This involves overapproximating the type of \verb|M|, which is \verb|integer{4,8}|.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{named}
  \begin{itemize}
    \item $\vt$ is a \namedtype;
    \item \Prosemakeanonymous{$\tenv$}{$\vt$}{$\vtp$};
    \item \Proseapproxtype{$\tenv$}{$\vapprox$}{$\vtp$}{\\ $\vs$}\ProseTerminateAs{\CannotOverapproximate}.
  \end{itemize}

  \item \AllApplyCase{int\_wellconstrained}
  \begin{itemize}
    \item $\vt$ is a \wellconstrainedintegertypeterm\ with the list of integer constraints $\cs$;
    \item \Proseapproxconstraints{$\tenv$}{$\vapprox$}{$\cs$}{\\ $\vs$}\ProseTerminateAs{\CannotOverapproximate}.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\vt$ is neither a \namedtypeterm\ nor a \wellconstrainedintegertypeterm;
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[named]{
  \isnamed(\vt)\\
  \makeanonymous(\tenv, \vt) \typearrow \vtp\\
  \approxtype(\tenv, \vapprox, \vtp) \typearrow \vs \terminateas \CannotOverapproximate
}{
  \approxtype(\tenv, \vapprox, \vt) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_wellconstrained]{
  \vt = \TInt(\WellConstrained(\cs))\\
  \approxconstraints(\tenv, \vapprox, \cs) \typearrow \vs \terminateas \CannotOverapproximate
}{
  \approxtype(\tenv, \vapprox, \vt) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \neg\isnamed(\vt) \land \neg\iswellconstrainedinteger(\vt)\\
  \approxbottomtop(\vapprox) \typearrow \vs
}{
  \approxtype(\tenv, \vapprox, \vt) \typearrow \vs
}
\end{mathpar}

\TypingRuleDef{ConstraintBinop}
\RenderRelation{constraint_binop}
\BackupOriginalRelation{
The function
\[
\constraintbinop(
  \overname{\binop}{\op} \aslsep
  \overname{\KleeneStar{\intconstraint}}{\csone} \aslsep
  \overname{\KleeneStar{\intconstraint}}{\cstwo}
)
\aslto \overname{\constraintkind}{\newcs}
\]
symbolically applies the binary operation $\op$ to the lists of integer constraints $\csone$ and $\cstwo$,
yielding the integer constraints $\newcs$.
} % END_OF_BACKUP_RELATION

For examples of the generated constraints
for the modulus operation see \ExampleRef{Generating Modulus Constraints},
for examples of the generated constraints for exponentiation,
see \ExampleRef{Generating Exponentiation Constraints},
and for examples of the generated constraints for all other operations
see \ExampleRef{Generating Constraints for Binary Operations}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{extremities}
  \begin{itemize}
    \item $\op$ is either $\DIV$, $\DIVRM$, $\MUL$, $\ADD$, $\SUB$, $\SHR$, or $\SHL$;
    \item applying $\applybinopextremities$ to every pair of constraints \\
          $\csone[\vi]$ and $\cstwo[\vj]$ where $\vi\in\listrange(\csone)$ and
          $\vj\in\listrange(\cstwo)$, yields $\vc_{\vi,\vj}$;
    \item define $\newcs$ as the list of constraints $\vc_{\vi,\vj}$, for every
          $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$.
  \end{itemize}

  \item \AllApplyCase{mod}
  \begin{itemize}
    \item $\op$ is $\MOD$;
    \item applying $\constraintmod$ to $\cstwo[\vj]$, for every $\vj\in\listrange(\cstwo)$, yields $\vc_\vj$;
    \item define $\newcs$ as $\vc_\vj$, for every $\vj\in\listrange(\cstwo)$.
  \end{itemize}

  \item \AllApplyCase{pow}
  \begin{itemize}
    \item $\op$ is $\POW$;
    \item applying $\constraintpow$ to every pair of constraints $\csone[\vi]$ and $\cstwo[\vj]$
          where $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$, yields $\vc_{\vi,\vj}$;
    \item define $\newcs$ as the list of constraints $\vc_{\vi,\vj}$, for every
          $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[extremities]{
  \op \in \{\DIV, \DIVRM, \MUL, \ADD, \SUB, \SHR, \SHL\}\\
  {
    \begin{array}{r}
      \vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \\
      \applybinopextremities(\csone[\vi], \cstwo[\vj]) \typearrow \vc_{\vi,\vj}
    \end{array}
  }\\
  \newcs \eqdef [\vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \vc_{\vi,\vj}]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[mod]{
  \op = \MOD\\
  \vj\in\listrange(\cstwo): \constraintmod(\cstwo[\vj]) \typearrow \vc_\vj\\
  \newcs = [\vj\in\listrange(\cstwo): \vc_\vj]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[pow]{
  \op = \POW\\
  {
    \begin{array}{r}
      \vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \\
      \constraintpow(\csone[\vi], \cstwo[\vj]) \typearrow \vc_{\vi,\vj}
    \end{array}
  }\\
  \newcs \eqdef [\vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \vc_{\vi,\vj}]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}
\CodeSubsection{\ConstraintBinopBegin}{\ConstraintBinopEnd}{../Typing.ml}

\TypingRuleDef{ApplyBinopExtremities}
\RenderRelation{apply_binop_extremities}
\BackupOriginalRelation{
The function
\[
\applybinopextremities(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vctwo}
) \aslto \overname{\KleeneStar{\intconstraint}}{\newcs}
\]
yields a list of constraints $\newcs$ for the constraints $\vcone$ and $\vctwo$, which are needed to include
range constraints for cases where the binary operation $\op$ yields a \dynamicerrorterm{}.
} % END_OF_BACKUP_RELATION

\ExampleDef{Generating Constraints for Binary Operations}
See \ExampleRef{Generating Range-to-Exact Constraints} and
\ExampleRef{Generating Exact-to-Range Constraints} for examples of generating constraints
when one of the constraints is an \exactconstraintterm{} and the other is a \rangeconstraintterm.

The specification in \listingref{ApplyBinopExtremities} shows examples of the constraints
generated (as type annotations on the left-hand-side of local storage declarations)
for cases where a binary operation involves two \rangeconstraintsterm.
\ASLListing{Generating constraints for binary operations}{ApplyBinopExtremities}{\typingtests/TypingRule.ApplyBinopExtremities.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact\_exact}
  \begin{itemize}
    \item $\vcone$ is a constraint for the expression $\va$;
    \item $\vctwo$ is a constraint for the expression $\vc$;
    \item define $\newcs$ as the list containing the constraint for the \binopexpressionterm{} $\AbbrevEBinop{\op}{\va}{\vc}$.
  \end{itemize}

  \item \AllApplyCase{range\_exact}
  \begin{itemize}
    \item $\vcone$ is a range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is a constraint for the expression $\vc$;
    \item applying $\possibleextremitiesleft$ to $\op$, $\va$, and $\vb$ yields $\extpairs$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vc}}{\AbbrevEBinop{\op}{\vbp}{\vc}}$
          for each pair of expressions $(\vap, \vbp)$ in $\extpairs$.
  \end{itemize}

  \item \AllApplyCase{exact\_range}
  \begin{itemize}
    \item $\vcone$ is a constraint for the expression $\va$;
    \item $\vctwo$ is a range constraint for the expressions $\vc$ and $\vd$;
    \item applying $\possibleextremitiesright$ to $\op$, $\vc$, and $\vd$ yields $\extpairs$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\va}{\vcp}}{\AbbrevEBinop{\op}{\va}{\vdp}}$
          for each pair of expressions $(\vcp, \vdp)$ in $\extpairs$.
  \end{itemize}

  \item \AllApplyCase{range\_range}
  \begin{itemize}
    \item $\vcone$ is a range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is a range constraint for the expressions $\vc$ and $\vd$;
    \item applying $\possibleextremitiesleft$ to $\op$, $\va$, and $\vb$ yields $\extpairsab$;
    \item applying $\possibleextremitiesright$ to $\op$, $\vc$, and $\vd$ yields $\extpairscd$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vcp}}{\AbbrevEBinop{\op}{\vbp}{\vdp}}$
          for each pair of expressions
          $(\vap, \vbp)$ in $\extpairsab$
          and each pair of expressions
          $(\vcp, \vdp)$ in $\extpairscd$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact\_exact]{}{
  {
    \begin{array}{r}
  \applybinopextremities(\op, \overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[ \ConstraintExact(\AbbrevEBinop{\op}{\va}{\vc}) ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact]{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \extpairs\\
  \newcs \eqdef [(\vap, \vbp) \in \extpairs: \AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vc}}{\AbbrevEBinop{\op}{\vbp}{\vc}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range]{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \extpairs\\
  \newcs \eqdef [(\vcp, \vdp) \in \extpairs: \AbbrevConstraintRange{\AbbrevEBinop{\op}{\va}{\vcp}}{\AbbrevEBinop{\op}{\va}{\vdp}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintRange(\vc, \vd)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range]{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \extpairsab\\
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \extpairscd\\
  \newcs \eqdef [(\vap, \vbp) \in \extpairsab, (\vcp, \vdp) \in \extpairscd:
  \AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vcp}}{\AbbrevEBinop{\op}{\vbp}{\vdp}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintRange(\vc, \vd)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\TypingRuleDef{PossibleExtremitiesLeft}
\RenderRelation{possible_extremities_left}
\BackupOriginalRelation{
The function
\[
\possibleextremitiesleft(
  \overname{\binop}{\op} \aslsep
  \overname{\expr}{\va} \aslsep \overname{\expr}{\vb}
) \aslto \overname{\KleeneStar{(\expr\times\expr)}}{\extpairs}
\]
yields a list of pairs of expressions $\extpairs$ given the binary operation $\op$
and pair of expressions $\va$ and $\vb$, which are needed to form constraints
for cases where applying $\op$ to $\va$ and $\vb$ would lead to a \dynamicerrorterm{}.
} % END_OF_BACKUP_RELATION

\ExampleDef{Generating Range-to-Exact Constraints}
The specification in \listingref{PossibleExtremitiesLeft}
shows the constraints inferred for various binary operations
(in the type annotations of the corresponding left-hand-side declarations)
where the type of \verb|x| contains a \rangeconstraintterm{} and the type of \verb|c|
contains an \exactconstraintterm.
\ASLListing{Generating range-to-exact constraints}{PossibleExtremitiesLeft}{\typingtests/TypingRule.PossibleExtremitiesLeft.asl}

\ProseParagraph
\begin{itemize}
  \item \AllApplyCase{mul}
  \begin{itemize}
    \item $\op$ is $\MUL$;
    \item define $\extpairs$ as the list consisting of $(\va, \va)$, $(\va, \vb)$, $(\vb, \va)$, and $(\vb, \vb)$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\op$ is either $\DIV$, $\DIVRM$, $\SHR$, $\SHL$, $\ADD$, or $\SUB$;
    \item define $\extpairs$ as the list consisting of $(\va, \vb)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[mul]{}{
  \possibleextremitiesleft(\overname{\MUL}{\op}, \va, \vb) \typearrow \overname{[(\va, \va), (\va, \vb), (\vb, \va), (\vb, \vb)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \op \in \{\DIV, \DIVRM, \SHR, \SHL, \ADD, \SUB\}
}{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \overname{[(\va, \vb)]}{\extpairs}
}
\end{mathpar}

\TypingRuleDef{PossibleExtremitiesRight}
\RenderRelation{possible_extremities_right}
\BackupOriginalRelation{
The function
\[
\possibleextremitiesright(
  \overname{\binop}{\op} \aslsep
  \overname{\expr}{\vc} \aslsep \overname{\expr}{\vd}
) \aslto \overname{\KleeneStar{(\expr\times\expr)}}{\extpairs}
\]
yields a list of pairs of expressions $\extpairs$ given the binary operation $\op$
and pair of expressions $\vc$ and $\vd$, which are needed to form constraints
for cases where applying $\op$ to $\vc$ and $\vd$ would lead to a \dynamicerrorterm{}.
} % END_OF_BACKUP_RELATION

\ExampleDef{Generating Exact-to-Range Constraints}
The specification in \listingref{PossibleExtremitiesRight}
shows the constraints inferred for various binary operations
(in the type annotations of the corresponding left-hand-side declarations)
where the type of \verb|a| contains an \exactconstraintterm{} and the type of \verb|y|
contains a \rangeconstraintterm{}.
\ASLListing{Generating exact-to-range constraints}{PossibleExtremitiesRight}{\typingtests/TypingRule.PossibleExtremitiesRight.asl}

\ProseParagraph
\begin{itemize}
  \item \AllApplyCase{plus}
  \begin{itemize}
    \item $\op$ is $\ADD$;
    \item define $\extpairs$ as the list consisting of $(\vc, \vd)$.
  \end{itemize}

  \item \AllApplyCase{minus}
  \begin{itemize}
    \item $\op$ is $\SUB$;
    \item define $\extpairs$ as the list consisting of $(\vd, \vc)$.
  \end{itemize}

  \item \AllApplyCase{mul}
  \begin{itemize}
    \item $\op$ is $\MUL$;
    \item define $\extpairs$ as the list consisting of $(\vc, \vc)$, $(\vc, \vd)$, $(\vd, \vc)$, and $(\vd, \vd)$.
  \end{itemize}

  \item \AllApplyCase{shl\_shr}
  \begin{itemize}
    \item $\op$ is either $\SHL$ or $\SHR$;
    \item define $\extpairs$ as the list consisting of $(\vd, \ELInt{0})$ and $(\ELInt{0}, \vd)$.
  \end{itemize}

  \item \AllApplyCase{div\_divrm}
  \begin{itemize}
    \item $\op$ is either $\DIV$ or $\DIVRM$;
    \item define $\extpairs$ as the list consisting of $(\vd, \ELInt{1})$ and $(\ELInt{1}, \vd)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[plus]{}{
  \possibleextremitiesright(\overname{\ADD}{\op}, \vc, \vd) \typearrow \overname{[(\vc, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[minus]{}{
  \possibleextremitiesright(\overname{\SUB}{\op}, \vc, \vd) \typearrow \overname{[(\vd, \vc)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul]{}{
  \possibleextremitiesright(\overname{\MUL}{\op}, \vc, \vd) \typearrow \overname{[(\vc, \vc), (\vc, \vd), (\vd, \vc), (\vd, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[shl\_shr]{
  \op \in \{\SHL, \SHR\}
}{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \overname{[(\vd, \ELInt{0}), (\ELInt{0}, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_divrm]{
  \op \in \{\DIV, \DIVRM\}
}{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \overname{[(\vd, \ELInt{1}), (\ELInt{1}, \vd)]}{\extpairs}
}
\end{mathpar}

\TypingRuleDef{ConstraintMod}
\RenderRelation{constraint_mod}
\BackupOriginalRelation{
The function
\[
\constraintmod(\overname{\intconstraint}{\vc}) \aslto \overname{\intconstraint}{\newc}
\]
yields a range constraint $\newc$ from $0$ to the expression in $\vc$ that is maximal.
This is needed to apply the modulus operation to a pair of constraints.
} % END_OF_BACKUP_RELATION

\ExampleDef{Generating Modulus Constraints}
The specification in \listingref{ConstraintMod}
shows the constraints inferred for the exponentiation expression \verb|x MOD y|
(in the type annotation for \verb|z|).
\ASLListing{Generating modulus constraints}{ConstraintMod}{\typingtests/TypingRule.ConstraintMod.asl}

\ExampleDef{Ill-typed Modulus Constraint Assignment}
In \listingref{typing-constraintmod}, the assignment to \texttt{z} is illegal, since the type
inferred for \texttt{z} is\\
\verb|integer{0..2}|.

\ASLListing{An ill-typed modulus constraint assignment}{typing-constraintmod}{\typingtests/TypingRule.ConstraintMod.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\veupper$}{
    $\ve$ if $\vc$ is a single constraint for $\ve$,
    and $\vb$ if $\vc$ is a range constraint for a pair of expressions, the second of which is $\vb$.
  };
  \item \Proseeqdef{$\veminusone$}{the binary expression subtracting $1$ from $\veupper$};
  \item \Proseeqdef{$\newc$}{a range constraint for the literal expression for $0$ for $\veminusone$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \veupper \eqdef \begin{cases}
      \ve & \vc = \ConstraintExact(\ve)\\
      \vb & \vc = \ConstraintRange(\Ignore, \vb)
    \end{cases}
  }\\
  \veminusone \eqdef \EBinop(\SUB, \veupper, \ELInt{1})
}{
  \constraintmod(\vc) \typearrow \overname{\ConstraintRange(\ELInt{0}, \veminusone)}{\newc}
}
\end{mathpar}
\CodeSubsection{\ConstraintModBegin}{\ConstraintModEnd}{../Typing.ml}

\TypingRuleDef{ConstraintPow}
\RenderRelation{constraint_pow}
\BackupOriginalRelation{
The function
\[
\constraintpow(\overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vctwo}) \aslto \overname{\KleenePlus{\intconstraint}}{\newcs}
\]
yields a list of range constraints $\newcs$ that are needed to calculate the result of
applying a $\POW$ operation to the constraints $\vcone$ and $\vctwo$.
} % END_OF_BACKUP_RELATION

\ExampleDef{Generating Exponentiation Constraints}
The specification in \listingref{ConstraintPow}
shows the constraints inferred for the exponentiation expression \verb|x^y|
(in the type annotation for \verb|z|).
\ASLListing{Generating exponentiation constraints}{ConstraintPow}{\typingtests/TypingRule.ConstraintPow.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact\_exact}
  \begin{itemize}
    \item $\vcone$ is the constraint for the expression $\va$;
    \item $\vcone$ is the constraint for the expression $\vc$;
    \item define $\newcs$ as the list containing the constraint
    for the expression \\ $\EBinop(\POW, \va, \vc)$.
  \end{itemize}

  \item \AllApplyCase{range\_exact}
  \begin{itemize}
    \item $\vcone$ is the range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is the constraint for the expression $\vc$;
    \item define $\vmac$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vc)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \vb, \vc)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmac)$ and $\vmac$;
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{exact\_range}
  \begin{itemize}
    \item $\vcone$ is the constraint for the expression $\va$;
    \item $\vctwo$ is the range constraint for the expressions $\Ignore$ and $\vd$;
    \item define $\vmad$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vd)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \va, \vd)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmad)$ and $\vmad$;
      \item the constraint for the literal integer expression for $1$.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{range\_range}
  \begin{itemize}
    \item $\vcone$ is the range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is the range constraint for the expressions $\Ignore$ and $\vd$;
    \item define $\vmad$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vd)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \vb, \vd)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmad)$ and $\vmad$;
      \item the constraint for the literal integer expression for $1$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact\_exact]{}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[\ \ConstraintExact(\EBinop(\POW, \va, \vc))\ ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact]{
  \vmac \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vc)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\vb}{\vc}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmac)}{\vmac}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range]{
  \vmad \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vd)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintRange(\Ignore, \vd)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\va}{\vd}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmad)}{\vmad},\
  \AbbrevConstraintExact{\ELInt{1}}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range]{
  \vmad \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vd)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintRange(\Ignore, \vd)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\vb}{\vd}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmad)}{\vmad},\
  \AbbrevConstraintExact{\ELInt{1}}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\ConstraintPowBegin}{\ConstraintPowEnd}{../Typing.ml}
