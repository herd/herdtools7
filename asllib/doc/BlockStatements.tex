\chapter{Block Statements\label{chap:BlockStatements}}
Block statements are statements executing in their own scope when they appear
in one of the following:
\begin{itemize}
  \item the body of a \whilestatementterm,
  \item the body of a \repeatstatementsterm,
  \item the body of a \forstatementterm,
  \item one of the branches of a \conditionalstatementterm,
  \item the body of a \trystatementterm, or
  \item the statement executed by an exception catcher.
\end{itemize}

\ExampleDef{Block Statements}
In \listingref{block},
the conditional statement \verb|if TRUE then ... end;| defines a
block structure. Thus, the scope of the declaration \texttt{let y = 2;} is
limited to its declaring block --- the binding for \texttt{y} no longer exists
once the block is exited. As a consequence, the subsequent declaration
\texttt{let y = 1} is valid.  By contrast, the assignment of the mutable
variable~\texttt{x} persists after block end. However, observe that \texttt{x}
is defined before the block and hence still exists after the block.
\ASLListing{A conditional statement defining a block structure}{block}{\semanticstests/SemanticsRule.Block.asl}

\ChapterOutline
\begin{itemize}
  \item \FormalRelationsRef{Block Statements} defines the formal relations for block statements;
  \item \TypeRulesRef{Block Statements} defines the type rule for block statements; and
  \item \SemanticsRulesRef{Block Statements} defines the semantics of block statements.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FormalRelationsDef{Block Statements}
\paragraph{Syntax:} Block statements are grammatically the same as other statements
derived from $\Nstmt$.

\paragraph{Abstract Syntax:} Block statements appear in the abstract syntax
as statements $\stmt$.

\paragraph{Typing:} Block statements are annotated by $\annotateblock$.

\paragraph{Semantics:} Block statements are evaluated by $\evalblock$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\TypeRulesDef{Block Statements}
\RenderRelation{annotate_block}

\TypingRuleDef{Block}
See \ExampleRef{Block Statements}.
\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the statement $\vs$ in $\tenv$ yields $(\newstmt, \newtenv, \vses)$\ProseOrTypeError;
  \item the modified environment $\newtenv$ is dropped.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatestmt(\tenv, \vs) \typearrow (\newstmt, \Ignore, \vses) \OrTypeError
}{
  \annotateblock(\tenv, \vs) \typearrow (\newstmt, \vses)
}
\end{mathpar}
\CodeSubsection{\BlockBegin}{\BlockEnd}{../Typing.ml}

\subsection{Comments}
A local identifier declared in a block statement (with \texttt{var}, \texttt{let}, or \texttt{constant})
is in scope from the point immediately after its declaration until the end of the
immediately enclosing block. This means, we can discard the environment at the end of
an enclosing block, which has the effect of dropping bindings of the identifiers declared inside the block.

\identr{JBXQ}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\SemanticsRulesDef{Block Statements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RenderRelation{eval_block}

\SemanticsRuleDef{Block}
See \ExampleRef{Block Statements}.

The $\poplocalscope$ function is used below to effectively discard the bindings for variables declared inside the block statement $\stm$.

\ProseParagraph
\AllApply
\begin{itemize}
    \item evaluating $\stm$ in $\env$, as per \chapref{Statements},
          is $\vres$\ProseOrDynErrorDiverging;
    \item \OneApplies
      \begin{itemize}
        \item \AllApplyCase{returning}
        \begin{itemize}
          \item $\vres$ is $\Returning((\vvs, \newg), \envret)$;
          \item \Proseeqdef{$\newenv$}{\Prosepoplocalscope{$\env$}{$\envret$}}.
          \item the result of the entire evaluation is $\Returning((\vvs, \newg), \newenv)$.
        \end{itemize}

        \item \AllApplyCase{continuing}
        \begin{itemize}
          \item $\vres$ is $\Continuing(\newg, \envcont)$;
          \item \Proseeqdef{$\newenv$}{\Prosepoplocalscope{$\env$}{$\envcont$}}.
          \item the result of the entire evaluation is $\Continuing(\newg, \newenv)$.
        \end{itemize}

        \item \AllApplyCase{throwing}
        \begin{itemize}
          \item $\vres$ is $\Throwing(\vv, \vt, \newg, \envthrow)$;
          \item \Proseeqdef{$\newenv$}{\Prosepoplocalscope{$\env$}{$\envthrow$}}.
          \item the result of the entire evaluation is $\Throwing(\vv, \vt, \newg, \newenv)$.
        \end{itemize}
      \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[returning]{
  \env \eqname (\tenv,\denv)\\
  \evalstmt(\env, \stm) \evalarrow \vres \OrDynErrorDiverging\\\\
  \commonprefixline \\\\
  \vres = \Returning((\vvs, \newg), \envret) \\
  \envret \eqname (\tenvone, \denvone) \\
  \newenv \eqdef (\tenv, \poplocalscope(\denv,\denvone))
}{
  \evalblock(\env, \stm) \evalarrow \Returning((\vvs, \newg), \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[continuing]{
  \env \eqname (\tenv,\denv)\\
  \evalstmt(\env, \stm) \evalarrow \vres \OrDynErrorDiverging\\\\
  \commonprefixline \\\\
  \vres = \Continuing(\newg, \envcont) \\
  \envcont \eqname (\tenvone, \denvone) \\
  \newenv \eqdef (\tenv, \poplocalscope(\denv,\denvone))
}{
  \evalblock(\env, \stm) \evalarrow \Continuing(\newg, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[throwing]{
  \env \eqname (\tenv,\denv)\\
  \evalstmt(\env, \stm) \evalarrow \vres \OrDynErrorDiverging\\\\
  \commonprefixline \\\\
  \vres = \Throwing(\vv,\vt,\newg, \envthrow) \\
  \envthrow \eqname (\tenvone, \denvone) \\
  \newenv \eqdef (\tenv, \poplocalscope(\denv,\denvone))
}{
  \evalblock(\env, \stm) \evalarrow \Throwing(\vv,\vt,\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalBlockBegin}{\EvalBlockEnd}{../Interpreter.ml}

That is, evaluating a block discards the bindings for variables declared inside $\stm$.

\SemanticsRuleDef{PopLocalScope}
\RenderRelation{pop_local_scope}

See \ExampleRef{Block Statements}.

\ProseParagraph
\ProseEqdef{$\newdenv$}{$\vinnerenv$ without the bindings to local storage elements that are not in $\vouterenv$}.

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  {
    \begin{array}{r}
  \poplocalscope(\vouterenv, \vinnerenv) \evalarrow\\
    \{ \dynamicenvsG:
      \vinnerenv.\dynamicenvsG,
        \dynamicenvsL:
      \restrictfunc{\vinnerenv.\dynamicenvsL}{{\dom(\vouterenv.\dynamicenvsL)}}
    \}
    \end{array}
  }
}
\end{mathpar}
