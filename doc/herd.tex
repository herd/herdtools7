\cutname{herd.html}

The tool \herd{} is a memory model simulator.
Users may write simple, single events,
axiomatic models of their own and run litmus tests on top
of their model.
The \herd{} distribution already includes some models.

The authors of~\herd{} are Jade Alglave and Luc Maranget.


\section{Writing simple models}
This section introduces \cat{}, our language for describing memory models.
The \cat{} language is a domain specific language for writing and executing
memory models. From the language perspective, \cat{} is loosely inspired
by OCaml. That is, it is a functional language, with similar syntax
and constructs.
The basic values of \cat{} are sets of events, which include memory events
but also additional events such as fence events,
and relations over events.


\subsection{Sequential consistency}
The simulator \herd{} accepts models written in text files.
For instance here is \afile{sc.cat},
the definition of the sequentially consistent (SC) model in the partial-order
style:
\verbatiminput{sc.cat}
The model above illustrates some features of model definitions:
\begin{enumerate}
\item A model file starts with a tag (here \verb+SC+), which can also be a
string (in double quotes) in case the tag includes special characters or spaces.
\item Pre-defined bindings. Here \verb+po+ (program order)
and \texttt{rf} (read from) are pre-defined.
The remaining two communication relations (\texttt{co} and~\texttt{fr})
are computed by the included file \verb+cos.cat+, which we describe later
--- See Sec.~\ref{sec:cos}.
For simplicity, we may as well assume that \verb+co+
and~\verb+fr+ are pre-defined.
\item The computation of new relations from other relations,
and their binding to a name with the \verb+let+ construct.
Here, a new relation \verb+com+ is the union ``\texttt{|}'' of
the three pre-defined communication relations.
\item The performance of some checks. Here the relation ``\verb+po | com+''
(\emph{i.e.} the union of program order \textrel{po} and of  communication
relations) is required to be acyclic.
Checks can be given names by suffixing them with
``\texttt{as~}\textit{name}''.
This last feature will be used in Sec.~\ref{name:check}
\end{enumerate}
%We postpone the discussion of the \verb+show+ instruction, see
%Sec.~\ref{sec:show}.

One can then run some litmus test, for instance \atest{SB}
(for \emph{Store Buffering},
see also Sec.~\ref{litmus:simple}), on top of the SC model:
\begin{verbatim}
% herd7 -model ./sc.cat SB.litmus
Test SB Allowed
States 3
0:EAX=0; 1:EAX=1;
0:EAX=1; 1:EAX=0;
0:EAX=1; 1:EAX=1;
No
Witnesses
Positive: 0 Negative: 3
Condition exists (0:EAX=0 /\ 1:EAX=0)
Observation SB Never 0 3
Hash=7dbd6b8e6dd4abc2ef3d48b0376fb2e3
\end{verbatim}
The output of \herd{} mainly consists in
the list of final states that are allowed by the simulated model.
Additional output relates to the test condition.
One sees that the test condition does not validate on top of SC,
as ``\texttt{No}'' appears just after the list of final states
and as there is no ``Positive'' witness.
Namely, the condition ``\verb+exists (0:EAX=0 /\ 1:EAX=0)+''
reflects a non-SC behaviour, see Sec.~\ref{intro:candidate}.

\label{intro:candidate}%
The simulator \herd{} works by generating all candidate executions
of a given test.
By ``candidate execution'' we mean a choice of events,
program order~\textrel{po}, of the read-from relation~\texttt{rf}
and of final writes to memory
(last write to a given location)\footnote{Alternatively,
we may adopt the simpler view that
a candidate execution includes a choice of all communication relations.}.
In the case of the \ltest{SB} example, we get the following four executions:
\begin{center}
\img{SB-00}\quad\quad
\img{SB-01}\quad\quad
\img{SB-02}\quad\quad
\img{SB-03}
\end{center}
Indeed, there is no choice for the program order \textrel{po}, as there are no
conditional jumps in this example; and  no choice for the final
writes either, as there is only one store per location, which
must be \textrel{co}-after the initial stores (pictured as small red dots).
Then, there are two read events from locations $x$ and~$y$ respectively,
which take their values either from the initial stores or from
the stores in program. As a result, there are four possible executions.
The model \afile{sc.cat} gets executed on each of the four
candidate executions. The three first executions
are accepted and the last one is rejected, as it presents a cycle
in \texttt{po | fr}.
On the following diagram,
the cycle  is obvious:
\begin{center}\img{SB+SC}\end{center}

\subsection{Total Store Order (TSO)}
However, the non-SC execution \ahrefloc{x86:classic}{shows up} on x86 machines,
whose memory model is TSO. As TSO relaxes the write-to-read order, we attempt
to write a TSO model \afile{tso-00.cat}, by simply removing write-to-read
pairs from the acyclicity check:
\verbatiminput{tso-00.cat}
This model illustrates several features
of model definitions:
\begin{itemize}
\item New predefined sets: \verb+W+, \verb+R+ and~\verb+M+, which are
the sets of write events, read events and of memory events, respectively.
\item The cartesian product operator ``\verb+*+'' that returns the cartesian
product of two event sets as a relation.
\item The intersection operator ``\verb+&+'' that operates on sets and
relations.
\end{itemize}
As a result, the effect of the declaration
\verb+let po-tso = po & (W*W | R*M)+ is to define \verb+po-tso+
as the program order on memory events minus write-to-read pairs.

We run \atest{SB} on top of the tentative TSO model:
\begin{verbatim}
% herd7 -model tso-00.cat SB.litmus
Test SB Allowed
States 4
0:EAX=0; 1:EAX=0;
0:EAX=0; 1:EAX=1;
0:EAX=1; 1:EAX=0;
0:EAX=1; 1:EAX=1;
Ok
Witnesses
Positive: 1 Negative: 3
...
\end{verbatim}
\label{sb:image}The non-SC behaviour is now accepted, as write-to-read \textrel{po}-pairs
do not participate to the acyclicity check any more. In effect, this allows
the \ahref{SB-03.png}{last execution} above,
as $\textrel{ghb}$ (\emph{i.e.}
\verb+po-tso | com-tso+) is acyclic.
\begin{center}\img{SB+TSO}\end{center}


However,
our model \afile{tso-00.cat} is flawed: it is still to strict,
forbidding some behaviours that the TSO model should accept.
Consider the test \atest{SB+rfi-pos},
which is test \atest{STFW-PPC} for X86 from Sec.~\ref{stfw} with a normalised name (see Sec.~\ref{sec:names}).
This test targets the following execution:
\begin{center}\img{SB+rfi-pos}\end{center}
Namely the test condition
\verb+exists (0:EAX=1 /\ 0:EBX=0 /\ 1:EAX=1 /\ 1:EBX=0)+
specifies that Thread~$0$ writes~$1$ into location~$x$,
reads the value $1$~from the location~$x$ (possibly by store forwarding) and
then reads the value~$0$ from the location~$y$;
while Thread~$1$ writes~$1$ into~$y$,
reads~$1$ from~$y$ and then reads~$0$ from~$x$.
Hence, this test derives from the previous~\atest{SB}
by adding loads in the middle, those loads
being  satisfied from local stores.
As can be seen by running the test on top of the \afile{tso-00.cat}
model, the target execution is forbidden:
\begin{verbatim}
% herd7 -model tso-00.cat SB+rfi-pos.litmus
Test SB+rfi-pos Allowed
States 15
0:EAX=0; 0:EBX=0; 1:EAX=0; 1:EBX=0;
...
0:EAX=1; 0:EBX=1; 1:EAX=1; 1:EBX=1;
No
Witnesses
Positive: 0 Negative: 15
..
\end{verbatim}
However, running the test with litmus demonstrates that the behaviour
is observed on some X86 machine:
\begin{verbatim}
% arch
x86_64
% litmus7 -mach x86 SB+rfi-pos.litmus
...
Test SB+rfi-pos Allowed
Histogram (4 states)
11589 *>0:EAX=1; 0:EBX=0; 1:EAX=1; 1:EBX=0;
3993715:>0:EAX=1; 0:EBX=1; 1:EAX=1; 1:EBX=0;
3994308:>0:EAX=1; 0:EBX=0; 1:EAX=1; 1:EBX=1;
388   :>0:EAX=1; 0:EBX=1; 1:EAX=1; 1:EBX=1;
Ok

Witnesses
Positive: 11589, Negative: 7988411
Condition exists (0:EAX=1 /\ 0:EBX=0 /\ 1:EAX=1 /\ 1:EBX=0) is validated
...
\end{verbatim}
As a conclusion, our tentative TSO model is too strong.
The following diagram pictures its \textrel{ghb} relation:
\begin{center}\img{SB+rfi-pos+TER}\end{center}
One easily sees that \textrel{ghb} is cyclic, whereas it should not.
Namely, the internal read-from relation~\textrel{rfi} does
not create global order in the TSO model.
Hence, \textrel{rfi} is not included in \textrel{ghb}.
We rephrase our tentative TSO model, resulting into the new model
\afile{tso-01.cat}:
\verbatiminput{tso-01.cat}
As can be observed above \texttt{rfi} (internal read-from) is no longer
included in \textrel{ghb}. However, \texttt{rfe} (external read-from)
still is. Notice that \texttt{rfe} and~\texttt{rfi} are pre-defined.


As intended, this new tentative TSO model allows the behaviour of test~\atest{SB+rfi-pos}:
\begin{verbatim}
%  herd7 -model tso-01.cat SB+rfi-pos.litmus
Test SB+rfi-pos Allowed
States 16
...
0:EAX=1; 0:EBX=1; 1:EAX=1; 1:EBX=0;
...
Ok
Witnesses
Positive: 1 Negative: 15
...
\end{verbatim}
And indeed, the global-happens-before relation is no-longer cyclic:
\begin{center}\img{SB+rfi-pos+BIS}\end{center}


We are not done yet, as our model is too weak in two aspects.
First, it has no semantics for fences.
As a result the test \atest{SB+mfences} is allowed, whereas it should
be forbidden, as this is the very purpose of the fence \texttt{mfence}.
\begin{center}\img{SB+mfences}\end{center}
One easily solves this issue by first defining the \verb+mfence+
that relates events with a \verb+MFENCE+ event \texttt{po}-in-between them;
and then by adding \verb+mfence+ to the definition of \verb+po-tso+:
\begin{verbatim}
let mfence = po & (_ * MFENCE) ; po
let po-tso = po & (W*W | R*M) | mfence
\end{verbatim}
Notice how the relation \verb+mfence+ is defined from two pre-defined sets:
``\verb+_+'' the universal set of all events and \verb+MFENCE+ the set
of fence events generated by the X86 \texttt{mfence} instruction.
An alternative, more precise definition, is possible:
\begin{verbatim}
let mem-to-mfence = po & M * MFENCE
let mfence-to-mem = po & MFENCE * M
let mfence = mem-to-mfence; mfence-to-mem
\end{verbatim}
This alternative definition of \texttt{mfence},
although yielding a smaller relation, is equivalent to the original one
for our purpose of checking \texttt{ghb} acyclicity.

But the resulting model is still too weak,
as it allows some behaviours that any model must
reject for the sake of single thread correctness.
The following test \atest{CoRWR} illustrates the issue:
\verbatiminput{CoRWR.litmus}
The test final condition targets the following execution candidate:
\begin{center}\img{CoRWR}\end{center}
The TSO check ``\verb+acyclic po-tso|com-tso+'' does not suffice to reject
two absurd behaviours pictured in the execution diagram above:
(1) the read~$a$ is allowed to
read from the \textrel{po}-after write~$b$, as \textrel{rfi} is not included
in \textrel{com-tso}; and~(2)
the read~$c$ is allowed to read the initial value of location~$x$
although the initial write~$d$ is \textrel{co}-before the write~$b$,
since \verb+po & (W * R)+ is not in \textrel{po-tso}.

\label{defuniproc}For any model, we rule out those very
untimely behaviours by the so-called
\textsc{uniproc}
check that states that executions projected on events that access one variable
only are SC.
In practice, having defined \verb+po-loc+ as \verb+po+ restricted to
events that touch the same address (\emph{i.e.}
as \verb+po & loc+), we further require the acyclicity
of the relation \verb+po-loc|fr|rf|co+.
In the TSO case, the \textsc{uniproc}~check can be
somehow simplified by considering only
the cycles in \verb+po-loc|fr|rf|co+ that
are not already rejected by the main check of the model.
This amounts to design specific checks for the two relations that are
not global in TSO: \verb+rfi+ and \verb+po & (W*R)+.
Doing so, we finally produce a correct model for TSO \afile{tso-02.cat}:
\verbatiminput{tso-02.cat}
This last model illustrates another feature of \cat{}:
\herd{} may also performs irreflexivity checks with the keyword
``\verb+irreflexive+''.

\subsection{Sequential consistency, total order definition}
We now illustrate another style of model.
We consider the original definition of sequential consistency~\cite{lam79}.
An execution is SC when there exists a total (strict) order~\verb+S+ on events such that:
\begin{enumerate}
\item $S$ includes the program order~\verb+po+;
\item \label{rfcond}and read events read from the most recent write events in the past,
\emph{i.e.} a read~$r$ from location~$x$ reads the value stored by
the \verb+S+-maximal write amongst those writes to location~$x$
that \verb+S+-precede~$r$.
\end{enumerate}
So we could just generate all total strict orders amongst events,
and filter those ``scheduling order candidates'' according to the two rules
above.

\label{sec:final:initial}Things are a bit more complex in~\herd{}, due to the presence of initial and final writes. Up to now we have ignored those writes,
we are now going to integrate them explicitly.

Initial writes are write events that initialise the memory locations.
Initial writes are not generated by the instructions of the test.
Instead, they are created by \herd{} machinery, and are available
from model text as the set \verb+IW+.


Final writes may be  generated by program instructions, and, when such,
they must be ordered by~$S$.
A final write is a write to a phantom read performed once
program execution is over.
The constraint on final writes
originates from \herd{} technique to enumerate execution candidates:
actual execution candidates also include a choice of final writes for
the locations that are observed in the test final condition\footnote{Doing
so permits pruning executions that are irrelevant to the test final condition,
see \herd{} option \ahrefloc{speedcheck:opt}{\opt{-speedcheck}}}.
As test outcome (\emph{i.e.} the final values of observed locations) is
settled before executing the model, it is important \emph{not} to accept
executions that yield a different outcome. Doing so may validate outcomes
that should be rejected.
In practice, the final write $w_f$
to location~$x$ must follow all other writes to~$x$ in~$S$.
Considering that the set of final writes is available to \cat{}~models
as the pre-defined set~\verb+FW+,
the  constraint on final writes
can be expressed as a relation:
\begin{verbatim}
let preSC = loc & (W \ FW) * FW
\end{verbatim}
Where \verb+loc+ is a predefined relation that relates all events
that access the same location.

By contrast with final writes, initial writes are not generated
by program instructions, and it is possible not to order them completely.
In particular, it is not useful to order initial writes to different locations,
nor the initial write to location~$x$ with any access to location~$y$.
Notice that we could include initial writes in~$S$ as we did for
final writes. Not doing so will slightly improve efficiency.

\label{intro:linearisations}%
Finally, the strict order~$S$ is not just any order on events,
it is a topological order of the events generated by threads
(implemented as the set \verb+~IW+. \emph{i.e.} the complement of the set
of initial writes) that extends the pre-order~\verb+preSC+.
We can generate all such topological orders with the \cat{}~primitive
\verb+linearisations+:
\begin{verbatim}
let allS = linearisations(~IW,preSC)
\end{verbatim}
The call \texttt{linearisations($E$,$r$)}, where $E$ is a set of events
and~$r$ is a relation on events, returns the set of all total
strict orders defined on~$E$ that extend~$r$. Notice that if~$r$ is cyclic,
the empty set is  returned.

\label{intro:with}We now need to iterate over the set~\verb+allS+.
We do so with the \verb+with+ construct:
\begin{verbatim}
with S from allS
\end{verbatim}
It is important to notice that the construct above extends the current
execution candidate (\emph{i.e.} a choice of events, plus a choice of
two relations~\texttt{po} and~\texttt{rf}) with a candidate strict order~$S$.
In other words, the scope of the iteration is the remainder of the model text.
Once model execution terminates for a choice of~$S$
(some element of~\texttt{allS}), model execution restarts just
after the \texttt{with} construct, with variable~$S$ bound to
the next choice picked in~\texttt{allS}.

As a first consistency check, we check that $S$ includes the program order:
\begin{verbatim}
empty po \ S as PoCons
\end{verbatim}
Notice that, to check for inclusion, we test the emptiness of relation
difference (operator ``\verb+\+'').


It remains to check that the \texttt{rf} relation of the execution candidate
is the same as the one defined by condition~\ref{rfcond}.
To that aim, we complement~$S$ with the constraint over initial
writes that  must precede all events to their location:
\begin{verbatim}
let S = S | loc & IW * (M \ IW)
\end{verbatim}
Observe that $S$ is no longer a total strict order. However, it is still a total
strict order when restricted to events that access a given location,
which is all that matters for condition~\ref{rfcond} to give a value
to all reads. As regards our SC model, we define \texttt{rf-S}
the read-from relation induced by~$S$ as follows:
\begin{verbatim}
let WRS = W * R & S & loc  (* Writes from the past, same location *)
let rf-S = WRS \ (S;WRS)   (* Most recent amongst them *)
\end{verbatim}
The definition is a two-step process: we first define
a relation~\texttt{WRS} from writes to reads (to the same location)
that follow them in~$S$. Observe that,
by complementing~$S$ with initial writes, we achieve that for any read~$r$
there exists at least a write~$w$ such that $(w,r) \in \texttt{WRS}$.
It then remains to filter out non-maximal writes in \texttt{WRS}
as we do in the definition of \texttt{rf-S}, by the means of
the difference operator ``\verb+\+''.
We then check the equality of \texttt{rf} (pre-defined as part of the candidate
execution) and of \texttt{rf-S} by double inclusion:
\begin{verbatim}
empty rf \ rf-S as RfCons
empty rf-S \ rf as RfCons
\end{verbatim}

As an example, he show six attempts of \texttt{po} compatible $S$~orders
for the non-SC outcome of the test~\atest{SB} in figure~\ref{sblamport}.
\begin{figure}[htp]
\caption{\label{sblamport}Failed attempts of SC scheduling orders~$S$.}
\begin{center}
\img{SB+L-00}\quad\img{SB+L-01}\quad\img{SB+L-02}\\
\img{SB+L-03}\quad\img{SB+L-04}\quad\img{SB+L-05}
\end{center}
\end{figure}
Observe that all attempts fail as \texttt{rf} and \texttt{rf-S}
are different in all diagrams.

We also show all successful SC scheduling in figure~\ref{sbok}.
\begin{figure}[htp]
\caption{\label{sbok}SC executions of test~\atest{SB}.}
\begin{center}
\img{SB+OK-00}\quad\img{SB+OK-01}\quad\img{SB+OK-02}\\
\img{SB+OK-03}\quad\img{SB+OK-04}\quad\img{SB+OK-05}
\end{center}
\end{figure}


For reference we provide our complete model~\afile{lamport.cat}
\verbatiminput{lamport.cat}

\subsection{Computing \label{sec:cos}coherence orders}
All the models seen so far include the
file \ahref{./cos-no-opt.cat}{\texttt{cos.cat}} that define
``coherence relations'', written~\texttt{co}. This section describes
a possible computation of coherence orders\footnote{The actual computation of coherence orders slighty differs. Interested readers can look at the
\afile{cross.cat}~file.}. It can be skipped in first
reading, as users may find sufficient to include the file.

For a given location~$x$ the coherence order is a total strict order on the
write events to location~$x$. The coherence relation~\texttt{co} is the union
of those orders for all locations.
In this section, we show how to compute all possible coherence orders for
a candidate execution.
We seize the opportunity to introduce advanced features of the \cat{}
language, such as functions and pattern matching over sets.

Possible coherence orders for a given location~$x$
are not totally arbitrary in two aspects:
\begin{enumerate}
\item The write events to location~$x$ include
the initial write event to location~$x$.  The initial write to~$x$ must come
first in any coherence order for~$x$.
\item One of the writes to~$x$ performed by the test (may) have been declared
to be final by \herd{} machinery prior to model execution.
In that case, the final write to~$x$ must come last in any coherence order
for~$x$.
\end{enumerate}
See Sec.~\ref{sec:final:initial} for details on initial and final writes.

We can express the two conditions above for all locations of the program
as a relation \texttt{co0}:
\begin{verbatim}
let co0 = loc & (IW*(W\IW)|(W\FW)*FW)
\end{verbatim}
Where the pre-defined sets \texttt{IW} and~\texttt{FW} are the sets
of all initial and final writes respectively.
%TODO exemple of co0 on 2+2W

Then, assuming that $W_x$ is the set of all writes to location~$x$, one
can compute the set of all possible coherence orders for~$x$ with
the \texttt{linearisations} primitive as \texttt{linearisations($W_x$,co0)}.
In practice, we define a function that takes the set~$W_x$ as an argument:
\begin{verbatim}
let makeCoX(Wx) = linearisations(Wx,co0)
\end{verbatim}
The \texttt{linearisations} primitive is introduced in
Sec.~\ref{intro:linearisations}. It returns all topological sorts
of the events  of the set~\texttt{Wx} that are compatible
with the relation~\texttt{co0}.


In fact, we want to compute the set of all possible \texttt{co} relations,
\emph{i.e.} all the unions of all the possible coherence orders for all
locations~$x$. To that end we use another \cat{} primitive:
\texttt{partition($S$)}, which takes a set of events as argument and
returns a set of set of events $T = \{S_1,\ldots,S_n\}$, where each
$S_i$ is the set of all events in $S$ that act on location $L_i$,
and, of course $S$ is the union $\bigcup_{i=1}^{i=n} S_i$.
Hence we shall compute the set of all \texttt{Wx} sets
as \texttt{partition(W)},
where \texttt{W} is the pre-defined set of all writes (including initial
writes).

For combining the effect of the \texttt{partition} and \texttt{linearisations}
primitives, we first define a \texttt{map}
function\footnote{Function \texttt{map} is defined at the end of \herd standard
library~\afile{stdlib.cat}} that, given a set~$S=
\{e_1,\ldots,e_n\}$ and a function $f$, returns the set
$\{f(e_1),\ldots,f(e_n)\}$:
\begin{verbatim}
let map f  =
  let rec do_map S = match S with
  || {} -> {}
  || e ++ S -> f e ++ do_map S
  end in
  do_map
\end{verbatim}
The \texttt{map} function is written in curried style.
That is one calls it as \texttt{map~$f$~$S$}, parsed
as \texttt{(map~$f$)~$S$}. More precisely, the left-most function
call~\texttt{(map~$f$)} returns a function.
Here it returns~\texttt{do\_map} with free variable \texttt{f} being bound
to the argument~$f$.
The definition of~\texttt{map} illustrate several new features:
\begin{enumerate}
\item The empty set constant~``\verb+{}+'',
and the set addition operator \texttt{$e$ ++ $S$} that returns the set~$S$
augmented with element~$e$.
\item Recursive function definitions. The function~\verb+do_map+
is recursive as it calls itself.
\item Pattern matching on sets.
This construct, similar to OCaml pattern matching on lists, discriminates
between empty (\verb+|| {} ->+~$e_0$) and non-empty
(\verb!|| e ++ es ->!~$e_1$) sets.
In the second case of a non-empty set, the expression~$e_1$ is evaluated
in a context extended with two bindings: a binding from the variable~\texttt{e}
to an arbitrary element of the matched set, and a binding from
the variable~\texttt{es} to the matched set minus the arbitrary element.
\end{enumerate}

Then, we generate the set of all possible coherence orders
for all locations~$x$ as follows:
\begin{verbatim}
let allCoX = map makeCoX (partition(W))
\end{verbatim}
Notice that \texttt{allCoX} is a set of sets of relations,
each element being the set of all possible coherence orders
for a specific~$x$.

We still need to generate all possible \texttt{co} relations,
that is all unions of the possible coherence orders for
all locations~$x$.  It can be done by another \cat{} function:
\texttt{cross}, which takes a set of sets $S = \{S_1, S_2, \ldots, S_n\}$ as
argument and returns all possible unions built by picking elements from each of
the $S_i$:
$$
\left\{\, e_1 \cup e_2 \cup \cdots \cup e_n \mid
e_1 \in S_1, e_2 \in S_2, \ldots, e_n \in S_n \,\right\}
$$
One may notice that if $S$ is empty, then \texttt{cross} should
return one relation exactly: the empty relation, \emph{i.e.} the neutral
element of the union operator.
This choice for \texttt{cross($\emptyset$)} is natural
when we define \texttt{cross} inductively:
$$
\texttt{cross}(S_1 \mathop{\texttt{++}} S) =
\bigcup_{e_1 \in S_1, t \in \texttt{cross}(S)} \left\{ e_1 \cup t \right\}
$$
In the definition above, we simply build
\texttt{cross($S_1 \mathop{\texttt{++}} S$)} by building the set
of all unions of one relation~$e_1$ picked in~$S_1$
and of one relation~$t$ picked in $\texttt{cross}(S)$.

So as to write~\texttt{cross},
we first define a classical \texttt{fold} function over sets:
given a set $S = \{ e_1, e_2, \ldots, e_n\}$, an initial value~$y_0$
and a function $f$~that takes a pair $(e,y)$ as argument,
\texttt{fold} computes:
$$
f (e_{i_1},f (e_{i_2}, \ldots, f(e_{i_n},y_0)))
$$
where $i_1, i_2, \ldots, i_n$ defines a permutation
of the indices $1, 2, \ldots, n$.
\begin{verbatim}
let fold f =
  let rec fold_rec (es,y) = match es with
  || {} -> y
  || e ++ es -> fold_rec (es,f (e,y))
  end in
  fold_rec
\end{verbatim}
The function~\texttt{fold} is written in the same curried style as~\texttt{map}.
Notice that the inner function~\verb+fold_rec+ takes one argument.
However this argument is a pair.
As a gentle example of \texttt{fold} usage, we could have
defined~\texttt{map} as:
\begin{verbatim}
let map f = fun S -> fold (fun (e,y) -> f e ++ y) (S,{})
\end{verbatim}
This example also introduce ``anonymous'' functions.


As a more involved example of \texttt{fold} usage, we
 write the function~\texttt{cross}.
\begin{verbatim}
let rec cross S = match S with
  || {} -> { 0 } (* 0 is the empty relation *)
  || S1 ++ S ->
      let ts = cross S in
      fold
        (fun (e1,r) -> map (fun t -> e1 | t) ts | r)
        (S1,{})
  end
\end{verbatim}
The function~\texttt{cross} is a recursive function over a set (of sets).
Its code follows the inductive definition given above.

Finally, we generate all possible \texttt{co} relations by:
\begin{verbatim}
let allCo = cross allCoX
\end{verbatim}

Computation goes on by iterating over \texttt{allCo} using
the \texttt{with $x$ from~$S$} construct:
\begin{verbatim}
with co from allCo
\end{verbatim}
See Sec.~\ref{intro:with} for details on this construct.

Once~\texttt{co} has been defined, one defines~\texttt{fr} and
internal and external variations:
\begin{verbatim}
(* From now, co is a coherence relation *)
let coi = co & int
let coe = co & ext

(* Compute fr *)
let fr = rf^-1 ; co
let fri = fr & int
let fre = fr & ext
\end{verbatim}
The pre-defined relation \texttt{ext} (resp. \texttt{int}) relates
events generated by different (resp. the same) threads.


\section{Producing pictures of executions}
The simulator \herd{} can be instructed to produce pictures of
executions.
Those pictures are instrumental in understanding and
debugging models.
It is important to understand that \herd{} does not produce pictures
by default. To get pictures one must instruct \herd{} to produce
pictures of some executions with the \opt{-show} option.
This option accepts specific keywords, its default being ``\opt{none}'',
instructing \herd{} not to produce any picture.

A frequently used keyword is ``\opt{prop}'' that means ``show the executions
that validate the proposition in the final condition''.
Namely, the final condition in litmus test is a quantified
boolean proposition as for instance ``\verb+exists (0:EAX=0 /\ 1:EAX=0)+'' at the end of test \atest{SB}.

But this is not enough, users also have to specify what to do with the picture:
save it in file in the DOT format of the
\ahref{http://graphviz.org/}{\prog{graphviz} graph visualization software}, or
display the image,\footnote{This option requires
the Postscript visualiser \ahref{\urlgv}{\prog{gv}}.} or both.
One instructs  \herd{} to save images with the \opt{-o }\textit{dirname} option,
where \textit{dirname} is the name of a directory, which must exists.
Then, when processing the file \textit{name}\texttt{.litmus},
\herd{} will create a file \textit{name}\texttt{.dot} into the
directory~\textit{dirname}.
For displaying images, one uses the \opt{-gv} option.

\label{sec:show}As an example,
so as to display the image of the non-SC behaviour of \atest{SB}, one
should invoke \herd{} as:
\begin{verbatim}
% herd7 -model tso-02.cat -show prop -gv SB.litmus
\end{verbatim}
\aname{sb:cluster}{As}
a result, users should see a window popping and displaying this image:
\begin{center}\img{SB+CLUSTER}\end{center}
Notice that we got the PNG version of this image as follows:
\begin{verbatim}
% herd7 -model tso-02.cat -show prop -o /tmp SB.litmus
% dot -Tpng /tmp/SB.dot -o SB+CLUSTER.png
\end{verbatim}
That is, we applied the \prog{dot} tool from the
\ahref{\urlgraphviz}{\prog{graphviz}} package, using the appropriate option
to produce a PNG image.

One may observe that there are \verb+ghb+ arrows in the diagram.
This results from the \verb+show ghb+ instruction
at the end of the model file~\afile{tso-02.cat}.

\subsection{Graph modes}
The image \ahrefloc{sb:cluster}{above} much differs from
the one in Sec.~\ref{sb:image} that describes the same execution
and that is reproduced in Fig.~\ref{fig:sb}
\begin{figure}
\caption{\label{fig:sb}The non-SC behaviour of \atest{SB} is allowed by TSO}
\begin{center}
\img{SB+TSO}
\end{center}
\end{figure}

\label{mode:example}In effect, \herd{} can produce three styles
of pictures, \prog{dot} clustered pictures, \prog{dot} free pictures,
and \prog{neato} pictures with explicit placement of the
events of one thread as a column.
The style is commanded by the \opt{-graph} option that accepts three
possible arguments: \opt{cluster} (default), \opt{free} and~\opt{columns}.
The following pictures show
the effect of graph styles on the \atest{SB}~example:
\begin{center}
\begin{tabular}{*{3}{p{.25\linewidth}}}
\multicolumn{1}{c}{\opt{-graph cluster}} &
\multicolumn{1}{c}{\opt{-graph free}} &
\multicolumn{1}{c}{\opt{-graph columns}}\\
\img{SB+SQUISHED} \qquad &
\img{SB+FREE}\qquad &
\img{SB+COLUMNS}
\end{tabular}
\end{center}
Notice that we used another option \opt{-squished true} that much reduces
the information displayed in nodes. Also notice that
the first two pictures are formatted by \prog{dot},
while the rightmost picture is formatted by \prog{neato}.

One may also observe that the ``\opt{-graph columns}''  picture does not
look exactly like Fig.~\ref{fig:sb}. For instance the
\textrel{ghb} arrows are thicker in the figure.
There are many parameters to control \prog{neato} (and~\prog{dot}),
many of which are accessible to \herd{} users by the means of appropriate
options. We do not intend to describe them all.
However, users can reproduce the style of the diagram of this manual using
yet another feature of \herd: \ahrefloc{herd:configfile}{configuration files}
that contains settings for \herd{} options and that are loaded with the
\opt{-conf~}\textit{name} option.
In this manual we mostly used the \afile{doc.cfg} configuration file.
As this file is present in \herd{} distribution, users
can use the diagram style of this manual:
\begin{verbatim}
% herd7 -conf doc.cfg ...
\end{verbatim}

\subsection{\label{show:forbidden}Showing forbidden executions}
Images are produced or displayed once the model has been executed.
As a consequence,
forbidden executions won't appear by default.
Consider for instance the test \atest{SB+mfences},
where the \texttt{mfence} instruction is used to forbid
\atest{SB} non-SC execution. Running \herd{} as
\begin{verbatim}
% herd7 -model tso-02.cat -conf doc.cfg -show prop -gv SB+mfences.litmus
\end{verbatim}
will produce no picture, as the TSO model forbids the target execution
of~\textsf{SB+mfences}.

To get a picture, we can run \textsf{SB+mfences} on top of the minimal
model, a pre-defined model that allows all executions:
\begin{verbatim}
% herd7 -model minimal -conf doc.cfg -show prop -gv SB+mfences.litmus
\end{verbatim}
And we get the picture:
\begin{center}\img{SB+mfences}\end{center}
It is worth mentioning again  that although the minimal model allows all
executions, the final condition
selects the displayed picture, as we have specified the
\opt{-show prop} option.


\label{name:check}The picture above shows \verb+mfence+ arrows, as all
fence relations are displayed by the minimal model.
However, it  does not show the \verb+ghb+ relation, as the minimal
model knows nothing of it.
To display~\verb+ghb+ we could write another model file that would be just as
\afile{tso-02.cat}, with checks erased.
The simulator \herd{} provides a simpler technique:
one can instruct \herd{} to ignore
either all checks (\opt{-through invalid}), or a selection of checks
(\opt{-skipchecks~\textit{name$_1$},\ldots,\textit{name$_n$}}).
Thus, either of the following two commands
\begin{verbatim}
% herd7 -through invalid -model tso-02.cat -conf doc.cfg -show prop -gv SB+mfences.litmus
% herd7 -skipcheck tso -model tso-02.cat -conf doc.cfg -show prop -gv SB+mfences.litmus
\end{verbatim}
will produce the picture we wish:
\begin{center}\img{SB+mfences+GHB}\end{center}
Notice that \verb+mfence+ and~\verb+ghb+ are displayed because
of the instruction ``\verb+show mfence ghb+'' (fence relation are not shown
by default);
while \opt{-skipcheck tso} works because the \afile{tso-02.cat} model
names its main check with ``\verb+as tso+''.

The image above is barely readable.
For such graphs with many relations, the \verb+cluster+ and~\verb+free+ modes
are worth a try. The commands:
\begin{verbatim}
% herd7 -skipcheck tso -model tso-02.cat -conf doc.cfg -show prop -graph cluster -gv SB+mfences.litmus
% herd7 -skipcheck tso -model tso-02.cat -conf doc.cfg -show prop -graph free -gv SB+mfences.litmus
\end{verbatim}
will produce the images:
\begin{center}
\begin{tabular}{p{.33\linewidth}@{\hspace*{6em}}p{.33\linewidth}}
\img{SB+mfences+CLUSTER}
&
\img{SB+mfences+FREE}
\end{tabular}
\end{center}
Namely, command line options are scanned left-to-right,
so that most of the settings of \afile{doc.cfg} are kept\footnote{The setting of \opt{showthread} is also changed, by the omitted \opt{-showthread true} command line option}
(for instance thick \verb+ghb+ arrows), while the graph mode is overridden.


\section{\label{herd:language}Model definitions}

We describe our \cat{}~language for defining models.
The syntax of the language is given in BNF-like notation. Terminal
symbols are set in typewriter font (\synt{\T{like} \T{this}}).
Non-terminal symbols are set in italic font (\synt{\NT{like} \NT{that}}).
A~vertical bar \synt{\ldots\orelse\ldots}
denotes alternative.
Square brackets \synt{\boption{}\ldots\eoption{}} denote optional components. Curly brackets
\synt{\brepet{}\ldots\erepet{}} denotes zero,
one or several repetitions of the enclosed
components.
Parentheses \synt{\bparen{}\ldots\eparen{}} denote grouping.


Model source files may contain comments of the OCaml type
(\verb+(*+\ldots \verb+*)+, can be nested), or line comments starting with
``\verb+//+'' and running until end of line.

\subsection{\label{overview}Overview}
The \cat{} language is much inspired by OCaml, featuring immutable bindings,
first-class functions, pattern matching, etc.
However, \cat{} is a domain specific language, with important differences
from OCaml.
\begin{enumerate}
\item
Base values are specialised, they are sets of events and relations
over events. There are also tags, akin to C~enumerations or OCaml
``constant'' constructors and first class functions. Moreover, events
can be extracted from sets and pair of events (element of relations)
from relations.

There are two structured values: tuples of values and sets of values.
Once should notice that primitive set of events and structured set of events are not the same
thing. In fact, the language prevents the construction of structured set of events.
Similarily, there are no structured sets of elements of relations, there are only relations.

\item There is a distinction between expressions that evaluate
to some value, and instructions that are executed for their effect.
\end{enumerate}
A model, or \cat{} program is a sequence of instructions.
At startup, pre-defined identifiers are bound to event sets and relations
over events.
Those pre-defined identifiers describe a candidate execution
(in the sense of the memory model).
Executing the model means allowing or forbiding that candidate
execution.


\subsection{\label{language:identifier}Identifiers}
\begin{syntax}
\NT{letter} \is \T{a} \ldots\T{z}
\orelse  \T{A} \ldots\T{Z}
\sep
\NT{digit} \is \T{0} \ldots\T{9}
\sep
\NT{id} \is \NT{letter} \brepet{} \NT{letter} \orelse \NT{digit}
\orelse \T{\_} \orelse \T{.} \orelse \T{-} \erepet
\end{syntax}
Identifiers are rather standard: they are a sequence of letters, digits,
``\texttt{\_}'' (the underscore character), ``\texttt{.}'' (the dot character)
and ``\texttt{-}'' (the minus character),
starting with a letter.
Using the minus character inside identifiers  may look a bit surprising.
We did so as to allow identifiers such as \texttt{po-loc}.

\label{sec:predef}At startup, pre-defined identifiers are bound to
event sets and to relations
between events.

Those pre-defined identifiers first describe the events of
the candidate execution as various sets, as described by the first table
of figure~\ref{predefset}.
\begin{figure}[htp]
\caption{\label{predefset}Pre-defined event sets.}
\begin{idtable}
\textrel{emptyset} & empty set of events \\
\textrel{W} & write events \\
\textrel{R} & read events \\
\textrel{M} & memory events &
we have $\textrel{M} = \textrel{W} \cup \textrel{R}$\\
\textrel{IW} & initial writes &
feed reads that read from the initial state\\
\textrel{FW} & final writes & writes that are observed at the end of test execution\\
\textrel{B} & branch events\\
\textrel{RMW} & read-modify-write events\\
\textrel{F} & fence events\\
\textit{NAME} & specific fence events & those depend on the test architecture\\
\end{idtable}

\begin{desctable}{architecture}{fence sets}
\textrel{X86} & \textrel{MFENCE}, \textrel{SFENCE}, \textrel{LFENCE}\\
\textrel{PPC} & \textrel{SYNC}, \textrel{LWSYNC}, \textrel{EIEIO}, \textrel{ISYNC}\\
\textrel{ARM} &  \textrel{DMB}, \textrel{DMB.ST}, \textrel{DSB}, \textrel{DSB.ST}, \textrel{ISB}\\
 \textrel{MIPS} & \textrel{SYNC}\\
\textrel{AArch64} &  \textrel{DMB.SY},  \textrel{DMB.ST}, \textrel{DMB.ST}, \ldots
\textrel{DSB.SY},  \textrel{DSB.ST}, \textrel{DSB.ST}, \ldots\\
\end{desctable}
\end{figure}
Specific fence event sets depends on the test architecture,
their name is always uppercase and derive from the mnemonic of
the instruction that generates them.
The second table of figure~\ref{predefset} shows
a (non-exhaustive) list.


Other pre-defined identifiers are relations.
Most of those are the program order~\tid{po} and its refinements:
\begin{idtable}
$\po$    & program order & instruction order lifted to events \\
$\addr$ & address dependency & the address of the second event depends on
the value loaded by the first (read) event\\
$\data$ & data dependency & the value stored by the second (write)
event depends on
the value loaded by the first (read) event\\
$\ctrl$ & control dependency &
the second event is in a branch controled by the value loaded by the
commfirst (read) event\\
$\rmwr$ & read-exclusive write-exclusive pair &
relate the read and write events emitted
by matching successful load-reserve store conditional instructions,
or atomic rmw instructions.\\
$\amo$ & atomic modify &
relate the read and write events emitted
by atomic rmw instructions.
\end{idtable}


Finally, a few pre-defined relations describe the execution
candidate structure and write-to-read communication:
\begin{idtable}
$\id$ & identity & relates each event to itself\\
$\locr$ & same location & events that touch the same address\\
$\extr$ & external & events from different threads\\
$\intr$ & internal & events from the same thread\\

$\rf$  & read-from & links a write $w$ to a read $r$ taking its value from $w$ \\
\end{idtable}

Some additional relations are defined by library files written in the \cat{}
language, see Sec.~\ref{sec:library}.

\subsection{\label{language:expression}Expressions}
Expressions are evaluated by \herd, yielding a value.
\begin{syntax}
\NT{expr} \is{} \T{0}
\alt \NT{id}
\alt \NT{tag}
\alt \T{(}\T{)} \orelse \T{(} \NT{expr} \T{,} \NT{expr} \brepet{} \T{,} \NT{expr} \erepet \T{)}
\alt \T{\{}\T{\}} \orelse \T{\{} \NT{expr} \brepet{} \T{,} \NT{expr} \erepet \T{\}}
\alt \NT{expr}\T{*} \orelse \NT{expr}\T{+} \orelse \NT{expr}\T{?}
\orelse \NT{expr}\T{\textasciicircum-1}
\alt \T{\textasciitilde}\NT{expr}
\alt \T{[}\NT{expr}\T{]}
\alt \NT{expr}\T{|}\NT{expr} \orelse
\NT{expr}\T{++}\NT{expr} \orelse
\NT{expr}\T{;}\NT{expr} \orelse
\NT{expr}\T{\textbackslash}\NT{expr} \orelse
\NT{expr}\T{\&}\NT{expr} \orelse
\NT{expr} \T{*} \NT{expr}
\alt \NT{expr} \NT{expr}
\alt \T{fun} \NT{pat} \T{->} \NT{expr}
\alt \T{let} \boption{} \T{rec} \eoption \NT{binding} \brepet{} \T{and} \NT{binding} \erepet{} \T{in} \NT{expr}
\alt \T{match} \NT{expr} \T{with} \NT{clauses} \T{end}
\alt \T{(}\NT{expr}\T{)} \orelse  \T{begin} \NT{expr} \T{end}
\alt \T{instructions} \NT{id}\T{[}\NT{taglist}\T{]}
\sep
\sep
\NT{tag} \is \T{'} \NT{id}
\sep
\NT{taglist} \is \NT{tag} \T{,} \NT{taglist}
\sep
\NT{pat} \is \NT{id} \orelse \T{(}\T{)} \orelse \T{(} \NT{id} \brepet{} \T{,} \NT{id} \erepet \T{)}
\sep
\NT{binding} \is \NT{valbinding} \orelse \NT{funbinding}
\sep
\NT{valbinding} \is \NT{id} \T{=} \NT{expr}
\sep
\NT{funbinding} \is \NT{id} \NT{pat} \T{=} \NT{expr}
\sep
\sep
\NT{clauses} \is \NT{tagclauses} \orelse \NT{setclauses}
\sep
\NT{tagclauses} \is \boption{} \T{||} \eoption \NT{tag} \T{->} \NT{expr}
\brepet{} \T{||} \NT{tag} \T{->} \NT{expr} \erepet
\boption \T{\_} \T{->} \NT{expr} \eoption
\sep
\NT{setclauses} \is \boption{} \T{||} \eoption \T{\{}\T{\}} \T{->} \NT{expr}
\T{||} \NT{id} \T{++} \NT{id} \T{->} \NT{expr}
\end{syntax}

\subsubsection*{Simple expressions}
Simple expressions are the empty relation (keyword~\synt{\T{0}}),
identifiers~\synt{\NT{id}} and tags~\synt{\NT{tag}}.  Identifiers are bound to
values, either before the execution (see pre-defined identifiers in
Sec.~\ref{sec:predef}), or by the model itself.  Tags are constants similar to
C enum values or OCaml constant constructors.  Tags must be declared with the
\T{enum} instruction. We go back to \T{enum} and tags in Sec.~\ref{sec:enum}
and \ref{sec:bell}.

\subsubsection*{Tuples}
Tuples include a constant, the empty tuple \synt{\T{(}\T{)}},
and constructed tuples
\synt{\T{(} \NT{expr}_1 \T{,} \NT{expr}_1 \T{,}\ldots \T{,} \NT{expr}_n\T{)}},
with $n \geq 2$. In other words there is no tuple of size one.
Syntax \synt{\T{(} \NT{expr} \T{)}} denotes grouping and has the same
value as~\synt{\NT{expr}}.


\subsubsection*{Explicit sets of values}
Explicit sets are written as the comma separated
list of their elements between curly braces:
\synt{\T{\{} \NT{expr}_1 \T{,} \NT{expr}_1 \T{,}\ldots \T{,} \NT{expr}_n\T{\}}},
with $n \geq 0$.
Sets are homogenous, in the sense that sets hold elements of the same type.

In case the values \synt{\NT{expr}_k} are events, the result will be a primitive event set.
In case they are elements of relations, the result
will be a relation (and not a set of event pairs).

The empty set~\synt{\T{\{}\T{\}}} is the empty set of events and the empty relation.



\subsubsection*{Operator expressions}
Most operators are overloaded and apply to event sets, relations and explicit sets.
However, by nature, some operators apply to relations only (as sequence and transitive closure
below) or to sets only (as the cartesian product). Additionally, an event in a context where
an event set is expected will be promoted to a singleton event set. The situation of an
elementary relation in a relation context is similar.

The transitive and reflexive-transitive closure of an expression are performed
by the postfix operators \T{+} and~\T{*}.
The  postfix operator \T{\textasciicircum-1} performs relation inversion.
The construct \synt{\NT{expr}\T{?}} (option) evaluates to the union
of  \NT{expr} value and of the identity relation.
Notice that postfix operators operate on relations only.

There is one prefix operator~\T{\textasciitilde} that performs
relation and set complement.

Finally, there is one last unary operator: \synt{\T{[}\NT{expr}\T{]}}
that evaluate \synt{\NT{expr}} to an event set and returns the identity
relation over this set.

Infix operators are
\T{|} (union), \T{++} (set addition),
\T{;} (sequence), \T{\&} (intersection), \T{\textbackslash} (set difference),
and~\T{*} (cartesian product).
Infix operators  are listed in order of increasing precedence,
while  postfix and prefix operators bind tighter than infix operators.
All infix operators are right-associative,
except set difference which is left-associative, and cartesian product
which is non-associative.

The union, intersection and difference operators apply to relations
and all kinds of sets. The cartesian product takes two event sets as arguments and returns
a relation.

The addition operator \synt{\NT{expr}_1 \T{++} \NT{expr}_2} operates on
sets: the value of \synt{\NT{expr}_2} must be a set of values (or an event, or
an element of relation)
~$S$ and the operator returns the set~$S$ augmented with the value of
\synt{\NT{expr}_1} (or a new event set, or a new relation).
By exception, the arguments to the addition operator can also be an elementary relation. It then yields a relation.

For the record, given two relations $r_1$ and~$r_2$,
the sequence $r_1; r_2$ is defined
as $\{ (x,y) \mid \exists z, (x,z) \in r_1 \wedge (z,y) \in r_2\}$.

\subsubsection*{Function calls}
Functions calls are written \synt{\NT{expr}_1 \NT{expr}_2}.
That is, functions are of arity one and the application operator
is left implicit. Notice that function application binds tighter
than all binary operators and looser that postfix operators.
Furthermore the implicit application operator is left-associative.

The \cat{} language has call-by-value semantics. That is,
the effective parameter
\synt{\NT{expr}_2} is evaluated before being bound to the
function formal parameter(s).

N-ary functions can be encoded either using tuples as arguments
or by curryfication (\emph{i.e.} as functions that return functions).
Considering binary functions, in the former case,
a function call is written
\synt{\NT{expr}_1 \T{(} \NT{expr}_2 \T{,} \NT{expr}_3\T{)}};
while in the latter case, a function call is written
\synt{\NT{expr}_1~\NT{expr}_2~\NT{expr}_3}
(which by left-associativity, is to be understood
as \synt{\T{(}\NT{expr}_1~\NT{expr}_2\T{)}~\NT{expr}_3}).
The two forms of function call are not interchangeable, using one or the
other depends on the definition of the function.


\subsubsection*{Functions}
Functions are first class values, as reflected by the anonymous
function construct \synt{\T{fun} \NT{pat}  \T{->} \NT{expr}}.
A function takes one argument only.

In the case where this argument is a tuple, it may be destructured
by the means of a tuple pattern. That is \synt{\NT{pat}}
above is \synt{\T{(} \NT{id}_1 \T{,} \ldots \NT{id}_n\T{)}}.
For instance here is a function that takes a tuple of
relations (or sets) as argument and return their symmetric difference:
\begin{verbatim}
fun (a,b) -> (a\b)|(b\a)
\end{verbatim}

Functions have the usual static scoping semantics:
variables that appear free in function bodies
(\synt{\NT{expr}} above) are bound to
the value of such free variable at function creation time.
As a result one may also write the symmetric difference function
as follows:
\begin{verbatim}
fun a -> fun b -> (a\b)|(b\a)
\end{verbatim}

\subsubsection*{\label{bindings}Local bindings}
The local binding construct
\synt{\T{let} \boption{} \T{rec} \eoption{} \nt{bindings} \T{in} \NT{expr}}
binds the names defined by \nt{bindings}
for evaluating the expression \NT{expr}.
Both non-recursive and recursive bindings are allowed.
The function binding
\synt{\NT{id} \NT{pat}  \T{=} \NT{expr}} is syntactic sugar
for \synt{\NT{id} \T{=} \T{fun} \NT{pat} \T{->} \NT{expr}}.

The construct
\begin{center}
\synt{\T{let} \NT{pat}_1 \T{=} \NT{expr}_1 \T{and} \ldots \T{and} \NT{pat}_n \T{=} \NT{expr}_n} \T{in} \NT{expr}
\end{center}
evaluates \synt{\nt{expr}_1,\ldots, \nt{expr}_n},
and binds the names in the patterns
\synt{\nt{pat}_1,\ldots, \nt{pat}_n} to the resulting values.
The bindings for \synt{\nt{pat} \T{=} \nt{expr}} are as follows:
if \nt{pat} is \T{(}\T{)}, then \nt{expr} must evaluate to the empty
tuple;
if \nt{pat} is \synt{\nt{id}} or \synt{\T{(}\nt{id}\T{)}},
then \nt{id} is bound to the value of~\synt{\nt{expr}};
if \nt{pat} is a proper tuple pattern
\synt{\T{(}\nt{id}_1\T{,}\ldots \T{,}\nt{id}_n\T{)}} with $n \geq 2$,
then \synt{\nt{expr}} must evaluate to a tuple value of size~$n$
$(v_1,\ldots,v_n)$ and the names $\nt{id}_1,\ldots,\nt{id}_n$ are
bound to the values  $v_1,\ldots,v_n$.
By exception, in the case $n=2$, the expression \synt{\nt{expr}} may evaluate to
an elementary relation. If so, the value behaves as a tuple of arity two.

\aname{letrec}{The} construct
\begin{center}
\synt{\T{let} \T{rec} \NT{pat}_1 \T{=} \NT{expr}_1 \T{and} \ldots \T{and} \NT{pat}_n \T{=} \NT{expr}_n} \T{in} \NT{expr}
\end{center}
computes the least fixpoint of the equations
$\nt{pat}_1 = \nt{expr}_1$,\ldots, $\nt{pat}_n = \nt{expr}_n$.
It then binds the names in the patterns
\synt{\nt{pat}_1,\ldots, \nt{pat}_n} to the
resulting values.
The least fixpoint computation applies to set and relation values,
(using inclusion for ordering); and to
functions (using the usual definition ordering).


\subsubsection*{Pattern matching over tags}
The syntax for pattern matching over tags is:
\begin{center}
\synt{\T{match} \NT{expr} \T{with} \NT{tag}_1 \T{->} \NT{expr}_1
\T{||} \cdots \T{||} \NT{tag}_n \T{->} \NT{expr}_n
\T{||} \T{\_} \T{->} \NT{expr}_d
\T{end}}
\end{center}
The value of the match expression is computed as follow: first evaluate
\synt{\nt{expr}} to some value~$v$, which must be a tag~$t$.
Then $v$ is compared with the tags \synt{\nt{tag}_1,\ldots,\nt{tag}_n},
in that order.
If some tag pattern~\synt{\nt{tag}_i} equals~$t$, then the value of the
match is the value of the corresponding expression~\synt{\nt{expr}_i}.
Otherwise, the value of the match is the value of the default
expression~\synt{\nt{expr}_d}.
As the default clause~\synt{\T{\_} \T{->} \NT{expr}_d} is optional,
the match construct may fail.

\subsubsection*{Pattern matching over sets}
The syntax for pattern matching over sets is:
\begin{center}
\synt{\T{match} \NT{expr} \T{with}
\T{\{}\T{\}} \T{->} \NT{expr}_1
\T{||} \NT{id}_1 \T{++} \NT{id}_2 \T{->} \NT{expr}_2
\T{end}}
\end{center}
The value of the match expression is computed as follow: first evaluate
\synt{\nt{expr}} to some value~$v$, which must be a set of values.
If $v$ is the empty set, that the value of the match is the
value of the corresponding expression~\synt{\nt{expr}_1}.
Otherwise, $v$ is a non-empty set, then let $v_e$ be some element in~$v$
and $v_r$ be the set~$v$ minus the element~$v_e$.
The value of the match is the value of \synt{\nt{expr}_2} in a context
where \synt{\nt{id}_1} is bound to~$v_e$ and \synt{\nt{id}_2} is bound
to~$v_r$.

The construct also also applies to primitive event sets and relations.
If the matched expression is non-empty, then the bound element is an event
and an element of relation, respectively. One easily rebuilds an event set
(or a relation) for instance by using the singleton construct as
\synt{\T{\{} \NT{id}_1 \T{\}}}.

\subsubsection*{Parenthesised expressions}
The expression \synt{\T{(}\NT{expr}\T{)}}
has the same value as \synt{\NT{expr}}.
Notice that a parenthesised expression
can also be written as  \synt{\T{begin} \NT{expr} \T{end}}.

\subsection{\label{language:instruction}Instructions}
Instruction are executed for their  effect.
There are three kinds of effects: adding new bindings,
checking a condition, and specifying relations that are shown in pictures.
\begin{syntax}
\NT{instruction} \is{}  \T{let} \boption{} \T{rec} \eoption \NT{binding} \brepet{} \T{and} \NT{binding} \erepet{}
\alt \boption \T{flag} \eoption \NT{check} \NT{expr} \boption \T{as} \NT{id}\eoption
\alt \T{enum} \NT{id} \T{=} \boption \T{||} \NT{tag}
\brepet \T{||} \NT{tag} \erepet
\alt \T{procedure} \NT{id} \NT{pat} \T{=} \brepet \NT{instruction} \erepet \T{end}
\alt \T{call} \NT{id} \NT{expr}  \boption \T{as} \NT{id}\eoption
\alt \T{show} \NT{expr} \T{as} \NT{id}
\alt \T{show} \NT{id} \brepet \T{,} \NT{id} \erepet
\alt \T{unshow} \NT{id} \brepet \T{,} \NT{id} \erepet
\alt \T{forall} \NT{id} \T{in} \NT{expr} \T{do} \brepet{} \NT{instruction} \erepet \T{end}
\alt \T{with} \NT{id} \T{from} \NT{expr}
\alt \T{include} \nt{string}
\alt \T{if} \T{variant} \nt{string}  \brepet \NT{instruction} \erepet \boption \T{else} \brepet \NT{instruction} \erepet \eoption \T{end}
\sep
\NT{check} \is \NT{checkname} \orelse \T{\textasciitilde} \NT{checkname}
\sep
\NT{checkname} \is \T{acyclic} \orelse \T{irreflexive} \orelse \T{empty}
\end{syntax}

\subsubsection*{Bindings}
The \T{let} and \T{let}~\T{rec} constructs bind value names for the rest
of model execution.
See the subsection on \ahrefloc{bindings}{bindings}
in Section~\ref{language:expression}
for additional information on the syntax and semantics of bindings.


Recursive definitions computes fixpoints of relations.
For instance, the following fragment computes the transitive closure of
all communication relations:
\begin{verbatim}
let com = rf | co | fr
let rec complus = com | (complus ; complus)
\end{verbatim}
Notice that the instruction \verb-let complus = (rf|co|fr)+- is equivalent.
Notice that \herd{} assumes that recursive definitions are well-formed,
\emph{i.e.} that they yield an increasing functional.
The result of ill-formed definitions is undefined.

Although \herd{} features recursive functions, those cannot be used
to compute a transitive closure, due to the lack of some construct
say to test relation equality. Nevertheless, one can
write a generic transitive closure
function by using a local recursive binding:
\begin{verbatim}
let tr(r) = let rec t = r | (t;t) in t
\end{verbatim}
Again, notice that the instruction \verb-let tr (r) = r+- is equivalent.

Thanks to pattern matching constructs,
recursive functions are useful to compute over sets (and tags).
For instance here is the definition of a function \texttt{power} that compute
power sets:
\begin{verbatim}
let rec power S = match S with
|| {} -> { {} }
|| e ++ S ->
    let rec add_e RR = match RR with
    || {} -> { }
    || R ++ RR -> R ++ (e ++ R) ++ add_e RR
    end in
    add_e (power S)
end
\end{verbatim}

\subsubsection*{\label{sec:check}Checks}
The construct
\begin{center}\synt{\NT{check} \NT{expr}}\end{center}
evaluates \nt{expr} and applies the check \nt{check}.
There are six checks: the three basic acyclicity (keyword~\T{acyclic}),
irreflexivity (keyword~\T{irreflexive})
and emptyness (keyword~\T{empty}); and their
negations.
If the check succeeds, execution goes on. Otherwise, execution stops.

\label{name:check:def}The performance of a
check can optionally be named  by appending
\synt{\T{as} \NT{id}} after it.
The feature permits not to perform some checks at user's will,
thanks to the \ahrefloc{skipchecks}{\opt{-skipchecks~}\nt{id}}
command line~option.

A check can also be flagged, by prefixing it with the \T{flag}
keyword. Flagged checks must be named with the \T{as} construct.
Failed flagged checks do \emph{not} stop execution.
Instead successful flagged checks are recorded under their name,
for \herd{} machinery to handle flagged executions later.
Flagged checks are useful for models that define conditions
over executions that impact the semantics of the whole program.
This is typically the case of data races.
Let us assume that some relation \verb+race+ has been defined,
such that an non-empty \verb+race+ relation in  some execution
would make the whole program undefined. We would then write:
\begin{verbatim}
flag ~empty race as undefined
\end{verbatim}
Then, \herd{} will indicate in its output that some
execution have been flagged as \verb+undefined+.

\subsubsection*{Procedure definition and call}
Procedures are similar to functions except that they have no results:
the body of a procedure is a list of instructions
and the procedure will be called for the effect of executing
those instructions. Intended usage of procedures is to define checks
that are executed later. However, the body of a procedure may
consist in any kind of instructions.
Notice that procedure calls can be named with the \T{as} keyword.
The intention is to control the performance of procedure calls
from  the command line, exactly as for checks (see
\ahrefloc{name:check:def}{above}).


As an example of procedure,
one may define the following \verb+uniproc+ procedure with
no arguments:
\begin{verbatim}
procedure uniproc() =
  let com = fr | rf | co in
  acyclic com | po
end
\end{verbatim}
Then one can perform the acyclicity check (see
\ahrefloc{sec:check}{previous section}) by executing the instruction:
\begin{verbatim}
call uniproc()
\end{verbatim}
As a result the execution will stop if the acyclicity check fails,
or continue otherwise.

Procedures are lexically scoped as functions are.
Additionally, the bindings performed during the execution of a procedure call
are discarded when the procedure returns, all other effects performed
(namely flags and shows) are retained.

\subsubsection*{Show (and unshow) directives}
\label{show:def}The constructs:
\begin{center}
\synt{\T{show} \NT{id} \brepet \T{,} \NT{id} \erepet}\quad{and}\quad\synt{\T{unshow} \NT{id} \brepet \T{,} \NT{id} \erepet}
\end{center}
take (non-empty, comma separated) lists of identifiers as arguments.
The \T{show} construct adds the present values of identifiers for being
shown in pictures.
The \T{unshow} construct removes the identifiers from shown relations.

The more sophisticated construct
\begin{center}\synt{\T{show} \NT{expr} \T{as} \NT{id}}\end{center}
evaluates \nt{expr} to a relation, which will be shown in pictures with
label~\nt{id}.
Hence  \synt{\T{show} \nt{id}} can be viewed as a shorthand
for \synt{\T{show} \nt{id} \T{as} \nt{id}}

\subsubsection*{Iteration over sets}
The \T{forall} iteration construct
permits the iteration of checks (in fact of any kind of instructions)
over a set. Syntax is:
\begin{center}
\T{forall} \NT{id} \T{in} \NT{expr} \T{do} \nt{instructions} \T{end}
\end{center}
The expression \synt{\nt{expr}} must evaluate to a set~$S$.
Then, the list of instructions \nt{instructions} is executed
for all bindings of the name~\nt{id} to some element of~$S$.
In practice, as failed checks stop execution, this amounts
to check the conjunction of the checks performed by \nt{instructions}
for all the elements of~$S$.
Similarly to procedure calls,
the bindings performed during the execution of an iteration
are discarded at iteration ends, all other effects performed are
retained.

\subsubsection*{Candidate execution extension}
This construct permits the extension of the current candidate
execution by one binding.
Syntax is \synt{\T{with} \NT{id} \T{from} \NT{expr}}.
The expression \nt{expr} is evaluated to a set~$S$.
Then the remainder of the model is executed for each choice
of element~$e$ in~$S$ in a context extended by a binding
of the name~\nt{id} to~$e$.
An example of the construct usage is described in Sec.~\ref{intro:with}.

\subsubsection*{Model inclusion}
The construct \synt{\T{include} \T{"}\nt{filename}\T{"}} is interpreted as
the inclusion of the model contained in the file whose name is given as
an argument to the \synt{\T{include}} instruction.
In practice, the list of intructions defined by the included model file
are executed.
The string argument is delimited by double quotes ``\verb+"+'',
which, of course, are not part of the filename.
Files are searched according to \herd{} rules --- see Sec.~\ref{herd:searchpath}.

Inclusion is performed only \emph{once}. Subsequent \synt{\T{include}} instructions
are not executed and a warning is issued.

\subsubsection*{Conditional execution}
The conditional instruction allows some control over model execution by setting variants.
\ahrefloc{opt:variant}{Variants} are predefined tags set on the
command line or in configuration files.

The
construct \synt{\T{if} \T{variant} \T{"}\nt{tag}\T{"} \nt{instructions}_1 \T{else} \nt{instructions}_2 \T{end}}
behaves as follows: if the variant \textit{tag} is set, then the
(possibly empty) list of instructions \synt{\nt{instructions}_1} is
executed, otherwise the (optional, possibly empty) list of
instructions \synt{\nt{instructions}_2} is executed. If \textit{tag}
is not a recognised variant tag, a warning is issued and the
non-existent variant is assumed to~be~unset.


\subsection*{\label{sec:bell}Bell extensions}

Users can attain more genericity in their models by defining a {\tt bell} file,
as an addendum, or rather preamble, to a {\tt cat} file.

\subsubsection*{\label{sec:enum}Enumerations}
The \T{enum} construct defines a set of enumerated values or tags. Syntax is
\begin{center}
\synt{\T{enum} \NT{id} \T{=} \NT{tag}_1 \T{||} \cdots \T{||} \NT{tag}_n}
\end{center}
The construct has two main effects.
It first defines the tags \synt{\nt{tag}_1,\ldots,\nt{tag}_n}.
Notice that tags do not exist before being defined, that is
evaluating the expression \nt{tag} is an error without a prior
\T{enum} that defines the tag~\nt{tag}. Tags are typed in the sense
that they belong to the tag type \nt{id} and that tags from
different types cannot be members of the same set.
The second effect of the construct is to define a set of tags~\nt{id}
as the set of all tags listed in the construct.
That is, the \T{enum} construct performs the binding of~\nt{id}
to \synt{\T{\{} \nt{tag}_1,\ldots,\nt{tag}_n\T{\}}}.

\emph{Scopes} are a special case of enumeration: the construct {\tt enum
scopes} must be used to define hierarchical models such as Nvidia GPUs.
% (see e.g.~\cite{abd15}).

An {\tt enum scopes} declaration must be paired with two functions {\tt narrower} and {\tt wider} that implement the hierarchy amongst scopes. For example:

\begin{verbatim}
enum scopes = 'discography || 'I || 'II || 'III || 'IV

let narrower(t) = match t with
  || 'discography -> {'I, 'II, 'III, 'IV}
end

let wider(t) = match t with
  || 'I -> 'discography
  || 'II -> 'discography
  || 'III -> 'discography
  || 'IV -> 'discography
end
\end{verbatim}

Here we define five scopes, where the first one, {\tt discography}, is wider
than all the other ones.

\subsubsection*{Instructions}
The predefined sets of events \textrel{W}, \textrel{R}, \textrel{RMW},
\textrel{F}, and \textrel{B} can be \emph{annotated} with user-defined tags
(see Sec.~\ref{sec:enum}).

The construct :

\begin{center}
\T{instructions}\NT{id}\T{[}\NT{taglist}  \T{]}
\end{center}

takes the identifier of a pre-defined set and a possibly empty, square bracketed
list of tags.

%jade@Luc: du coup il faudrait peut etre les distinguer dans la def des
%expressions?
The primitive {\tt tag2instrs} yields, given a tag {\tt 't}, the set of
instructions bearing the annotation {\tt t} that was previously declared in an
enumeration type.
%\fixme{jade: enumeration type? c'est comme ca que ca se dit?}

The primitive {\tt tag2scope} yields, given a tag {\tt 't}, the relation
between instructions TODO

\subsection{\label{language:model}Models}
\begin{syntax}
\NT{model} \is \boption \NT{id} \eoption \boption \NT{model-comment} \eoption \brepet \NT{instruction} \erepet
\sep
\NT{model-comment} \is \NT{id} \orelse  \nt{string}
\end{syntax}
A model is a list of instructions preceded by an optional architecture
specification and an optional comment.
Architecture specification is a name that follows  \herd{} conventions for identifiers. Identifiers that are not valid architecture names, such as \texttt{AArch64}, \texttt{PPC} etc., are silently ignored.
The following \synt{\NT{model-comment}} can be either a name or a string enclosed in double quotes~``\verb+"+''.
If only one name is present, it will act both as tentative architecture specification and as a comment.
When present, model architecture specifications will be checked against test architectures, see also option~\ahrefloc{opt:archcheck}{\opt{-archcheck}}.


Models operate on candidate executions
(see Sec.~\ref{sec:predef}),
instructions are executed in sequence,
until one instruction stops, or until the end of the instruction list.
In that latter case, the model accepts the execution.
The accepted execution is then passed over to the rest of \herd{}
engine, in order to collect final states of locations
and to display pictures. Notice that the \synt{\NT{model-comment}} will appear
in those picture legends.

\iffalse
\subsubsection*{Model options}

Model options control some experimental features of \herd.
More precisely, by default, \herd{} includes a complete
coherence order relation in every candidate execution,
and does not represent initial writes by plain memory
write events. Said otherwise, by default,
model files have options \T{withco} and \T{whithoutinit}.

The generation of all possible coherence orders by \herd{} engine
is a source of inefficiency that can be alleviated by having the
model itself compute the sub-relation of \texttt{co} that is really useful.
Such models must have option \T{withoutco}, so as to
prevent \herd{} engine from generating all coherence orders.
Instead, \herd{} will represent initial writes as plain write events
(\emph{i.e.} option \T{withoutco} implies \T{withinit})
identify last writes in coherence oders, and pass the model a
reduced~\texttt{co} relation, named \texttt{co0}, that will,
for any memory location~$x$,
relate the initial write to~$x$ to all writes to~$x$, and all writes
to~$x$ to the final write to~$x$.
It is then the model responsability  to compute the remainder
of \texttt{co} from the program read events.
The model \ahref{uniproccat.txt}{\texttt{uniproccat.cat}} from the distribution
gives an example of such an advanced model.

The option \T{withinit} can also be given alone so as to instruct
\herd{} engine to represent initial writes as plain write events.
In such a situation, \herd{} will compute complete coherence
orders~\texttt{co} that include those explicit initial writes as
minimal elements.
Observe that the representation of initial writes as events
can be also controlled from the
command-line (see option~\ahrefloc{opt:initwrites}{\opt{-initwrites}})
and that command line settings override model options.
\fi

\subsection{\label{sec:primitive}Primitives}

TODO:

\subsection{\label{sec:library}Library}

\subsubsection*{Standard library}
The standard library is a \cat{} file~\texttt{stdlib.cat}
which all models include by default.
It defines a a few convenient relations that are thus
available to all models.
\begin{idtable}
$\poloc$ & \po{} restricted to the same address &
events are in \po{} and touch the same address, namely $\po \cap \locr$\\
$\rfe$ & external read-from & read-from by different threads, namely $\rf \cap \extr$\\
$\rfi$ & internal read-from & read-from by the same thread, namely $\rf \cap \intr$\\
\end{idtable}

\subsubsection*{Coherence orders}
\bgroup\let\rln\tid
For most models, a complete list of communication relations would
also include \co{} and~\fr{}.
Those can be defined by including the file \texttt{cos.cat}
(see Sec.~\ref{sec:cos}).
\begin{idtable}
$\co$    & coherence     & total strict order over writes to the same address \\
$\fr$    & from-read     & links a read $r$ to a write $w'$ $\co$-after the write $w$ from which $r$ takes its value \\
\coi, \fri & internal communications &
communication between events of the same thread\\
\coe, \fre & external communications &
communication between events of different threads
\end{idtable}
Notice that the internal and external sub-relations of \co{} and~\fr{}
are also defined.
\egroup

\subsubsection*{Fences}
\bgroup\let\rln\tid
Fence relations denote the presence of a specific
fence (or barrier) in-between two events.
Those can be defined by including architecture specific files.
\begin{desctable}{file}{relations}
x86fences.cat &  \mfence{}, \sfence, \lfence{}\\
ppcfences.cat &  \sync, \lwsync, \eieio, \isync, \ctrlisync{}\\
armfences.cat & \dsb, \dmb, \dsbst, \dmbst, \isb{}, \ctrlisb{}\\
mipsfences.cat & \sync\\
aarch64fences.cat & \ldots
\end{desctable}
In other words, models for, say, ARM machines should include the following
instruction:
\begin{verbatim}
include "armfences.cat"
\end{verbatim}

Notice that for the Power (PPC) (resp. ARM) architecture,
an additional relation \ctrlisync{} (res. \ctrlisb) is defined.
The relation \ctrlisync{} reads control +\isync{}.
It means that the branch to the instruction that generates the
second event additionnaly contains
a \texttt{isync} fence preceeding that instruction.
For reference, here is a possible definition of \ctrlisync:
\begin{verbatim}
let ctrlisync  = ctrl & (_ * ISYNC); po
\end{verbatim}

One may define all fence relations by including the file
\texttt{fences.cat}. As a result, fence relations that are
relevant to the architecture of the test being simulated  are properly defined,
while irrelevant fence relations are the empty relation.
This feature proves convenient for writing generic models that apply
to several concrete architectures.
\egroup



\section{Usage of \herd}

\subsection{Arguments}
The command \herd{} handles its arguments like \litmus.
That is, \herd{} interprets its argument as file names.
Those files are either a single litmus test
when having extension \file{.litmus}, or a list of file names
when prefixed by \file{@}.


\subsection{Options}
There are many command line options.
We describe the more useful ones:

\paragraph*{General behaviour}
\begin{description}
\item[{\tt -version}] Show version number and exit.
\item[{\tt -libdir}] Show installation directory and exit.
\item[{\tt -I <name>}] Add directory~\opt{name} at the end of
\prog{herd} \ahrefloc{herd:searchpath}{search path}. If the given directory
starts with \texttt{+} it is taken relative to \herd{} library directory.
\item[{\tt -v}] Be verbose, can be repeated to increase verbosity.
\item[{\tt -q}] Be quiet, suppress any diagnostic message.
\item[{\tt -conf <name>}] Read configuration file~\opt{name}.
\ahrefloc{herd:configfile}{Configuration files} have a very simple syntax:
a line ``\textit{opt}\texttt{  }\textit{arg}'' has the same effect as
the command-line option ``\texttt{-}\textit{opt} \textit{arg}''.
\item[{\tt -o <dest>}] Output files into directory \opt{<dest>}.
Notice that \opt{<dest>} must exist.
At the moment \herd{} may output one \texttt{.dot} file per processed test:
the file for test \textit{base}\texttt{.litmus}
is named  \textit{base}\texttt{.dot}.
By default \herd{} does not generate \texttt{.dot} files.
\item[{\tt -suffix <suf>}] Change the name of \texttt{.dot} files
into \textit{base}\textit{suff}\texttt{.dot}. Useful when several \texttt{.dot} files derive from the same test. Default is the empty string (no suffix).
\item[{\tt \aname{opt:gv}{-gv}}] Fork the \ahref{\urlgv}{\prog{gv} Postscript viewer} to display execution diagrams.
\item[{\tt \aname{opt:evince}{-evince}}] Fork the evince document viewer to display execution diagrams. This option provides an alternative to the
{\tt gv} viewer.
\item[{\tt -dumpes <bool>}]
Dump genererated event structures and exit. Default is \opt{false}.
Event structures will be dumped in a \texttt{.dot} file whose
name is determined as usual --- See options \opt{-o} and \opt{-suffix} above.
Optionally the event structures can be displayed with the \opt{-gv} option.
\item[{\tt -unroll <int>}] The setting \opt{-unroll }$n$ performs backwards
jumps $n$ times. This is a workaround for one of \herd{} main limitation:
\herd{} does not really handle loops. Default is~\opt{2}.
\item[{\tt -hexa <bool>}] Print numbers in hexadecimal. Default is \opt{false}
(numbers are printed in decimal).
\end{description}

\paragraph{Engine control}
The main purpose of \herd{} is to run tests on top of memory models.
For a given test, \herd{} performs a three stage process:
\begin{enumerate}
\item Generate candidate executions.
\item For each candidate execution, run the model.
The model may reject or accept the execution.
\item For each candidate execution that the model accepts,
record observed locations and, if so instructed,
a diagram of the execution.
\end{enumerate}
We now describe options that control those three stages.

\begin{description}
\item[{\tt -model (cav12|minimal|uniproc|<filename>.cat)}]
Select model, this option accept one tag or one file name
with extension~\texttt{.cat}.
Tags instruct \herd{} to select an internal model,
while file names are read for a model definition.
Documented model tags are:
\begin{itemize}
\item \opt{cav12}, the model of~\cite{mms12} (Power);
\item \opt{minimal}, the minimal model that allows all executions;
\item \opt{uniproc}, the uniproc model that checks single-thread correctness.
\end{itemize}

In fact, \herd{} accepts potentially infinitely many models,
as models can given in text files in an adhoc language described in
Sec.~\ref{herd:language}.
The \herd{} distribution includes several such models:
\afile{minimal.cat} and \afile{uniproc.cat}
are the text file versions of the homonymous internal models, but may
produce pictures that show different relations.
The \herd{} distribution also includes models for a variety of architectures
and several models for the C~language.
Model files are searched according to  the same
\ahrefloc{herd:searchpath}{rules}
as configuration files.
Some architectures have a default model:
\opt{arm.cat} model for ARM, \opt{ppc.cat} model for PPC,
\opt{x86tso.cat} for X86, and \opt{aarch64.cat} for AArch64 (ARMv8).

\item[{\tt -through (all|invalid|none)}]
Let additional executions reach the final stage of \herd{} engine.
This option permits users to generate pictures of forbidden executions, which
are otherwise rejected at an early stage of \herd{} engine --- see Sec.~\ref{show:forbidden}.
Namely, the default~``\opt{none}'' let only valid (according to the
active model) executions through.
The behaviour of this option differs between internal and text file models:
\begin{itemize}
\item For internal models:
the tag~\opt{all} let all executions go through;
while the tag~\opt{invalid} will reject executions that violate uniproc,
while letting other forbidden execution go through.
\item Text file models: the tags \opt{all} and~\opt{invalid} let all
executions go through. For such models, a more precise control over
executions that reach \herd{} final phase can be achieved
with the option~\opt{-skipcheck} --- see  next option.
\end{itemize}
Default is~\opt{none}.

\item[{\tt -skipchecks <\textit{name}$_1$,\ldots,\textit{name}$_n$>}]
\aname{skipchecks}{This option}
applies to text file models. It instructs \herd{} to ignore
the outcomes of the given checks. For the option to operate, checks must
be named in the model file with the \texttt{as }\textit{name} construct --
see Sec.~\ref{name:check:def}.
Notice that the arguments to \opt{-skipcheck} options cumulate.
That is, ``\opt{-skipcheck }\textit{name}$_1$ \opt{-skipcheck }\textit{name}$_2$'' acts like ``\opt{-skipcheck }\textit{name}$_1$\texttt{,}\textit{name}$_2$''.

\item [{\tt -strictskip <bool>}] Setting this option (\opt{-strictskip true}),
will change the behaviour of the previous option \opt{-skipcheck}:
it will let executions go through when the skipped checks yield
false and the unskipped checks yield true. This option comes handy
when one want to observe the executions that fail one (or several) checks
while passing others. Default is \opt{false}.

\item[{\tt -optace <bool>}] Optimise the axiomatic candidate execution stage.
When enabled by \opt{-optace true},  \herd{} does not generate candidate
executions that fail the uniproc test. The default is ``\opt{true}''
for internal models (except the minimal model), and ``\opt{false}'' for
text file models. Notice that \opt{-model uniproc.cat}
and \opt{-model minimal.cat -optace true} should yield identical results,
the second being faster.
Setting \opt{-optace true} can lower the execution time significantly,
but one should pay attention not to design models that forget the uniproc
condition.

\item[{\tt \aname{opt:archcheck}{-archcheck} <bool>}]
Control compatibily check of test and cat file
architecture. More precisely, some cat files are specific to an architecture.
Running tests of a different architecture on them will result in
cryptic error messages. In that situation, compatibility check will
yield a more understandable diagnostic. Default is~\opt{true}.

\item[{\tt \aname{opt:show}{-show} (prop|neg|all|cond|wit|none)}]
Select execution diagrams for picture display and generation.
Execution diagrams are shown according to
the final condition of test. The final condition is a quantified boolean
proposition \verb+exists +$p$, \verb+~exists +$p$, or \verb+forall +$p$.
The semantics of recognised tags is as follows:
\begin{itemize}
\item \opt{prop} Picture executions for which $p$ is true.
\item \opt{neg} Picture executions for which $p$ is false.
\item \opt{all}  Picture all executions.
\item \opt{cond} Picture executions that validate  the condition,
\emph{i.e.} $p$ is true for \verb+exists+ and \verb+forall+, and false
for \verb+~exists+.
\item \opt{wit} Picture ``\emph{interesting}'' executions,
\emph{i.e.} $p$ is true for \verb+exists+ and \verb+~exists+,
and false for \verb+forall+.
\item \opt{none} Picture no  execution.
\end{itemize}
Default is \opt{none}.

\item[{\tt \aname{opt:initwrites}{-initwrites}  <bool>}]
Represent init writes as plain write events, default is \opt{false} except
for specifically tagged generic models --- see ``Model options''
in Sec.~\ref{language:model}.

\item[{\tt \aname{opt:variant}{-variant} <\textit{tag}$_1$,\ldots,\textit{tag}$_n$>}]
Activate variation(s) of models. Most variations are minor change in instruction semantics,
are used for experimental purpose and remain undocumented. With the exception of tag
``\texttt{mixed}'' that command mixed-size mode. Mixed-size mode is appropriate for mixed-size
tests that performs accesses of different sizes, as well as indexed accesses.

\end{description}

\paragraph*{Discard some observations}
Those options intentionally omit some of the final states that \herd{} would
normally generate.

\begin{description}
\item[{\tt -speedcheck (false|true|fast)}]
\aname{speedcheck:opt}{When} enabled by \opt{-speedcheck true}
or \opt{-speedcheck fast}, attempt to settle the test condition.
That is, \herd{} will
generate a subset of executions (those named ``\emph{interesting}'' above)
in place of all executions.
With setting \opt{-speedcheck fast},
\herd{} will additionally stop as soon as a condition \verb+exists +$p$ is validated, and as soon as a condition \verb+~exists +$p$ or
\verb+forall +$p$ is invalidated. Default is \opt{false}.

\item[{\tt -nshow <int>}]
Stop once \verb+<int>+ pictures have been collected. Default is to
collect all (specified, see option \ahrefloc{opt:show}{\opt{-show}}) pictures.
\end{description}

\paragraph*{Control \texttt{dot} pictures}
These options control the content of DOT images.

We first describe options that act at the general level.
\begin{description}
\item[{\tt -graph (cluster|free|columns)}] Select main mode for graphs.
See Sec.~\ref{mode:example}. The default is \opt{cluster}.
\item[{\tt -dotmode (plain|fig)}] The setting \opt{-dotmode fig}
produces output that includes the proper escape
sequence for translating \texttt{.dot} files
to \texttt{.fig} files (\emph{e.g.} with \texttt{dot -Tfig\ldots}).
Default is \opt{plain}.
\item[{\tt -dotcom (dot|neato|circo)}] Select the command that formats
graphs displayed by the \ahrefloc{opt:gv}{\opt{-gv}} option.
The default is \opt{dot} for the \opt{cluster} and~\opt{free} graph modes,
and \opt{neato} for the \opt{columns} graph mode.

\item[{\tt -showevents (all|mem|noregs)}] Control which events are
pictured:
\begin{itemize}
\item \opt{all} Picture all events.
\item \opt{mem} Picture memory events.
\item \opt{noregs} Picture all events except register events,
\emph{i.e.} memory, fences and branch events.
\end{itemize}
Default is \opt{noregs}.

\item[{\tt -showinitwrites <bool>}] Show initial write events
(when existing, see option~\ahrefloc{opt:initwrites}{-initwrites})
in pictures. Default is \opt{true}.

\item[{\tt -mono <bool>}] The setting \opt{-mono true} commands monochrome
pictures. This option acts upon default color selection. Thus, it
has no effect on colors given explicitely with the
\ahrefloc{opt:edgeattr}{\opt{-edgeattr}} option.

\item[{\tt -scale <float>}]
Global scale factor for graphs in \opt{columns} mode.
Default is \opt{1.0}.
\item[{\tt -xscale <float>}]
Global scale factor for graphs in \opt{columns} mode, x direction.
Default is \opt{1.0}.
\item[{\tt -yscale <float>}]
Global scale factor for graphs in \opt{columns} mode, y direction.
Default is \opt{1.0}.
\item[{\tt -showthread <bool>}] Show thread numbers in figures.
In \opt{cluster} mode where the events of a thread are clustered,
thread cluster have a label.
In \opt{free} mode \textrel{po} edges are suffixed by a thread number.
In \opt{columns} mode,  columhs have a header node that shows
the thread number. Default is~\opt{true}.
\item[{\tt -texmacros <bool>}] Use latex commands in some text of pictures.
If activated (\opt{-showthread true}), thread numbers are shown as
\verb+\myth{+$n$\verb+}+. Assembler instructions are locations in nodes
are argument to an \verb+\asm+ command. It user responsability to define
those commands in their \LaTeX{} documents that include the pictures.
Possible definitions are \verb+\newcommand{\myth}[1]{Thread~#1}+
and \verb+\newcommand{\asm}[1]{\texttt{#1}}+.
Default is~\opt{false}.
\end{description}

A few options control picture legends.
\begin{description}
\item[{\tt -showlegend <bool>}]
Add a legend to pictures. By default legends show the test name and
a comment from the executed model.
This comment is the first item
of model syntax  --- see Sec~\ref{language:model}.
Default is~\opt{true}.
\item[{\tt -showkind <bool>}]
Show test kind in legend.
The kind derive from the quantifier of test final condition,
kind \texttt{Allow} being \verb+exists+,
kind \texttt{Forbid} being \verb+~exists+,
and kind \texttt{Require} being \verb+forall+.
Default is~\opt{false}.
\item[{\tt -shortlegend <bool>}]
Limit legend to test name. Default is~\opt{false}.
\end{description}

A few options control what is shown in nodes
and on their sizes, \emph{i.e.}
on how events are pictured.
\begin{description}
\item[{\tt -squished <bool>}] The setting \opt{-squished true} drastically
limits the information displayed in graph nodes. This is usually what
is wanted in modes \opt{free} and~\opt{columns}. Default is~\opt{false}.
\item[{\tt -fixedsize <bool>}] This setting is meaningfull in
\opt{columns} graph mode and for squished nodes. When set by
\opt{-fixedsize true} it forces node width to be $65\%$ of the space
between columns. This may sometime yield a nice edge routing. Default is~\opt{false}
\item[{\tt -extrachars <float>}] This setting is meaningful in
\opt{columns} graph mode and for squished nodes.
When the size of nodes is not fixed (\emph{i.e.} \opt{-fixedsize false} and default), \herd{} computes the width of nodes by counting caracters in node
labels and scaling the result by the font size.
The setting \opt{-extrachars~}$v$ commands adding the value $v$ before scaling.
Negative values are of course accepted. Default is \opt{0.0}.
\item[{\tt -showobserved <bool>}] Highlight observed memory read events with
stars ``\texttt{*}''. A memory read is observed when the value it reads
is stored in a register that appears in final states.
Default is~\opt{false}.
\item[{\tt -brackets <bool>}] Show brackets around locations. Default
is~\opt{false}.
\end{description}

Then we list options that offer some control on which edges are shown.
We recall that the main controls over the shown and unshown edges are
the \verb+show+ and \verb+unshow+ directives in model definitions ---
see Sec.~\ref{show:def}.
However, some edges can be controled only with options (or configuration
files) and the \opt{-unshow} option proves convenient.
\begin{description}
\item[{\tt -showpo <bool>}] Show program order (\textrel{po}) edges.
Default is~\opt{true}.
Default is~\opt{false}.
\item[{\tt -showinitrf <bool>}] Show read-from edges from initial state.
Default is~\opt{false}.
\item[{\tt -showfinalrf <bool>}] Show read-from edges to the final state,
\emph{i.e} show the last store to locations. Default is~\opt{false}.
\emph{i.e} show the last store to locations. Default is~\opt{false}.
\item[{\tt -showfr <bool>}] Show from-read edges. Default is~\opt{true}.
\item[{\tt \aname{opt:doshow}{-doshow} <\textit{name}$_1$,\ldots,\textit{name}$_n$>}]
Do show edges labelled with \textit{name}$_1$,\ldots,\textit{name}$_n$.
This setting applies when names are bound in model definition.
\item[{\tt -unshow <\textit{name}$_1$,\ldots,\textit{name}$_n$>}]
Do not show edges labelled with \textit{name}$_1$,\ldots,\textit{name}$_n$.
This setting applies at the very last momement and thus cancels any
\verb+show+ directive in model definition and any \opt{-doshow} command
line~option.
\end{description}
Other options offer some control over some of the attributes defined in
\ahref{\urlgraphviz}{Graphviz software} documentation.
Notice that the controlled attributes are omitted from DOT files
when no setting is present.
For instance in the absence of a \opt{-spline <tag>} option, \herd{}
will generate no definition for the \texttt{splines} attribute thus
resorting to DOT tools defaults.
Most of the following
options accept the \opt{none}~argument that restores their
default behaviour.
\begin{description}
\item[{\tt -splines (spline|true|line|false|polyline|ortho|curved|none)}]
Define the value of the \texttt{splines} attribute. Tags are replicated in
output files as the value of the attribute, except for \opt{none}.
\item[{\tt -margin <float|none>}] Specifies the \texttt{margin} attribute of graphs.
\item[{\tt -pad <float|none>}] Specifies the \texttt{pad} attribute of graphs.
\item[{\tt -sep <string|none>}] Specifies the \texttt{sep} attribute of graphs.
Notice that the argument is an arbitray string, so as to allow DOT general
syntax for this attribute.
\item[{\tt -fontname <string|none>}] Specifies the graph fontname attribute.
\item[{\tt -fontsize <int|none>}] Specifies the fontsize attribute~$n$ of all
text in the graph.
\item[{\tt -edgefontsizedelta <int>}] option \opt{-edgefontsizedelta }$m$ sets
the fontsize attributes of edges to $n+m$, where $n$ is the argument to
the \opt{-fontsize} option. Default is \opt{0}. This option has  no effect if
fontsize is unset.
\item[{\tt -penwidth <float|none>}] Specifies the \texttt{penwidth} attribute of
edges.
\item[{\tt -arrowsize <float|none>}] Specifies the \texttt{arrowsize}
attribute of edges.
\item[{\tt \aname{opt:edgeattr}{-edgeattr} <label,attribute,value>}]
Give value \opt{value} to attribute \opt{attribute}  of all edges labelled
\opt{label}. This powerful option  permits alternative styles for edges.
For instance, the \textrel{ghb} edges of the diagrams of this document
are thick purple (blueviolet) arrows thanks to the settings:
\opt{-edgeattr ghb,color,blueviolet}
\opt{-edgeattr ghb,penwidth,3.0}
\opt{-edgeattr ghb,arrowsize,1.2}. Notice that the settings performed
by the \opt{-edgeattr} option override other settings.
This option has no default.
\end{description}

\paragraph*{Change input}
Those options are the same as the ones
of~\litmus{} --- see Sec.~\ref{change:input}.

\begin{description}
\item[{\tt -names <file>}] Run \herd{} only on tests whose names are
listed in \texttt{<file>}.
\item[{\tt -rename <file>}] Change test names.
\item[{\tt -kinds <file>}] Change test kinds.
This amonts to changing the quantifier of final conditions, with
kind \texttt{Allow} being \verb+exists+,
kind \texttt{Forbid} being \verb+~exists+
and kind \texttt{Require} being \verb+forall+.
\item[{\tt -conds <file>}] Change the final condition of tests.
This is by far the most useful of these options:
in combination with option \opt{-show prop} it permits a fine grain
selection of execution pictures.
% --- see Sec.~\ref{example:invalid}.
\end{description}

\subsection{\label{herd:configfile}{Configuration files}}
The syntax of configuration files is minimal:
lines ``\textit{key} \textit{arg}'' are interpreted
as setting the value of parameter~\textit{key} to \textit{arg}.
Each parameter has a corresponding option,
usually \opt{-}\textit{key}, except for the single letter
option \opt{-v} whose parameter is \opt{verbose}.

As command line option are processed left-to-right,
settings from a configuration file (option \opt{-conf})
can be overridden by a later command line option.
Configuration files will be used mostly for controling pictures.
Some configuration files are
are present in the distribution.
As an example, here is the configuration file \afile{apoil.cfg},
which can be used to display images in \opt{free} mode.
\verbatiminput{apoil.cfg}
The configuration above is commented with line comments that starts
with ``\verb+#+''.
The above configuration file comes handy to eye-proof model output,
even for relatively complex tests, such as \atest{IRIW+lwsyncs}
and \atest{IRIW+syncs}:
\begin{verbatim}
% herd7 -conf apoil.cfg -show prop -doshow prop -gv IRIW+lwsyncs.litmus
% herd7 -through invalid -conf apoil.cfg -show prop -doshow prop -gv IRIW+syncs.litmus
\end{verbatim}
In the command lines above, \ahrefloc{opt:show}{\opt{-show prop}}
instructs \herd{} to produce images of the executions that validate
the final test condtion, while \ahrefloc{opt:doshow}{\opt{-doshow prop}}
instructs \herd{} to display the relation named ``\texttt{prop}''.
In spite of the unfortunate name clashes, those are not to be confused\ldots

We run the two tests on top of the default Power model that computes,
amongst others, a \texttt{prop} relation. The model rejects executions
with a cyclic \textrel{prop}.
One can then see that the relation \textrel{prop} is acyclic
for \ltest{IRIW+lwsyncs} and cyclic for \ltest{IRIW+syncs}:
\begin{center}\img{IRIW+lwsyncs+APOIL}\quad\quad\img{IRIW+syncs+APOIL}\end{center}
Notice that we used the option~\opt{-through invalid} in the case
of \ltest{IRIW+syncs} as we would otherwise have no image.


\subsection{\label{herd:searchpath}File searching}
Configuration and model files are searched first in the current directory;
then in the search path;
then in any directory specified
by setting the shell environment variable \texttt{HERDLIB};
and then in herd installation directory, which is defined
while compiling~\herd.

%\section{Extensions to Herd}
%
%\begin{quote}\it
%This section describes several extensions to \herd{} that have been implemented by Tyler Sorensen and John Wickerson in collaboration with the original authors. In due course, the contents of this section will probably be merged into the previous sections to form a cohesive manual.
%\end{quote}
%
%\subsection{Additional command line options}
%
%\begin{description}
%\item[{\tt \aname{opt:dumplem}{-dumplem}}] Convert the given herd model to Lem format, and exit. The resultant Lem file is generated on {\tt stdout}.
%\begin{quote}\emph{Note.} It is necessary to provide a litmus test when invoking \herd{} in this way, even though the litmus test will not be examined. This is due to a minor technical problem.\end{quote}
%\end{description}
%
%
%
%\subsection{Curried function application}
%
%A test-instruction is used to enforce a contract between the programming language and the programmer. There are two types: \emph{provided conditions} and \emph{undefined-unless conditions}. The latter are indicated with the \synt{\T{undefined\_unless}} keyword. A provided condition is an obligation on the programming language; that is, the programmer can assume that every execution of their program will satisfy every provided condition. An undefined-unless condition is an obligation on the programmer; that is, the compiler-writer can assume that every execution of the program will satisfy every undefined-unless condition. In other words, if a program has an execution that violates an undefined-unless condition, then its behaviour is completely undefined.

%The syntax for instructions thus becomes:
%
%\begin{syntax}
%\nt{instruction} \is{} \ldots
%\alt \T{undefined\_unless} \NT{check} \NT{expr} \boption \T{as} \NT{id}\eoption
%\end{syntax}

%\subsection{Additional identifiers}
%
%\begin{quote}\it
%This is an appendix to Section~\ref{language:identifier}.
%\end{quote}

%\paragraph*{Pre-defined relations}
%
%Here are some more pre-defined relations.
%\begin{idtable}
%{\tt unv}    & universal relation & relates every event in the structure to every other event %\\
%{\tt int-$s$} & internal at given scope & \emph{(applicable only to scoped memory models)} relates events that are in the same part of the execution hierarchy \\
%{\tt ext-$s$} & external at given scope & \emph{(applicable only to scoped memory models)} relates events that are in different parts of the execution hierarchy \\
%\end{idtable}
%Here, $s$ ranges over the following values:
%
%\begin{center}
%\begin{tabular}{ll}
%value of $s$ & description (in OpenCL terminology) \\
%\hline
%{\tt wi}, {\tt thread} & work-item \\
%{\tt sg}, {\tt warp} & sub-group \\
%{\tt wg}, {\tt block}, {\tt cta} & work-group \\
%{\tt kernel} & kernel \\
%{\tt dev} & device \\
%\end{tabular}
%\end{center}
%
%For example, {\tt int-cta} relates all events that are in the same work-group, while {\tt ext-wi} relates all events that are in different work-items (threads).
%
%We provide the following additional fence relations: \verb"membar.cta", \verb"membar.gl", \verb"membar.sys" (PTX). C++ and OpenCL fences do not appear in this list because those fences are modelled as events rather than relations. By modelling these fences as events, we are better able to attach parameters to them, such as the memory-order (C++ and OpenCL) and the memory-scope (OpenCL).
%
%In C++ models, the following relations are pre-defined.
%\begin{idtable}
%{\tt asw}    & additional synchronises-with & links every initial write to every event that is not an initial write \\
%{\tt lo}     & lock order & a total order on all mutex operations (similar to {\tt co}, but for mutexes instead of writes) \\
%\end{idtable}

%\paragraph*{Pre-defined sets}
%Here are some pre-defined sets, available in all models.
%\begin{idtable}
%{\tt \_}    & universal set & the set of all events in the structure \\
%{\tt R} & read events & set of all reads from memory \\
%{\tt W} & write events & set of all writes to memory \\
%{\tt M} & memory events & set of all reads from and writes to memory \\
%{\tt B} & barrier events & is a barrier \\
%{\tt A} & atomic events & is an atomic event \\
%{\tt P} & plain events & is not an atomic event \\
%{\tt I} & initial writes & is an initial write event \\
%\end{idtable}

%Having defined these sets, it is now possible to write expressions of the form {\tt RW($e$)} as {\tt [R * W] \& $e$}. However, the simulation in the latter case may be less efficient, owing to the need to construct the intermediate relation {\tt [R * W]}.

%In C++ and OpenCL models, the following sets are pre-defined.
%
%\begin{idtable}
%{\tt rmw} & read-modify-writes & the set of all read-modify-write events \\
%{\tt brmw} & blocked read-modify-writes & events representing an attempted read-modify-write operation that has become stuck \\
%{\tt F} & fences & the set of all fences \\
%{\tt acq} & acquire & atomic events with ``acquire'' memory-order \\
%{\tt rel} & release & atomic events with ``release'' memory-order \\
%{\tt acq\_rel} & acquire/release & atomic events with ``acquire/release'' memory-order \\
%{\tt rlx} & relaxed & atomic events with ``relaxed'' memory-order \\
%{\tt sc} & sequentially consistent & atomic events with ``sequentially consistent'' memory-order \\
%{\tt na} & non-atomics & non-atomic events \\
%\end{idtable}

%In C++ models, the following sets are pre-defined.
%
%\begin{idtable}
%{\tt lk} & locks & the set of all lock events \\
%{\tt ls} & successful locks & the set of all successful lock events \\
%{\tt ul} & unlocks & the set of all unlock events \\
%{\tt con} & consume & atomic events with ``consume'' memory-order \\
%{\tt atomicloc} & atomic locations & events acting on atomic locations \\
%{\tt nonatomicloc} & non-atomic locations & events acting on non-atomic locations \\
%{\tt mutexloc} & mutex locations & events acting on mutex locations \\
%\end{idtable}

%In OpenCL models, the following sets are pre-defined.
%
%\begin{idtable}
%{\tt gF} & global fences & the set of all global fences \\
%{\tt lF} & local fences & the set of all local fences \\
%{\tt wi} & work-item scope & events with ``work-item'' memory-scope \\
%{\tt sg} & sub-group scope & events with ``sub-group'' memory-scope \\
%{\tt wg} & work-group scope & events with ``work-group'' memory-scope \\
%{\tt dev} & device scope & events with ``device'' memory-scope \\
%{\tt all\_dev} & all-devices scope & events with ``all\_svn\_devices'' memory-scope \\
%\end{idtable}
