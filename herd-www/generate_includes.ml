(****************************************************************************)
(*                           the diy toolsuite                              *)
(*                                                                          *)
(* Jade Alglave, University College London, UK.                             *)
(* Luc Maranget, INRIA Paris-Rocquencourt, France.                          *)
(*                                                                          *)
(* Copyright 2019-present Institut National de Recherche en Informatique et *)
(* en Automatique and the authors. All rights reserved.                     *)
(*                                                                          *)
(* This software is governed by the CeCILL-B license under French law and   *)
(* abiding by the rules of distribution of free software. You can use,      *)
(* modify and/ or redistribute the software under the terms of the CeCILL-B *)
(* license as circulated by CEA, CNRS and INRIA at the following URL        *)
(* "http://www.cecill.info". We also give a copy in LICENSE.txt.            *)
(****************************************************************************)

let prog = Sys.argv.(0)

module StringMap = Map.Make(String)

let output_header () =
  Printf.printf
    "(* Warning: file generated by ./generate_includes.ml DO NOT EDIT *)\n\n"

let output_env fs =
  Printf.printf "let map_env = StringMap.empty\n" ;
  List.iter
    (fun (k,cts) ->
      Printf.printf
        "  |> StringMap.add %S %S\n" k cts)
    fs ;
  Printf.printf "\n" ;
  ()

let output_postlude () =
  let pp s = Printf.printf "%s\n" s in
  pp "let autoloader ~prefix ~path =" ;
  pp "  try" ;
  pp "    ignore (prefix) ; Some (StringMap.find path map_env)" ;
  pp "  with Not_found -> None" ;
  ()

let file_ok f =
  Filename.check_suffix f ".cat" ||
  Filename.check_suffix f ".bell" ||
  Filename.check_suffix f ".def" ||
  Filename.check_suffix f ".cfg" ||
  Filename.check_suffix f ".opn" ||
  Filename.check_suffix f ".asl"



let read_file f =
  let chan = open_in f in
  let len = in_channel_length chan in
  let cts = really_input_string chan len in
  close_in chan ;
  cts

let same_file d1 d2 f =
  let f1 = Filename.concat d1 f
  and f2 = Filename.concat d2 f in
  read_file f1 = read_file f2

let rec all_files do_rec m path d =
  assert (Sys.is_directory(d)) ;
  let fs = Sys.readdir d in
  let mr = ref m in
  for k=0 to Array.length fs-1 do
    let f = fs.(k) in
    let true_f = Filename.concat d f in
    if do_rec && Sys.is_directory true_f then
      mr := all_files do_rec !mr  (Filename.concat path f) true_f
    else if file_ok f then begin
        let key = Filename.concat path f in
        if  not (StringMap.mem key !mr) then begin
        mr := StringMap.add key d !mr
     end else
       let old = StringMap.find key !mr in
       if not (same_file old d f) then
         Printf.eprintf "%s ignored (%s already here)\n"
           (Filename.concat d f)  (Filename.concat old f)
    end
  done ;
  !mr

let bind d f =
  let g = Filename.concat d (Filename.basename f) in
  f,read_file g

let _ =
  let mr = ref StringMap.empty in
  let k0,do_rec =
    if Array.length Sys.argv < 2 then 1,false
    else
      match Sys.argv.(1) with
      | "-rec" -> 2,true
      | "-norec" -> 2,false
      | _ -> 1,true in
  for k = k0 to Array.length Sys.argv-1 do
    mr := all_files do_rec !mr "" Sys.argv.(k)
  done ;
  begin match Filename.basename prog with
  | "generate_includes.ml" ->
      let files =
        StringMap.fold
          (fun f d k -> bind d f::k)
          !mr [] in
      output_header () ;
      output_env files ;
      output_postlude ()
  | "generate_names.ml" ->
      let files =
        StringMap.fold
          (fun f d k -> Filename.concat d (Filename.basename f)::k)
          !mr [] in
      List.iter
        (fun f -> Printf.printf "%s\n" f)
        files
  | _ -> assert false
  end ;
  ()
