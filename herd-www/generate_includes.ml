let prog = Sys.argv.(0)

module StringMap = Map.Make(String)

let output_header () =
  Printf.printf
    "(* Warning: file generated by ./generate_includes.ml DO NOT EDIT *)\n\n"

let output_env fs =
  Printf.printf "let map_env = StringMap.empty\n\n" ;
  List.iter
    (fun (k,cts) ->
      Printf.printf
        "let map_env = StringMap.add %S %S map_env\n" k cts)
    fs ;
  Printf.printf "\n" ;
  ()

let output_postlude () =
  let pp s = Printf.printf "%s\n" s in
  pp "let autoloader ~prefix ~path =" ;
  pp "  try" ;
  pp "    ignore (prefix) ; Some (StringMap.find path map_env)" ;
  pp "  with Not_found -> None" ;
  ()

let file_ok f =
  Filename.check_suffix f ".cat" ||
  Filename.check_suffix f ".bell" ||
  Filename.check_suffix f ".def" ||
  Filename.check_suffix f ".cfg"

let all_files m d =
  assert (Sys.is_directory(d)) ;
  let fs = Sys.readdir d in
  let mr = ref m in
  for k=0 to Array.length fs-1 do
    let f = fs.(k) in
    if file_ok f && not (StringMap.mem f !mr) then begin
      mr := StringMap.add f d !mr
    end
  done ;
  !mr

let read_file f =
  let chan = open_in f in
  let len = in_channel_length chan in
  let cts = really_input_string chan len in
  close_in chan ;
  cts

let bind d f =
  let g = Filename.concat d f in
  f,read_file g

let _ =
  let mr = ref StringMap.empty in
  for k = 1 to Array.length Sys.argv-1 do
    mr := all_files !mr Sys.argv.(k)
  done ;
  begin match Filename.basename prog with
  | "generate_includes.ml" ->
      let files =
        StringMap.fold
          (fun f d k -> bind d f::k)
          !mr [] in
      output_header () ;
      output_env files ;
      output_postlude ()
  | "generate_names.ml" ->
      let files =
        StringMap.fold
          (fun f d k -> Filename.concat d f::k)
          !mr [] in
      List.iter
        (fun f -> Printf.printf "%s\n" f)
        files
  | _ -> assert false
  end ;
  ()
