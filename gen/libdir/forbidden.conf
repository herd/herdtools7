# The Armv8 Application Level Memory Model.
#
# This is a machine-readable, executable and formal artefact, which aims to
# generate systematic families of litmus tests which are forbidden by the Arm
# memory model.
# If you have comments on the content of this file, please send an email to
# jade.alglave@arm.com, referring to version number:
# 9470edab1356b1d824422808bf681d59529e8b91
#
# For the executable formal Armv memory model, see:
# https://developer.arm.com/architectures/cpu-architecture/a-profile/memory-model-tool
# For a textual version of the model, see section B2.3 of the Armv8 ARM:
# https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile
#
# Author: Will Deacon <will.deacon@arm.com>
# Author: Jade Alglave <jade.alglave@arm.com>
#
# Copyright (C) 2016-2020, Arm Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#     * Neither the name of ARM nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-arch AArch64
-nprocs 2
-size 6
# the generated file name is in format `Armv8-ext-forbidden********.litmus`,
# where `********` are 8 digit numbers.
-name Armv8-ext-forbidden
-fmt 8
# present value in hex
#-hexa
# If only want to generate cycles rather than litmus tests
#-cycleonly true

# If `-relax` is enabled, tests will be required to have a relaxation from the list specified as its argument.
#-relax {RELAX_LIST}


# let ca = fr | co
# let Exp-obs =
#   [Exp & M]; rf & ext; [Exp & M]
#   | [Exp & M]; ca & ext; [Exp & M]
-safe ExpObs

#let Exp-haz-ob = [Exp & R]; (po & same-loc); [Exp & R]; (ca & ext); [Exp & W]
-safe [PosRR Fre]

#let lwfs = [Exp & M | Imp & Tag & R]; (po & same-loc); [Exp & W]
-safe Pos*W
-safe [Pos*R Amo.Swp] [Pos*R Amo.Cas] [Pos*R Amo.StAdd] [Pos*R Amo.LdAdd] [Pos*R LxSx]

### Data and address dependance
# let data = [Exp & R]; (basic-dep; [DATA]; iico_data+; [Exp & W]) & ~same-instance
# let dob = data
-safe DpDatadW
# `DpDatasW` is stronger than `Pos*W`.
#-safe DpDatasW

# let addr = [Exp & R]; (basic-dep; [ADDR]; iico_data+; [Exp & M | Imp & Tag & R | Imp & TTD & R | HU | TLBI | DC.CVAU | IC.IVAU]) & ~same-instance
# let dob = addr
-safe DpAddrd* DpAddrsR
# `DpAddrsW` is stronger than `Pos*W`.
#-safe DpAddrsW

# let ctrl = [Exp & R]; basic-dep; [BCC]; po
# let dob = ctrl; [Exp & W | HU | TLBI | DC.CVAU | IC]
-safe [DpCtrldW ExpObs]
# `DpCtrlsW` is stronger than `Pos*W`.
#-safe DpCtrlsW
-safe [DpCtrldR Amo.Cas] [DpCtrldR Amo.Swp] [DpCtrldR Amo.StAdd] [DpCtrldR Amo.LdAdd] [DpCtrldR LxSx]
#`[DpCtrlsR rmw]` is stronger than `Pos*W`.
#-safe [DpCtrlsR Amo.Cas] [DpCtrlsR Amo.Swp] [DpCtrlsR LxSx]

# let dob = addr; [Exp & M]; po; [Exp & W | HU]
-safe [DpAddr Pod*W] [DpAddrd* Pos*W]
# `[DpAddrs* Pos*W]` are stronger than `Pos*W` as the former are a read followed by a write to the same location.
#-safe [DpAddrs* Pos*W]
-safe [DpAddr*R Amo.Swp PodWW]
-safe [DpAddr*R Amo.Cas PodWW]
-safe [DpAddr*R Amo.StAdd PodWW]
-safe [DpAddr*R Amo.LdAdd PodWW]
-safe [DpAddr*R LxSx PodWW]
# `[DpAddrdR rmw PosWW]` can be combined by `diy` as `[DpAddrdR rmw]` and `PosWW`
-safe [DpAddrd* Po**R Amo.Swp] [DpAddrs* Pod*R Amo.Swp]
-safe [DpAddrd* Po**R Amo.Cas] [DpAddrs* Pod*R Amo.Cas]
-safe [DpAddrd* Po**R Amo.StAdd] [DpAddrs* Pod*R Amo.StAdd]
-safe [DpAddrd* Po**R Amo.LdAdd] [DpAddrs* Pod*R Amo.LdAdd]
-safe [DpAddrd* Po**R LxSx] [DpAddrs* Pod*R LxSx]
# `[DpAddrs* Pos*R rmw]` is stronger than `Pos*W`.

# let dob = addr; [Exp & M]; lmrs; [Exp & R | Imp & Tag & R]
# let lmrs = [W]; ((po & same-loc) & ~(intervening(W,(po & same-loc)))); [R]
-safe [DpAddr*W PosWR]
-safe [DpAddrdR Amo.Swp PosWR] [DpAddrsR Amo.Swp PosWR]
-safe [DpAddrdR Amo.Cas PosWR] [DpAddrsR Amo.Cas PosWR]
-safe [DpAddrdR Amo.StAdd PosWR] [DpAddrsR Amo.StAdd PosWR]
-safe [DpAddrdR Amo.LdAdd PosWR] [DpAddrsR Amo.LdAdd PosWR]
-safe [DpAddrdR LxSx PosWR] [DpAddrsR LxSx PosWR]

# let dob = data; [Exp & M]; lmrs; [Exp & R | Imp & Tag & R]
# let lmrs = [W]; ((po & same-loc) & ~(intervening(W,(po & same-loc)))); [R]
-safe [DpData*W PosWR]

# let ctrl = [Exp & R]; basic-dep; [BCC]; po
# let IFB-ob = [Exp & R]; ctrl; [IFB]; po
# let IFB = ISB | EXC-ENTRY-IFB | EXC-RET-IFB
-safe [DpCtrld* ISB ExpObs] [DpCtrlsR ISB ExpObs]
# [DpCtrlsW ISB] is stronger than `Pos*W`
#-safe [DpCtrlsW ISB]

# let IFB-ob = [Exp & R]; pick-ctrl-dep; [IFB]; po
# let IFB = ISB | EXC-ENTRY-IFB | EXC-RET-IFB
-safe [DpCtrlCseld* ISB ExpObs] [DpCtrlCselsR ISB ExpObs]
# [DpCtrlCselsW ISB] is stronger than `Pos*W`
#-safe [DpCtrlCselsW ISB]

# let IFB-ob = [Exp & R]; addr; [Exp & M]; po; [IFB]; po
-safe [DpAddr*R ISB*RR ExpObs] [DpAddr*W ISBdWR ExpObs]
# `[DpAddrs* ISBs*W]` are stronger than `Pos*W` as the former are a read followed by a write to the same location.
#-safe [DpAddrs* ISBs*W]
# `[DpAddr** ISB**W]` is stronger than `[DpAddr** Po**W]`
#-safe [DpAddr** ISB**W]
# `[DpAddrdW ISBsWR]` is stronger than `[DpAddrdW PosWR]`.
#-safe [DpAddrdW ISBsWR]
-safe [DpAddr*R Amo.Swp ISBdWR ExpObs]
-safe [DpAddr*R Amo.Cas ISBdWR ExpObs]
-safe [DpAddr*R Amo.StAdd ISBdWR ExpObs]
-safe [DpAddr*R Amo.LdAdd ISBdWR ExpObs]
-safe [DpAddr*R LxSx ISBdWR ExpObs]
# `[DpAddr*R rmw ISBsWR]` is stronger than `[DpAddr*R rmw PosWR]`
#-safe [DpAddrdR Amo.Swp ISBsWR] [DpAddrsR Amo.Swp ISBsWR]
#-safe [DpAddrdR Amo.Cas ISBsWR] [DpAddrsR Amo.Cas ISBsWR]
#-safe [DpAddrdR LxSx ISBsWR] [DpAddrsR LxSx ISBsWR]

# let IFB-ob = [Exp & R]; pick-addr-dep; [Exp & M]; po; [IFB]; po
-safe [DpAddrCsel ISB**R ExpObs]
# `[DpAddrCsels* ISBs*W]` are stronger than `Pos*W` as the former are a read followed by a write to the same location.
#-safe [DpAddrCsels* ISBs*W]
# `[DpAddrCsel** ISB**W]` is stronger than `[DpAddr** Po**W]`
#-safe [DpAddrCsel** ISB**W]
-safe [DpAddrCsel*R Amo.Swp ISB*WR ExpObs]
-safe [DpAddrCsel*R Amo.Cas ISB*WR ExpObs]
-safe [DpAddrCsel*R Amo.StAdd ISB*WR ExpObs]
-safe [DpAddrCsel*R Amo.LdAdd ISB*WR ExpObs]
-safe [DpAddrCsel*R LxSx ISB*WR ExpObs]

# let pob = pick-addr-dep; [Exp & W | HU | TLBI | DC.CVAU | IC]
-safe DpAddrCseldW
# `DpAddrCselsW` is stronger than `Pos*W`.
#-safe DpAddrCselsW
-safe [DpAddrCseldR Amo.Swp] [DpAddrCseldR Amo.Cas] [DpAddrCseldR Amo.StAdd] [DpAddrCseldR Amo.LdAdd] [DpAddrCseldR LxSx]

# let pob = pick-data-dep
-safe DpDataCseldW
# `DpDataCselsW` is stronger than `Pos*W`.
#-safe DpDataCselsW

# let pob = pick-ctrl-dep; [Exp & W | HU | TLBI | DC.CVAU | IC]
-safe DpCtrlCseldW
# `DpCtrlCselsW` is stronger than `Pos*W`.
#-safe DpCtrlCselsW
-safe [DpCtrlCseldR Amo.Swp] [DpCtrlCseldR Amo.Cas] [DpCtrlCseldR Amo.StAdd] [DpCtrlCseldR Amo.LdAdd] [DpCtrlCseldR LxSx]

# let pob = pick-addr-dep; [Exp & M]; po; [Exp & W | HU]
-safe [DpAddrCsel Pod*W] [DpAddrCseld* Pos*W]
# `[DpAddrCsels* Pos*W]` are stronger than `Pos*W` as the former are a read followed by a write to the same location.
#-safe [DpAddrCsels* Pos*W]
-safe [DpAddrCsel*R Amo.Swp Po*WW]
-safe [DpAddrCsel*R Amo.Cas Po*WW]
-safe [DpAddrCsel*R Amo.StAdd Po*WW]
-safe [DpAddrCsel*R Amo.LdAdd Po*WW]
-safe [DpAddrCsel*R LxSx Po*WW]
#
-safe [DpAddrCseld* Po**R Amo.Swp] [DpAddrCsels* Pod*R Amo.Swp]
-safe [DpAddrCseld* Po**R Amo.Cas] [DpAddrCsels* Pod*R Amo.Cas]
-safe [DpAddrCseld* Po**R Amo.StAdd] [DpAddrCsels* Pod*R Amo.StAdd]
-safe [DpAddrCseld* Po**R Amo.LdAdd] [DpAddrCsels* Pod*R Amo.LdAdd]
-safe [DpAddrCseld* Po**R LxSx] [DpAddrCsels* Pod*R LxSx]
# `[DpAddrCsels* Pos*R rmw]` is stronger than `Pos*W`.
-safe [DpAddrCseldR Amo.Swp Po*WR Amo.Swp] [DpAddrCseldR Amo.Swp Po*WR Amo.Cas] [DpAddrCseldR Amo.Swp Po*WR Amo.StAdd] [DpAddrCseldR Amo.Swp Po*WR Amo.LdAdd] [DpAddrCseldR Amo.Swp Po*WR LxSx]
-safe [DpAddrCselsR Amo.Swp PodWR Amo.Swp] [DpAddrCselsR Amo.Swp PodWR Amo.Cas] [DpAddrCselsR Amo.Swp PodWR Amo.StAdd] [DpAddrCselsR Amo.Swp PodWR Amo.LdAdd] [DpAddrCselsR Amo.Swp PodWR LxSx]
#
-safe [DpAddrCseldR Amo.Cas Po*WR Amo.Swp] [DpAddrCseldR Amo.Cas Po*WR Amo.Cas] [DpAddrCseldR Amo.Cas Po*WR Amo.StAdd] [DpAddrCseldR Amo.Cas Po*WR Amo.LdAdd] [DpAddrCseldR Amo.Cas Po*WR LxSx]
-safe [DpAddrCselsR Amo.Cas PodWR Amo.Swp] [DpAddrCselsR Amo.Cas PodWR Amo.Cas] [DpAddrCselsR Amo.Cas PodWR Amo.StAdd] [DpAddrCselsR Amo.Cas PodWR Amo.LdAdd] [DpAddrCselsR Amo.Cas PodWR LxSx]
#
-safe [DpAddrCseldR Amo.StAdd Po*WR Amo.Swp] [DpAddrCseldR Amo.StAdd Po*WR Amo.Cas] [DpAddrCseldR Amo.StAdd Po*WR Amo.StAdd] [DpAddrCseldR Amo.StAdd Po*WR Amo.LdAdd] [DpAddrCseldR Amo.StAdd Po*WR LxSx]
-safe [DpAddrCselsR Amo.StAdd PodWR Amo.Swp] [DpAddrCselsR Amo.StAdd PodWR Amo.Cas] [DpAddrCselsR Amo.StAdd PodWR Amo.StAdd] [DpAddrCselsR Amo.StAdd PodWR Amo.LdAdd] [DpAddrCselsR Amo.StAdd PodWR LxSx]
#
-safe [DpAddrCseldR Amo.LdAdd Po*WR Amo.Swp] [DpAddrCseldR Amo.LdAdd Po*WR Amo.Cas] [DpAddrCseldR Amo.LdAdd Po*WR Amo.StAdd] [DpAddrCseldR Amo.LdAdd Po*WR Amo.LdAdd] [DpAddrCseldR Amo.LdAdd Po*WR LxSx]
-safe [DpAddrCselsR Amo.LdAdd PodWR Amo.Swp] [DpAddrCselsR Amo.LdAdd PodWR Amo.Cas] [DpAddrCselsR Amo.LdAdd PodWR Amo.StAdd] [DpAddrCselsR Amo.LdAdd PodWR Amo.LdAdd] [DpAddrCselsR Amo.LdAdd PodWR LxSx]
#
-safe [DpAddrCseldR LxSx Po*WR Amo.Swp] [DpAddrCseldR LxSx Po*WR Amo.Cas] [DpAddrCseldR LxSx Po*WR Amo.StAdd] [DpAddrCseldR LxSx Po*WR Amo.LdAdd] [DpAddrCseldR LxSx Po*WR LxSx]
-safe [DpAddrCselsR LxSx PodWR Amo.Swp] [DpAddrCselsR LxSx PodWR Amo.Cas] [DpAddrCselsR LxSx PodWR Amo.StAdd] [DpAddrCselsR LxSx PodWR Amo.LdAdd] [DpAddrCselsR LxSx PodWR LxSx]
# `[DpAddrCselsR rmw PosWR rmw]` is stronger than `Pos*W`

### Fence

# let bob = [Exp & M | Imp & Tag & R]; po; [dmb.full]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
# DMB.ISH*** DMB.OSH*** in `-moreedges` in `diy7`; these two edges also satisfy `dmb.full`
-safe [ExpObs DMB.SYd** ExpObs] [ExpObs DMB.SYs*R ExpObs]
# `DMB.SYs*W` is stronger than `Pos*W`.
#-safe DMB.SYs*W

# let bob = [Exp & (R \ NoRet) | Imp & Tag & R]; po; [dmb.ld]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe [DMB.LDdR* ExpObs] [DMB.LDsRR ExpObs]
# `DMB.LDsRW` is stronger than `Pos*W`.
#-safe DMB.LDsRW
-safe [Amo.Swp DMB.LDdW*] [Amo.Cas DMB.LDdW*] [Amo.LdAdd DMB.LDdW*] [LxSx DMB.LDdW*]
-safe [Amo.Swp DMB.LDsWR] [Amo.Cas DMB.LDsWR] [Amo.LdAdd DMB.LDsWR] [LxSx DMB.LDsWR]
# `[DMB.LD*R* rmw]` can be combined by `diy`

# let bob = [Exp & W]; po; [dmb.st]; po; [Exp & W | MMU & FAULT]
-safe DMB.STdWW
# `DMB.STsWW` is stronger than `Pos*W`.
#-safe DMB.STsWW
-safe [DMB.STdWR Amo.Swp] [DMB.STdWR Amo.Cas] [DMB.STdWR Amo.StAdd] [DMB.STdWR Amo.LdAdd] [DMB.STdWR LxSx]

# let DSB-ob = [M | DC.CVAU | IC]; po; [dsb.full]; po; [~(Imp & TTD & M | Imp & Instr & R)]
# DSB.ISH*** DSB.OSH*** in `-moreedges` in `diy7`; these two edges also satisfy `dsb.full`
-safe [ExpObs DSB.SYd** ExpObs] [ExpObs DSB.SYs*R ExpObs]
# `DSB.SYs*W` is stronger than `Pos*W`.
#-safe DSB.SYs*W

# let DSB-ob = [(Exp & R) \ NoRet | Imp & Tag & R]; po; [dsb.ld]; po; [~(Imp & TTD & M | Imp & Instr & R)]
-safe [DSB.LDdR* ExpObs] [DSB.LDsRR ExpObs]
# `DSB.LDsRW` is stronger than `Pos*W`.
#-safe DSB.LDsRW
-safe [Amo.Swp DSB.LDdW*] [Amo.Cas DSB.LDdW*] [Amo.LdAdd DSB.LDdW*] [LxSx DSB.LDdW*]
-safe [Amo.Swp DSB.LDsWR] [Amo.Cas DSB.LDsWR] [Amo.LdAdd DSB.LDsWR] [LxSx DSB.LDsWR]

# let DSB-ob = [Exp & W]; po; [dsb.st]; po; [~(Imp & TTD & M | Imp & Instr & R)]
-safe [DSB.STdW* ExpObs] [DSB.STsWR ExpObs]
# `DSB.STsWW` is stronger than `Pos*W`.
#-safe DSB.STsWW

### Acquire-Release load and store
# let bob = [L]; po; [A]
-safe [L Po*WR A]
# `[(rmw) L Po*WR A (rmw)]` can be combined by `diy`

### Atomic operation
# Amo.Swp
# Amo.Cas
# Amo.LdAdd Amo.LdClr Amo.LdEor Amo.LdSet Amo.LdSmax Amo.LdSmin Amo.LdUmax Amo.LdUmin
# Amo.StAdd Amo.StClr Amo.StEor Amo.StSet
# There is a known problem for `Amo.Ld*` and `Amo.St*` relaxations,
# because commutative of those relaxations leads to value collision.
# For this reason, these relaxations are not included.

# let bob = [A | Q]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe [A PodR* ExpObs] [A PosRR ExpObs] [Q PodR* ExpObs] [Q PosRR ExpObs]
# `[A|Q PosRW]` is stronger than `PosRW`
#-safe [A PosRW] [Q PosRW]
# An acquire atomic operation followed by a memory access also matches above
-safe [A Amo.Swp PodW* ExpObs] [A Amo.Swp PosWR ExpObs]
-safe [A Amo.Cas PodW* ExpObs] [A Amo.Cas PosWR ExpObs]
-safe [A Amo.StAdd PodW* ExpObs] [A Amo.StAdd PosWR ExpObs]
-safe [A Amo.LdAdd PodW* ExpObs] [A Amo.LdAdd PosWR ExpObs]
-safe [A LxSx PodW* ExpObs] [A LxSx PosWR ExpObs]
-safe [Q LxSx PodW* ExpObs] [Q LxSx PosWR ExpObs]
#[A|Q rmw PosWW] is stronger than `Pos*W`
#-safe [A Amo.Swp PosWW] [A Amo.Cas PosWW] [A Amo.StAdd PosWW] [A Amo.LdAdd PosWW] [A LxSx PosWW] [Q LxSx PosWW]

# let bob = [Exp & M | Imp & Tag & R]; po; [L]
-safe [ExpObs Pod*W L]
# `[Pos*W L]` is stronger than `Pos*W`
# -safe [Pos*W L]
# A memory access followed by a release atomic operation also matches above.
-safe [ExpObs Pod*R Amo.Swp L]
-safe [ExpObs Pod*R Amo.Cas L]
-safe [ExpObs Pod*R Amo.StAdd L]
-safe [ExpObs Pod*R Amo.LdAdd L]
-safe [ExpObs Pod*R LxSx L]
# `[Pos*R rmw L]` is stronger than `Pos*W`
#-safe [Pos*R Amo.Swp L] [Pos*R Amo.Cas L] [Pos*R LxSx L]

# let aob = [Exp & M]; rmw; [Exp & M]
-safe LxSx Amo.Swp Amo.Cas

# le aob = [Exp & M]; rmw; lrs; [A | Q]
# let lrs = [W]; ((po & same-loc) & ~(intervening(W,(po & same-loc)))); [R]
-safe [LxSx PosWR A] [Amo.Swp PosWR A] [Amo.Cas PosWR A] [Amo.StAdd PosWR A] [Amo.LdAdd PosWR A]
-safe [LxSx PosWR Q] [Amo.Swp PosWR Q] [Amo.Cas PosWR Q] [Amo.StAdd PosWR Q] [Amo.LdAdd PosWR Q]

#let bob = [range([A];amo;[L])]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
# This relation cannot be directly mapped to a relaxation in `diy`,
# however, the individual `amo` relation is a suset of `rmw`, and is in `aob`,
# which means it is ordered.
# For this reason, here, we map
# `[A]; amo; [range([A];amo;[L])]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]`
-safe [A Amo.Swp L PodW* ExpObs] [A Amo.Swp L PosWR ExpObs]
-safe [A Amo.Cas L PodW* ExpObs] [A Amo.Cas L PosWR ExpObs]
-safe [A Amo.StAdd L PodW* ExpObs] [A Amo.StAdd L PosWR ExpObs]
-safe [A Amo.LdAdd L PodW* ExpObs] [A Amo.LdAdd L PosWR ExpObs]
-safe [A LxSx L PodW* ExpObs]    [A LxSx L PosWR ExpObs]
# `[A rmw L PosWW]` is stronger than `Pos*W`
#-safe [A Amo.Swp L PosWW] [A Amo.Cas L PosWW] [A LxSx L PosWW]

# let bob = [Exp & M | Imp & Tag & R]; po; [L] for `Pos*** A Amo.* L` Note that `A` is irrelevant
# then let [range([A];amo;[L])]; po; [Exp & M | Imp & Tag & R | MMU & FAULT] for `A Amo.* L Po***`
# This particular edges cannot be auto generated from other safe edges.
-safe [ExpObs Po**R A Amo.Swp L Po*W* ExpObs]
-safe [ExpObs Po**R A Amo.Cas L Po*W* ExpObs]
-safe [ExpObs Po**R A Amo.StAdd L Po*W* ExpObs]
-safe [ExpObs Po**R A Amo.LdAdd L Po*W* ExpObs]

### Hat
# `Hat` is an a read-read communication edge in `diy`, namely
# the end of a thread and the beginning of antoher thread are both read events
# and they will read the same value.
###
-safe [Hat Fre]
-safe [Hat DpAddrd*]
-safe [Hat DpDatadW]
-safe [Hat DpCtrldW ExpObs]
-safe [Hat DMB.SYdR* ExpObs]
-safe [Hat DSB.SYdR* ExpObs]
-safe [Hat DMB.LDdR* ExpObs]
-safe [Hat DSB.LDdR* ExpObs]
-safe [Hat A PodR* ExpObs] [Hat Q PodR* ExpObs]
-safe [Hat Amo.Swp] [Hat Amo.Cas] [Hat Amo.StAdd] [Hat Amo.LdAdd] [Hat LxSx]

### Note for consuming the generated tests
# When verifying all the generated tests are indeed forbidden via `herd7`,
# `LxSx` and its variants take more time for `herd7` to simulate due to loop.
# It recommends pass `-unroll 0` to `herd7` for better performance.
###
