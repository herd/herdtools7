#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
import argparse
import re
import sys
import subprocess

CHOICES_RF=["ConsRFna","Naive","Arf","Arfna"]
CHOICES_SC=["SCorig","SCnew"]
CHOICES_RS=["RSorig","RSnew"]
CHOICES_ST=["STorig","STnew"]

def main(argv=None):
  if argv is None:
    argv = sys.argv[1:]
  parser = argparse.ArgumentParser(
    description="Generate a model variant"
  )
  parser.add_argument("--RF", metavar="X", choices=CHOICES_RF, default=CHOICES_RF[0], help="choice of ConsRFna axiom: {0}".format(", ".join(CHOICES_RF)))
  parser.add_argument("--SC", metavar="X", choices=CHOICES_SC, default=CHOICES_SC[0], help="choice of SCReads axiom: {0}".format(", ".join(CHOICES_SC)))
  parser.add_argument("--RS", metavar="X", choices=CHOICES_RS, default=CHOICES_RS[0], help="choice of rseq definition: {0}".format(", ".join(CHOICES_RS)))
  parser.add_argument("--ST", metavar="X", choices=CHOICES_ST, default=CHOICES_ST[0], help="choice of sameThread definition: {0}".format(", ".join(CHOICES_ST)))
  parser.add_argument("--input", default="c11.cat-template", type=argparse.FileType('r'), help="Template cat file")
  parser.add_argument("--output", default="gen.cat", type=argparse.FileType('w'), help="Output cat file")
  parser.add_argument("--herd7", action="store_true", help="Use herd7 tool")
  parser.add_argument("--strip-comments", action="store_true", help="Remove single-line comments from template")
  parser.add_argument("--inline-libraries", action="store_true", help="Inline library includes")
  parser.add_argument('herdflags', nargs='*', help="Passed to herd command-line")
  args = parser.parse_args(argv)
  herdtool = 'herd'
  if args.herd7:
    if args.input.name == "c11.cat-template":
      args.input = open("c11.cat7-template", 'r')
    herdtool = 'herd7'
  if args.output.name == "stdout":
    args.output = sys.stdout
  choices = {
    "RF": args.RF,
    "SC": args.SC,
    "RS": args.RS,
    "ST": args.ST,
  }

  # Process each line of [lines] and print to [args.output]
  def process(lines):
    output = True
    for l in lines:
      if args.inline_libraries and l.startswith("include"):
        _unused,lib = l.split()
        lib = lib.replace('"', '')
        try: # open library and process lines
          with open(lib, "r") as libinput:
            # deliberately skip first two lines
            next(libinput)
            next(libinput)
            process(libinput)
        except IOError: # library not found
          print(l, file=args.output, end="")
        continue
      if l.startswith("#if") or l.startswith("#elif"):
        _unused1,key,_unused,val = l.split()
        assert key in choices.keys()
        output = val == choices[key]
        continue
      elif l.startswith("#endif"):
        output = True
        continue
      if args.strip_comments:
        if '(*' in l and '*)' in l:
          l = re.sub(r"\(\*[^\*]*\*\)", "", l)
          if l.strip() == "": continue
        if '(*' in l and not '*)' in l:
          assert False and "Multi-line comments can't be stripped"
      if output:
        print(l, file=args.output, end="")

  # Print header
  if not args.strip_comments:
    print("(* ({0}, {1}, {2}, {3}) *)".format(args.RF, args.SC, args.RS, args.ST), file=args.output)
    print("(* Autogenerated! Do not modify. *)", file=args.output)
  # Process top-level input
  process(args.input)
  if args.output != sys.stdout:
    print("model ({0}, {1}, {2}, {3}) generated in {4}".format(args.RF, args.SC, args.RS, args.ST, args.output.name))

  if args.output == sys.stdout or args.herdflags == []:
    return 0

  # check that herd exists in path
  args.output.close()
  cmd = [herdtool, '-conf', 'c11.cfg'] + args.herdflags
  print(" ".join(cmd))
  return subprocess.call(cmd)

if __name__ == '__main__':
  sys.exit(main())
